import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { getAnnotationMarksForPos } from '@atlaskit/editor-common/utils';
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { Selection } from '@atlaskit/editor-prosemirror/state';
import { safeInsert } from '@atlaskit/editor-prosemirror/utils';
import { fg } from '@atlaskit/platform-feature-flags';
export const createEmojiFragment = (doc, pos, emoji) => {
  const {
    id = '',
    fallback,
    shortName
  } = emoji;
  const annotationMarksForPos = getAnnotationMarksForPos(pos);
  const emojiNode = doc.type.schema.nodes.emoji.createChecked({
    shortName,
    id,
    text: fallback || shortName
  }, null, annotationMarksForPos);
  const space = doc.type.schema.text(' ', annotationMarksForPos);
  return Fragment.fromArray([emojiNode, space]);
};
export const insertEmoji = editorAnalyticsAPI => (emojiId, inputMethod) => {
  return ({
    tr
  }) => {
    const {
      doc,
      selection
    } = tr;
    const {
      emoji
    } = tr.doc.type.schema.nodes;
    if (emoji && emojiId) {
      let fragment;
      if (fg('editor_inline_comments_paste_insert_nodes')) {
        fragment = createEmojiFragment(doc, selection.$head, emojiId);
      } else {
        const node = emoji.createChecked({
          ...emojiId,
          text: emojiId.fallback || emojiId.shortName
        });
        const textNode = doc.type.schema.text(' ');
        fragment = Fragment.fromArray([node, textNode]);
      }
      const newTr = safeInsert(fragment)(tr);
      if (inputMethod) {
        editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 ? void 0 : editorAnalyticsAPI.attachAnalyticsEvent({
          action: ACTION.INSERTED,
          actionSubject: ACTION_SUBJECT.DOCUMENT,
          actionSubjectId: ACTION_SUBJECT_ID.EMOJI,
          attributes: {
            inputMethod
          },
          eventType: EVENT_TYPE.TRACK
        })(newTr);
      }
      newTr.setSelection(Selection.near(newTr.doc.resolve(selection.$from.pos + fragment.size)));
      return newTr;
    }
    return null;
  };
};