import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { isSSR } from '@atlaskit/editor-common/core-utils';
import { messages, EmojiSharedCssClassName, defaultEmojiHeight } from '@atlaskit/editor-common/emoji';
import { logException } from '@atlaskit/editor-common/monitoring';
import { DOMSerializer } from '@atlaskit/editor-prosemirror/model';
import { emojiToDom } from './emojiNodeSpec';
export var EmojiNodeView = /*#__PURE__*/function () {
  function EmojiNodeView(node, _ref) {
    var _this = this;
    var intl = _ref.intl,
      api = _ref.api;
    _classCallCheck(this, EmojiNodeView);
    _defineProperty(this, "destroy", function () {});
    // The pure `span` element will be used as a worse fallback only
    // if DOMSerializer.renderSpec() in constructor fails.
    _defineProperty(this, "dom", document.createElement('span'));
    this.node = node;
    this.intl = intl;
    try {
      var _api$emoji, _sharedState$currentS;
      var _DOMSerializer$render = DOMSerializer.renderSpec(document, emojiToDom(this.node)),
        dom = _DOMSerializer$render.dom;
      if (!(dom instanceof HTMLElement)) {
        // It's safe to throw error here because, the code is wrapped in try-catch.
        // However, it should never happen because `DOMSerializer.renderSpec()` should always return HTMLElement.
        throw new Error('DOMSerializer.renderSpec() did not return HTMLElement');
      }
      this.dom = dom;
      if (isSSR()) {
        // The provider doesn't work in SSR, and we don't want to render fallback in SSR,
        // that's why we don't need to continue node rendering.
        // In SSR we want to show a placeholder, that `emojiToDom()` returns.
        return;
      }

      // We use the `emojiProvider` from the shared state
      // because it supports the `emojiProvider` prop in the `ComposableEditor` options
      // as well as the `emojiProvider` in the `EmojiPlugin` options.
      var sharedState = api === null || api === void 0 || (_api$emoji = api.emoji) === null || _api$emoji === void 0 ? void 0 : _api$emoji.sharedState;
      if (!sharedState) {
        return;
      }
      var emojiProvider = (_sharedState$currentS = sharedState.currentState()) === null || _sharedState$currentS === void 0 ? void 0 : _sharedState$currentS.emojiProvider;
      if (emojiProvider) {
        void this.updateDom(emojiProvider);
      }
      var unsubscribe = sharedState.onChange(function (_ref2) {
        var nextSharedState = _ref2.nextSharedState;
        if (emojiProvider === (nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.emojiProvider)) {
          // Do not update if the provider is the same
          return;
        }
        emojiProvider = nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.emojiProvider;
        void _this.updateDom(emojiProvider);
      });
      this.destroy = function () {
        unsubscribe();
      };
    } catch (error) {
      EmojiNodeView.logError(error instanceof Error ? error : new Error('Unknown error on EmojiNodeView constructor'));
      this.renderFallback();
    }
  }
  return _createClass(EmojiNodeView, [{
    key: "updateDom",
    value: function () {
      var _updateDom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(emojiProvider) {
        var _this$node$attrs, shortName, id, fallback, emojiDescription, emojiRepresentation;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _this$node$attrs = this.node.attrs, shortName = _this$node$attrs.shortName, id = _this$node$attrs.id, fallback = _this$node$attrs.text;
              _context.next = 4;
              return emojiProvider === null || emojiProvider === void 0 ? void 0 : emojiProvider.fetchByEmojiId({
                id: id,
                shortName: shortName,
                fallback: fallback
              }, true);
            case 4:
              emojiDescription = _context.sent;
              if (emojiDescription) {
                _context.next = 9;
                break;
              }
              EmojiNodeView.logError(new Error('Emoji description is not loaded'));
              this.renderFallback();
              return _context.abrupt("return");
            case 9:
              emojiRepresentation = emojiDescription === null || emojiDescription === void 0 ? void 0 : emojiDescription.representation;
              if (EmojiNodeView.isEmojiRepresentationSupported(emojiRepresentation)) {
                _context.next = 14;
                break;
              }
              EmojiNodeView.logError(new Error('Emoji representation is not supported'));
              this.renderFallback();
              return _context.abrupt("return");
            case 14:
              this.renderEmoji(emojiDescription, emojiRepresentation);
              _context.next = 21;
              break;
            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](0);
              EmojiNodeView.logError(_context.t0 instanceof Error ? _context.t0 : new Error('Unknown error on EmojiNodeView updateDom'));
              this.renderFallback();
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 17]]);
      }));
      function updateDom(_x) {
        return _updateDom.apply(this, arguments);
      }
      return updateDom;
    }()
  }, {
    key: "cleanUpAndRenderCommonAttributes",
    value:
    // Pay attention, this method should be called only when the emoji provider returns
    // emoji data to prevent rendering empty emoji during loading.
    function cleanUpAndRenderCommonAttributes() {
      // Clean up the DOM before rendering the new emoji
      this.dom.innerHTML = '';
      this.dom.style.cssText = '';
      this.dom.classList.remove(EmojiSharedCssClassName.EMOJI_PLACEHOLDER);
      this.dom.removeAttribute('aria-label'); // The label is set in the renderEmoji method
      this.dom.removeAttribute('aria-busy');

      // Each vanilla JS node implementation should have this data attribute
      this.dom.setAttribute('data-prosemirror-node-view-type', 'vanilla');
    }
  }, {
    key: "renderFallback",
    value: function renderFallback() {
      this.cleanUpAndRenderCommonAttributes();
      var fallbackElement = document.createElement('span');
      fallbackElement.innerText = this.node.attrs.text || this.node.attrs.shortName;
      fallbackElement.setAttribute('data-testid', "fallback-emoji-".concat(this.node.attrs.shortName));
      fallbackElement.setAttribute('data-emoji-type', 'fallback');
      this.dom.appendChild(fallbackElement);
    }
  }, {
    key: "renderEmoji",
    value: function renderEmoji(description, representation) {
      this.cleanUpAndRenderCommonAttributes();
      var emojiType = 'sprite' in representation ? 'sprite' : 'image';

      // Add wrapper for the emoji
      var containerElement = document.createElement('span');
      containerElement.setAttribute('role', 'img');
      containerElement.classList.add(EmojiSharedCssClassName.EMOJI_CONTAINER);
      containerElement.setAttribute('data-testid', "".concat(emojiType, "-emoji-").concat(description.shortName));
      containerElement.setAttribute('data-emoji-type', emojiType);
      containerElement.setAttribute('aria-label', "".concat(this.intl.formatMessage(messages.emojiNodeLabel), " ").concat(description.shortName));
      var emojiElement = 'sprite' in representation ? this.createSpriteEmojiElement(representation) : this.createImageEmojiElement(description, representation);
      containerElement.appendChild(emojiElement);
      this.dom.appendChild(containerElement);
    }
  }, {
    key: "createSpriteEmojiElement",
    value: function createSpriteEmojiElement(representation) {
      var spriteElement = document.createElement('span');
      spriteElement.classList.add(EmojiSharedCssClassName.EMOJI_SPRITE);
      var sprite = representation.sprite;
      var xPositionInPercent = 100 / (sprite.column - 1) * representation.xIndex;
      var yPositionInPercent = 100 / (sprite.row - 1) * representation.yIndex;
      spriteElement.style.backgroundImage = "url(".concat(sprite.url, ")");
      spriteElement.style.backgroundPosition = "".concat(xPositionInPercent, "% ").concat(yPositionInPercent, "%");
      spriteElement.style.backgroundSize = "".concat(sprite.column * 100, "% ").concat(sprite.row * 100, "%");
      spriteElement.style.width = "".concat(defaultEmojiHeight, "px");
      spriteElement.style.minWidth = "".concat(defaultEmojiHeight, "px");
      spriteElement.style.height = "".concat(defaultEmojiHeight, "px");
      spriteElement.style.minHeight = "".concat(defaultEmojiHeight, "px");
      return spriteElement;
    }
  }, {
    key: "createImageEmojiElement",
    value: function createImageEmojiElement(emojiDescription, representation) {
      var imageElement = document.createElement('img');
      imageElement.classList.add(EmojiSharedCssClassName.EMOJI_IMAGE);
      imageElement.src = 'imagePath' in representation ? representation.imagePath : representation.mediaPath;
      imageElement.loading = 'lazy';
      imageElement.alt = emojiDescription.name || emojiDescription.shortName;
      if (representation.width && representation.height) {
        imageElement.height = defaultEmojiHeight;
        // Because img.width is round to the nearest integer.
        imageElement.setAttribute('width', "".concat(defaultEmojiHeight / representation.height * representation.width));
      }
      return imageElement;
    }
  }], [{
    key: "logError",
    value: function logError(error) {
      void logException(error, {
        location: 'editor-plugin-emoji/EmojiNodeView'
      });
    }
  }, {
    key: "isEmojiRepresentationSupported",
    value: function isEmojiRepresentationSupported(representation) {
      return !!representation && ('sprite' in representation || 'imagePath' in representation || 'mediaPath' in representation);
    }
  }]);
}();