"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapping = mapping;
exports.onSelectionChanged = onSelectionChanged;
exports.reducer = reducer;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _state = require("@atlaskit/editor-prosemirror/state");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function reducer(pluginState, meta) {
  // If the same nodeview is clicked twice, calendar should close
  if (meta.showDatePickerAt === pluginState.showDatePickerAt) {
    return _objectSpread(_objectSpread({}, pluginState), {}, {
      showDatePickerAt: null
    });
  }
  var showDatePickerAt = pluginState.showDatePickerAt,
    isNew = pluginState.isNew;
  var showDatePickerAtMeta = meta.showDatePickerAt;
  // If date picker position has changed, it is no longer new
  if (showDatePickerAt && showDatePickerAtMeta && showDatePickerAt !== showDatePickerAtMeta && isNew) {
    return _objectSpread(_objectSpread(_objectSpread({}, pluginState), meta), {}, {
      isNew: false
    });
  }
  return _objectSpread(_objectSpread({}, pluginState), meta);
}
function mapping(tr, pluginState) {
  if (!pluginState.showDatePickerAt) {
    return pluginState;
  }
  var _tr$mapping$mapResult = tr.mapping.mapResult(pluginState.showDatePickerAt),
    pos = _tr$mapping$mapResult.pos;
  return {
    showDatePickerAt: pos,
    isNew: pluginState.isNew,
    isDateEmpty: pluginState.isDateEmpty,
    focusDateInput: pluginState.focusDateInput
  };
}
function onSelectionChanged(tr, pluginState) {
  if (tr.docChanged && isDateNodeSelection(tr.selection)) {
    return _objectSpread(_objectSpread({}, pluginState), {}, {
      isQuickInsertAction: false,
      showDatePickerAt: tr.selection.from
    });
  } else if (!isDateNodeSelection(tr.selection) && !pluginState.isQuickInsertAction) {
    if (pluginState.showDatePickerAt) {
      return {
        showDatePickerAt: null,
        isNew: false,
        isDateEmpty: false,
        focusDateInput: false
      };
    }
    return pluginState;
  }
  return pluginState;
}
var isDateNodeSelection = function isDateNodeSelection(selection) {
  if (selection instanceof _state.NodeSelection) {
    var nodeTypeName = selection.node.type.name;
    return nodeTypeName === 'date';
  }
  return false;
};