import React from 'react';
import { textColor } from '@atlaskit/adf-schema';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { changeColor } from './pm-plugins/commands/change-color';
import { createPlugin, pluginKey as textColorPluginKey } from './pm-plugins/main';
import { FloatingToolbarComponent } from './ui/FloatingToolbarComponent';
import { PrimaryToolbarComponent } from './ui/PrimaryToolbarComponent';
const pluginConfig = textColorConfig => {
  if (!textColorConfig || typeof textColorConfig === 'boolean') {
    return undefined;
  }
  return textColorConfig;
};
export const textColorPlugin = ({
  config: textColorConfig,
  api
}) => {
  var _api$primaryToolbar;
  const primaryToolbarComponent = ({
    editorView,
    popupsMountPoint,
    popupsBoundariesElement,
    popupsScrollableElement,
    isToolbarReducedSpacing,
    dispatchAnalyticsEvent,
    disabled
  }) => {
    return /*#__PURE__*/React.createElement(PrimaryToolbarComponent, {
      isReducedSpacing: isToolbarReducedSpacing,
      editorView: editorView,
      popupsMountPoint: popupsMountPoint,
      popupsBoundariesElement: popupsBoundariesElement,
      popupsScrollableElement: popupsScrollableElement,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      disabled: disabled,
      api: api
    });
  };
  api === null || api === void 0 ? void 0 : (_api$primaryToolbar = api.primaryToolbar) === null || _api$primaryToolbar === void 0 ? void 0 : _api$primaryToolbar.actions.registerComponent({
    name: 'textColor',
    component: primaryToolbarComponent
  });
  return {
    name: 'textColor',
    marks() {
      return [{
        name: 'textColor',
        mark: textColor
      }];
    },
    pmPlugins() {
      return [{
        name: 'textColor',
        plugin: ({
          dispatch
        }) => createPlugin(dispatch, pluginConfig(textColorConfig))
      }];
    },
    getSharedState(editorState) {
      if (!editorState) {
        return undefined;
      }
      return textColorPluginKey.getState(editorState);
    },
    actions: {
      changeColor: (color, inputMethod) => {
        var _api$analytics;
        return changeColor(color, api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions, inputMethod);
      }
    },
    pluginsOptions: {
      selectionToolbar: () => {
        var _api$selectionToolbar, _api$selectionToolbar2, _api$selectionToolbar3;
        if ((api === null || api === void 0 ? void 0 : (_api$selectionToolbar = api.selectionToolbar) === null || _api$selectionToolbar === void 0 ? void 0 : (_api$selectionToolbar2 = _api$selectionToolbar.sharedState) === null || _api$selectionToolbar2 === void 0 ? void 0 : (_api$selectionToolbar3 = _api$selectionToolbar2.currentState()) === null || _api$selectionToolbar3 === void 0 ? void 0 : _api$selectionToolbar3.toolbarDocking) === 'none' && editorExperiment('platform_editor_controls', 'variant1', {
          exposure: true
        })) {
          const toolbarCustom = {
            type: 'custom',
            render: (view, _idx, dispatchAnalyticsEvent) => {
              if (!view) {
                return;
              }
              return /*#__PURE__*/React.createElement(FloatingToolbarComponent, {
                editorView: view,
                dispatchAnalyticsEvent: dispatchAnalyticsEvent,
                api: api
              });
            },
            fallback: []
          };
          return {
            isToolbarAbove: true,
            items: [toolbarCustom],
            rank: 6,
            pluginName: 'textColor'
          };
        } else {
          return undefined;
        }
      }
    },
    primaryToolbarComponent: !(api !== null && api !== void 0 && api.primaryToolbar) ? primaryToolbarComponent : undefined
  };
};