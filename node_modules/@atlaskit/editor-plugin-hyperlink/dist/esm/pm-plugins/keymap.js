import { getLinkMatch } from '@atlaskit/adf-schema';
import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { addLinkMetadata } from '@atlaskit/editor-common/card';
import { addLink, bindKeymapWithCommand, bindKeymapWithEditorCommand, enter, escape, insertNewLine } from '@atlaskit/editor-common/keymaps';
import { findFilepaths, getLinkCreationAnalyticsEvent, isLinkInMatches, shouldAutoLinkifyMatch } from '@atlaskit/editor-common/utils';
import { keymap } from '@atlaskit/editor-prosemirror/keymap';
import { hideLinkToolbar, showLinkToolbar } from '../editor-commands/commands';
import { stateKey } from '../pm-plugins/main';
import { toolbarKey } from './toolbar-buttons';
export function createKeymapPlugin(editorAnalyticsApi) {
  var list = {};
  bindKeymapWithEditorCommand(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  addLink.common, showLinkToolbar(INPUT_METHOD.SHORTCUT, editorAnalyticsApi), list);

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  bindKeymapWithCommand(enter.common, mayConvertLastWordToHyperlink(editorAnalyticsApi), list);
  bindKeymapWithCommand(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  insertNewLine.common, mayConvertLastWordToHyperlink(editorAnalyticsApi), list);
  bindKeymapWithCommand(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  escape.common, function (state, dispatch, view) {
    var hyperlinkPlugin = stateKey.getState(state);
    if (hyperlinkPlugin.activeLinkMark) {
      hideLinkToolbar()(state, dispatch);
      if (view) {
        view.focus();
      }
      return false;
    }
    return false;
  }, list);
  return keymap(list);
}

/**
 * Convert the last word before the selection to a hyperlink if it's a valid URL with a tld we want to linkify
 */
var mayConvertLastWordToHyperlink = function mayConvertLastWordToHyperlink(editorAnalyticsApi) {
  return function (state, dispatch) {
    var _toolbarKey$getState$, _toolbarKey$getState;
    var skipAnalytics = (_toolbarKey$getState$ = (_toolbarKey$getState = toolbarKey.getState(state)) === null || _toolbarKey$getState === void 0 ? void 0 : _toolbarKey$getState.skipAnalytics) !== null && _toolbarKey$getState$ !== void 0 ? _toolbarKey$getState$ : false;
    var nodeBefore = state.selection.$from.nodeBefore;
    if (!nodeBefore || !nodeBefore.isText || !nodeBefore.text) {
      return false;
    }

    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var words = nodeBefore.text.split(' ');
    var lastWord = words[words.length - 1];
    var match = getLinkMatch(lastWord);
    if (match) {
      if (!shouldAutoLinkifyMatch(match)) {
        return false;
      }
      var hyperlinkedText = match.raw;
      var start = state.selection.$from.pos - hyperlinkedText.length;
      var end = state.selection.$from.pos;
      if (state.doc.rangeHasMark(start, end, state.schema.marks.link)) {
        return false;
      }
      var url = match.url;
      var markType = state.schema.mark('link', {
        href: url
      });
      var filepaths = findFilepaths(nodeBefore.text, start - (nodeBefore.text.length - hyperlinkedText.length) // The position referenced by 'start' is relative to the start of the document, findFilepaths deals with index in a node only.
      );
      if (isLinkInMatches(start, filepaths)) {
        return false;
      }
      var tr = state.tr.addMark(start, end, markType);
      if (dispatch) {
        addLinkMetadata(state.selection, tr, {
          inputMethod: INPUT_METHOD.AUTO_DETECT
        });
        if (skipAnalytics) {
          dispatch(tr);
        } else {
          editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent(getLinkCreationAnalyticsEvent(INPUT_METHOD.AUTO_DETECT, url))(tr);
          dispatch(tr);
        }
      }
    }
    return false;
  };
};
export default createKeymapPlugin;