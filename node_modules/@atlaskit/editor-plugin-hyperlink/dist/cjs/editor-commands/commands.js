"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editInsertedLink = editInsertedLink;
exports.hideLinkToolbar = hideLinkToolbar;
exports.hideLinkToolbarSetMeta = void 0;
exports.insertLink = insertLink;
exports.onEscapeCallback = exports.onClickAwayCallback = exports.insertLinkWithAnalytics = void 0;
exports.removeLink = removeLink;
exports.removeLinkEditorCommand = removeLinkEditorCommand;
exports.setLinkHref = setLinkHref;
exports.showLinkToolbar = showLinkToolbar;
exports.updateLink = updateLink;
exports.updateLinkEditorCommand = updateLinkEditorCommand;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _card = require("@atlaskit/editor-common/card");
var _editorAnalytics = require("@atlaskit/editor-common/editor-analytics");
var _link = require("@atlaskit/editor-common/link");
var _preset = require("@atlaskit/editor-common/preset");
var _utils = require("@atlaskit/editor-common/utils");
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _main = require("../pm-plugins/main");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function setLinkHrefEditorCommand(href, pos, editorAnalyticsApi, to, isTabPressed) {
  return function (_ref) {
    var tr = _ref.tr;
    if (!(0, _link.isTextAtPos)(pos)({
      tr: tr
    })) {
      return null;
    }
    var $pos = tr.doc.resolve(pos);
    var node = tr.doc.nodeAt(pos);
    var linkMark = tr.doc.type.schema.marks.link;
    var mark = linkMark.isInSet(node.marks);
    var url = (0, _utils.normalizeUrl)(href);
    if (mark && mark.attrs.href === url) {
      return null;
    }
    var rightBound = to && pos !== to ? to : pos - $pos.textOffset + node.nodeSize;
    tr.removeMark(pos, rightBound, linkMark);
    if (href.trim()) {
      tr.addMark(pos, rightBound, linkMark.create(_objectSpread(_objectSpread({}, mark && mark.attrs || {}), {}, {
        href: url
      })));
    } else {
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent((0, _analytics.unlinkPayload)(_analytics.ACTION_SUBJECT_ID.HYPERLINK))(tr);
    }
    if (!isTabPressed) {
      tr.setMeta(_main.stateKey, {
        type: _link.LinkAction.HIDE_TOOLBAR
      });
    }
    return tr;
  };
}
function setLinkHref(href, pos, editorAnalyticsApi, to, isTabPressed) {
  return (0, _preset.editorCommandToPMCommand)(setLinkHrefEditorCommand(href, pos, editorAnalyticsApi, to, isTabPressed));
}
function updateLinkEditorCommand(href, text, pos, to) {
  return function (_ref2) {
    var tr = _ref2.tr;
    var $pos = tr.doc.resolve(pos);
    var node = tr.doc.nodeAt(pos);
    if (!node) {
      return null;
    }
    var url = (0, _utils.normalizeUrl)(href);
    var mark = tr.doc.type.schema.marks.link.isInSet(node.marks);
    var linkMark = tr.doc.type.schema.marks.link;
    var rightBound = to && pos !== to ? to : pos - $pos.textOffset + node.nodeSize;
    if (!url && text) {
      tr.removeMark(pos, rightBound, linkMark);
      tr.insertText(text, pos, rightBound);
    } else if (!url) {
      return null;
    } else {
      tr.insertText(text, pos, rightBound);
      // Casting to LinkAttributes to prevent wrong attributes been passed (Example ED-7951)
      var linkAttrs = _objectSpread(_objectSpread({}, mark && mark.attrs || {}), {}, {
        href: url
      });
      tr.addMark(pos, pos + text.length, linkMark.create(linkAttrs));
      tr.setMeta(_main.stateKey, {
        type: _link.LinkAction.HIDE_TOOLBAR
      });
    }
    return tr;
  };
}
function updateLink(href, text, pos, to) {
  return (0, _preset.editorCommandToPMCommand)(updateLinkEditorCommand(href, text, pos, to));
}
function insertLink(from, to, incomingHref, incomingTitle, displayText, source, sourceEvent) {
  var appearance = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'inline';
  var cardApiActions = arguments.length > 8 ? arguments[8] : undefined;
  return function (state, dispatch) {
    var link = state.schema.marks.link;
    var tr = state.tr;
    if (incomingHref.trim()) {
      var _stateKey$getState;
      var normalizedUrl = (0, _utils.normalizeUrl)(incomingHref);
      // NB: in this context, `currentText` represents text which has been
      // highlighted in the Editor, upon which a link is is being added.
      var currentText = (_stateKey$getState = _main.stateKey.getState(state)) === null || _stateKey$getState === void 0 ? void 0 : _stateKey$getState.activeText;
      var markEnd = to;
      var _text = displayText || incomingTitle || incomingHref;
      if (!displayText || displayText !== currentText) {
        tr.insertText(_text, from, to);
        if ((0, _platformFeatureFlags.fg)('platform_editor_update_insert_link_mark_end_pos')) {
          // new block created to wrap the link
          if (tr.mapping.map(from) === from + _text.length + 2) {
            // +1 is for the block's opening tag
            markEnd = from + _text.length + 1;
          } else {
            markEnd = from + _text.length;
          }
        } else {
          if (!(0, _link.isTextAtPos)(from)(state)) {
            markEnd = from + _text.length + 1;
          } else {
            markEnd = from + _text.length;
          }
        }
      }
      tr.addMark(from, markEnd, link.create({
        href: normalizedUrl
      }));
      tr.setSelection(_state.Selection.near(tr.doc.resolve(markEnd)));
      if (!displayText || displayText === incomingHref) {
        var queueCardsFromChangedTr = cardApiActions === null || cardApiActions === void 0 ? void 0 : cardApiActions.queueCardsFromChangedTr;
        if (queueCardsFromChangedTr) {
          queueCardsFromChangedTr === null || queueCardsFromChangedTr === void 0 || queueCardsFromChangedTr(state, tr,
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          source, _analytics.ACTION.INSERTED, false, sourceEvent, appearance);
        } else {
          (0, _card.addLinkMetadata)(state.selection, tr, {
            action: _analytics.ACTION.INSERTED,
            inputMethod: source,
            sourceEvent: sourceEvent
          });
        }
      } else {
        /**
         * Add link metadata because queue cards would have otherwise handled this for us
         */
        (0, _card.addLinkMetadata)(state.selection, tr, {
          action: _analytics.ACTION.INSERTED,
          inputMethod: source,
          sourceEvent: sourceEvent
        });
      }
      tr.setMeta(_main.stateKey, {
        type: _link.LinkAction.HIDE_TOOLBAR
      });
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    tr.setMeta(_main.stateKey, {
      type: _link.LinkAction.HIDE_TOOLBAR
    });
    if (dispatch) {
      dispatch(tr);
    }
    return false;
  };
}
var insertLinkWithAnalytics = exports.insertLinkWithAnalytics = function insertLinkWithAnalytics(inputMethod, from, to, href, cardActions, editorAnalyticsApi, title, displayText) {
  var cardsAvailable = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var sourceEvent = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : undefined;
  var appearance = arguments.length > 10 ? arguments[10] : undefined;
  // If smart cards are available, we send analytics for hyperlinks when a smart link is rejected.
  if (cardsAvailable && !title && !displayText) {
    return insertLink(from, to, href, title, displayText, inputMethod, sourceEvent, appearance, cardActions);
  }
  return (0, _editorAnalytics.withAnalytics)(editorAnalyticsApi, (0, _utils.getLinkCreationAnalyticsEvent)(inputMethod, href))(insertLink(from, to, href, title, displayText, inputMethod, sourceEvent, appearance, cardActions));
};
function removeLink(pos, editorAnalyticsApi) {
  return (0, _card.commandWithMetadata)(setLinkHref('', pos, editorAnalyticsApi), {
    action: _analytics.ACTION.UNLINK
  });
}
function removeLinkEditorCommand(pos, editorAnalyticsApi) {
  return function (_ref3) {
    var tr = _ref3.tr;
    setLinkHrefEditorCommand('', pos, editorAnalyticsApi)({
      tr: tr
    });
    (0, _card.addLinkMetadata)(tr.selection, tr, {
      action: _analytics.ACTION.UNLINK
    });
    return tr;
  };
}
function editInsertedLink(editorAnalyticsApi) {
  return function (state, dispatch) {
    if (dispatch) {
      var _tr = state.tr;
      _tr.setMeta(_main.stateKey, {
        type: _link.LinkAction.EDIT_INSERTED_TOOLBAR,
        inputMethod: _analytics.INPUT_METHOD.FLOATING_TB
      });
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent((0, _analytics.buildEditLinkPayload)(_analytics.ACTION_SUBJECT_ID.HYPERLINK))(_tr);
      dispatch(_tr);
    }
    return true;
  };
}
function showLinkToolbar(inputMethod, editorAnalyticsApi) {
  return function (_ref4) {
    var tr = _ref4.tr;
    var newTr = tr.setMeta(_main.stateKey, {
      type: _link.LinkAction.SHOW_INSERT_TOOLBAR,
      inputMethod: inputMethod
    });
    editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent({
      action: _analytics.ACTION.INVOKED,
      actionSubject: _analytics.ACTION_SUBJECT.TYPEAHEAD,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.TYPEAHEAD_LINK,
      attributes: {
        inputMethod: inputMethod
      },
      eventType: _analytics.EVENT_TYPE.UI
    })(newTr);
    return newTr;
  };
}
function hideLinkToolbar() {
  return function (state, dispatch) {
    if (dispatch) {
      dispatch(hideLinkToolbarSetMeta(state.tr));
    }
    return true;
  };
}
var hideLinkToolbarSetMeta = exports.hideLinkToolbarSetMeta = function hideLinkToolbarSetMeta(tr) {
  return tr.setMeta(_main.stateKey, {
    type: _link.LinkAction.HIDE_TOOLBAR
  });
};
var onEscapeCallback = exports.onEscapeCallback = function onEscapeCallback(cardActions) {
  return function (state, dispatch) {
    var _cardActions$hideLink;
    var tr = state.tr;
    hideLinkToolbarSetMeta(tr);
    cardActions === null || cardActions === void 0 || (_cardActions$hideLink = cardActions.hideLinkToolbar) === null || _cardActions$hideLink === void 0 || _cardActions$hideLink.call(cardActions, tr);
    if (dispatch) {
      dispatch(tr);
      return true;
    }
    return false;
  };
};
var onClickAwayCallback = exports.onClickAwayCallback = function onClickAwayCallback(state, dispatch) {
  if (dispatch) {
    hideLinkToolbar()(state, dispatch);
    return true;
  }
  return false;
};