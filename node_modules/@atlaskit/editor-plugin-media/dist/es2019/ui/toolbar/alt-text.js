import React from 'react';
import { addAltText, ToolTipContent } from '@atlaskit/editor-common/keymaps';
import { altTextMessages as messages } from '@atlaskit/editor-common/media';
import { MediaSharedClassNames as ClassNames } from '@atlaskit/editor-common/styles';
import { RECENT_SEARCH_WIDTH_IN_PX as CONTAINER_WIDTH_IN_PX } from '@atlaskit/editor-common/ui';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import TextIcon from '@atlaskit/icon/core/text';
import { openMediaAltTextMenu } from '../../pm-plugins/alt-text/commands';
import AltTextEdit from '../../pm-plugins/alt-text/ui/AltTextEdit';
import { isImage } from '../../pm-plugins/utils/is-type';
import { getMediaSingleOrInlineNodeFromSelection } from '../../pm-plugins/utils/media-common';
import { getNodeType } from './commands';
const testId = 'alt-text-edit-button';
export const altTextButton = (intl, state, editorAnalyticsAPI) => {
  const mediaNode = getMediaSingleOrInlineNodeFromSelection(state);
  const message = mediaNode && mediaNode.attrs.alt ? messages.editAltText : messages.altText;
  const title = intl.formatMessage(message);
  return {
    title,
    id: 'editor.media.altText',
    type: 'button',
    onClick: openMediaAltTextMenu(editorAnalyticsAPI),
    showTitle: true,
    testId,
    tooltipContent: /*#__PURE__*/React.createElement(ToolTipContent, {
      description: title,
      keymap: addAltText
    })
  };
};
const altTextEditComponent = options => {
  return {
    type: 'custom',
    fallback: [],
    disableArrowNavigation: true,
    render: (view, idx) => {
      if (!view) {
        return null;
      }
      const state = view.state;
      const mediaNode = getMediaSingleOrInlineNodeFromSelection(state);
      if (!mediaNode) {
        return null;
      }
      /** Focus should move to the 'Alt text' button when the toolbar closes
       * and not close the floating toolbar.
       */
      const handleEsc = () => {
        var _options$forceFocusSe;
        const {
          state: {
            tr
          },
          dispatch
        } = view;
        const newTr = options === null || options === void 0 ? void 0 : (_options$forceFocusSe = options.forceFocusSelector) === null || _options$forceFocusSe === void 0 ? void 0 : _options$forceFocusSe.call(options, `[data-testid="${testId}"]`)(tr);
        if (newTr) {
          dispatch(newTr);
        }
      };
      const type = getNodeType(state);
      return /*#__PURE__*/React.createElement(AltTextEdit, {
        view: view,
        key: idx,
        nodeType: type,
        mediaType: mediaNode.attrs.type,
        value: mediaNode.attrs.alt,
        altTextValidator: options && options.altTextValidator,
        onEscape: handleEsc
      });
    }
  };
};
export const getAltTextToolbar = (toolbarBaseConfig, options) => {
  return {
    ...toolbarBaseConfig,
    width: CONTAINER_WIDTH_IN_PX,
    className: ClassNames.FLOATING_TOOLBAR_COMPONENT,
    items: [altTextEditComponent(options)]
  };
};
export const getAltTextDropdownOption = (state, formatMessage, allowAltTextOnImages, selectedNodeType, editorAnalyticsAPI) => {
  const {
    mediaSingle,
    mediaInline
  } = state.schema.nodes;
  const mediaType = state.selection instanceof NodeSelection && state.selection.node.attrs.type;
  if (allowAltTextOnImages && (selectedNodeType === mediaSingle || selectedNodeType === mediaInline && isImage(mediaType))) {
    return [{
      title: formatMessage(messages.addAltText),
      onClick: openMediaAltTextMenu(editorAnalyticsAPI),
      icon: /*#__PURE__*/React.createElement(TextIcon, {
        label: ""
      }),
      testId: 'media-alt-text-dropdown-option'
    }];
  }
  return [];
};