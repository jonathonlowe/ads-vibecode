import React, { useCallback, useMemo, useState } from 'react';
import { injectIntl } from 'react-intl-next';
import { VIEW_METHOD } from '@atlaskit/editor-common/analytics';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { CommentBadge as CommentBadgeComponent, CommentBadgeNext } from '@atlaskit/editor-common/media-single';
const CommentBadgeWrapper = ({
  api,
  mediaNode,
  view,
  getPos,
  intl,
  isDrafting,
  badgeOffsetRight
}) => {
  const [entered, setEntered] = useState(false);
  const {
    annotationState
  } = useSharedPluginState(api, ['annotation']);
  const {
    state: {
      schema: {
        nodes: {
          media
        },
        marks: {
          annotation
        }
      }
    },
    state,
    dispatch
  } = view;
  const status = useMemo(() => {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(annotation => !!mediaNode.marks.find(mark => mark.attrs.id === annotation.id)) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  const onClick = useCallback(() => {
    if (api.annotation && mediaNode) {
      const {
        showCommentForBlockNode
      } = api.annotation.actions;
      showCommentForBlockNode(mediaNode, VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  const pos = getPos();
  const hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(maybeAnnotation => maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id]);
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }

  /**
   * After performing certain operations like drag and drop,
   * the position may momentarily shift. It will NOT always be an HTML element;
   * it could also be plain text.
   */
  const maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  const mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/React.createElement(CommentBadgeComponent, {
    badgeOffsetRight: badgeOffsetRight,
    width: mediaNode.attrs.width,
    height: mediaNode.attrs.height,
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    intl: intl,
    status: entered ? 'entered' : status,
    onMouseEnter: () => setEntered(true),
    onMouseLeave: () => setEntered(false)
  });
};
export const CommentBadge = injectIntl(CommentBadgeWrapper);

/**
 * Remove CommentBadgeWrapper component above
 * and rename CommentBadgeNextWrapper to CommentBadgeWrapper
 * when clean up platform_editor_add_media_from_url_rollout feature flag
 */

export const CommentBadgeNextWrapper = ({
  api,
  mediaNode,
  view,
  getPos,
  isDrafting
}) => {
  const [entered, setEntered] = useState(false);
  const {
    annotationState
  } = useSharedPluginState(api, ['annotation']);
  const {
    state: {
      schema: {
        nodes: {
          media
        },
        marks: {
          annotation
        }
      }
    },
    state,
    dispatch
  } = view;
  const status = useMemo(() => {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(annotation => !!mediaNode.marks.find(mark => mark.attrs.id === annotation.id)) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  const onClick = useCallback(() => {
    if (api.annotation && mediaNode) {
      const {
        showCommentForBlockNode
      } = api.annotation.actions;
      showCommentForBlockNode(mediaNode, VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  const pos = getPos();
  const hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(maybeAnnotation => maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id]);
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }
  const maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  const mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/React.createElement(CommentBadgeNext, {
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    status: entered ? 'entered' : status,
    onMouseEnter: () => setEntered(true),
    onMouseLeave: () => setEntered(false)
  });
};