/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { useCallback } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { pixelEntryMessages as messages } from '@atlaskit/editor-common/media';
import { calcMinWidth, DEFAULT_IMAGE_HEIGHT, DEFAULT_IMAGE_WIDTH } from '@atlaskit/editor-common/media-single';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { hasParentNode } from '@atlaskit/editor-prosemirror/utils';
import { akEditorDefaultLayoutWidth, akEditorFullWidthLayoutWidth } from '@atlaskit/editor-shared-styles';
import { Text } from '@atlaskit/primitives/compiled';
import { updateMediaSingleWidthTr } from '../../../ui/toolbar/commands';
import { getPixelWidthOfElement, calcNewLayout } from '../../../ui/toolbar/utils';
import { isVideo } from '../../utils/media-single';
import { closePixelEditorAndSave } from '../commands';
import { PixelEntryComponent } from './pixel-entry';
import { pixelSizingFullWidthLabelStyles } from './styles';
export const PixelEntry = ({
  editorView,
  selectedMediaSingleNode,
  pluginInjectionApi,
  intl,
  pluginState,
  hoverDecoration,
  isEditorFullWidthEnabled
}) => {
  var _pluginInjectionApi$w, _pluginInjectionApi$m, _pluginInjectionApi$m2;
  const {
    state,
    dispatch
  } = editorView;
  const {
    mediaSingle
  } = state.schema.nodes;
  const contentWidth = (pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$w = pluginInjectionApi.width.sharedState.currentState()) === null || _pluginInjectionApi$w === void 0 ? void 0 : _pluginInjectionApi$w.lineLength) || akEditorDefaultLayoutWidth;
  const {
    width: mediaSingleWidth,
    widthType,
    layout
  } = selectedMediaSingleNode.node.attrs;

  // hasParentNode will return falsey value if selection depth === 0
  const isNested = hasParentNode(n => n.type !== state.schema.nodes.doc)(state.selection);
  const updateNodeWithTr = useCallback((width, validation) => {
    var _pluginInjectionApi$a;
    const newLayout = calcNewLayout(width, layout, contentWidth, isEditorFullWidthEnabled, isNested);
    return updateMediaSingleWidthTr(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$a = pluginInjectionApi.analytics) === null || _pluginInjectionApi$a === void 0 ? void 0 : _pluginInjectionApi$a.actions, state, width, validation, 'floatingToolBar', newLayout);
  }, [layout, contentWidth, isEditorFullWidthEnabled, isNested, state, pluginInjectionApi]);
  const selectedMediaNode = selectedMediaSingleNode.node.content.firstChild;
  if (!selectedMediaNode) {
    return null;
  }
  const {
    width: mediaWidth,
    height: mediaHeight
  } = selectedMediaNode.attrs;
  const maxWidthForNestedNode = pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$m = pluginInjectionApi.media) === null || _pluginInjectionApi$m === void 0 ? void 0 : (_pluginInjectionApi$m2 = _pluginInjectionApi$m.sharedState.currentState()) === null || _pluginInjectionApi$m2 === void 0 ? void 0 : _pluginInjectionApi$m2.currentMaxWidth;
  const maxWidth = maxWidthForNestedNode || akEditorFullWidthLayoutWidth;
  const isVideoFile = isVideo(selectedMediaNode.attrs.__fileMimeType);
  const minWidth = calcMinWidth(isVideoFile, maxWidthForNestedNode || contentWidth);
  const hasPixelType = widthType === 'pixel';
  const pixelWidthFromElement = getPixelWidthOfElement(editorView, selectedMediaSingleNode.pos + 1,
  // get pos of media node
  mediaWidth || DEFAULT_IMAGE_WIDTH);
  const pixelWidth = hasPixelType ? mediaSingleWidth : pixelWidthFromElement;
  return jsx(PixelEntryComponent, {
    intl: intl,
    width: pluginState.isResizing ? pluginState.resizingWidth : pixelWidth,
    showMigration: !pluginState.isResizing && !hasPixelType,
    mediaWidth: mediaWidth || DEFAULT_IMAGE_WIDTH,
    mediaHeight: mediaHeight || DEFAULT_IMAGE_HEIGHT,
    minWidth: minWidth,
    maxWidth: maxWidth,
    onChange: valid => {
      if (valid) {
        hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(mediaSingle, true, 'warning')(editorView.state, dispatch, editorView);
      } else {
        hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(mediaSingle, false)(editorView.state, dispatch, editorView);
      }
    },
    onSubmit: ({
      width,
      validation
    }) => {
      const tr = updateNodeWithTr(width, validation);
      if (tr) {
        dispatch(tr);
      }
    },
    onMigrate: () => {
      const tr = state.tr.setNodeMarkup(selectedMediaSingleNode.pos, undefined, {
        ...selectedMediaSingleNode.node.attrs,
        width: pixelWidthFromElement,
        widthType: 'pixel'
      });
      tr.setMeta('scrollIntoView', false);
      tr.setSelection(NodeSelection.create(tr.doc, selectedMediaSingleNode.pos));
      dispatch(tr);
    },
    onCloseAndSave: ({
      width,
      validation
    }) => {
      const tr = updateNodeWithTr(width, validation);
      if (tr) {
        return closePixelEditorAndSave(() => tr)(state, dispatch);
      }
    },
    isViewMode: pluginState.isResizing
  });
};
export const FullWidthDisplay = ({
  intl: {
    formatMessage
  }
}) => {
  return (
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/design-system/consistent-css-prop-usage -- Ignored via go/DSP-18766
    jsx("div", {
      css: pixelSizingFullWidthLabelStyles
    }, jsx(Text, null, formatMessage(messages.fullWidthLabel)))
  );
};