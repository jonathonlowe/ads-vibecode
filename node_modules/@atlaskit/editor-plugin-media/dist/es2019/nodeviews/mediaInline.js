/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { useEffect, useMemo, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { MediaInlineImageCard } from '@atlaskit/editor-common/media-inline';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { SelectionBasedNodeView } from '@atlaskit/editor-common/selection-based-node-view';
import { MediaInlineCard } from '@atlaskit/media-card';
import { getMediaClient } from '@atlaskit/media-client-react';
import { MediaInlineCardLoadingView } from '@atlaskit/media-ui';
import { fg } from '@atlaskit/platform-feature-flags';
import { isImage } from '../pm-plugins/utils/is-type';
import { MediaViewerContainer } from '../ui/MediaViewer/MediaViewerContainer';
import { MediaNodeUpdater } from './mediaNodeUpdater';
const createMediaNodeUpdater = props => {
  const node = props.node;
  return new MediaNodeUpdater({
    ...props,
    isMediaSingle: true,
    node: node ? node : props.node,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    contextIdentifierProvider: props.contextIdentifierProvider
  });
};

/**
 * Handles updating the media inline node attributes
 * but also handling copy-paste for cross-editor of the same instance
 * using the contextid
 *
 */
const updateMediaNodeAttributes = async (props, mediaNodeUpdater) => {
  const {
    addPendingTask
  } = props.mediaPluginState;
  const node = props.node;
  if (!node) {
    return;
  }
  const contextId = mediaNodeUpdater.getNodeContextId();
  if (!contextId) {
    await mediaNodeUpdater.updateContextId();
  }
  const shouldNodeBeDeepCopied = await mediaNodeUpdater.shouldNodeBeDeepCopied();
  if (shouldNodeBeDeepCopied) {
    // Copy paste flow (different pages)
    try {
      const copyNode = mediaNodeUpdater.copyNode({
        traceId: node.attrs.__mediaTraceId
      });
      addPendingTask(copyNode);
      await copyNode;
    } catch (e) {
      return;
    }
  }
  await mediaNodeUpdater.updateMediaSingleFileAttrs();
};
export const handleNewNode = props => {
  const {
    node,
    mediaPluginState,
    getPos
  } = props;
  mediaPluginState.handleMediaNodeMount(node, () => getPos());
};
export const MediaInline = props => {
  var _props$node, _props$node$marks;
  const [viewMediaClientConfig, setViewMediaClientConfig] = useState();
  const [isNodeScopeUnsync, setIsNodeScopeUnsync] = useState(true);
  useEffect(() => {
    const mediaNodeUpdater = createMediaNodeUpdater(props);
    mediaNodeUpdater.shouldNodeBeDeepCopied().then(setIsNodeScopeUnsync);
    handleNewNode(props);
    updateMediaNodeAttributes(props, mediaNodeUpdater);
    updateViewMediaClientConfig(props);
    return () => {
      const {
        mediaPluginState
      } = props;
      mediaPluginState.handleMediaNodeUnmount(props.node);
    };
  }, [props]);
  const updateViewMediaClientConfig = async props => {
    const mediaProvider = await props.mediaProvider;
    if (mediaProvider) {
      const viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
      setViewMediaClientConfig(viewMediaClientConfig);
    }
  };
  const {
    id,
    collection,
    type,
    alt,
    width,
    height
  } = props.node.attrs;
  const identifier = {
    id,
    mediaItemType: 'file',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    collectionName: collection
  };

  /*
   * Show the loading view if
   * 1. The media provider is not ready
   * 2. Context Id is not synced
   * to prevent calling the media API (in mounting of `MediaInlineCard`)
   * before the prerequisites meet
   */
  if (!viewMediaClientConfig || isNodeScopeUnsync) {
    return jsx(MediaInlineCardLoadingView, {
      message: "",
      isSelected: false
    });
  }
  const {
    allowInlineImages
  } = props.mediaPluginState;
  const borderMark = (_props$node = props.node) === null || _props$node === void 0 ? void 0 : (_props$node$marks = _props$node.marks) === null || _props$node$marks === void 0 ? void 0 : _props$node$marks.find(mark => mark.type.name === 'border');
  if (allowInlineImages && isImage(type)) {
    return jsx(MediaInlineImageCard, {
      mediaClient: getMediaClient(viewMediaClientConfig),
      identifier: identifier,
      isSelected: props.isSelected,
      alt: alt,
      width: width,
      height: height,
      border: {
        borderSize: borderMark === null || borderMark === void 0 ? void 0 : borderMark.attrs.size,
        borderColor: borderMark === null || borderMark === void 0 ? void 0 : borderMark.attrs.color
      },
      isViewOnly: props.editorViewMode
    });
  }
  return jsx(MediaViewerContainer, {
    mediaNode: props.node,
    mediaPluginState: props.mediaPluginState,
    isEditorViewMode: props.editorViewMode,
    isSelected: props.isSelected,
    isInline: fg('platform_editor_render_media_viewer_as_inline')
  }, jsx(MediaInlineCard, {
    isSelected: props.isSelected,
    identifier: identifier,
    mediaClientConfig: viewMediaClientConfig
  }));
};
const MediaInlineSharedState = ({
  identifier,
  node,
  isSelected,
  getPos,
  contextIdentifierProvider,
  api,
  view
}) => {
  const {
    editorViewModeState,
    mediaState
  } = useSharedPluginState(api, ['editorViewMode', 'media']);
  const newMediaProvider = useMemo(() => mediaState !== null && mediaState !== void 0 && mediaState.mediaProvider ? Promise.resolve(mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider) : undefined, [mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider]);
  if (!mediaState || !newMediaProvider) {
    return null;
  }
  return jsx(MediaInline, {
    identifier: identifier,
    mediaProvider: newMediaProvider,
    mediaPluginState: mediaState,
    node: node,
    isSelected: isSelected,
    view: view,
    getPos: getPos,
    contextIdentifierProvider: contextIdentifierProvider,
    editorViewMode: (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view'
  });
};
export class MediaInlineNodeView extends SelectionBasedNodeView {
  createDomRef() {
    const domRef = document.createElement('span');
    domRef.contentEditable = 'false';
    return domRef;
  }
  ignoreMutation() {
    return true;
  }
  viewShouldUpdate(nextNode) {
    if (this.node.attrs !== nextNode.attrs) {
      return true;
    }
    return super.viewShouldUpdate(nextNode);
  }
  render(props) {
    const {
      providerFactory,
      api
    } = props;
    const {
      view
    } = this;
    const getPos = this.getPos;
    return jsx(WithProviders, {
      providers: ['contextIdentifierProvider'],
      providerFactory: providerFactory,
      renderNode: ({
        mediaProvider,
        contextIdentifierProvider
      }) => {
        return jsx(MediaInlineSharedState, {
          identifier: this.node.attrs.id,
          node: this.node,
          isSelected: this.nodeInsideSelection(),
          view: view,
          getPos: getPos,
          contextIdentifierProvider: contextIdentifierProvider,
          api: api
        });
      }
    });
  }
}
export const ReactMediaInlineNode = (portalProviderAPI, eventDispatcher, providerFactory, api, dispatchAnalyticsEvent) => (node, view, getPos) => {
  return new MediaInlineNodeView(node, view, getPos, portalProviderAPI, eventDispatcher, {
    providerFactory,
    dispatchAnalyticsEvent,
    api
  }).init();
};