import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import { bind } from 'bind-event-listener';
import { MEDIA_CONTEXT } from '@atlaskit/analytics-namespaced-context';
import { AnalyticsContext } from '@atlaskit/analytics-next';
import { setNodeSelection, setTextSelection, withImageLoader } from '@atlaskit/editor-common/utils';
import { CellSelection } from '@atlaskit/editor-tables/cell-selection';
import { Card, CardLoading } from '@atlaskit/media-card';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { stateKey as mediaStateKey } from '../../pm-plugins/plugin-key';
import { MediaCardWrapper } from '../styles';

// This is being used by DropPlaceholder now
export const MEDIA_HEIGHT = 125;
export const FILE_WIDTH = 156;
// eslint-disable-next-line @repo/internal/react/no-class-components
export class MediaNode extends Component {
  constructor(_props) {
    super(_props);
    _defineProperty(this, "state", {});
    _defineProperty(this, "videoControlsWrapperRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "unbindKeyDown", null);
    _defineProperty(this, "setViewMediaClientConfig", async () => {
      const mediaProvider = await this.props.mediaProvider;
      if (mediaProvider) {
        const viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
        this.setState({
          viewMediaClientConfig
        });
      }
    });
    _defineProperty(this, "selectMediaSingleFromCard", ({
      event
    }) => {
      this.selectMediaSingle(event);

      // In edit mode (node content wrapper has contenteditable set to true), link redirection is disabled by default
      // We need to call "stopPropagation" here in order to prevent in editor view mode, the browser from navigating to
      // another URL if the media node is wrapped in a link mark.
      if (this.props.isViewOnly && editorExperiment('platform_editor_controls', 'variant1')) {
        event.preventDefault();
      }
    });
    _defineProperty(this, "selectMediaSingle", event => {
      const propPos = this.props.getPos();
      if (typeof propPos !== 'number') {
        return;
      }

      // NOTE: This does not prevent the link navigation in the editor view mode, .preventDefault is needed (see selectMediaSingleFromCard)
      // Hence it should be removed
      // We need to call "stopPropagation" here in order to prevent the browser from navigating to
      // another URL if the media node is wrapped in a link mark.
      if (editorExperiment('platform_editor_controls', 'control')) {
        event.stopPropagation();
      }
      const {
        state
      } = this.props.view;
      if (event.shiftKey) {
        // don't select text if there is current selection in a table (as this would override selected cells)
        if (state.selection instanceof CellSelection) {
          return;
        }
        setTextSelection(this.props.view, state.selection.from < propPos ? state.selection.from : propPos - 1,
        // + 3 needed for offset of the media inside mediaSingle and cursor to make whole mediaSingle selected
        state.selection.to > propPos ? state.selection.to : propPos + 2);
      } else {
        setNodeSelection(this.props.view, propPos - 1);
      }
    });
    _defineProperty(this, "onFullscreenChange", fullscreen => {
      var _this$mediaPluginStat;
      (_this$mediaPluginStat = this.mediaPluginState) === null || _this$mediaPluginStat === void 0 ? void 0 : _this$mediaPluginStat.updateAndDispatch({
        isFullscreen: fullscreen
      });
    });
    _defineProperty(this, "handleNewNode", props => {
      var _this$mediaPluginStat2;
      const {
        node
      } = props;
      (_this$mediaPluginStat2 = this.mediaPluginState) === null || _this$mediaPluginStat2 === void 0 ? void 0 : _this$mediaPluginStat2.handleMediaNodeMount(node, () => this.props.getPos());
    });
    const {
      view
    } = this.props;
    this.mediaPluginState = mediaStateKey.getState(view.state);
  }
  shouldComponentUpdate(nextProps, nextState) {
    const hasNewViewMediaClientConfig = !this.state.viewMediaClientConfig && nextState.viewMediaClientConfig;
    if (this.props.selected !== nextProps.selected || this.props.node.attrs.id !== nextProps.node.attrs.id || this.props.node.attrs.collection !== nextProps.node.attrs.collection || this.props.maxDimensions.height !== nextProps.maxDimensions.height || this.props.maxDimensions.width !== nextProps.maxDimensions.width || this.props.contextIdentifierProvider !== nextProps.contextIdentifierProvider || this.props.isLoading !== nextProps.isLoading || this.props.mediaProvider !== nextProps.mediaProvider || hasNewViewMediaClientConfig) {
      return true;
    }
    return false;
  }
  async componentDidMount() {
    this.handleNewNode(this.props);
    const {
      contextIdentifierProvider
    } = this.props;
    this.setState({
      contextIdentifierProvider: await contextIdentifierProvider
    });
    await this.setViewMediaClientConfig();
  }
  componentWillUnmount() {
    var _this$mediaPluginStat3;
    const {
      node
    } = this.props;
    (_this$mediaPluginStat3 = this.mediaPluginState) === null || _this$mediaPluginStat3 === void 0 ? void 0 : _this$mediaPluginStat3.handleMediaNodeUnmount(node);
    if (this.unbindKeyDown && typeof this.unbindKeyDown === 'function') {
      this.unbindKeyDown();
    }
  }
  componentDidUpdate(prevProps) {
    var _this$mediaPluginStat5;
    if (prevProps.node.attrs.id !== this.props.node.attrs.id) {
      var _this$mediaPluginStat4;
      (_this$mediaPluginStat4 = this.mediaPluginState) === null || _this$mediaPluginStat4 === void 0 ? void 0 : _this$mediaPluginStat4.handleMediaNodeUnmount(prevProps.node);
      this.handleNewNode(this.props);
    }
    (_this$mediaPluginStat5 = this.mediaPluginState) === null || _this$mediaPluginStat5 === void 0 ? void 0 : _this$mediaPluginStat5.updateElement();
    this.setViewMediaClientConfig();
    // this.videoControlsWrapperRef is null on componentDidMount. We need to wait until it has value
    if (this.videoControlsWrapperRef && this.videoControlsWrapperRef.current) {
      var _this$mediaPluginStat6;
      if (!((_this$mediaPluginStat6 = this.mediaPluginState) !== null && _this$mediaPluginStat6 !== void 0 && _this$mediaPluginStat6.videoControlsWrapperRef)) {
        var _this$mediaPluginStat7;
        this.bindKeydown();
        (_this$mediaPluginStat7 = this.mediaPluginState) === null || _this$mediaPluginStat7 === void 0 ? void 0 : _this$mediaPluginStat7.updateAndDispatch({
          videoControlsWrapperRef: this.videoControlsWrapperRef.current
        });
      }
    }
  }
  bindKeydown() {
    var _this$videoControlsWr3;
    const onKeydown = event => {
      if (event.key === 'Tab') {
        var _this$videoControlsWr, _this$videoControlsWr2;
        // Add focus trap for controls panel
        let firstElement;
        let lastElement;
        const focusableElements = (_this$videoControlsWr = this.videoControlsWrapperRef) === null || _this$videoControlsWr === void 0 ? void 0 : (_this$videoControlsWr2 = _this$videoControlsWr.current) === null || _this$videoControlsWr2 === void 0 ? void 0 : _this$videoControlsWr2.querySelectorAll('button, input, [tabindex]:not([tabindex="-1"])');
        if (focusableElements && focusableElements.length) {
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          firstElement = focusableElements[0];
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          lastElement = focusableElements[focusableElements.length - 1];
          if (event.shiftKey && document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          } else if (!event.shiftKey && document.activeElement === lastElement) {
            var _firstElement;
            event.preventDefault();
            (_firstElement = firstElement) === null || _firstElement === void 0 ? void 0 : _firstElement.focus();
          }
        }
      }
    };
    if ((_this$videoControlsWr3 = this.videoControlsWrapperRef) !== null && _this$videoControlsWr3 !== void 0 && _this$videoControlsWr3.current) {
      this.unbindKeyDown = bind(this.videoControlsWrapperRef.current, {
        type: 'keydown',
        listener: onKeydown,
        options: {
          capture: true,
          passive: false
        }
      });
    }
  }
  render() {
    const {
      node,
      selected,
      originalDimensions,
      isLoading,
      maxDimensions,
      mediaOptions
    } = this.props;
    const borderMark = node.marks.find(m => m.type.name === 'border');
    const {
      viewMediaClientConfig,
      contextIdentifierProvider
    } = this.state;
    const {
      id,
      type,
      collection,
      url,
      alt
    } = node.attrs;
    if (isLoading || type !== 'external' && !viewMediaClientConfig) {
      return /*#__PURE__*/React.createElement(MediaCardWrapper, {
        dimensions: originalDimensions
      }, /*#__PURE__*/React.createElement(CardLoading, {
        interactionName: "editor-media-card-loading"
      }));
    }
    const contextId = contextIdentifierProvider && contextIdentifierProvider.objectId;
    const identifier = type === 'external' ? {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      dataURI: url,
      name: url,
      mediaItemType: 'external-image'
    } : {
      id,
      mediaItemType: 'file',
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      collectionName: collection
    };

    // mediaClientConfig is not needed for "external" case. So we have to cheat here.
    // there is a possibility mediaClientConfig will be part of a identifier,
    // so this might be not an issue
    const mediaClientConfig = viewMediaClientConfig || {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      authProvider: () => ({})
    };
    let ssr;
    if (fg('platform_editor_ssr_media')) {
      ssr = process.env.REACT_SSR ? 'server' : 'client';
    }
    return /*#__PURE__*/React.createElement(MediaCardWrapper, {
      dimensions: originalDimensions,
      onContextMenu: this.selectMediaSingle,
      borderWidth: borderMark === null || borderMark === void 0 ? void 0 : borderMark.attrs.size,
      selected: selected
    }, /*#__PURE__*/React.createElement(AnalyticsContext, {
      data: {
        [MEDIA_CONTEXT]: {
          border: !!borderMark
        }
      }
    }, /*#__PURE__*/React.createElement(Card, {
      mediaClientConfig: mediaClientConfig,
      resizeMode: "stretchy-fit",
      dimensions: maxDimensions,
      originalDimensions: originalDimensions,
      identifier: identifier,
      selectable: true,
      selected: selected,
      disableOverlay: true,
      onFullscreenChange: this.onFullscreenChange,
      onClick: this.selectMediaSingleFromCard,
      useInlinePlayer: mediaOptions && mediaOptions.allowLazyLoading,
      isLazy: mediaOptions && mediaOptions.allowLazyLoading,
      featureFlags: mediaOptions && mediaOptions.featureFlags,
      contextId: contextId,
      alt: alt,
      videoControlsWrapperRef: this.videoControlsWrapperRef,
      ssr: ssr
    })));
  }
}
export default withImageLoader(MediaNode);