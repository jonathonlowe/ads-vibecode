import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * @jsxRuntime classic
 * @jsx jsx
 * @jsxFrag
 */

import React, { Component, Fragment, useCallback, useMemo } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { captionMessages } from '@atlaskit/editor-common/media';
import { calcMediaSinglePixelWidth, DEFAULT_IMAGE_HEIGHT, DEFAULT_IMAGE_WIDTH, ExternalImageBadge, getMaxWidthForNestedNode, MEDIA_SINGLE_GUTTER_SIZE, MediaBadges } from '@atlaskit/editor-common/media-single';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import { MediaSingle } from '@atlaskit/editor-common/ui';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import { browser, isNodeSelectedOrInRange, setNodeSelection, setTextSelection } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeOfTypeClosestToPos } from '@atlaskit/editor-prosemirror/utils';
import { CellSelection } from '@atlaskit/editor-tables/cell-selection';
import { getAttrsFromUrl } from '@atlaskit/media-client';
import { fg } from '@atlaskit/platform-feature-flags';
import { insertAndSelectCaptionFromMediaSinglePos } from '../pm-plugins/commands/captions';
import { MEDIA_CONTENT_WRAP_CLASS_NAME } from '../pm-plugins/main';
import { isMediaBlobUrlFromAttrs } from '../pm-plugins/utils/media-common';
import { CaptionPlaceholder, CaptionPlaceholderButton } from '../ui/CaptionPlaceholder';
import { CommentBadge, CommentBadgeNextWrapper } from '../ui/CommentBadge';
import ResizableMediaSingle from '../ui/ResizableMediaSingle';
import ResizableMediaSingleNext from '../ui/ResizableMediaSingle/ResizableMediaSingleNext';
import { hasPrivateAttrsChanged } from './helpers';
import { MediaNodeUpdater } from './mediaNodeUpdater';
import { MediaSingleNodeNext } from './mediaSingleNext';
import { MediaSingleNodeSelector } from './styles';
const figureWrapperStyles = css({
  margin: 0
});
// eslint-disable-next-line @repo/internal/deprecations/deprecation-ticket-required -- Ignored via go/ED-25883
/*
 * @deprecated Please use the MediaSingleNodeNext
 */
// eslint-disable-next-line @repo/internal/react/no-class-components
export default class MediaSingleNode extends Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "mediaNodeUpdater", null);
    _defineProperty(this, "state", {
      width: undefined,
      height: undefined,
      viewMediaClientConfig: undefined,
      isCopying: false
    });
    _defineProperty(this, "mediaSingleWrapperRef", /*#__PURE__*/React.createRef());
    // platform_editor_typography_ugc clean up
    // remove HTMLSpanElement type
    _defineProperty(this, "captionPlaceHolderRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "createOrUpdateMediaNodeUpdater", props => {
      const node = this.props.node.firstChild;
      const updaterProps = {
        ...props,
        isMediaSingle: true,
        node: node ? node : this.props.node,
        dispatchAnalyticsEvent: this.props.dispatchAnalyticsEvent
      };
      if (!this.mediaNodeUpdater) {
        this.mediaNodeUpdater = new MediaNodeUpdater(updaterProps);
      } else {
        var _this$mediaNodeUpdate;
        (_this$mediaNodeUpdate = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate === void 0 ? void 0 : _this$mediaNodeUpdate.setProps(updaterProps);
      }
    });
    _defineProperty(this, "setViewMediaClientConfig", async props => {
      const mediaProvider = await props.mediaProvider;
      if (mediaProvider) {
        const viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
        this.setState({
          viewMediaClientConfig
        });
      }
    });
    _defineProperty(this, "updateMediaNodeAttributes", async props => {
      var _this$mediaNodeUpdate2, _this$props$node$firs, _this$mediaNodeUpdate4, _this$mediaNodeUpdate6;
      this.createOrUpdateMediaNodeUpdater(props);
      const {
        addPendingTask
      } = this.props.mediaPluginState;

      // we want the first child of MediaSingle (type "media")
      const node = this.props.node.firstChild;
      if (!node) {
        return;
      }
      const updatedDimensions = await ((_this$mediaNodeUpdate2 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate2 === void 0 ? void 0 : _this$mediaNodeUpdate2.getRemoteDimensions());
      const currentAttrs = (_this$props$node$firs = this.props.node.firstChild) === null || _this$props$node$firs === void 0 ? void 0 : _this$props$node$firs.attrs;
      if (updatedDimensions && ((currentAttrs === null || currentAttrs === void 0 ? void 0 : currentAttrs.width) !== updatedDimensions.width || (currentAttrs === null || currentAttrs === void 0 ? void 0 : currentAttrs.height) !== updatedDimensions.height)) {
        var _this$mediaNodeUpdate3;
        (_this$mediaNodeUpdate3 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate3 === void 0 ? void 0 : _this$mediaNodeUpdate3.updateDimensions(updatedDimensions);
      }
      if (node.attrs.type === 'external' && node.attrs.__external) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const updatingNode = this.mediaNodeUpdater.handleExternalMedia(this.props.getPos);
        addPendingTask(updatingNode);
        await updatingNode;
        return;
      }
      const contextId = (_this$mediaNodeUpdate4 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate4 === void 0 ? void 0 : _this$mediaNodeUpdate4.getNodeContextId();
      if (!contextId) {
        var _this$mediaNodeUpdate5;
        await ((_this$mediaNodeUpdate5 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate5 === void 0 ? void 0 : _this$mediaNodeUpdate5.updateContextId());
      }
      const shouldNodeBeDeepCopied = await ((_this$mediaNodeUpdate6 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate6 === void 0 ? void 0 : _this$mediaNodeUpdate6.shouldNodeBeDeepCopied());
      if (shouldNodeBeDeepCopied) {
        this.setState({
          isCopying: true
        });
        try {
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const copyNode = this.mediaNodeUpdater.copyNode({
            traceId: node.attrs.__mediaTraceId
          });
          addPendingTask(copyNode);
          await copyNode;
        } catch (e) {
          // if copyNode fails, let's set isCopying false so we can show the eventual error
          this.setState({
            isCopying: false
          });
        }
      }
    });
    _defineProperty(this, "selectMediaSingle", ({
      event
    }) => {
      const propPos = this.props.getPos();
      if (typeof propPos !== 'number') {
        return;
      }

      // We need to call "stopPropagation" here in order to prevent the browser from navigating to
      // another URL if the media node is wrapped in a link mark.
      event.stopPropagation();
      const {
        state
      } = this.props.view;
      if (event.shiftKey) {
        // don't select text if there is current selection in a table (as this would override selected cells)
        if (state.selection instanceof CellSelection) {
          return;
        }
        setTextSelection(this.props.view, state.selection.from < propPos ? state.selection.from : propPos,
        // + 3 needed for offset of the media inside mediaSingle and cursor to make whole mediaSingle selected
        state.selection.to > propPos ? state.selection.to : propPos + 3);
      } else {
        setNodeSelection(this.props.view, propPos);
      }
    });
    _defineProperty(this, "updateSize", (width, layout) => {
      const {
        state,
        dispatch
      } = this.props.view;
      const pos = this.props.getPos();
      if (typeof pos === 'undefined') {
        return;
      }
      const tr = state.tr.setNodeMarkup(pos, undefined, {
        ...this.props.node.attrs,
        layout,
        width,
        widthType: 'pixel'
      });
      tr.setMeta('scrollIntoView', false);
      /**
       * Any changes to attributes of a node count the node as "recreated" in Prosemirror[1]
       * This makes it so Prosemirror resets the selection to the child i.e. "media" instead of "media-single"
       * The recommended fix is to reset the selection.[2]
       *
       * [1] https://discuss.prosemirror.net/t/setnodemarkup-loses-current-nodeselection/976
       * [2] https://discuss.prosemirror.net/t/setnodemarkup-and-deselect/3673
       */
      tr.setSelection(NodeSelection.create(tr.doc, pos));
      return dispatch(tr);
    });
    _defineProperty(this, "onMediaSingleClicked", event => {
      var _this$captionPlaceHol;
      // Workaround for iOS 16 Caption selection issue
      // @see https://product-fabric.atlassian.net/browse/MEX-2012
      if (!browser.ios) {
        return;
      }
      if (this.mediaSingleWrapperRef.current !== event.target) {
        return;
      }
      (_this$captionPlaceHol = this.captionPlaceHolderRef.current) === null || _this$captionPlaceHol === void 0 ? void 0 : _this$captionPlaceHol.click();
    });
    _defineProperty(this, "clickPlaceholder", () => {
      var _pluginInjectionApi$a;
      const {
        view,
        getPos,
        node,
        pluginInjectionApi
      } = this.props;
      if (typeof getPos === 'boolean') {
        return;
      }
      insertAndSelectCaptionFromMediaSinglePos(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$a = pluginInjectionApi.analytics) === null || _pluginInjectionApi$a === void 0 ? void 0 : _pluginInjectionApi$a.actions)(getPos(), node)(view.state, view.dispatch);
    });
  }
  // Ignored via go/ees005
  // eslint-disable-next-line react/no-unsafe
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!this.mediaNodeUpdater) {
      this.createOrUpdateMediaNodeUpdater(nextProps);
    }
    if (nextProps.mediaProvider !== this.props.mediaProvider) {
      this.setViewMediaClientConfig(nextProps);
    }

    // Forced updates not required on mobile
    if (nextProps.isCopyPasteEnabled === false) {
      return;
    }
    if (nextProps.mediaProvider !== this.props.mediaProvider) {
      var _this$mediaNodeUpdate7;
      this.createOrUpdateMediaNodeUpdater(nextProps);
      (_this$mediaNodeUpdate7 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate7 === void 0 ? void 0 : _this$mediaNodeUpdate7.updateMediaSingleFileAttrs();
    } else if (nextProps.node.firstChild && this.props.node.firstChild) {
      const attrsChanged = hasPrivateAttrsChanged(this.props.node.firstChild.attrs, nextProps.node.firstChild.attrs);
      if (attrsChanged) {
        var _this$mediaNodeUpdate8;
        this.createOrUpdateMediaNodeUpdater(nextProps);
        // We need to call this method on any prop change since attrs can get removed with collab editing
        (_this$mediaNodeUpdate8 = this.mediaNodeUpdater) === null || _this$mediaNodeUpdate8 === void 0 ? void 0 : _this$mediaNodeUpdate8.updateMediaSingleFileAttrs();
      }
    }
  }
  async componentDidMount() {
    const {
      contextIdentifierProvider
    } = this.props;
    this.createOrUpdateMediaNodeUpdater(this.props);
    await Promise.all([this.setViewMediaClientConfig(this.props), this.updateMediaNodeAttributes(this.props)]);
    this.setState({
      contextIdentifierProvider: await contextIdentifierProvider
    });
  }
  render() {
    var _pluginInjectionApi$m, _pluginInjectionApi$m2, _node$firstChild;
    const {
      selected,
      getPos,
      node,
      mediaOptions,
      fullWidthMode,
      view: {
        state
      },
      view,
      pluginInjectionApi,
      width: containerWidth,
      lineLength,
      dispatchAnalyticsEvent,
      editorViewMode,
      editorDisabled,
      annotationPluginState,
      editorAppearance
    } = this.props;
    const {
      layout,
      widthType,
      width: mediaSingleWidthAttribute
    } = node.attrs;
    const childNode = node.firstChild;
    const attrs = (childNode === null || childNode === void 0 ? void 0 : childNode.attrs) || {};

    // original width and height of child media node (scaled)
    let {
      width,
      height
    } = attrs;
    if (attrs.type === 'external') {
      if (isMediaBlobUrlFromAttrs(attrs)) {
        const urlAttrs = getAttrsFromUrl(attrs.url);
        if (urlAttrs) {
          const {
            width: urlWidth,
            height: urlHeight
          } = urlAttrs;
          width = width || urlWidth;
          height = height || urlHeight;
        }
      }
      const {
        width: stateWidth,
        height: stateHeight
      } = this.state;
      if (width === null) {
        width = stateWidth || DEFAULT_IMAGE_WIDTH;
      }
      if (height === null) {
        height = stateHeight || DEFAULT_IMAGE_HEIGHT;
      }
    }
    if (!width || !height) {
      width = DEFAULT_IMAGE_WIDTH;
      height = DEFAULT_IMAGE_HEIGHT;
    }
    const isSelected = selected();
    const currentMaxWidth = isSelected ? pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$m = pluginInjectionApi.media) === null || _pluginInjectionApi$m === void 0 ? void 0 : (_pluginInjectionApi$m2 = _pluginInjectionApi$m.sharedState.currentState()) === null || _pluginInjectionApi$m2 === void 0 ? void 0 : _pluginInjectionApi$m2.currentMaxWidth : undefined;
    const contentWidthForLegacyExperience = getMaxWidthForNestedNode(view, getPos()) || lineLength;
    const contentWidth = currentMaxWidth || lineLength;
    const mediaSingleProps = {
      layout,
      width,
      height,
      containerWidth: containerWidth,
      lineLength: contentWidth,
      fullWidthMode,
      hasFallbackContainer: false,
      mediaSingleWidth: calcMediaSinglePixelWidth({
        width: mediaSingleWidthAttribute,
        widthType,
        origWidth: width,
        layout,
        // This will only be used when calculating legacy media single width
        // thus we use the legacy value (exclude table as container node)
        contentWidth: contentWidthForLegacyExperience,
        containerWidth,
        gutterOffset: MEDIA_SINGLE_GUTTER_SIZE
      }),
      allowCaptions: mediaOptions.allowCaptions,
      editorAppearance
    };
    const resizableMediaSingleProps = {
      view: view,
      getPos: getPos,
      updateSize: this.updateSize,
      gridSize: 12,
      viewMediaClientConfig: this.state.viewMediaClientConfig,
      allowBreakoutSnapPoints: mediaOptions && mediaOptions.allowBreakoutSnapPoints,
      selected: isSelected,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      pluginInjectionApi: pluginInjectionApi,
      forceHandlePositioning: mediaOptions === null || mediaOptions === void 0 ? void 0 : mediaOptions.forceHandlePositioning,
      ...mediaSingleProps
    };
    let canResize = !!this.props.mediaOptions.allowResizing && !editorDisabled && !editorViewMode;
    if (!this.props.mediaOptions.allowResizingInTables) {
      // If resizing not allowed in tables, check parents for tables
      const pos = getPos();
      if (pos) {
        const $pos = state.doc.resolve(pos);
        const {
          table
        } = state.schema.nodes;
        const disabledNode = !!findParentNodeOfTypeClosestToPos($pos, [table]);
        canResize = canResize && !disabledNode;
      }
    }
    const isBadgePosOffsetRight = () => {
      const pos = getPos();
      if (pos !== undefined) {
        const $pos = view.state.doc.resolve(pos);
        const {
          table
        } = view.state.schema.nodes;
        const foundTableNode = findParentNodeOfTypeClosestToPos($pos, [table]);
        return foundTableNode ? '2px' : '14px';
      }
    };
    const badgeOffsetRight = isBadgePosOffsetRight();
    let shouldShowPlaceholder = mediaOptions.allowCaptions && node.childCount !== 2 && isSelected && state.selection instanceof NodeSelection;
    shouldShowPlaceholder = !editorDisabled && shouldShowPlaceholder;
    const isCurrentNodeDrafting = (annotationPluginState === null || annotationPluginState === void 0 ? void 0 : annotationPluginState.isDrafting) && (annotationPluginState === null || annotationPluginState === void 0 ? void 0 : annotationPluginState.targetNodeId) === (node === null || node === void 0 ? void 0 : (_node$firstChild = node.firstChild) === null || _node$firstChild === void 0 ? void 0 : _node$firstChild.attrs.id);
    const pos = getPos();
    const isInsideTable = pos !== undefined && findParentNodeOfTypeClosestToPos(state.doc.resolve(pos), [state.schema.nodes.table]);
    const currentMediaElement = () => {
      if (pos !== undefined) {
        const mediaNode = view.domAtPos(pos + 1).node;
        return mediaNode instanceof HTMLElement ? mediaNode : null;
      }
      return null;
    };
    const MediaChildren =
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-noninteractive-element-interactions
    jsx("figure", {
      ref: this.mediaSingleWrapperRef,
      css: figureWrapperStyles
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: MediaSingleNodeSelector,
      onClick: this.onMediaSingleClicked
    }, fg('platform_editor_add_media_from_url_rollout') && jsx(MediaBadges, {
      mediaElement: currentMediaElement(),
      mediaHeight: height,
      mediaWidth: width,
      extendedResizeOffset: mediaOptions.allowPixelResizing && !isInsideTable
    }, ({
      visible
    }) => jsx(React.Fragment, null, visible && jsx(ExternalImageBadge, {
      type: attrs.type,
      url: attrs.type === 'external' ? attrs.url : undefined
    }), mediaOptions.allowCommentsOnMedia && jsx(CommentBadgeNextWrapper, {
      view: view,
      api: pluginInjectionApi,
      mediaNode: node === null || node === void 0 ? void 0 : node.firstChild,
      getPos: getPos,
      isDrafting: isCurrentNodeDrafting
    }))), !fg('platform_editor_add_media_from_url_rollout') && mediaOptions.allowCommentsOnMedia && jsx(CommentBadge, {
      view: view,
      api: pluginInjectionApi,
      mediaNode: node === null || node === void 0 ? void 0 : node.firstChild,
      badgeOffsetRight: badgeOffsetRight,
      getPos: getPos,
      isDrafting: isCurrentNodeDrafting
    }), jsx("div", {
      ref: this.props.forwardRef
    }), shouldShowPlaceholder && (fg('platform_editor_typography_ugc') ? jsx(CaptionPlaceholderButton
    // platform_editor_typography_ugc clean up
    // remove typecasting
    , {
      ref: this.captionPlaceHolderRef,
      onClick: this.clickPlaceholder,
      placeholderMessage: mediaOptions.allowImagePreview ? captionMessages.placeholderWithDoubleClickPrompt : captionMessages.placeholder
    }) : jsx(CaptionPlaceholder, {
      ref: this.captionPlaceHolderRef,
      onClick: this.clickPlaceholder,
      placeholderMessage: mediaOptions.allowImagePreview ? captionMessages.placeholderWithDoubleClickPrompt : captionMessages.placeholder
    })));
    return jsx(Fragment, null, canResize ? mediaOptions.allowPixelResizing ? jsx(ResizableMediaSingleNext
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, resizableMediaSingleProps, {
      showLegacyNotification: widthType !== 'pixel'
    }), MediaChildren) : jsx(ResizableMediaSingle
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, resizableMediaSingleProps, {
      lineLength: contentWidthForLegacyExperience,
      pctWidth: mediaSingleWidthAttribute
    }), MediaChildren) : jsx(MediaSingle
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, mediaSingleProps, {
      pctWidth: mediaSingleWidthAttribute,
      size: {
        width: mediaSingleWidthAttribute,
        widthType: widthType
      }
    }), MediaChildren));
  }
}
_defineProperty(MediaSingleNode, "defaultProps", {
  mediaOptions: {}
});
_defineProperty(MediaSingleNode, "displayName", 'MediaSingleNode');
const MediaSingleNodeWrapper = ({
  pluginInjectionApi,
  contextIdentifierProvider,
  node,
  getPos,
  mediaOptions,
  view,
  fullWidthMode,
  selected,
  eventDispatcher,
  dispatchAnalyticsEvent,
  forwardRef,
  editorAppearance
}) => {
  const {
    widthState,
    mediaState,
    annotationState,
    editorDisabledState,
    editorViewModeState
  } = useSharedPluginState(pluginInjectionApi, ['width', 'media', 'annotation', 'editorDisabled', 'editorViewMode']);
  const hasHadInteraction = useSharedPluginStateSelector(pluginInjectionApi, 'interaction.hasHadInteraction');
  const mediaProvider = useMemo(() => mediaState !== null && mediaState !== void 0 && mediaState.mediaProvider ? Promise.resolve(mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider) : undefined, [mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider]);
  const isSelectedAndInteracted = useCallback(() => Boolean(selected() && hasHadInteraction), [hasHadInteraction, selected]);
  if (fg('platform_editor_react18_phase2__media_single') || fg('platform_editor_react18_phase2__media_single_jira')) {
    return jsx(MediaSingleNodeNext, {
      width: (widthState === null || widthState === void 0 ? void 0 : widthState.width) || 0,
      lineLength: (widthState === null || widthState === void 0 ? void 0 : widthState.lineLength) || 0,
      node: node,
      getPos: getPos,
      mediaProvider: mediaProvider,
      contextIdentifierProvider: contextIdentifierProvider,
      mediaOptions: mediaOptions,
      view: view,
      fullWidthMode: fullWidthMode,
      selected: fg('platform_editor_no_selection_until_interaction') ? isSelectedAndInteracted : selected,
      eventDispatcher: eventDispatcher,
      mediaPluginState: mediaState !== null && mediaState !== void 0 ? mediaState : undefined,
      annotationPluginState: annotationState !== null && annotationState !== void 0 ? annotationState : undefined,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      forwardRef: forwardRef,
      pluginInjectionApi: pluginInjectionApi,
      editorDisabled: editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled,
      editorViewMode: (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view',
      editorAppearance: editorAppearance
    });
  }
  return jsx(MediaSingleNode
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  , {
    width: widthState.width
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    lineLength: widthState.lineLength,
    node: node,
    getPos: getPos,
    mediaProvider: mediaProvider,
    contextIdentifierProvider: contextIdentifierProvider,
    mediaOptions: mediaOptions,
    view: view,
    fullWidthMode: fullWidthMode,
    selected: fg('platform_editor_no_selection_until_interaction') ? isSelectedAndInteracted : selected,
    eventDispatcher: eventDispatcher,
    mediaPluginState: mediaState !== null && mediaState !== void 0 ? mediaState : undefined,
    annotationPluginState: annotationState !== null && annotationState !== void 0 ? annotationState : undefined,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    forwardRef: forwardRef,
    pluginInjectionApi: pluginInjectionApi,
    editorDisabled: editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled,
    editorViewMode: (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view',
    editorAppearance: editorAppearance
  });
};
class MediaSingleNodeView extends ReactNodeView {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "lastOffsetLeft", 0);
    _defineProperty(this, "forceViewUpdate", false);
    _defineProperty(this, "selectionType", null);
    _defineProperty(this, "checkAndUpdateSelectionType", () => {
      const getPos = this.getPos;
      const {
        selection
      } = this.view.state;

      /**
       *  ED-19831
       *  There is a getPos issue coming from this code. We need to apply this workaround for now and apply a patch
       *  directly to confluence since this bug is now in production.
       */
      let pos;
      try {
        pos = getPos ? getPos() : undefined;
      } catch (e) {
        pos = undefined;
      }
      const isNodeSelected = isNodeSelectedOrInRange(selection.$anchor.pos, selection.$head.pos, pos, this.node.nodeSize);
      this.selectionType = isNodeSelected;
      return isNodeSelected;
    });
    _defineProperty(this, "isNodeSelected", () => {
      this.checkAndUpdateSelectionType();
      return this.selectionType !== null;
    });
  }
  createDomRef() {
    var _this$reactComponentP, _this$reactComponentP2, _this$reactComponentP3, _this$reactComponentP4;
    const domRef = document.createElement('div');

    // control the domRef contentEditable attribute based on the editor view mode
    this.unsubscribeToViewModeChange = this.subscribeToViewModeChange(domRef);
    const initialViewMode = (_this$reactComponentP = this.reactComponentProps.pluginInjectionApi) === null || _this$reactComponentP === void 0 ? void 0 : (_this$reactComponentP2 = _this$reactComponentP.editorViewMode) === null || _this$reactComponentP2 === void 0 ? void 0 : (_this$reactComponentP3 = _this$reactComponentP2.sharedState.currentState()) === null || _this$reactComponentP3 === void 0 ? void 0 : _this$reactComponentP3.mode;
    this.updateDomRefContentEditable(domRef, initialViewMode);
    if ((_this$reactComponentP4 = this.reactComponentProps.mediaOptions) !== null && _this$reactComponentP4 !== void 0 && _this$reactComponentP4.allowPixelResizing) {
      domRef.classList.add('media-extended-resize-experience');
    }
    return domRef;
  }
  getContentDOM() {
    const dom = document.createElement('div');
    dom.classList.add(MEDIA_CONTENT_WRAP_CLASS_NAME);
    return {
      dom
    };
  }
  viewShouldUpdate(nextNode) {
    if (this.forceViewUpdate) {
      this.forceViewUpdate = false;
      return true;
    }
    if (this.node.attrs !== nextNode.attrs) {
      return true;
    }
    if (this.selectionType !== this.checkAndUpdateSelectionType()) {
      return true;
    }
    if (this.node.childCount !== nextNode.childCount) {
      return true;
    }
    return super.viewShouldUpdate(nextNode);
  }
  subscribeToViewModeChange(domRef) {
    var _this$reactComponentP5, _this$reactComponentP6;
    return (_this$reactComponentP5 = this.reactComponentProps.pluginInjectionApi) === null || _this$reactComponentP5 === void 0 ? void 0 : (_this$reactComponentP6 = _this$reactComponentP5.editorViewMode) === null || _this$reactComponentP6 === void 0 ? void 0 : _this$reactComponentP6.sharedState.onChange(viewModeState => {
      var _viewModeState$nextSh;
      this.updateDomRefContentEditable(domRef, (_viewModeState$nextSh = viewModeState.nextSharedState) === null || _viewModeState$nextSh === void 0 ? void 0 : _viewModeState$nextSh.mode);
    });
  }
  updateDomRefContentEditable(domRef, editorViewMode) {
    var _this$reactComponentP7;
    // if the editor is in view mode, we should not allow editing
    if (editorViewMode === 'view') {
      domRef.contentEditable = 'false';
      return;
    }

    // if the editor is in edit mode, we should allow editing if the media options allow it
    if ((_this$reactComponentP7 = this.reactComponentProps.mediaOptions) !== null && _this$reactComponentP7 !== void 0 && _this$reactComponentP7.allowMediaSingleEditable) {
      // workaround Chrome bug in https://product-fabric.atlassian.net/browse/ED-5379
      // see also: https://github.com/ProseMirror/prosemirror/issues/884
      domRef.contentEditable = 'true';
    }
  }
  getNodeMediaId(node) {
    if (node.firstChild) {
      return node.firstChild.attrs.id;
    }
    return undefined;
  }
  stopEvent(event) {
    if (this.isNodeSelected() && event instanceof KeyboardEvent && (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLElement) {
      const targetType = event.target.type;
      if (event.key === 'Enter' && targetType === 'button') {
        return true;
      }
    }
    return false;
  }
  update(node, decorations, _innerDecorations, isValidUpdate) {
    if (!isValidUpdate) {
      isValidUpdate = (currentNode, newNode) => this.getNodeMediaId(currentNode) === this.getNodeMediaId(newNode);
    }
    return super.update(node, decorations, _innerDecorations, isValidUpdate);
  }
  render(props, forwardRef) {
    const {
      eventDispatcher,
      fullWidthMode,
      providerFactory,
      mediaOptions,
      dispatchAnalyticsEvent,
      pluginInjectionApi,
      editorAppearance
    } = this.reactComponentProps;

    // getPos is a boolean for marks, since this is a node we know it must be a function
    const getPos = this.getPos;
    return jsx(WithProviders, {
      providers: ['contextIdentifierProvider'],
      providerFactory: providerFactory,
      renderNode: ({
        contextIdentifierProvider
      }) => {
        return jsx(MediaSingleNodeWrapper, {
          pluginInjectionApi: pluginInjectionApi,
          contextIdentifierProvider: contextIdentifierProvider,
          node: this.node,
          getPos: getPos,
          mediaOptions: mediaOptions,
          view: this.view,
          fullWidthMode: fullWidthMode,
          selected: this.isNodeSelected,
          eventDispatcher: eventDispatcher
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          ,
          dispatchAnalyticsEvent: dispatchAnalyticsEvent
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          ,
          forwardRef: forwardRef,
          editorAppearance: editorAppearance
        });
      }
    });
  }
  ignoreMutation() {
    // DOM has changed; recalculate if we need to re-render
    if (this.dom) {
      // Ignored via go/ees005
      // eslint-disable-next-line @atlaskit/editor/no-as-casting
      const offsetLeft = this.dom.offsetLeft;
      if (offsetLeft !== this.lastOffsetLeft) {
        this.lastOffsetLeft = offsetLeft;
        this.forceViewUpdate = true;
        this.update(this.node, [], undefined, () => true);
      }
    }
    return true;
  }
  destroy() {
    var _this$unsubscribeToVi;
    (_this$unsubscribeToVi = this.unsubscribeToViewModeChange) === null || _this$unsubscribeToVi === void 0 ? void 0 : _this$unsubscribeToVi.call(this);
  }
}
export const ReactMediaSingleNode = (portalProviderAPI, eventDispatcher, providerFactory, pluginInjectionApi, dispatchAnalyticsEvent, mediaOptions = {}) => (node, view, getPos) => {
  return new MediaSingleNodeView(node, view, getPos, portalProviderAPI, eventDispatcher, {
    eventDispatcher,
    fullWidthMode: mediaOptions.fullWidthEnabled,
    providerFactory,
    mediaOptions,
    dispatchAnalyticsEvent,
    isCopyPasteEnabled: mediaOptions.isCopyPasteEnabled,
    pluginInjectionApi,
    editorAppearance: mediaOptions.editorAppearance
  }).init();
};