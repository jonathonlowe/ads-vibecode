"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVideo = exports.isMediaSingle = exports.insertMediaSingleNode = exports.insertMediaAsMediaSingle = exports.changeFromMediaInlineToMediaSingleNode = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _insert = require("@atlaskit/editor-common/insert");
var _mediaSingle = require("@atlaskit/editor-common/media-single");
var _selection = require("@atlaskit/editor-common/selection");
var _utils = require("@atlaskit/editor-common/utils");
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _mediaCommon = require("../utils/media-common");
var _analytics2 = require("./analytics");
var _isType = require("./is-type");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var getInsertMediaAnalytics = function getInsertMediaAnalytics(inputMethod, fileExtension, insertMediaVia) {
  return {
    action: _analytics.ACTION.INSERTED,
    actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: _analytics.ACTION_SUBJECT_ID.MEDIA,
    attributes: {
      inputMethod: inputMethod,
      insertMediaVia: insertMediaVia,
      fileExtension: fileExtension,
      type: _analytics.ACTION_SUBJECT_ID.MEDIA_SINGLE
    },
    eventType: _analytics.EVENT_TYPE.TRACK
  };
};
function shouldAddParagraph(state) {
  return (0, _selection.atTheBeginningOfBlock)(state) && !(0, _utils.checkNodeDown)(state.selection, state.doc, _utils.isEmptyParagraph);
}
function insertNodesWithOptionalParagraph(_ref) {
  var nodes = _ref.nodes,
    _ref$analyticsAttribu = _ref.analyticsAttributes,
    analyticsAttributes = _ref$analyticsAttribu === void 0 ? {} : _ref$analyticsAttribu,
    editorAnalyticsAPI = _ref.editorAnalyticsAPI,
    insertMediaVia = _ref.insertMediaVia;
  return function (state, dispatch) {
    var tr = state.tr,
      schema = state.schema;
    var paragraph = schema.nodes.paragraph;
    var inputMethod = analyticsAttributes.inputMethod,
      fileExtension = analyticsAttributes.fileExtension,
      newType = analyticsAttributes.newType,
      previousType = analyticsAttributes.previousType;
    var updatedTr = tr;
    var openEnd = 0;
    if (shouldAddParagraph(state) && !(0, _platformFeatureFlags.fg)('platform_editor_axe_leading_paragraph_from_media')) {
      nodes.push(paragraph.create());
      openEnd = 1;
    }
    if (state.selection.empty) {
      var insertFrom = (0, _selection.atTheBeginningOfBlock)(state) && (0, _platformFeatureFlags.fg)('platform_editor_axe_leading_paragraph_from_media') ? state.selection.$from.before() : state.selection.from;
      if ((0, _platformFeatureFlags.fg)('platform_editor_axe_leading_paragraph_from_media')) {
        if ((0, _platformFeatureFlags.fg)('platform_editor_multi_images_overridden_upload_fix')) {
          // the use of pmSafeInsert causes the node selection to media single node.
          // It leads to discrepancy between the full-page and comment editor - not sure why :shrug:
          // When multiple images are uploaded, the node selection is set to the previous node
          // and got overridden by the next node inserted.
          // It also causes the images position shifted when the images are uploaded.
          // E.g the images are uploaded after a table, the images will be inserted inside the table.
          // so we revert to use tr.insert instead. No extra paragraph is added.
          updatedTr = updatedTr.insert(insertFrom, nodes);
        } else {
          var shouldInsertFrom = !(0, _mediaCommon.isInsidePotentialEmptyParagraph)(state);
          updatedTr = (0, _selection.atTheBeginningOfBlock)(state) ? (0, _utils2.safeInsert)(nodes[0], shouldInsertFrom ? insertFrom : undefined, false)(updatedTr) : updatedTr.insert(insertFrom, nodes);
        }
      } else {
        updatedTr.insert(insertFrom, nodes);
      }
      var endPos = state.selection.from + nodes.reduce(function (totalSize, currNode) {
        return totalSize + currNode.nodeSize;
      }, 0);
      if (!(0, _platformFeatureFlags.fg)('platform_editor_axe_leading_paragraph_from_media')) {
        updatedTr.setSelection(new _state.TextSelection(updatedTr.doc.resolve(endPos), updatedTr.doc.resolve(endPos)));
      }
    } else {
      updatedTr.replaceSelection(new _model.Slice(_model.Fragment.from(nodes), 0, openEnd));
    }
    if (inputMethod) {
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(getInsertMediaAnalytics(inputMethod, fileExtension, insertMediaVia))(updatedTr);
    }
    if (newType && previousType) {
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent((0, _analytics2.getChangeMediaAnalytics)(previousType, newType, (0, _analytics2.findChangeFromLocation)(state.selection)))(updatedTr);
    }
    if (dispatch) {
      dispatch(updatedTr);
    }
    return true;
  };
}
var isMediaSingle = exports.isMediaSingle = function isMediaSingle(schema, fileMimeType) {
  return !!schema.nodes.mediaSingle && (0, _isType.isImage)(fileMimeType);
};
var insertMediaAsMediaSingle = exports.insertMediaAsMediaSingle = function insertMediaAsMediaSingle(view, node, inputMethod, editorAnalyticsAPI, insertMediaVia, allowPixelResizing) {
  var _node$attrs$width;
  var state = view.state,
    dispatch = view.dispatch;
  var _state$schema$nodes = state.schema.nodes,
    mediaSingle = _state$schema$nodes.mediaSingle,
    media = _state$schema$nodes.media;
  if (!mediaSingle) {
    return false;
  }

  // if not an image type media node
  if (node.type !== media || !(0, _isType.isImage)(node.attrs.__fileMimeType) && node.attrs.type !== 'external') {
    return false;
  }
  var insertMediaPopup = (0, _platformFeatureFlags.fg)('platform_editor_add_media_from_url_rollout');
  var mediaSingleAttrs = allowPixelResizing && insertMediaPopup ? {
    widthType: 'pixel',
    width: (0, _mediaSingle.getMediaSingleInitialWidth)((_node$attrs$width = node.attrs.width) !== null && _node$attrs$width !== void 0 ? _node$attrs$width : _mediaSingle.DEFAULT_IMAGE_WIDTH),
    layout: 'center'
  } : {};
  var mediaSingleNode = mediaSingle.create(mediaSingleAttrs, node);
  var nodes = [mediaSingleNode];
  var analyticsAttributes = {
    inputMethod: inputMethod,
    fileExtension: node.attrs.__fileMimeType
  };
  return insertNodesWithOptionalParagraph({
    nodes: nodes,
    analyticsAttributes: analyticsAttributes,
    editorAnalyticsAPI: editorAnalyticsAPI,
    insertMediaVia: insertMediaVia
  })(state, dispatch);
};
var getFileExtension = function getFileExtension(fileName) {
  if (fileName) {
    var extensionIdx = fileName.lastIndexOf('.');
    return extensionIdx >= 0 ? fileName.substring(extensionIdx + 1) : undefined;
  }
  return undefined;
};
var insertMediaSingleNode = exports.insertMediaSingleNode = function insertMediaSingleNode(view, mediaState, inputMethod, collection, alignLeftOnInsert, widthPluginState, editorAnalyticsAPI, onNodeInserted, insertMediaVia, allowPixelResizing) {
  var _state$selection$$fro;
  if (collection === undefined) {
    return false;
  }
  var state = view.state,
    dispatch = view.dispatch;
  var grandParentNodeType = (_state$selection$$fro = state.selection.$from.node(-1)) === null || _state$selection$$fro === void 0 ? void 0 : _state$selection$$fro.type;
  var parentNodeType = state.selection.$from.parent.type;

  // add undefined as fallback as we don't want media single width to have upper limit as 0
  // if widthPluginState.width is 0, default 760 will be used
  var contentWidth = (0, _mediaSingle.getMaxWidthForNestedNodeNext)(view, state.selection.$from.pos, true) || (widthPluginState === null || widthPluginState === void 0 ? void 0 : widthPluginState.lineLength) || (widthPluginState === null || widthPluginState === void 0 ? void 0 : widthPluginState.width) || undefined;
  var node = createMediaSingleNode(state.schema, collection, contentWidth, mediaState.status !== 'error' && isVideo(mediaState.fileMimeType) ? _mediaSingle.MEDIA_SINGLE_VIDEO_MIN_PIXEL_WIDTH : _mediaSingle.MEDIA_SINGLE_DEFAULT_MIN_PIXEL_WIDTH, alignLeftOnInsert, allowPixelResizing)(mediaState);
  var fileExtension;
  if (mediaState.fileName) {
    var extensionIdx = mediaState.fileName.lastIndexOf('.');
    fileExtension = extensionIdx >= 0 ? mediaState.fileName.substring(extensionIdx + 1) : undefined;
  }
  // should split if media is valid content for the grandparent of the selected node
  // and the parent node is a paragraph
  if ((0, _insert.shouldSplitSelectedNodeOnNodeInsertion)({
    parentNodeType: parentNodeType,
    grandParentNodeType: grandParentNodeType,
    content: node
  })) {
    insertNodesWithOptionalParagraph({
      nodes: [node],
      analyticsAttributes: {
        fileExtension: fileExtension,
        inputMethod: inputMethod
      },
      editorAnalyticsAPI: editorAnalyticsAPI,
      insertMediaVia: insertMediaVia
    })(state, dispatch);
  } else {
    var tr = null;
    tr = (0, _insert.safeInsert)(node, state.selection.from)(state.tr);
    if (!tr) {
      var content = shouldAddParagraph(view.state) ? _model.Fragment.fromArray([node, state.schema.nodes.paragraph.create()]) : node;
      tr = (0, _utils2.safeInsert)(content, undefined, true)(state.tr);
    }
    if (inputMethod) {
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(getInsertMediaAnalytics(inputMethod, fileExtension, insertMediaVia))(tr);
    }
    dispatch(tr);
  }
  if (onNodeInserted) {
    onNodeInserted(mediaState.id, view.state.selection.to);
  }
  return true;
};
var changeFromMediaInlineToMediaSingleNode = exports.changeFromMediaInlineToMediaSingleNode = function changeFromMediaInlineToMediaSingleNode(view, fromNode, widthPluginState, editorAnalyticsAPI, allowPixelResizing) {
  var _state$selection$$fro2;
  var state = view.state,
    dispatch = view.dispatch;
  var mediaInline = state.schema.nodes.mediaInline;
  if (fromNode.type !== mediaInline) {
    return false;
  }
  var grandParentNodeType = (_state$selection$$fro2 = state.selection.$from.node(-1)) === null || _state$selection$$fro2 === void 0 ? void 0 : _state$selection$$fro2.type;
  var parentNodeType = state.selection.$from.parent.type;

  // add undefined as fallback as we don't want media single width to have upper limit as 0
  // if widthPluginState.width is 0, default 760 will be used
  var contentWidth = (0, _mediaSingle.getMaxWidthForNestedNodeNext)(view, state.selection.$from.pos, true) || (widthPluginState === null || widthPluginState === void 0 ? void 0 : widthPluginState.lineLength) || (widthPluginState === null || widthPluginState === void 0 ? void 0 : widthPluginState.width) || undefined;
  var node = replaceWithMediaSingleNode(state.schema, contentWidth, _mediaSingle.MEDIA_SINGLE_DEFAULT_MIN_PIXEL_WIDTH, allowPixelResizing)(fromNode);
  var fileExtension = getFileExtension(fromNode.attrs.__fileName);
  // should split if media is valid content for the grandparent of the selected node
  // and the parent node is a paragraph
  if ((0, _insert.shouldSplitSelectedNodeOnNodeInsertion)({
    parentNodeType: parentNodeType,
    grandParentNodeType: grandParentNodeType,
    content: node
  })) {
    return insertNodesWithOptionalParagraph({
      nodes: [node],
      analyticsAttributes: {
        fileExtension: fileExtension,
        newType: _analytics.ACTION_SUBJECT_ID.MEDIA_SINGLE,
        previousType: _analytics.ACTION_SUBJECT_ID.MEDIA_INLINE
      },
      editorAnalyticsAPI: editorAnalyticsAPI
    })(state, dispatch);
  } else {
    var nodePos = state.tr.doc.resolve(state.selection.from).end();
    var tr = null;
    tr = (0, _utils2.removeSelectedNode)(state.tr);
    tr = (0, _insert.safeInsert)(node, nodePos)(tr);
    if (!tr) {
      var content = shouldAddParagraph(view.state) ? _model.Fragment.fromArray([node, state.schema.nodes.paragraph.create()]) : node;
      tr = (0, _utils2.safeInsert)(content, undefined, true)(state.tr);
    }
    editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent((0, _analytics2.getChangeMediaAnalytics)(_analytics.ACTION_SUBJECT_ID.MEDIA_INLINE, _analytics.ACTION_SUBJECT_ID.MEDIA_SINGLE, (0, _analytics2.findChangeFromLocation)(state.selection)))(tr);
    dispatch(tr);
  }
  return true;
};
var createMediaSingleNode = function createMediaSingleNode(schema, collection, maxWidth, minWidth, alignLeftOnInsert, allowPixelResizing) {
  return function (mediaState) {
    var id = mediaState.id,
      dimensions = mediaState.dimensions,
      contextId = mediaState.contextId,
      _mediaState$scaleFact = mediaState.scaleFactor,
      scaleFactor = _mediaState$scaleFact === void 0 ? 1 : _mediaState$scaleFact,
      fileName = mediaState.fileName;
    var _ref2 = dimensions || {
        height: undefined,
        width: undefined
      },
      width = _ref2.width,
      height = _ref2.height;
    var _schema$nodes = schema.nodes,
      media = _schema$nodes.media,
      mediaSingle = _schema$nodes.mediaSingle;
    var scaledWidth = width && Math.round(width / scaleFactor);
    var mediaNode = media.create(_objectSpread({
      id: id,
      type: 'file',
      collection: collection,
      contextId: contextId,
      width: scaledWidth,
      height: height && Math.round(height / scaleFactor)
    }, fileName && {
      alt: fileName
    }));
    var mediaSingleAttrs = alignLeftOnInsert ? {
      layout: 'align-start'
    } : {};
    var extendedMediaSingleAttrs = allowPixelResizing ? _objectSpread(_objectSpread({}, mediaSingleAttrs), {}, {
      width: (0, _mediaSingle.getMediaSingleInitialWidth)(scaledWidth, maxWidth, minWidth),
      // TODO: ED-26962 - change to use enum
      widthType: 'pixel'
    }) : mediaSingleAttrs;
    (0, _mediaCommon.copyOptionalAttrsFromMediaState)(mediaState, mediaNode);
    return mediaSingle.createChecked(extendedMediaSingleAttrs, mediaNode);
  };
};
var replaceWithMediaSingleNode = function replaceWithMediaSingleNode(schema, maxWidth, minWidth, allowPixelResizing) {
  return function (mediaNode) {
    var width = mediaNode.attrs.width;
    var _schema$nodes2 = schema.nodes,
      media = _schema$nodes2.media,
      mediaSingle = _schema$nodes2.mediaSingle;
    var copiedMediaNode = media.create(_objectSpread(_objectSpread({}, mediaNode.attrs), {}, {
      type: 'file'
    }), mediaNode.content, mediaNode.marks);
    var extendedMediaSingleAttrs = allowPixelResizing ? {
      width: (0, _mediaSingle.getMediaSingleInitialWidth)(width, maxWidth, minWidth),
      widthType: 'pixel'
    } : {};
    return mediaSingle.createChecked(extendedMediaSingleAttrs, copiedMediaNode);
  };
};
var isVideo = exports.isVideo = (0, _memoizeOne.default)(function (fileType) {
  return !!fileType && fileType.includes('video');
});