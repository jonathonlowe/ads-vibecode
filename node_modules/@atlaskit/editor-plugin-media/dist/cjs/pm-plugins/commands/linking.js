"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unlink = exports.showLinkingToolbarWithMediaTypeCheck = exports.showLinkingToolbar = exports.setUrlToMedia = exports.hideLinkingToolbar = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _commands = require("@atlaskit/editor-common/commands");
var _utils = require("@atlaskit/editor-common/utils");
var _linking = require("../linking");
var _actions = require("../linking/actions");
var _main = require("../main");
var _checkMediaType = require("../utils/check-media-type");
var _currentMediaNode = require("../utils/current-media-node");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var showLinkingToolbar = exports.showLinkingToolbar = (0, _linking.createMediaLinkingCommand)(function (state) {
  var mediaLinkingState = (0, _linking.getMediaLinkingState)(state);
  if (mediaLinkingState && mediaLinkingState.mediaPos !== null) {
    var node = state.doc.nodeAt(mediaLinkingState.mediaPos);
    if (node) {
      return {
        type: _actions.MediaLinkingActionsTypes.showToolbar
      };
    }
  }
  return false;
});
var showLinkingToolbarWithMediaTypeCheck = exports.showLinkingToolbarWithMediaTypeCheck = function showLinkingToolbarWithMediaTypeCheck(editorState, dispatch, editorView) {
  if (dispatch && editorView) {
    var mediaNode = (0, _currentMediaNode.currentMediaNode)(editorState);
    var mediaInlineNode = (0, _currentMediaNode.currentMediaInlineNode)(editorState);
    var nodeSelection = editorState.selection;
    var currentSelectedNode = nodeSelection.node;
    if (!mediaNode && !mediaInlineNode) {
      return false;
    }
    var _getMediaPluginState = (0, _main.getMediaPluginState)(editorState),
      mediaClientConfig = _getMediaPluginState.mediaClientConfig;
    if (!mediaClientConfig) {
      return false;
    }
    if (mediaNode && currentSelectedNode !== mediaInlineNode) {
      (0, _checkMediaType.checkMediaType)(mediaNode, mediaClientConfig).then(function (mediaType) {
        if ((mediaType === 'external' || mediaType === 'image') &&
        // We make sure the selection and the node hasn't changed.
        (0, _currentMediaNode.currentMediaNode)(editorView.state) === mediaNode) {
          dispatch(editorView.state.tr.setMeta(_linking.mediaLinkingPluginKey, {
            type: _actions.MediaLinkingActionsTypes.showToolbar
          }));
        }
      });
    }
    if (mediaInlineNode) {
      (0, _checkMediaType.checkMediaType)(mediaInlineNode, mediaClientConfig).then(function (mediaType) {
        if ((mediaType === 'external' || mediaType === 'image') &&
        // We make sure the selection and the node hasn't changed.
        (0, _currentMediaNode.currentMediaInlineNode)(editorView.state) === mediaInlineNode) {
          dispatch(editorView.state.tr.setMeta(_linking.mediaLinkingPluginKey, {
            type: _actions.MediaLinkingActionsTypes.showToolbar
          }));
        }
      });
    }
  }
  return true;
};
var hideLinkingToolbarCommand = (0, _linking.createMediaLinkingCommand)({
  type: _actions.MediaLinkingActionsTypes.hideToolbar
});
var hideLinkingToolbar = exports.hideLinkingToolbar = function hideLinkingToolbar(state, dispatch, view, focusFloatingToolbar) {
  hideLinkingToolbarCommand(state, dispatch, view);

  // restore focus on the editor so keyboard shortcuts aren't lost to the browser
  if (view && !focusFloatingToolbar) {
    view.focus();
  }
};
function getCurrentUrl(state) {
  var linkType = state.schema.marks.link;
  var mediaLinkingState = (0, _linking.getMediaLinkingState)(state);
  if (!mediaLinkingState || mediaLinkingState.mediaPos === null) {
    return;
  }
  var $pos = state.doc.resolve(mediaLinkingState.mediaPos);
  var node = state.doc.nodeAt($pos.pos);
  if (!node) {
    return;
  }
  var hasLink = linkType.isInSet(node.marks);
  if (!hasLink) {
    return;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var link = node.marks.find(function (mark) {
    return mark.type === linkType;
  }); // Already check exist
  var url = link.attrs.href;
  return url;
}
function toggleLinkMark(tr, state, _ref) {
  var _ref$forceRemove = _ref.forceRemove,
    forceRemove = _ref$forceRemove === void 0 ? false : _ref$forceRemove,
    url = _ref.url;
  var mediaLinkingState = (0, _linking.getMediaLinkingState)(state);
  if (!mediaLinkingState || mediaLinkingState.mediaPos === null) {
    return tr;
  }
  var $pos = state.doc.resolve(mediaLinkingState.mediaPos);
  var node = state.doc.nodeAt($pos.pos);
  if (!node) {
    return tr;
  }
  var linkMark = state.schema.marks.link;
  var _state$schema$nodes = state.schema.nodes,
    media = _state$schema$nodes.media,
    mediaInline = _state$schema$nodes.mediaInline;
  if (node.type !== mediaInline) {
    var toggleBlockLinkMark = (0, _commands.createToggleBlockMarkOnRange)(linkMark, function (prevAttrs, node) {
      // Only add mark to media
      if (!node || node.type !== media) {
        return; //No op
      }
      if (forceRemove) {
        return false;
      }
      var href = (0, _utils.normalizeUrl)(url);
      if (prevAttrs && prevAttrs.href === href) {
        return; //No op
      }
      if (href.trim() === '') {
        return false; // remove
      }
      return _objectSpread(_objectSpread({}, prevAttrs), {}, {
        href: href
      });
    }, [media]);
    toggleBlockLinkMark($pos.pos, $pos.pos + node.nodeSize, tr, state);
  }
  var toggleInlineLinkMark = (0, _commands.createToggleInlineMarkOnRange)(linkMark, function (prevAttrs, node) {
    // Only add mark to mediaInline
    if (!node || node.type !== mediaInline) {
      return; //No op
    }
    if (forceRemove) {
      return false;
    }
    var href = (0, _utils.normalizeUrl)(url);
    if (prevAttrs && prevAttrs.href === href) {
      return; //No op
    }
    if (href.trim() === '') {
      return false; // remove
    }
    return _objectSpread(_objectSpread({}, prevAttrs), {}, {
      href: href
    });
  });
  toggleInlineLinkMark($pos.pos, $pos.pos + node.nodeSize, tr, state);
  return tr;
}
var fireAnalyticForMediaLink = function fireAnalyticForMediaLink(tr, action) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var editorAnalyticsAPI = arguments.length > 3 ? arguments[3] : undefined;
  editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
    action: action,
    eventType: _analytics.EVENT_TYPE.TRACK,
    actionSubject: _analytics.ACTION_SUBJECT.MEDIA,
    actionSubjectId: _analytics.ACTION_SUBJECT_ID.LINK,
    attributes: attributes
  })(tr);
  return tr;
};
var unlink = exports.unlink = function unlink(editorAnalyticsAPI) {
  return (0, _linking.createMediaLinkingCommand)({
    type: _actions.MediaLinkingActionsTypes.unlink
  }, function (tr, state) {
    var transaction = toggleLinkMark(tr, state, {
      forceRemove: true
    });
    return fireAnalyticForMediaLink(transaction, _analytics.ACTION.DELETED, _objectSpread({}, getNodeTypeAndMediaTypeAttributes(state)), editorAnalyticsAPI);
  });
};
var getAction = function getAction(newUrl, state) {
  var currentUrl = getCurrentUrl(state);
  if (!currentUrl) {
    return _analytics.ACTION.ADDED;
  } else if (newUrl !== currentUrl) {
    return _analytics.ACTION.EDITED;
  }
  return undefined;
};
var getNodeTypeAndMediaTypeAttributes = function getNodeTypeAndMediaTypeAttributes(state) {
  var mediaLinkingState = (0, _linking.getMediaLinkingState)(state);
  var _getMediaPluginState2 = (0, _main.getMediaPluginState)(state),
    allowInlineImages = _getMediaPluginState2.allowInlineImages;
  var _state$schema$nodes2 = state.schema.nodes,
    mediaInline = _state$schema$nodes2.mediaInline,
    mediaSingle = _state$schema$nodes2.mediaSingle;
  if (!mediaLinkingState || mediaLinkingState.mediaPos === null) {
    return;
  }
  var $pos = state.doc.resolve(mediaLinkingState.mediaPos);
  var node = state.doc.nodeAt($pos.pos);
  if (!node) {
    return {};
  }
  if (allowInlineImages && node.type === mediaInline) {
    return {
      type: mediaInline.name,
      mediaType: node.attrs.type
    };
  }
  return {
    type: mediaSingle.name,
    mediaType: node.attrs.type
  };
};
var setUrlToMedia = exports.setUrlToMedia = function setUrlToMedia(url, inputMethod, editorAnalyticsAPI) {
  return (0, _linking.createMediaLinkingCommand)({
    type: _actions.MediaLinkingActionsTypes.setUrl,
    payload: (0, _utils.normalizeUrl)(url)
  }, function (tr, state) {
    var action = getAction(url, state);
    if (!action) {
      return tr;
    }
    var nodeTypeAndMediaTypeAttrs = getNodeTypeAndMediaTypeAttributes(state);
    try {
      var toggleLinkMarkResult = toggleLinkMark(tr, state, {
        url: url
      });
      fireAnalyticForMediaLink(tr, action, action === _analytics.ACTION.ADDED ? _objectSpread({
        inputMethod: inputMethod
      }, nodeTypeAndMediaTypeAttrs) : nodeTypeAndMediaTypeAttrs, editorAnalyticsAPI);
      return toggleLinkMarkResult;
    } catch (e) {
      fireAnalyticForMediaLink(tr, _analytics.ACTION.ERRORED, _objectSpread({
        action: action
      }, nodeTypeAndMediaTypeAttrs), editorAnalyticsAPI);
      throw e;
    }
  });
};