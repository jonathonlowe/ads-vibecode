"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommentBadgeNextWrapper = exports.CommentBadge = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactIntlNext = require("react-intl-next");
var _analytics = require("@atlaskit/editor-common/analytics");
var _hooks = require("@atlaskit/editor-common/hooks");
var _mediaSingle = require("@atlaskit/editor-common/media-single");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var CommentBadgeWrapper = function CommentBadgeWrapper(_ref) {
  var api = _ref.api,
    mediaNode = _ref.mediaNode,
    view = _ref.view,
    getPos = _ref.getPos,
    intl = _ref.intl,
    isDrafting = _ref.isDrafting,
    badgeOffsetRight = _ref.badgeOffsetRight;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    entered = _useState2[0],
    setEntered = _useState2[1];
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(api, ['annotation']),
    annotationState = _useSharedPluginState.annotationState;
  var _view$state$schema = view.state.schema,
    media = _view$state$schema.nodes.media,
    annotation = _view$state$schema.marks.annotation,
    state = view.state,
    dispatch = view.dispatch;
  var status = (0, _react.useMemo)(function () {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(function (annotation) {
      return !!mediaNode.marks.find(function (mark) {
        return mark.attrs.id === annotation.id;
      });
    }) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  var onClick = (0, _react.useCallback)(function () {
    if (api.annotation && mediaNode) {
      var showCommentForBlockNode = api.annotation.actions.showCommentForBlockNode;
      showCommentForBlockNode(mediaNode, _analytics.VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  var pos = getPos();
  var hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(function (maybeAnnotation) {
    return maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id];
  });
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }

  /**
   * After performing certain operations like drag and drop,
   * the position may momentarily shift. It will NOT always be an HTML element;
   * it could also be plain text.
   */
  var maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  var mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/_react.default.createElement(_mediaSingle.CommentBadge, {
    badgeOffsetRight: badgeOffsetRight,
    width: mediaNode.attrs.width,
    height: mediaNode.attrs.height,
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    intl: intl,
    status: entered ? 'entered' : status,
    onMouseEnter: function onMouseEnter() {
      return setEntered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setEntered(false);
    }
  });
};
var CommentBadge = exports.CommentBadge = (0, _reactIntlNext.injectIntl)(CommentBadgeWrapper);

/**
 * Remove CommentBadgeWrapper component above
 * and rename CommentBadgeNextWrapper to CommentBadgeWrapper
 * when clean up platform_editor_add_media_from_url_rollout feature flag
 */

var CommentBadgeNextWrapper = exports.CommentBadgeNextWrapper = function CommentBadgeNextWrapper(_ref2) {
  var api = _ref2.api,
    mediaNode = _ref2.mediaNode,
    view = _ref2.view,
    getPos = _ref2.getPos,
    isDrafting = _ref2.isDrafting;
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    entered = _useState4[0],
    setEntered = _useState4[1];
  var _useSharedPluginState2 = (0, _hooks.useSharedPluginState)(api, ['annotation']),
    annotationState = _useSharedPluginState2.annotationState;
  var _view$state$schema2 = view.state.schema,
    media = _view$state$schema2.nodes.media,
    annotation = _view$state$schema2.marks.annotation,
    state = view.state,
    dispatch = view.dispatch;
  var status = (0, _react.useMemo)(function () {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(function (annotation) {
      return !!mediaNode.marks.find(function (mark) {
        return mark.attrs.id === annotation.id;
      });
    }) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  var onClick = (0, _react.useCallback)(function () {
    if (api.annotation && mediaNode) {
      var showCommentForBlockNode = api.annotation.actions.showCommentForBlockNode;
      showCommentForBlockNode(mediaNode, _analytics.VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  var pos = getPos();
  var hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(function (maybeAnnotation) {
    return maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id];
  });
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }
  var maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  var mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/_react.default.createElement(_mediaSingle.CommentBadgeNext, {
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    status: entered ? 'entered' : status,
    onMouseEnter: function onMouseEnter() {
      return setEntered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setEntered(false);
    }
  });
};