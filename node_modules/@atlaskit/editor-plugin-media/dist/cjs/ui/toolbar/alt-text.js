"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAltTextToolbar = exports.getAltTextDropdownOption = exports.altTextButton = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _keymaps = require("@atlaskit/editor-common/keymaps");
var _media = require("@atlaskit/editor-common/media");
var _styles = require("@atlaskit/editor-common/styles");
var _ui = require("@atlaskit/editor-common/ui");
var _state = require("@atlaskit/editor-prosemirror/state");
var _text = _interopRequireDefault(require("@atlaskit/icon/core/text"));
var _commands = require("../../pm-plugins/alt-text/commands");
var _AltTextEdit = _interopRequireDefault(require("../../pm-plugins/alt-text/ui/AltTextEdit"));
var _isType = require("../../pm-plugins/utils/is-type");
var _mediaCommon = require("../../pm-plugins/utils/media-common");
var _commands2 = require("./commands");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var testId = 'alt-text-edit-button';
var altTextButton = exports.altTextButton = function altTextButton(intl, state, editorAnalyticsAPI) {
  var mediaNode = (0, _mediaCommon.getMediaSingleOrInlineNodeFromSelection)(state);
  var message = mediaNode && mediaNode.attrs.alt ? _media.altTextMessages.editAltText : _media.altTextMessages.altText;
  var title = intl.formatMessage(message);
  return {
    title: title,
    id: 'editor.media.altText',
    type: 'button',
    onClick: (0, _commands.openMediaAltTextMenu)(editorAnalyticsAPI),
    showTitle: true,
    testId: testId,
    tooltipContent: /*#__PURE__*/_react.default.createElement(_keymaps.ToolTipContent, {
      description: title,
      keymap: _keymaps.addAltText
    })
  };
};
var altTextEditComponent = function altTextEditComponent(options) {
  return {
    type: 'custom',
    fallback: [],
    disableArrowNavigation: true,
    render: function render(view, idx) {
      if (!view) {
        return null;
      }
      var state = view.state;
      var mediaNode = (0, _mediaCommon.getMediaSingleOrInlineNodeFromSelection)(state);
      if (!mediaNode) {
        return null;
      }
      /** Focus should move to the 'Alt text' button when the toolbar closes
       * and not close the floating toolbar.
       */
      var handleEsc = function handleEsc() {
        var _options$forceFocusSe;
        var tr = view.state.tr,
          dispatch = view.dispatch;
        var newTr = options === null || options === void 0 || (_options$forceFocusSe = options.forceFocusSelector) === null || _options$forceFocusSe === void 0 ? void 0 : _options$forceFocusSe.call(options, "[data-testid=\"".concat(testId, "\"]"))(tr);
        if (newTr) {
          dispatch(newTr);
        }
      };
      var type = (0, _commands2.getNodeType)(state);
      return /*#__PURE__*/_react.default.createElement(_AltTextEdit.default, {
        view: view,
        key: idx,
        nodeType: type,
        mediaType: mediaNode.attrs.type,
        value: mediaNode.attrs.alt,
        altTextValidator: options && options.altTextValidator,
        onEscape: handleEsc
      });
    }
  };
};
var getAltTextToolbar = exports.getAltTextToolbar = function getAltTextToolbar(toolbarBaseConfig, options) {
  return _objectSpread(_objectSpread({}, toolbarBaseConfig), {}, {
    width: _ui.RECENT_SEARCH_WIDTH_IN_PX,
    className: _styles.MediaSharedClassNames.FLOATING_TOOLBAR_COMPONENT,
    items: [altTextEditComponent(options)]
  });
};
var getAltTextDropdownOption = exports.getAltTextDropdownOption = function getAltTextDropdownOption(state, formatMessage, allowAltTextOnImages, selectedNodeType, editorAnalyticsAPI) {
  var _state$schema$nodes = state.schema.nodes,
    mediaSingle = _state$schema$nodes.mediaSingle,
    mediaInline = _state$schema$nodes.mediaInline;
  var mediaType = state.selection instanceof _state.NodeSelection && state.selection.node.attrs.type;
  if (allowAltTextOnImages && (selectedNodeType === mediaSingle || selectedNodeType === mediaInline && (0, _isType.isImage)(mediaType))) {
    return [{
      title: formatMessage(_media.altTextMessages.addAltText),
      onClick: (0, _commands.openMediaAltTextMenu)(editorAnalyticsAPI),
      icon: /*#__PURE__*/_react.default.createElement(_text.default, {
        label: ""
      }),
      testId: 'media-alt-text-dropdown-option'
    }];
  }
  return [];
};