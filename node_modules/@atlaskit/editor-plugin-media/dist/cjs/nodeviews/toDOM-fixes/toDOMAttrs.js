"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaAttrs = exports.getAttrsFromNodeMediaSingle = exports.camelCaseToKebabCase = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _colors = require("@atlaskit/theme/colors");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * Copied from `packages/adf-schema/src/schema/nodes/media.ts`
 *
 * When we patch adf-schema with media `toDOM` fixes we can remove this.
 */
var getMediaAttrs = exports.getMediaAttrs = function getMediaAttrs(nodeName, node) {
  var copyPrivateAttributes = function copyPrivateAttributes(from, to, map) {
    if (node.attrs) {
      Object.keys(node.attrs).forEach(function (key) {
        if (key[0] === '_' && key[1] === '_' && from[key]) {
          to[map ? map(key) : key] = from[key];
        }
      });
    }
  };
  var attrs = {
    'data-id': node.attrs.id,
    'data-node-type': "".concat(nodeName),
    'data-type': node.attrs.type,
    'data-collection': node.attrs.collection,
    'data-occurrence-key': node.attrs.occurrenceKey,
    'data-width': node.attrs.width,
    'data-height': node.attrs.height,
    'data-url': node.attrs.url,
    'data-alt': node.attrs.alt,
    // toDOM is used for static rendering as well as editor rendering. This comes into play for
    // emails, copy/paste, etc, so the title and styling here *is* useful (despite a React-based
    // node view being used for editing).
    title: 'Attachment',
    // Manually kept in sync with the style of media cards. The goal is to render a plain gray
    // rectangle that provides an affordance for media.
    style: "display: inline-block; border-radius: 3px; background: ".concat(_colors.N30, "; box-shadow: 0 1px 1px rgba(9, 30, 66, 0.2), 0 0 1px 0 rgba(9, 30, 66, 0.24);")
  };
  copyPrivateAttributes(node.attrs, attrs, function (key) {
    return "data-".concat(camelCaseToKebabCase(key.slice(2)));
  });
  return attrs;
};
var camelCaseToKebabCase = exports.camelCaseToKebabCase = function camelCaseToKebabCase(str) {
  return (
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    str.replace(/([^A-Z]+)([A-Z])/g, function (_, x, y) {
      return "".concat(x, "-").concat(y.toLowerCase());
    })
  );
};

/**
 * Copied from `packages/adf-schema/src/schema/nodes/media-single.ts`
 *
 * When we patch adf-schema with media `toDOM` fixes we can remove this.
 */
var getAttrsFromNodeMediaSingle = exports.getAttrsFromNodeMediaSingle = function getAttrsFromNodeMediaSingle(withExtendedWidthTypes, node) {
  var _node$attrs = node.attrs,
    layout = _node$attrs.layout,
    width = _node$attrs.width;
  var attrs = {
    'data-node-type': 'mediaSingle',
    'data-layout': layout
  };
  if (width) {
    attrs['data-width'] = isFinite(width) && Math.floor(width) === width ? width : width.toFixed(2);
  }
  var widthType = node.attrs.widthType;
  return _objectSpread(_objectSpread({}, attrs), {}, {
    'data-width-type': widthType || 'percentage'
  });
};