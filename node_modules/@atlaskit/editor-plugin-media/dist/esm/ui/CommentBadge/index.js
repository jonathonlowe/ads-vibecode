import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useMemo, useState } from 'react';
import { injectIntl } from 'react-intl-next';
import { VIEW_METHOD } from '@atlaskit/editor-common/analytics';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { CommentBadge as CommentBadgeComponent, CommentBadgeNext } from '@atlaskit/editor-common/media-single';
var CommentBadgeWrapper = function CommentBadgeWrapper(_ref) {
  var api = _ref.api,
    mediaNode = _ref.mediaNode,
    view = _ref.view,
    getPos = _ref.getPos,
    intl = _ref.intl,
    isDrafting = _ref.isDrafting,
    badgeOffsetRight = _ref.badgeOffsetRight;
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    entered = _useState2[0],
    setEntered = _useState2[1];
  var _useSharedPluginState = useSharedPluginState(api, ['annotation']),
    annotationState = _useSharedPluginState.annotationState;
  var _view$state$schema = view.state.schema,
    media = _view$state$schema.nodes.media,
    annotation = _view$state$schema.marks.annotation,
    state = view.state,
    dispatch = view.dispatch;
  var status = useMemo(function () {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(function (annotation) {
      return !!mediaNode.marks.find(function (mark) {
        return mark.attrs.id === annotation.id;
      });
    }) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  var onClick = useCallback(function () {
    if (api.annotation && mediaNode) {
      var showCommentForBlockNode = api.annotation.actions.showCommentForBlockNode;
      showCommentForBlockNode(mediaNode, VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  var pos = getPos();
  var hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(function (maybeAnnotation) {
    return maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id];
  });
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }

  /**
   * After performing certain operations like drag and drop,
   * the position may momentarily shift. It will NOT always be an HTML element;
   * it could also be plain text.
   */
  var maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  var mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/React.createElement(CommentBadgeComponent, {
    badgeOffsetRight: badgeOffsetRight,
    width: mediaNode.attrs.width,
    height: mediaNode.attrs.height,
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    intl: intl,
    status: entered ? 'entered' : status,
    onMouseEnter: function onMouseEnter() {
      return setEntered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setEntered(false);
    }
  });
};
export var CommentBadge = injectIntl(CommentBadgeWrapper);

/**
 * Remove CommentBadgeWrapper component above
 * and rename CommentBadgeNextWrapper to CommentBadgeWrapper
 * when clean up platform_editor_add_media_from_url_rollout feature flag
 */

export var CommentBadgeNextWrapper = function CommentBadgeNextWrapper(_ref2) {
  var api = _ref2.api,
    mediaNode = _ref2.mediaNode,
    view = _ref2.view,
    getPos = _ref2.getPos,
    isDrafting = _ref2.isDrafting;
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    entered = _useState4[0],
    setEntered = _useState4[1];
  var _useSharedPluginState2 = useSharedPluginState(api, ['annotation']),
    annotationState = _useSharedPluginState2.annotationState;
  var _view$state$schema2 = view.state.schema,
    media = _view$state$schema2.nodes.media,
    annotation = _view$state$schema2.marks.annotation,
    state = view.state,
    dispatch = view.dispatch;
  var status = useMemo(function () {
    if (!(annotationState !== null && annotationState !== void 0 && annotationState.selectedAnnotations) || !mediaNode) {
      return 'default';
    }
    return annotationState.selectedAnnotations.some(function (annotation) {
      return !!mediaNode.marks.find(function (mark) {
        return mark.attrs.id === annotation.id;
      });
    }) && !annotationState.isInlineCommentViewClosed ? 'active' : 'default';
  }, [annotationState, mediaNode]);
  var onClick = useCallback(function () {
    if (api.annotation && mediaNode) {
      var showCommentForBlockNode = api.annotation.actions.showCommentForBlockNode;
      showCommentForBlockNode(mediaNode, VIEW_METHOD.BADGE)(state, dispatch);
    }
  }, [api.annotation, dispatch, mediaNode, state]);
  var pos = getPos();
  var hasNoComments = !Number.isFinite(pos) || !(annotationState !== null && annotationState !== void 0 && annotationState.annotations) || !mediaNode || mediaNode.type !== media || mediaNode.marks.every(function (maybeAnnotation) {
    return maybeAnnotation.type !== annotation || !(maybeAnnotation.attrs.id in annotationState.annotations) || annotationState.annotations[maybeAnnotation.attrs.id];
  });
  if (!isDrafting && hasNoComments || !mediaNode) {
    return null;
  }
  var maybeMediaSingleElement = view.domAtPos(pos + 1).node;
  var mediaSingleElement = maybeMediaSingleElement instanceof HTMLElement ? maybeMediaSingleElement : null;
  return /*#__PURE__*/React.createElement(CommentBadgeNext, {
    onClick: onClick,
    mediaSingleElement: mediaSingleElement,
    status: entered ? 'entered' : status,
    onMouseEnter: function onMouseEnter() {
      return setEntered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setEntered(false);
    }
  });
};