import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import { addAltText, ToolTipContent } from '@atlaskit/editor-common/keymaps';
import { altTextMessages as messages } from '@atlaskit/editor-common/media';
import { MediaSharedClassNames as ClassNames } from '@atlaskit/editor-common/styles';
import { RECENT_SEARCH_WIDTH_IN_PX as CONTAINER_WIDTH_IN_PX } from '@atlaskit/editor-common/ui';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import TextIcon from '@atlaskit/icon/core/text';
import { openMediaAltTextMenu } from '../../pm-plugins/alt-text/commands';
import AltTextEdit from '../../pm-plugins/alt-text/ui/AltTextEdit';
import { isImage } from '../../pm-plugins/utils/is-type';
import { getMediaSingleOrInlineNodeFromSelection } from '../../pm-plugins/utils/media-common';
import { getNodeType } from './commands';
var testId = 'alt-text-edit-button';
export var altTextButton = function altTextButton(intl, state, editorAnalyticsAPI) {
  var mediaNode = getMediaSingleOrInlineNodeFromSelection(state);
  var message = mediaNode && mediaNode.attrs.alt ? messages.editAltText : messages.altText;
  var title = intl.formatMessage(message);
  return {
    title: title,
    id: 'editor.media.altText',
    type: 'button',
    onClick: openMediaAltTextMenu(editorAnalyticsAPI),
    showTitle: true,
    testId: testId,
    tooltipContent: /*#__PURE__*/React.createElement(ToolTipContent, {
      description: title,
      keymap: addAltText
    })
  };
};
var altTextEditComponent = function altTextEditComponent(options) {
  return {
    type: 'custom',
    fallback: [],
    disableArrowNavigation: true,
    render: function render(view, idx) {
      if (!view) {
        return null;
      }
      var state = view.state;
      var mediaNode = getMediaSingleOrInlineNodeFromSelection(state);
      if (!mediaNode) {
        return null;
      }
      /** Focus should move to the 'Alt text' button when the toolbar closes
       * and not close the floating toolbar.
       */
      var handleEsc = function handleEsc() {
        var _options$forceFocusSe;
        var tr = view.state.tr,
          dispatch = view.dispatch;
        var newTr = options === null || options === void 0 || (_options$forceFocusSe = options.forceFocusSelector) === null || _options$forceFocusSe === void 0 ? void 0 : _options$forceFocusSe.call(options, "[data-testid=\"".concat(testId, "\"]"))(tr);
        if (newTr) {
          dispatch(newTr);
        }
      };
      var type = getNodeType(state);
      return /*#__PURE__*/React.createElement(AltTextEdit, {
        view: view,
        key: idx,
        nodeType: type,
        mediaType: mediaNode.attrs.type,
        value: mediaNode.attrs.alt,
        altTextValidator: options && options.altTextValidator,
        onEscape: handleEsc
      });
    }
  };
};
export var getAltTextToolbar = function getAltTextToolbar(toolbarBaseConfig, options) {
  return _objectSpread(_objectSpread({}, toolbarBaseConfig), {}, {
    width: CONTAINER_WIDTH_IN_PX,
    className: ClassNames.FLOATING_TOOLBAR_COMPONENT,
    items: [altTextEditComponent(options)]
  });
};
export var getAltTextDropdownOption = function getAltTextDropdownOption(state, formatMessage, allowAltTextOnImages, selectedNodeType, editorAnalyticsAPI) {
  var _state$schema$nodes = state.schema.nodes,
    mediaSingle = _state$schema$nodes.mediaSingle,
    mediaInline = _state$schema$nodes.mediaInline;
  var mediaType = state.selection instanceof NodeSelection && state.selection.node.attrs.type;
  if (allowAltTextOnImages && (selectedNodeType === mediaSingle || selectedNodeType === mediaInline && isImage(mediaType))) {
    return [{
      title: formatMessage(messages.addAltText),
      onClick: openMediaAltTextMenu(editorAnalyticsAPI),
      icon: /*#__PURE__*/React.createElement(TextIcon, {
        label: ""
      }),
      testId: 'media-alt-text-dropdown-option'
    }];
  }
  return [];
};