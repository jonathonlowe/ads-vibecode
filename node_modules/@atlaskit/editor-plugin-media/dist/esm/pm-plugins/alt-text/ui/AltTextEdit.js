import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

import React from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { injectIntl } from 'react-intl-next';
import { withAnalyticsEvents } from '@atlaskit/analytics-next';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, fireAnalyticsEvent } from '@atlaskit/editor-common/analytics';
import { escape, ToolTipContent } from '@atlaskit/editor-common/keymaps';
import { altTextMessages as messages } from '@atlaskit/editor-common/media';
import { RECENT_SEARCH_WIDTH_IN_PX as CONTAINER_WIDTH_IN_PX, FloatingToolbarButton as Button, ErrorMessage, PanelTextInput } from '@atlaskit/editor-common/ui';
import { relativeFontSizeToBase16 } from '@atlaskit/editor-shared-styles';
import CrossCircleIcon from '@atlaskit/icon/core/migration/cross-circle';
import ChevronLeftLargeIcon from '@atlaskit/icon/utility/migration/chevron-left--chevron-left-large';
import { N200, N30, N80, R400 } from '@atlaskit/theme/colors';
import { closeMediaAltTextMenu, closeMediaAltTextMenuAndSave } from '../commands';
export var MAX_ALT_TEXT_LENGTH = 510; // double tweet length

var supportTextStyles = css({
  color: "var(--ds-text-subtlest, ".concat(N200, ")"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  fontSize: relativeFontSizeToBase16(12),
  padding: "var(--ds-space-150, 12px)".concat(" ", "var(--ds-space-500, 40px)"),
  // eslint-disable-next-line @atlaskit/design-system/use-tokens-typography
  lineHeight: '20px',
  borderTop: "1px solid ".concat("var(--ds-border, ".concat(N30, ")")),
  margin: 0
});
var containerStyles = css({
  // eslint-disable-next-line  @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  width: "".concat(CONTAINER_WIDTH_IN_PX, "px"),
  display: 'flex',
  flexDirection: 'column',
  overflow: 'auto',
  // eslint-disable-next-line @atlaskit/design-system/use-tokens-typography
  lineHeight: 2
});
var inputWrapperStyles = css({
  display: 'flex',
  // eslint-disable-next-line @atlaskit/design-system/use-tokens-typography
  lineHeight: 0,
  padding: "var(--ds-space-075, 6px)".concat(" 0"),
  alignItems: 'center'
});
var validationWrapperStyles = css({
  display: 'flex',
  // eslint-disable-next-line @atlaskit/design-system/use-tokens-typography
  lineHeight: 0,
  padding: "var(--ds-space-150, 12px)".concat(" ", "var(--ds-space-300, 24px)", " ", "var(--ds-space-150, 12px)", " 0"),
  margin: "0 ".concat("var(--ds-space-150, 12px)", " 0 ", "var(--ds-space-500, 40px)"),
  borderTop: "1px solid ".concat("var(--ds-border-danger, ".concat(R400, ")")),
  alignItems: 'start',
  flexDirection: 'column'
});
var buttonWrapperStyles = css({
  display: 'flex',
  padding: "var(--ds-space-050, 4px)".concat(" ", "var(--ds-space-100, 8px)")
});
var clearTextStyles = css({
  color: "var(--ds-icon-subtle, ".concat(N80, ")")
});
// eslint-disable-next-line @repo/internal/react/no-class-components
export var AltTextEditComponent = /*#__PURE__*/function (_React$Component) {
  function AltTextEditComponent(props) {
    var _this;
    _classCallCheck(this, AltTextEditComponent);
    _this = _callSuper(this, AltTextEditComponent, [props]);
    _defineProperty(_this, "state", {
      showClearTextButton: Boolean(_this.props.value),
      validationErrors: _this.props.value ? _this.getValidationErrors(_this.props.value) : [],
      lastValue: _this.props.value
    });
    _defineProperty(_this, "closeMediaAltTextMenu", function () {
      var view = _this.props.view;
      if (_this.state.validationErrors.length === 0) {
        closeMediaAltTextMenuAndSave(_this.state.lastValue || '')(view.state, view.dispatch);
      } else {
        closeMediaAltTextMenu(view.state, view.dispatch);
      }
    });
    _defineProperty(_this, "dispatchCancelEvent", function (event) {
      var _this$props = _this.props,
        view = _this$props.view,
        onEscape = _this$props.onEscape;

      // We need to pass down the ESCAPE keymap
      // because when we focus on the Toolbar, Prosemirror blur,
      // making all keyboard shortcuts not working
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      view.someProp('handleKeyDown', function (fn) {
        return fn(view, event);
      });
      onEscape === null || onEscape === void 0 || onEscape();
    });
    _defineProperty(_this, "handleOnChange", function (newAltText) {
      var _this$state;
      var validationErrors = _this.getValidationErrors(newAltText);
      if (((_this$state = _this.state) === null || _this$state === void 0 || (_this$state = _this$state.validationErrors) === null || _this$state === void 0 ? void 0 : _this$state.length) !== (validationErrors === null || validationErrors === void 0 ? void 0 : validationErrors.length)) {
        // If number of errors was changed we need to reset attribute to get new SR announcement

        if (_this.errorsListRef) {
          var _this$errorsListRef;
          var errorsArea = (_this$errorsListRef = _this.errorsListRef) === null || _this$errorsListRef === void 0 ? void 0 : _this$errorsListRef.current;
          errorsArea === null || errorsArea === void 0 || errorsArea.removeAttribute('aria-live');
          errorsArea === null || errorsArea === void 0 || errorsArea.setAttribute('aria-live', 'assertive');
        }
      }
      _this.setState({
        showClearTextButton: Boolean(newAltText),
        validationErrors: validationErrors,
        lastValue: newAltText
      });
    });
    _defineProperty(_this, "handleOnBlur", function (e) {
      // prevent other selection transaction gets triggered
      e.stopPropagation();
      _this.closeMediaAltTextMenu();
    });
    _defineProperty(_this, "handleClearText", function () {
      _this.handleOnChange('');
    });
    var createAnalyticsEvent = props.createAnalyticsEvent;
    _this.fireCustomAnalytics = fireAnalyticsEvent(createAnalyticsEvent);
    _this.errorsListRef = /*#__PURE__*/React.createRef();
    return _this;
  }
  _inherits(AltTextEditComponent, _React$Component);
  return _createClass(AltTextEditComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.prevValue = this.props.value;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.fireAnalytics(ACTION.CLOSED);
      if (!this.prevValue && this.state.lastValue) {
        this.fireAnalytics(ACTION.ADDED);
      }
      if (this.prevValue && !this.state.lastValue) {
        this.fireAnalytics(ACTION.CLEARED);
      }
      if (this.prevValue && this.prevValue !== this.state.lastValue) {
        this.fireAnalytics(ACTION.EDITED);
      }
    }
  }, {
    key: "getValidationErrors",
    value: function getValidationErrors(value) {
      var altTextValidator = this.props.altTextValidator;
      if (value && typeof altTextValidator === 'function') {
        return altTextValidator(value) || [];
      }
      return [];
    }
  }, {
    key: "render",
    value: function render() {
      var formatMessage = this.props.intl.formatMessage;
      var showClearTextButton = this.state.showClearTextButton;
      var backButtonMessage = formatMessage(messages.back);
      var backButtonMessageComponent = jsx(ToolTipContent, {
        description: backButtonMessage,
        keymap: escape,
        shortcutOverride: "Esc"
      });
      var errorsList = (this.state.validationErrors || []).map(function (error, index) {
        // Ignored via go/ees005
        // eslint-disable-next-line react/no-array-index-key
        return jsx(ErrorMessage, {
          key: index
        }, error);
      });
      var hasErrors = !!errorsList.length;
      return jsx("div", {
        css: containerStyles
      }, jsx("section", {
        css: inputWrapperStyles
      }, jsx("div", {
        css: buttonWrapperStyles
      }, jsx(Button, {
        title: formatMessage(messages.back),
        icon: jsx(ChevronLeftLargeIcon, {
          label: formatMessage(messages.back)
        }),
        tooltipContent: backButtonMessageComponent,
        onClick: this.closeMediaAltTextMenu
      })), jsx(PanelTextInput, {
        testId: "alt-text-input",
        ariaLabel: formatMessage(messages.placeholder),
        describedById: "".concat(hasErrors ? 'errors-list' : '', " support-text"),
        placeholder: formatMessage(messages.placeholder),
        defaultValue: this.state.lastValue,
        onCancel: this.dispatchCancelEvent,
        onChange: this.handleOnChange,
        onBlur: this.handleOnBlur,
        onSubmit: this.closeMediaAltTextMenu,
        maxLength: MAX_ALT_TEXT_LENGTH,
        ariaRequired: true,
        ariaInvalid: hasErrors,
        autoFocus: true
      }), showClearTextButton && jsx("div", {
        css: buttonWrapperStyles
      }, jsx(Button, {
        testId: "alt-text-clear-button",
        title: formatMessage(messages.clear),
        icon: jsx("span", {
          css: clearTextStyles
        }, jsx(CrossCircleIcon, {
          label: formatMessage(messages.clear)
        })),
        tooltipContent: formatMessage(messages.clear),
        onClick: this.handleClearText
      }))), hasErrors && jsx("section", {
        id: "errors-list",
        ref: this.errorsListRef,
        "aria-live": "assertive",
        css: validationWrapperStyles
      }, errorsList), jsx("p", {
        css: supportTextStyles,
        id: "support-text"
      }, formatMessage(messages.supportText)));
    }
  }, {
    key: "fireAnalytics",
    value: function fireAnalytics(actionType) {
      var _this$props2 = this.props,
        createAnalyticsEvent = _this$props2.createAnalyticsEvent,
        nodeType = _this$props2.nodeType,
        mediaType = _this$props2.mediaType;
      if (createAnalyticsEvent && this.fireCustomAnalytics) {
        this.fireCustomAnalytics({
          payload: {
            action: actionType,
            actionSubject: ACTION_SUBJECT.MEDIA,
            actionSubjectId: ACTION_SUBJECT_ID.ALT_TEXT,
            eventType: EVENT_TYPE.TRACK,
            attributes: {
              type: nodeType,
              mediaType: mediaType
            }
          }
        });
      }
    }
  }]);
}(React.Component);
export default withAnalyticsEvents()(injectIntl(AltTextEditComponent));