import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { useEffect, useMemo, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { MediaInlineImageCard } from '@atlaskit/editor-common/media-inline';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { SelectionBasedNodeView } from '@atlaskit/editor-common/selection-based-node-view';
import { MediaInlineCard } from '@atlaskit/media-card';
import { getMediaClient } from '@atlaskit/media-client-react';
import { MediaInlineCardLoadingView } from '@atlaskit/media-ui';
import { fg } from '@atlaskit/platform-feature-flags';
import { isImage } from '../pm-plugins/utils/is-type';
import { MediaViewerContainer } from '../ui/MediaViewer/MediaViewerContainer';
import { MediaNodeUpdater } from './mediaNodeUpdater';
var createMediaNodeUpdater = function createMediaNodeUpdater(props) {
  var node = props.node;
  return new MediaNodeUpdater(_objectSpread(_objectSpread({}, props), {}, {
    isMediaSingle: true,
    node: node ? node : props.node,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    contextIdentifierProvider: props.contextIdentifierProvider
  }));
};

/**
 * Handles updating the media inline node attributes
 * but also handling copy-paste for cross-editor of the same instance
 * using the contextid
 *
 */
var updateMediaNodeAttributes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(props, mediaNodeUpdater) {
    var addPendingTask, node, contextId, shouldNodeBeDeepCopied, copyNode;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          addPendingTask = props.mediaPluginState.addPendingTask;
          node = props.node;
          if (node) {
            _context.next = 4;
            break;
          }
          return _context.abrupt("return");
        case 4:
          contextId = mediaNodeUpdater.getNodeContextId();
          if (contextId) {
            _context.next = 8;
            break;
          }
          _context.next = 8;
          return mediaNodeUpdater.updateContextId();
        case 8:
          _context.next = 10;
          return mediaNodeUpdater.shouldNodeBeDeepCopied();
        case 10:
          shouldNodeBeDeepCopied = _context.sent;
          if (!shouldNodeBeDeepCopied) {
            _context.next = 22;
            break;
          }
          _context.prev = 12;
          copyNode = mediaNodeUpdater.copyNode({
            traceId: node.attrs.__mediaTraceId
          });
          addPendingTask(copyNode);
          _context.next = 17;
          return copyNode;
        case 17:
          _context.next = 22;
          break;
        case 19:
          _context.prev = 19;
          _context.t0 = _context["catch"](12);
          return _context.abrupt("return");
        case 22:
          _context.next = 24;
          return mediaNodeUpdater.updateMediaSingleFileAttrs();
        case 24:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[12, 19]]);
  }));
  return function updateMediaNodeAttributes(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
export var handleNewNode = function handleNewNode(props) {
  var node = props.node,
    mediaPluginState = props.mediaPluginState,
    getPos = props.getPos;
  mediaPluginState.handleMediaNodeMount(node, function () {
    return getPos();
  });
};
export var MediaInline = function MediaInline(props) {
  var _props$node;
  var _useState = useState(),
    _useState2 = _slicedToArray(_useState, 2),
    viewMediaClientConfig = _useState2[0],
    setViewMediaClientConfig = _useState2[1];
  var _useState3 = useState(true),
    _useState4 = _slicedToArray(_useState3, 2),
    isNodeScopeUnsync = _useState4[0],
    setIsNodeScopeUnsync = _useState4[1];
  useEffect(function () {
    var mediaNodeUpdater = createMediaNodeUpdater(props);
    mediaNodeUpdater.shouldNodeBeDeepCopied().then(setIsNodeScopeUnsync);
    handleNewNode(props);
    updateMediaNodeAttributes(props, mediaNodeUpdater);
    updateViewMediaClientConfig(props);
    return function () {
      var mediaPluginState = props.mediaPluginState;
      mediaPluginState.handleMediaNodeUnmount(props.node);
    };
  }, [props]);
  var updateViewMediaClientConfig = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
      var mediaProvider, _viewMediaClientConfig;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return props.mediaProvider;
          case 2:
            mediaProvider = _context2.sent;
            if (mediaProvider) {
              _viewMediaClientConfig = mediaProvider.viewMediaClientConfig;
              setViewMediaClientConfig(_viewMediaClientConfig);
            }
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function updateViewMediaClientConfig(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var _props$node$attrs = props.node.attrs,
    id = _props$node$attrs.id,
    collection = _props$node$attrs.collection,
    type = _props$node$attrs.type,
    alt = _props$node$attrs.alt,
    width = _props$node$attrs.width,
    height = _props$node$attrs.height;
  var identifier = {
    id: id,
    mediaItemType: 'file',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    collectionName: collection
  };

  /*
   * Show the loading view if
   * 1. The media provider is not ready
   * 2. Context Id is not synced
   * to prevent calling the media API (in mounting of `MediaInlineCard`)
   * before the prerequisites meet
   */
  if (!viewMediaClientConfig || isNodeScopeUnsync) {
    return jsx(MediaInlineCardLoadingView, {
      message: "",
      isSelected: false
    });
  }
  var allowInlineImages = props.mediaPluginState.allowInlineImages;
  var borderMark = (_props$node = props.node) === null || _props$node === void 0 || (_props$node = _props$node.marks) === null || _props$node === void 0 ? void 0 : _props$node.find(function (mark) {
    return mark.type.name === 'border';
  });
  if (allowInlineImages && isImage(type)) {
    return jsx(MediaInlineImageCard, {
      mediaClient: getMediaClient(viewMediaClientConfig),
      identifier: identifier,
      isSelected: props.isSelected,
      alt: alt,
      width: width,
      height: height,
      border: {
        borderSize: borderMark === null || borderMark === void 0 ? void 0 : borderMark.attrs.size,
        borderColor: borderMark === null || borderMark === void 0 ? void 0 : borderMark.attrs.color
      },
      isViewOnly: props.editorViewMode
    });
  }
  return jsx(MediaViewerContainer, {
    mediaNode: props.node,
    mediaPluginState: props.mediaPluginState,
    isEditorViewMode: props.editorViewMode,
    isSelected: props.isSelected,
    isInline: fg('platform_editor_render_media_viewer_as_inline')
  }, jsx(MediaInlineCard, {
    isSelected: props.isSelected,
    identifier: identifier,
    mediaClientConfig: viewMediaClientConfig
  }));
};
var MediaInlineSharedState = function MediaInlineSharedState(_ref3) {
  var identifier = _ref3.identifier,
    node = _ref3.node,
    isSelected = _ref3.isSelected,
    getPos = _ref3.getPos,
    contextIdentifierProvider = _ref3.contextIdentifierProvider,
    api = _ref3.api,
    view = _ref3.view;
  var _useSharedPluginState = useSharedPluginState(api, ['editorViewMode', 'media']),
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    mediaState = _useSharedPluginState.mediaState;
  var newMediaProvider = useMemo(function () {
    return mediaState !== null && mediaState !== void 0 && mediaState.mediaProvider ? Promise.resolve(mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider) : undefined;
  }, [mediaState === null || mediaState === void 0 ? void 0 : mediaState.mediaProvider]);
  if (!mediaState || !newMediaProvider) {
    return null;
  }
  return jsx(MediaInline, {
    identifier: identifier,
    mediaProvider: newMediaProvider,
    mediaPluginState: mediaState,
    node: node,
    isSelected: isSelected,
    view: view,
    getPos: getPos,
    contextIdentifierProvider: contextIdentifierProvider,
    editorViewMode: (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view'
  });
};
export var MediaInlineNodeView = /*#__PURE__*/function (_SelectionBasedNodeVi) {
  function MediaInlineNodeView() {
    _classCallCheck(this, MediaInlineNodeView);
    return _callSuper(this, MediaInlineNodeView, arguments);
  }
  _inherits(MediaInlineNodeView, _SelectionBasedNodeVi);
  return _createClass(MediaInlineNodeView, [{
    key: "createDomRef",
    value: function createDomRef() {
      var domRef = document.createElement('span');
      domRef.contentEditable = 'false';
      return domRef;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation() {
      return true;
    }
  }, {
    key: "viewShouldUpdate",
    value: function viewShouldUpdate(nextNode) {
      if (this.node.attrs !== nextNode.attrs) {
        return true;
      }
      return _superPropGet(MediaInlineNodeView, "viewShouldUpdate", this, 3)([nextNode]);
    }
  }, {
    key: "render",
    value: function render(props) {
      var _this = this;
      var providerFactory = props.providerFactory,
        api = props.api;
      var view = this.view;
      var getPos = this.getPos;
      return jsx(WithProviders, {
        providers: ['contextIdentifierProvider'],
        providerFactory: providerFactory,
        renderNode: function renderNode(_ref4) {
          var mediaProvider = _ref4.mediaProvider,
            contextIdentifierProvider = _ref4.contextIdentifierProvider;
          return jsx(MediaInlineSharedState, {
            identifier: _this.node.attrs.id,
            node: _this.node,
            isSelected: _this.nodeInsideSelection(),
            view: view,
            getPos: getPos,
            contextIdentifierProvider: contextIdentifierProvider,
            api: api
          });
        }
      });
    }
  }]);
}(SelectionBasedNodeView);
export var ReactMediaInlineNode = function ReactMediaInlineNode(portalProviderAPI, eventDispatcher, providerFactory, api, dispatchAnalyticsEvent) {
  return function (node, view, getPos) {
    return new MediaInlineNodeView(node, view, getPos, portalProviderAPI, eventDispatcher, {
      providerFactory: providerFactory,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      api: api
    }).init();
  };
};