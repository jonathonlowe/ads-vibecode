"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HoverCardComponent = exports.HOVER_CARD_SOURCE = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactIntlNext = require("react-intl-next");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _popup = _interopRequireDefault(require("@atlaskit/popup"));
var _constants = require("../../../constants");
var _messages = require("../../../messages");
var _actions = require("../../../state/actions");
var _renderers = require("../../../state/renderers");
var _store = require("../../../state/store");
var _SmartLinkAnalyticsContext = require("../../../utils/analytics/SmartLinkAnalyticsContext");
var _CustomPopupContainer = _interopRequireDefault(require("../components/CustomPopupContainer"));
var _HoverCardContent = _interopRequireDefault(require("../components/HoverCardContent"));
var _styled = require("../styled");
var _excluded = ["aria-haspopup", "aria-expanded"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var HOVER_CARD_SOURCE = exports.HOVER_CARD_SOURCE = 'smartLinkPreviewHoverCard';
var FADE_IN_DELAY = 500;
var FADE_OUT_DELAY = 300;
var RESOLVE_DELAY = 100;
var HoverCardComponent = exports.HoverCardComponent = function HoverCardComponent(_ref) {
  var _hoverPreviewOptions$;
  var children = _ref.children,
    url = _ref.url,
    _ref$id = _ref.id,
    id = _ref$id === void 0 ? '' : _ref$id,
    _ref$canOpen = _ref.canOpen,
    canOpen = _ref$canOpen === void 0 ? true : _ref$canOpen,
    _ref$closeOnChildClic = _ref.closeOnChildClick,
    closeOnChildClick = _ref$closeOnChildClic === void 0 ? false : _ref$closeOnChildClic,
    actionOptions = _ref.actionOptions,
    _ref$allowEventPropag = _ref.allowEventPropagation,
    allowEventPropagation = _ref$allowEventPropag === void 0 ? false : _ref$allowEventPropag,
    _ref$zIndex = _ref.zIndex,
    zIndex = _ref$zIndex === void 0 ? _styled.HOVER_CARD_Z_INDEX : _ref$zIndex,
    _ref$noFadeDelay = _ref.noFadeDelay,
    noFadeDelay = _ref$noFadeDelay === void 0 ? false : _ref$noFadeDelay,
    hoverPreviewOptions = _ref.hoverPreviewOptions,
    role = _ref.role,
    label = _ref.label,
    titleId = _ref.titleId,
    _ref$showLabel = _ref.showLabel,
    showLabel = _ref$showLabel === void 0 ? true : _ref$showLabel;
  var fadeInDelay = (_hoverPreviewOptions$ = hoverPreviewOptions === null || hoverPreviewOptions === void 0 ? void 0 : hoverPreviewOptions.fadeInDelay) !== null && _hoverPreviewOptions$ !== void 0 ? _hoverPreviewOptions$ : FADE_IN_DELAY;
  var _React$useState = _react.default.useState(false),
    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
    isOpen = _React$useState2[0],
    setIsOpen = _React$useState2[1];
  var fadeOutTimeoutId = (0, _react.useRef)();
  var fadeInTimeoutId = (0, _react.useRef)();
  var resolveTimeOutId = (0, _react.useRef)();
  var mousePos = (0, _react.useRef)();
  var popupOffset = (0, _react.useRef)();
  var parentSpan = (0, _react.useRef)(null);
  var _useIntl = (0, _reactIntlNext.useIntl)(),
    formatMessage = _useIntl.formatMessage;
  var renderers = (0, _renderers.useSmartLinkRenderers)();
  var linkState = (0, _store.useSmartCardState)(url);
  var _useSmartCardActions = (0, _actions.useSmartCardActions)(id, url),
    loadMetadata = _useSmartCardActions.loadMetadata;
  var setMousePosition = (0, _react.useCallback)(function (event) {
    if (isOpen && canOpen) {
      return;
    }
    mousePos.current = {
      x: event.clientX,
      y: event.clientY
    };

    //If these are undefined then popupOffset is undefined and we fallback to default bottom-start placement
    if ((!isOpen || !canOpen) && parentSpan.current && mousePos.current) {
      var _parentSpan$current$g = parentSpan.current.getBoundingClientRect(),
        bottom = _parentSpan$current$g.bottom,
        left = _parentSpan$current$g.left;
      popupOffset.current = [mousePos.current.x - left + _styled.CARD_GAP_PX, mousePos.current.y - bottom + _styled.CARD_GAP_PX];
    }
  }, [canOpen, isOpen]);
  var hideCard = (0, _react.useCallback)(function () {
    setIsOpen(false);
  }, []);
  var initHideCard = (0, _react.useCallback)(function () {
    if (fadeInTimeoutId.current) {
      clearTimeout(fadeInTimeoutId.current);
      // because fadeInTimeoutId.current is set by mouseOver which triggers multiple times in a hover,
      // we want to clear out the reference to signify that there's no in-progress fade in event
      fadeInTimeoutId.current = undefined;
    }
    if (resolveTimeOutId.current) {
      clearTimeout(resolveTimeOutId.current);
      // because resolveTimeOutId.current is set by mouseOver which triggers multiple times in a hover,
      // we want to clear out the reference to signify that there's no in-progress resolve event
      resolveTimeOutId.current = undefined;
    }
    if (noFadeDelay) {
      hideCard();
    } else {
      fadeOutTimeoutId.current = setTimeout(function () {
        return hideCard();
      }, FADE_OUT_DELAY);
    }
  }, [hideCard, noFadeDelay]);

  // clearing out the timeouts in order to avoid memory leaks
  // in case the component unmounts before they execute
  (0, _react.useEffect)(function () {
    return function () {
      if (fadeOutTimeoutId.current) {
        clearTimeout(fadeOutTimeoutId.current);
      }
      if (fadeInTimeoutId.current) {
        clearTimeout(fadeInTimeoutId.current);
        // because fadeInTimeoutId.current is set by mouseOver which triggers multiple times in a hover,
        // we want to clear out the reference to signify that there's no in-progress fade in event
        fadeInTimeoutId.current = undefined;
      }
      if (resolveTimeOutId.current) {
        clearTimeout(resolveTimeOutId.current);
        // because resolveTimeOutId.current is set by mouseOver which triggers multiple times in a hover,
        // we want to clear out the reference to signify that there's no in-progress resolve event
        resolveTimeOutId.current = undefined;
      }
    };
  }, []);

  // we want to initiate resolve a bit earlier for standalone cards
  // to minimize the loading state
  var initResolve = (0, _react.useCallback)(function () {
    // this check covers both non-SSR (status) & SSR case (metadataStatus)
    var isLinkUnresolved = linkState.status === 'pending' || !linkState.metadataStatus;
    if (!resolveTimeOutId.current && isLinkUnresolved) {
      resolveTimeOutId.current = setTimeout(function () {
        loadMetadata();
      }, RESOLVE_DELAY);
    }
  }, [linkState.metadataStatus, linkState.status, loadMetadata]);
  var initShowCard = (0, _react.useCallback)(function (event) {
    // clearing out fadeOutTimeoutId in case it's already counting down to hide the card
    if (fadeOutTimeoutId.current) {
      clearTimeout(fadeOutTimeoutId.current);
    }

    // starting to resolve the hover card if the store doesn't have data about the link yet
    initResolve();

    //Set mouse position in the case it's not already set by onMouseMove, as in the case of scrolling
    setMousePosition(event);
    if (!isOpen && !fadeInTimeoutId.current) {
      // setting a timeout to show a Hover Card after delay runs out
      if (noFadeDelay) {
        setIsOpen(true);
      } else {
        fadeInTimeoutId.current = setTimeout(function () {
          setIsOpen(true);
        }, fadeInDelay);
      }
    }
  }, [initResolve, isOpen, setMousePosition, noFadeDelay, fadeInDelay]);
  var onActionClick = (0, _react.useCallback)(function (actionId) {
    if (actionId === _constants.ActionName.PreviewAction || actionId === _constants.ActionName.AutomationAction) {
      hideCard();
    }
  }, [hideCard]);

  // Stop hover preview content to propagate event to parent.
  var handleChildClick = (0, _react.useCallback)(function (e, closeOnClick) {
    if (!allowEventPropagation) {
      e.stopPropagation();
    }
    if (closeOnClick) {
      hideCard();
    }
  }, [allowEventPropagation, hideCard]);
  var onContextMenuClick = (0, _react.useCallback)(function (e) {
    return handleChildClick(e, true);
  }, [handleChildClick]);
  var onChildClick = (0, _react.useCallback)(function (e) {
    return handleChildClick(e, closeOnChildClick);
  }, [closeOnChildClick, handleChildClick]);
  var content = (0, _react.useCallback)(function (_ref2) {
    var update = _ref2.update;
    var hoverCardContentProps = {
      onMouseEnter: initShowCard,
      onMouseLeave: initHideCard,
      cardState: linkState,
      onActionClick: onActionClick,
      onResolve: update,
      renderers: renderers,
      actionOptions: actionOptions,
      url: url,
      id: id
    };
    return /*#__PURE__*/_react.default.createElement(_SmartLinkAnalyticsContext.SmartLinkAnalyticsContext, {
      url: url,
      display: _constants.CardDisplay.HoverCardPreview,
      id: id,
      source: HOVER_CARD_SOURCE
    }, /*#__PURE__*/_react.default.createElement(_HoverCardContent.default, hoverCardContentProps));
  }, [initShowCard, initHideCard, linkState, onActionClick, renderers, actionOptions, url, id]);
  var trigger = (0, _react.useCallback)(function (_ref3) {
    var ariaHasPopup = _ref3['aria-haspopup'],
      ariaExpanded = _ref3['aria-expanded'],
      triggerProps = (0, _objectWithoutProperties2.default)(_ref3, _excluded);
    return /*#__PURE__*/_react.default.createElement("span", {
      ref: parentSpan
    }, /*#__PURE__*/_react.default.createElement("span", (0, _extends2.default)({}, triggerProps, {
      // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
      onMouseOver: initShowCard,
      onMouseLeave: initHideCard,
      onMouseMove: setMousePosition,
      onClick: onChildClick,
      onContextMenu: onContextMenuClick,
      "data-testid": "hover-card-trigger-wrapper",
      "aria-label": showLabel ? formatMessage(_messages.messages.more_information_about_this_work_item) : undefined
    }, (0, _platformFeatureFlags.fg)('fix_a11y_violation_in_hover_card_trigger') ? {
      role: 'button'
    } : {}), children));
  }, [children, initHideCard, initShowCard, onChildClick, onContextMenuClick, setMousePosition, formatMessage, showLabel]);
  return /*#__PURE__*/_react.default.createElement(_popup.default, {
    testId: "hover-card",
    isOpen: isOpen && canOpen,
    onClose: hideCard,
    placement: "bottom-start",
    offset: popupOffset.current,
    autoFocus: false,
    content: content,
    trigger: trigger,
    zIndex: zIndex,
    role: role,
    titleId: titleId,
    label: label
    // @ts-ignore: [PIT-1685] Fails in post-office due to backwards incompatibility issue with React 18
    ,
    popupComponent: _CustomPopupContainer.default
  });
};