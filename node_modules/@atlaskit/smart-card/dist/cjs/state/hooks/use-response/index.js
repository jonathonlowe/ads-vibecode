"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _reactDom = require("react-dom");
var _linkProvider = require("@atlaskit/link-provider");
var _linkingCommon = require("@atlaskit/linking-common");
var _constants = require("../../../constants");
var _jsonld = require("../../../utils/jsonld");
var _constants2 = require("../../actions/constants");
var useResponse = function useResponse() {
  // Takes in the JSON-LD response and dispatch the resolved action for the card.
  // It will dispatch a successful or error action
  var _useSmartLinkContext = (0, _linkProvider.useSmartLinkContext)(),
    store = _useSmartLinkContext.store,
    config = _useSmartLinkContext.config;
  var getState = store.getState,
    dispatch = store.dispatch;
  var hasAuthFlowSupported = config.authFlow !== 'disabled';
  var setMetadataStatus = (0, _react.useCallback)(function (url, metadataStatus) {
    dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_UPDATE_METADATA_STATUS, {
      url: url
    }, undefined, undefined, metadataStatus));
  }, [dispatch]);
  var handleResolvedLinkError = (0, _react.useCallback)(function (url, error, response, isMetadataRequest) {
    var newState = {
      status: _constants.SmartLinkStatus.Pending,
      details: undefined
    };
    var _ref = getState()[url] || newState,
      details = _ref.details;
    var hasData = !!(details && details.data);

    // If metadata request then set metadata status, return and do not alter link status
    if (isMetadataRequest) {
      setMetadataStatus(url, 'errored');
      return;
    }
    if (error.kind === 'fatal') {
      // If we already have resolved data for this URL in the store, then
      // simply fallback to the previous data.
      if (hasData) {
        dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_RESOLVED, {
          url: url
        }, details));

        // If there's no previous data in the store for this URL, then bail
        // out and let the editor handle fallbacks (returns to a blue link).
      } else {
        dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_ERROR, {
          url: url
        }, details, error));
        throw error;
      }

      // Handle AuthErrors (user did not have access to resource) -
      // Missing AAID in ASAP claims, or missing UserContext, or 403 from downstream
    } else if (error.kind === 'auth') {
      dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_RESOLVED, {
        url: url
      }, (0, _jsonld.getUnauthorizedJsonLd)()));
    } else {
      if (error.kind === 'fallback') {
        // Fallback to blue link with smart link formatting. Not part of reliability.
        dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_ERROR_FALLBACK, {
          url: url
        }, response, error));
      } else {
        // Fallback to blue link with smart link formatting. Part of reliability.
        dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_ERROR, {
          url: url
        }, undefined, error));
      }
    }
  }, [getState, setMetadataStatus, dispatch]);
  var handleResolvedLinkSuccess = (0, _react.useCallback)(function (resourceUrl, response, isReloading, isMetadataRequest) {
    //if a link resolves normally, metadata will also always be resolved
    setMetadataStatus(resourceUrl, 'resolved');
    // Dispatch Analytics and resolved card action - including unauthorized states.
    if (isReloading) {
      dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_RELOADING, {
        url: resourceUrl
      }, response));
    } else {
      dispatch((0, _linkingCommon.cardAction)(_linkingCommon.ACTION_RESOLVED, {
        url: resourceUrl
      }, response, undefined, undefined, isMetadataRequest));
    }
  }, [setMetadataStatus, dispatch]);
  var handleResolvedLinkResponse = (0, _react.useCallback)(function (resourceUrl, response) {
    var isReloading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isMetadataRequest = arguments.length > 3 ? arguments[3] : undefined;
    var hostname = new URL(resourceUrl).hostname;
    var nextStatus = response ? (0, _linkingCommon.getStatus)(response) : 'fatal';

    // If we require authorization & do not have an authFlow available,
    // throw an error and render as a normal blue link.
    if ((nextStatus === 'unauthorized' || nextStatus === 'forbidden') && !hasAuthFlowSupported) {
      handleResolvedLinkError(resourceUrl, new _linkingCommon.APIError('fallback', hostname, _constants2.ERROR_MESSAGE_OAUTH), response, isMetadataRequest);
      return;
    }

    // Handle any other errors
    if (!response || nextStatus === 'fatal') {
      handleResolvedLinkError(resourceUrl, new _linkingCommon.APIError('fatal', hostname, _constants2.ERROR_MESSAGE_FATAL), undefined, isMetadataRequest);
      return;
    }

    // Handle errors of any other kind in the metadata request response
    if (isMetadataRequest && nextStatus !== 'resolved') {
      handleResolvedLinkError(resourceUrl, new _linkingCommon.APIError('error', hostname, _constants2.ERROR_MESSAGE_METADATA), response, isMetadataRequest);
      return;
    }

    /**
     * Using unstable_batchedUpdates because this store update happens async and triggers a rerender
     * more info:
     * https://github.com/facebook/react/blob/v18.2.0/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L113
     * https://react-redux.js.org/api/batch
     */
    (0, _reactDom.unstable_batchedUpdates)(function () {
      handleResolvedLinkSuccess(resourceUrl, response, isReloading, isMetadataRequest);
    });
  }, [handleResolvedLinkError, handleResolvedLinkSuccess, hasAuthFlowSupported]);
  return (0, _react.useMemo)(function () {
    return {
      handleResolvedLinkError: handleResolvedLinkError,
      handleResolvedLinkResponse: handleResolvedLinkResponse
    };
  }, [handleResolvedLinkError, handleResolvedLinkResponse]);
};
var _default = exports.default = useResponse;