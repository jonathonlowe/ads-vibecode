"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = require("react");
var _linkingCommon = require("@atlaskit/linking-common");
var _query = require("./query");
/**
 * @param baseUriWithNoTrailingSlash base url which will then be appended with /gateway/api/graphql to make requests to AGG
 */
var useIncomingOutgoingAri = function useIncomingOutgoingAri() {
  var baseUriWithNoTrailingSlash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var aggRequestCall = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(body, headers) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", (0, _linkingCommon.request)('post', baseUriWithNoTrailingSlash + '/gateway/api/graphql', body, headers, [200]));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }(), [baseUriWithNoTrailingSlash]);
  var getIncomingOutgoingAris = (0, _react.useCallback)(
  /*#__PURE__*/
  /**
   * Returning aris linking to (outgoing) and from (incoming) a given ari from AGS using
   * https://developer.atlassian.com/cloud/ari-graph-store/relationships/content-referenced-entity/#query
   * @param ari the ari for which the incoming outgoing aris are to be retrieved
   * @param firstIncoming The maximum count of incoming relationships to fetch. Must not exceed 1000. This max limit is handled by AGG itself. Default is 50 (ORS batch max limit)
   * @param firstOutgoing The maximum count of outgoing relationships to fetch. Must not exceed 1000. This max limit is handled by AGG itself. Default is 50 (ORS batch max limit)
   *
   */
  function () {
    var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(ari) {
      var _response$data$graphS, _response$data, _response$data$graphS2, _response$data2;
      var firstIncoming,
        firstOutgoing,
        response,
        incomingAris,
        outgoingAris,
        _args2 = arguments;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            firstIncoming = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 50;
            firstOutgoing = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 50;
            _context2.next = 4;
            return aggRequestCall({
              variables: {
                id: ari,
                firstIncoming: firstIncoming,
                firstOutgoing: firstOutgoing
              },
              query: _query.queryIncomingOutgoingLinks
            });
          case 4:
            response = _context2.sent;
            incomingAris = (_response$data$graphS = response === null || response === void 0 || (_response$data = response.data) === null || _response$data === void 0 || (_response$data = _response$data.graphStore) === null || _response$data === void 0 || (_response$data = _response$data.incoming) === null || _response$data === void 0 || (_response$data = _response$data.aris) === null || _response$data === void 0 || (_response$data = _response$data.map(function (node) {
              return node === null || node === void 0 ? void 0 : node.id;
            })) === null || _response$data === void 0 ? void 0 : _response$data.filter(function (id) {
              return !!id;
            })) !== null && _response$data$graphS !== void 0 ? _response$data$graphS : [];
            outgoingAris = (_response$data$graphS2 = response === null || response === void 0 || (_response$data2 = response.data) === null || _response$data2 === void 0 || (_response$data2 = _response$data2.graphStore) === null || _response$data2 === void 0 || (_response$data2 = _response$data2.outgoing) === null || _response$data2 === void 0 || (_response$data2 = _response$data2.aris) === null || _response$data2 === void 0 || (_response$data2 = _response$data2.map(function (node) {
              return node === null || node === void 0 ? void 0 : node.id;
            })) === null || _response$data2 === void 0 ? void 0 : _response$data2.filter(function (id) {
              return !!id;
            })) !== null && _response$data$graphS2 !== void 0 ? _response$data$graphS2 : [];
            return _context2.abrupt("return", {
              incomingAris: incomingAris,
              outgoingAris: outgoingAris
            });
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x3) {
      return _ref2.apply(this, arguments);
    };
  }(), [aggRequestCall]);
  return (0, _react.useMemo)(function () {
    return {
      getIncomingOutgoingAris: getIncomingOutgoingAris
    };
  }, [getIncomingOutgoingAris]);
};
var _default = exports.default = useIncomingOutgoingAri;