import React, { useMemo, useState } from 'react';
import { di } from 'react-magnetic-di';
import { ModalTransition } from '@atlaskit/modal-dialog';
import UserInputForm from './manual-triggers-form/main';
import { invokeManuallyTriggeredRule, searchManuallyTriggeredRules } from './services';

/**
 * React hook that implements the fetch and invoke actions for manual triggers.
 * Can be used standalone or in the HOC provided below.
 * @param site - The site to filter on. We map this to just a cloudId to resolve the manual rules API path
 * @param query - Query object containing filter props (container, object(s))
 */
export const useManualRules = (site, query) => {
  const [initialised, setInitialised] = useState(false);
  const [error, setError] = useState(null);
  const [rules, setRules] = useState([]);
  const transformRules = ruleResponse => {
    const rulesUnsorted = Object.values(ruleResponse);
    return rulesUnsorted.sort((rule1, rule2) => rule1.name.localeCompare(rule2.name));
  };
  const triggerFetch = async () => {
    setInitialised(false);
    try {
      const fetchedRules = await searchManuallyTriggeredRules(site, query);
      setError(null);
      setRules(transformRules(fetchedRules));
    } catch (e) {
      setError(e);
      setRules([]);
    } finally {
      setInitialised(true);
    }
  };
  return [triggerFetch, initialised, error, rules];
};
/**
 *
 * Container HOC that implements the above hook and behaviours.
 *
 * This HOC uses rendered props to allow the use of any render instructions
 * for manual rules, while still maintaining the behaviour of invoking rules.
 *
 * The HOC also appends a dialog that is displayed when the {@code invokeRuleOrShowDialog}
 * prop is called, if the underlying rule has user inputs.
 *
 * The component exposes the "invokingRuleId" property to the child hierarchy,
 * because the children might care about the invocation state. It does not expose
 * the "selected" state, or any information about the dialog, as the children
 * should not care about this, only how to trigger invocation and understand
 * the invocation lifecycle.
 *
 * @param props - cloudId, projectId, children
 */
export const ManualRulesContainer = props => {
  const {
    site,
    query,
    children,
    onInputsModalOpened,
    onInputsModalClosed,
    onRuleInvocationLifecycleStarted,
    onRuleInvocationSuccess,
    onRuleInvocationFailure,
    onRuleInvocationLifecycleDone
  } = props;
  // Initial data loading state
  const [triggerFetch, initialised, error, rules] = useManualRules(site, query);
  // We store a rule in state here if and only if a rule has user inputs, and thus
  // we need to preserve state while the input dialog is open.
  const [selectedRule, setSelectedRule] = useState(null);
  const clearSelectedRule = () => {
    setSelectedRule(null);
  };
  // Value set when a rule is invoking, either from the dialog or without dialog
  const [invokingRuleId, setInvokingRuleId] = useState(null);

  // Memoized projection of rules by id
  const rulesById = useMemo(() => rules.reduce((acc, rule) => ({
    // eslint-disable-next-line
    ...acc,
    [rule.id]: rule
  }), {}), [rules]);
  const getRule = id => rulesById[id];
  const ruleHasInputs = rule => {
    var _rule$userInputPrompt;
    return (rule === null || rule === void 0 ? void 0 : (_rule$userInputPrompt = rule.userInputPrompts) === null || _rule$userInputPrompt === void 0 ? void 0 : _rule$userInputPrompt.length) > 0;
  };
  const getFailedObjects = response => Object.keys(response).filter(object => response[object] !== 'SUCCESS');
  const getSuccessfulObjects = response => Object.keys(response).filter(object => response[object] === 'SUCCESS');
  const handleInvocationFailure = (ruleId, successfulObjects, failedObjects) => {
    if (onRuleInvocationFailure) {
      onRuleInvocationFailure(ruleId, successfulObjects, failedObjects);
    }
  };
  const invokeRule = async (ruleId, objects, userInputs) => {
    const rule = getRule(ruleId);
    if (rule) {
      setInvokingRuleId(ruleId);
      try {
        if (onRuleInvocationLifecycleStarted) {
          onRuleInvocationLifecycleStarted(ruleId, objects, userInputs);
        }
        const response = await invokeManuallyTriggeredRule(site, ruleId, objects, userInputs);
        const failedObjects = getFailedObjects(response);
        setInvokingRuleId(null);
        if (failedObjects.length === 0) {
          if (onRuleInvocationSuccess) {
            onRuleInvocationSuccess(ruleId, objects);
          }
        } else {
          const successfulObjects = getSuccessfulObjects(response);
          handleInvocationFailure(ruleId, successfulObjects, failedObjects);
        }
      } catch (e) {
        handleInvocationFailure(ruleId, [], objects);
        setInvokingRuleId(null);
      }
    } else {
      handleInvocationFailure(ruleId, [], objects);
    }
    clearSelectedRule();
    if (onRuleInvocationLifecycleDone) {
      onRuleInvocationLifecycleDone(ruleId, objects);
    }
  };
  const invokeRuleOrShowDialog = (ruleId, objects) => {
    const rule = getRule(ruleId);
    if (!rule) {
      return handleInvocationFailure(ruleId, [], objects);
    }
    if (ruleHasInputs(rule)) {
      setSelectedRule({
        rule,
        objects
      });
    } else {
      invokeRule(ruleId, objects);
    }
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, children({
    triggerFetch,
    initialised,
    error,
    rules,
    invokingRuleId,
    invokeRuleOrShowDialog
  }), /*#__PURE__*/React.createElement(ModalTransition, null, selectedRule && /*#__PURE__*/React.createElement(UserInputForm, {
    onInputsModalOpened: onInputsModalOpened,
    onInputsModalClosed: onInputsModalClosed,
    clearSelectedRule: clearSelectedRule,
    selectedRule: selectedRule,
    invokeRule: invokeRule
  })));
};