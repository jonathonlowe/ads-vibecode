import _extends from "@babel/runtime/helpers/extends";
import React, { useContext } from 'react';
import { FormattedDate } from 'react-intl-next';
import { ElementName, IconType, SmartLinkInternalTheme } from '../../../../constants';
import { messages } from '../../../../messages';
import { FlexibleUiContext } from '../../../../state/flexible-ui-context';
import AppliedToComponentsCount from './applied-to-components-count';
import AtlaskitBadge from './atlaskit-badge';
import AvatarGroup from './avatar-group';
import Badge from './badge';
import DateTime from './date-time';
import Icon from './icon';
import Link from './link';
import Lozenge from './lozenge';
import Media from './media';
import Text from './text';
const elementMappings = {
  [ElementName.AppliedToComponentsCount]: {
    component: AppliedToComponentsCount,
    props: {
      icon: IconType.Component
    }
  },
  [ElementName.AttachmentCount]: {
    component: Badge,
    props: {
      icon: IconType.Attachment
    }
  },
  [ElementName.AuthorGroup]: {
    component: AvatarGroup
  },
  [ElementName.ChecklistProgress]: {
    component: Badge,
    props: {
      icon: IconType.CheckItem
    }
  },
  [ElementName.CollaboratorGroup]: {
    component: AvatarGroup
  },
  [ElementName.CommentCount]: {
    component: Badge,
    props: {
      icon: IconType.Comment
    }
  },
  [ElementName.ViewCount]: {
    component: Badge,
    props: {
      icon: IconType.View
    }
  },
  [ElementName.ReactCount]: {
    component: Badge,
    props: {
      icon: IconType.React
    }
  },
  [ElementName.VoteCount]: {
    component: Badge,
    props: {
      icon: IconType.Vote
    }
  },
  [ElementName.CreatedBy]: {
    component: Text
  },
  [ElementName.OwnedBy]: {
    component: Text
  },
  [ElementName.AssignedTo]: {
    component: Text
  },
  [ElementName.AssignedToGroup]: {
    component: AvatarGroup
  },
  [ElementName.OwnedByGroup]: {
    component: AvatarGroup
  },
  [ElementName.CreatedOn]: {
    component: DateTime
  },
  [ElementName.DueOn]: {
    component: Lozenge
  },
  [ElementName.LatestCommit]: {
    component: Badge,
    props: {
      icon: IconType.Commit
    }
  },
  [ElementName.LinkIcon]: {
    component: Icon
  },
  [ElementName.ModifiedBy]: {
    component: Text
  },
  [ElementName.ModifiedOn]: {
    component: DateTime
  },
  [ElementName.Preview]: {
    component: Media
  },
  [ElementName.Priority]: {
    component: Badge
  },
  [ElementName.ProgrammingLanguage]: {
    component: Badge,
    props: {
      icon: IconType.ProgrammingLanguage
    }
  },
  [ElementName.Provider]: {
    component: Badge
  },
  [ElementName.ReadTime]: {
    component: Text
  },
  [ElementName.SentOn]: {
    component: DateTime
  },
  [ElementName.SourceBranch]: {
    component: Text
  },
  [ElementName.State]: {
    component: Lozenge
  },
  [ElementName.SubscriberCount]: {
    component: Badge,
    props: {
      icon: IconType.Subscriber
    }
  },
  [ElementName.SubTasksProgress]: {
    component: Badge,
    props: {
      icon: IconType.SubTasksProgress
    }
  },
  [ElementName.StoryPoints]: {
    component: AtlaskitBadge
  },
  [ElementName.TargetBranch]: {
    component: Text
  },
  [ElementName.Title]: {
    component: Link
  },
  [ElementName.Location]: {
    component: Link,
    props: {
      theme: SmartLinkInternalTheme.Grey
    }
  }
};
const getContextKey = name => {
  // Attempt to predict context prop name in advance to reduce the amount of
  // code run during runtime
  return name.length > 0 ? name.charAt(0).toLowerCase() + name.slice(1) : undefined;
};
const getData = (elementName, contextKey, context) => {
  if (!context) {
    return undefined;
  }
  const data = context[contextKey];
  switch (elementName) {
    case ElementName.AssignedToGroup:
    case ElementName.AuthorGroup:
    case ElementName.CollaboratorGroup:
    case ElementName.OwnedByGroup:
      const AvatarGroupsWithFallback = [ElementName.AssignedToGroup];
      const showFallbackAvatar = AvatarGroupsWithFallback.includes(elementName);
      return toAvatarGroupProps(data, showFallbackAvatar);
    case ElementName.AppliedToComponentsCount:
    case ElementName.AttachmentCount:
    case ElementName.ChecklistProgress:
    case ElementName.CommentCount:
    case ElementName.ViewCount:
    case ElementName.ReactCount:
    case ElementName.VoteCount:
    case ElementName.ProgrammingLanguage:
    case ElementName.SubscriberCount:
    case ElementName.LatestCommit:
    case ElementName.SubTasksProgress:
      return toBadgeProps(data);
    case ElementName.StoryPoints:
      return toAtlaskitBadgeProps(data);
    case ElementName.CreatedBy:
      return toFormattedTextProps(messages.created_by, context.createdBy);
    case ElementName.AssignedTo:
      return toFormattedTextProps(messages.assigned_to, context.assignedTo);
    case ElementName.OwnedBy:
      return toFormattedTextProps(messages.owned_by, context.ownedBy);
    case ElementName.CreatedOn:
      return toDateTimeProps('created', context.createdOn);
    case ElementName.DueOn:
      return toDateLozengeProps(context.dueOn);
    case ElementName.ModifiedBy:
      return toFormattedTextProps(messages.modified_by, context.modifiedBy);
    case ElementName.ModifiedOn:
      return toDateTimeProps('modified', context.modifiedOn);
    case ElementName.SentOn:
      return toDateTimeProps('sent', context.sentOn);
    case ElementName.ReadTime:
      return toFormattedTextProps(messages.read_time, data);
    case ElementName.SourceBranch:
    case ElementName.TargetBranch:
      return toTextProps(data);
    case ElementName.Title:
      return toLinkProps(context.title, context.url);
    default:
      return typeof data === 'object' ? data : undefined;
  }
};
const toAvatarGroupProps = (items, showFallbackAvatar) => {
  return items ? {
    items
  } : showFallbackAvatar ? {
    items: []
  } : undefined;
};
const toBadgeProps = label => {
  return label ? {
    label
  } : undefined;
};
const toAtlaskitBadgeProps = value => {
  return value ? {
    value
  } : undefined;
};
const toDateLozengeProps = dateString => {
  if (dateString) {
    const text = Date.parse(dateString) ? /*#__PURE__*/React.createElement(FormattedDate, {
      value: new Date(dateString),
      year: "numeric",
      month: "short",
      day: "numeric",
      formatMatcher: "best fit"
    }) : dateString;
    return {
      text
    };
  }
};
const toDateTimeProps = (type, dateString) => {
  return dateString ? {
    date: new Date(dateString),
    type
  } : undefined;
};
const toFormattedTextProps = (descriptor, context) => {
  return context ? {
    message: {
      descriptor,
      values: {
        context
      }
    }
  } : undefined;
};
const toLinkProps = (text, url) => {
  return text ? {
    text,
    url
  } : undefined;
};
const toTextProps = content => {
  return content ? {
    content
  } : undefined;
};
export const createElement = name => {
  const {
    component: BaseElement,
    props
  } = elementMappings[name] || {};
  const contextKey = getContextKey(name);
  if (!BaseElement) {
    throw Error(`Element ${name} does not exist.`);
  }
  return overrides => {
    const context = useContext(FlexibleUiContext);
    const data = getData(name, contextKey, context);
    return data ? /*#__PURE__*/React.createElement(BaseElement, _extends({}, props, data, overrides, {
      name: name
    })) : null;
  };
};