import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import { FormattedMessage } from 'react-intl-next';
import Loadable from 'react-loadable';
import { fg } from '@atlaskit/platform-feature-flags';
import { SmartLinkSize } from '../../../constants';
export const sizeToButtonSpacing = {
  [SmartLinkSize.Small]: 'none',
  [SmartLinkSize.Medium]: 'compact',
  [SmartLinkSize.Large]: 'compact',
  [SmartLinkSize.XLarge]: 'default'
};
export const getFormattedMessage = message => {
  if (message) {
    const {
      descriptor,
      values
    } = message;
    return /*#__PURE__*/React.createElement(FormattedMessage, _extends({}, descriptor, {
      values: values
    }));
  }
};
export const getFormattedMessageAsString = (intl, message, context) => {
  const {
    formatMessage
  } = intl;
  return message ? formatMessage(message, {
    context
  }) : '';
};

// TODO Delete when cleaning platform-smart-card-icon-migration
export const getIconWidthOld = size => {
  switch (size) {
    case SmartLinkSize.XLarge:
      return '2rem';
    case SmartLinkSize.Large:
      return '1.5rem';
    case SmartLinkSize.Medium:
      return '1rem';
    case SmartLinkSize.Small:
    default:
      return '.75rem';
  }
};

// TODO Rename to getIconWidth when cleaning platform-smart-card-icon-migration
export const getIconWidthNew = size => {
  switch (size) {
    case SmartLinkSize.XLarge:
    case SmartLinkSize.Large:
      return "var(--ds-space-300, 24px)";
    case SmartLinkSize.Medium:
    case SmartLinkSize.Small:
    default:
      return "var(--ds-space-200, 16px)";
  }
};

// TODO Delete when cleaning platform-smart-card-icon-migration
export const getIconWidth = size => {
  return fg('platform-smart-card-icon-migration') ? getIconWidthNew(size) : getIconWidthOld(size);
};
export const importIcon = importFn => {
  return Loadable({
    loader: () => importFn().then(module => module.default),
    loading: () => null
  }); // Because we're using dynamic loading here, TS will not be able to infer the type.
};
export const getMaxLineHeight = size => {
  // The maximum line height based on all elements in specific size.
  // These heights belongs to AvatarGroup.
  switch (size) {
    case SmartLinkSize.XLarge:
    case SmartLinkSize.Large:
      return 1.75;
    case SmartLinkSize.Medium:
    case SmartLinkSize.Small:
    default:
      return 1.5;
  }
};
export const getMaxLines = (value, defaultValue, max, min) => {
  if (value > max) {
    return defaultValue;
  }
  if (value < min) {
    return min;
  }
  return value;
};

/**
 * A space between element based on smart link size
 * To replace blocks/utils.tsz getGapSize() with space token for primitives
 */
export const getPrimitivesInlineSpaceBySize = size => {
  switch (size) {
    case SmartLinkSize.XLarge:
      return 'space.250';
    case SmartLinkSize.Large:
      return 'space.200';
    case SmartLinkSize.Medium:
      return 'space.100';
    case SmartLinkSize.Small:
    default:
      return 'space.050';
  }
};
export const hasWhiteSpace = str => {
  return str.search(/\s/) >= 0;
};