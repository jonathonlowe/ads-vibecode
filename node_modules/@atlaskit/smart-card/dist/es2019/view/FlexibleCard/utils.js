import { extractProvider } from '@atlaskit/link-extractors';
import { fg } from '@atlaskit/platform-feature-flags';
import { SmartLinkStatus } from '../../constants';
import { extractRequestAccessContextImproved } from '../../extractors/common/context';
import extractFlexibleUiContext from '../../extractors/flexible';
import extractPreview from '../../extractors/flexible/extract-preview';
import { extractErrorIcon } from '../../extractors/flexible/icon';
import extractProviderIcon from '../../extractors/flexible/icon/extract-provider-icon';
import { messages } from '../../messages';
import { handleOnClick } from '../../utils';
import { getEmptyJsonLd, getForbiddenJsonLd } from '../../utils/jsonld';
export const getContextByStatus = params => {
  const {
    response,
    status,
    url
  } = params !== null && params !== void 0 ? params : {};
  switch (status) {
    case SmartLinkStatus.Pending:
    case SmartLinkStatus.Resolving:
      return {
        title: url,
        url
      };
    case SmartLinkStatus.Resolved:
      return extractFlexibleUiContext(params);
    case SmartLinkStatus.Unauthorized:
    case SmartLinkStatus.Forbidden:
    case SmartLinkStatus.NotFound:
    case SmartLinkStatus.Errored:
    case SmartLinkStatus.Fallback:
    default:
      const preview = extractPreview(response === null || response === void 0 ? void 0 : response.data);
      const linkIcon = extractErrorIcon(response, status);
      const provider = extractProviderIcon(response === null || response === void 0 ? void 0 : response.data);
      return {
        linkIcon,
        title: url,
        url,
        provider,
        preview
      };
  }
};
const getForbiddenMessageKey = meta => {
  var _meta$requestAccess;
  const accessType = meta === null || meta === void 0 ? void 0 : (_meta$requestAccess = meta.requestAccess) === null || _meta$requestAccess === void 0 ? void 0 : _meta$requestAccess.accessType;
  switch (accessType) {
    case 'DIRECT_ACCESS':
      return fg('confluence-issue-terminology-refresh') ? 'join_to_viewIssueTermRefresh' : 'join_to_view';
    case 'REQUEST_ACCESS':
      return fg('confluence-issue-terminology-refresh') ? 'request_access_to_viewIssueTermRefresh' : 'request_access_to_view';
    case 'PENDING_REQUEST_EXISTS':
      return 'pending_request';
    case 'FORBIDDEN':
      return 'forbidden_access';
    case 'DENIED_REQUEST_EXISTS':
      return 'request_denied';
    default:
      return 'restricted_link';
  }
};
export const getRetryOptions = (url, status, response, onAuthorize) => {
  var _response$meta, _access$action, _access$buttonDisable;
  const data = response && response.data || getEmptyJsonLd();
  const provider = extractProvider(data);
  const context = provider === null || provider === void 0 ? void 0 : provider.text;
  const values = context ? {
    context
  } : undefined;
  switch (status) {
    case SmartLinkStatus.Forbidden:
      const meta = (_response$meta = response === null || response === void 0 ? void 0 : response.meta) !== null && _response$meta !== void 0 ? _response$meta : getForbiddenJsonLd().meta;
      const access = extractRequestAccessContextImproved({
        jsonLd: meta,
        url,
        product: context !== null && context !== void 0 ? context : ''
      });
      const messageKey = getForbiddenMessageKey(meta);
      const descriptor = messages[messageKey];
      const retry = onAuthorize || (access === null || access === void 0 ? void 0 : (_access$action = access.action) === null || _access$action === void 0 ? void 0 : _access$action.promise);
      const onClick = retry && !((_access$buttonDisable = access === null || access === void 0 ? void 0 : access.buttonDisabled) !== null && _access$buttonDisable !== void 0 ? _access$buttonDisable : false) ? handleOnClick(retry) : undefined;
      return {
        descriptor,
        onClick,
        values
      };
    case SmartLinkStatus.Unauthorized:
      return onAuthorize ? {
        descriptor: messages.connect_link_account_card_name,
        onClick: handleOnClick(onAuthorize),
        values
      } : undefined;
    case SmartLinkStatus.NotFound:
      return {
        descriptor: messages.cannot_find_link
      };
  }
};