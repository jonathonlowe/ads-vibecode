import { extractType } from '@atlaskit/link-extractors';
import { ElementName } from '../../constants';
import { extractOwnedBy } from '../../extractors/flexible/utils';
const getSimulatedBetterMetadata = (extensionKey, data) => {
  var _data$Type$includes, _data$Type;
  const types = data ? extractType(data) : undefined;
  const defaultMetadata = {
    primary: [ElementName.AuthorGroup, ElementName.ModifiedOn]
  };
  switch (extensionKey) {
    case 'bitbucket-object-provider':
    case 'native-bitbucket-object-provider':
      if (types !== null && types !== void 0 && types.includes('atlassian:SourceCodePullRequest')) {
        return {
          primary: [ElementName.AuthorGroup, ElementName.ModifiedOn, ElementName.SubscriberCount, ElementName.State],
          subtitle: [ElementName.SourceBranch, ElementName.TargetBranch]
        };
      }
      if (types !== null && types !== void 0 && types.includes('schema:DigitalDocument')) {
        return {
          primary: [ElementName.LatestCommit, ElementName.CollaboratorGroup, ElementName.ModifiedOn]
        };
      }
      return {
        primary: [ElementName.AuthorGroup, ElementName.ModifiedOn]
      };
    case 'confluence-object-provider':
      const primaryAttribution = data && extractOwnedBy(data) ? ElementName.OwnedByGroup : ElementName.AuthorGroup;
      return {
        primary: [primaryAttribution, ElementName.ModifiedOn],
        tertiary: [ElementName.ReactCount, ElementName.CommentCount, ElementName.ViewCount]
      };
    case 'jira-object-provider':
      const isJiraTask = (_data$Type$includes = data === null || data === void 0 ? void 0 : (_data$Type = data['@type']) === null || _data$Type === void 0 ? void 0 : _data$Type.includes('atlassian:Task')) !== null && _data$Type$includes !== void 0 ? _data$Type$includes : false;
      return {
        ...defaultMetadata,
        ...(isJiraTask && {
          primary: [ElementName.AssignedToGroup, ElementName.State, ElementName.StoryPoints, ElementName.Priority]
        })
      };
    case 'trello-object-provider':
      return {
        primary: [ElementName.CollaboratorGroup, ElementName.State, ElementName.DueOn],
        secondary: [ElementName.ReactCount, ElementName.CommentCount, ElementName.AttachmentCount, ElementName.ChecklistProgress],
        subtitle: [ElementName.Location]
      };
    case 'watermelon-object-provider':
      if (types !== null && types !== void 0 && types.includes('atlassian:Project')) {
        return {
          primary: [ElementName.AuthorGroup, ElementName.ModifiedOn, ElementName.State, ElementName.DueOn]
        };
      }
      return {
        primary: [ElementName.AuthorGroup, ElementName.State, ElementName.DueOn]
      };
    case 'slack-object-provider':
      return {
        primary: [ElementName.AuthorGroup, ElementName.SentOn],
        tertiary: [ElementName.ReactCount, ElementName.CommentCount]
      };
    case 'google-object-provider':
    case 'figma-object-provider':
      return {
        primary: [ElementName.AuthorGroup, ElementName.ModifiedOn]
      };
    default:
      return defaultMetadata;
  }
};
const AvatarGroupsWithNamePrefix = [ElementName.AssignedToGroup, ElementName.OwnedByGroup, ElementName.AuthorGroup];
const toElementItem = name => {
  const showNamePrefix = AvatarGroupsWithNamePrefix.indexOf(name) !== -1 ? true : undefined;
  const testId = `${name.toLowerCase()}-metadata-element`;
  return {
    name,
    showNamePrefix,
    testId
  };
};
const toElementItems = elementNames => {
  if (!(elementNames !== null && elementNames !== void 0 && elementNames.length)) {
    return;
  }
  return elementNames.filter(name => name in ElementName).map(toElementItem);
};
export const getMetadata = (extensionKey, data) => {
  const metadata = getSimulatedBetterMetadata(extensionKey, data);
  const primary = [].concat(metadata.primary, metadata.tertiary);
  return {
    subtitle: toElementItems(metadata.subtitle),
    primary: toElementItems(primary),
    secondary: toElementItems(metadata.secondary)
  };
};