import React, { useCallback, useEffect, useMemo } from 'react';
import { useAnalyticsEvents as useAnalyticsEventsNext } from '@atlaskit/analytics-next';
import { fg } from '@atlaskit/platform-feature-flags';
import { useAnalyticsEvents } from '../../common/analytics/generated/use-analytics-events';
import { CardDisplay } from '../../constants';
import { useSmartLink } from '../../state';
import { succeedUfoExperience } from '../../state/analytics';
import { getClickUrl, getDefinitionId, getExtensionKey, getResourceType, getServices, isFinalState } from '../../state/helpers';
import { SmartLinkModalProvider } from '../../state/modal';
import { isSpecialEvent } from '../../utils';
import { combineActionOptions } from '../../utils/actions/combine-action-options';
import { fireLinkClickedEvent } from '../../utils/analytics/click';
import { SmartLinkAnalyticsContext } from '../../utils/analytics/SmartLinkAnalyticsContext';
import { isFlexibleUiCard } from '../../utils/flexible';
import * as measure from '../../utils/performance';
import { BlockCard } from '../BlockCard';
import { EmbedCard } from '../EmbedCard';
import FlexibleCard from '../FlexibleCard';
import { InlineCard } from '../InlineCard';
function Component({
  id,
  url,
  isSelected,
  isHovered,
  frameStyle,
  platform,
  onClick,
  appearance,
  onResolve,
  onError,
  testId,
  actionOptions: actionOptionsProp,
  inheritDimensions,
  embedIframeRef,
  embedIframeUrlType,
  inlinePreloaderStyle,
  ui,
  children,
  showHoverPreview,
  hoverPreviewOptions,
  removeTextHighlightingFromTitle,
  resolvingPlaceholder,
  truncateInline
}) {
  const {
    createAnalyticsEvent
  } = useAnalyticsEventsNext();
  const {
    fireEvent
  } = useAnalyticsEvents();

  // Get state, actions for this card.
  const {
    state,
    actions,
    config,
    renderers,
    error
  } = useSmartLink(id, url);
  const definitionId = getDefinitionId(state.details);
  const extensionKey = getExtensionKey(state.details);
  const resourceType = getResourceType(state.details);
  const services = getServices(state.details);
  let isFlexibleUi = useMemo(() => isFlexibleUiCard(children, fg('platform-linking-flexible-card-openness') ? ui : undefined), [children, ui]);
  const actionOptions = combineActionOptions({
    actionOptions: actionOptionsProp,
    platform
  });

  // Setup UI handlers.
  const handleClickWrapper = useCallback(event => {
    const isModifierKeyPressed = isSpecialEvent(event);
    fireEvent('ui.smartLink.clicked', {
      id,
      display: isFlexibleUi ? CardDisplay.Flexible : appearance,
      definitionId: definitionId !== null && definitionId !== void 0 ? definitionId : null,
      isModifierKeyPressed
    });
    if (!onClick && !isFlexibleUi) {
      const clickUrl = getClickUrl(url, state.details);
      // Ctrl+left click on mac typically doesn't trigger onClick
      // The event could have potentially had `e.preventDefault()` called on it by now
      // event by smart card internally
      // If it has been called then only then can `isModifierKeyPressed` be true.
      const target = isModifierKeyPressed ? '_blank' : '_self';
      window.open(clickUrl, target);
      fireLinkClickedEvent(createAnalyticsEvent)(event, {
        attributes: {
          clickOutcome: target === '_blank' ? 'clickThroughNewTabOrWindow' : 'clickThrough'
        }
      });
    } else {
      if (onClick) {
        onClick(event);
      }
      fireLinkClickedEvent(createAnalyticsEvent)(event);
    }
  }, [id, url, state.details, appearance, definitionId, onClick, isFlexibleUi, createAnalyticsEvent, fireEvent]);
  const handleAuthorize = useCallback(() => actions.authorize(appearance), [actions, appearance]);
  const handleRetry = useCallback(() => {
    actions.reload();
  }, [actions]);
  const handleInvoke = useCallback(opts => actions.invoke(opts, appearance), [actions, appearance]);

  // NB: for each status change in a Smart Link, a performance mark is created.
  // Measures are sent relative to the first mark, matching what a user sees.
  useEffect(() => {
    measure.mark(id, state.status);
    if (state.status !== 'pending' && state.status !== 'resolving') {
      var _state$error, _state$error2;
      measure.create(id, state.status);
      if (state.status === 'resolved') {
        var _measure$getMeasure$d, _measure$getMeasure;
        fireEvent('operational.smartLink.resolved', {
          definitionId: definitionId !== null && definitionId !== void 0 ? definitionId : null,
          duration: (_measure$getMeasure$d = (_measure$getMeasure = measure.getMeasure(id, state.status)) === null || _measure$getMeasure === void 0 ? void 0 : _measure$getMeasure.duration) !== null && _measure$getMeasure$d !== void 0 ? _measure$getMeasure$d : null
        });
      } else if (((_state$error = state.error) === null || _state$error === void 0 ? void 0 : _state$error.type) !== 'ResolveUnsupportedError' && ((_state$error2 = state.error) === null || _state$error2 === void 0 ? void 0 : _state$error2.type) !== 'UnsupportedError') {
        fireEvent('operational.smartLink.unresolved', {
          definitionId: definitionId !== null && definitionId !== void 0 ? definitionId : null,
          reason: state.status,
          error: state.error === undefined ? null : {
            name: state.error.name,
            kind: state.error.kind,
            type: state.error.type
          }
        });
      }
    }
  }, [id, appearance, state.status, state.error, definitionId, extensionKey, resourceType, fireEvent]);

  // NB: once the smart-card has rendered into an end state, we capture
  // this as a successful render. These can be one of:
  // - the resolved state: when metadata is shown;
  // - the unresolved states: viz. forbidden, not_found, unauthorized, errored.
  useEffect(() => {
    if (isFinalState(state.status)) {
      succeedUfoExperience('smart-link-rendered', id || 'NULL', {
        extensionKey,
        display: isFlexibleUi ? 'flexible' : appearance
      });

      // UFO will disregard this if authentication experience has not yet been started
      succeedUfoExperience('smart-link-authenticated', id || 'NULL', {
        display: isFlexibleUi ? 'flexible' : appearance
      });
      fireEvent('ui.smartLink.renderSuccess', {
        display: isFlexibleUi ? 'flexible' : appearance
      });
    }
  }, [appearance, extensionKey, fireEvent, id, isFlexibleUi, state.status]);
  const onIframeDwell = useCallback((dwellTime, dwellPercentVisible) => {
    fireEvent('ui.smartLinkIframe.dwelled', {
      id,
      definitionId: definitionId !== null && definitionId !== void 0 ? definitionId : null,
      display: isFlexibleUi ? 'flexible' : appearance,
      dwellPercentVisible,
      dwellTime
    });
  }, [id, appearance, definitionId, isFlexibleUi, fireEvent]);
  const onIframeFocus = useCallback(() => {
    fireEvent('ui.smartLinkIframe.focused', {
      id,
      definitionId: definitionId !== null && definitionId !== void 0 ? definitionId : null,
      display: isFlexibleUi ? 'flexible' : appearance
    });
  }, [id, appearance, definitionId, isFlexibleUi, fireEvent]);
  if (isFlexibleUi) {
    let cardState = state;
    if (error) {
      if ((error === null || error === void 0 ? void 0 : error.name) === 'APIError') {
        cardState = {
          status: 'errored'
        };
      } else {
        throw error;
      }
    }
    return /*#__PURE__*/React.createElement(FlexibleCard, {
      id: id,
      cardState: cardState,
      onAuthorize: services.length && handleAuthorize || undefined,
      onClick: handleClickWrapper,
      origin: "smartLinkCard",
      renderers: renderers,
      ui: ui,
      showHoverPreview: showHoverPreview,
      hoverPreviewOptions: hoverPreviewOptions,
      actionOptions: actionOptions,
      url: url,
      testId: testId,
      onResolve: onResolve,
      onError: onError
    }, children);
  }

  // We have to keep this last to prevent hook order from being violated
  if (error) {
    throw error;
  }
  switch (appearance) {
    case 'inline':
      return /*#__PURE__*/React.createElement(InlineCard, {
        id: id,
        url: url,
        renderers: renderers,
        cardState: state,
        handleAuthorize: services.length && handleAuthorize || undefined,
        handleFrameClick: handleClickWrapper,
        isSelected: isSelected,
        isHovered: isHovered,
        onResolve: onResolve,
        onError: onError,
        testId: testId,
        inlinePreloaderStyle: inlinePreloaderStyle,
        showHoverPreview: showHoverPreview,
        hoverPreviewOptions: hoverPreviewOptions,
        actionOptions: actionOptions,
        removeTextHighlightingFromTitle: removeTextHighlightingFromTitle,
        resolvingPlaceholder: resolvingPlaceholder,
        truncateInline: truncateInline
      });
    case 'block':
      return /*#__PURE__*/React.createElement(BlockCard, {
        id: id,
        url: url,
        renderers: renderers,
        authFlow: config && config.authFlow,
        cardState: state,
        handleAuthorize: services.length && handleAuthorize || undefined,
        handleFrameClick: handleClickWrapper,
        isSelected: isSelected,
        onResolve: onResolve,
        onError: onError,
        testId: testId,
        actionOptions: actionOptions
      });
    case 'embed':
      return /*#__PURE__*/React.createElement(EmbedCard, {
        id: id,
        url: url,
        renderers: renderers,
        cardState: state,
        iframeUrlType: embedIframeUrlType,
        handleAuthorize: services.length && handleAuthorize || undefined,
        handleErrorRetry: handleRetry,
        handleFrameClick: handleClickWrapper,
        handleInvoke: handleInvoke,
        isSelected: isSelected,
        frameStyle: frameStyle,
        platform: platform,
        onResolve: onResolve,
        onError: onError,
        testId: testId,
        inheritDimensions: inheritDimensions,
        actionOptions: actionOptions,
        ref: embedIframeRef,
        onIframeDwell: onIframeDwell,
        onIframeFocus: onIframeFocus
      });
  }
}
export const CardWithUrlContent = props => {
  const display = isFlexibleUiCard(props.children, fg('platform-linking-flexible-card-openness') ? props === null || props === void 0 ? void 0 : props.ui : undefined) ? CardDisplay.Flexible : props.appearance;
  return /*#__PURE__*/React.createElement(SmartLinkModalProvider, null, /*#__PURE__*/React.createElement(SmartLinkAnalyticsContext, {
    url: props.url,
    id: props.id,
    display: display
  }, /*#__PURE__*/React.createElement(Component, props)));
};