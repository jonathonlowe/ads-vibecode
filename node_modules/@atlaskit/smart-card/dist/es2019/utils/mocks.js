import { CardClient } from '@atlaskit/link-provider';
export const mockContext = {
  '@vocab': 'https://www.w3.org/ns/activitystreams#',
  atlassian: 'https://schema.atlassian.com/ns/vocabulary#',
  schema: 'http://schema.org/'
};
export const mockGenerator = {
  '@type': 'Application',
  '@id': 'https://www.atlassian.com/#Jira',
  name: 'Jira'
};
export const mockByUrl = url => {
  return {
    meta: {
      visibility: 'public',
      access: 'granted',
      auth: [],
      definitionId: 'd1',
      key: 'object-provider',
      resourceType: 'object-resource',
      subproduct: 'object-subproduct',
      product: 'object-product'
    },
    data: {
      '@context': {
        '@vocab': 'https://www.w3.org/ns/activitystreams#',
        atlassian: 'https://schema.atlassian.com/ns/vocabulary#',
        schema: 'http://schema.org/'
      },
      '@type': 'Object',
      name: url,
      summary: 'Here is your serving of cheese: ðŸ§€',
      'schema:potentialAction': {
        '@id': 'comment',
        '@type': 'CommentAction',
        identifier: 'object-provider',
        name: 'Comment'
      },
      preview: {
        href: 'https://www.ilovecheese.com'
      },
      url: url
    }
  };
};
const errorResponseData = {
  '@context': {
    '@vocab': 'https://www.w3.org/ns/activitystreams#',
    atlassian: 'https://schema.atlassian.com/ns/vocabulary#',
    schema: 'http://schema.org/'
  },
  '@type': 'Object',
  name: 'I love cheese',
  url: 'https://some.url'
};
const successfulResponseData = {
  ...errorResponseData,
  summary: 'Here is your serving of cheese: ðŸ§€',
  'schema:potentialAction': {
    '@id': 'download',
    '@type': 'DownloadAction',
    identifier: 'object-provider',
    name: 'Download'
  },
  'atlassian:downloadUrl': 'https://some-download.url',
  'atlassian:ari': 'ari:cloud:example:1234',
  preview: {
    href: 'https://www.ilovecheese.com'
  }
};
const jsonLdResponse = {
  meta: {
    visibility: 'public',
    access: 'granted',
    auth: [],
    definitionId: 'd1',
    key: 'object-provider'
  },
  data: successfulResponseData
};
const nounDataResponse = {
  nounData: {
    id: 'I love cheese',
    displayName: 'I love cheese',
    url: 'https://some.url',
    lastUpdatedAt: '2025-01-08T22:26:52.501Z',
    thumbnail: {
      externalUrl: 'https://www.ilovecheese.com'
    },
    'atlassian:design': {
      liveEmbedUrl: 'https://www.ilovecheese.com',
      type: 'FILE',
      inspectUrl: 'https://www.ilovecheese.com',
      iconUrl: 'https://www.ilovecheese.com'
    }
  }
};
export const mocks = {
  success: {
    ...jsonLdResponse
  },
  nounDataSuccess: {
    ...jsonLdResponse,
    ...nounDataResponse,
    meta: {
      ...jsonLdResponse.meta,
      generator: {
        name: 'I love cheese',
        icon: {
          url: 'https://www.ilovecheese.com'
        }
      }
    }
  },
  notFound: {
    meta: {
      visibility: 'not_found',
      access: 'forbidden',
      auth: [],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: errorResponseData
  },
  forbidden: {
    meta: {
      visibility: 'restricted',
      access: 'forbidden',
      auth: [{
        key: 'some-flow',
        displayName: 'Flow',
        url: 'https://outbound-auth/flow'
      }],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: errorResponseData
  },
  forbiddenWithNoAuth: {
    meta: {
      visibility: 'restricted',
      access: 'forbidden',
      auth: [],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: errorResponseData
  },
  unauthorized: {
    meta: {
      visibility: 'restricted',
      access: 'unauthorized',
      auth: [{
        key: 'some-flow',
        displayName: 'Flow',
        url: 'https://outbound-auth/flow'
      }],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: errorResponseData
  },
  unauthorizedWithNoAuth: {
    meta: {
      visibility: 'restricted',
      access: 'unauthorized',
      auth: [],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: errorResponseData
  },
  actionSuccess: {
    meta: {
      visibility: 'public',
      access: 'granted',
      auth: [],
      definitionId: 'd1'
    },
    data: {
      status: 'CompletedStatus'
    }
  },
  analytics: {
    status: 'resolved',
    details: {
      meta: {
        visibility: 'public',
        access: 'granted',
        auth: [],
        definitionId: 'spaghetti-id',
        key: 'spaghetti-key',
        resourceType: 'spaghetti-resource',
        subproduct: 'spaghetti-subproduct',
        product: 'spaghetti-product'
      }
    }
  },
  withDatasource: {
    meta: {
      visibility: 'public',
      access: 'granted',
      auth: [],
      definitionId: 'd1',
      key: 'object-provider'
    },
    data: successfulResponseData,
    datasources: [{
      key: 'datasource-jira-issues',
      parameters: {
        jql: '(text ~ "test*" OR summary ~ "test*") order by created DESC',
        cloudId: '16f8b71e'
      },
      id: '1234-test-id-321',
      ari: 'ari:cloud:linking-platform::datasource/1234-test-id-321',
      description: 'For extracting a list of Jira issues using JQL',
      name: 'Jira issues'
    }]
  }
};
export const fakeResponse = () => Promise.resolve(mocks.success);
export const fakeFactory = (implementation, implementationPost, implementationPrefetch, implementationAri) => class CustomClient extends CardClient {
  // @ts-ignore
  async fetchData(url) {
    return await implementation(url);
  }
  // @ts-ignore
  async postData() {
    return await implementationPost();
  }
  // @ts-ignore
  async prefetchData() {
    return await implementationPrefetch();
  }
  // @ts-ignore
  async fetchDataAris(aris) {
    return await implementationAri(aris);
  }
};
export const waitFor = (time = 1) => new Promise(res => setTimeout(res, time));