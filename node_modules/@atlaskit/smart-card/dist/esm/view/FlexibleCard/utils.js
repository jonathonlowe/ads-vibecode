import { extractProvider } from '@atlaskit/link-extractors';
import { fg } from '@atlaskit/platform-feature-flags';
import { SmartLinkStatus } from '../../constants';
import { extractRequestAccessContextImproved } from '../../extractors/common/context';
import extractFlexibleUiContext from '../../extractors/flexible';
import extractPreview from '../../extractors/flexible/extract-preview';
import { extractErrorIcon } from '../../extractors/flexible/icon';
import extractProviderIcon from '../../extractors/flexible/icon/extract-provider-icon';
import { messages } from '../../messages';
import { handleOnClick } from '../../utils';
import { getEmptyJsonLd, getForbiddenJsonLd } from '../../utils/jsonld';
export var getContextByStatus = function getContextByStatus(params) {
  var _ref = params !== null && params !== void 0 ? params : {},
    response = _ref.response,
    status = _ref.status,
    url = _ref.url;
  switch (status) {
    case SmartLinkStatus.Pending:
    case SmartLinkStatus.Resolving:
      return {
        title: url,
        url: url
      };
    case SmartLinkStatus.Resolved:
      return extractFlexibleUiContext(params);
    case SmartLinkStatus.Unauthorized:
    case SmartLinkStatus.Forbidden:
    case SmartLinkStatus.NotFound:
    case SmartLinkStatus.Errored:
    case SmartLinkStatus.Fallback:
    default:
      var preview = extractPreview(response === null || response === void 0 ? void 0 : response.data);
      var linkIcon = extractErrorIcon(response, status);
      var provider = extractProviderIcon(response === null || response === void 0 ? void 0 : response.data);
      return {
        linkIcon: linkIcon,
        title: url,
        url: url,
        provider: provider,
        preview: preview
      };
  }
};
var getForbiddenMessageKey = function getForbiddenMessageKey(meta) {
  var _meta$requestAccess;
  var accessType = meta === null || meta === void 0 || (_meta$requestAccess = meta.requestAccess) === null || _meta$requestAccess === void 0 ? void 0 : _meta$requestAccess.accessType;
  switch (accessType) {
    case 'DIRECT_ACCESS':
      return fg('confluence-issue-terminology-refresh') ? 'join_to_viewIssueTermRefresh' : 'join_to_view';
    case 'REQUEST_ACCESS':
      return fg('confluence-issue-terminology-refresh') ? 'request_access_to_viewIssueTermRefresh' : 'request_access_to_view';
    case 'PENDING_REQUEST_EXISTS':
      return 'pending_request';
    case 'FORBIDDEN':
      return 'forbidden_access';
    case 'DENIED_REQUEST_EXISTS':
      return 'request_denied';
    default:
      return 'restricted_link';
  }
};
export var getRetryOptions = function getRetryOptions(url, status, response, onAuthorize) {
  var _response$meta, _access$action, _access$buttonDisable;
  var data = response && response.data || getEmptyJsonLd();
  var provider = extractProvider(data);
  var context = provider === null || provider === void 0 ? void 0 : provider.text;
  var values = context ? {
    context: context
  } : undefined;
  switch (status) {
    case SmartLinkStatus.Forbidden:
      var meta = (_response$meta = response === null || response === void 0 ? void 0 : response.meta) !== null && _response$meta !== void 0 ? _response$meta : getForbiddenJsonLd().meta;
      var access = extractRequestAccessContextImproved({
        jsonLd: meta,
        url: url,
        product: context !== null && context !== void 0 ? context : ''
      });
      var messageKey = getForbiddenMessageKey(meta);
      var descriptor = messages[messageKey];
      var retry = onAuthorize || (access === null || access === void 0 || (_access$action = access.action) === null || _access$action === void 0 ? void 0 : _access$action.promise);
      var onClick = retry && !((_access$buttonDisable = access === null || access === void 0 ? void 0 : access.buttonDisabled) !== null && _access$buttonDisable !== void 0 ? _access$buttonDisable : false) ? handleOnClick(retry) : undefined;
      return {
        descriptor: descriptor,
        onClick: onClick,
        values: values
      };
    case SmartLinkStatus.Unauthorized:
      return onAuthorize ? {
        descriptor: messages.connect_link_account_card_name,
        onClick: handleOnClick(onAuthorize),
        values: values
      } : undefined;
    case SmartLinkStatus.NotFound:
      return {
        descriptor: messages.cannot_find_link
      };
  }
};