import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useCallback } from 'react';
import { useSmartLinkContext } from '@atlaskit/link-provider';
import { ACTION_UPDATE_METADATA_STATUS, cardAction } from '@atlaskit/linking-common';
export function usePrefetch(url) {
  var _useSmartLinkContext = useSmartLinkContext(),
    store = _useSmartLinkContext.store,
    prefetchStore = _useSmartLinkContext.prefetchStore,
    connections = _useSmartLinkContext.connections;
  var _ref = store || {},
    dispatch = _ref.dispatch,
    getState = _ref.getState;
  var _ref2 = connections || {},
    client = _ref2.client;
  return useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var isPrefetching, isFetching, needsPrefetch, response;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(!store || !prefetchStore || !connections)) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return");
        case 2:
          // If the link is already being prefetched, the prefetch store
          // should have a flag set against the URL. The prefetch store is purposefully
          // separate from the UI in order to ensure no rendering takes place;
          // all mutations which occur are purely store-based mutations.
          isPrefetching = prefetchStore[url]; // If the link has already been registered in the store, then it no
          // longer needs to be prefetched, as the normal flow of a link being in
          // the viewport and being fetched is now in motion.
          isFetching = getState()[url]; // We compute if a link needs to be prefetched thus, referencing the above.
          needsPrefetch = !isPrefetching && !isFetching;
          if (!needsPrefetch) {
            _context.next = 16;
            break;
          }
          // We specify in the prefetch store that this link no
          // longer needs to be prefetched. Data which comes back
          // from a successful prefetch flow here will be used to
          // render all URLs which are the same.
          prefetchStore[url] = true;
          // Try fetch the data for this URL from Object Resolver Service (ORS), executing batch
          // requests by domain (as usual) to ensure we minimize the amount of connections
          // we create between browser -> ORS when making network requests.
          _context.prev = 7;
          _context.next = 10;
          return client.prefetchData(url);
        case 10:
          response = _context.sent;
          // Once the data comes back, we put the link in the `resolved` status. This ensures
          // that when the link enters the viewport and is rendered, we immediately show it as
          // a Smart Link, rather than rendering a loading spinner -> immediate Smart Link.
          if (response) {
            dispatch({
              type: 'resolved',
              url: url,
              payload: response
            });
            // Put the metadata in resolved state, theres no need for a pending or errored state as
            // we are following the same render flow as described by the comments above and below.
            dispatch(cardAction(ACTION_UPDATE_METADATA_STATUS, {
              url: url
            }, undefined, undefined, 'resolved'));
          }
          _context.next = 16;
          break;
        case 14:
          _context.prev = 14;
          _context.t0 = _context["catch"](7);
        case 16:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[7, 14]]);
  })), [store, prefetchStore, connections, url, getState, client, dispatch]);
}