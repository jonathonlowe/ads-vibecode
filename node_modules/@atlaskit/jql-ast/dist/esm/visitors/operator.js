import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _createSuper(t) { var r = _isNativeReflectConstruct(); return function () { var e, o = _getPrototypeOf(t); if (r) { var s = _getPrototypeOf(this).constructor; e = Reflect.construct(o, arguments, s); } else e = o.apply(this, arguments); return _possibleConstructorReturn(this, e); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { internalCreators } from '../creators';
import { isChangedOperator, isComparisonOperator, isEqualsOperator, isInOperator, isIsOperator, isLikeOperator, isOperator, isWasInOperator, isWasOperator } from '../types';
import { getPositionFromContext, getPositionFromToken, JastBuildingVisitor, normalizeText } from './common';
export var OperatorVisitor = /*#__PURE__*/function (_JastBuildingVisitor) {
  _inherits(OperatorVisitor, _JastBuildingVisitor);
  var _super = _createSuper(OperatorVisitor);
  function OperatorVisitor() {
    var _this;
    _classCallCheck(this, OperatorVisitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    // Recover from clause type ambiguities, e.g. "issuetype was " (which can be a WAS or WAS IN clause)
    _defineProperty(_assertThisInitialized(_this), "visitChildren", function (node) {
      var sourceInterval = node.sourceInterval;
      var text = _this.tokens.getText(sourceInterval);
      if (text) {
        var value = normalizeText(text);
        var startIndex = sourceInterval.a,
          stopIndex = sourceInterval.b;
        var startToken = _this.tokens.get(startIndex);
        var stopToken = _this.tokens.get(stopIndex);
        var position = getPositionFromToken(startToken, stopToken);
        if (isOperator(value)) {
          return internalCreators.operator(value, text, position);
        }
      }
    });
    return _this;
  }
  _createClass(OperatorVisitor, [{
    key: "visitJqlEqualsOperator",
    value: function visitJqlEqualsOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!isEqualsOperator(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised equals operators"));
      }
      return internalCreators.operator(text, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlLikeOperator",
    value: function visitJqlLikeOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!isLikeOperator(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised like operators"));
      }
      return internalCreators.operator(text, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlComparisonOperator",
    value: function visitJqlComparisonOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!isComparisonOperator(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised comparison operators"));
      }
      return internalCreators.operator(text, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlInOperator",
    value: function visitJqlInOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = normalizeText(text);
      if (!isInOperator(value)) {
        // This can happen if an incomplete operator is used, e.g. `status not open`.
        return undefined;
      }
      return internalCreators.operator(value, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlIsOperator",
    value: function visitJqlIsOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = normalizeText(text);
      if (!isIsOperator(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised is operators"));
      }
      return internalCreators.operator(value, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlWasOperator",
    value: function visitJqlWasOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = normalizeText(text);
      if (!isWasOperator(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised was operators"));
      }
      return internalCreators.operator(value, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlWasInOperator",
    value: function visitJqlWasInOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = normalizeText(text);
      if (!isWasInOperator(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised was in operators"));
      }
      return internalCreators.operator(value, text, getPositionFromContext(ctx));
    }
  }, {
    key: "visitJqlChangedOperator",
    value: function visitJqlChangedOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = normalizeText(text);
      if (!isChangedOperator(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised changed operators"));
      }
      return internalCreators.operator(value, text, getPositionFromContext(ctx));
    }
  }]);
  return OperatorVisitor;
}(JastBuildingVisitor);