import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var computeFlatWidth = function computeFlatWidth(doc) {
  if (typeof doc === 'string') {
    return doc.length;
  }
  if (Array.isArray(doc)) {
    return doc.reduce(function (result, innerDoc) {
      return result + computeFlatWidth(innerDoc);
    }, 0);
  }
  switch (doc.type) {
    case 'group':
      {
        return computeFlatWidth(doc.contents);
      }
    case 'if-break':
      {
        return computeFlatWidth(doc.flatContents);
      }
    case 'new-line':
      {
        // TODO This probably represents a bug as we don't expect new lines in the flat path
        return 0;
      }
    default:
      throw new Error('Unrecognised doc type.');
  }
};
var printDoc = function printDoc(doc, context) {
  if (typeof doc === 'string') {
    return {
      result: doc,
      endIndex: context.startIndex + doc.length
    };
  }
  switch (doc.type) {
    case 'group':
      {
        return printGroup(doc, context);
      }
    case 'if-break':
      {
        return printIfBreak(doc, context);
      }
    case 'new-line':
      {
        return printNewLine();
      }
    default:
      throw new Error('Unrecognised doc type.');
  }
};
var printGroup = function printGroup(doc, context) {
  var docWidth = context.startIndex + computeFlatWidth(doc);
  var breakContents = context.printWidth !== null && docWidth > context.printWidth;
  return doc.contents.reduce(function (agg, innerDoc) {
    var innerContext = _objectSpread(_objectSpread({}, context), {}, {
      startIndex: agg.endIndex,
      breakContents: breakContents
    });
    var output = printDoc(innerDoc, innerContext);
    return {
      result: agg.result + output.result,
      endIndex: output.endIndex
    };
  }, {
    result: '',
    endIndex: context.startIndex
  });
};
var printIfBreak = function printIfBreak(doc, context) {
  if (context.breakContents) {
    return printDoc(doc.breakContents, context);
  }
  return printDoc(doc.flatContents, context);
};
var printNewLine = function printNewLine() {
  return {
    result: '\n',
    // Reset our end index as a new line is being output.
    endIndex: 0
  };
};
// TODO Tweak this number with design
var defaultPrintWidth = 100;
export var printDocToString = function printDocToString(doc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$printWidth = options.printWidth,
    printWidth = _options$printWidth === void 0 ? defaultPrintWidth : _options$printWidth;
  var output = printDoc(doc, {
    printWidth: printWidth,
    startIndex: 0,
    breakContents: false
  });
  return output.result;
};