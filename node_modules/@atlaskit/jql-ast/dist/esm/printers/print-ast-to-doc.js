import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
function _createSuper(t) { var r = _isNativeReflectConstruct(); return function () { var e, o = _getPrototypeOf(t); if (r) { var s = _getPrototypeOf(this).constructor; e = Reflect.construct(o, arguments, s); } else e = o.apply(this, arguments); return _possibleConstructorReturn(this, e); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { CLAUSE_TYPE_COMPOUND } from '../constants';
import { AbstractJastVisitor } from '../jast-visitors';
import { group, ifBreak, newLine } from './utils';
var formatOperator = function formatOperator(operator, operatorCase) {
  switch (operatorCase) {
    case 'lower':
      return operator.toLowerCase();
    case 'upper':
      return operator.toUpperCase();
    case 'preserve':
      return operator;
  }
};
export var AstToDocVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  _inherits(AstToDocVisitor, _AbstractJastVisitor);
  var _super = _createSuper(AstToDocVisitor);
  function AstToDocVisitor() {
    var _this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      operatorCase = _ref.operatorCase;
    _classCallCheck(this, AstToDocVisitor);
    _this = _super.call(this);
    _this.operatorCase = operatorCase || 'preserve';
    return _this;
  }
  _createClass(AstToDocVisitor, [{
    key: "visitArgument",
    value: function visitArgument(argument) {
      return argument.text;
    }

    /**
     * Visit each of the provided nodes and form a new array with each `Doc` joined by the provided separator.
     */
  }, {
    key: "joinNodes",
    value: function joinNodes(nodes, separator) {
      var _this2 = this;
      var docs = [];
      nodes.forEach(function (node) {
        if (separator !== undefined && docs.length > 0) {
          docs.push(separator);
        }
        docs.push(node.accept(_this2));
      });
      return docs;
    }
  }, {
    key: "visitCompoundClause",
    value: function visitCompoundClause(compoundClause) {
      var _this3 = this;
      var operatorDoc = compoundClause.operator.accept(this);
      var clauseDocs = [];
      compoundClause.clauses.forEach(function (clause) {
        if (clauseDocs.length > 0) {
          clauseDocs.push(ifBreak(newLine(), ' '), operatorDoc, ' ');
        }

        // Wrap nested compound clauses in parentheses
        if (clause.clauseType === CLAUSE_TYPE_COMPOUND) {
          clauseDocs.push('(', clause.accept(_this3), ')');
        } else {
          clauseDocs.push(clause.accept(_this3));
        }
      });
      return group(clauseDocs);
    }
  }, {
    key: "visitCompoundOperator",
    value: function visitCompoundOperator(compoundOperator) {
      return formatOperator(compoundOperator.value, this.operatorCase);
    }
  }, {
    key: "visitField",
    value: function visitField(field) {
      var propertyDocs = field.properties ? this.joinNodes(field.properties) : [];
      return group([field.text].concat(_toConsumableArray(propertyDocs)));
    }
  }, {
    key: "visitFunction",
    value: function visitFunction(functionString) {
      return functionString.text;
    }
  }, {
    key: "visitFunctionOperand",
    value: function visitFunctionOperand(functionOperand) {
      var argumentDocs = this.joinNodes(functionOperand.arguments, ', ');
      return group([functionOperand.function.accept(this), '('].concat(_toConsumableArray(argumentDocs), [')']));
    }
  }, {
    key: "visitKeywordOperand",
    value: function visitKeywordOperand(keywordOperand) {
      return keywordOperand.value;
    }
  }, {
    key: "visitListOperand",
    value: function visitListOperand(listOperand) {
      var operandDocs = this.joinNodes(listOperand.values, ', ');
      return group(['('].concat(_toConsumableArray(operandDocs), [')']));
    }
  }, {
    key: "visitOperator",
    value: function visitOperator(operator) {
      return formatOperator(operator.text, this.operatorCase);
    }
  }, {
    key: "visitOrderBy",
    value: function visitOrderBy(orderBy) {
      var fieldDocs = this.joinNodes(orderBy.fields, ', ');
      return group([orderBy.operator.accept(this), ' '].concat(_toConsumableArray(fieldDocs)));
    }
  }, {
    key: "visitOrderByDirection",
    value: function visitOrderByDirection(orderByDirection) {
      return orderByDirection.value;
    }
  }, {
    key: "visitOrderByField",
    value: function visitOrderByField(orderByField) {
      var docs = [orderByField.field.accept(this)];
      if (orderByField.direction) {
        docs.push(' ', orderByField.direction.accept(this));
      }
      return group(docs);
    }
  }, {
    key: "visitOrderByOperator",
    value: function visitOrderByOperator(orderByOperator) {
      return formatOperator(orderByOperator.value, this.operatorCase);
    }
  }, {
    key: "visitPredicate",
    value: function visitPredicate(predicate) {
      var docs = [predicate.operator.accept(this)];
      if (predicate.operand) {
        docs.push(' ', predicate.operand.accept(this));
      }
      return group(docs);
    }
  }, {
    key: "visitPredicateOperator",
    value: function visitPredicateOperator(predicateOperator) {
      return formatOperator(predicateOperator.text, this.operatorCase);
    }
  }, {
    key: "visitProperty",
    value: function visitProperty(property) {
      var docs = [];
      if (property.key) {
        docs.push('[', property.key.accept(this), ']');
      }
      if (property.path) {
        var pathDocs = this.joinNodes(property.path, ' ');
        docs.push.apply(docs, _toConsumableArray(pathDocs));
      }
      return group(docs);
    }
  }, {
    key: "visitQuery",
    value: function visitQuery(query) {
      if (query.where && query.orderBy) {
        return group([query.where.accept(this), ifBreak(newLine(), ' '), query.orderBy.accept(this)]);
      } else if (query.where) {
        return query.where.accept(this);
      } else if (query.orderBy) {
        return query.orderBy.accept(this);
      }
      return '';
    }
  }, {
    key: "visitTerminalClause",
    value: function visitTerminalClause(terminalClause) {
      var _this4 = this;
      var docs = [terminalClause.field.accept(this)];
      if (terminalClause.operator) {
        docs.push(' ', terminalClause.operator.accept(this));
      }
      if (terminalClause.operand) {
        docs.push(' ', terminalClause.operand.accept(this));
      }
      terminalClause.predicates.forEach(function (predicate) {
        docs.push(' ', predicate.accept(_this4));
      });
      return group(docs);
    }
  }, {
    key: "visitValueOperand",
    value: function visitValueOperand(valueOperand) {
      return valueOperand.text;
    }
  }, {
    key: "visitNotClause",
    value: function visitNotClause(notClause) {
      var clauseDocs = [];
      // Wrap nested compound clauses in parentheses
      if (notClause.clause.clauseType === CLAUSE_TYPE_COMPOUND) {
        clauseDocs.push('(', notClause.clause.accept(this), ')');
      } else {
        clauseDocs.push(notClause.clause.accept(this));
      }
      return group([notClause.operator.accept(this), ' '].concat(clauseDocs));
    }
  }, {
    key: "visitNotClauseOperator",
    value: function visitNotClauseOperator(notClauseOperator) {
      return notClauseOperator.value;
    }
  }, {
    key: "visitChildren",
    value: function visitChildren() {
      throw new Error('Required visit method not implemented for node');
    }
  }, {
    key: "defaultResult",
    value: function defaultResult() {
      return '';
    }
  }]);
  return AstToDocVisitor;
}(AbstractJastVisitor);
export var printAstToDoc = function printAstToDoc(jast, options) {
  var astToDocVisitor = new AstToDocVisitor(options);
  return jast.query ? jast.query.accept(astToDocVisitor) : '';
};