/**
 * Declare separate creator functions for public and internal usage. Internal creators have a more verbose method
 * signature to give granular control over contextual node data such as position. Public creators are a simplified API
 * we provide to consumers to be used during AST transformation.
 */
export declare const internalCreators: {
    query: (where: void | import("..").Clause, orderBy: void | import("..").OrderBy, position?: import("..").Position | null) => import("..").Query;
    compoundClause: (operator: import("..").CompoundOperator, clauses: import("..").Clause[], position?: import("..").Position | null) => import("..").CompoundClause;
    compoundOperator: (value: import("..").CompoundOperatorValue, operatorPositions: import("..").Position[]) => import("..").CompoundOperator;
    terminalClause: (field: import("..").Field, operator: void | import("..").Operator, operand: void | import("..").Operand, predicates: import("..").Predicate[], position?: import("..").Position | null) => import("..").TerminalClause;
    notClause: (clause: import("..").Clause, operator: import("..").NotClauseOperator, position?: import("..").Position | null) => import("..").NotClause;
    notClauseOperator: (position?: import("..").Position | null) => import("..").NotClauseOperator;
    predicate: (operator: import("..").PredicateOperator, operand: void | import("..").Operand, position?: import("..").Position | null) => import("..").Predicate;
    predicateOperator: (value: "after" | "before" | "by" | "during" | "from" | "on" | "to", text: string, position?: import("..").Position | null) => import("..").PredicateOperator;
    field: (value: string, text: string, properties: void | import("..").Property[], position?: import("..").Position | null) => import("..").Field;
    property: (key: void | import("..").Argument, path: import("..").Argument[], position?: import("..").Position | null) => import("..").Property;
    operator: (value: "=" | "!=" | ">" | "<" | ">=" | "<=" | "in" | "not in" | "~" | "!~" | "is" | "is not" | "was" | "was in" | "was not in" | "was not" | "changed", text: string, position?: import("..").Position | null) => import("..").Operator;
    valueOperand: (value: string, text: string, position?: import("..").Position | null) => import("..").ValueOperand;
    keywordOperand: (value: "empty", position?: import("..").Position | null) => import("..").KeywordOperand;
    functionOperand: (functionString: import("..").FunctionString, args: import("..").Argument[], position?: import("..").Position | null) => import("..").FunctionOperand;
    functionString: (value: string, text: string, position?: import("..").Position | null) => import("..").FunctionString;
    argument: (value: string, text: string, position?: import("..").Position | null) => import("..").Argument;
    listOperand: (values: import("..").Operand[], position?: import("..").Position | null) => import("..").ListOperand;
    orderBy: (fields: import("..").OrderByField[], operator: import("..").OrderByOperator, position?: import("..").Position | null) => import("..").OrderBy;
    orderByOperator: (position?: import("..").Position | null) => import("..").OrderByOperator;
    orderByField: (field: import("..").Field, direction: void | import("..").OrderByDirection, position?: import("..").Position | null) => import("..").OrderByField;
    orderByDirection: (value: import("..").OrderByDirectionValue, position?: import("..").Position | null) => import("..").OrderByDirection;
};
declare const _default: {
    jast: (query: void | import("..").Query, represents?: string, errors?: import("..").JQLParseError[]) => import("..").Jast;
    query: (where: void | import("..").Clause, orderBy?: import("..").OrderBy | undefined) => import("..").Query;
    compoundClause: (operator: import("..").CompoundOperator, clauses: import("..").Clause[]) => import("..").CompoundClause;
    compoundOperator: (value: import("..").CompoundOperatorValue) => import("..").CompoundOperator;
    terminalClause: (field: import("..").Field, operator?: import("..").Operator | undefined, operand?: import("..").Operand | undefined, predicates?: import("..").Predicate[]) => import("..").TerminalClause;
    notClause: (clause: import("..").Clause) => import("..").NotClause;
    notClauseOperator: () => import("..").NotClauseOperator;
    predicate: (operator: import("..").PredicateOperator, operand?: import("..").Operand | undefined) => import("..").Predicate;
    predicateOperator: (value: "after" | "before" | "by" | "during" | "from" | "on" | "to") => import("..").PredicateOperator;
    field: (value: string, properties?: import("..").Property[] | undefined) => import("..").Field;
    property: (key: void | import("..").Argument, path?: import("..").Argument[]) => import("..").Property;
    operator: (value: "=" | "!=" | ">" | "<" | ">=" | "<=" | "in" | "not in" | "~" | "!~" | "is" | "is not" | "was" | "was in" | "was not in" | "was not" | "changed") => import("..").Operator;
    valueOperand: (value: string) => import("..").ValueOperand;
    keywordOperand: () => import("..").KeywordOperand;
    functionOperand: (functionString: import("..").FunctionString, args?: import("..").Argument[]) => import("..").FunctionOperand;
    functionString: (value: string) => import("..").FunctionString;
    argument: (value: string) => import("..").Argument;
    listOperand: (values: import("..").Operand[]) => import("..").ListOperand;
    orderBy: (fields: import("..").OrderByField[]) => import("..").OrderBy;
    orderByOperator: () => import("..").OrderByOperator;
    orderByField: (field: import("..").Field, direction?: import("..").OrderByDirection | undefined) => import("..").OrderByField;
    orderByDirection: (value: import("..").OrderByDirectionValue) => import("..").OrderByDirection;
    byText: {
        argument: (text: string) => import("..").Argument;
        valueOperand: (text: string) => import("..").ValueOperand;
    };
};
export default _default;
