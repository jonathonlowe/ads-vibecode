import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { CLAUSE_TYPE_COMPOUND, COLLAPSED_CUSTOM_FIELD_PATTERN, ORDER_BY_OPERATOR_ORDER_BY, PRIVACY_SAFE_FIELDS } from '../constants';
import { notUndefined } from '../utils';
import { AbstractJastVisitor } from './abstract-jast-visitor';
const ANONYMIZED_FIELD = '"?"';
const ANONYMIZED_VALUE = '"?"';
const CUSTOM_FIELD_PATTERN = /^cf\[\d+]$/i;
const privacySafeFields = new Set(PRIVACY_SAFE_FIELDS);
const getPrivacySafeFieldName = field => {
  // Privacy safe field name (Jira field)
  if (privacySafeFields.has(field.value.toLowerCase())) {
    return field.text;
  }

  // Custom field identifier, e.g. cf[10001]
  if (CUSTOM_FIELD_PATTERN.test(field.value)) {
    return field.text;
  }

  // Collapsed custom field
  const match = field.text.match(COLLAPSED_CUSTOM_FIELD_PATTERN);
  if (match) {
    return `"?[${match[1]}]"`;
  }

  // Other field names that can potentially contain UGC
  return ANONYMIZED_FIELD;
};
export class JqlAnonymizerVisitor extends AbstractJastVisitor {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "visitQuery", query => {
      const where = query.where ? query.where.accept(this) : undefined;
      const orderBy = query.orderBy ? query.orderBy.accept(this) : undefined;
      return [where, orderBy].filter(notUndefined).join(' ');
    });
    _defineProperty(this, "visitField", field => {
      const name = getPrivacySafeFieldName(field);
      if (field.properties && field.properties.length) {
        const properties = field.properties.map(property => {
          const key = property.key ? property.key.text : '';
          const path = property.path ? property.path.map(arg => arg.text).join('') : '';
          return `[${key}]${path}`;
        }).join('');
        return `${name}${properties}`;
      }
      return name;
    });
    _defineProperty(this, "visitTerminalClause", terminalClause => {
      const field = terminalClause.field.accept(this);
      const operator = terminalClause.operator ? terminalClause.operator.text : undefined;
      const operand = terminalClause.operand ? terminalClause.operand.accept(this) : undefined;
      const predicates = terminalClause.predicates.map(predicate => predicate.accept(this));
      return [field, operator, operand, ...predicates].filter(notUndefined).join(' ');
    });
    _defineProperty(this, "visitCompoundClause", compoundClause => {
      const operator = compoundClause.operator.value;
      return compoundClause.clauses.map(clause => {
        // Nested compound clauses should be wrapped in parentheses
        return clause.clauseType === CLAUSE_TYPE_COMPOUND ? `(${clause.accept(this)})` : clause.accept(this);
      }).join(` ${operator} `);
    });
    _defineProperty(this, "visitNotClause", notClause => {
      // Nested compound clauses should be wrapped in parentheses
      const nestedClause = notClause.clause.clauseType === CLAUSE_TYPE_COMPOUND ? `(${notClause.clause.accept(this)})` : notClause.clause.accept(this);
      return `${notClause.operator.value} ${nestedClause}`;
    });
    _defineProperty(this, "visitValueOperand", () => {
      return ANONYMIZED_VALUE;
    });
    _defineProperty(this, "visitListOperand", listOperand => {
      return `(${listOperand.values.map(value => value.accept(this)).join(', ')})`;
    });
    _defineProperty(this, "visitFunctionOperand", functionOperand => {
      const functionName = functionOperand.function.text;
      const functionArguments = functionOperand.arguments.map(() => ANONYMIZED_VALUE).join(', ');
      return `${functionName}(${functionArguments})`;
    });
    _defineProperty(this, "visitKeywordOperand", keywordOperand => {
      return keywordOperand.value;
    });
    _defineProperty(this, "visitPredicate", predicate => {
      const operator = predicate.operator.text;
      const operand = predicate.operand ? predicate.operand.accept(this) : undefined;
      return [operator, operand].filter(notUndefined).join(' ');
    });
    _defineProperty(this, "visitOrderBy", orderBy => {
      const orderByFields = orderBy.fields.map(orderByField => {
        const field = orderByField.field.accept(this);
        const direction = orderByField.direction ? orderByField.direction.value : undefined;
        return [field, direction].filter(notUndefined).join(' ');
      });
      return `${ORDER_BY_OPERATOR_ORDER_BY} ${orderByFields.join(', ')}`;
    });
  }
  defaultResult() {
    return '';
  }
}