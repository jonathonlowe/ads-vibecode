import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { walkAST } from '../api';
import { ASSIGNEE_FIELD, COLLAPSED_CUSTOM_FIELD_PATTERN_NO_QUOTES, COMPOUND_OPERATOR_AND, COMPOUND_OPERATOR_OR, CREATED_FIELD, DUE_DATE_FIELD, ISSUE_TYPE_FIELD, LAST_VIEWED_FIELD, PRIORITY_FIELD, PRIVACY_SAFE_FIELDS, PROJECT_FIELD, REPORTER_FIELD, RESOLUTION_DATE_FIELD, RESOLUTION_FIELD, STATUS_FIELD, SUMMARY_FIELD, TEAM_CUSTOM_FIELD_TYPE, TYPE_FIELD, UPDATED_FIELD } from '../constants';
/**
 * Splits the provided text by new line characters.
 */
export const splitTextByNewLine = text => text.split(/(?:\r\n?|\n)/);

/**
 * Finds the field type in the collapsed field syntax. eg. "field[xyz]" -> "[xyz]"
 */
export const collapsedFieldType = text => {
  const match = COLLAPSED_CUSTOM_FIELD_PATTERN_NO_QUOTES.exec(text.toLowerCase());
  if (match) {
    return `[${match[1]}]`;
  }
};

/**
 * Analytics computed for a JQL query.
 */

class JastAnalyticsListener {
  constructor(jast) {
    // Default attributes
    _defineProperty(this, "attributes", {
      jqlFieldValueCount: {
        issueType: 0,
        project: 0,
        assignee: 0,
        reporter: 0,
        priority: 0,
        status: 0,
        resolution: 0,
        team: 0
      },
      jqlFieldIsUsed: {
        summary: false,
        due: false,
        resolutionDate: false,
        created: false,
        lastviewed: false,
        updated: false,
        team: false
      },
      jqlUsedFields: [],
      jqlUsedFieldsCount: 0,
      jqlUsedFieldsOrderBy: [],
      jqlLineCount: 0,
      jqlErrorCount: 0,
      jqlClauseCount: {
        orderBy: 0,
        leaf: 0,
        and: 0,
        not: 0,
        or: 0
      },
      jqlMaxCompoundClauseDepth: 0
    });
    _defineProperty(this, "usedFields", new Set());
    _defineProperty(this, "usedFieldsOrderBy", new Set());
    _defineProperty(this, "fieldValueCount", 0);
    // The current number of nested compound clauses for an AST node
    _defineProperty(this, "compoundClauseDepth", 0);
    _defineProperty(this, "getFieldName", field => {
      return collapsedFieldType(field.value) || field.value.toLowerCase();
    });
    _defineProperty(this, "incrementFieldValueCount", () => {
      this.fieldValueCount += 1;
    });
    _defineProperty(this, "exitQuery", () => {
      // Track all fields used in the query using the term 'other' for non-privacy safe fields
      const privacySafeFields = new Set();
      this.usedFields.forEach(field => privacySafeFields.add(PRIVACY_SAFE_FIELDS.includes(field) ? field : 'other'));
      this.attributes.jqlUsedFields = Array.from(privacySafeFields).sort();
      this.attributes.jqlUsedFieldsCount = this.usedFields.size;
      this.attributes.jqlUsedFieldsOrderBy = Array.from(this.usedFieldsOrderBy);
    });
    _defineProperty(this, "enterCompoundClause", compoundClause => {
      if (compoundClause.operator.value === COMPOUND_OPERATOR_AND) {
        this.attributes.jqlClauseCount.and += 1;
      } else if (compoundClause.operator.value === COMPOUND_OPERATOR_OR) {
        this.attributes.jqlClauseCount.or += 1;
      }
      this.compoundClauseDepth += 1;
      if (this.compoundClauseDepth > this.attributes.jqlMaxCompoundClauseDepth) {
        this.attributes.jqlMaxCompoundClauseDepth = this.compoundClauseDepth;
      }
    });
    _defineProperty(this, "exitCompoundClause", () => {
      this.compoundClauseDepth -= 1;
    });
    _defineProperty(this, "enterTerminalClause", terminalClause => {
      const field = this.getFieldName(terminalClause.field);
      switch (field) {
        case SUMMARY_FIELD:
          this.attributes.jqlFieldIsUsed.summary = true;
          break;
        case DUE_DATE_FIELD:
          this.attributes.jqlFieldIsUsed.due = true;
          break;
        case RESOLUTION_DATE_FIELD:
          this.attributes.jqlFieldIsUsed.resolutionDate = true;
          break;
        case CREATED_FIELD:
          this.attributes.jqlFieldIsUsed.created = true;
          break;
        case LAST_VIEWED_FIELD:
          this.attributes.jqlFieldIsUsed.lastviewed = true;
          break;
        case UPDATED_FIELD:
          this.attributes.jqlFieldIsUsed.updated = true;
          break;
        case TEAM_CUSTOM_FIELD_TYPE:
          this.attributes.jqlFieldIsUsed.team = true;
          break;
      }
      this.attributes.jqlClauseCount.leaf += 1;

      // Track all fields used in the query
      this.usedFields.add(field);

      // Reset our count of RHS values for the field
      this.fieldValueCount = 0;
    });
    _defineProperty(this, "exitTerminalClause", terminalClause => {
      switch (this.getFieldName(terminalClause.field)) {
        case ISSUE_TYPE_FIELD:
        case TYPE_FIELD:
          this.attributes.jqlFieldValueCount.issueType += this.fieldValueCount;
          break;
        case PROJECT_FIELD:
          this.attributes.jqlFieldValueCount.project += this.fieldValueCount;
          break;
        case ASSIGNEE_FIELD:
          this.attributes.jqlFieldValueCount.assignee += this.fieldValueCount;
          break;
        case REPORTER_FIELD:
          this.attributes.jqlFieldValueCount.reporter += this.fieldValueCount;
          break;
        case PRIORITY_FIELD:
          this.attributes.jqlFieldValueCount.priority += this.fieldValueCount;
          break;
        case STATUS_FIELD:
          this.attributes.jqlFieldValueCount.status += this.fieldValueCount;
          break;
        case RESOLUTION_FIELD:
          this.attributes.jqlFieldValueCount.resolution += this.fieldValueCount;
          break;
        case TEAM_CUSTOM_FIELD_TYPE:
          this.attributes.jqlFieldValueCount.team += this.fieldValueCount;
          break;
        default:
          break;
      }
    });
    _defineProperty(this, "enterNotClause", () => {
      this.attributes.jqlClauseCount.not += 1;
    });
    _defineProperty(this, "enterFunctionOperand", this.incrementFieldValueCount);
    _defineProperty(this, "enterKeywordOperand", this.incrementFieldValueCount);
    _defineProperty(this, "enterValueOperand", this.incrementFieldValueCount);
    _defineProperty(this, "enterOrderByField", orderByField => {
      this.usedFieldsOrderBy.add(this.getFieldName(orderByField.field));
      this.attributes.jqlClauseCount.orderBy += 1;
    });
    this.attributes.jqlLineCount = splitTextByNewLine(jast.represents).length;
    this.attributes.jqlErrorCount = jast.errors.length;
  }
}
export const computeJqlInsights = jast => {
  const listener = new JastAnalyticsListener(jast);
  walkAST(listener, jast);
  return listener.attributes;
};