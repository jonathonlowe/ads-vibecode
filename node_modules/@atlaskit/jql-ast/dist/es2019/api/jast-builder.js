import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { CharStreams, CommonTokenStream } from 'antlr4ts';
import memoize from 'memoize-one';
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import creators from '../creators';
import { JastBuilderErrorListener, JQLParseError } from '../errors';
import { QueryVisitor } from '../visitors';
export class JastBuilder {
  constructor() {
    _defineProperty(this, "errorListeners", []);
    _defineProperty(this, "errorHandler", undefined);
    _defineProperty(this, "getTokens", memoize(value => {
      const chars = CharStreams.fromString(value);
      const lexer = new JQLLexer(chars);
      return new CommonTokenStream(lexer);
    }));
    _defineProperty(this, "getParser", memoize(tokens => new JQLParser(tokens)));
  }
  setErrorHandler(errorHandler) {
    this.errorHandler = errorHandler;
    return this;
  }
  setErrorListeners(errorListeners) {
    this.errorListeners = this.errorListeners.concat(errorListeners);
    return this;
  }
  build(value) {
    const tokens = this.getTokens(value);
    const parser = this.getParser(tokens);
    const astErrorListener = new JastBuilderErrorListener();
    parser.removeErrorListeners();
    parser.addErrorListener(astErrorListener);
    this.errorListeners.forEach(errorListener => parser.addErrorListener(errorListener));
    if (this.errorHandler) {
      parser.errorHandler = this.errorHandler;
      this.errorHandler.reset(parser);
    }
    const visitor = new QueryVisitor(tokens);
    try {
      const parseTree = parser.jqlQuery();
      const query = parseTree.accept(visitor);
      return creators.jast(query, value, astErrorListener.errors);
    } catch (error) {
      return creators.jast(undefined, value, [new JQLParseError(error.message, error)]);
    }
  }
}