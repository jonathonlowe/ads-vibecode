import { CLAUSE_TYPE_COMPOUND } from '../constants';
import { AbstractJastVisitor } from '../jast-visitors';
import { group, ifBreak, newLine } from './utils';
const formatOperator = (operator, operatorCase) => {
  switch (operatorCase) {
    case 'lower':
      return operator.toLowerCase();
    case 'upper':
      return operator.toUpperCase();
    case 'preserve':
      return operator;
  }
};
export class AstToDocVisitor extends AbstractJastVisitor {
  constructor({
    operatorCase
  } = {}) {
    super();
    this.operatorCase = operatorCase || 'preserve';
  }
  visitArgument(argument) {
    return argument.text;
  }

  /**
   * Visit each of the provided nodes and form a new array with each `Doc` joined by the provided separator.
   */
  joinNodes(nodes, separator) {
    const docs = [];
    nodes.forEach(node => {
      if (separator !== undefined && docs.length > 0) {
        docs.push(separator);
      }
      docs.push(node.accept(this));
    });
    return docs;
  }
  visitCompoundClause(compoundClause) {
    const operatorDoc = compoundClause.operator.accept(this);
    const clauseDocs = [];
    compoundClause.clauses.forEach(clause => {
      if (clauseDocs.length > 0) {
        clauseDocs.push(ifBreak(newLine(), ' '), operatorDoc, ' ');
      }

      // Wrap nested compound clauses in parentheses
      if (clause.clauseType === CLAUSE_TYPE_COMPOUND) {
        clauseDocs.push('(', clause.accept(this), ')');
      } else {
        clauseDocs.push(clause.accept(this));
      }
    });
    return group(clauseDocs);
  }
  visitCompoundOperator(compoundOperator) {
    return formatOperator(compoundOperator.value, this.operatorCase);
  }
  visitField(field) {
    const propertyDocs = field.properties ? this.joinNodes(field.properties) : [];
    return group([field.text, ...propertyDocs]);
  }
  visitFunction(functionString) {
    return functionString.text;
  }
  visitFunctionOperand(functionOperand) {
    const argumentDocs = this.joinNodes(functionOperand.arguments, ', ');
    return group([functionOperand.function.accept(this), '(', ...argumentDocs, ')']);
  }
  visitKeywordOperand(keywordOperand) {
    return keywordOperand.value;
  }
  visitListOperand(listOperand) {
    const operandDocs = this.joinNodes(listOperand.values, ', ');
    return group(['(', ...operandDocs, ')']);
  }
  visitOperator(operator) {
    return formatOperator(operator.text, this.operatorCase);
  }
  visitOrderBy(orderBy) {
    const fieldDocs = this.joinNodes(orderBy.fields, ', ');
    return group([orderBy.operator.accept(this), ' ', ...fieldDocs]);
  }
  visitOrderByDirection(orderByDirection) {
    return orderByDirection.value;
  }
  visitOrderByField(orderByField) {
    const docs = [orderByField.field.accept(this)];
    if (orderByField.direction) {
      docs.push(' ', orderByField.direction.accept(this));
    }
    return group(docs);
  }
  visitOrderByOperator(orderByOperator) {
    return formatOperator(orderByOperator.value, this.operatorCase);
  }
  visitPredicate(predicate) {
    const docs = [predicate.operator.accept(this)];
    if (predicate.operand) {
      docs.push(' ', predicate.operand.accept(this));
    }
    return group(docs);
  }
  visitPredicateOperator(predicateOperator) {
    return formatOperator(predicateOperator.text, this.operatorCase);
  }
  visitProperty(property) {
    const docs = [];
    if (property.key) {
      docs.push('[', property.key.accept(this), ']');
    }
    if (property.path) {
      const pathDocs = this.joinNodes(property.path, ' ');
      docs.push(...pathDocs);
    }
    return group(docs);
  }
  visitQuery(query) {
    if (query.where && query.orderBy) {
      return group([query.where.accept(this), ifBreak(newLine(), ' '), query.orderBy.accept(this)]);
    } else if (query.where) {
      return query.where.accept(this);
    } else if (query.orderBy) {
      return query.orderBy.accept(this);
    }
    return '';
  }
  visitTerminalClause(terminalClause) {
    const docs = [terminalClause.field.accept(this)];
    if (terminalClause.operator) {
      docs.push(' ', terminalClause.operator.accept(this));
    }
    if (terminalClause.operand) {
      docs.push(' ', terminalClause.operand.accept(this));
    }
    terminalClause.predicates.forEach(predicate => {
      docs.push(' ', predicate.accept(this));
    });
    return group(docs);
  }
  visitValueOperand(valueOperand) {
    return valueOperand.text;
  }
  visitNotClause(notClause) {
    const clauseDocs = [];
    // Wrap nested compound clauses in parentheses
    if (notClause.clause.clauseType === CLAUSE_TYPE_COMPOUND) {
      clauseDocs.push('(', notClause.clause.accept(this), ')');
    } else {
      clauseDocs.push(notClause.clause.accept(this));
    }
    return group([notClause.operator.accept(this), ' ', ...clauseDocs]);
  }
  visitNotClauseOperator(notClauseOperator) {
    return notClauseOperator.value;
  }
  visitChildren() {
    throw new Error('Required visit method not implemented for node');
  }
  defaultResult() {
    return '';
  }
}
export const printAstToDoc = (jast, options) => {
  const astToDocVisitor = new AstToDocVisitor(options);
  return jast.query ? jast.query.accept(astToDocVisitor) : '';
};