import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { OPERAND_EMPTY } from '../constants';
import { internalCreators } from '../creators';
import { notUndefined } from '../utils';
import { ArgumentVisitor } from './argument';
import { getPositionFromContext, getPositionFromToken, JastBuildingVisitor } from './common';
import { NumberVisitor } from './number';
import { StringVisitor } from './string';
export class OperandVisitor extends JastBuildingVisitor {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "stringVisitor", new StringVisitor(this.tokens));
    _defineProperty(this, "numberVisitor", new NumberVisitor(this.tokens));
    _defineProperty(this, "functionNameVisitor", new FunctionNameVisitor(this.tokens));
    _defineProperty(this, "argumentListVisitor", new ArgumentListVisitor(this.tokens));
    _defineProperty(this, "visitJqlOperand", ctx => {
      const operandContext = [ctx.jqlEmpty(), ctx.jqlValue(), ctx.jqlList(), ctx.jqlFunction()].find(notUndefined);
      return operandContext === null || operandContext === void 0 ? void 0 : operandContext.accept(this);
    });
    _defineProperty(this, "visitJqlEmpty", ctx => {
      // ANTLR will optimistically create a jqlEmpty node in some situations where user input doesn't match the EMPTY
      // token, e.g. when using value operands in IS clauses ("field is value"), where EMPTY is the only valid operand.
      if (ctx.exception) {
        return undefined;
      }
      return internalCreators.keywordOperand(OPERAND_EMPTY, getPositionFromToken(ctx.EMPTY().payload));
    });
    _defineProperty(this, "visitJqlValue", ctx => {
      const stringContext = ctx.jqlString();
      if (stringContext !== undefined) {
        const stringValue = stringContext.accept(this.stringVisitor);
        return internalCreators.valueOperand(stringValue.value, stringValue.text, stringValue.position);
      }
      const numberContext = ctx.jqlNumber();
      if (numberContext !== undefined) {
        return numberContext.accept(this.numberVisitor);
      }
    });
    _defineProperty(this, "visitJqlList", ctx => {
      const values = ctx.jqlOperand().map(operandCtx => operandCtx.accept(this)).filter(notUndefined);
      return internalCreators.listOperand(values, getPositionFromContext(ctx));
    });
    _defineProperty(this, "visitJqlFunction", ctx => {
      const argumentListContext = ctx.jqlArgumentList();
      return internalCreators.functionOperand(ctx.jqlFunctionName().accept(this.functionNameVisitor), argumentListContext === undefined ? [] : argumentListContext.accept(this.argumentListVisitor), getPositionFromContext(ctx));
    });
  }
}
class FunctionNameVisitor extends JastBuildingVisitor {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "stringVisitor", new StringVisitor(this.tokens));
    _defineProperty(this, "visitJqlFunctionName", ctx => {
      const stringContext = ctx.jqlString();
      if (stringContext !== undefined) {
        const stringValue = stringContext.accept(this.stringVisitor);
        return internalCreators.functionString(stringValue.value, stringValue.text, stringValue.position);
      } else {
        const text = this.tokens.getText(ctx);
        return internalCreators.functionString(text, text, getPositionFromContext(ctx));
      }
    });
  }
}
class ArgumentListVisitor extends JastBuildingVisitor {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "argumentVisitor", new ArgumentVisitor(this.tokens));
    _defineProperty(this, "visitJqlArgumentList", ctx => {
      return ctx.jqlArgument().map(argumentCtx => argumentCtx.accept(this.argumentVisitor));
    });
  }
}