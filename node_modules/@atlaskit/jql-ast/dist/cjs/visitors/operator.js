"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OperatorVisitor = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _creators = require("../creators");
var _types = require("../types");
var _common = require("./common");
function _createSuper(t) { var r = _isNativeReflectConstruct(); return function () { var e, o = (0, _getPrototypeOf2.default)(t); if (r) { var s = (0, _getPrototypeOf2.default)(this).constructor; e = Reflect.construct(o, arguments, s); } else e = o.apply(this, arguments); return (0, _possibleConstructorReturn2.default)(this, e); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var OperatorVisitor = exports.OperatorVisitor = /*#__PURE__*/function (_JastBuildingVisitor) {
  (0, _inherits2.default)(OperatorVisitor, _JastBuildingVisitor);
  var _super = _createSuper(OperatorVisitor);
  function OperatorVisitor() {
    var _this;
    (0, _classCallCheck2.default)(this, OperatorVisitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    // Recover from clause type ambiguities, e.g. "issuetype was " (which can be a WAS or WAS IN clause)
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "visitChildren", function (node) {
      var sourceInterval = node.sourceInterval;
      var text = _this.tokens.getText(sourceInterval);
      if (text) {
        var value = (0, _common.normalizeText)(text);
        var startIndex = sourceInterval.a,
          stopIndex = sourceInterval.b;
        var startToken = _this.tokens.get(startIndex);
        var stopToken = _this.tokens.get(stopIndex);
        var position = (0, _common.getPositionFromToken)(startToken, stopToken);
        if ((0, _types.isOperator)(value)) {
          return _creators.internalCreators.operator(value, text, position);
        }
      }
    });
    return _this;
  }
  (0, _createClass2.default)(OperatorVisitor, [{
    key: "visitJqlEqualsOperator",
    value: function visitJqlEqualsOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!(0, _types.isEqualsOperator)(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised equals operators"));
      }
      return _creators.internalCreators.operator(text, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlLikeOperator",
    value: function visitJqlLikeOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!(0, _types.isLikeOperator)(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised like operators"));
      }
      return _creators.internalCreators.operator(text, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlComparisonOperator",
    value: function visitJqlComparisonOperator(ctx) {
      var text = this.tokens.getText(ctx);
      if (!(0, _types.isComparisonOperator)(text)) {
        throw new Error("'".concat(text, "' does not match any of the recognised comparison operators"));
      }
      return _creators.internalCreators.operator(text, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlInOperator",
    value: function visitJqlInOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = (0, _common.normalizeText)(text);
      if (!(0, _types.isInOperator)(value)) {
        // This can happen if an incomplete operator is used, e.g. `status not open`.
        return undefined;
      }
      return _creators.internalCreators.operator(value, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlIsOperator",
    value: function visitJqlIsOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = (0, _common.normalizeText)(text);
      if (!(0, _types.isIsOperator)(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised is operators"));
      }
      return _creators.internalCreators.operator(value, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlWasOperator",
    value: function visitJqlWasOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = (0, _common.normalizeText)(text);
      if (!(0, _types.isWasOperator)(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised was operators"));
      }
      return _creators.internalCreators.operator(value, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlWasInOperator",
    value: function visitJqlWasInOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = (0, _common.normalizeText)(text);
      if (!(0, _types.isWasInOperator)(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised was in operators"));
      }
      return _creators.internalCreators.operator(value, text, (0, _common.getPositionFromContext)(ctx));
    }
  }, {
    key: "visitJqlChangedOperator",
    value: function visitJqlChangedOperator(ctx) {
      var text = this.tokens.getText(ctx);
      var value = (0, _common.normalizeText)(text);
      if (!(0, _types.isChangedOperator)(value)) {
        throw new Error("'".concat(text, "' does not match any of the recognised changed operators"));
      }
      return _creators.internalCreators.operator(value, text, (0, _common.getPositionFromContext)(ctx));
    }
  }]);
  return OperatorVisitor;
}(_common.JastBuildingVisitor);