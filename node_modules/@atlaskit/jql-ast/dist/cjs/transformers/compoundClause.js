"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.appendClause = appendClause;
exports.remove = remove;
exports.removeClause = removeClause;
exports.replace = replace;
exports.replaceClause = replaceClause;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _constants = require("../constants");
var _common = require("../creators/common");
/**
 * Append the provided clause to this compound clause. If the clause to append is also a compound clause sharing the
 * same operator as this node then the two compound clauses will be merged.
 *
 * @param clause Clause to append
 */
function appendClause(clause) {
  var _this$clauses;
  var clausesToAppend = [clause];

  // If the clause to append is compound with a matching operator then we flatten it into the current clause
  if (clause.clauseType === _constants.CLAUSE_TYPE_COMPOUND && clause.operator.value === this.operator.value) {
    clausesToAppend = clause.clauses;
  }
  (_this$clauses = this.clauses).push.apply(_this$clauses, (0, _toConsumableArray2.default)(clausesToAppend));
  (0, _common.assignParent)(this);
}

/**
 * Remove the current node from its parent. The parent node is responsible for implementing the logic to remove any
 * references to the child node.
 */
function remove() {
  if (this.parent) {
    this.parent.removeClause(this);
  }
}

/**
 * Remove the provided clause from the node. If the clause to remove is not found as a child of the current node then
 * no changes will be made.
 *
 * If the `CompoundClause` has only 1 child clause remaining after the operation, then the current node will be replaced
 * with the child clause (flattening the tree structure). If there are 0 child clauses remaining then the compound
 * clause will be removed entirely.
 *
 * @param clause Clause to remove
 */
function removeClause(clause) {
  this.clauses = this.clauses.filter(function (val) {
    return val !== clause;
  });
  if (this.clauses.length === 1) {
    this.replace(this.clauses[0]);
  } else if (this.clauses.length === 0) {
    this.remove();
  }
}

/**
 * Replace the current node from its parent with the provided node. The parent node is responsible for implementing
 * the logic to replace any references to the child node.
 */
function replace(nextClause) {
  if (this.parent) {
    this.parent.replaceClause(this, nextClause);
  }
}

/**
 * Replace the matching child clause with the provided `nextClause` node. If the clause to replace is not found as a
 * child of the current node then no changes will be made.
 *
 * @param clause Clause to be replaced
 * @param nextClause Clause to set as the new value
 */
function replaceClause(clause, nextClause) {
  this.clauses = this.clauses.map(function (child) {
    return child === clause ? nextClause : child;
  });
  (0, _common.assignParent)(this);
}