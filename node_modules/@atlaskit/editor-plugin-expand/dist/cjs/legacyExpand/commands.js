"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateExpandTitle = exports.toggleExpandExpanded = exports.setSelectionInsideExpand = exports.setExpandRef = exports.insertExpandWithInputMethod = exports.insertExpand = exports.focusTitle = exports.focusIcon = exports.deleteExpandAtPos = exports.deleteExpand = exports.createExpandNode = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _steps = require("@atlaskit/adf-schema/steps");
var _analytics = require("@atlaskit/editor-common/analytics");
var _selection = require("@atlaskit/editor-common/selection");
var _styles = require("@atlaskit/editor-common/styles");
var _transforms = require("@atlaskit/editor-common/transforms");
var _utils = require("@atlaskit/editor-common/utils");
var _state2 = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _utils3 = require("@atlaskit/editor-tables/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _utils4 = require("../utils");
var _pluginFactory = require("./pm-plugins/plugin-factory");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var setExpandRef = exports.setExpandRef = function setExpandRef(ref) {
  return (0, _pluginFactory.createCommand)({
    type: 'SET_EXPAND_REF',
    data: {
      ref: ref
    }
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var deleteExpandAtPos = exports.deleteExpandAtPos = function deleteExpandAtPos(editorAnalyticsAPI) {
  return function (expandNodePos, expandNode) {
    return function (state, dispatch) {
      if (!expandNode || isNaN(expandNodePos)) {
        return false;
      }
      var payload = {
        action: _analytics.ACTION.DELETED,
        actionSubject: expandNode.type === state.schema.nodes.expand ? _analytics.ACTION_SUBJECT.EXPAND : _analytics.ACTION_SUBJECT.NESTED_EXPAND,
        attributes: {
          inputMethod: _analytics.INPUT_METHOD.TOOLBAR
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      };
      if (expandNode && dispatch) {
        var tr = state.tr;
        tr.delete(expandNodePos, expandNodePos + expandNode.nodeSize);
        editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(tr);
        if (expandNode.type === state.schema.nodes.nestedExpand) {
          var resolvedPos = tr.doc.resolve(expandNodePos + 1);
          if (resolvedPos) {
            tr.setSelection(_state2.Selection.near(resolvedPos, -1));
          }
        }
        dispatch(tr);
      }
      return true;
    };
  };
};
var deleteExpand = exports.deleteExpand = function deleteExpand(editorAnalyticsAPI) {
  return function (state, dispatch) {
    var expandNode = (0, _transforms.findExpand)(state);
    if (!expandNode) {
      return false;
    }
    return deleteExpandAtPos(editorAnalyticsAPI)(expandNode.pos, expandNode.node)(state, dispatch);
  };
};
var updateExpandTitle = exports.updateExpandTitle = function updateExpandTitle(_ref) {
  var title = _ref.title,
    nodeType = _ref.nodeType,
    pos = _ref.pos,
    __livePage = _ref.__livePage;
  return function (state, dispatch) {
    var node = state.doc.nodeAt(pos);
    if (node && node.type === nodeType && dispatch) {
      var tr = state.tr;
      if (__livePage && (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence')) {
        tr.step(new _steps.SetAttrsStep(pos, _objectSpread(_objectSpread({}, node.attrs), {}, {
          title: title
        })));
      } else {
        tr.setNodeMarkup(pos, node.type, _objectSpread(_objectSpread({}, node.attrs), {}, {
          title: title
        }), node.marks);
      }
      dispatch(tr);
    }
    return true;
  };
};
var toggleExpandExpanded = exports.toggleExpandExpanded = function toggleExpandExpanded(_ref2) {
  var editorAnalyticsAPI = _ref2.editorAnalyticsAPI,
    pos = _ref2.pos,
    nodeType = _ref2.nodeType,
    __livePage = _ref2.__livePage;
  return function (state, dispatch) {
    var node = state.doc.nodeAt(pos);
    if (node && node.type === nodeType && dispatch) {
      var tr = state.tr;
      var isExpandedNext = !node.attrs.__expanded;
      if (__livePage && (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence')) {
        tr.step(new _steps.SetAttrsStep(pos, _objectSpread(_objectSpread({}, node.attrs), {}, {
          __expanded: isExpandedNext
        })));
      } else {
        tr.setNodeMarkup(pos, node.type, _objectSpread(_objectSpread({}, node.attrs), {}, {
          __expanded: isExpandedNext
        }), node.marks);
      }

      // If we're going to collapse the expand and our cursor is currently inside
      // Move to a right gap cursor, if the toolbar is interacted (or an API),
      // it will insert below rather than inside (which will be invisible).
      if (__livePage && (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') ? isExpandedNext === true : isExpandedNext === false && (0, _transforms.findExpand)(state)) {
        tr.setSelection(new _selection.GapCursorSelection(tr.doc.resolve(pos + node.nodeSize), _selection.Side.RIGHT));
      }

      // log when people open/close expands
      // TODO: ED-8523 - make platform/mode global attributes?
      var payload = {
        action: _analytics.ACTION.TOGGLE_EXPAND,
        actionSubject: nodeType === state.schema.nodes.expand ? _analytics.ACTION_SUBJECT.EXPAND : _analytics.ACTION_SUBJECT.NESTED_EXPAND,
        attributes: {
          platform: _analytics.PLATFORMS.WEB,
          mode: _analytics.MODE.EDITOR,
          expanded: __livePage && (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') ? !isExpandedNext : isExpandedNext
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      };

      // `isRemote` meta prevents this step from being
      // sync'd between sessions in synchrony collab edit
      tr.setMeta('isRemote', true);
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(tr);
      dispatch(tr);
    }
    return true;
  };
};

// Creates either an expand or a nestedExpand node based on the current selection
var createExpandNode = exports.createExpandNode = function createExpandNode(state) {
  var _state$schema$nodes = state.schema.nodes,
    expand = _state$schema$nodes.expand,
    nestedExpand = _state$schema$nodes.nestedExpand;
  var isSelectionInTable = !!(0, _utils3.findTable)(state.selection);
  var isSelectionInExpand = (0, _utils4.isNestedInExpand)(state);
  var expandType = isSelectionInTable || isSelectionInExpand ? nestedExpand : expand;
  return expandType.createAndFill({});
};
var insertExpandWithInputMethod = exports.insertExpandWithInputMethod = function insertExpandWithInputMethod(editorAnalyticsAPI) {
  return function (inputMethod) {
    return function (state, dispatch) {
      var expandNode = createExpandNode(state);
      if (!expandNode) {
        return false;
      }
      var tr = state.selection.empty ? (0, _utils2.safeInsert)(expandNode)(state.tr).scrollIntoView() : (0, _utils.createWrapSelectionTransaction)({
        state: state,
        type: expandNode.type
      });
      var payload = {
        action: _analytics.ACTION.INSERTED,
        actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: (expandNode === null || expandNode === void 0 ? void 0 : expandNode.type) === state.schema.nodes.expand ? _analytics.ACTION_SUBJECT_ID.EXPAND : _analytics.ACTION_SUBJECT_ID.NESTED_EXPAND,
        attributes: {
          inputMethod: inputMethod
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      };
      if (dispatch && expandNode) {
        editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(tr);
        dispatch(tr);
      }
      return true;
    };
  };
};
var insertExpand = exports.insertExpand = function insertExpand(editorAnalyticsAPI) {
  return function (state, dispatch) {
    return insertExpandWithInputMethod(editorAnalyticsAPI)(_analytics.INPUT_METHOD.INSERT_MENU)(state, dispatch);
  };
};
var focusTitle = exports.focusTitle = function focusTitle(pos) {
  return function (state, dispatch, editorView) {
    if (editorView) {
      var dom = editorView.domAtPos(pos);
      var expandWrapper = dom.node.parentElement;
      if (expandWrapper) {
        setSelectionInsideExpand(pos)(state, dispatch, editorView);
        var input = expandWrapper.querySelector('input');
        if (input) {
          input.focus();
          return true;
        }
      }
    }
    return false;
  };
};
var focusIcon = exports.focusIcon = function focusIcon(expand) {
  return function (state, dispatch, editorView) {
    if (!(expand instanceof HTMLElement)) {
      return false;
    }

    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    var iconContainer = expand.querySelector(".".concat(_styles.expandClassNames.iconContainer));
    if (iconContainer && iconContainer.focus) {
      var tr = state.tr;
      var pos = state.selection.from;
      tr.setSelection(new _state2.TextSelection(tr.doc.resolve(pos)));
      if (dispatch) {
        dispatch(tr);
      }
      editorView === null || editorView === void 0 || editorView.dom.blur();
      iconContainer.focus();
      return true;
    }
    return false;
  };
};

// Used to clear any node or cell selection when expand title is focused
var setSelectionInsideExpand = exports.setSelectionInsideExpand = function setSelectionInsideExpand(expandPos) {
  return function (_state, dispatch, editorView) {
    if (editorView) {
      if (!editorView.hasFocus()) {
        editorView.focus();
      }
      var sel = _state2.Selection.findFrom(editorView.state.doc.resolve(expandPos), 1, true);
      if (sel && dispatch) {
        dispatch(editorView.state.tr.setSelection(sel));
      }
      return true;
    }
    return false;
  };
};