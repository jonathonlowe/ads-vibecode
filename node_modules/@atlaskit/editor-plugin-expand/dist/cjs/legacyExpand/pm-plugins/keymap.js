"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expandKeymap = expandKeymap;
var _keymaps = require("@atlaskit/editor-common/keymaps");
var _selection = require("@atlaskit/editor-common/selection");
var _transforms = require("@atlaskit/editor-common/transforms");
var _utils = require("@atlaskit/editor-common/utils");
var _keymap = require("@atlaskit/editor-prosemirror/keymap");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-tables/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _commands = require("../commands");
var isExpandNode = function isExpandNode(node) {
  return (node === null || node === void 0 ? void 0 : node.type.name) === 'expand' || (node === null || node === void 0 ? void 0 : node.type.name) === 'nestedExpand';
};
var isExpandSelected = function isExpandSelected(selection) {
  return selection instanceof _state.NodeSelection && isExpandNode(selection.node);
};
function expandKeymap(api, options) {
  var list = {};
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.moveRight.common, function (state, dispatch, editorView) {
    var _api$selection;
    if (!editorView) {
      return false;
    }
    var selection = state.selection;
    var selectionSharedState = (api === null || api === void 0 || (_api$selection = api.selection) === null || _api$selection === void 0 ? void 0 : _api$selection.sharedState.currentState()) || {};
    var selectionRelativeToNode = selectionSharedState.selectionRelativeToNode;
    if (isExpandSelected(selection) && selectionRelativeToNode === _selection.RelativeSelectionPos.Start) {
      return (0, _commands.focusTitle)(selection.from + 1)(state, dispatch, editorView);
    }
    return false;
  }, list);
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.moveLeft.common, function (state, dispatch, editorView) {
    var _api$selection2;
    if (!editorView) {
      return false;
    }
    var selection = state.selection;
    var selectionSharedState = (api === null || api === void 0 || (_api$selection2 = api.selection) === null || _api$selection2 === void 0 ? void 0 : _api$selection2.sharedState.currentState()) || {};
    var selectionRelativeToNode = selectionSharedState.selectionRelativeToNode;
    if (isExpandSelected(selection) && (selectionRelativeToNode === undefined || selectionRelativeToNode === _selection.RelativeSelectionPos.End)) {
      return (0, _commands.focusTitle)(selection.from + 1)(state, dispatch, editorView);
    }
    return false;
  }, list);
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.tab.common, function (state, dispatch, editorView) {
    if (editorView && editorView.dom instanceof HTMLElement) {
      var from = state.selection.from;

      // if the node selected is an expand
      if (isExpandSelected(state.selection)) {
        var expand = editorView.nodeDOM(from);
        if (!expand) {
          return false;
        }
        return (0, _commands.focusIcon)(expand)(state, dispatch, editorView);
      }

      // if the text selection is inside an expand
      else if (state.selection instanceof _state.TextSelection && !(0, _utils2.isInTable)(state)) {
        var _expand = (0, _transforms.findExpand)(state);
        if (_expand) {
          var expandNode = editorView.nodeDOM(_expand.pos);
          if (expandNode) {
            return (0, _commands.focusIcon)(expandNode)(state, dispatch, editorView);
          }
        }
      }
    }
    return false;
  }, list);
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.moveUp.common, function (state, dispatch, editorView) {
    if (!editorView) {
      return false;
    }
    var selection = state.selection,
      schema = state.schema;
    var nodeBefore = selection.$from.nodeBefore;
    if (selection instanceof _selection.GapCursorSelection && selection.side === _selection.Side.RIGHT && nodeBefore && (nodeBefore.type === schema.nodes.expand || nodeBefore.type === schema.nodes.nestedExpand) && (
    // eslint-disable-next-line @atlaskit/platform/no-preconditioning
    (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') && options.__livePage ? nodeBefore.attrs.__expanded : !nodeBefore.attrs.__expanded)) {
      var _$from = selection.$from;
      return (0, _commands.focusTitle)(Math.max(_$from.pos - 1, 0))(state, dispatch, editorView);
    }
    var $from = state.selection.$from;
    if (editorView.endOfTextblock('up')) {
      var expand = (0, _transforms.findExpand)(state);

      // Moving UP in a table should move the cursor to the row above
      // however when an expand is in a table cell to the left of the
      // current table cell, arrow UP moves the cursor to the left
      // see ED-15425
      if ((0, _utils.isPositionNearTableRow)($from, schema, 'before') && !expand) {
        return false;
      }
      var prevCursorPos = Math.max($from.pos - $from.parentOffset - 1, 0);
      // move cursor from expand's content to its title
      if (expand && expand.start === prevCursorPos) {
        return (0, _commands.focusTitle)(expand.start)(state, dispatch, editorView);
      }
      var sel = _state.Selection.findFrom(state.doc.resolve(prevCursorPos), -1);
      var expandBefore = (0, _transforms.findExpand)(state, sel);
      if (sel && expandBefore) {
        // moving cursor from outside of an expand to the title when it is collapsed
        if (
        // eslint-disable-next-line @atlaskit/platform/no-preconditioning
        (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') && options.__livePage ? expandBefore.node.attrs.__expanded : !expandBefore.node.attrs.__expanded) {
          return (0, _commands.focusTitle)(expandBefore.start)(state, dispatch, editorView);
        }
        // moving cursor from outside of an expand to the content when it is expanded
        else if (dispatch) {
          dispatch(state.tr.setSelection(sel));
        }
        return true;
      }
    }
    return false;
  }, list);
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.moveDown.common, function (state, dispatch, editorView) {
    if (!editorView) {
      return false;
    }
    var _state$schema$nodes = state.schema.nodes,
      expand = _state$schema$nodes.expand,
      nestedExpand = _state$schema$nodes.nestedExpand;
    var selection = state.selection;
    var nodeAfter = selection.$from.nodeAfter;
    if (selection instanceof _selection.GapCursorSelection && selection.side === _selection.Side.LEFT && nodeAfter && (nodeAfter.type === expand || nodeAfter.type === nestedExpand) && (
    // eslint-disable-next-line @atlaskit/platform/no-preconditioning
    (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') && options.__livePage ? nodeAfter.attrs.__expanded : !nodeAfter.attrs.__expanded)) {
      var $from = selection.$from;
      return (0, _commands.focusTitle)($from.pos + 1)(state, dispatch, editorView);
    }
    if (editorView.endOfTextblock('down')) {
      var _$from2 = state.selection.$from;
      if (_$from2.depth === 0) {
        return false;
      }
      var $after = state.doc.resolve(_$from2.after());
      if ($after.nodeAfter && ($after.nodeAfter.type === expand || $after.nodeAfter.type === nestedExpand)) {
        return (0, _commands.focusTitle)($after.pos + 1)(state, dispatch, editorView);
      }
    }
    return false;
  }, list);
  (0, _keymaps.bindKeymapWithCommand)(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  _keymaps.backspace.common, function (state, dispatch, editorView) {
    var selection = state.selection;
    var $from = selection.$from;
    if (!editorView || !selection.empty) {
      return false;
    }
    var _state$schema$nodes2 = state.schema.nodes,
      expand = _state$schema$nodes2.expand,
      nestedExpand = _state$schema$nodes2.nestedExpand;
    var expandNode = (0, _transforms.findExpand)(state);
    if (!expandNode) {
      // @see ED-7977
      var sel = _state.Selection.findFrom(state.doc.resolve(Math.max(selection.$from.pos - 1, 0)), -1);
      var expandBefore = (0, _transforms.findExpand)(state, sel);
      if (expandBefore && (expandBefore.node.type === expand || expandBefore.node.type === nestedExpand) && (
      // eslint-disable-next-line @atlaskit/platform/no-preconditioning
      (0, _platformFeatureFlags.fg)('platform.editor.live-pages-expand-divergence') && options.__livePage ? expandBefore.node.attrs.__expanded : !expandBefore.node.attrs.__expanded)) {
        return (0, _commands.focusTitle)(expandBefore.start)(state, dispatch, editorView);
      }
      return false;
    }
    var parentNode = state.doc.nodeAt($from.before(Math.max($from.depth - 1, 1)));
    // ED-10012 catch cases where the expand has another node nested within it and
    // the backspace should be applied only to the inner node instead of the expand
    if (parentNode && !isExpandNode(parentNode)) {
      return false;
    }
    var textSel = _state.Selection.findFrom(state.doc.resolve(expandNode.pos), 1, true);
    if (textSel && selection.$from.pos === textSel.$from.pos && (0, _utils.isEmptyNode)(state.schema)(expandNode.node) && dispatch) {
      var _api$analytics;
      return (0, _commands.deleteExpand)(api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions)(state, dispatch);
    }
    return false;
  }, list);
  return (0, _keymap.keymap)(list);
}