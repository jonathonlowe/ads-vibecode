import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { isWindowObjectAvailable } from '../platform-client/utils/window-helper';
var VisibilityChangeObserver = /*#__PURE__*/function () {
  function VisibilityChangeObserver() {
    var _this = this;
    _classCallCheck(this, VisibilityChangeObserver);
    _defineProperty(this, "started", false);
    _defineProperty(this, "observers", []);
    _defineProperty(this, "broadcast", function () {
      _this.observers.forEach(function (fn) {
        return fn();
      });
      _this.observers = [];
    });
  }
  return _createClass(VisibilityChangeObserver, [{
    key: "start",
    value: function start() {
      if (this.started) {
        return;
      }
      this.started = true;
      document.addEventListener('visibilitychange', this.broadcast);
      /**
       * According to https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event
       * Safari doesnâ€™t fire visibilitychange as expected when the value of the visibilityState property transitions to hidden;
       * so for that case, you need to also include code to listen for the pagehide event.
       */
      if (isWindowObjectAvailable()) {
        window.addEventListener('pagehide', this.broadcast);
      }
    }
  }, {
    key: "subscribe",
    value: function subscribe(callback) {
      this.observers.push(callback);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(callback) {
      this.observers = this.observers.filter(function (fn) {
        return fn !== callback;
      });
    }
  }]);
}();
export var visibilityChangeObserver = new VisibilityChangeObserver();