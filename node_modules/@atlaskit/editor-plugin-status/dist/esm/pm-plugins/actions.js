import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { uuid } from '@atlaskit/adf-schema';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { getAnnotationMarksForPos } from '@atlaskit/editor-common/utils';
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { NodeSelection, Selection } from '@atlaskit/editor-prosemirror/state';
import { canInsert } from '@atlaskit/editor-prosemirror/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { pluginKey } from './plugin-key';
export var DEFAULT_STATUS = {
  text: '',
  color: 'neutral'
};
export var verifyAndInsertStatus = function verifyAndInsertStatus(statusNode, tr, annotationMarks) {
  var fragment = Fragment.fromArray([statusNode, tr.doc.type.schema.text(' ', fg('editor_inline_comments_paste_insert_nodes') ? annotationMarks : undefined)]);
  var insertable = canInsert(tr.selection.$from, fragment);
  if (!insertable) {
    var parentSelection = NodeSelection.create(tr.doc, tr.selection.from - tr.selection.$anchor.parentOffset - 1);
    tr.insert(parentSelection.to, fragment).setSelection(NodeSelection.create(tr.doc, parentSelection.to + 1));
  } else {
    tr.insert(tr.selection.from, fragment).setSelection(NodeSelection.create(tr.doc, tr.selection.from - fragment.size));
  }
  return tr.setMeta(pluginKey, {
    showStatusPickerAt: tr.selection.from,
    isNew: true
  }).scrollIntoView();
};
export var createStatus = function createStatus(tr) {
  var annotationMarksForPos = fg('editor_inline_comments_paste_insert_nodes') ? getAnnotationMarksForPos(tr.selection.$head) : undefined;
  var statusNode = tr.doc.type.schema.nodes.status.createChecked(_objectSpread(_objectSpread({}, DEFAULT_STATUS), {}, {
    localId: uuid.generate()
  }), null, fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
  return verifyAndInsertStatus(statusNode, tr, fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
};
export var insertStatus = function insertStatus(editorAnalyticsAPI) {
  return function () {
    var inputMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INPUT_METHOD.TOOLBAR;
    return function (_ref) {
      var tr = _ref.tr;
      var statusTr = createStatus(tr);
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
        action: ACTION.INSERTED,
        actionSubject: ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: ACTION_SUBJECT_ID.STATUS,
        attributes: {
          inputMethod: inputMethod
        },
        eventType: EVENT_TYPE.TRACK
      })(statusTr);
      return statusTr;
    };
  };
};
export var updateStatus = function updateStatus(status) {
  return function (state, dispatch) {
    var schema = state.schema;
    var selectedStatus = status ? Object.assign(status, {
      text: status.text.trim(),
      localId: status.localId || uuid.generate()
    }) : status;
    var statusProps = _objectSpread(_objectSpread({}, DEFAULT_STATUS), selectedStatus);
    var tr = state.tr;
    var _ref2 = pluginKey.getState(state) || {},
      showStatusPickerAt = _ref2.showStatusPickerAt;
    if (!showStatusPickerAt) {
      // Same behaviour as quick insert (used in createStatus)
      var statusNode = schema.nodes.status.createChecked(statusProps);
      tr = verifyAndInsertStatus(statusNode, state.tr);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    if (state.doc.nodeAt(showStatusPickerAt)) {
      tr.setNodeMarkup(showStatusPickerAt, schema.nodes.status, statusProps).setSelection(NodeSelection.create(tr.doc, showStatusPickerAt)).setMeta(pluginKey, {
        showStatusPickerAt: showStatusPickerAt
      }).scrollIntoView();
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
export var updateStatusWithAnalytics = function updateStatusWithAnalytics(editorAnalyticsAPI) {
  return function (inputMethod, status) {
    return withAnalytics(editorAnalyticsAPI, {
      action: ACTION.INSERTED,
      actionSubject: ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: ACTION_SUBJECT_ID.STATUS,
      attributes: {
        inputMethod: inputMethod
      },
      eventType: EVENT_TYPE.TRACK
    })(updateStatus(status));
  };
};
export var setStatusPickerAt = function setStatusPickerAt(showStatusPickerAt) {
  return function (state, dispatch) {
    dispatch(state.tr.setMeta(pluginKey, {
      showStatusPickerAt: showStatusPickerAt,
      isNew: false
    }));
    return true;
  };
};
export var removeStatus = function removeStatus(showStatusPickerAt) {
  return function (_ref3) {
    var tr = _ref3.tr;
    tr.replace(showStatusPickerAt, showStatusPickerAt + 1);
    return tr;
  };
};
export var setFocusOnStatusInput = function setFocusOnStatusInput() {
  return function (state, dispatch) {
    if (!dispatch) {
      return false;
    }
    var tr = state.tr.setMeta(pluginKey, {
      focusStatusInput: true
    });
    dispatch(tr);
    return true;
  };
};
var handleClosingByArrows = function handleClosingByArrows(closingMethod, state, showStatusPickerAt, tr) {
  if (closingMethod === 'arrowLeft') {
    // put cursor right before status Lozenge
    tr = tr.setSelection(Selection.near(state.tr.doc.resolve(showStatusPickerAt), -1));
  } else if (closingMethod === 'arrowRight') {
    // put cursor right after status Lozenge
    tr = tr.setSelection(Selection.near(state.tr.doc.resolve(showStatusPickerAt + 1)));
  }
};
export var commitStatusPicker = function commitStatusPicker(closingPayload) {
  return function (editorView) {
    var state = editorView.state,
      dispatch = editorView.dispatch;
    var _ref4 = pluginKey.getState(state) || {},
      showStatusPickerAt = _ref4.showStatusPickerAt;
    var _ref5 = closingPayload || {},
      closingMethod = _ref5.closingMethod;
    if (!showStatusPickerAt) {
      return;
    }
    var statusNode = state.tr.doc.nodeAt(showStatusPickerAt);
    if (!statusNode) {
      return;
    }
    var tr = state.tr;
    tr = tr.setMeta(pluginKey, {
      showStatusPickerAt: null,
      focusStatusInput: false,
      isNew: false
    });
    if (closingMethod) {
      handleClosingByArrows(closingMethod, state, showStatusPickerAt, tr);
    } else if (statusNode.attrs.text) {
      // still has content - keep content
      // move selection after status if selection did not change
      if (tr.selection.from === showStatusPickerAt) {
        tr = tr.setSelection(Selection.near(state.tr.doc.resolve(showStatusPickerAt + 2)));
      }
    } else {
      // no content - remove node
      tr = tr.delete(showStatusPickerAt, showStatusPickerAt + 1);
    }
    dispatch(tr);
    editorView.focus();
  };
};