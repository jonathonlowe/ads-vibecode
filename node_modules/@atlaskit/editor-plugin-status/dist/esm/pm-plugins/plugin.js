import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { getInlineNodeViewProducer } from '@atlaskit/editor-common/react-node-view';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { pmHistoryPluginKey } from '@atlaskit/editor-common/utils';
import { NodeSelection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { StatusNodeView } from '../nodeviews/status';
import { StatusNodeView as StatusNodeViewVanilla } from '../nodeviews/StatusNodeView';
import { pluginKey } from './plugin-key';
import { isEmptyStatus, mayGetStatusAtSelection } from './utils';
var createPlugin = function createPlugin(pmPluginFactoryParams, options) {
  return new SafePlugin({
    state: {
      init: function init() {
        return {
          isNew: false,
          showStatusPickerAt: null,
          focusStatusInput: false
        };
      },
      apply: function apply(tr, state, oldEditorState) {
        var meta = tr.getMeta(pluginKey);
        if (meta) {
          var newState = _objectSpread(_objectSpread({}, state), meta);
          pmPluginFactoryParams.dispatch(pluginKey, newState);
          return newState;
        }
        if (tr.docChanged && state.showStatusPickerAt) {
          var _tr$mapping$mapResult = tr.mapping.mapResult(state.showStatusPickerAt),
            pos = _tr$mapping$mapResult.pos,
            deleted = _tr$mapping$mapResult.deleted;
          var showStatusPickerAt = deleted ? null : pos;
          var _newState = _objectSpread(_objectSpread({}, state), {}, {
            showStatusPickerAt: showStatusPickerAt
          });
          if (_newState.showStatusPickerAt !== state.showStatusPickerAt) {
            pmPluginFactoryParams.dispatch(pluginKey, _newState);
            return _newState;
          }
        }
        if (tr.selectionSet) {
          // Change in selection, while status picker was open, update state, if required.
          var selectionFrom = tr.selection.from;
          var nodeAtSelection = tr.doc.nodeAt(selectionFrom);
          var _showStatusPickerAt = null;
          if (nodeAtSelection && nodeAtSelection.type === oldEditorState.schema.nodes.status && tr.selection instanceof NodeSelection) {
            _showStatusPickerAt = selectionFrom;
          }
          if (_showStatusPickerAt !== state.showStatusPickerAt) {
            var _newState2 = _objectSpread(_objectSpread({}, state), {}, {
              isNew: false,
              showStatusPickerAt: _showStatusPickerAt,
              focusStatusInput: false
            });
            pmPluginFactoryParams.dispatch(pluginKey, _newState2);
            return _newState2;
          }
        }
        return state;
      }
    },
    filterTransaction: function filterTransaction(tr, state) {
      // if it is a selection change transaction, and selection changes from node to text
      if (tr.selectionSet && !tr.steps.length && tr.isGeneric && tr.selection instanceof TextSelection && state.selection instanceof NodeSelection) {
        var _ref = pluginKey.getState(state) || {},
          isNew = _ref.isNew,
          showStatusPickerAt = _ref.showStatusPickerAt;
        var nodeAtSelection = tr.doc.nodeAt(tr.selection.from);
        // prevent changing node selection to text selection on dom change right after inserting status
        // if newly selected status is selected with status picker opened
        if (isNew && showStatusPickerAt && nodeAtSelection && nodeAtSelection.type === state.schema.nodes.status) {
          return false;
        }
      }
      return true;
    },
    appendTransaction: function appendTransaction(transactions, oldEditorState, newEditorState) {
      var changed = false;
      var tr = newEditorState.tr;

      /**
       * When user start creating status, and, when users navigates away
       *  while empty, then we want to remove empty ("set a status") status.
       * But when transaction to add empty status happens from undo/redo
       *  we don't want to remove it.
       */
      if (transactions.find(function (tr) {
        return tr.selectionSet && !tr.getMeta(pmHistoryPluginKey);
      })) {
        var oldStatus = mayGetStatusAtSelection(oldEditorState.selection);
        var newStatus = mayGetStatusAtSelection(newEditorState.selection);
        if (oldStatus && (newStatus && oldStatus.localId !== newStatus.localId || !newStatus)) {
          if (isEmptyStatus(oldStatus)) {
            var pos = oldEditorState.selection.from;
            tr.delete(tr.mapping.map(pos), tr.mapping.map(pos + 1));
            changed = true;
          }
        }
      }
      return changed ? tr : undefined;
    },
    key: pluginKey,
    props: {
      nodeViews: {
        status: function status(node, view, getPos, decorations) {
          if (editorExperiment('platform_editor_vanilla_dom', true, {
            exposure: true
          })) {
            return new StatusNodeViewVanilla(node, pmPluginFactoryParams.getIntl());
          }
          return getInlineNodeViewProducer({
            pmPluginFactoryParams: pmPluginFactoryParams,
            Component: StatusNodeView,
            extraComponentProps: {
              options: options
            }
          })(node, view, getPos, decorations);
        }
      }
    }
  });
};
export default createPlugin;