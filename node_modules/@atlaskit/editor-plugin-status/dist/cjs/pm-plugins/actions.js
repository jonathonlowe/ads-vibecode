"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verifyAndInsertStatus = exports.updateStatusWithAnalytics = exports.updateStatus = exports.setStatusPickerAt = exports.setFocusOnStatusInput = exports.removeStatus = exports.insertStatus = exports.createStatus = exports.commitStatusPicker = exports.DEFAULT_STATUS = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _adfSchema = require("@atlaskit/adf-schema");
var _analytics = require("@atlaskit/editor-common/analytics");
var _editorAnalytics = require("@atlaskit/editor-common/editor-analytics");
var _utils = require("@atlaskit/editor-common/utils");
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _pluginKey = require("./plugin-key");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var DEFAULT_STATUS = exports.DEFAULT_STATUS = {
  text: '',
  color: 'neutral'
};
var verifyAndInsertStatus = exports.verifyAndInsertStatus = function verifyAndInsertStatus(statusNode, tr, annotationMarks) {
  var fragment = _model.Fragment.fromArray([statusNode, tr.doc.type.schema.text(' ', (0, _platformFeatureFlags.fg)('editor_inline_comments_paste_insert_nodes') ? annotationMarks : undefined)]);
  var insertable = (0, _utils2.canInsert)(tr.selection.$from, fragment);
  if (!insertable) {
    var parentSelection = _state.NodeSelection.create(tr.doc, tr.selection.from - tr.selection.$anchor.parentOffset - 1);
    tr.insert(parentSelection.to, fragment).setSelection(_state.NodeSelection.create(tr.doc, parentSelection.to + 1));
  } else {
    tr.insert(tr.selection.from, fragment).setSelection(_state.NodeSelection.create(tr.doc, tr.selection.from - fragment.size));
  }
  return tr.setMeta(_pluginKey.pluginKey, {
    showStatusPickerAt: tr.selection.from,
    isNew: true
  }).scrollIntoView();
};
var createStatus = exports.createStatus = function createStatus(tr) {
  var annotationMarksForPos = (0, _platformFeatureFlags.fg)('editor_inline_comments_paste_insert_nodes') ? (0, _utils.getAnnotationMarksForPos)(tr.selection.$head) : undefined;
  var statusNode = tr.doc.type.schema.nodes.status.createChecked(_objectSpread(_objectSpread({}, DEFAULT_STATUS), {}, {
    localId: _adfSchema.uuid.generate()
  }), null, (0, _platformFeatureFlags.fg)('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
  return verifyAndInsertStatus(statusNode, tr, (0, _platformFeatureFlags.fg)('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
};
var insertStatus = exports.insertStatus = function insertStatus(editorAnalyticsAPI) {
  return function () {
    var inputMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _analytics.INPUT_METHOD.TOOLBAR;
    return function (_ref) {
      var tr = _ref.tr;
      var statusTr = createStatus(tr);
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
        action: _analytics.ACTION.INSERTED,
        actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: _analytics.ACTION_SUBJECT_ID.STATUS,
        attributes: {
          inputMethod: inputMethod
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      })(statusTr);
      return statusTr;
    };
  };
};
var updateStatus = exports.updateStatus = function updateStatus(status) {
  return function (state, dispatch) {
    var schema = state.schema;
    var selectedStatus = status ? Object.assign(status, {
      text: status.text.trim(),
      localId: status.localId || _adfSchema.uuid.generate()
    }) : status;
    var statusProps = _objectSpread(_objectSpread({}, DEFAULT_STATUS), selectedStatus);
    var tr = state.tr;
    var _ref2 = _pluginKey.pluginKey.getState(state) || {},
      showStatusPickerAt = _ref2.showStatusPickerAt;
    if (!showStatusPickerAt) {
      // Same behaviour as quick insert (used in createStatus)
      var statusNode = schema.nodes.status.createChecked(statusProps);
      tr = verifyAndInsertStatus(statusNode, state.tr);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    if (state.doc.nodeAt(showStatusPickerAt)) {
      tr.setNodeMarkup(showStatusPickerAt, schema.nodes.status, statusProps).setSelection(_state.NodeSelection.create(tr.doc, showStatusPickerAt)).setMeta(_pluginKey.pluginKey, {
        showStatusPickerAt: showStatusPickerAt
      }).scrollIntoView();
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
var updateStatusWithAnalytics = exports.updateStatusWithAnalytics = function updateStatusWithAnalytics(editorAnalyticsAPI) {
  return function (inputMethod, status) {
    return (0, _editorAnalytics.withAnalytics)(editorAnalyticsAPI, {
      action: _analytics.ACTION.INSERTED,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.STATUS,
      attributes: {
        inputMethod: inputMethod
      },
      eventType: _analytics.EVENT_TYPE.TRACK
    })(updateStatus(status));
  };
};
var setStatusPickerAt = exports.setStatusPickerAt = function setStatusPickerAt(showStatusPickerAt) {
  return function (state, dispatch) {
    dispatch(state.tr.setMeta(_pluginKey.pluginKey, {
      showStatusPickerAt: showStatusPickerAt,
      isNew: false
    }));
    return true;
  };
};
var removeStatus = exports.removeStatus = function removeStatus(showStatusPickerAt) {
  return function (_ref3) {
    var tr = _ref3.tr;
    tr.replace(showStatusPickerAt, showStatusPickerAt + 1);
    return tr;
  };
};
var setFocusOnStatusInput = exports.setFocusOnStatusInput = function setFocusOnStatusInput() {
  return function (state, dispatch) {
    if (!dispatch) {
      return false;
    }
    var tr = state.tr.setMeta(_pluginKey.pluginKey, {
      focusStatusInput: true
    });
    dispatch(tr);
    return true;
  };
};
var handleClosingByArrows = function handleClosingByArrows(closingMethod, state, showStatusPickerAt, tr) {
  if (closingMethod === 'arrowLeft') {
    // put cursor right before status Lozenge
    tr = tr.setSelection(_state.Selection.near(state.tr.doc.resolve(showStatusPickerAt), -1));
  } else if (closingMethod === 'arrowRight') {
    // put cursor right after status Lozenge
    tr = tr.setSelection(_state.Selection.near(state.tr.doc.resolve(showStatusPickerAt + 1)));
  }
};
var commitStatusPicker = exports.commitStatusPicker = function commitStatusPicker(closingPayload) {
  return function (editorView) {
    var state = editorView.state,
      dispatch = editorView.dispatch;
    var _ref4 = _pluginKey.pluginKey.getState(state) || {},
      showStatusPickerAt = _ref4.showStatusPickerAt;
    var _ref5 = closingPayload || {},
      closingMethod = _ref5.closingMethod;
    if (!showStatusPickerAt) {
      return;
    }
    var statusNode = state.tr.doc.nodeAt(showStatusPickerAt);
    if (!statusNode) {
      return;
    }
    var tr = state.tr;
    tr = tr.setMeta(_pluginKey.pluginKey, {
      showStatusPickerAt: null,
      focusStatusInput: false,
      isNew: false
    });
    if (closingMethod) {
      handleClosingByArrows(closingMethod, state, showStatusPickerAt, tr);
    } else if (statusNode.attrs.text) {
      // still has content - keep content
      // move selection after status if selection did not change
      if (tr.selection.from === showStatusPickerAt) {
        tr = tr.setSelection(_state.Selection.near(state.tr.doc.resolve(showStatusPickerAt + 2)));
      }
    } else {
      // no content - remove node
      tr = tr.delete(showStatusPickerAt, showStatusPickerAt + 1);
    }
    dispatch(tr);
    editorView.focus();
  };
};