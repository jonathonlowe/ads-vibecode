import { GraphQLError, HttpError } from '../../../common/utils/error';
import { EXPONENTIAL_BACKOFF_RETRY_POLICY, is5xx, isFetchResponse, withExponentialBackoff } from '../../../common/utils/http';
import { handleResponse } from '../../../common/utils/status-code-handlers-provider';
export async function makeGraphQLRequestWithoutRetries(serviceUrl, body, options = {}) {
  const operationNameQuery = options.operationName ? `?q=${options.operationName}` : '';
  const errorPolicy = options.errorPolicy || 'none';
  const url = serviceUrl + operationNameQuery;
  const request = fetch(url, {
    method: 'POST',
    headers: new Headers({
      'Content-Type': 'application/json'
    }),
    credentials: 'include',
    body: JSON.stringify(body)
  }).then(res => {
    if (res.status < 300 || res.status === 400) {
      return res.json();
    } else {
      throw res;
    }
  });
  try {
    const response = await request;
    const errors = response.errors;
    if (errors) {
      if (errorPolicy === 'none') {
        throw GraphQLError.from(errors);
      } else if (errorPolicy === 'all') {
        // Set timeout will postpone error throwing and de-touch it to another event loop,
        // so we can return data along with throwing error
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(GraphQLError.from(errors));
          }, 0);
        });
      }
    }
    return response.data;
  } catch (error) {
    if (error instanceof Response) {
      return {
        response: error
      };
    }
    if (Object(error).hasOwnProperty('response')) {
      throw error;
    }
    return error;
  }
}
export async function handleGraphQLRequest(serviceUrl, body, options = {}) {
  const makeGraphQLRequestWithRetries = withExponentialBackoff(makeGraphQLRequestWithoutRetries, {
    initial: EXPONENTIAL_BACKOFF_RETRY_POLICY.INITIAL_DELAY,
    jitter: EXPONENTIAL_BACKOFF_RETRY_POLICY.JITTER,
    max: EXPONENTIAL_BACKOFF_RETRY_POLICY.MAX_RETRIES,
    retryIf: data => {
      return isFetchResponse(data) && is5xx(data.response.status);
    }
  });
  const result = await makeGraphQLRequestWithRetries(serviceUrl, body, options);
  const response = result === null || result === void 0 ? void 0 : result.response;
  if (response) {
    const status = response.status;
    const statusText = response.statusText;
    const traceId = response.headers.get('atl-traceid');
    handleResponse(response);
    if (status > 400 && status <= 599) {
      throw new HttpError({
        message: statusText,
        status,
        traceId: traceId !== null && traceId !== void 0 ? traceId : undefined
      });
    }
  }
  return result;
}