import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
export var EXPONENTIAL_BACKOFF_RETRY_POLICY = {
  INITIAL_DELAY: 200,
  MAX_RETRIES: 5,
  JITTER: true
};

/**
 * Checks whether a status code is a 5xx HTTP code.
 * @param {number} status HTTP status code
 */
export function is5xx(status) {
  return 500 <= status && status <= 599;
}
export function isFetchResponse(data) {
  if (!data || !data.hasOwnProperty('response')) {
    return false;
  }
  return data.response instanceof Response;
}

// tslint:disable-next-line no-any

// tslint:disable-next-line no-any
var defaultRetryIfCallback = function defaultRetryIfCallback(a) {
  return !a;
};
var defaultOptions = {
  initial: 200,
  jitter: false,
  max: 5,
  retryIf: defaultRetryIfCallback
};
/**
 * Transparently wrap a function so that it is retried until it succeeds or reaches a max retry limit.
 * The returned function has the same signature as the wrapped function.
 *
 * Modified from https://jsfiddle.net/pajtai/pLka0ow9/
 */
export function withExponentialBackoff(toTry) {
  var hofOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  var initial = hofOptions.initial,
    jitter = hofOptions.jitter,
    max = hofOptions.max,
    retryIf = hofOptions.retryIf;

  // Initialize max retry decrementing counter (range of max...0)
  var attemptsRemaining = max;

  // Initialize delay. This will exponentially increase each retry (delay = intial * 2^n)
  var delay = initial;

  /**
   * This function calls itself recursively until `retryIf` evaluates false or the retry limit is reached.
   * The functioned-to-be-retried is called on each recursion.
   */
  return /*#__PURE__*/function () {
    var _tryWithExponentialBackoff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var result,
        _args = arguments;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return toTry.apply(void 0, _args);
          case 2:
            result = _context.sent;
            --attemptsRemaining;

            // If tried function was unsuccessful and there are still retries remaining, retry!
            if (!(retryIf && retryIf(result) && attemptsRemaining > 0)) {
              _context.next = 9;
              break;
            }
            _context.next = 7;
            return new Promise(function (resolve) {
              return setTimeout(resolve, jitter ? Math.random() * delay : delay);
            });
          case 7:
            // Exponentially increase delay
            delay *= 2;

            // Initiate retry
            return _context.abrupt("return", tryWithExponentialBackoff.apply(void 0, _args));
          case 9:
            return _context.abrupt("return", result);
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function tryWithExponentialBackoff() {
      return _tryWithExponentialBackoff.apply(this, arguments);
    }
    return tryWithExponentialBackoff;
  }();
}
export var fetchWithExponentialBackoff = withExponentialBackoff(function (url, init) {
  return fetch(url, init);
}, {
  initial: EXPONENTIAL_BACKOFF_RETRY_POLICY.INITIAL_DELAY,
  jitter: EXPONENTIAL_BACKOFF_RETRY_POLICY.JITTER,
  max: EXPONENTIAL_BACKOFF_RETRY_POLICY.MAX_RETRIES,
  retryIf: function retryIf(response) {
    return is5xx(response.status);
  }
});