import React, { Component } from 'react';
import type { EditorAnalyticsAPI } from '@atlaskit/editor-common/analytics';
import type { Selection } from '@atlaskit/editor-prosemirror/state';
import type { EditorView } from '@atlaskit/editor-prosemirror/view';
import type { RowStickyState } from '../../pm-plugins/sticky-headers/types';
import type { PluginInjectionAPI } from '../../types';
import type { CellSelectionType } from './types';
export interface Props {
    editorView: EditorView;
    selection: Selection;
    api: PluginInjectionAPI | undefined | null;
    tableRef?: HTMLTableElement;
    mountPoint?: HTMLElement;
    boundariesElement?: HTMLElement;
    scrollableElement?: HTMLElement;
    stickyHeaders?: RowStickyState;
    isNumberColumnEnabled?: boolean;
    editorAnalyticsAPI?: EditorAnalyticsAPI;
}
interface State {
    selectionType?: CellSelectionType;
    left: number;
    top: number;
    indexes: number[];
    position?: string;
    scrollLeft: number;
}
declare class FloatingDeleteButton extends Component<Props, State> {
    static displayName: string;
    wrapper: HTMLElement | null;
    constructor(props: Props);
    shouldComponentUpdate(_: Props, nextState: State): boolean;
    componentDidMount(): void;
    componentDidUpdate(): void;
    updateWrapper: () => void;
    componentWillUnmount(): void;
    onWrapperScrolled: (e: Event) => void;
    /**
     * We derivate the button state from the properties passed.
     * We do this in here because we need this information in different places
     * and this prevent to do multiple width calculations in the same component.
     */
    static getDerivedStateFromProps(nextProps: Readonly<Props>, prevState: State): Partial<State> | null;
    private handleMouseEnter;
    private handleMouseLeave;
    /**
     *
     *
     * @private
     * @memberof FloatingDeleteButton
     */
    private handleClick;
    render(): React.JSX.Element | null;
}
export default FloatingDeleteButton;
