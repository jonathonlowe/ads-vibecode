import _typeof from "@babel/runtime/helpers/typeof";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import React from 'react';
import { getTableContainerWidth } from '@atlaskit/editor-common/node-width';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import { WithPluginState } from '@atlaskit/editor-common/with-plugin-state';
import { DOMSerializer } from '@atlaskit/editor-prosemirror/model';
import { akEditorTableNumberColumnWidth } from '@atlaskit/editor-shared-styles';
import { TableMap } from '@atlaskit/editor-tables/table-map';
import { fg } from '@atlaskit/platform-feature-flags';
import { pluginConfig as getPluginConfig } from '../pm-plugins/create-plugin-config';
import { pluginKey as tableDragAndDropPluginKey } from '../pm-plugins/drag-and-drop/plugin-key';
import { getPluginState } from '../pm-plugins/plugin-factory';
import { pluginKey } from '../pm-plugins/plugin-key';
import { pluginKey as tableResizingPluginKey } from '../pm-plugins/table-resizing/plugin-key';
import { generateColgroup } from '../pm-plugins/table-resizing/utils/colgroup';
import { pluginKey as tableWidthPluginKey } from '../pm-plugins/table-width';
import { isTableNested } from '../pm-plugins/utils/nodes';
import TableComponent from './TableComponent';
import { TableComponentWithSharedState } from './TableComponentWithSharedState';
import { tableNodeSpecWithFixedToDOM } from './toDOM';
var tableAttributes = function tableAttributes(node) {
  return {
    'data-number-column': node.attrs.isNumberColumnEnabled,
    'data-layout': node.attrs.layout,
    'data-autosize': node.attrs.__autoSize,
    'data-table-local-id': node.attrs.localId || '',
    'data-table-width': node.attrs.width || 'inherit',
    'data-table-display-mode': node.attrs.displayMode
  };
};
var getInlineWidth = function getInlineWidth(node, options, state, pos, allowTableResizing) {
  if (!node.attrs.width && options !== null && options !== void 0 && options.isCommentEditor && allowTableResizing) {
    return;
  }

  // provide a width for tables when custom table width is supported
  // this is to ensure 'responsive' tables (colgroup widths are undefined) become fixed to
  // support screen size adjustments
  var shouldHaveInlineWidth = allowTableResizing && !isTableNested(state, pos);
  var widthValue = getTableContainerWidth(node);
  if (node.attrs.isNumberColumnEnabled) {
    widthValue -= akEditorTableNumberColumnWidth;
  }
  return shouldHaveInlineWidth ? widthValue : undefined;
};
var handleInlineTableWidth = function handleInlineTableWidth(table, width) {
  if (!table || !width) {
    return;
  }
  table.style.setProperty('width', "".concat(width, "px"));
};

// Remove after removing the platform_editor_table_initial_load_fix flag.
var toDOM = function toDOM(node, props) {
  var colgroup = '';
  if (props.allowColumnResizing) {
    colgroup = ['colgroup', {}].concat(_toConsumableArray(generateColgroup(node)));
  }
  return ['table', tableAttributes(node), colgroup, ['tbody', 0]];
};
var TableView = /*#__PURE__*/function (_ReactNodeView) {
  function TableView(props) {
    var _this;
    _classCallCheck(this, TableView);
    _this = _callSuper(this, TableView, [props.node, props.view, props.getPos, props.portalProviderAPI, props.eventDispatcher, props]);
    _defineProperty(_this, "getNode", function () {
      return _this.node;
    });
    _defineProperty(_this, "hasHoveredRows", false);
    _this.getPos = props.getPos;
    _this.eventDispatcher = props.eventDispatcher;
    _this.options = props.options;
    _this.getEditorFeatureFlags = props.getEditorFeatureFlags;
    if (fg('platform_editor_table_initial_load_fix')) {
      _this.handleRef = function (node) {
        return _this._handleTableRef(node);
      };
    }
    return _this;
  }
  _inherits(TableView, _ReactNodeView);
  return _createClass(TableView, [{
    key: "getContentDOM",
    value: function getContentDOM() {
      var tableDOMStructure;
      if (fg('platform_editor_table_initial_load_fix')) {
        tableDOMStructure = tableNodeSpecWithFixedToDOM({
          allowColumnResizing: !!this.reactComponentProps.allowColumnResizing,
          tableResizingEnabled: !!this.reactComponentProps.allowTableResizing,
          getEditorContainerWidth: this.reactComponentProps.getEditorContainerWidth
        }).toDOM(this.node);
      } else {
        tableDOMStructure = toDOM(this.node, this.reactComponentProps);
      }
      var rendered = DOMSerializer.renderSpec(document, tableDOMStructure);
      if (rendered.dom) {
        var _this$options, _this$options2, _this$getEditorFeatur;
        if (fg('platform_editor_table_initial_load_fix')) {
          var tableElement = rendered.dom.querySelector('table');
          this.table = tableElement ? tableElement : rendered.dom;
          this.renderedDOM = rendered.dom;
        } else {
          this.table = rendered.dom;
        }
        if (!((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.isTableScalingEnabled) || (_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.isTableScalingEnabled && (_this$getEditorFeatur = this.getEditorFeatureFlags) !== null && _this$getEditorFeatur !== void 0 && _this$getEditorFeatur.call(this).tableWithFixedColumnWidthsOption && this.node.attrs.displayMode === 'fixed') {
          var tableInlineWidth = getInlineWidth(this.node, this.reactComponentProps.options, this.reactComponentProps.view.state, this.reactComponentProps.getPos(), this.reactComponentProps.allowTableResizing);
          if (tableInlineWidth) {
            handleInlineTableWidth(this.table, tableInlineWidth);
          }
        }
      }
      return rendered;
    }

    /**
     * Handles moving the table from ProseMirror's DOM structure into a React-rendered table node.
     * Temporarily disables mutation observers (except for selection changes) during the move,
     * preserves selection state, and restores it afterwards if mutations occurred and cursor
     * wasn't at start of node. This prevents duplicate tables and maintains editor state during
     * the DOM manipulation.
     */
  }, {
    key: "_handleTableRef",
    value: function _handleTableRef(node) {
      var _this2 = this;
      var oldIgnoreMutation;
      var selectionBookmark;
      var mutationsIgnored = false;

      // Only proceed if we have both a node and table, and the table isn't already inside the node
      if (node && this.table && !node.contains(this.table)) {
        // Store the current ignoreMutation handler so we can restore it later
        oldIgnoreMutation = this.ignoreMutation;

        // Set up a temporary mutation handler that:
        // - Ignores all DOM mutations except selection changes
        // - Tracks when mutations have been ignored via mutationsIgnored flag
        this.ignoreMutation = function (m) {
          var isSelectionMutation = m.type === 'selection';
          if (!isSelectionMutation) {
            mutationsIgnored = true;
          }
          return !isSelectionMutation;
        };

        // Store the current selection state if there is a visible selection
        // This lets us restore it after DOM changes
        if (this.view.state.selection.visible) {
          selectionBookmark = this.view.state.selection.getBookmark();
        }

        // Remove the ProseMirror table DOM structure to avoid duplication, as it's replaced with the React table node.
        if (this.dom && this.renderedDOM) {
          this.dom.removeChild(this.renderedDOM);
        }
        // Move the table from the ProseMirror table structure into the React rendered table node.
        node.appendChild(this.table);

        // After the next frame:
        requestAnimationFrame(function () {
          // Restore the original mutation handler
          _this2.ignoreMutation = oldIgnoreMutation;

          // Restore the selection only if:
          // - We have a selection bookmark
          // - Mutations were ignored during the table move
          // - The bookmarked selection is different from the current selection.
          if (selectionBookmark && mutationsIgnored) {
            var resolvedSelection = selectionBookmark.resolve(_this2.view.state.tr.doc);
            // Don't set the selection if it's the same as the current selection.
            if (!resolvedSelection.eq(_this2.view.state.selection)) {
              _this2.view.dispatch(_this2.view.state.tr.setSelection(resolvedSelection));
            }
          }
        });
      }
    }
  }, {
    key: "setDomAttrs",
    value: function setDomAttrs(node) {
      var _this3 = this,
        _this$options3,
        _this$options4,
        _this$getEditorFeatur2;
      if (!this.table) {
        return;
      }
      var attrs = tableAttributes(node);
      Object.keys(attrs).forEach(function (attr) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        _this3.table.setAttribute(attr, attrs[attr]);
      });

      // Preserve Table Width cannot have inline width set on the table
      if (!((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.isTableScalingEnabled) || (_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.isTableScalingEnabled && (_this$getEditorFeatur2 = this.getEditorFeatureFlags) !== null && _this$getEditorFeatur2 !== void 0 && _this$getEditorFeatur2.call(this).tableWithFixedColumnWidthsOption && node.attrs.displayMode === 'fixed') {
        var _tableWidthPluginKey$;
        // handle inline style when table been resized
        var tableInlineWidth = getInlineWidth(node, this.reactComponentProps.options, this.view.state, this.getPos(), this.reactComponentProps.allowTableResizing);
        var isTableResizing = (_tableWidthPluginKey$ = tableWidthPluginKey.getState(this.view.state)) === null || _tableWidthPluginKey$ === void 0 ? void 0 : _tableWidthPluginKey$.resizing;
        if (!isTableResizing && tableInlineWidth) {
          handleInlineTableWidth(this.table, tableInlineWidth);
        }
      }
    }
  }, {
    key: "render",
    value: function render(props, forwardRef) {
      var _this4 = this;
      if (fg('platform_editor_table_use_shared_state_hook_fg')) {
        return /*#__PURE__*/React.createElement(TableComponentWithSharedState, {
          forwardRef: forwardRef,
          getNode: this.getNode,
          view: props.view,
          options: props.options,
          eventDispatcher: props.eventDispatcher,
          api: props.pluginInjectionApi,
          allowColumnResizing: props.allowColumnResizing,
          allowTableAlignment: props.allowTableAlignment,
          allowTableResizing: props.allowTableResizing,
          allowControls: props.allowControls,
          getPos: props.getPos,
          getEditorFeatureFlags: props.getEditorFeatureFlags,
          dispatchAnalyticsEvent: props.dispatchAnalyticsEvent
        });
      }
      // Please, do not copy or use this kind of code below
      // @ts-ignore
      var fakePluginKey = {
        key: 'widthPlugin$',
        getState: function getState(state) {
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return state['widthPlugin$'];
        }
      };

      // Please, do not copy or use this kind of code below
      // @ts-ignore
      var fakeMediaPluginKey = {
        key: 'mediaPlugin$',
        getState: function getState(state) {
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return state['mediaPlugin$'];
        }
      };
      return /*#__PURE__*/React.createElement(WithPluginState, {
        plugins: {
          pluginState: pluginKey,
          tableResizingPluginState: tableResizingPluginKey,
          tableWidthPluginState: tableWidthPluginKey,
          widthPlugin: fakePluginKey,
          mediaState: fakeMediaPluginKey,
          tableDragAndDropState: tableDragAndDropPluginKey
        },
        editorView: props.view,
        render: function render(pluginStates) {
          var _props$options;
          var tableResizingPluginState = pluginStates.tableResizingPluginState,
            tableWidthPluginState = pluginStates.tableWidthPluginState,
            pluginState = pluginStates.pluginState,
            mediaState = pluginStates.mediaState;
          var containerWidth = props.getEditorContainerWidth();
          var isTableResizing = tableWidthPluginState === null || tableWidthPluginState === void 0 ? void 0 : tableWidthPluginState.resizing;
          var isResizing = Boolean((tableResizingPluginState === null || tableResizingPluginState === void 0 ? void 0 : tableResizingPluginState.dragging) || isTableResizing);

          /**
           *  ED-19810
           *  There is a getPos issue coming from this code. We need to apply this workaround for now and apply a patch
           *  directly to confluence since this bug is now in production.
           */
          var tablePos;
          try {
            tablePos = props.getPos ? props.getPos() : undefined;
          } catch (e) {
            tablePos = undefined;
          }

          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          var tableActive = tablePos === pluginState.tablePos && !isTableResizing;
          return /*#__PURE__*/React.createElement(TableComponent, {
            view: props.view,
            allowColumnResizing: props.allowColumnResizing,
            eventDispatcher: props.eventDispatcher,
            getPos: props.getPos,
            isMediaFullscreen: mediaState === null || mediaState === void 0 ? void 0 : mediaState.isFullscreen,
            options: props.options
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            allowControls: pluginState.pluginConfig.allowControls
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            isHeaderRowEnabled: pluginState.isHeaderRowEnabled
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            isHeaderColumnEnabled: pluginState.isHeaderColumnEnabled
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            isDragAndDropEnabled: pluginState.isDragAndDropEnabled,
            isTableScalingEnabled: (_props$options = props.options) === null || _props$options === void 0 ? void 0 : _props$options.isTableScalingEnabled // this.options?.isTableScalingEnabled same as TableOptions.isTableScalingEnabled same as pluginState.isTableScalingEnabled
            ,
            allowTableAlignment: props.allowTableAlignment,
            allowTableResizing: props.allowTableResizing,
            tableActive: tableActive
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            ordering: pluginState.ordering,
            isResizing: isResizing,
            getNode: _this4.getNode
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ,
            containerWidth: containerWidth,
            contentDOM: forwardRef,
            getEditorFeatureFlags: props.getEditorFeatureFlags,
            dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
            pluginInjectionApi: props.pluginInjectionApi
          });
        }
      });
    }
  }, {
    key: "viewShouldUpdate",
    value: function viewShouldUpdate(nextNode) {
      var _getPluginState = getPluginState(this.view.state),
        hoveredRows = _getPluginState.hoveredRows;
      var hoveredRowsChanged = !!(hoveredRows !== null && hoveredRows !== void 0 && hoveredRows.length) !== this.hasHoveredRows;
      if (nextNode.attrs.isNumberColumnEnabled && hoveredRowsChanged) {
        this.hasHoveredRows = !!(hoveredRows !== null && hoveredRows !== void 0 && hoveredRows.length);
        return true;
      }
      var node = this.getNode();
      if (_typeof(node.attrs) !== _typeof(nextNode.attrs)) {
        return true;
      }
      var attrKeys = Object.keys(node.attrs);
      var nextAttrKeys = Object.keys(nextNode.attrs);
      if (attrKeys.length !== nextAttrKeys.length) {
        return true;
      }
      var tableMap = TableMap.get(node);
      var nextTableMap = TableMap.get(nextNode);
      if (tableMap.width !== nextTableMap.width) {
        return true;
      }
      return attrKeys.some(function (key) {
        return node.attrs[key] !== nextNode.attrs[key];
      });
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      var type = mutation.type,
        _mutation$target = mutation.target,
        nodeName = _mutation$target.nodeName,
        firstChild = _mutation$target.firstChild;
      if (type === 'selection' && (nodeName === null || nodeName === void 0 ? void 0 : nodeName.toUpperCase()) === 'DIV' && (firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeName.toUpperCase()) === 'TABLE') {
        return false;
      }

      // ED-16668
      // Do not remove this fixes an issue with windows firefox that relates to
      // the addition of the shadow sentinels
      if (type === 'selection' && (nodeName === null || nodeName === void 0 ? void 0 : nodeName.toUpperCase()) === 'TABLE' && ((firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeName.toUpperCase()) === 'COLGROUP' || (firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeName.toUpperCase()) === 'SPAN')) {
        return false;
      }
      if (!this.contentDOM) {
        return true;
      }
      return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$eventDispatcher;
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
      (_this$eventDispatcher = this.eventDispatcher) === null || _this$eventDispatcher === void 0 || _this$eventDispatcher.emit('TABLE_DELETED', this.node);
      _superPropGet(TableView, "destroy", this, 3)([]);
    }
  }]);
}(ReactNodeView);
export { TableView as default };
export var createTableView = function createTableView(node, view, getPos, portalProviderAPI, eventDispatcher, getEditorContainerWidth, getEditorFeatureFlags, dispatchAnalyticsEvent, pluginInjectionApi, isCommentEditor, isChromelessEditor) {
  var _pluginInjectionApi$t;
  var _getPluginState2 = getPluginState(view.state),
    pluginConfig = _getPluginState2.pluginConfig,
    isFullWidthModeEnabled = _getPluginState2.isFullWidthModeEnabled,
    wasFullWidthModeEnabled = _getPluginState2.wasFullWidthModeEnabled,
    isDragAndDropEnabled = _getPluginState2.isDragAndDropEnabled,
    isTableScalingEnabled = _getPluginState2.isTableScalingEnabled;

  // Use shared state for isFullWidthModeEnabled and wasFullWidthModeEnabled for most up-to-date values
  var tableState = pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$t = pluginInjectionApi.table) === null || _pluginInjectionApi$t === void 0 ? void 0 : _pluginInjectionApi$t.sharedState.currentState();
  var _getPluginConfig = getPluginConfig(pluginConfig),
    allowColumnResizing = _getPluginConfig.allowColumnResizing,
    allowControls = _getPluginConfig.allowControls,
    allowTableResizing = _getPluginConfig.allowTableResizing,
    allowTableAlignment = _getPluginConfig.allowTableAlignment;
  return new TableView({
    node: node,
    view: view,
    allowColumnResizing: allowColumnResizing,
    allowTableResizing: allowTableResizing,
    allowTableAlignment: allowTableAlignment,
    allowControls: allowControls,
    portalProviderAPI: portalProviderAPI,
    eventDispatcher: eventDispatcher,
    getPos: getPos,
    options: {
      isFullWidthModeEnabled: fg('platform_editor_table_overflow_in_full_width_fix') ? tableState === null || tableState === void 0 ? void 0 : tableState.isFullWidthModeEnabled : isFullWidthModeEnabled,
      wasFullWidthModeEnabled: fg('platform_editor_table_overflow_in_full_width_fix') ? tableState === null || tableState === void 0 ? void 0 : tableState.wasFullWidthModeEnabled : wasFullWidthModeEnabled,
      isDragAndDropEnabled: isDragAndDropEnabled,
      isTableScalingEnabled: isTableScalingEnabled,
      // same as options.isTableScalingEnabled
      isCommentEditor: isCommentEditor,
      isChromelessEditor: isChromelessEditor
    },
    getEditorContainerWidth: getEditorContainerWidth,
    getEditorFeatureFlags: getEditorFeatureFlags,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    pluginInjectionApi: pluginInjectionApi
  }).init();
};