import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
/* eslint-disable @atlaskit/design-system/no-html-button */

import React, { useEffect, useMemo, useRef, useState } from 'react';
import classnames from 'classnames';
import ReactDOM from 'react-dom';
import { injectIntl } from 'react-intl-next';
import { browser } from '@atlaskit/editor-common/browser';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { tableMessages as messages } from '@atlaskit/editor-common/messages';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { findTable, TableMap } from '@atlaskit/editor-tables';
import { draggable } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { setCustomNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview';
import { getPluginState as getDnDPluginState } from '../../pm-plugins/drag-and-drop/plugin-factory';
import { getPluginState } from '../../pm-plugins/plugin-factory';
import { findDuplicatePosition, hasMergedCellsInSelection } from '../../pm-plugins/utils/merged-cells';
import { TableCssClassName as ClassName } from '../../types';
import { dragTableInsertColumnButtonSize } from '../consts';
import { DragPreview } from '../DragPreview';
import { HandleIconComponent } from './HandleIconComponent';
var DragHandleComponent = function DragHandleComponent(_ref) {
  var isDragMenuTarget = _ref.isDragMenuTarget,
    tableLocalId = _ref.tableLocalId,
    _ref$direction = _ref.direction,
    direction = _ref$direction === void 0 ? 'row' : _ref$direction,
    _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'default' : _ref$appearance,
    indexes = _ref.indexes,
    _ref$forceDefaultHand = _ref.forceDefaultHandle,
    forceDefaultHandle = _ref$forceDefaultHand === void 0 ? false : _ref$forceDefaultHand,
    previewWidth = _ref.previewWidth,
    previewHeight = _ref.previewHeight,
    onMouseOver = _ref.onMouseOver,
    onMouseOut = _ref.onMouseOut,
    toggleDragMenu = _ref.toggleDragMenu,
    hoveredCell = _ref.hoveredCell,
    onClick = _ref.onClick,
    editorView = _ref.editorView,
    formatMessage = _ref.intl.formatMessage,
    hoveredColumns = _ref.hoveredColumns,
    hoveredRows = _ref.hoveredRows;
  var dragHandleDivRef = useRef(null);
  var _useState = useState(null),
    _useState2 = _slicedToArray(_useState, 2),
    previewContainer = _useState2[0],
    setPreviewContainer = _useState2[1];
  var state = editorView.state,
    selection = editorView.state.selection;
  if (hoveredColumns === undefined || hoveredRows === undefined) {
    var _getPluginState = getPluginState(state),
      hoveredColumnsState = _getPluginState.hoveredColumns,
      hoveredRowsState = _getPluginState.hoveredRows;
    hoveredColumns = hoveredColumnsState;
    hoveredRows = hoveredRowsState;
  }
  var _getDnDPluginState = getDnDPluginState(state),
    _getDnDPluginState$is = _getDnDPluginState.isDragMenuOpen,
    isDragMenuOpen = _getDnDPluginState$is === void 0 ? false : _getDnDPluginState$is;
  var isRow = direction === 'row';
  var isColumn = direction === 'column';

  // Added !isDragMenuOpen check so when hover 'Delete column/row' from drag menu
  // the handle of the next column/row does not show the 'hovered' state icon
  var isRowHandleHovered = isRow && hoveredRows.length > 0 && !isDragMenuOpen;
  var isColumnHandleHovered = isColumn && hoveredColumns.length > 0 && !isDragMenuOpen;
  var hasMergedCells = useMemo(function () {
    var table = findTable(selection);
    if (!table) {
      return false;
    }
    var map = TableMap.get(table === null || table === void 0 ? void 0 : table.node);
    if (!map.hasMergedCells() || indexes.length < 1) {
      return false;
    }
    var mapByColumn = map.mapByColumn,
      mapByRow = map.mapByRow;

    // this handle when hover to first column or row which has merged cells.
    if (hoveredCell && hoveredCell.rowIndex !== undefined && hoveredCell.colIndex !== undefined && selection instanceof TextSelection) {
      var rowIndex = hoveredCell.rowIndex,
        colIndex = hoveredCell.colIndex;
      var mergedPositionInRow = findDuplicatePosition(mapByRow[rowIndex]);
      var mergedPositionInCol = findDuplicatePosition(mapByColumn[colIndex]);
      var hasMergedCellsInFirstRowOrColumn = direction === 'column' ? mergedPositionInRow.includes(mapByRow[0][colIndex]) : mergedPositionInCol.includes(mapByColumn[0][rowIndex]);
      var isHoveredOnFirstRowOrColumn = direction === 'column' ? hoveredCell.rowIndex === 0 && hasMergedCellsInFirstRowOrColumn : hoveredCell.colIndex === 0 && hasMergedCellsInFirstRowOrColumn;
      if (isHoveredOnFirstRowOrColumn) {
        var mergedSizes = direction === 'column' ? mapByRow[0].filter(function (el) {
          return el === mapByRow[0][colIndex];
        }).length : mapByColumn[0].filter(function (el) {
          return el === mapByColumn[0][rowIndex];
        }).length;
        var mergedSelection = hasMergedCellsInSelection(direction === 'column' ? [colIndex, colIndex + mergedSizes - 1] : [rowIndex, rowIndex + mergedSizes - 1], direction)(selection);
        return mergedSelection;
      }
    }
    return hasMergedCellsInSelection(indexes, direction)(selection);
  }, [indexes, selection, direction, hoveredCell]);
  var handleIconProps = {
    forceDefaultHandle: forceDefaultHandle,
    isHandleHovered: isColumnHandleHovered || isRowHandleHovered,
    hasMergedCells: hasMergedCells
  };
  useEffect(function () {
    var dragHandleDivRefCurrent = dragHandleDivRef.current;
    if (dragHandleDivRefCurrent) {
      return draggable({
        element: dragHandleDivRefCurrent,
        canDrag: function canDrag() {
          return !hasMergedCells;
        },
        getInitialData: function getInitialData() {
          return {
            localId: tableLocalId,
            type: "table-".concat(direction),
            indexes: indexes
          };
        },
        onGenerateDragPreview: function onGenerateDragPreview(_ref2) {
          var nativeSetDragImage = _ref2.nativeSetDragImage;
          setCustomNativeDragPreview({
            getOffset: function getOffset(_ref3) {
              var container = _ref3.container;
              var rect = container.getBoundingClientRect();
              if (browser.safari) {
                // See: https://product-fabric.atlassian.net/browse/ED-21442
                // We need to ensure that the preview is not overlaying screen content when the snapshot is taken, otherwise
                // safari will composite the screen text elements into the bitmap snapshot. The container is a wrapper which is already
                // positioned fixed at top/left 0.
                // IMPORTANT: we must not exceed more then the width of the container off-screen otherwise not preview will
                // be generated.
                container.style.left = "-".concat(rect.width - 0.0001, "px");
              }
              if (isRow) {
                return {
                  x: 12,
                  y: rect.height / 2
                };
              } else {
                return {
                  x: rect.width / 2 + 4,
                  y: 12
                };
              }
            },
            render: function render(_ref4) {
              var container = _ref4.container;
              setPreviewContainer(container);
              return function () {
                return setPreviewContainer(null);
              };
            },
            nativeSetDragImage: nativeSetDragImage
          });
        }
      });
    }
  }, [tableLocalId, direction, indexes, isRow, editorView.state.selection, hasMergedCells]);
  var showDragMenuAnchorId = isRow ? 'drag-handle-button-row' : 'drag-handle-button-column';
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
    type: "button"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: ClassName.DRAG_HANDLE_BUTTON_CLICKABLE_ZONE,
    "data-testid": "table-drag-handle-clickable-zone-button",
    style: {
      height: isRow ? // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      "calc(100% - ".concat(dragTableInsertColumnButtonSize, "px)") : "var(--ds-space-200, 16px)",
      // 16px here because it's the size of drag handle button's large side
      width: isRow ? "var(--ds-space-200, 16px)" // 16px here because it's the size of drag handle button's large side
      : // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      "calc(100% - ".concat(dragTableInsertColumnButtonSize, "px)"),
      left: isRow ? "var(--ds-space-050, 4px)" : undefined,
      bottom: isColumn ? "var(--ds-space-0, 0px)" : undefined,
      alignSelf: isColumn ? 'none' : 'center',
      zIndex: isColumn ? '-1' : 'auto',
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      pointerEvents: 'auto'
    },
    onMouseUp: function onMouseUp(e) {
      // should toggle menu if current drag menu open.
      // return focus to editor so copying table selections whilst still works, i cannot call e.preventDefault in a mousemove event as this stops dragstart events from firing
      // -> this is bad for a11y but is the current standard new copy/paste keyboard shortcuts should be introduced instead
      editorView.focus();
      if (isDragMenuOpen) {
        toggleDragMenu && toggleDragMenu('mouse', e);
      }
    },
    onClick: onClick
  }), /*#__PURE__*/React.createElement("button", {
    type: "button",
    id: isDragMenuTarget ? showDragMenuAnchorId : undefined
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: classnames(ClassName.DRAG_HANDLE_BUTTON_CONTAINER, appearance, _defineProperty({}, ClassName.DRAG_HANDLE_DISABLED, hasMergedCells)),
    ref: dragHandleDivRef,
    style: {
      transform: isColumn ? 'none' : 'rotate(90deg)',
      alignSelf: isColumn ? 'none' : 'center'
    },
    "data-testid": "table-drag-handle-button",
    "aria-label": formatMessage(isRow ? messages.rowDragHandle : messages.columnDragHandle),
    "aria-expanded": isDragMenuOpen && isDragMenuTarget ? 'true' : 'false',
    "aria-haspopup": "menu"
    // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
    ,
    onMouseOver: onMouseOver
    // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
    ,
    onMouseOut: onMouseOut,
    onMouseUp: function onMouseUp(e) {
      // return focus to editor so copying table selections whilst still works, i cannot call e.preventDefault in a mousemove event as this stops dragstart events from firing
      // -> this is bad for a11y but is the current standard new copy/paste keyboard shortcuts should be introduced instead
      editorView.focus();
      toggleDragMenu && toggleDragMenu('mouse', e);
    },
    onClick: onClick,
    onKeyDown: function onKeyDown(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        toggleDragMenu && toggleDragMenu('keyboard');
      }
    }
  }, appearance !== 'placeholder' ?
  //  cannot block pointer events in Firefox as it breaks Dragging functionality
  browser.gecko ?
  /*#__PURE__*/
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  React.createElement(HandleIconComponent, handleIconProps) :
  /*#__PURE__*/
  // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
  React.createElement("span", {
    style: {
      pointerEvents: 'none'
    }
  }, /*#__PURE__*/React.createElement(HandleIconComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , handleIconProps)) : null), previewContainer && previewWidth !== undefined && previewHeight !== undefined && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(DragPreview, {
    direction: direction,
    width: previewWidth,
    height: previewHeight
  }), previewContainer));
};
var DragHandleComponentWithSharedState = function DragHandleComponentWithSharedState(_ref5) {
  var isDragMenuTarget = _ref5.isDragMenuTarget,
    tableLocalId = _ref5.tableLocalId,
    direction = _ref5.direction,
    appearance = _ref5.appearance,
    indexes = _ref5.indexes,
    forceDefaultHandle = _ref5.forceDefaultHandle,
    previewHeight = _ref5.previewHeight,
    previewWidth = _ref5.previewWidth,
    onMouseOver = _ref5.onMouseOver,
    onMouseOut = _ref5.onMouseOut,
    toggleDragMenu = _ref5.toggleDragMenu,
    hoveredCell = _ref5.hoveredCell,
    onClick = _ref5.onClick,
    editorView = _ref5.editorView,
    intl = _ref5.intl,
    api = _ref5.api;
  var _ref6 = useSharedPluginState(api, ['table']),
    tableState = _ref6.tableState;
  return /*#__PURE__*/React.createElement(DragHandleComponent, {
    isDragMenuTarget: isDragMenuTarget,
    tableLocalId: tableLocalId,
    direction: direction,
    appearance: appearance,
    indexes: indexes,
    forceDefaultHandle: forceDefaultHandle,
    previewWidth: previewWidth,
    previewHeight: previewHeight,
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    toggleDragMenu: toggleDragMenu,
    hoveredCell: hoveredCell,
    onClick: onClick,
    editorView: editorView,
    intl: intl,
    hoveredColumns: tableState === null || tableState === void 0 ? void 0 : tableState.hoveredColumns,
    hoveredRows: tableState === null || tableState === void 0 ? void 0 : tableState.hoveredRows
  });
};
export var DragHandle = injectIntl(DragHandleComponent);
export var DragHandleWithSharedState = injectIntl(DragHandleComponentWithSharedState);