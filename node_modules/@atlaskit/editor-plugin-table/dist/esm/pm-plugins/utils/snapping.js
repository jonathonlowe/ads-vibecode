import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { isVerticalPosition } from '@atlaskit/editor-common/guideline';
import { akEditorCalculatedWideLayoutWidth, akEditorDefaultLayoutWidth, akEditorFullWidthLayoutWidth, akEditorGutterPaddingDynamic } from '@atlaskit/editor-shared-styles';
var numberOfLanesInDefaultLayoutWidth = 12;
var calculateSubSnappingWidths = function calculateSubSnappingWidths(totalLanes, totalWidth) {
  return new Array(Math.round(totalLanes / 2) - 1).fill(totalWidth / totalLanes).map(function (v, i) {
    return v * (i + 1) * 2;
  });
};
export var calculateDefaultSnappings = function calculateDefaultSnappings() {
  var lengthOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return [].concat(_toConsumableArray(calculateSubSnappingWidths(numberOfLanesInDefaultLayoutWidth, akEditorDefaultLayoutWidth + lengthOffset)), [akEditorDefaultLayoutWidth + lengthOffset, akEditorCalculatedWideLayoutWidth + lengthOffset, akEditorFullWidthLayoutWidth + lengthOffset]);
};
// FF TablePreserve for calculateDefaultSnappings
export var calculateDefaultTablePreserveSnappings = function calculateDefaultTablePreserveSnappings() {
  var lengthOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var editorContainerWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : akEditorFullWidthLayoutWidth;
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    innerGuidelines: false,
    breakoutPoints: false
  };
  var dynamicFullWidthLine = editorContainerWith - akEditorGutterPaddingDynamic() * 2 >= akEditorFullWidthLayoutWidth ? akEditorFullWidthLayoutWidth : editorContainerWith - akEditorGutterPaddingDynamic() * 2;
  var guides = [dynamicFullWidthLine - lengthOffset];
  if (!exclude.breakoutPoints) {
    guides.unshift(akEditorDefaultLayoutWidth + lengthOffset, akEditorCalculatedWideLayoutWidth + lengthOffset);
  }
  if (!exclude.innerGuidelines) {
    guides.unshift.apply(guides, [0].concat(_toConsumableArray(calculateSubSnappingWidths(numberOfLanesInDefaultLayoutWidth, akEditorDefaultLayoutWidth + lengthOffset))));
  }
  return guides;
};
export var defaultSnappingWidths = calculateDefaultSnappings();
export var PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET = 0;
// FF TablePreserve for defaultSnappingWidths
export var defaultTablePreserveSnappingWidths = function defaultTablePreserveSnappingWidths(lengthOffset, editorContainerWidth) {
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    innerGuidelines: false,
    breakoutPoints: false
  };
  return editorContainerWidth - akEditorGutterPaddingDynamic() * 2 > akEditorFullWidthLayoutWidth ? calculateDefaultSnappings() : calculateDefaultTablePreserveSnappings(lengthOffset, editorContainerWidth, exclude); // lengthOffset was hardcoded 0 here, created PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET instead.
};

/**
 * Returns keys of guidelines that are closest to the table and within the snapGap
 */
export var findClosestSnap = function findClosestSnap(currentWidth, snapWidths, guidelines) {
  var snapGap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var closestGapIndex = snapWidths.reduce(function (prev, curr, index) {
    return Math.abs(curr - currentWidth) < Math.abs(snapWidths[prev] - currentWidth) ? index : prev;
  }, 0);
  var gap = Math.abs(snapWidths[closestGapIndex] - currentWidth);
  if (gap < snapGap) {
    var snappingWidth = Math.round(snapWidths[closestGapIndex]);
    var guidelineKeys = guidelines.reduce(function (acc, guideline) {
      // NOTE: The snap points are based on the guidelines, however their formatted as a length value whereas the guidelines
      // are point based. The point base x coords are calculated by halving the lengths. This means we can convert the
      // point base position to length by simply multiplying by 2.
      var length = Math.round(Math.abs(isVerticalPosition(guideline.position) ? guideline.position.x : guideline.position.y) * 2);
      if (snappingWidth >= length - tolerance && snappingWidth <= length + tolerance) {
        acc.push(guideline.key);
      }
      return acc;
    }, []);
    return {
      gap: gap,
      keys: guidelineKeys
    };
  }
  return {
    gap: gap,
    keys: []
  };
};