import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { parsePx } from '@atlaskit/editor-common/utils';
import { safeInsert } from '@atlaskit/editor-prosemirror/utils';
import { TableMap } from '@atlaskit/editor-tables/table-map';
import { findTable, getSelectionRect, isRowSelected } from '@atlaskit/editor-tables/utils';
import { TableCssClassName as ClassName } from '../../types';
import { tableDeleteButtonSize } from '../../ui/consts';
export var getRowHeights = function getRowHeights(tableRef) {
  var heights = [];
  var tableBody = tableRef.querySelector('tbody');
  if (tableBody) {
    var rows = tableBody.childNodes;
    for (var i = 0, count = rows.length; i < count; i++) {
      var row = rows[i];
      heights[i] = row.getBoundingClientRect().height + 1;

      // padding only gets applied when the container has sticky
      if (row.classList.contains('sticky') && i === 0) {
        var styles = window.getComputedStyle(row);
        var paddingTop = parsePx(styles.paddingTop || '');
        heights[i] -= paddingTop ? paddingTop + 1 : +1;
      }
    }
  }
  return heights;
};
export var getRowDeleteButtonParams = function getRowDeleteButtonParams(rowsHeights, selection) {
  var offsetTop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var rect = getSelectionRect(selection);
  if (!rect) {
    return null;
  }
  var height = 0;
  var offset = offsetTop;
  // find the rows before the selection
  for (var i = 0; i < rect.top; i++) {
    var rowHeight = rowsHeights[i];
    if (rowHeight) {
      offset += rowHeight - 1;
    }
  }
  // these are the selected rows widths
  var indexes = [];
  for (var _i = rect.top; _i < rect.bottom; _i++) {
    var _rowHeight = rowsHeights[_i];
    if (_rowHeight) {
      height += _rowHeight - 1;
      indexes.push(_i);
    }
  }
  var top = offset + height / 2 - tableDeleteButtonSize / 2;
  return {
    top: top,
    indexes: indexes
  };
};
export var getRowsParams = function getRowsParams(rowsHeights) {
  var rows = [];
  for (var i = 0, count = rowsHeights.length; i < count; i++) {
    var height = rowsHeights[i];
    if (!height) {
      continue;
    }
    var endIndex = rowsHeights.length;
    for (var k = i + 1, _count = rowsHeights.length; k < _count; k++) {
      if (rowsHeights[k]) {
        endIndex = k;
        break;
      }
    }
    rows.push({
      startIndex: i,
      endIndex: endIndex,
      height: height
    });
  }
  return rows;
};
export var getRowClassNames = function getRowClassNames(index, selection) {
  var hoveredRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var isInDanger = arguments.length > 3 ? arguments[3] : undefined;
  var isResizing = arguments.length > 4 ? arguments[4] : undefined;
  var classNames = [];
  if (isRowSelected(index)(selection) || hoveredRows.indexOf(index) > -1 && !isResizing) {
    classNames.push(ClassName.HOVERED_CELL_ACTIVE);
    if (isInDanger) {
      classNames.push(ClassName.HOVERED_CELL_IN_DANGER);
    }
  }
  return classNames.join(' ');
};
export var copyPreviousRow = function copyPreviousRow(schema) {
  return function (insertNewRowIndex) {
    return function (tr) {
      var table = findTable(tr.selection);
      if (!table) {
        return tr;
      }
      var map = TableMap.get(table.node);
      var copyPreviousRowIndex = insertNewRowIndex - 1;
      if (insertNewRowIndex <= 0) {
        throw Error("Row Index less or equal 0 isn't not allowed since there is not a previous to copy");
      }
      if (insertNewRowIndex > map.height) {
        return tr;
      }
      var tableNode = table.node;
      var tableRow = schema.nodes.tableRow;
      var cellsInRow = map.cellsInRect({
        left: 0,
        right: map.width,
        top: copyPreviousRowIndex,
        bottom: copyPreviousRowIndex + 1
      });
      var offsetIndexPosition = copyPreviousRowIndex * map.width;
      var offsetNextLineIndexPosition = insertNewRowIndex * map.width;
      var cellsPositionsInOriginalRow = map.map.slice(offsetIndexPosition, offsetIndexPosition + map.width);
      var cellsPositionsInNextRow = map.map.slice(offsetNextLineIndexPosition, offsetNextLineIndexPosition + map.width);
      var cells = [];
      var fixRowspans = [];
      for (var i = 0; i < cellsPositionsInOriginalRow.length;) {
        var pos = cellsPositionsInOriginalRow[i];
        var documentCellPos = pos + table.start;
        var node = tr.doc.nodeAt(documentCellPos);
        if (!node) {
          continue;
        }
        var attributes = _objectSpread(_objectSpread({}, node.attrs), {}, {
          colspan: 1,
          rowspan: 1
        });
        var newCell = node.type.createAndFill(attributes);
        if (!newCell) {
          return tr;
        }
        if (cellsPositionsInNextRow.indexOf(pos) > -1) {
          fixRowspans.push({
            pos: documentCellPos,
            node: node
          });
        } else if (cellsInRow.indexOf(pos) > -1) {
          if (node.attrs.colspan > 1) {
            var newCellWithColspanFixed = node.type.createAndFill(_objectSpread(_objectSpread({}, attributes), {}, {
              colspan: node.attrs.colspan
            }));
            if (!newCellWithColspanFixed) {
              return tr;
            }
            cells.push(newCellWithColspanFixed);
            i = i + node.attrs.colspan;
            continue;
          }
          cells.push(newCell);
        } else {
          cells.push(newCell);
        }
        i++;
      }
      fixRowspans.forEach(function (cell) {
        tr.setNodeMarkup(cell.pos, undefined, _objectSpread(_objectSpread({}, cell.node.attrs), {}, {
          rowspan: cell.node.attrs.rowspan + 1
        }));
      });
      var cloneRow = tableNode.child(copyPreviousRowIndex);
      var rowPos = table.start;
      for (var _i2 = 0; _i2 < insertNewRowIndex; _i2++) {
        rowPos += tableNode.child(_i2).nodeSize;
      }
      return safeInsert(tableRow.createChecked(cloneRow.attrs, cells, cloneRow.marks), rowPos)(tr);
    };
  };
};