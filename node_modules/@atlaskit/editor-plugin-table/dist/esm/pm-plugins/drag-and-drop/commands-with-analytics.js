import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { ACTION_SUBJECT, EVENT_TYPE, INPUT_METHOD, TABLE_ACTION, TABLE_STATUS } from '@atlaskit/editor-common/analytics';
import { tableMessages as messages } from '@atlaskit/editor-common/messages';
import { CellSelection } from '@atlaskit/editor-tables/cell-selection';
import { findCellRectClosestToPos, getSelectionRect } from '@atlaskit/editor-tables/utils';
import { getSelectedTableInfo, withEditorAnalyticsAPI } from '../utils/analytics';
import { canMove, getTargetIndex } from '../utils/drag-menu';
import { getSelectedColumnIndexes, getSelectedRowIndexes } from '../utils/selection';
import { clearDropTarget, cloneSource, moveSource } from './commands';
export var clearDropTargetWithAnalytics = function clearDropTargetWithAnalytics(editorAnalyticsAPI) {
  return function (inputMethod, sourceType, sourceIndexes, status, tr) {
    return withEditorAnalyticsAPI(function (_ref) {
      var _sourceIndexes$length;
      var selection = _ref.selection;
      var _getSelectedTableInfo = getSelectedTableInfo(selection),
        totalRowCount = _getSelectedTableInfo.totalRowCount,
        totalColumnCount = _getSelectedTableInfo.totalColumnCount;
      return {
        action: sourceType === 'table-row' ? TABLE_ACTION.MOVED_ROW : TABLE_ACTION.MOVED_COLUMN,
        actionSubject: ACTION_SUBJECT.TABLE,
        actionSubjectId: null,
        attributes: {
          inputMethod: inputMethod,
          count: (_sourceIndexes$length = sourceIndexes === null || sourceIndexes === void 0 ? void 0 : sourceIndexes.length) !== null && _sourceIndexes$length !== void 0 ? _sourceIndexes$length : 0,
          distance: 0,
          status: status,
          totalRowCount: totalRowCount,
          totalColumnCount: totalColumnCount
        },
        eventType: EVENT_TYPE.TRACK
      };
    })(editorAnalyticsAPI)(function (state, dispatch) {
      if (dispatch) {
        clearDropTarget(tr)(state, dispatch);
      }
      return true;
    });
  };
};
export var moveSourceWithAnalytics = function moveSourceWithAnalytics(editorAnalyticsAPI, ariaNotify, getIntl) {
  return function (inputMethod, sourceType, sourceIndexes, targetIndex, tr) {
    return withEditorAnalyticsAPI(function (_ref2) {
      var selection = _ref2.selection;
      var direction = sourceIndexes[0] > targetIndex ? -1 : 1;
      var _getSelectedTableInfo2 = getSelectedTableInfo(selection),
        totalRowCount = _getSelectedTableInfo2.totalRowCount,
        totalColumnCount = _getSelectedTableInfo2.totalColumnCount;
      return {
        action: sourceType === 'table-row' ? TABLE_ACTION.MOVED_ROW : TABLE_ACTION.MOVED_COLUMN,
        actionSubject: ACTION_SUBJECT.TABLE,
        actionSubjectId: null,
        attributes: {
          inputMethod: inputMethod,
          count: sourceIndexes.length,
          // This identifies the total amount of row/cols the move operation covered. The distance covered should be a representaion
          // of the minimum distance. This will account for large selection being moved causing a large distance travelled value.
          distance: Math.min.apply(Math, _toConsumableArray(sourceIndexes.map(function (v) {
            return Math.abs(targetIndex - v);
          }))) * direction,
          // If a drop doesn't actually change anything then we're going to mark the event as cancelled.
          status: sourceIndexes.includes(targetIndex) ? TABLE_STATUS.CANCELLED : TABLE_STATUS.SUCCESS,
          totalRowCount: totalRowCount,
          totalColumnCount: totalColumnCount
        },
        eventType: EVENT_TYPE.TRACK
      };
    })(editorAnalyticsAPI)(function (state, dispatch) {
      if (dispatch) {
        moveSource(sourceType, sourceIndexes, targetIndex, tr)(state, dispatch);
        // Only considering single row/column movement for screen reader as only single row/column selection is supported via keyboard atm.
        if ((inputMethod === INPUT_METHOD.TABLE_CONTEXT_MENU || INPUT_METHOD.SHORTCUT) && sourceIndexes.length === 1 && ariaNotify && getIntl) {
          var direction = sourceIndexes[0] > targetIndex ? -1 : 1; // -1 for left/up , 1 for right/down
          var _getSelectedTableInfo3 = getSelectedTableInfo(state.selection),
            totalRowCount = _getSelectedTableInfo3.totalRowCount,
            totalColumnCount = _getSelectedTableInfo3.totalColumnCount;
          ariaNotify(getIntl().formatMessage(sourceType === 'table-row' ? direction > 0 ? messages.rowMovedDown : messages.rowMovedUp : direction > 0 ? messages.columnMovedRight : messages.columnMovedLeft, {
            index: targetIndex + 1,
            total: sourceType === 'table-row' ? totalRowCount : totalColumnCount
          }), {
            priority: 'important'
          });
        }
      }
      return true;
    });
  };
};
export var moveSourceWithAnalyticsViaShortcut = function moveSourceWithAnalyticsViaShortcut(editorAnalyticsAPI, ariaNotify, getIntl) {
  return function (sourceType, direction) {
    return function (state, dispatch) {
      var selection = state.selection;
      var isCellSelection = selection instanceof CellSelection;
      var selectionRect = isCellSelection ? getSelectionRect(selection) : findCellRectClosestToPos(selection.$from);
      if (!selectionRect) {
        return false;
      }
      var isRow = sourceType === 'table-row';
      var selectedIndexes = isRow ? getSelectedRowIndexes(selectionRect) : getSelectedColumnIndexes(selectionRect);
      if (selectedIndexes.length === 0) {
        return false;
      }
      var _getSelectedTableInfo4 = getSelectedTableInfo(selection),
        totalRowCount = _getSelectedTableInfo4.totalRowCount,
        totalColumnCount = _getSelectedTableInfo4.totalColumnCount;
      if (!canMove(sourceType, direction, isRow ? totalRowCount : totalColumnCount, selection, selectionRect)) {
        return false;
      }
      var targetIndex = getTargetIndex(selectedIndexes, direction);
      return moveSourceWithAnalytics(editorAnalyticsAPI, ariaNotify, getIntl)(INPUT_METHOD.SHORTCUT, sourceType, selectedIndexes, targetIndex)(state, dispatch);
    };
  };
};
export var cloneSourceWithAnalytics = function cloneSourceWithAnalytics(editorAnalyticsAPI) {
  return function (inputMethod, sourceType, sourceIndexes, targetIndex, targetDirection, tr) {
    return withEditorAnalyticsAPI(function (_ref3) {
      var selection = _ref3.selection;
      var direction = sourceIndexes[0] > targetIndex ? -1 : 1;
      var _getSelectedTableInfo5 = getSelectedTableInfo(selection),
        totalRowCount = _getSelectedTableInfo5.totalRowCount,
        totalColumnCount = _getSelectedTableInfo5.totalColumnCount;
      return {
        action: sourceType === 'table-row' ? TABLE_ACTION.CLONED_ROW : TABLE_ACTION.CLONED_COLUMN,
        actionSubject: ACTION_SUBJECT.TABLE,
        actionSubjectId: null,
        attributes: {
          inputMethod: inputMethod,
          count: sourceIndexes.length,
          // This identifies the total amount of row/cols the move operation covered. The distance covered should be a representaion
          // of the minimum distance. This will account for large selection being moved causing a large distance travelled value.
          distance: Math.min.apply(Math, _toConsumableArray(sourceIndexes.map(function (v) {
            return Math.abs(targetIndex - v);
          }))) * direction,
          // If a drop doesn't actually change anything then we're going to mark the event as cancelled.
          status: sourceIndexes.includes(targetIndex) ? TABLE_STATUS.CANCELLED : TABLE_STATUS.SUCCESS,
          totalRowCount: totalRowCount,
          totalColumnCount: totalColumnCount
        },
        eventType: EVENT_TYPE.TRACK
      };
    })(editorAnalyticsAPI)(function (state, dispatch) {
      if (dispatch) {
        cloneSource(sourceType, sourceIndexes, targetIndex, targetDirection, tr)(state, dispatch);
      }
      return true;
    });
  };
};