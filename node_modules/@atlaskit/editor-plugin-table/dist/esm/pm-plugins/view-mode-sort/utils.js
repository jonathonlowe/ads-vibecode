import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { SortOrder } from '@atlaskit/editor-common/types';
import { convertProsemirrorTableNodeToArrayOfRows, createCompareNodes } from '@atlaskit/editor-common/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { IS_DISABLED_CLASS_NAME, SORT_INDEX_DATA_ATTRIBUTE, SORTING_ICON_CLASS_NAME } from './consts';
export var unsort = function unsort(oldOrder, tableElement) {
  var tbody = fg('platform_editor_nested_tables_view_mode_sort') ? tableElement.querySelector(":scope > tbody") : tableElement.querySelector('tbody');
  var rows = fg('platform_editor_nested_tables_view_mode_sort') ? tableElement.querySelectorAll(":scope > tbody > tr") : tableElement.querySelectorAll('tr');
  var sortedOrder = _toConsumableArray(oldOrder).sort(function (a, b) {
    return a.value - b.value;
  });
  sortedOrder.forEach(function (item) {
    tbody === null || tbody === void 0 || tbody.appendChild(rows[item.index + 1]);
  });
};
var getSortOrderFromTable = function getSortOrderFromTable(tableNode, sortIndex, direction) {
  var tableArray = convertProsemirrorTableNodeToArrayOfRows(tableNode);
  tableArray.shift(); // remove header row

  // Keep track of the origin row index
  var tableArrayWithIndex = tableArray.map(function (node, index) {
    return {
      node: node,
      originalIndex: index
    };
  });
  var compareNodesInOrder = createCompareNodes({
    // TODO: ED-26961 - add inline card support
    getInlineCardTextFromStore: function getInlineCardTextFromStore() {
      return null;
    }
  }, direction);
  var order = tableArrayWithIndex.sort(function (a, b) {
    return compareNodesInOrder(a.node[sortIndex], b.node[sortIndex]);
  }).map(function (tableRow, index) {
    return {
      value: tableRow.originalIndex,
      index: index
    };
  });
  return [
  // Ensures the first tr is always first in the order
  {
    value: -1,
    index: -1
  }].concat(_toConsumableArray(order));
};
export var toggleSort = function toggleSort(view, event, pluginState) {
  var _target$closest, _tableNode$type;
  var target = event.target;
  if (!(target instanceof HTMLElement)) {
    return;
  }
  var widget = target.closest(".".concat(SORTING_ICON_CLASS_NAME));
  if (widget !== null && widget !== void 0 && widget.classList.contains(IS_DISABLED_CLASS_NAME) || !widget) {
    return;
  }
  var dataSortIndex = target === null || target === void 0 || (_target$closest = target.closest('.ProseMirror-widget')) === null || _target$closest === void 0 ? void 0 : _target$closest.getAttribute(SORT_INDEX_DATA_ATTRIBUTE);
  var tr = view.state.tr;
  var tableElement = target.closest('table');
  if (!tableElement || !dataSortIndex) {
    return;
  }
  var tablePos = view.posAtDOM(tableElement, 0);
  var tableNode = view.state.doc.nodeAt(tablePos - 1);
  var tableId = tableNode === null || tableNode === void 0 ? void 0 : tableNode.attrs.localId;
  if (!tableId || !tableNode || (tableNode === null || tableNode === void 0 || (_tableNode$type = tableNode.type) === null || _tableNode$type === void 0 ? void 0 : _tableNode$type.name) !== 'table') {
    return;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line prefer-const
  var _ref = (pluginState === null || pluginState === void 0 ? void 0 : pluginState[tableId]) || {},
    index = _ref.index,
    direction = _ref.direction,
    oldOrder = _ref.order;

  // Unsort if there was already a sort
  if (direction !== SortOrder.NO_ORDER && oldOrder !== undefined) {
    unsort(oldOrder, tableElement);
  }
  var sortIndex = parseInt(dataSortIndex);
  if (sortIndex === index) {
    switch (direction) {
      case SortOrder.NO_ORDER:
        direction = SortOrder.ASC;
        break;
      case SortOrder.ASC:
        direction = SortOrder.DESC;
        break;
      case SortOrder.DESC:
        direction = SortOrder.NO_ORDER;
        break;
    }
  } else {
    direction = SortOrder.ASC; // default direction when a new index is clicked
  }
  var order = getSortOrderFromTable(tableNode, sortIndex, direction);
  if (direction === SortOrder.NO_ORDER) {
    tr.setMeta('tableSortMeta', _defineProperty({}, tableId, {}));
  } else {
    tr.setMeta('tableSortMeta', _defineProperty({}, tableId, {
      index: sortIndex,
      direction: direction,
      order: order,
      tableElement: tableElement
    }));
  }
  view.dispatch(tr);
};
export var getTableElements = function getTableElements(tableId) {
  var tableElement = document.querySelector("table[data-table-local-id=\"".concat(tableId, "\"]"));
  var tbody = fg('platform_editor_nested_tables_view_mode_sort') ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector(':scope > tbody') : tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector('tbody');
  var rows = fg('platform_editor_nested_tables_view_mode_sort') ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelectorAll(':scope > tbody > tr') : tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelectorAll('tr');
  return {
    tbody: tbody,
    rows: rows
  };
};