import { getParentNodeWidth, getTableContainerWidth, layoutToWidth } from '@atlaskit/editor-common/node-width';
import { calcTableWidth } from '@atlaskit/editor-common/styles';
import { calcTableColumnWidths } from '@atlaskit/editor-common/utils';
import { akEditorFullWidthLayoutWidth, akEditorGutterPaddingDynamic, akEditorTableNumberColumnWidth } from '@atlaskit/editor-shared-styles';
import { hasTableBeenResized, hasTableColumnBeenResized } from './colgroup';
import { MAX_SCALING_PERCENT, MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION } from './consts';

// Translates named layouts in number values.
export function getLayoutSize(tableLayout) {
  var containerWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var isFullWidthModeEnabled = options.isFullWidthModeEnabled;
  if (isFullWidthModeEnabled) {
    return containerWidth ? Math.min(containerWidth - akEditorGutterPaddingDynamic() * 2, akEditorFullWidthLayoutWidth) : akEditorFullWidthLayoutWidth;
  }
  var calculatedTableWidth = calcTableWidth(tableLayout, containerWidth, true);
  if (calculatedTableWidth !== 'inherit') {
    return calculatedTableWidth;
  }
  return layoutToWidth[tableLayout] || containerWidth;
}

// Does the current position point at a cell.
export function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter;
}

// Get the current col width, handles colspan.
export function currentColWidth(view, cellPos, _ref) {
  var colspan = _ref.colspan,
    colwidth = _ref.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) {
    return width;
  }
  // Not fixed, read current width from DOM
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var domWidth = view.domAtPos(cellPos + 1).node.offsetWidth;
  var parts = colspan || 0;
  if (colwidth) {
    for (var i = 0; i < (colspan || 0); i++) {
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
    }
  }
  return domWidth / parts;
}
export var getTableMaxWidth = function getTableMaxWidth(_ref2) {
  var table = _ref2.table,
    tableStart = _ref2.tableStart,
    state = _ref2.state,
    layout = _ref2.layout,
    getEditorContainerWidth = _ref2.getEditorContainerWidth;
  var containerWidth = getEditorContainerWidth();
  var parentWidth = getParentNodeWidth(tableStart, state, containerWidth);
  var maxWidth = parentWidth || table.attrs.width || getLayoutSize(layout, containerWidth.width, {});
  if (table.attrs.isNumberColumnEnabled) {
    maxWidth -= akEditorTableNumberColumnWidth;
  }
  return maxWidth;
};

/**
 *
 * @param table
 * @returns calculated width of <table /> element derived from sum of colwidths on tableCell or tableHeader nodes or falls back to container width
 */
export var getTableElementWidth = function getTableElementWidth(table) {
  if (hasTableBeenResized(table)) {
    // TODO: ED-26961 - is there a scenario where ADF columns are SMALLER than container width?
    return calcTableColumnWidths(table).reduce(function (sum, width) {
      return sum + width;
    }, 0);
  }
  return getTableContainerElementWidth(table);
};
export var getTableContainerElementWidth = function getTableContainerElementWidth(table) {
  return getTableContainerWidth(table);
};
export var getTableScalingPercent = function getTableScalingPercent(table, tableRef, shouldUseIncreasedScalingPercent) {
  var _tableRef$parentEleme;
  var maxScalingPercent = shouldUseIncreasedScalingPercent ? MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION : MAX_SCALING_PERCENT;
  var tableWidth = getTableContainerElementWidth(table);
  var renderWidth = (tableRef === null || tableRef === void 0 || (_tableRef$parentEleme = tableRef.parentElement) === null || _tableRef$parentEleme === void 0 ? void 0 : _tableRef$parentEleme.clientWidth) || tableWidth;
  // minus 1 here to avoid any 1px scroll in Firefox
  var scalePercent = (renderWidth - 1) / tableWidth;
  scalePercent = Math.max(scalePercent, 1 - maxScalingPercent);
  return Math.min(scalePercent, 1);
};

// This function is used to default and full-width tables in Comment/Chromeless editors
// These tables don't have node.attrs.width set. Their pm-table-wrapper width depend on the editor container width.
// actual table node width can be calculated as sum of colwidth values if table's columns were resized.
// If colwidth are not set, table columns are not resized, they all are equal widths.
export var getScalingPercentForTableWithoutWidth = function getScalingPercentForTableWithoutWidth(table, tableRef) {
  // are table columns resized
  if (hasTableColumnBeenResized(table)) {
    var _tableRef$parentEleme2;
    var tableWidth = calcTableColumnWidths(table).reduce(function (sum, width) {
      return sum + width;
    }, 0);
    var renderWidth = (tableRef === null || tableRef === void 0 || (_tableRef$parentEleme2 = tableRef.parentElement) === null || _tableRef$parentEleme2 === void 0 ? void 0 : _tableRef$parentEleme2.clientWidth) || tableWidth;

    // minus 1 here to avoid any 1px scroll in Firefox
    return (renderWidth - 1) / tableWidth;
  }

  // When table cols are not resized and table width is not set,
  // tableWidth is equal to renderWidth
  return 1;
};
export var getStaticTableScalingPercent = function getStaticTableScalingPercent(table, tableRenderWidth, shouldUseIncreasedScalingPercent) {
  var maxScalingPercent = shouldUseIncreasedScalingPercent ? MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION : MAX_SCALING_PERCENT;
  var tableWidth = getTableContainerElementWidth(table);
  // minus 1 here to avoid any 1px scroll in Firefox
  var scalePercent = (tableRenderWidth - 1) / tableWidth;
  scalePercent = Math.max(scalePercent, 1 - maxScalingPercent);
  return Math.min(scalePercent, 1);
};