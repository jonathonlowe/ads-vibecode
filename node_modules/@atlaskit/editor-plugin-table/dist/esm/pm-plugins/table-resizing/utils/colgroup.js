import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { tableCellMinWidth } from '@atlaskit/editor-common/styles';
import { getFragmentBackingArray } from '@atlaskit/editor-common/utils';
import { DOMSerializer } from '@atlaskit/editor-prosemirror/model';
import { TableMap } from '@atlaskit/editor-tables/table-map';
import { COLUMN_MIN_WIDTH } from './consts';
import { getScalingPercentForTableWithoutWidth, getTableScalingPercent } from './misc';
/**
 * This ensures the combined width of the columns (and tbody) of table is always smaller or equal
 * than the table and table wrapper elements. This is necessary as there is no longer
 * padding on the .pm-table-wrapper, so all elements need to be the same width to avoid
 * overflow.
 */
export var getColWidthFix = function getColWidthFix(colwidth, tableColumnCount) {
  return colwidth - 1 / tableColumnCount;
};
export var generateColgroup = function generateColgroup(table, tableRef, shouldUseIncreasedScalingPercent, isCommentEditor) {
  var cols = [];
  var map = TableMap.get(table);

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  table.content.firstChild.content.forEach(function (cell) {
    var colspan = cell.attrs.colspan || 1;
    if (Array.isArray(cell.attrs.colwidth)) {
      // We slice here to guard against our colwidth array having more entries
      // Than the we actually span. We'll patch the document at a later point.
      if (tableRef) {
        var _table$attrs;
        // if we have tableRef here, isTableScalingEnabled is true
        var scalePercent = 1;
        if (isCommentEditor && !((_table$attrs = table.attrs) !== null && _table$attrs !== void 0 && _table$attrs.width)) {
          scalePercent = getScalingPercentForTableWithoutWidth(table, tableRef);
        } else {
          scalePercent = getTableScalingPercent(table, tableRef, shouldUseIncreasedScalingPercent);
        }
        cell.attrs.colwidth.slice(0, colspan).forEach(function (width) {
          var fixedColWidth = getColWidthFix(width, map.width);
          var scaledWidth = fixedColWidth * scalePercent;
          var finalWidth = Math.max(scaledWidth, tableCellMinWidth);
          cols.push(['col', {
            style: "width: ".concat(finalWidth, "px;")
          }]);
        });
      } else {
        cell.attrs.colwidth.slice(0, colspan).forEach(function (width) {
          cols.push(['col', {
            style: "width: ".concat(getColWidthFix(width ? Math.max(width, tableCellMinWidth) : tableCellMinWidth, map.width), "px;")
          }]);
        });
      }
    } else {
      // When we have merged cells on the first row (firstChild),
      // We want to ensure we're creating the appropriate amount of
      // cols the table still has.
      cols.push.apply(cols, _toConsumableArray(Array.from({
        length: colspan
      }, function (_) {
        return ['col', {
          style: "width: ".concat(tableCellMinWidth, "px;")
        }];
      })));
    }
  });
  return cols;
};
export var insertColgroupFromNode = function insertColgroupFromNode(tableRef, table) {
  var isTableScalingEnabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var shouldRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldUseIncreasedScalingPercent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var isCommentEditor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var colgroup = tableRef === null || tableRef === void 0 ? void 0 : tableRef.querySelector('colgroup');
  if (colgroup && shouldRemove) {
    tableRef === null || tableRef === void 0 || tableRef.removeChild(colgroup);
  }
  colgroup = renderColgroupFromNode(table, isTableScalingEnabled ? tableRef !== null && tableRef !== void 0 ? tableRef : undefined : undefined, shouldUseIncreasedScalingPercent, isCommentEditor);
  if (shouldRemove) {
    tableRef === null || tableRef === void 0 || tableRef.insertBefore(colgroup, tableRef === null || tableRef === void 0 ? void 0 : tableRef.firstChild);
  }
  return colgroup.children;
};
export var hasTableBeenResized = function hasTableBeenResized(table) {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return !!getFragmentBackingArray(table.content.firstChild.content).find(function (cell) {
    return cell.attrs.colwidth;
  });
};
export var hasTableColumnBeenResized = hasTableBeenResized;

/**
 * Check if a table has all the column width set to tableCellMinWidth(48px) or null
 *
 * @param table
 * @returns true if all column width is equal to tableCellMinWidth or null, false otherwise
 */
export var isMinCellWidthTable = function isMinCellWidthTable(table) {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var cellArray = getFragmentBackingArray(table.content.firstChild.content);
  var isTableMinCellWidth = cellArray.every(function (cell) {
    return cell.attrs.colwidth && cell.attrs.colwidth[0] === tableCellMinWidth || cell.attrs.colwidth === null;
  });
  return isTableMinCellWidth;
};
function renderColgroupFromNode(table, maybeTableRef, shouldUseIncreasedScalingPercent, isCommentEditor) {
  var rendered = DOMSerializer.renderSpec(document, ['colgroup', {}].concat(_toConsumableArray(generateColgroup(table, maybeTableRef, shouldUseIncreasedScalingPercent, isCommentEditor))));

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  return rendered.dom;
}
export var getColgroupChildrenLength = function getColgroupChildrenLength(table) {
  var map = TableMap.get(table);
  return map.width;
};
export var getResizerMinWidth = function getResizerMinWidth(node) {
  var currentColumnCount = getColgroupChildrenLength(node);
  var minColumnWidth = Math.min(3, currentColumnCount) * COLUMN_MIN_WIDTH;
  // add an extra pixel as the scale table logic will scale columns to be tableContainerWidth - 1
  // the table can't scale past its min-width, so instead restrict table container min width to avoid that situation
  return minColumnWidth + 1;
};