// #region Imports
import { TableMap } from '@atlaskit/editor-tables/table-map';
import { findTable, getCellsInColumn, getCellsInRow } from '@atlaskit/editor-tables/utils';
import { TableDecorations } from '../../types';
import { createCommand, getPluginState } from '../plugin-factory';
import { createCellHoverDecoration, createColumnLineResize, createControlsHoverDecoration } from '../utils/decoration';
import { getMergedCellsPositions } from '../utils/table';
import { updatePluginStateDecorations } from '../utils/update-plugin-state-decorations';
var makeArray = function makeArray(n) {
  return Array.from(Array(n).keys());
};
export var hoverMergedCells = function hoverMergedCells() {
  return createCommand(function (state) {
    var mergedCellsPositions = getMergedCellsPositions(state.tr);
    if (!mergedCellsPositions.length) {
      return false;
    }
    var table = findTable(state.tr.selection);
    if (!table) {
      return false;
    }
    var mergedCells = mergedCellsPositions.map(function (pos) {
      return {
        pos: pos + table.start,
        start: pos + table.start + 1,
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node: table.node.nodeAt(pos)
      };
    });
    var decorations = createCellHoverDecoration(mergedCells);
    return {
      type: 'HOVER_MERGED_CELLS',
      data: {
        decorationSet: updatePluginStateDecorations(state, decorations, TableDecorations.CELL_CONTROLS_HOVER)
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var hoverColumns = function hoverColumns(hoveredColumns, isInDanger) {
  return createCommand(function (state) {
    var cells = getCellsInColumn(hoveredColumns)(state.tr.selection);
    var _getPluginState = getPluginState(state),
      isDragAndDropEnabled = _getPluginState.isDragAndDropEnabled;
    if (!cells) {
      return false;
    }
    var decorations = createControlsHoverDecoration(cells, 'column', state.tr, isDragAndDropEnabled, hoveredColumns, isInDanger);
    return {
      type: 'HOVER_COLUMNS',
      data: {
        decorationSet: updatePluginStateDecorations(state, decorations, TableDecorations.COLUMN_CONTROLS_HOVER),
        hoveredColumns: hoveredColumns,
        isInDanger: isInDanger
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var hoverRows = function hoverRows(hoveredRows, isInDanger) {
  return createCommand(function (state) {
    var cells = getCellsInRow(hoveredRows)(state.selection);
    if (!cells) {
      return false;
    }
    var _getPluginState2 = getPluginState(state),
      isDragAndDropEnabled = _getPluginState2.isDragAndDropEnabled;
    var decorations = createControlsHoverDecoration(cells, 'row', state.tr, isDragAndDropEnabled, hoveredRows, isInDanger);
    return {
      type: 'HOVER_ROWS',
      data: {
        decorationSet: updatePluginStateDecorations(state, decorations, TableDecorations.ROW_CONTROLS_HOVER),
        hoveredRows: hoveredRows,
        isInDanger: isInDanger
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var hoverTable = function hoverTable(isInDanger, isSelected) {
  return createCommand(function (state) {
    var table = findTable(state.selection);
    if (!table) {
      return false;
    }
    var map = TableMap.get(table.node);
    var hoveredColumns = makeArray(map.width);
    var hoveredRows = makeArray(map.height);
    var cells = getCellsInRow(hoveredRows)(state.selection);
    if (!cells) {
      return false;
    }
    var _getPluginState3 = getPluginState(state),
      isDragAndDropEnabled = _getPluginState3.isDragAndDropEnabled;
    var decorations = createControlsHoverDecoration(cells, 'table', state.tr, isDragAndDropEnabled, [], isInDanger, isSelected);
    return {
      type: 'HOVER_TABLE',
      data: {
        decorationSet: updatePluginStateDecorations(state, decorations, TableDecorations.TABLE_CONTROLS_HOVER),
        hoveredColumns: hoveredColumns,
        hoveredRows: hoveredRows,
        isInDanger: isInDanger,
        isWholeTableInDanger: isInDanger
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var clearHoverSelection = function clearHoverSelection() {
  return createCommand(function (state) {
    return {
      type: 'CLEAR_HOVER_SELECTION',
      data: {
        decorationSet: updatePluginStateDecorations(state, [], TableDecorations.ALL_CONTROLS_HOVER),
        isInDanger: false,
        isWholeTableInDanger: false
      }
    };
  });
};
export var showResizeHandleLine = function showResizeHandleLine(cellColumnPositioning) {
  return createCommand(function (state) {
    var _getPluginState4 = getPluginState(state),
      isDragAndDropEnabled = _getPluginState4.isDragAndDropEnabled;
    return {
      type: 'SHOW_RESIZE_HANDLE_LINE',
      data: {
        decorationSet: updatePluginStateDecorations(state, createColumnLineResize(state.selection, cellColumnPositioning, isDragAndDropEnabled), TableDecorations.COLUMN_RESIZING_HANDLE_LINE)
      }
    };
  });
};
export var hideResizeHandleLine = function hideResizeHandleLine() {
  return createCommand(function (state) {
    return {
      type: 'HIDE_RESIZE_HANDLE_LINE',
      data: {
        decorationSet: updatePluginStateDecorations(state, [], TableDecorations.COLUMN_RESIZING_HANDLE_LINE)
      }
    };
  });
};
export var setTableHovered = function setTableHovered(hovered) {
  return createCommand(function () {
    return {
      type: 'TABLE_HOVERED',
      data: {
        isTableHovered: hovered
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var hoverCell = function hoverCell(rowIndex, colIndex) {
  return createCommand(function (state) {
    var _getPluginState5 = getPluginState(state),
      prevHoveredCell = _getPluginState5.hoveredCell;

    // If no arguments have been passed then the intention it to reset the hover cell data
    var clear = rowIndex === undefined && colIndex === undefined;
    var nextRowIndex = clear ? undefined : rowIndex !== null && rowIndex !== void 0 ? rowIndex : prevHoveredCell.rowIndex;
    var nextColIndex = clear ? undefined : colIndex !== null && colIndex !== void 0 ? colIndex : prevHoveredCell.colIndex;
    if (nextRowIndex === prevHoveredCell.rowIndex && nextColIndex === prevHoveredCell.colIndex) {
      return false;
    }
    return {
      type: 'HOVER_CELL',
      data: {
        hoveredCell: {
          rowIndex: nextRowIndex,
          colIndex: nextColIndex
        }
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};