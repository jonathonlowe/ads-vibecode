import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import isEqual from 'lodash/isEqual';
import { getTableContainerWidth } from '@atlaskit/editor-common/node-width';
import { closestElement, isParagraph, isTextSelection, mapSlice } from '@atlaskit/editor-common/utils';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { CellSelection } from '@atlaskit/editor-tables/cell-selection';
import { TableMap } from '@atlaskit/editor-tables/table-map';
import { findCellClosestToPos, findTable, getCellsInColumn, getCellsInRow, getSelectionRect, isSelectionType, isTableSelected, removeTable, selectColumns as selectColumnsTransform, selectColumn as selectColumnTransform, selectionCell, selectRows as selectRowsTransform, selectRow as selectRowTransform, setCellAttrs } from '@atlaskit/editor-tables/utils';
import { TableCssClassName as ClassName, TableDecorations } from '../../types';
import { getDecorations } from '../decorations/plugin';
import { buildColumnResizingDecorations, clearColumnResizingDecorations } from '../decorations/utils/column-resizing';
import { createCommand, getPluginState } from '../plugin-factory';
import { fixAutoSizedTable } from '../transforms/fix-tables';
import { createColumnControlsDecoration, createColumnSelectedDecoration } from '../utils/decoration';
import { checkIfHeaderColumnEnabled, checkIfHeaderRowEnabled, checkIfNumberColumnEnabled, isIsolating } from '../utils/nodes';
import { updatePluginStateDecorations } from '../utils/update-plugin-state-decorations';
export var setEditorFocus = function setEditorFocus(editorHasFocus) {
  return createCommand({
    type: 'SET_EDITOR_FOCUS',
    data: {
      editorHasFocus: editorHasFocus
    }
  });
};
export var setTableRef = function setTableRef(ref) {
  return createCommand(function (state) {
    var tableRef = ref;
    var foundTable = findTable(state.selection);
    var tableNode = ref && foundTable ? foundTable.node : undefined;
    var tablePos = ref && foundTable ? foundTable.pos : undefined;
    var tableWrapperTarget = closestElement(tableRef, ".".concat(ClassName.TABLE_NODE_WRAPPER)) || undefined;
    var _getPluginState = getPluginState(state),
      isDragAndDropEnabled = _getPluginState.isDragAndDropEnabled;
    return {
      type: 'SET_TABLE_REF',
      data: {
        tableRef: tableRef,
        tableNode: tableNode,
        tablePos: tablePos,
        tableWrapperTarget: tableWrapperTarget,
        isNumberColumnEnabled: checkIfNumberColumnEnabled(state.selection),
        isHeaderRowEnabled: checkIfHeaderRowEnabled(state.selection),
        isHeaderColumnEnabled: checkIfHeaderColumnEnabled(state.selection),
        // decoration set is drawn by the decoration plugin, skip this for DnD as all controls are floating
        decorationSet: !isDragAndDropEnabled ? updatePluginStateDecorations(state, createColumnControlsDecoration(state.selection), TableDecorations.COLUMN_CONTROLS_DECORATIONS) : undefined,
        resizeHandleRowIndex: undefined,
        resizeHandleColumnIndex: undefined
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var setCellAttr = function setCellAttr(name, value) {
  return function (state, dispatch) {
    var tr = state.tr,
      selection = state.selection;
    if (selection instanceof CellSelection) {
      var updated = false;
      selection.forEachCell(function (cell, pos) {
        if (cell.attrs[name] !== value) {
          tr.setNodeMarkup(pos, cell.type, _objectSpread(_objectSpread({}, cell.attrs), {}, _defineProperty({}, name, value)));
          updated = true;
        }
      });
      if (updated) {
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      }
    } else {
      var cell = selectionCell(state.selection);
      if (cell) {
        if (dispatch) {
          var _cell$nodeAfter, _cell$nodeAfter2;
          dispatch(tr.setNodeMarkup(cell.pos, (_cell$nodeAfter = cell.nodeAfter) === null || _cell$nodeAfter === void 0 ? void 0 : _cell$nodeAfter.type, _objectSpread(_objectSpread({}, (_cell$nodeAfter2 = cell.nodeAfter) === null || _cell$nodeAfter2 === void 0 ? void 0 : _cell$nodeAfter2.attrs), {}, _defineProperty({}, name, value))));
        }
        return true;
      }
    }
    return false;
  };
};
export var triggerUnlessTableHeader = function triggerUnlessTableHeader(command) {
  return function (state, dispatch, view) {
    var selection = state.selection,
      tableHeader = state.schema.nodes.tableHeader;
    if (selection instanceof TextSelection) {
      var cell = findCellClosestToPos(selection.$from);
      if (cell && cell.node.type !== tableHeader) {
        return command(state, dispatch, view);
      }
    }
    if (selection instanceof CellSelection) {
      var rect = getSelectionRect(selection);
      if (!checkIfHeaderRowEnabled(selection) || rect && rect.top > 0) {
        return command(state, dispatch, view);
      }
    }
    return false;
  };
};
export var transformSliceRemoveCellBackgroundColor = function transformSliceRemoveCellBackgroundColor(slice, schema) {
  var _schema$nodes = schema.nodes,
    tableCell = _schema$nodes.tableCell,
    tableHeader = _schema$nodes.tableHeader;
  return mapSlice(slice, function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      var cellAttrs = _objectSpread({}, maybeCell.attrs);
      cellAttrs.background = undefined;
      return maybeCell.type.createChecked(cellAttrs, maybeCell.content, maybeCell.marks);
    }
    return maybeCell;
  });
};
export var transformSliceToAddTableHeaders = function transformSliceToAddTableHeaders(slice, schema) {
  var _schema$nodes2 = schema.nodes,
    table = _schema$nodes2.table,
    tableHeader = _schema$nodes2.tableHeader,
    tableRow = _schema$nodes2.tableRow;
  return mapSlice(slice, function (maybeTable) {
    if (maybeTable.type === table) {
      var firstRow = maybeTable.firstChild;
      if (firstRow) {
        var headerCols = [];
        firstRow.forEach(function (oldCol) {
          headerCols.push(tableHeader.createChecked(oldCol.attrs, oldCol.content, oldCol.marks));
        });
        var headerRow = tableRow.createChecked(firstRow.attrs, headerCols, firstRow.marks);
        return maybeTable.copy(maybeTable.content.replaceChild(0, headerRow));
      }
    }
    return maybeTable;
  });
};
export var transformSliceToRemoveColumnsWidths = function transformSliceToRemoveColumnsWidths(slice, schema) {
  var _schema$nodes3 = schema.nodes,
    tableHeader = _schema$nodes3.tableHeader,
    tableCell = _schema$nodes3.tableCell;
  return mapSlice(slice, function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      if (!maybeCell.attrs.colwidth) {
        return maybeCell;
      }
      return maybeCell.type.createChecked(_objectSpread(_objectSpread({}, maybeCell.attrs), {}, {
        colwidth: undefined
      }), maybeCell.content, maybeCell.marks);
    }
    return maybeCell;
  });
};
export var countCellsInSlice = function countCellsInSlice(slice, schema, type) {
  var _schema$nodes4 = schema.nodes,
    tableHeader = _schema$nodes4.tableHeader,
    tableCell = _schema$nodes4.tableCell;
  var count = 0;
  if (!type) {
    return count;
  }
  slice.content.descendants(function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      count += type === 'row' ? maybeCell.attrs.colspan : maybeCell.attrs.rowspan;
      return false;
    }
  });
  return count;
};
export var getTableSelectionType = function getTableSelectionType(selection) {
  if (selection instanceof CellSelection) {
    return selection.isRowSelection() ? 'row' : selection.isColSelection() ? 'column' : undefined;
  }
};
export var getTableElementMoveTypeBySlice = function getTableElementMoveTypeBySlice(slice, state) {
  var _state$schema$nodes = state.schema.nodes,
    tableRow = _state$schema$nodes.tableRow,
    table = _state$schema$nodes.table;
  var currentTable = findTable(state.tr.selection);

  // check if copied slice is a table or table row
  if (!slice.content.firstChild || slice.content.firstChild.type !== table && slice.content.firstChild.type !== tableRow || !currentTable) {
    return undefined;
  }

  // if the slice only contains one table row, assume it's a row
  if (slice.content.childCount === 1 && slice.content.firstChild.type === tableRow) {
    return 'row';
  }

  // `TableMap.get` can throw if the content is invalid - in which case we should just
  // return undefined
  try {
    var map = TableMap.get(currentTable.node);
    var slicedMap = TableMap.get(slice.content.firstChild);
    return map.width === slicedMap.width ? 'row' : map.height === slicedMap.height ? 'column' : undefined;
  } catch (e) {
    return undefined;
  }
};
export var isInsideFirstCellOfRowOrColumn = function isInsideFirstCellOfRowOrColumn(selection, type) {
  var table = findTable(selection);
  if (!table || !type) {
    return false;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var map = TableMap.get(table.node);
  var cell = findCellClosestToPos(selection.$anchor);
  if (!cell) {
    return false;
  }
  var pos = cell.pos - table.pos - 1;
  // cell positions in table map always start at 1, as they're offsets not positions
  var index = map.map.findIndex(function (value) {
    return value === pos;
  });
  return type === 'row' ? index % map.width === 0 : index < map.width;
};
export var deleteTable = function deleteTable(state, dispatch) {
  if (dispatch) {
    dispatch(removeTable(state.tr));
  }
  return true;
};
export var deleteTableIfSelected = function deleteTableIfSelected(state, dispatch) {
  if (isTableSelected(state.selection)) {
    return deleteTable(state, dispatch);
  }
  return false;
};
export var convertFirstRowToHeader = function convertFirstRowToHeader(schema) {
  return function (tr) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var table = findTable(tr.selection);
    var map = TableMap.get(table.node);
    for (var i = 0; i < map.width; i++) {
      var cell = table.node.child(0).child(i);
      tr.setNodeMarkup(table.start + map.map[i], schema.nodes.tableHeader, cell.attrs);
    }
    return tr;
  };
};
export var moveCursorBackward = function moveCursorBackward(state, dispatch) {
  var _ref = state.selection,
    $cursor = _ref.$cursor;
  // if cursor is in the middle of a text node, do nothing
  if (!$cursor || $cursor.parentOffset > 0) {
    return false;
  }

  // find the node before the cursor
  var before;
  var cut;
  if (!isIsolating($cursor.parent)) {
    for (var i = $cursor.depth - 1; !before && i >= 0; i--) {
      if ($cursor.index(i) > 0) {
        cut = $cursor.before(i + 1);
        before = $cursor.node(i).child($cursor.index(i) - 1);
      }
      if (isIsolating($cursor.node(i))) {
        break;
      }
    }
  }

  // if the node before is not a table node - do nothing
  if (!before || before.type !== state.schema.nodes.table) {
    return false;
  }

  /*
     ensure we're just at a top level paragraph
     otherwise, perform regular backspace behaviour
    */
  var grandparent = $cursor.node($cursor.depth - 1);
  if ($cursor.parent.type !== state.schema.nodes.paragraph || grandparent && grandparent.type !== state.schema.nodes.doc) {
    return false;
  }
  var tr = state.tr;
  var lastCellPos = (cut || 0) - 4;
  // need to move cursor inside the table to be able to calculate table's offset
  tr.setSelection(new TextSelection(state.doc.resolve(lastCellPos)));
  var $from = tr.selection.$from;
  var start = $from.start(-1);
  var pos = start + $from.parent.nodeSize - 1;

  // move cursor to the last cell
  // it doesn't join node before (last cell) with node after (content after the cursor)
  // due to ridiculous amount of PM code that would have been required to overwrite
  tr.setSelection(new TextSelection(state.doc.resolve(pos)));

  // if we are inside an empty paragraph not at the end of the doc we delete it
  var cursorNode = $cursor.node();
  var docEnd = state.doc.content.size;
  var paragraphWrapStart = $cursor.pos - 1;
  var paragraphWrapEnd = $cursor.pos + 1;
  if (cursorNode.content.size === 0 && $cursor.pos + 1 !== docEnd) {
    tr.delete(paragraphWrapStart, paragraphWrapEnd);
  }
  if (dispatch) {
    dispatch(tr);
  }
  return true;
};
export var setMultipleCellAttrs = function setMultipleCellAttrs(attrs, editorView) {
  return function (state, dispatch) {
    var cursorPos;
    var tr = state.tr;
    var _getPluginState2 = getPluginState(state),
      targetCellPosition = _getPluginState2.targetCellPosition;
    if (isSelectionType(tr.selection, 'cell')) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var selection = tr.selection;
      selection.forEachCell(function (_cell, pos) {
        var $pos = tr.doc.resolve(tr.mapping.map(pos + 1));
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        tr = setCellAttrs(findCellClosestToPos($pos), attrs)(tr);
      });
      cursorPos = selection.$headCell.pos;
    } else if (targetCellPosition) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var cell = findCellClosestToPos(tr.doc.resolve(targetCellPosition + 1));
      tr = setCellAttrs(cell, attrs)(tr);
      cursorPos = cell.pos;
    }
    if (tr.docChanged && cursorPos !== undefined) {
      if (dispatch) {
        if (cursorPos !== undefined) {
          editorView === null || editorView === void 0 || editorView.focus();
          tr.setSelection(new TextSelection(tr.doc.resolve(cursorPos)));
        }
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
export var selectColumn = function selectColumn(column, expand) {
  var triggeredByKeyboard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return createCommand(function (state) {
    var cells = getCellsInColumn(column)(state.tr.selection);
    if (!cells || !cells.length || typeof cells[0].pos !== 'number') {
      return false;
    }
    var decorations = createColumnSelectedDecoration(selectColumnTransform(column, expand)(state.tr));
    var decorationSet = updatePluginStateDecorations(state, decorations, TableDecorations.COLUMN_SELECTED);
    var targetCellPosition = cells[0].pos;
    return {
      type: 'SELECT_COLUMN',
      data: {
        targetCellPosition: targetCellPosition,
        decorationSet: decorationSet
      }
    };
  }, function (tr) {
    return selectColumnTransform(column, expand)(tr).setMeta('addToHistory', false).setMeta('selectedColumnViaKeyboard', triggeredByKeyboard);
  });
};
export var selectColumns = function selectColumns(columnIndexes) {
  return createCommand(function (state) {
    if (!columnIndexes) {
      return false;
    }
    var cells = columnIndexes.map(function (column) {
      return getCellsInColumn(column)(state.tr.selection);
    }).flat();
    if (!cells || !cells.length || cells.some(function (cell) {
      return cell && typeof cell.pos !== 'number';
    })) {
      return false;
    }
    var decorations = createColumnSelectedDecoration(selectColumnsTransform(columnIndexes)(state.tr));
    var decorationSet = updatePluginStateDecorations(state, decorations, TableDecorations.COLUMN_SELECTED);
    var cellsInFirstColumn = getCellsInColumn(Math.min.apply(Math, _toConsumableArray(columnIndexes)))(state.tr.selection);
    if (!cellsInFirstColumn || cellsInFirstColumn.length === 0) {
      return false;
    }
    var targetCellPosition = cellsInFirstColumn[0].pos;
    return {
      type: 'SELECT_COLUMN',
      data: {
        targetCellPosition: targetCellPosition,
        decorationSet: decorationSet
      }
    };
  }, function (tr) {
    return selectColumnsTransform(columnIndexes)(tr).setMeta('addToHistory', false);
  });
};
export var selectRow = function selectRow(row, expand) {
  var triggeredByKeyboard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return createCommand(function (state) {
    var targetCellPosition;
    var cells = getCellsInRow(row)(state.tr.selection);
    if (cells && cells.length) {
      targetCellPosition = cells[0].pos;
    }
    return {
      type: 'SET_TARGET_CELL_POSITION',
      data: {
        targetCellPosition: targetCellPosition
      }
    };
  }, function (tr) {
    return selectRowTransform(row, expand)(tr).setMeta('addToHistory', false).setMeta('selectedRowViaKeyboard', triggeredByKeyboard);
  });
};
export var selectRows = function selectRows(rowIndexes) {
  return createCommand(function (state) {
    if (rowIndexes.length === 0) {
      return false;
    }
    var cells = rowIndexes.map(function (row) {
      return getCellsInRow(row)(state.tr.selection);
    }).flat();
    if (!cells || !cells.length || cells.some(function (cell) {
      return cell && typeof cell.pos !== 'number';
    })) {
      return false;
    }
    var cellsInFirstRow = getCellsInRow(Math.min.apply(Math, _toConsumableArray(rowIndexes)))(state.tr.selection);
    if (!cellsInFirstRow || cellsInFirstRow.length === 0) {
      return false;
    }
    var targetCellPosition = cellsInFirstRow[0].pos;
    return {
      type: 'SET_TARGET_CELL_POSITION',
      data: {
        targetCellPosition: targetCellPosition
      }
    };
  }, function (tr) {
    return selectRowsTransform(rowIndexes)(tr).setMeta('addToHistory', false);
  });
};
export var showInsertColumnButton = function showInsertColumnButton(columnIndex) {
  return createCommand(function (_) {
    return columnIndex > -1 ? {
      type: 'SHOW_INSERT_COLUMN_BUTTON',
      data: {
        insertColumnButtonIndex: columnIndex
      }
    } : false;
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var showInsertRowButton = function showInsertRowButton(rowIndex) {
  return createCommand(function (_) {
    return rowIndex > -1 ? {
      type: 'SHOW_INSERT_ROW_BUTTON',
      data: {
        insertRowButtonIndex: rowIndex
      }
    } : false;
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var hideInsertColumnOrRowButton = function hideInsertColumnOrRowButton() {
  return createCommand({
    type: 'HIDE_INSERT_COLUMN_OR_ROW_BUTTON'
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var addResizeHandleDecorations = function addResizeHandleDecorations(rowIndex, columnIndex, includeTooltip, nodeViewPortalProviderAPI, isKeyboardResize) {
  return createCommand(function (state) {
    var tableNode = findTable(state.selection);
    var _getPluginState3 = getPluginState(state),
      allowColumnResizing = _getPluginState3.pluginConfig.allowColumnResizing,
      getIntl = _getPluginState3.getIntl;
    if (!tableNode || !allowColumnResizing) {
      return false;
    }
    return {
      type: 'ADD_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: buildColumnResizingDecorations(rowIndex, columnIndex, includeTooltip, getIntl, nodeViewPortalProviderAPI)({
          tr: state.tr,
          decorationSet: getDecorations(state)
        }),
        resizeHandleRowIndex: rowIndex,
        resizeHandleColumnIndex: columnIndex,
        resizeHandleIncludeTooltip: includeTooltip,
        isKeyboardResize: isKeyboardResize || false
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var updateResizeHandleDecorations = function updateResizeHandleDecorations(nodeViewPortalProviderAPI, rowIndex, columnIndex, includeTooltip) {
  return createCommand(function (state) {
    var tableNode = findTable(state.selection);
    var _getPluginState4 = getPluginState(state),
      resizeHandleRowIndex = _getPluginState4.resizeHandleRowIndex,
      resizeHandleColumnIndex = _getPluginState4.resizeHandleColumnIndex,
      resizeHandleIncludeTooltip = _getPluginState4.resizeHandleIncludeTooltip,
      allowColumnResizing = _getPluginState4.pluginConfig.allowColumnResizing,
      getIntl = _getPluginState4.getIntl;
    if (!tableNode || !allowColumnResizing) {
      return false;
    }
    var resolvedRowIndex = rowIndex !== null && rowIndex !== void 0 ? rowIndex : resizeHandleRowIndex;
    var resolvedColumnIndex = columnIndex !== null && columnIndex !== void 0 ? columnIndex : resizeHandleColumnIndex;
    var resolvedIncludeTooltip = includeTooltip !== null && includeTooltip !== void 0 ? includeTooltip : resizeHandleIncludeTooltip;
    if (resolvedRowIndex === undefined || resolvedColumnIndex === undefined || resolvedIncludeTooltip === undefined) {
      return false;
    }
    return {
      type: 'UPDATE_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: buildColumnResizingDecorations(resolvedRowIndex, resolvedColumnIndex, resolvedIncludeTooltip, getIntl, nodeViewPortalProviderAPI)({
          tr: state.tr,
          decorationSet: getDecorations(state)
        }),
        resizeHandleRowIndex: rowIndex,
        resizeHandleColumnIndex: columnIndex,
        resizeHandleIncludeTooltip: includeTooltip
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var removeResizeHandleDecorations = function removeResizeHandleDecorations() {
  return createCommand(function (state) {
    return {
      type: 'REMOVE_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: clearColumnResizingDecorations()({
          tr: state.tr,
          decorationSet: getDecorations(state)
        })
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
export var autoSizeTable = function autoSizeTable(view, node, table, basePos, opts) {
  if (typeof basePos !== 'number') {
    return false;
  }
  view.dispatch(fixAutoSizedTable(view, node, table, basePos, opts));
  return true;
};
export var addBoldInEmptyHeaderCells = function addBoldInEmptyHeaderCells(tableCellHeader) {
  return function (state, dispatch) {
    var tr = state.tr;
    if (
    // Avoid infinite loop when the current selection is not a TextSelection
    isTextSelection(tr.selection) && tr.selection.$cursor &&
    // When storedMark is null that means this is the initial state
    // if the user press to remove the mark storedMark will be an empty array
    // and we shouldn't apply the strong mark
    tr.storedMarks == null &&
    // Check if the current node is a direct child from paragraph
    tr.selection.$from.depth === tableCellHeader.depth + 1 &&
    // this logic is applied only for empty paragraph
    tableCellHeader.node.nodeSize === 4 && isParagraph(tableCellHeader.node.firstChild, state.schema)) {
      var strong = state.schema.marks.strong;
      tr.setStoredMarks([strong.create()]).setMeta('addToHistory', false);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
export var updateWidthToWidest = function updateWidthToWidest(widthToWidest) {
  return createCommand(function (state) {
    var _getPluginState5 = getPluginState(state),
      prevWidthToWidest = _getPluginState5.widthToWidest;
    if (isEqual(widthToWidest, prevWidthToWidest)) {
      return false;
    }
    return {
      type: 'UPDATE_TABLE_WIDTH_TO_WIDEST',
      data: {
        widthToWidest: _objectSpread(_objectSpread({}, prevWidthToWidest), widthToWidest)
      }
    };
  });
};
export var setTableAlignment = function setTableAlignment(newAlignment, isCommentEditor) {
  return function (_ref2) {
    var tr = _ref2.tr;
    var tableObject = findTable(tr.selection);
    if (!tableObject) {
      return null;
    }
    var nextTableAttrs = _objectSpread(_objectSpread({}, tableObject.node.attrs), {}, {
      layout: newAlignment
    });

    // table uses old breakout values in layout attribute to determine width
    // but that information is lost when alignment changes, so we need to ensure we retain that info
    // If table width is not set in the Comment editor, it means that the table width is inherited from the editor and is "full width".
    // In that case when switching between alignment options in the Comment editor we should keep the table width unset.
    if (!tableObject.node.attrs.width && !isCommentEditor) {
      var tableWidth = getTableContainerWidth(tableObject.node);
      nextTableAttrs.width = tableWidth;
    }
    tr.setNodeMarkup(tableObject.pos, undefined, nextTableAttrs).setMeta('scrollIntoView', false);
    return tr;
  };
};
export var setTableAlignmentWithTableContentWithPos = function setTableAlignmentWithTableContentWithPos(newAlignment, tableNodeWithPos) {
  return function (_ref3) {
    var tr = _ref3.tr;
    var table = tableNodeWithPos.node;
    var nextTableAttrs = _objectSpread(_objectSpread({}, table.attrs), {}, {
      layout: newAlignment
    });

    // table uses old breakout values in layout attribute to determine width
    // but that information is lost when alignment changes, so we need to ensure we retain that info
    if (!table.attrs.width) {
      var tableWidth = getTableContainerWidth(table);
      nextTableAttrs.width = tableWidth;
    }
    tr.setNodeMarkup(tableNodeWithPos.pos, undefined, nextTableAttrs).setMeta('scrollIntoView', false);
    return tr;
  };
};
export var setFocusToCellMenu = function setFocusToCellMenu() {
  var isCellMenuOpenByKeyboard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var originalTr = arguments.length > 1 ? arguments[1] : undefined;
  return createCommand(function () {
    return {
      type: 'SET_CELL_MENU_OPEN',
      data: {
        isCellMenuOpenByKeyboard: isCellMenuOpenByKeyboard
      }
    };
  }, function (tr) {
    return (originalTr || tr).setMeta('addToHistory', false);
  });
};