"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDraggableDataFromEvent = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _closestEdge = require("@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge");
var _getDragBehaviour = require("./getDragBehaviour");
var getDraggableDataFromEvent = exports.getDraggableDataFromEvent = function getDraggableDataFromEvent(_ref) {
  var _extractClosestEdge;
  var location = _ref.location,
    source = _ref.source;
  var destination = location.current.dropTargets.at(0);
  // If no target exists at the current location, then the current draggable is not over a target or the target doesn't support
  // the current draggable.
  if (!destination) {
    return undefined;
  }

  // This is the draggable elements data
  var _ref2 = source.data,
    sourceIndexes = _ref2.indexes,
    sourceType = _ref2.type,
    sourceLocalId = _ref2.localId;

  // This is the drop target's data
  var _ref3 = destination.data,
    targetIndex = _ref3.targetIndex,
    targetType = _ref3.type,
    targetLocalId = _ref3.localId;

  // Some basic check to abort early with...
  if (!sourceIndexes || targetIndex < 0 ||
  // abort if the type of the draggable is different to the target, for eg. rows cannot be dropped onto column targets.
  sourceType !== targetType ||
  // abort if the draggable is coming from a different table that the target is on.
  sourceLocalId !== targetLocalId) {
    return undefined;
  }
  var targetClosestEdge = (_extractClosestEdge = (0, _closestEdge.extractClosestEdge)(destination.data)) !== null && _extractClosestEdge !== void 0 ? _extractClosestEdge : targetType === 'table-row' ? 'top' : 'left';
  // NOTE: By default we always insert row/cols at the target index to the top/left (retrospectively of row/cols).
  // This introduces an offset in the event the drop occured closer to the bottom/right of the target. We want
  // the new target index to be 1 index higher.
  var targetOffset = targetClosestEdge === 'right' || targetClosestEdge === 'bottom' ? 1 : 0;

  // if the min index is greater then the target index, the then the direction of the DnD is decreasing
  // if the target is within the min/max index then we can assume that no direction exists so it will be 0.
  var srcMin = Math.min.apply(Math, (0, _toConsumableArray2.default)(sourceIndexes));
  var srcMax = Math.max.apply(Math, (0, _toConsumableArray2.default)(sourceIndexes));
  var direction = targetIndex >= srcMin && targetIndex <= srcMax ? 0 : srcMin >= targetIndex ? -1 : 1;
  return {
    sourceType: sourceType,
    sourceLocalId: sourceLocalId,
    sourceIndexes: sourceIndexes,
    targetType: targetType,
    targetLocalId: targetLocalId,
    targetIndex: targetIndex,
    targetAdjustedIndex: targetIndex + targetOffset,
    targetClosestEdge: targetClosestEdge,
    targetDirection: targetClosestEdge === 'top' || targetClosestEdge === 'left' ? 'start' : 'end',
    direction: direction,
    behaviour: (0, _getDragBehaviour.getDragBehaviour)(location.current.input)
  };
};