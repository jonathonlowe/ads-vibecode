"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleDocOrSelectionChanged = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _customSteps = require("@atlaskit/custom-steps");
var _utils = require("@atlaskit/editor-common/utils");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _utils3 = require("@atlaskit/editor-tables/utils");
var _defaultTableSelection = require("./default-table-selection");
var _pluginKey = require("./table-resizing/plugin-key");
var _collapse = require("./utils/collapse");
var _nodes = require("./utils/nodes");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // #region Imports
// @ts-ignore -- ReadonlyTransaction is a local declaration and will cause a TS2305 error in CCFE typecheck
var nextTableSorting = function nextTableSorting(tr, table) {
  var tableSortStep = tr.steps.find(function (step) {
    return step instanceof _customSteps.TableSortStep;
  });
  return tableSortStep && table && table.pos === tableSortStep.pos ? tableSortStep.next : undefined;
};
var nextResizeHandleColumnIndex = function nextResizeHandleColumnIndex(tr, resizeHandleColumnIndex) {
  if (tr.getMeta(_pluginKey.pluginKey)) {
    return undefined;
  }
  return resizeHandleColumnIndex;
};
var updateTargetCellPosition = function updateTargetCellPosition(_ref) {
  var tr = _ref.tr,
    table = _ref.table;
  return function (pluginState) {
    var tableNode = table && table.node;
    if (!tableNode) {
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        targetCellPosition: undefined
      });
    }
    var _tr$doc$type$schema$n = tr.doc.type.schema.nodes,
      tableCell = _tr$doc$type$schema$n.tableCell,
      tableHeader = _tr$doc$type$schema$n.tableHeader;
    var cell = (0, _utils2.findParentNodeOfType)([tableCell, tableHeader])(tr.selection);
    var targetCellPosition = cell ? cell.pos : undefined;
    if (pluginState.targetCellPosition === targetCellPosition) {
      return pluginState;
    }
    return _objectSpread(_objectSpread({}, pluginState), {}, {
      targetCellPosition: targetCellPosition
    });
  };
};
var updateTableNodePluginState = function updateTableNodePluginState(_ref2) {
  var tr = _ref2.tr,
    table = _ref2.table;
  return function (pluginState) {
    var tableNode = table && table.node;
    if (!tableNode || (0, _utils.isTextInput)(tr)) {
      return pluginState;
    }
    return _objectSpread(_objectSpread(_objectSpread({}, pluginState), _defaultTableSelection.defaultTableSelection), {}, {
      tableNode: tableNode,
      ordering: nextTableSorting(tr, table),
      resizeHandleColumnIndex: nextResizeHandleColumnIndex(tr, pluginState.resizeHandleColumnIndex),
      isNumberColumnEnabled: (0, _nodes.checkIfNumberColumnEnabled)(tr.selection),
      isHeaderColumnEnabled: (0, _nodes.checkIfHeaderColumnEnabled)(tr.selection),
      isHeaderRowEnabled: (0, _nodes.checkIfHeaderRowEnabled)(tr.selection)
    });
  };
};
var updateCollapseHandler = function updateCollapseHandler(_ref3) {
  var tr = _ref3.tr,
    table = _ref3.table;
  return function (pluginState) {
    var tableNode = table && table.node;
    var schema = tr.doc.type.schema;
    var allowCollapse = pluginState.pluginConfig.allowCollapse;
    var isExpandInSchema = schema.nodes.expand !== undefined;
    var isCollapseEnabled = allowCollapse && isExpandInSchema;

    /**
     * If we don't have focus, or collapse isn't allowed, or a table node doesn't
     * exist, we don't need to waste extra checks below
     */
    if (!pluginState.editorHasFocus || !isCollapseEnabled || !tableNode) {
      return pluginState;
    }
    var expandNodeType = schema.nodes.expand;
    var isTableCollapsed = expandNodeType && !!(0, _utils2.findParentNodeOfType)(expandNodeType)(tr.selection);
    var trCanBeCollapsed = (0, _collapse.isTableCollapsible)(tr).tableIsCollapsible;

    // We're focused on a table + we're not inside an expand
    var canCollapseTable = !!pluginState.tableNode &&
    // is it already collapsed?
    !isTableCollapsed && !!trCanBeCollapsed;
    if (pluginState.isTableCollapsed !== isTableCollapsed || pluginState.canCollapseTable !== canCollapseTable) {
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        isTableCollapsed: isTableCollapsed,
        canCollapseTable: canCollapseTable
      });
    }
    return pluginState;
  };
};
var buildPluginState = function buildPluginState(builders) {
  return function (props) {
    return function (pluginState) {
      if (!props.table) {
        return pluginState.targetCellPosition ? _objectSpread(_objectSpread({}, pluginState), {}, {
          targetCellPosition: undefined
        }) : pluginState;
      }
      return builders.reduce(function (_pluginState, transform) {
        return transform(props)(_pluginState);
      }, pluginState);
    };
  };
};
var handleDocOrSelectionChanged = exports.handleDocOrSelectionChanged = function handleDocOrSelectionChanged(tr, pluginState) {
  return buildPluginState([updateTargetCellPosition, updateTableNodePluginState, updateCollapseHandler])({
    tr: tr,
    table: (0, _utils3.findTable)(tr.selection)
  })(pluginState);
};