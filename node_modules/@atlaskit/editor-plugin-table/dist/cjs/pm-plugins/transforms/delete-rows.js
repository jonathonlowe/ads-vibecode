"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteRows = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _utils = require("@atlaskit/editor-tables/utils");
var _merge = require("./merge");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var deleteRows = exports.deleteRows = function deleteRows(rect) {
  var isHeaderRowRequired = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function (tr) {
    var table = (0, _utils.findTable)(tr.selection);
    if (!table) {
      return tr;
    }
    var rowsToDelete = [];
    var map = _tableMap.TableMap.get(table.node);
    for (var i = rect.top; i < rect.bottom; i++) {
      // skip header row if its required
      if (isHeaderRowRequired) {
        var cell = table.node.nodeAt(map.map[i * map.width]);
        if (cell && cell.type !== cell.type.schema.nodes.tableHeader) {
          rowsToDelete.push(i);
        }
      } else {
        rowsToDelete.push(i);
      }
    }
    if (!rowsToDelete.length) {
      return tr;
    }
    var rows = [];
    var seen = {};
    var deletedCells = {};
    var _loop = function _loop(rowIndex) {
      var rowCells = [];
      var row = table.node.child(rowIndex);
      var _loop2 = function _loop2() {
          var cellPos = map.map[rowIndex * map.width + colIndex];
          var cell = table.node.nodeAt(cellPos);
          if (!cell) {
            return 0; // continue
          }
          var cellsInRow = map.cellsInRect({
            left: 0,
            top: rowIndex,
            right: map.width,
            bottom: rowIndex + 1
          });
          if (rowsToDelete.indexOf(rowIndex) === -1 && !seen[cellPos]) {
            // decrement rowspans for row-spanning cells that overlap deleted rows
            if (cellsInRow.indexOf(cellPos) > -1) {
              var overlappingRows = 0;
              rowsToDelete.forEach(function (rowIndexToDelete) {
                if (rowIndex < rowIndexToDelete && cell.attrs.rowspan + rowIndex - 1 >= rowIndexToDelete) {
                  overlappingRows += 1;
                }
              });
              if (overlappingRows > 0) {
                var newCell = cell.type.createChecked(_objectSpread(_objectSpread({}, cell.attrs), {}, {
                  rowspan: cell.attrs.rowspan - overlappingRows
                }), cell.content, cell.marks);
                rowCells.push(newCell);
                seen[cellPos] = true;
                return 0; // continue
              }
            } else if (deletedCells[cellPos]) {
              // if we're removing a row-spanning cell, we need to add missing cells to rows below
              var attrs = _objectSpread(_objectSpread({}, cell.attrs), {}, {
                colspan: 1,
                rowspan: 1
              });
              if (cell.attrs.colwidth) {
                var pos = colIndex > 0 ? colIndex - map.colCount(cellPos) : 0;
                attrs.colwidth = cell.attrs.colwidth.slice().splice(pos, 1);
              }
              var _newCell = cell.type.createChecked(attrs, cell.type.schema.nodes.paragraph.createChecked(), cell.marks);
              rowCells.push(_newCell);
              return 0; // continue
            }

            // normal cells that we want to keep
            if (!seen[cellPos]) {
              seen[cellPos] = true;
              rowCells.push(cell);
            }
          } else if (cellsInRow.indexOf(cellPos) > -1) {
            deletedCells[cellPos] = true;
          }
        },
        _ret;
      for (var colIndex = 0; colIndex < map.width; colIndex++) {
        _ret = _loop2();
        if (_ret === 0) continue;
      }
      if (rowCells.length) {
        rows.push(row.type.createChecked(row.attrs, rowCells, row.marks));
      }
    };
    for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
      _loop(rowIndex);
    }
    if (!rows.length) {
      return tr;
    }
    var newTable = table.node.type.createChecked(table.node.attrs, rows, table.node.marks);
    var fixedTable = (0, _merge.mergeEmptyColumns)(newTable);
    if (fixedTable === null) {
      return tr;
    }
    var cursorPos = getNextCursorPos(newTable, rowsToDelete);
    return tr.replaceWith(table.pos, table.pos + table.node.nodeSize, fixedTable)
    // move cursor before the deleted rows if possible, otherwise - to the first row
    .setSelection(_state.Selection.near(tr.doc.resolve(table.pos + cursorPos)));
  };
};
function getNextCursorPos(table, deletedRows) {
  var minRow = Math.min.apply(Math, (0, _toConsumableArray2.default)(deletedRows));
  var nextRowWithCursor = minRow > 0 ? minRow - 1 : 0;
  var map = _tableMap.TableMap.get(table);
  return map.map[nextRowWithCursor * map.width];
}