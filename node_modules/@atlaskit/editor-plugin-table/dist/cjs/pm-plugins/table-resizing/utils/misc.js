"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentColWidth = currentColWidth;
exports.getLayoutSize = getLayoutSize;
exports.getTableScalingPercent = exports.getTableMaxWidth = exports.getTableElementWidth = exports.getTableContainerElementWidth = exports.getStaticTableScalingPercent = exports.getScalingPercentForTableWithoutWidth = void 0;
exports.pointsAtCell = pointsAtCell;
var _nodeWidth = require("@atlaskit/editor-common/node-width");
var _styles = require("@atlaskit/editor-common/styles");
var _utils = require("@atlaskit/editor-common/utils");
var _editorSharedStyles = require("@atlaskit/editor-shared-styles");
var _colgroup = require("./colgroup");
var _consts = require("./consts");
// Translates named layouts in number values.
function getLayoutSize(tableLayout) {
  var containerWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var isFullWidthModeEnabled = options.isFullWidthModeEnabled;
  if (isFullWidthModeEnabled) {
    return containerWidth ? Math.min(containerWidth - (0, _editorSharedStyles.akEditorGutterPaddingDynamic)() * 2, _editorSharedStyles.akEditorFullWidthLayoutWidth) : _editorSharedStyles.akEditorFullWidthLayoutWidth;
  }
  var calculatedTableWidth = (0, _styles.calcTableWidth)(tableLayout, containerWidth, true);
  if (calculatedTableWidth !== 'inherit') {
    return calculatedTableWidth;
  }
  return _nodeWidth.layoutToWidth[tableLayout] || containerWidth;
}

// Does the current position point at a cell.
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter;
}

// Get the current col width, handles colspan.
function currentColWidth(view, cellPos, _ref) {
  var colspan = _ref.colspan,
    colwidth = _ref.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) {
    return width;
  }
  // Not fixed, read current width from DOM
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var domWidth = view.domAtPos(cellPos + 1).node.offsetWidth;
  var parts = colspan || 0;
  if (colwidth) {
    for (var i = 0; i < (colspan || 0); i++) {
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
    }
  }
  return domWidth / parts;
}
var getTableMaxWidth = exports.getTableMaxWidth = function getTableMaxWidth(_ref2) {
  var table = _ref2.table,
    tableStart = _ref2.tableStart,
    state = _ref2.state,
    layout = _ref2.layout,
    getEditorContainerWidth = _ref2.getEditorContainerWidth;
  var containerWidth = getEditorContainerWidth();
  var parentWidth = (0, _nodeWidth.getParentNodeWidth)(tableStart, state, containerWidth);
  var maxWidth = parentWidth || table.attrs.width || getLayoutSize(layout, containerWidth.width, {});
  if (table.attrs.isNumberColumnEnabled) {
    maxWidth -= _editorSharedStyles.akEditorTableNumberColumnWidth;
  }
  return maxWidth;
};

/**
 *
 * @param table
 * @returns calculated width of <table /> element derived from sum of colwidths on tableCell or tableHeader nodes or falls back to container width
 */
var getTableElementWidth = exports.getTableElementWidth = function getTableElementWidth(table) {
  if ((0, _colgroup.hasTableBeenResized)(table)) {
    // TODO: ED-26961 - is there a scenario where ADF columns are SMALLER than container width?
    return (0, _utils.calcTableColumnWidths)(table).reduce(function (sum, width) {
      return sum + width;
    }, 0);
  }
  return getTableContainerElementWidth(table);
};
var getTableContainerElementWidth = exports.getTableContainerElementWidth = function getTableContainerElementWidth(table) {
  return (0, _nodeWidth.getTableContainerWidth)(table);
};
var getTableScalingPercent = exports.getTableScalingPercent = function getTableScalingPercent(table, tableRef, shouldUseIncreasedScalingPercent) {
  var _tableRef$parentEleme;
  var maxScalingPercent = shouldUseIncreasedScalingPercent ? _consts.MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION : _consts.MAX_SCALING_PERCENT;
  var tableWidth = getTableContainerElementWidth(table);
  var renderWidth = (tableRef === null || tableRef === void 0 || (_tableRef$parentEleme = tableRef.parentElement) === null || _tableRef$parentEleme === void 0 ? void 0 : _tableRef$parentEleme.clientWidth) || tableWidth;
  // minus 1 here to avoid any 1px scroll in Firefox
  var scalePercent = (renderWidth - 1) / tableWidth;
  scalePercent = Math.max(scalePercent, 1 - maxScalingPercent);
  return Math.min(scalePercent, 1);
};

// This function is used to default and full-width tables in Comment/Chromeless editors
// These tables don't have node.attrs.width set. Their pm-table-wrapper width depend on the editor container width.
// actual table node width can be calculated as sum of colwidth values if table's columns were resized.
// If colwidth are not set, table columns are not resized, they all are equal widths.
var getScalingPercentForTableWithoutWidth = exports.getScalingPercentForTableWithoutWidth = function getScalingPercentForTableWithoutWidth(table, tableRef) {
  // are table columns resized
  if ((0, _colgroup.hasTableColumnBeenResized)(table)) {
    var _tableRef$parentEleme2;
    var tableWidth = (0, _utils.calcTableColumnWidths)(table).reduce(function (sum, width) {
      return sum + width;
    }, 0);
    var renderWidth = (tableRef === null || tableRef === void 0 || (_tableRef$parentEleme2 = tableRef.parentElement) === null || _tableRef$parentEleme2 === void 0 ? void 0 : _tableRef$parentEleme2.clientWidth) || tableWidth;

    // minus 1 here to avoid any 1px scroll in Firefox
    return (renderWidth - 1) / tableWidth;
  }

  // When table cols are not resized and table width is not set,
  // tableWidth is equal to renderWidth
  return 1;
};
var getStaticTableScalingPercent = exports.getStaticTableScalingPercent = function getStaticTableScalingPercent(table, tableRenderWidth, shouldUseIncreasedScalingPercent) {
  var maxScalingPercent = shouldUseIncreasedScalingPercent ? _consts.MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION : _consts.MAX_SCALING_PERCENT;
  var tableWidth = getTableContainerElementWidth(table);
  // minus 1 here to avoid any 1px scroll in Firefox
  var scalePercent = (tableRenderWidth - 1) / tableWidth;
  scalePercent = Math.max(scalePercent, 1 - maxScalingPercent);
  return Math.min(scalePercent, 1);
};