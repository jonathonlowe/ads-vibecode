"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFreeSpace = exports.getColumnStateFromDOM = exports.getCellsRefsInColumn = exports.calculateColumnWidth = exports.addContainerLeftRightPadding = void 0;
var _styles = require("@atlaskit/editor-common/styles");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _contentWidth2 = require("./content-width");
var _unitToNumber = require("./unit-to-number");
// Reads `width` and `minWidth` of each column from DOM and returns `ColumnState` containing those values
var getColumnStateFromDOM = exports.getColumnStateFromDOM = function getColumnStateFromDOM(cells, index, minWidth) {
  var width = calculateColumnWidth(cells, calculateColumnWidthCallback);
  var minColumnWidth = width < minWidth ?
  // for newly created column (where width < minWidth) we set minWidth = tableNewColumnMinWidth (140px atm)
  _styles.tableNewColumnMinWidth : calculateColumnWidth(cells, calculateColumnMinWidthCallback(minWidth));
  return {
    index: index,
    width: width < minWidth ? _styles.tableNewColumnMinWidth : width,
    minWidth: minColumnWidth
  };
};
var getFreeSpace = exports.getFreeSpace = function getFreeSpace(state) {
  return Math.max(state.width - state.minWidth, 0);
};

// Returns DOM refs of all cells in a column by `columnIndex`
var getCellsRefsInColumn = exports.getCellsRefsInColumn = function getCellsRefsInColumn(columnIndex, table, tableStart, domAtPos) {
  var map = _tableMap.TableMap.get(table);
  var cellsPositions = map.cellsInRect({
    left: columnIndex,
    right: columnIndex + 1,
    top: 0,
    bottom: map.height
  });
  var cells = [];
  cellsPositions.forEach(function (pos) {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    var col = (0, _utils.findDomRefAtPos)(pos + tableStart, domAtPos);
    if (col) {
      cells.push(col);
    }
  });
  return cells;
};

// calculates column widths based on `cells` DOM refs
var calculateColumnWidth = exports.calculateColumnWidth = function calculateColumnWidth(cells, calculateColumnWidthCb) {
  var maxColWidth = 0;
  var colSpanWidth = 0;
  cells.forEach(function (cellRef) {
    var css = getComputedStyle(cellRef);
    var colspan = Number(cellRef.getAttribute('colspan') || 1);
    if (colspan > 1) {
      colSpanWidth = calculateColumnWidthCb(css, cellRef, colspan);
      return;
    }
    if (css) {
      var colWidth = calculateColumnWidthCb(css, cellRef, colspan);
      maxColWidth = Math.max(colWidth, maxColWidth);
    }
  });
  return maxColWidth || colSpanWidth;
};
var addContainerLeftRightPadding = exports.addContainerLeftRightPadding = function addContainerLeftRightPadding(amount, css) {
  return amount + (0, _unitToNumber.unitToNumber)(css.paddingLeft) + (0, _unitToNumber.unitToNumber)(css.paddingRight);
};
function calculateColumnWidthCallback(css) {
  return (0, _unitToNumber.unitToNumber)(css.width);
}
function calculateColumnMinWidthCallback(minColumnWidth) {
  return function (css, cellRef, colSpan) {
    if (colSpan && colSpan > 1) {
      return (0, _unitToNumber.unitToNumber)(css.width);
    }
    var _contentWidth = (0, _contentWidth2.contentWidth)(cellRef, cellRef),
      minContentWidth = _contentWidth.minWidth;
    // Override the min width, if there is content that can't collapse
    // Past a certain width.
    return Math.max(addContainerLeftRightPadding(minContentWidth, css), minContentWidth, minColumnWidth);
  };
}