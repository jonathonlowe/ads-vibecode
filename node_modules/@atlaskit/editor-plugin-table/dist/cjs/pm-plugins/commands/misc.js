"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateWidthToWidest = exports.updateResizeHandleDecorations = exports.triggerUnlessTableHeader = exports.transformSliceToRemoveColumnsWidths = exports.transformSliceToAddTableHeaders = exports.transformSliceRemoveCellBackgroundColor = exports.showInsertRowButton = exports.showInsertColumnButton = exports.setTableRef = exports.setTableAlignmentWithTableContentWithPos = exports.setTableAlignment = exports.setMultipleCellAttrs = exports.setFocusToCellMenu = exports.setEditorFocus = exports.setCellAttr = exports.selectRows = exports.selectRow = exports.selectColumns = exports.selectColumn = exports.removeResizeHandleDecorations = exports.moveCursorBackward = exports.isInsideFirstCellOfRowOrColumn = exports.hideInsertColumnOrRowButton = exports.getTableSelectionType = exports.getTableElementMoveTypeBySlice = exports.deleteTableIfSelected = exports.deleteTable = exports.countCellsInSlice = exports.convertFirstRowToHeader = exports.autoSizeTable = exports.addResizeHandleDecorations = exports.addBoldInEmptyHeaderCells = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _isEqual = _interopRequireDefault(require("lodash/isEqual"));
var _nodeWidth = require("@atlaskit/editor-common/node-width");
var _utils = require("@atlaskit/editor-common/utils");
var _state = require("@atlaskit/editor-prosemirror/state");
var _cellSelection = require("@atlaskit/editor-tables/cell-selection");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _utils2 = require("@atlaskit/editor-tables/utils");
var _types = require("../../types");
var _plugin = require("../decorations/plugin");
var _columnResizing = require("../decorations/utils/column-resizing");
var _pluginFactory = require("../plugin-factory");
var _fixTables = require("../transforms/fix-tables");
var _decoration = require("../utils/decoration");
var _nodes = require("../utils/nodes");
var _updatePluginStateDecorations = require("../utils/update-plugin-state-decorations");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var setEditorFocus = exports.setEditorFocus = function setEditorFocus(editorHasFocus) {
  return (0, _pluginFactory.createCommand)({
    type: 'SET_EDITOR_FOCUS',
    data: {
      editorHasFocus: editorHasFocus
    }
  });
};
var setTableRef = exports.setTableRef = function setTableRef(ref) {
  return (0, _pluginFactory.createCommand)(function (state) {
    var tableRef = ref;
    var foundTable = (0, _utils2.findTable)(state.selection);
    var tableNode = ref && foundTable ? foundTable.node : undefined;
    var tablePos = ref && foundTable ? foundTable.pos : undefined;
    var tableWrapperTarget = (0, _utils.closestElement)(tableRef, ".".concat(_types.TableCssClassName.TABLE_NODE_WRAPPER)) || undefined;
    var _getPluginState = (0, _pluginFactory.getPluginState)(state),
      isDragAndDropEnabled = _getPluginState.isDragAndDropEnabled;
    return {
      type: 'SET_TABLE_REF',
      data: {
        tableRef: tableRef,
        tableNode: tableNode,
        tablePos: tablePos,
        tableWrapperTarget: tableWrapperTarget,
        isNumberColumnEnabled: (0, _nodes.checkIfNumberColumnEnabled)(state.selection),
        isHeaderRowEnabled: (0, _nodes.checkIfHeaderRowEnabled)(state.selection),
        isHeaderColumnEnabled: (0, _nodes.checkIfHeaderColumnEnabled)(state.selection),
        // decoration set is drawn by the decoration plugin, skip this for DnD as all controls are floating
        decorationSet: !isDragAndDropEnabled ? (0, _updatePluginStateDecorations.updatePluginStateDecorations)(state, (0, _decoration.createColumnControlsDecoration)(state.selection), _types.TableDecorations.COLUMN_CONTROLS_DECORATIONS) : undefined,
        resizeHandleRowIndex: undefined,
        resizeHandleColumnIndex: undefined
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var setCellAttr = exports.setCellAttr = function setCellAttr(name, value) {
  return function (state, dispatch) {
    var tr = state.tr,
      selection = state.selection;
    if (selection instanceof _cellSelection.CellSelection) {
      var updated = false;
      selection.forEachCell(function (cell, pos) {
        if (cell.attrs[name] !== value) {
          tr.setNodeMarkup(pos, cell.type, _objectSpread(_objectSpread({}, cell.attrs), {}, (0, _defineProperty2.default)({}, name, value)));
          updated = true;
        }
      });
      if (updated) {
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      }
    } else {
      var cell = (0, _utils2.selectionCell)(state.selection);
      if (cell) {
        if (dispatch) {
          var _cell$nodeAfter, _cell$nodeAfter2;
          dispatch(tr.setNodeMarkup(cell.pos, (_cell$nodeAfter = cell.nodeAfter) === null || _cell$nodeAfter === void 0 ? void 0 : _cell$nodeAfter.type, _objectSpread(_objectSpread({}, (_cell$nodeAfter2 = cell.nodeAfter) === null || _cell$nodeAfter2 === void 0 ? void 0 : _cell$nodeAfter2.attrs), {}, (0, _defineProperty2.default)({}, name, value))));
        }
        return true;
      }
    }
    return false;
  };
};
var triggerUnlessTableHeader = exports.triggerUnlessTableHeader = function triggerUnlessTableHeader(command) {
  return function (state, dispatch, view) {
    var selection = state.selection,
      tableHeader = state.schema.nodes.tableHeader;
    if (selection instanceof _state.TextSelection) {
      var cell = (0, _utils2.findCellClosestToPos)(selection.$from);
      if (cell && cell.node.type !== tableHeader) {
        return command(state, dispatch, view);
      }
    }
    if (selection instanceof _cellSelection.CellSelection) {
      var rect = (0, _utils2.getSelectionRect)(selection);
      if (!(0, _nodes.checkIfHeaderRowEnabled)(selection) || rect && rect.top > 0) {
        return command(state, dispatch, view);
      }
    }
    return false;
  };
};
var transformSliceRemoveCellBackgroundColor = exports.transformSliceRemoveCellBackgroundColor = function transformSliceRemoveCellBackgroundColor(slice, schema) {
  var _schema$nodes = schema.nodes,
    tableCell = _schema$nodes.tableCell,
    tableHeader = _schema$nodes.tableHeader;
  return (0, _utils.mapSlice)(slice, function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      var cellAttrs = _objectSpread({}, maybeCell.attrs);
      cellAttrs.background = undefined;
      return maybeCell.type.createChecked(cellAttrs, maybeCell.content, maybeCell.marks);
    }
    return maybeCell;
  });
};
var transformSliceToAddTableHeaders = exports.transformSliceToAddTableHeaders = function transformSliceToAddTableHeaders(slice, schema) {
  var _schema$nodes2 = schema.nodes,
    table = _schema$nodes2.table,
    tableHeader = _schema$nodes2.tableHeader,
    tableRow = _schema$nodes2.tableRow;
  return (0, _utils.mapSlice)(slice, function (maybeTable) {
    if (maybeTable.type === table) {
      var firstRow = maybeTable.firstChild;
      if (firstRow) {
        var headerCols = [];
        firstRow.forEach(function (oldCol) {
          headerCols.push(tableHeader.createChecked(oldCol.attrs, oldCol.content, oldCol.marks));
        });
        var headerRow = tableRow.createChecked(firstRow.attrs, headerCols, firstRow.marks);
        return maybeTable.copy(maybeTable.content.replaceChild(0, headerRow));
      }
    }
    return maybeTable;
  });
};
var transformSliceToRemoveColumnsWidths = exports.transformSliceToRemoveColumnsWidths = function transformSliceToRemoveColumnsWidths(slice, schema) {
  var _schema$nodes3 = schema.nodes,
    tableHeader = _schema$nodes3.tableHeader,
    tableCell = _schema$nodes3.tableCell;
  return (0, _utils.mapSlice)(slice, function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      if (!maybeCell.attrs.colwidth) {
        return maybeCell;
      }
      return maybeCell.type.createChecked(_objectSpread(_objectSpread({}, maybeCell.attrs), {}, {
        colwidth: undefined
      }), maybeCell.content, maybeCell.marks);
    }
    return maybeCell;
  });
};
var countCellsInSlice = exports.countCellsInSlice = function countCellsInSlice(slice, schema, type) {
  var _schema$nodes4 = schema.nodes,
    tableHeader = _schema$nodes4.tableHeader,
    tableCell = _schema$nodes4.tableCell;
  var count = 0;
  if (!type) {
    return count;
  }
  slice.content.descendants(function (maybeCell) {
    if (maybeCell.type === tableCell || maybeCell.type === tableHeader) {
      count += type === 'row' ? maybeCell.attrs.colspan : maybeCell.attrs.rowspan;
      return false;
    }
  });
  return count;
};
var getTableSelectionType = exports.getTableSelectionType = function getTableSelectionType(selection) {
  if (selection instanceof _cellSelection.CellSelection) {
    return selection.isRowSelection() ? 'row' : selection.isColSelection() ? 'column' : undefined;
  }
};
var getTableElementMoveTypeBySlice = exports.getTableElementMoveTypeBySlice = function getTableElementMoveTypeBySlice(slice, state) {
  var _state$schema$nodes = state.schema.nodes,
    tableRow = _state$schema$nodes.tableRow,
    table = _state$schema$nodes.table;
  var currentTable = (0, _utils2.findTable)(state.tr.selection);

  // check if copied slice is a table or table row
  if (!slice.content.firstChild || slice.content.firstChild.type !== table && slice.content.firstChild.type !== tableRow || !currentTable) {
    return undefined;
  }

  // if the slice only contains one table row, assume it's a row
  if (slice.content.childCount === 1 && slice.content.firstChild.type === tableRow) {
    return 'row';
  }

  // `TableMap.get` can throw if the content is invalid - in which case we should just
  // return undefined
  try {
    var map = _tableMap.TableMap.get(currentTable.node);
    var slicedMap = _tableMap.TableMap.get(slice.content.firstChild);
    return map.width === slicedMap.width ? 'row' : map.height === slicedMap.height ? 'column' : undefined;
  } catch (e) {
    return undefined;
  }
};
var isInsideFirstCellOfRowOrColumn = exports.isInsideFirstCellOfRowOrColumn = function isInsideFirstCellOfRowOrColumn(selection, type) {
  var table = (0, _utils2.findTable)(selection);
  if (!table || !type) {
    return false;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var map = _tableMap.TableMap.get(table.node);
  var cell = (0, _utils2.findCellClosestToPos)(selection.$anchor);
  if (!cell) {
    return false;
  }
  var pos = cell.pos - table.pos - 1;
  // cell positions in table map always start at 1, as they're offsets not positions
  var index = map.map.findIndex(function (value) {
    return value === pos;
  });
  return type === 'row' ? index % map.width === 0 : index < map.width;
};
var deleteTable = exports.deleteTable = function deleteTable(state, dispatch) {
  if (dispatch) {
    dispatch((0, _utils2.removeTable)(state.tr));
  }
  return true;
};
var deleteTableIfSelected = exports.deleteTableIfSelected = function deleteTableIfSelected(state, dispatch) {
  if ((0, _utils2.isTableSelected)(state.selection)) {
    return deleteTable(state, dispatch);
  }
  return false;
};
var convertFirstRowToHeader = exports.convertFirstRowToHeader = function convertFirstRowToHeader(schema) {
  return function (tr) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var table = (0, _utils2.findTable)(tr.selection);
    var map = _tableMap.TableMap.get(table.node);
    for (var i = 0; i < map.width; i++) {
      var cell = table.node.child(0).child(i);
      tr.setNodeMarkup(table.start + map.map[i], schema.nodes.tableHeader, cell.attrs);
    }
    return tr;
  };
};
var moveCursorBackward = exports.moveCursorBackward = function moveCursorBackward(state, dispatch) {
  var _ref = state.selection,
    $cursor = _ref.$cursor;
  // if cursor is in the middle of a text node, do nothing
  if (!$cursor || $cursor.parentOffset > 0) {
    return false;
  }

  // find the node before the cursor
  var before;
  var cut;
  if (!(0, _nodes.isIsolating)($cursor.parent)) {
    for (var i = $cursor.depth - 1; !before && i >= 0; i--) {
      if ($cursor.index(i) > 0) {
        cut = $cursor.before(i + 1);
        before = $cursor.node(i).child($cursor.index(i) - 1);
      }
      if ((0, _nodes.isIsolating)($cursor.node(i))) {
        break;
      }
    }
  }

  // if the node before is not a table node - do nothing
  if (!before || before.type !== state.schema.nodes.table) {
    return false;
  }

  /*
     ensure we're just at a top level paragraph
     otherwise, perform regular backspace behaviour
    */
  var grandparent = $cursor.node($cursor.depth - 1);
  if ($cursor.parent.type !== state.schema.nodes.paragraph || grandparent && grandparent.type !== state.schema.nodes.doc) {
    return false;
  }
  var tr = state.tr;
  var lastCellPos = (cut || 0) - 4;
  // need to move cursor inside the table to be able to calculate table's offset
  tr.setSelection(new _state.TextSelection(state.doc.resolve(lastCellPos)));
  var $from = tr.selection.$from;
  var start = $from.start(-1);
  var pos = start + $from.parent.nodeSize - 1;

  // move cursor to the last cell
  // it doesn't join node before (last cell) with node after (content after the cursor)
  // due to ridiculous amount of PM code that would have been required to overwrite
  tr.setSelection(new _state.TextSelection(state.doc.resolve(pos)));

  // if we are inside an empty paragraph not at the end of the doc we delete it
  var cursorNode = $cursor.node();
  var docEnd = state.doc.content.size;
  var paragraphWrapStart = $cursor.pos - 1;
  var paragraphWrapEnd = $cursor.pos + 1;
  if (cursorNode.content.size === 0 && $cursor.pos + 1 !== docEnd) {
    tr.delete(paragraphWrapStart, paragraphWrapEnd);
  }
  if (dispatch) {
    dispatch(tr);
  }
  return true;
};
var setMultipleCellAttrs = exports.setMultipleCellAttrs = function setMultipleCellAttrs(attrs, editorView) {
  return function (state, dispatch) {
    var cursorPos;
    var tr = state.tr;
    var _getPluginState2 = (0, _pluginFactory.getPluginState)(state),
      targetCellPosition = _getPluginState2.targetCellPosition;
    if ((0, _utils2.isSelectionType)(tr.selection, 'cell')) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var selection = tr.selection;
      selection.forEachCell(function (_cell, pos) {
        var $pos = tr.doc.resolve(tr.mapping.map(pos + 1));
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        tr = (0, _utils2.setCellAttrs)((0, _utils2.findCellClosestToPos)($pos), attrs)(tr);
      });
      cursorPos = selection.$headCell.pos;
    } else if (targetCellPosition) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var cell = (0, _utils2.findCellClosestToPos)(tr.doc.resolve(targetCellPosition + 1));
      tr = (0, _utils2.setCellAttrs)(cell, attrs)(tr);
      cursorPos = cell.pos;
    }
    if (tr.docChanged && cursorPos !== undefined) {
      if (dispatch) {
        if (cursorPos !== undefined) {
          editorView === null || editorView === void 0 || editorView.focus();
          tr.setSelection(new _state.TextSelection(tr.doc.resolve(cursorPos)));
        }
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
var selectColumn = exports.selectColumn = function selectColumn(column, expand) {
  var triggeredByKeyboard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _pluginFactory.createCommand)(function (state) {
    var cells = (0, _utils2.getCellsInColumn)(column)(state.tr.selection);
    if (!cells || !cells.length || typeof cells[0].pos !== 'number') {
      return false;
    }
    var decorations = (0, _decoration.createColumnSelectedDecoration)((0, _utils2.selectColumn)(column, expand)(state.tr));
    var decorationSet = (0, _updatePluginStateDecorations.updatePluginStateDecorations)(state, decorations, _types.TableDecorations.COLUMN_SELECTED);
    var targetCellPosition = cells[0].pos;
    return {
      type: 'SELECT_COLUMN',
      data: {
        targetCellPosition: targetCellPosition,
        decorationSet: decorationSet
      }
    };
  }, function (tr) {
    return (0, _utils2.selectColumn)(column, expand)(tr).setMeta('addToHistory', false).setMeta('selectedColumnViaKeyboard', triggeredByKeyboard);
  });
};
var selectColumns = exports.selectColumns = function selectColumns(columnIndexes) {
  return (0, _pluginFactory.createCommand)(function (state) {
    if (!columnIndexes) {
      return false;
    }
    var cells = columnIndexes.map(function (column) {
      return (0, _utils2.getCellsInColumn)(column)(state.tr.selection);
    }).flat();
    if (!cells || !cells.length || cells.some(function (cell) {
      return cell && typeof cell.pos !== 'number';
    })) {
      return false;
    }
    var decorations = (0, _decoration.createColumnSelectedDecoration)((0, _utils2.selectColumns)(columnIndexes)(state.tr));
    var decorationSet = (0, _updatePluginStateDecorations.updatePluginStateDecorations)(state, decorations, _types.TableDecorations.COLUMN_SELECTED);
    var cellsInFirstColumn = (0, _utils2.getCellsInColumn)(Math.min.apply(Math, (0, _toConsumableArray2.default)(columnIndexes)))(state.tr.selection);
    if (!cellsInFirstColumn || cellsInFirstColumn.length === 0) {
      return false;
    }
    var targetCellPosition = cellsInFirstColumn[0].pos;
    return {
      type: 'SELECT_COLUMN',
      data: {
        targetCellPosition: targetCellPosition,
        decorationSet: decorationSet
      }
    };
  }, function (tr) {
    return (0, _utils2.selectColumns)(columnIndexes)(tr).setMeta('addToHistory', false);
  });
};
var selectRow = exports.selectRow = function selectRow(row, expand) {
  var triggeredByKeyboard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _pluginFactory.createCommand)(function (state) {
    var targetCellPosition;
    var cells = (0, _utils2.getCellsInRow)(row)(state.tr.selection);
    if (cells && cells.length) {
      targetCellPosition = cells[0].pos;
    }
    return {
      type: 'SET_TARGET_CELL_POSITION',
      data: {
        targetCellPosition: targetCellPosition
      }
    };
  }, function (tr) {
    return (0, _utils2.selectRow)(row, expand)(tr).setMeta('addToHistory', false).setMeta('selectedRowViaKeyboard', triggeredByKeyboard);
  });
};
var selectRows = exports.selectRows = function selectRows(rowIndexes) {
  return (0, _pluginFactory.createCommand)(function (state) {
    if (rowIndexes.length === 0) {
      return false;
    }
    var cells = rowIndexes.map(function (row) {
      return (0, _utils2.getCellsInRow)(row)(state.tr.selection);
    }).flat();
    if (!cells || !cells.length || cells.some(function (cell) {
      return cell && typeof cell.pos !== 'number';
    })) {
      return false;
    }
    var cellsInFirstRow = (0, _utils2.getCellsInRow)(Math.min.apply(Math, (0, _toConsumableArray2.default)(rowIndexes)))(state.tr.selection);
    if (!cellsInFirstRow || cellsInFirstRow.length === 0) {
      return false;
    }
    var targetCellPosition = cellsInFirstRow[0].pos;
    return {
      type: 'SET_TARGET_CELL_POSITION',
      data: {
        targetCellPosition: targetCellPosition
      }
    };
  }, function (tr) {
    return (0, _utils2.selectRows)(rowIndexes)(tr).setMeta('addToHistory', false);
  });
};
var showInsertColumnButton = exports.showInsertColumnButton = function showInsertColumnButton(columnIndex) {
  return (0, _pluginFactory.createCommand)(function (_) {
    return columnIndex > -1 ? {
      type: 'SHOW_INSERT_COLUMN_BUTTON',
      data: {
        insertColumnButtonIndex: columnIndex
      }
    } : false;
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var showInsertRowButton = exports.showInsertRowButton = function showInsertRowButton(rowIndex) {
  return (0, _pluginFactory.createCommand)(function (_) {
    return rowIndex > -1 ? {
      type: 'SHOW_INSERT_ROW_BUTTON',
      data: {
        insertRowButtonIndex: rowIndex
      }
    } : false;
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var hideInsertColumnOrRowButton = exports.hideInsertColumnOrRowButton = function hideInsertColumnOrRowButton() {
  return (0, _pluginFactory.createCommand)({
    type: 'HIDE_INSERT_COLUMN_OR_ROW_BUTTON'
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var addResizeHandleDecorations = exports.addResizeHandleDecorations = function addResizeHandleDecorations(rowIndex, columnIndex, includeTooltip, nodeViewPortalProviderAPI, isKeyboardResize) {
  return (0, _pluginFactory.createCommand)(function (state) {
    var tableNode = (0, _utils2.findTable)(state.selection);
    var _getPluginState3 = (0, _pluginFactory.getPluginState)(state),
      allowColumnResizing = _getPluginState3.pluginConfig.allowColumnResizing,
      getIntl = _getPluginState3.getIntl;
    if (!tableNode || !allowColumnResizing) {
      return false;
    }
    return {
      type: 'ADD_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: (0, _columnResizing.buildColumnResizingDecorations)(rowIndex, columnIndex, includeTooltip, getIntl, nodeViewPortalProviderAPI)({
          tr: state.tr,
          decorationSet: (0, _plugin.getDecorations)(state)
        }),
        resizeHandleRowIndex: rowIndex,
        resizeHandleColumnIndex: columnIndex,
        resizeHandleIncludeTooltip: includeTooltip,
        isKeyboardResize: isKeyboardResize || false
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var updateResizeHandleDecorations = exports.updateResizeHandleDecorations = function updateResizeHandleDecorations(nodeViewPortalProviderAPI, rowIndex, columnIndex, includeTooltip) {
  return (0, _pluginFactory.createCommand)(function (state) {
    var tableNode = (0, _utils2.findTable)(state.selection);
    var _getPluginState4 = (0, _pluginFactory.getPluginState)(state),
      resizeHandleRowIndex = _getPluginState4.resizeHandleRowIndex,
      resizeHandleColumnIndex = _getPluginState4.resizeHandleColumnIndex,
      resizeHandleIncludeTooltip = _getPluginState4.resizeHandleIncludeTooltip,
      allowColumnResizing = _getPluginState4.pluginConfig.allowColumnResizing,
      getIntl = _getPluginState4.getIntl;
    if (!tableNode || !allowColumnResizing) {
      return false;
    }
    var resolvedRowIndex = rowIndex !== null && rowIndex !== void 0 ? rowIndex : resizeHandleRowIndex;
    var resolvedColumnIndex = columnIndex !== null && columnIndex !== void 0 ? columnIndex : resizeHandleColumnIndex;
    var resolvedIncludeTooltip = includeTooltip !== null && includeTooltip !== void 0 ? includeTooltip : resizeHandleIncludeTooltip;
    if (resolvedRowIndex === undefined || resolvedColumnIndex === undefined || resolvedIncludeTooltip === undefined) {
      return false;
    }
    return {
      type: 'UPDATE_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: (0, _columnResizing.buildColumnResizingDecorations)(resolvedRowIndex, resolvedColumnIndex, resolvedIncludeTooltip, getIntl, nodeViewPortalProviderAPI)({
          tr: state.tr,
          decorationSet: (0, _plugin.getDecorations)(state)
        }),
        resizeHandleRowIndex: rowIndex,
        resizeHandleColumnIndex: columnIndex,
        resizeHandleIncludeTooltip: includeTooltip
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var removeResizeHandleDecorations = exports.removeResizeHandleDecorations = function removeResizeHandleDecorations() {
  return (0, _pluginFactory.createCommand)(function (state) {
    return {
      type: 'REMOVE_RESIZE_HANDLE_DECORATIONS',
      data: {
        decorationSet: (0, _columnResizing.clearColumnResizingDecorations)()({
          tr: state.tr,
          decorationSet: (0, _plugin.getDecorations)(state)
        })
      }
    };
  }, function (tr) {
    return tr.setMeta('addToHistory', false);
  });
};
var autoSizeTable = exports.autoSizeTable = function autoSizeTable(view, node, table, basePos, opts) {
  if (typeof basePos !== 'number') {
    return false;
  }
  view.dispatch((0, _fixTables.fixAutoSizedTable)(view, node, table, basePos, opts));
  return true;
};
var addBoldInEmptyHeaderCells = exports.addBoldInEmptyHeaderCells = function addBoldInEmptyHeaderCells(tableCellHeader) {
  return function (state, dispatch) {
    var tr = state.tr;
    if (
    // Avoid infinite loop when the current selection is not a TextSelection
    (0, _utils.isTextSelection)(tr.selection) && tr.selection.$cursor &&
    // When storedMark is null that means this is the initial state
    // if the user press to remove the mark storedMark will be an empty array
    // and we shouldn't apply the strong mark
    tr.storedMarks == null &&
    // Check if the current node is a direct child from paragraph
    tr.selection.$from.depth === tableCellHeader.depth + 1 &&
    // this logic is applied only for empty paragraph
    tableCellHeader.node.nodeSize === 4 && (0, _utils.isParagraph)(tableCellHeader.node.firstChild, state.schema)) {
      var strong = state.schema.marks.strong;
      tr.setStoredMarks([strong.create()]).setMeta('addToHistory', false);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
var updateWidthToWidest = exports.updateWidthToWidest = function updateWidthToWidest(widthToWidest) {
  return (0, _pluginFactory.createCommand)(function (state) {
    var _getPluginState5 = (0, _pluginFactory.getPluginState)(state),
      prevWidthToWidest = _getPluginState5.widthToWidest;
    if ((0, _isEqual.default)(widthToWidest, prevWidthToWidest)) {
      return false;
    }
    return {
      type: 'UPDATE_TABLE_WIDTH_TO_WIDEST',
      data: {
        widthToWidest: _objectSpread(_objectSpread({}, prevWidthToWidest), widthToWidest)
      }
    };
  });
};
var setTableAlignment = exports.setTableAlignment = function setTableAlignment(newAlignment, isCommentEditor) {
  return function (_ref2) {
    var tr = _ref2.tr;
    var tableObject = (0, _utils2.findTable)(tr.selection);
    if (!tableObject) {
      return null;
    }
    var nextTableAttrs = _objectSpread(_objectSpread({}, tableObject.node.attrs), {}, {
      layout: newAlignment
    });

    // table uses old breakout values in layout attribute to determine width
    // but that information is lost when alignment changes, so we need to ensure we retain that info
    // If table width is not set in the Comment editor, it means that the table width is inherited from the editor and is "full width".
    // In that case when switching between alignment options in the Comment editor we should keep the table width unset.
    if (!tableObject.node.attrs.width && !isCommentEditor) {
      var tableWidth = (0, _nodeWidth.getTableContainerWidth)(tableObject.node);
      nextTableAttrs.width = tableWidth;
    }
    tr.setNodeMarkup(tableObject.pos, undefined, nextTableAttrs).setMeta('scrollIntoView', false);
    return tr;
  };
};
var setTableAlignmentWithTableContentWithPos = exports.setTableAlignmentWithTableContentWithPos = function setTableAlignmentWithTableContentWithPos(newAlignment, tableNodeWithPos) {
  return function (_ref3) {
    var tr = _ref3.tr;
    var table = tableNodeWithPos.node;
    var nextTableAttrs = _objectSpread(_objectSpread({}, table.attrs), {}, {
      layout: newAlignment
    });

    // table uses old breakout values in layout attribute to determine width
    // but that information is lost when alignment changes, so we need to ensure we retain that info
    if (!table.attrs.width) {
      var tableWidth = (0, _nodeWidth.getTableContainerWidth)(table);
      nextTableAttrs.width = tableWidth;
    }
    tr.setNodeMarkup(tableNodeWithPos.pos, undefined, nextTableAttrs).setMeta('scrollIntoView', false);
    return tr;
  };
};
var setFocusToCellMenu = exports.setFocusToCellMenu = function setFocusToCellMenu() {
  var isCellMenuOpenByKeyboard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var originalTr = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _pluginFactory.createCommand)(function () {
    return {
      type: 'SET_CELL_MENU_OPEN',
      data: {
        isCellMenuOpenByKeyboard: isCellMenuOpenByKeyboard
      }
    };
  }, function (tr) {
    return (originalTr || tr).setMeta('addToHistory', false);
  });
};