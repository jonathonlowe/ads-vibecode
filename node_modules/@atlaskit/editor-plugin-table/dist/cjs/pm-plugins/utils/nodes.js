"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tablesHaveDifferentNoOfRows = exports.tablesHaveDifferentNoOfColumns = exports.tablesHaveDifferentColumnWidths = exports.supportedHeaderRow = exports.isTableNestedInMoreThanOneNode = exports.isTableNested = exports.isIsolating = exports.getTableWidth = exports.containsHeaderRow = exports.containsHeaderColumn = exports.checkIfNumberColumnEnabled = exports.checkIfHeaderRowEnabled = exports.checkIfHeaderColumnEnabled = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("@atlaskit/editor-common/utils");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _utils2 = require("@atlaskit/editor-tables/utils");
var isIsolating = exports.isIsolating = function isIsolating(node) {
  return !!node.type.spec.isolating;
};
var containsHeaderColumn = exports.containsHeaderColumn = function containsHeaderColumn(table) {
  var map = _tableMap.TableMap.get(table);
  // Get cell positions for first column.
  var cellPositions = map.cellsInRect({
    left: 0,
    top: 0,
    right: 1,
    bottom: map.height
  });
  for (var i = 0; i < cellPositions.length; i++) {
    try {
      var cell = table.nodeAt(cellPositions[i]);
      if (cell && cell.type !== table.type.schema.nodes.tableHeader) {
        return false;
      }
    } catch (e) {
      return false;
    }
  }
  return true;
};
var containsHeaderRow = exports.containsHeaderRow = function containsHeaderRow(table) {
  var map = _tableMap.TableMap.get(table);
  for (var i = 0; i < map.width; i++) {
    var cell = table.nodeAt(map.map[i]);
    if (cell && cell.type !== table.type.schema.nodes.tableHeader) {
      return false;
    }
  }
  return true;
};
var checkIfHeaderColumnEnabled = exports.checkIfHeaderColumnEnabled = function checkIfHeaderColumnEnabled(selection) {
  return filterNearSelection(selection, _utils2.findTable, containsHeaderColumn, false);
};
var checkIfHeaderRowEnabled = exports.checkIfHeaderRowEnabled = function checkIfHeaderRowEnabled(selection) {
  return filterNearSelection(selection, _utils2.findTable, containsHeaderRow, false);
};
var checkIfNumberColumnEnabled = exports.checkIfNumberColumnEnabled = function checkIfNumberColumnEnabled(selection) {
  return filterNearSelection(selection, _utils2.findTable, function (table) {
    return !!table.attrs.isNumberColumnEnabled;
  }, false);
};
var getTableWidth = exports.getTableWidth = function getTableWidth(node) {
  return getTableWidths(node).reduce(function (acc, current) {
    return acc + current;
  }, 0);
};
var tablesHaveDifferentColumnWidths = exports.tablesHaveDifferentColumnWidths = function tablesHaveDifferentColumnWidths(currentTable, previousTable) {
  var currentTableWidths = getTableWidths(currentTable);
  var previousTableWidths = getTableWidths(previousTable);
  if (currentTableWidths.length !== previousTableWidths.length) {
    return true;
  }
  var sameWidths = currentTableWidths.every(function (value, index) {
    return value === previousTableWidths[index];
  });
  return sameWidths === false;
};
var tablesHaveDifferentNoOfColumns = exports.tablesHaveDifferentNoOfColumns = function tablesHaveDifferentNoOfColumns(currentTable, previousTable) {
  var prevMap = _tableMap.TableMap.get(previousTable);
  var currentMap = _tableMap.TableMap.get(currentTable);
  return prevMap.width !== currentMap.width;
};
var tablesHaveDifferentNoOfRows = exports.tablesHaveDifferentNoOfRows = function tablesHaveDifferentNoOfRows(currentTable, previousTable) {
  var prevMap = _tableMap.TableMap.get(previousTable);
  var currentMap = _tableMap.TableMap.get(currentTable);
  return prevMap.height !== currentMap.height;
};
function filterNearSelection(selection, findNode, predicate, defaultValue) {
  var found = findNode(selection);
  if (!found) {
    return defaultValue;
  }
  return predicate(found.node, found.pos);
}
function getTableWidths(node) {
  if (!node.content.firstChild) {
    return [];
  }
  var tableWidths = [];
  node.content.firstChild.content.forEach(function (cell) {
    if (Array.isArray(cell.attrs.colwidth)) {
      var colspan = cell.attrs.colspan || 1;
      tableWidths.push.apply(tableWidths, (0, _toConsumableArray2.default)(cell.attrs.colwidth.slice(0, colspan)));
    }
  });
  return tableWidths;
}
var isTableNested = exports.isTableNested = function isTableNested(state) {
  var tablePos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var parent = state.doc.resolve(tablePos).parent;
  var nodeTypes = state.schema.nodes;
  return parent.type === nodeTypes.layoutColumn || parent.type === nodeTypes.expand || parent.type === nodeTypes.bodiedExtension || parent.type === nodeTypes.extensionFrame || parent.type === nodeTypes.tableHeader || parent.type === nodeTypes.tableCell;
};
var isTableNestedInMoreThanOneNode = exports.isTableNestedInMoreThanOneNode = function isTableNestedInMoreThanOneNode(state) {
  var tablePos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return state.doc.resolve(tablePos).depth > 2;
};
var anyChildCellMergedAcrossRow = function anyChildCellMergedAcrossRow(node) {
  return (0, _utils.mapChildren)(node, function (child) {
    return child.attrs.rowspan || 0;
  }).some(function (rowspan) {
    return rowspan > 1;
  });
};

/**
 * Check if a given node is a header row with this definition:
 *  - all children are tableHeader cells
 *  - no table cells have been have merged with other table row cells
 *
 * @param node ProseMirror node
 * @return boolean if it meets definition
 */
var supportedHeaderRow = exports.supportedHeaderRow = function supportedHeaderRow(node) {
  var allHeaders = (0, _utils.mapChildren)(node, function (child) {
    return child.type.name === 'tableHeader';
  }).every(Boolean);
  var someMerged = anyChildCellMergedAcrossRow(node);
  return allHeaders && !someMerged;
};