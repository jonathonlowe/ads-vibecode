"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findClosestSnap = exports.defaultTablePreserveSnappingWidths = exports.defaultSnappingWidths = exports.calculateDefaultTablePreserveSnappings = exports.calculateDefaultSnappings = exports.PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _guideline = require("@atlaskit/editor-common/guideline");
var _editorSharedStyles = require("@atlaskit/editor-shared-styles");
var numberOfLanesInDefaultLayoutWidth = 12;
var calculateSubSnappingWidths = function calculateSubSnappingWidths(totalLanes, totalWidth) {
  return new Array(Math.round(totalLanes / 2) - 1).fill(totalWidth / totalLanes).map(function (v, i) {
    return v * (i + 1) * 2;
  });
};
var calculateDefaultSnappings = exports.calculateDefaultSnappings = function calculateDefaultSnappings() {
  var lengthOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return [].concat((0, _toConsumableArray2.default)(calculateSubSnappingWidths(numberOfLanesInDefaultLayoutWidth, _editorSharedStyles.akEditorDefaultLayoutWidth + lengthOffset)), [_editorSharedStyles.akEditorDefaultLayoutWidth + lengthOffset, _editorSharedStyles.akEditorCalculatedWideLayoutWidth + lengthOffset, _editorSharedStyles.akEditorFullWidthLayoutWidth + lengthOffset]);
};
// FF TablePreserve for calculateDefaultSnappings
var calculateDefaultTablePreserveSnappings = exports.calculateDefaultTablePreserveSnappings = function calculateDefaultTablePreserveSnappings() {
  var lengthOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var editorContainerWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _editorSharedStyles.akEditorFullWidthLayoutWidth;
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    innerGuidelines: false,
    breakoutPoints: false
  };
  var dynamicFullWidthLine = editorContainerWith - (0, _editorSharedStyles.akEditorGutterPaddingDynamic)() * 2 >= _editorSharedStyles.akEditorFullWidthLayoutWidth ? _editorSharedStyles.akEditorFullWidthLayoutWidth : editorContainerWith - (0, _editorSharedStyles.akEditorGutterPaddingDynamic)() * 2;
  var guides = [dynamicFullWidthLine - lengthOffset];
  if (!exclude.breakoutPoints) {
    guides.unshift(_editorSharedStyles.akEditorDefaultLayoutWidth + lengthOffset, _editorSharedStyles.akEditorCalculatedWideLayoutWidth + lengthOffset);
  }
  if (!exclude.innerGuidelines) {
    guides.unshift.apply(guides, [0].concat((0, _toConsumableArray2.default)(calculateSubSnappingWidths(numberOfLanesInDefaultLayoutWidth, _editorSharedStyles.akEditorDefaultLayoutWidth + lengthOffset))));
  }
  return guides;
};
var defaultSnappingWidths = exports.defaultSnappingWidths = calculateDefaultSnappings();
var PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET = exports.PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET = 0;
// FF TablePreserve for defaultSnappingWidths
var defaultTablePreserveSnappingWidths = exports.defaultTablePreserveSnappingWidths = function defaultTablePreserveSnappingWidths(lengthOffset, editorContainerWidth) {
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    innerGuidelines: false,
    breakoutPoints: false
  };
  return editorContainerWidth - (0, _editorSharedStyles.akEditorGutterPaddingDynamic)() * 2 > _editorSharedStyles.akEditorFullWidthLayoutWidth ? calculateDefaultSnappings() : calculateDefaultTablePreserveSnappings(lengthOffset, editorContainerWidth, exclude); // lengthOffset was hardcoded 0 here, created PRESERVE_TABLE_SNAPPING_LENGTH_OFFSET instead.
};

/**
 * Returns keys of guidelines that are closest to the table and within the snapGap
 */
var findClosestSnap = exports.findClosestSnap = function findClosestSnap(currentWidth, snapWidths, guidelines) {
  var snapGap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var closestGapIndex = snapWidths.reduce(function (prev, curr, index) {
    return Math.abs(curr - currentWidth) < Math.abs(snapWidths[prev] - currentWidth) ? index : prev;
  }, 0);
  var gap = Math.abs(snapWidths[closestGapIndex] - currentWidth);
  if (gap < snapGap) {
    var snappingWidth = Math.round(snapWidths[closestGapIndex]);
    var guidelineKeys = guidelines.reduce(function (acc, guideline) {
      // NOTE: The snap points are based on the guidelines, however their formatted as a length value whereas the guidelines
      // are point based. The point base x coords are calculated by halving the lengths. This means we can convert the
      // point base position to length by simply multiplying by 2.
      var length = Math.round(Math.abs((0, _guideline.isVerticalPosition)(guideline.position) ? guideline.position.x : guideline.position.y) * 2);
      if (snappingWidth >= length - tolerance && snappingWidth <= length + tolerance) {
        acc.push(guideline.key);
      }
      return acc;
    }, []);
    return {
      gap: gap,
      keys: guidelineKeys
    };
  }
  return {
    gap: gap,
    keys: []
  };
};