"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMergedCellsPositions = exports.getAssistiveMessage = void 0;
var _messages = require("@atlaskit/editor-common/messages");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _utils = require("@atlaskit/editor-tables/utils");
var getMergedCellsPositions = exports.getMergedCellsPositions = function getMergedCellsPositions(tr) {
  var table = (0, _utils.findTable)(tr.selection);
  if (!table) {
    return [];
  }
  var map = _tableMap.TableMap.get(table.node);
  var cellPositions = new Set();
  var mergedCells = [];
  map.map.forEach(function (value) {
    if (cellPositions.has(value)) {
      mergedCells.push(value);
    } else {
      cellPositions.add(value);
    }
  });
  return mergedCells;
};
var getAssistiveMessage = exports.getAssistiveMessage = function getAssistiveMessage(prevTableNode, currentTableNode, intl) {
  var formatMessage = intl.formatMessage;
  var prevTableMap = _tableMap.TableMap.get(prevTableNode);
  var currentTableMap = _tableMap.TableMap.get(currentTableNode);
  if (currentTableMap.width !== prevTableMap.width) {
    var diff = Math.abs(currentTableMap.width - prevTableMap.width);
    if (currentTableMap.width > prevTableMap.width) {
      return formatMessage(_messages.tableMessages.columnsAreInserted, {
        count: diff
      });
    }
    if (currentTableMap.width < prevTableMap.width) {
      return formatMessage(_messages.tableMessages.columnsAreRemoved, {
        count: diff
      });
    }
  }
  if (currentTableMap.height !== prevTableMap.height) {
    var _diff = Math.abs(currentTableMap.height - prevTableMap.height);
    if (currentTableMap.height > prevTableMap.height) {
      return formatMessage(_messages.tableMessages.rowsAreInserted, {
        count: _diff
      });
    }
    if (currentTableMap.height < prevTableMap.height) {
      return formatMessage(_messages.tableMessages.rowsAreRemoved, {
        count: _diff
      });
    }
  }
  return '';
};