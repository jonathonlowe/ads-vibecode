"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleMouseUp = exports.handleMouseOver = exports.handleMouseOut = exports.handleMouseMove = exports.handleMouseLeave = exports.handleMouseEnter = exports.handleMouseDown = exports.handleFocus = exports.handleCut = exports.handleClick = exports.handleBlur = void 0;
exports.handleTripleClick = handleTripleClick;
exports.withCellTracking = exports.whenTableInFocus = exports.isTableInFocus = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _rafSchd = _interopRequireDefault(require("raf-schd"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _nesting = require("@atlaskit/editor-common/nesting");
var _utils = require("@atlaskit/editor-common/utils");
var _state5 = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _cellSelection = require("@atlaskit/editor-tables/cell-selection");
var _tableMap = require("@atlaskit/editor-tables/table-map");
var _utils3 = require("@atlaskit/editor-tables/utils");
var _commands = require("../pm-plugins/commands");
var _pluginFactory = require("../pm-plugins/drag-and-drop/plugin-factory");
var _pluginFactory2 = require("../pm-plugins/plugin-factory");
var _pluginFactory3 = require("../pm-plugins/table-resizing/plugin-factory");
var _deleteColumns = require("../pm-plugins/transforms/delete-columns");
var _deleteRows = require("../pm-plugins/transforms/delete-rows");
var _analytics2 = require("../pm-plugins/utils/analytics");
var _columnControls = require("../pm-plugins/utils/column-controls");
var _dom = require("../pm-plugins/utils/dom");
var _getAllowAddColumnCustomStep = require("../pm-plugins/utils/get-allow-add-column-custom-step");
var _types = require("../types");
var isFocusingCalendar = function isFocusingCalendar(event) {
  return event instanceof FocusEvent && event.relatedTarget instanceof HTMLElement && event.relatedTarget.getAttribute('aria-label') === 'calendar';
};
var isFocusingModal = function isFocusingModal(event) {
  return event instanceof FocusEvent && event.relatedTarget instanceof HTMLElement && event.relatedTarget.closest('[role="dialog"]');
};
var isFocusingFloatingToolbar = function isFocusingFloatingToolbar(event) {
  return event instanceof FocusEvent && event.relatedTarget instanceof HTMLElement && event.relatedTarget.closest('[role="toolbar"]');
};
var isFocusingDragHandles = function isFocusingDragHandles(event) {
  return event instanceof FocusEvent && event.relatedTarget instanceof HTMLElement && event.relatedTarget.closest('button') && event.relatedTarget.getAttribute('draggable') === 'true';
};
var isFocusingDragHandlesClickableZone = function isFocusingDragHandlesClickableZone(event) {
  return event instanceof FocusEvent && event.relatedTarget instanceof HTMLElement && event.relatedTarget.closest('button') && event.relatedTarget.classList.contains(_types.TableCssClassName.DRAG_HANDLE_BUTTON_CLICKABLE_ZONE);
};
var handleBlur = exports.handleBlur = function handleBlur(view, event) {
  var state = view.state,
    dispatch = view.dispatch;
  // IE version check for ED-4665
  // Calendar focus check for ED-10466
  if (_utils.browser.ie_version !== 11 && !isFocusingCalendar(event) && !isFocusingModal(event) && !isFocusingFloatingToolbar(event) && !isFocusingDragHandles(event) && !isFocusingDragHandlesClickableZone(event)) {
    (0, _commands.setEditorFocus)(false)(state, dispatch);
  }
  event.preventDefault();
  return false;
};
var handleFocus = exports.handleFocus = function handleFocus(view, event) {
  var state = view.state,
    dispatch = view.dispatch;
  (0, _commands.setEditorFocus)(true)(state, dispatch);
  event.preventDefault();
  return false;
};
var handleClick = exports.handleClick = function handleClick(view, event) {
  if (!(event.target instanceof HTMLElement)) {
    return false;
  }
  var element = event.target;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var table = (0, _utils3.findTable)(view.state.selection);

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  if (event instanceof MouseEvent && (0, _dom.isColumnControlsDecorations)(element)) {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    var _getColumnOrRowIndex = (0, _dom.getColumnOrRowIndex)(element),
      _getColumnOrRowIndex2 = (0, _slicedToArray2.default)(_getColumnOrRowIndex, 1),
      startIndex = _getColumnOrRowIndex2[0];
    var state = view.state,
      _dispatch = view.dispatch;
    return (0, _commands.selectColumn)(startIndex, event.shiftKey)(state, _dispatch);
  }
  var matchfn = element.matches ? element.matches : element.msMatchesSelector;

  // check if the table cell with an image is clicked and its not the image itself
  if (!table ||
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  !(0, _utils.isElementInTableCell)(element) || !matchfn || matchfn.call(element, 'table .image, table p, table .image div')) {
    return false;
  }
  var map = _tableMap.TableMap.get(table.node);

  /** Getting the offset of current item clicked */
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var colElement = (0, _utils.closestElement)(element, 'td') ||
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  (0, _utils.closestElement)(element, 'th');
  var colIndex = colElement && colElement.cellIndex;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var rowElement = (0, _utils.closestElement)(element, 'tr');
  var rowIndex = rowElement && rowElement.rowIndex;
  var cellIndex = map.width * rowIndex + colIndex;
  var dispatch = view.dispatch,
    _view$state = view.state,
    tr = _view$state.tr,
    paragraph = _view$state.schema.nodes.paragraph;
  var cellPos = map.map[cellIndex];
  if (isNaN(cellPos) || cellPos === undefined || typeof cellPos !== 'number') {
    return false;
  }
  var editorElement = table.node.nodeAt(cellPos);
  /** Only if the last item is media group, insert a paragraph */
  if ((0, _utils.isLastItemMediaGroup)(editorElement)) {
    var posInTable = map.map[cellIndex] + editorElement.nodeSize;
    tr.insert(posInTable + table.pos, paragraph.create());
    dispatch(tr);
    (0, _utils.setNodeSelection)(view, posInTable + table.pos);
  }
  return true;
};
var handleMouseOver = exports.handleMouseOver = function handleMouseOver(view, mouseEvent) {
  if (!(mouseEvent.target instanceof HTMLElement)) {
    return false;
  }
  var state = view.state,
    dispatch = view.dispatch;
  var target = mouseEvent.target;
  var _getPluginState = (0, _pluginFactory2.getPluginState)(state),
    insertColumnButtonIndex = _getPluginState.insertColumnButtonIndex,
    insertRowButtonIndex = _getPluginState.insertRowButtonIndex,
    isTableHovered = _getPluginState.isTableHovered;
  if ((0, _dom.isInsertRowButton)(target)) {
    var _getColumnOrRowIndex3 = (0, _dom.getColumnOrRowIndex)(target),
      _getColumnOrRowIndex4 = (0, _slicedToArray2.default)(_getColumnOrRowIndex3, 2),
      startIndex = _getColumnOrRowIndex4[0],
      endIndex = _getColumnOrRowIndex4[1];
    var positionRow = (0, _dom.getMousePositionVerticalRelativeByElement)(mouseEvent) === 'bottom' ? endIndex : startIndex;
    return (0, _commands.showInsertRowButton)(positionRow)(state, dispatch);
  }
  if ((0, _dom.isColumnControlsDecorations)(target)) {
    var _getColumnOrRowIndex5 = (0, _dom.getColumnOrRowIndex)(target),
      _getColumnOrRowIndex6 = (0, _slicedToArray2.default)(_getColumnOrRowIndex5, 1),
      _startIndex = _getColumnOrRowIndex6[0];
    var _state = view.state,
      _dispatch2 = view.dispatch;
    return (0, _commands.hoverColumns)([_startIndex], false)(_state, _dispatch2);
  }
  var isNestedTable = (0, _nesting.getParentOfTypeCount)(state.schema.nodes.table)(state.selection.$from) > 1;
  if (isNestedTable) {
    // if the table is nested inside a table, we only call hideInsertColumnOrRowButton if the table nearest to the mouse target is NOT the parent table
    var nearestTable = (0, _utils.closestElement)(target, 'table');
    var nestedTable = (0, _utils2.findParentNodeOfTypeClosestToPos)(state.doc.resolve(state.selection.from), [state.schema.nodes.table]);
    var parentTable = (0, _utils2.findParentNodeOfTypeClosestToPos)(state.doc.resolve((nestedTable === null || nestedTable === void 0 ? void 0 : nestedTable.pos) || 0), [state.schema.nodes.table]);
    if ((nearestTable === null || nearestTable === void 0 ? void 0 : nearestTable.dataset.tableLocalId) !== (parentTable === null || parentTable === void 0 ? void 0 : parentTable.node.attrs.localId) && ((0, _dom.isCell)(target) || (0, _dom.isCornerButton)(target)) && (typeof insertColumnButtonIndex === 'number' || typeof insertRowButtonIndex === 'number')) {
      return (0, _commands.hideInsertColumnOrRowButton)()(state, dispatch);
    }
  } else if (((0, _dom.isCell)(target) || (0, _dom.isCornerButton)(target)) && (typeof insertColumnButtonIndex === 'number' || typeof insertRowButtonIndex === 'number')) {
    return (0, _commands.hideInsertColumnOrRowButton)()(state, dispatch);
  }
  if ((0, _dom.isResizeHandleDecoration)(target)) {
    var _getColumnOrRowIndex7 = (0, _dom.getColumnOrRowIndex)(target),
      _getColumnOrRowIndex8 = (0, _slicedToArray2.default)(_getColumnOrRowIndex7, 2),
      _startIndex2 = _getColumnOrRowIndex8[0],
      _endIndex = _getColumnOrRowIndex8[1];
    return (0, _commands.showResizeHandleLine)({
      left: _startIndex2,
      right: _endIndex
    })(state, dispatch);
  }
  if (!isTableHovered) {
    return (0, _commands.setTableHovered)(true)(state, dispatch);
  }
  return false;
};
var handleMouseUp = exports.handleMouseUp = function handleMouseUp(view, mouseEvent) {
  if (!(mouseEvent instanceof MouseEvent)) {
    return false;
  }
  var state = view.state,
    dispatch = view.dispatch;
  var _getPluginState2 = (0, _pluginFactory2.getPluginState)(state),
    insertColumnButtonIndex = _getPluginState2.insertColumnButtonIndex,
    tableNode = _getPluginState2.tableNode,
    tableRef = _getPluginState2.tableRef;
  if (insertColumnButtonIndex !== undefined && tableRef && tableRef.parentElement && tableNode) {
    var _TableMap$get = _tableMap.TableMap.get(tableNode),
      width = _TableMap$get.width;
    var newInsertColumnButtonIndex = insertColumnButtonIndex + 1;
    if (width === newInsertColumnButtonIndex) {
      var tableWidth = tableRef.clientWidth;
      tableRef.parentElement.scrollTo(tableWidth, 0);
      return (0, _commands.showInsertColumnButton)(newInsertColumnButtonIndex)(state, dispatch);
    }
  }
  return false;
};

// Ignore any `mousedown` `event` from control and numbered column buttons
// PM end up changing selection during shift selection if not prevented
var handleMouseDown = exports.handleMouseDown = function handleMouseDown(_, event) {
  var isControl = !!(event.target && event.target instanceof HTMLElement && ((0, _dom.isTableContainerOrWrapper)(event.target) || (0, _dom.isColumnControlsDecorations)(event.target) || (0, _dom.isRowControlsButton)(event.target) || (0, _dom.isDragCornerButton)(event.target)));
  if (isControl) {
    event.preventDefault();
  }
  return isControl;
};
var handleMouseOut = exports.handleMouseOut = function handleMouseOut(view, mouseEvent) {
  if (!(mouseEvent instanceof MouseEvent) || !(mouseEvent.target instanceof HTMLElement)) {
    return false;
  }
  var target = mouseEvent.target;
  if ((0, _dom.isColumnControlsDecorations)(target)) {
    var state = view.state,
      dispatch = view.dispatch;
    return (0, _commands.clearHoverSelection)()(state, dispatch);
  }
  var relatedTarget = mouseEvent.relatedTarget;
  // In case the user is moving between cell at the same column
  // we don't need to hide the resize handle decoration
  if ((0, _dom.isResizeHandleDecoration)(target) && !(0, _dom.isResizeHandleDecoration)(relatedTarget)) {
    var _state2 = view.state,
      _dispatch3 = view.dispatch;
    var _getPluginState3 = (0, _pluginFactory2.getPluginState)(_state2),
      isKeyboardResize = _getPluginState3.isKeyboardResize;
    if (isKeyboardResize) {
      // no need to hide decoration if column resizing started by keyboard
      return false;
    }
    return (0, _commands.hideResizeHandleLine)()(_state2, _dispatch3);
  }
  return false;
};
var handleMouseEnter = exports.handleMouseEnter = function handleMouseEnter(view, mouseEvent) {
  var state = view.state,
    dispatch = view.dispatch;
  var _getPluginState4 = (0, _pluginFactory2.getPluginState)(state),
    isTableHovered = _getPluginState4.isTableHovered;
  if (!isTableHovered) {
    return (0, _commands.setTableHovered)(true)(state, dispatch);
  }
  return false;
};
var handleMouseLeave = exports.handleMouseLeave = function handleMouseLeave(view, event) {
  if (!(event.target instanceof HTMLElement)) {
    return false;
  }
  var state = view.state,
    dispatch = view.dispatch;
  var _getPluginState5 = (0, _pluginFactory2.getPluginState)(state),
    insertColumnButtonIndex = _getPluginState5.insertColumnButtonIndex,
    insertRowButtonIndex = _getPluginState5.insertRowButtonIndex,
    isDragAndDropEnabled = _getPluginState5.isDragAndDropEnabled,
    isTableHovered = _getPluginState5.isTableHovered;
  if (isTableHovered) {
    if (isDragAndDropEnabled) {
      var _getDragDropPluginSta = (0, _pluginFactory.getPluginState)(state),
        _getDragDropPluginSta2 = _getDragDropPluginSta.isDragMenuOpen,
        isDragMenuOpen = _getDragDropPluginSta2 === void 0 ? false : _getDragDropPluginSta2;
      !isDragMenuOpen && (0, _commands.setTableHovered)(false)(state, dispatch);
    } else {
      (0, _commands.setTableHovered)(false)(state, dispatch);
    }
    return true;
  }

  // If this table doesn't have focus then we want to skip everything after this.
  if (!isTableInFocus(view)) {
    return false;
  }
  var target = event.target;
  if ((0, _dom.isTableControlsButton)(target)) {
    return true;
  }
  if ((typeof insertColumnButtonIndex !== 'undefined' || typeof insertRowButtonIndex !== 'undefined') && (0, _commands.hideInsertColumnOrRowButton)()(state, dispatch)) {
    return true;
  }
  return false;
};

// IMPORTANT: The mouse move handler has been setup with RAF schedule to avoid Reflows which will occur as some methods
// need to access the mouse event offset position and also the target clientWidth vallue.
var handleMouseMoveDebounce = function handleMouseMoveDebounce(nodeViewPortalProviderAPI) {
  return (0, _rafSchd.default)(function (view, event, offsetX) {
    if (!(event.target instanceof HTMLElement)) {
      return false;
    }
    var element = event.target;
    if ((0, _dom.isColumnControlsDecorations)(element) || (0, _dom.isDragColumnFloatingInsertDot)(element)) {
      var state = view.state,
        dispatch = view.dispatch;
      var _getPluginState6 = (0, _pluginFactory2.getPluginState)(state),
        insertColumnButtonIndex = _getPluginState6.insertColumnButtonIndex;
      var _getColumnOrRowIndex9 = (0, _dom.getColumnOrRowIndex)(element),
        _getColumnOrRowIndex10 = (0, _slicedToArray2.default)(_getColumnOrRowIndex9, 2),
        startIndex = _getColumnOrRowIndex10[0],
        endIndex = _getColumnOrRowIndex10[1];
      var positionColumn = (0, _dom.getMousePositionHorizontalRelativeByElement)(event, offsetX, undefined) === 'right' ? endIndex : startIndex;
      if (positionColumn !== insertColumnButtonIndex) {
        return (0, _commands.showInsertColumnButton)(positionColumn)(state, dispatch);
      }
    }
    if ((0, _dom.isRowControlsButton)(element) || (0, _dom.isDragRowFloatingInsertDot)(element)) {
      var _state3 = view.state,
        _dispatch4 = view.dispatch;
      var _getPluginState7 = (0, _pluginFactory2.getPluginState)(_state3),
        insertRowButtonIndex = _getPluginState7.insertRowButtonIndex;
      var _getColumnOrRowIndex11 = (0, _dom.getColumnOrRowIndex)(element),
        _getColumnOrRowIndex12 = (0, _slicedToArray2.default)(_getColumnOrRowIndex11, 2),
        _startIndex3 = _getColumnOrRowIndex12[0],
        _endIndex2 = _getColumnOrRowIndex12[1];
      var positionRow = (0, _dom.getMousePositionVerticalRelativeByElement)(event) === 'bottom' ? _endIndex2 : _startIndex3;
      if (positionRow !== insertRowButtonIndex) {
        return (0, _commands.showInsertRowButton)(positionRow)(_state3, _dispatch4);
      }
    }
    if (!(0, _dom.isResizeHandleDecoration)(element) && (0, _dom.isCell)(element)) {
      var _positionColumn = (0, _dom.getMousePositionHorizontalRelativeByElement)(event, offsetX, _types.RESIZE_HANDLE_AREA_DECORATION_GAP);
      if (_positionColumn !== null) {
        var _state4 = view.state,
          _dispatch5 = view.dispatch;
        var _getPluginState8 = (0, _pluginFactory2.getPluginState)(_state4),
          resizeHandleColumnIndex = _getPluginState8.resizeHandleColumnIndex,
          resizeHandleRowIndex = _getPluginState8.resizeHandleRowIndex;
        var isKeyboardResize = (0, _pluginFactory2.getPluginState)(_state4).isKeyboardResize;
        var tableCell = (0, _utils.closestElement)(element, 'td, th');
        var cellStartPosition = view.posAtDOM(tableCell, 0);
        var rect = (0, _utils3.findCellRectClosestToPos)(_state4.doc.resolve(cellStartPosition));
        if (rect) {
          var columnEndIndexTarget = _positionColumn === 'left' ? rect.left : rect.right;
          var rowIndexTarget = rect.top;
          if ((columnEndIndexTarget !== resizeHandleColumnIndex || rowIndexTarget !== resizeHandleRowIndex || !(0, _dom.hasResizeHandler)({
            target: element,
            columnEndIndexTarget: columnEndIndexTarget
          })) && !isKeyboardResize // if initiated by keyboard don't need to react on hover for other resize sliders
          ) {
            return (0, _commands.addResizeHandleDecorations)(rowIndexTarget, columnEndIndexTarget, true, nodeViewPortalProviderAPI)(_state4, _dispatch5);
          }
        }
      }
    }
    return false;
  });
};
var handleMouseMove = exports.handleMouseMove = function handleMouseMove(nodeViewPortalProviderAPI) {
  return function (view, event) {
    if (!(event.target instanceof HTMLElement)) {
      return false;
    }

    // NOTE: When accessing offsetX in gecko from a deferred callback, it will return 0. However it will be non-zero if accessed
    // within the scope of it's initial mouse move handler. Also Chrome does return the correct value, however it could trigger
    // a reflow. So for now this will just grab the offsetX value immediately for gecko and chrome will calculate later
    // in the deferred callback handler.
    // Bug Tracking: https://bugzilla.mozilla.org/show_bug.cgi?id=1882903
    handleMouseMoveDebounce(nodeViewPortalProviderAPI)(view, event, _utils.browser.gecko ? event.offsetX : NaN);
    return false;
  };
};
function handleTripleClick(view, pos) {
  var state = view.state,
    dispatch = view.dispatch;
  var $cellPos = (0, _utils3.cellAround)(state.doc.resolve(pos));
  if (!$cellPos) {
    return false;
  }
  var cell = state.doc.nodeAt($cellPos.pos);
  if (cell) {
    var selFrom = _state5.Selection.findFrom($cellPos, 1, true);
    var selTo = _state5.Selection.findFrom(state.doc.resolve($cellPos.pos + cell.nodeSize), -1, true);
    if (selFrom && selTo) {
      dispatch(state.tr.setSelection(new _state5.TextSelection(selFrom.$from, selTo.$to)));
      return true;
    }
  }
  return false;
}
var handleCut = exports.handleCut = function handleCut(oldTr, oldState, newState, api, editorAnalyticsAPI, editorView) {
  var isTableScalingEnabled = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var isTableFixedColumnWidthsOptionEnabled = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var shouldUseIncreasedScalingPercent = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var oldSelection = oldState.tr.selection;
  var tr = newState.tr;
  if (oldSelection instanceof _cellSelection.CellSelection) {
    var $anchorCell = oldTr.doc.resolve(oldTr.mapping.map(oldSelection.$anchorCell.pos));
    var $headCell = oldTr.doc.resolve(oldTr.mapping.map(oldSelection.$headCell.pos));
    var cellSelection = new _cellSelection.CellSelection($anchorCell, $headCell);
    tr.setSelection(cellSelection);
    if (tr.selection instanceof _cellSelection.CellSelection) {
      var rect = (0, _utils3.getSelectionRect)(cellSelection);
      if (rect) {
        var _getSelectedCellInfo = (0, _analytics2.getSelectedCellInfo)(tr.selection),
          verticalCells = _getSelectedCellInfo.verticalCells,
          horizontalCells = _getSelectedCellInfo.horizontalCells,
          totalCells = _getSelectedCellInfo.totalCells,
          totalRowCount = _getSelectedCellInfo.totalRowCount,
          totalColumnCount = _getSelectedCellInfo.totalColumnCount;

        // Reassigning to make it more obvious and consistent
        editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
          action: _analytics.TABLE_ACTION.CUT,
          actionSubject: _analytics.ACTION_SUBJECT.TABLE,
          actionSubjectId: null,
          attributes: {
            verticalCells: verticalCells,
            horizontalCells: horizontalCells,
            totalCells: totalCells,
            totalRowCount: totalRowCount,
            totalColumnCount: totalColumnCount
          },
          eventType: _analytics.EVENT_TYPE.TRACK
        })(tr);

        // Need this check again since we are overriding the tr in previous statement
        if (tr.selection instanceof _cellSelection.CellSelection) {
          var isTableSelected = tr.selection.isRowSelection() && tr.selection.isColSelection();
          if (isTableSelected) {
            tr = (0, _utils3.removeTable)(tr);
          } else if (tr.selection.isRowSelection()) {
            var _getPluginState9 = (0, _pluginFactory2.getPluginState)(newState),
              isHeaderRowRequired = _getPluginState9.pluginConfig.isHeaderRowRequired;
            tr = (0, _deleteRows.deleteRows)(rect, isHeaderRowRequired)(tr);
          } else if (tr.selection.isColSelection()) {
            tr = (0, _deleteColumns.deleteColumns)(rect, (0, _getAllowAddColumnCustomStep.getAllowAddColumnCustomStep)(oldState), api, editorView, isTableScalingEnabled, isTableFixedColumnWidthsOptionEnabled, shouldUseIncreasedScalingPercent)(tr);
          }
        }
      }
    }
  }
  return tr;
};
var isTableInFocus = exports.isTableInFocus = function isTableInFocus(view) {
  var _getPluginState10, _getResizePluginState;
  return !!((_getPluginState10 = (0, _pluginFactory2.getPluginState)(view.state)) !== null && _getPluginState10 !== void 0 && _getPluginState10.tableNode) && !((_getResizePluginState = (0, _pluginFactory3.getPluginState)(view.state)) !== null && _getResizePluginState !== void 0 && _getResizePluginState.dragging);
};
var whenTableInFocus = exports.whenTableInFocus = function whenTableInFocus(eventHandler, pluginInjectionApi) {
  return function (view, mouseEvent) {
    var _pluginInjectionApi$e;
    if (!isTableInFocus(view)) {
      return false;
    }
    var isViewMode = (pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$e = pluginInjectionApi.editorViewMode) === null || _pluginInjectionApi$e === void 0 || (_pluginInjectionApi$e = _pluginInjectionApi$e.sharedState.currentState()) === null || _pluginInjectionApi$e === void 0 ? void 0 : _pluginInjectionApi$e.mode) === 'view';
    /**
     * Table cannot be in focus if we are in view mode.
     * This will prevent an infinite flow of adding and removing
     * resize handle decorations in view mode that causes unpredictable
     * selections.
     */
    if (isViewMode) {
      return false;
    }
    return eventHandler(view, mouseEvent);
  };
};
var trackCellLocation = function trackCellLocation(view, mouseEvent) {
  var _tableElement$dataset;
  var target = mouseEvent.target;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var maybeTableCell = (0, _utils.isElementInTableCell)(target);
  var _getPluginState11 = (0, _pluginFactory2.getPluginState)(view.state),
    tableNode = _getPluginState11.tableNode,
    tableRef = _getPluginState11.tableRef;

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var tableElement = (0, _utils.closestElement)(target, 'table');

  // hover will only trigger if target localId is the same with selected localId
  if (tableElement !== null && tableElement !== void 0 && (_tableElement$dataset = tableElement.dataset) !== null && _tableElement$dataset !== void 0 && _tableElement$dataset.tableLocalId && tableElement.dataset.tableLocalId !== (tableNode === null || tableNode === void 0 ? void 0 : tableNode.attrs.localId)) {
    return;
  }
  if (!maybeTableCell || !tableRef) {
    return;
  }
  var htmlColIndex = maybeTableCell.cellIndex;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var rowElement = (0, _utils.closestElement)(target, 'tr');
  var htmlRowIndex = rowElement && rowElement.rowIndex;
  var tableMap = tableNode && _tableMap.TableMap.get(tableNode);
  var colIndex = htmlColIndex;
  if (tableMap) {
    var convertedColIndex = (0, _columnControls.convertHTMLCellIndexToColumnIndex)(htmlColIndex, htmlRowIndex, tableMap);
    colIndex = (0, _columnControls.getColumnIndexMappedToColumnIndexInFirstRow)(convertedColIndex, htmlRowIndex, tableMap);
  }
  (0, _commands.hoverCell)(htmlRowIndex, colIndex)(view.state, view.dispatch);
};
var withCellTracking = exports.withCellTracking = function withCellTracking(eventHandler) {
  return function (view, mouseEvent) {
    if ((0, _pluginFactory2.getPluginState)(view.state).isDragAndDropEnabled && (0, _pluginFactory.getPluginState)(view.state) && !(0, _pluginFactory.getPluginState)(view.state).isDragging) {
      trackCellLocation(view, mouseEvent);
    }
    return eventHandler(view, mouseEvent);
  };
};