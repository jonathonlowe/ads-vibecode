"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DragHandleWithSharedState = exports.DragHandle = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _classnames2 = _interopRequireDefault(require("classnames"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _reactIntlNext = require("react-intl-next");
var _browser = require("@atlaskit/editor-common/browser");
var _hooks = require("@atlaskit/editor-common/hooks");
var _messages = require("@atlaskit/editor-common/messages");
var _state = require("@atlaskit/editor-prosemirror/state");
var _editorTables = require("@atlaskit/editor-tables");
var _adapter = require("@atlaskit/pragmatic-drag-and-drop/element/adapter");
var _setCustomNativeDragPreview = require("@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview");
var _pluginFactory = require("../../pm-plugins/drag-and-drop/plugin-factory");
var _pluginFactory2 = require("../../pm-plugins/plugin-factory");
var _mergedCells = require("../../pm-plugins/utils/merged-cells");
var _types = require("../../types");
var _consts = require("../consts");
var _DragPreview = require("../DragPreview");
var _HandleIconComponent = require("./HandleIconComponent");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/* eslint-disable @atlaskit/design-system/no-html-button */

var DragHandleComponent = function DragHandleComponent(_ref) {
  var isDragMenuTarget = _ref.isDragMenuTarget,
    tableLocalId = _ref.tableLocalId,
    _ref$direction = _ref.direction,
    direction = _ref$direction === void 0 ? 'row' : _ref$direction,
    _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'default' : _ref$appearance,
    indexes = _ref.indexes,
    _ref$forceDefaultHand = _ref.forceDefaultHandle,
    forceDefaultHandle = _ref$forceDefaultHand === void 0 ? false : _ref$forceDefaultHand,
    previewWidth = _ref.previewWidth,
    previewHeight = _ref.previewHeight,
    onMouseOver = _ref.onMouseOver,
    onMouseOut = _ref.onMouseOut,
    toggleDragMenu = _ref.toggleDragMenu,
    hoveredCell = _ref.hoveredCell,
    onClick = _ref.onClick,
    editorView = _ref.editorView,
    formatMessage = _ref.intl.formatMessage,
    hoveredColumns = _ref.hoveredColumns,
    hoveredRows = _ref.hoveredRows;
  var dragHandleDivRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(null),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    previewContainer = _useState2[0],
    setPreviewContainer = _useState2[1];
  var state = editorView.state,
    selection = editorView.state.selection;
  if (hoveredColumns === undefined || hoveredRows === undefined) {
    var _getPluginState = (0, _pluginFactory2.getPluginState)(state),
      hoveredColumnsState = _getPluginState.hoveredColumns,
      hoveredRowsState = _getPluginState.hoveredRows;
    hoveredColumns = hoveredColumnsState;
    hoveredRows = hoveredRowsState;
  }
  var _getDnDPluginState = (0, _pluginFactory.getPluginState)(state),
    _getDnDPluginState$is = _getDnDPluginState.isDragMenuOpen,
    isDragMenuOpen = _getDnDPluginState$is === void 0 ? false : _getDnDPluginState$is;
  var isRow = direction === 'row';
  var isColumn = direction === 'column';

  // Added !isDragMenuOpen check so when hover 'Delete column/row' from drag menu
  // the handle of the next column/row does not show the 'hovered' state icon
  var isRowHandleHovered = isRow && hoveredRows.length > 0 && !isDragMenuOpen;
  var isColumnHandleHovered = isColumn && hoveredColumns.length > 0 && !isDragMenuOpen;
  var hasMergedCells = (0, _react.useMemo)(function () {
    var table = (0, _editorTables.findTable)(selection);
    if (!table) {
      return false;
    }
    var map = _editorTables.TableMap.get(table === null || table === void 0 ? void 0 : table.node);
    if (!map.hasMergedCells() || indexes.length < 1) {
      return false;
    }
    var mapByColumn = map.mapByColumn,
      mapByRow = map.mapByRow;

    // this handle when hover to first column or row which has merged cells.
    if (hoveredCell && hoveredCell.rowIndex !== undefined && hoveredCell.colIndex !== undefined && selection instanceof _state.TextSelection) {
      var rowIndex = hoveredCell.rowIndex,
        colIndex = hoveredCell.colIndex;
      var mergedPositionInRow = (0, _mergedCells.findDuplicatePosition)(mapByRow[rowIndex]);
      var mergedPositionInCol = (0, _mergedCells.findDuplicatePosition)(mapByColumn[colIndex]);
      var hasMergedCellsInFirstRowOrColumn = direction === 'column' ? mergedPositionInRow.includes(mapByRow[0][colIndex]) : mergedPositionInCol.includes(mapByColumn[0][rowIndex]);
      var isHoveredOnFirstRowOrColumn = direction === 'column' ? hoveredCell.rowIndex === 0 && hasMergedCellsInFirstRowOrColumn : hoveredCell.colIndex === 0 && hasMergedCellsInFirstRowOrColumn;
      if (isHoveredOnFirstRowOrColumn) {
        var mergedSizes = direction === 'column' ? mapByRow[0].filter(function (el) {
          return el === mapByRow[0][colIndex];
        }).length : mapByColumn[0].filter(function (el) {
          return el === mapByColumn[0][rowIndex];
        }).length;
        var mergedSelection = (0, _mergedCells.hasMergedCellsInSelection)(direction === 'column' ? [colIndex, colIndex + mergedSizes - 1] : [rowIndex, rowIndex + mergedSizes - 1], direction)(selection);
        return mergedSelection;
      }
    }
    return (0, _mergedCells.hasMergedCellsInSelection)(indexes, direction)(selection);
  }, [indexes, selection, direction, hoveredCell]);
  var handleIconProps = {
    forceDefaultHandle: forceDefaultHandle,
    isHandleHovered: isColumnHandleHovered || isRowHandleHovered,
    hasMergedCells: hasMergedCells
  };
  (0, _react.useEffect)(function () {
    var dragHandleDivRefCurrent = dragHandleDivRef.current;
    if (dragHandleDivRefCurrent) {
      return (0, _adapter.draggable)({
        element: dragHandleDivRefCurrent,
        canDrag: function canDrag() {
          return !hasMergedCells;
        },
        getInitialData: function getInitialData() {
          return {
            localId: tableLocalId,
            type: "table-".concat(direction),
            indexes: indexes
          };
        },
        onGenerateDragPreview: function onGenerateDragPreview(_ref2) {
          var nativeSetDragImage = _ref2.nativeSetDragImage;
          (0, _setCustomNativeDragPreview.setCustomNativeDragPreview)({
            getOffset: function getOffset(_ref3) {
              var container = _ref3.container;
              var rect = container.getBoundingClientRect();
              if (_browser.browser.safari) {
                // See: https://product-fabric.atlassian.net/browse/ED-21442
                // We need to ensure that the preview is not overlaying screen content when the snapshot is taken, otherwise
                // safari will composite the screen text elements into the bitmap snapshot. The container is a wrapper which is already
                // positioned fixed at top/left 0.
                // IMPORTANT: we must not exceed more then the width of the container off-screen otherwise not preview will
                // be generated.
                container.style.left = "-".concat(rect.width - 0.0001, "px");
              }
              if (isRow) {
                return {
                  x: 12,
                  y: rect.height / 2
                };
              } else {
                return {
                  x: rect.width / 2 + 4,
                  y: 12
                };
              }
            },
            render: function render(_ref4) {
              var container = _ref4.container;
              setPreviewContainer(container);
              return function () {
                return setPreviewContainer(null);
              };
            },
            nativeSetDragImage: nativeSetDragImage
          });
        }
      });
    }
  }, [tableLocalId, direction, indexes, isRow, editorView.state.selection, hasMergedCells]);
  var showDragMenuAnchorId = isRow ? 'drag-handle-button-row' : 'drag-handle-button-column';
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("button", {
    type: "button"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: _types.TableCssClassName.DRAG_HANDLE_BUTTON_CLICKABLE_ZONE,
    "data-testid": "table-drag-handle-clickable-zone-button",
    style: {
      height: isRow ? // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      "calc(100% - ".concat(_consts.dragTableInsertColumnButtonSize, "px)") : "var(--ds-space-200, 16px)",
      // 16px here because it's the size of drag handle button's large side
      width: isRow ? "var(--ds-space-200, 16px)" // 16px here because it's the size of drag handle button's large side
      : // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      "calc(100% - ".concat(_consts.dragTableInsertColumnButtonSize, "px)"),
      left: isRow ? "var(--ds-space-050, 4px)" : undefined,
      bottom: isColumn ? "var(--ds-space-0, 0px)" : undefined,
      alignSelf: isColumn ? 'none' : 'center',
      zIndex: isColumn ? '-1' : 'auto',
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      pointerEvents: 'auto'
    },
    onMouseUp: function onMouseUp(e) {
      // should toggle menu if current drag menu open.
      // return focus to editor so copying table selections whilst still works, i cannot call e.preventDefault in a mousemove event as this stops dragstart events from firing
      // -> this is bad for a11y but is the current standard new copy/paste keyboard shortcuts should be introduced instead
      editorView.focus();
      if (isDragMenuOpen) {
        toggleDragMenu && toggleDragMenu('mouse', e);
      }
    },
    onClick: onClick
  }), /*#__PURE__*/_react.default.createElement("button", {
    type: "button",
    id: isDragMenuTarget ? showDragMenuAnchorId : undefined
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: (0, _classnames2.default)(_types.TableCssClassName.DRAG_HANDLE_BUTTON_CONTAINER, appearance, (0, _defineProperty2.default)({}, _types.TableCssClassName.DRAG_HANDLE_DISABLED, hasMergedCells)),
    ref: dragHandleDivRef,
    style: {
      transform: isColumn ? 'none' : 'rotate(90deg)',
      alignSelf: isColumn ? 'none' : 'center'
    },
    "data-testid": "table-drag-handle-button",
    "aria-label": formatMessage(isRow ? _messages.tableMessages.rowDragHandle : _messages.tableMessages.columnDragHandle),
    "aria-expanded": isDragMenuOpen && isDragMenuTarget ? 'true' : 'false',
    "aria-haspopup": "menu"
    // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
    ,
    onMouseOver: onMouseOver
    // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
    ,
    onMouseOut: onMouseOut,
    onMouseUp: function onMouseUp(e) {
      // return focus to editor so copying table selections whilst still works, i cannot call e.preventDefault in a mousemove event as this stops dragstart events from firing
      // -> this is bad for a11y but is the current standard new copy/paste keyboard shortcuts should be introduced instead
      editorView.focus();
      toggleDragMenu && toggleDragMenu('mouse', e);
    },
    onClick: onClick,
    onKeyDown: function onKeyDown(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        toggleDragMenu && toggleDragMenu('keyboard');
      }
    }
  }, appearance !== 'placeholder' ?
  //  cannot block pointer events in Firefox as it breaks Dragging functionality
  _browser.browser.gecko ?
  /*#__PURE__*/
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  _react.default.createElement(_HandleIconComponent.HandleIconComponent, handleIconProps) :
  /*#__PURE__*/
  // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
  _react.default.createElement("span", {
    style: {
      pointerEvents: 'none'
    }
  }, /*#__PURE__*/_react.default.createElement(_HandleIconComponent.HandleIconComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , handleIconProps)) : null), previewContainer && previewWidth !== undefined && previewHeight !== undefined && /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_react.default.createElement(_DragPreview.DragPreview, {
    direction: direction,
    width: previewWidth,
    height: previewHeight
  }), previewContainer));
};
var DragHandleComponentWithSharedState = function DragHandleComponentWithSharedState(_ref5) {
  var isDragMenuTarget = _ref5.isDragMenuTarget,
    tableLocalId = _ref5.tableLocalId,
    direction = _ref5.direction,
    appearance = _ref5.appearance,
    indexes = _ref5.indexes,
    forceDefaultHandle = _ref5.forceDefaultHandle,
    previewHeight = _ref5.previewHeight,
    previewWidth = _ref5.previewWidth,
    onMouseOver = _ref5.onMouseOver,
    onMouseOut = _ref5.onMouseOut,
    toggleDragMenu = _ref5.toggleDragMenu,
    hoveredCell = _ref5.hoveredCell,
    onClick = _ref5.onClick,
    editorView = _ref5.editorView,
    intl = _ref5.intl,
    api = _ref5.api;
  var _ref6 = (0, _hooks.useSharedPluginState)(api, ['table']),
    tableState = _ref6.tableState;
  return /*#__PURE__*/_react.default.createElement(DragHandleComponent, {
    isDragMenuTarget: isDragMenuTarget,
    tableLocalId: tableLocalId,
    direction: direction,
    appearance: appearance,
    indexes: indexes,
    forceDefaultHandle: forceDefaultHandle,
    previewWidth: previewWidth,
    previewHeight: previewHeight,
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    toggleDragMenu: toggleDragMenu,
    hoveredCell: hoveredCell,
    onClick: onClick,
    editorView: editorView,
    intl: intl,
    hoveredColumns: tableState === null || tableState === void 0 ? void 0 : tableState.hoveredColumns,
    hoveredRows: tableState === null || tableState === void 0 ? void 0 : tableState.hoveredRows
  });
};
var DragHandle = exports.DragHandle = (0, _reactIntlNext.injectIntl)(DragHandleComponent);
var DragHandleWithSharedState = exports.DragHandleWithSharedState = (0, _reactIntlNext.injectIntl)(DragHandleComponentWithSharedState);