import React, { useEffect } from 'react';
import { tableCell, tableCellWithNestedTable, tableHeader, tableHeaderWithNestedTable, tableRow, tableRowWithNestedTable } from '@atlaskit/adf-schema';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD, TABLE_ACTION } from '@atlaskit/editor-common/analytics';
import { browser } from '@atlaskit/editor-common/browser';
import { ErrorBoundary } from '@atlaskit/editor-common/error-boundary';
import { getDomRefFromSelection } from '@atlaskit/editor-common/get-dom-ref-from-selection';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { IconTable } from '@atlaskit/editor-common/icons';
import { toggleTable, tooltip } from '@atlaskit/editor-common/keymaps';
import { toolbarInsertBlockMessages as messages } from '@atlaskit/editor-common/messages';
import { getParentOfTypeCount, getPositionAfterTopParentNodeOfType } from '@atlaskit/editor-common/nesting';
import { editorCommandToPMCommand } from '@atlaskit/editor-common/preset';
import { ResizerBreakoutModeLabel } from '@atlaskit/editor-common/resizer';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { WithPluginState } from '@atlaskit/editor-common/with-plugin-state';
import { hasParentNodeOfType, safeInsert } from '@atlaskit/editor-prosemirror/utils';
import { akEditorFloatingPanelZIndex } from '@atlaskit/editor-shared-styles';
import { tableEditing } from '@atlaskit/editor-tables/pm-plugins';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { tableNodeSpecWithFixedToDOM } from './nodeviews/toDOM';
import { createPlugin as createTableAnalyticsPlugin } from './pm-plugins/analytics/plugin';
import { pluginKey as tableAnalyticsPluginKey } from './pm-plugins/analytics/plugin-key';
import { insertTableWithNestingSupport, insertTableWithSize } from './pm-plugins/commands/insert';
import { pluginConfig } from './pm-plugins/create-plugin-config';
import { createPlugin as createDecorationsPlugin } from './pm-plugins/decorations/plugin';
import { createPlugin as createDragAndDropPlugin } from './pm-plugins/drag-and-drop/plugin';
import { pluginKey as dragAndDropPluginKey } from './pm-plugins/drag-and-drop/plugin-key';
import { keymapPlugin } from './pm-plugins/keymap';
import { createPlugin } from './pm-plugins/main';
import { pluginKey } from './pm-plugins/plugin-key';
import { createPlugin as createTableSafariDeleteCompositionTextIssueWorkaroundPlugin } from './pm-plugins/safari-delete-composition-text-issue-workaround';
import { createPlugin as createStickyHeadersPlugin } from './pm-plugins/sticky-headers/plugin';
import { pluginKey as stickyHeadersPluginKey } from './pm-plugins/sticky-headers/plugin-key';
import { findStickyHeaderForTable } from './pm-plugins/sticky-headers/util';
import { createPlugin as createTableOverflowAnalyticsPlugin } from './pm-plugins/table-analytics';
import { createPlugin as createTableLocalIdPlugin } from './pm-plugins/table-local-id';
import { createPlugin as createFlexiResizingPlugin } from './pm-plugins/table-resizing/plugin';
import { getPluginState as getFlexiResizingPlugin } from './pm-plugins/table-resizing/plugin-factory';
import { pluginKey as tableResizingPluginKey } from './pm-plugins/table-resizing/plugin-key';
import { tableSelectionKeymapPlugin } from './pm-plugins/table-selection-keymap';
import { createPlugin as createSizeSelectorPlugin, pluginKey as sizeSelectorPluginKey } from './pm-plugins/table-size-selector';
import { createPlugin as createTableWidthPlugin, pluginKey as tableWidthPluginKey } from './pm-plugins/table-width';
import { createPlugin as createTableWidthInCommentFixPlugin } from './pm-plugins/table-width-in-comment-fix';
import { createTableWithWidth } from './pm-plugins/utils/create';
import { createPlugin as createViewModeSortPlugin } from './pm-plugins/view-mode-sort';
import { ContentComponent } from './ui/ContentComponent';
import FloatingContextualButton from './ui/FloatingContextualButton';
import FloatingContextualMenu from './ui/FloatingContextualMenu';
import FloatingDeleteButton from './ui/FloatingDeleteButton';
import FloatingDragMenu from './ui/FloatingDragMenu';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import FloatingInsertButton from './ui/FloatingInsertButton';
import { FloatingToolbarLabel } from './ui/FloatingToolbarLabel/FloatingToolbarLabel';
import { GlobalStylesWrapper } from './ui/global-styles';
import { SizeSelector } from './ui/SizeSelector';
import { FullWidthDisplay } from './ui/TableFullWidthLabel';
import { getToolbarConfig } from './ui/toolbar';
const defaultGetEditorFeatureFlags = () => ({});

/**
 * Table plugin to be added to an `EditorPresetBuilder` and used with `ComposableEditor`
 * from `@atlaskit/editor-core`.
 */
const tablePlugin = ({
  config: options,
  api
}) => {
  var _api$analytics, _api$accessibilityUti, _options$getEditorFea, _options$getEditorFea2, _api$analytics2;
  const editorViewRef = {
    current: null
  };
  const defaultGetEditorContainerWidth = () => {
    var _api$width$sharedStat, _api$width, _document$body$offset, _document, _document$body;
    return (_api$width$sharedStat = api === null || api === void 0 ? void 0 : (_api$width = api.width) === null || _api$width === void 0 ? void 0 : _api$width.sharedState.currentState()) !== null && _api$width$sharedStat !== void 0 ? _api$width$sharedStat : {
      width: (_document$body$offset = (_document = document) === null || _document === void 0 ? void 0 : (_document$body = _document.body) === null || _document$body === void 0 ? void 0 : _document$body.offsetWidth) !== null && _document$body$offset !== void 0 ? _document$body$offset : 500
    };
  };
  const editorAnalyticsAPI = api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions;
  const ariaNotifyPlugin = api === null || api === void 0 ? void 0 : (_api$accessibilityUti = api.accessibilityUtils) === null || _api$accessibilityUti === void 0 ? void 0 : _api$accessibilityUti.actions.ariaNotify;
  const isTableFixedColumnWidthsOptionEnabled = (options === null || options === void 0 ? void 0 : (_options$getEditorFea = options.getEditorFeatureFlags) === null || _options$getEditorFea === void 0 ? void 0 : _options$getEditorFea.call(options).tableWithFixedColumnWidthsOption) || false;
  const shouldUseIncreasedScalingPercent = (options === null || options === void 0 ? void 0 : options.isTableScalingEnabled) && (isTableFixedColumnWidthsOptionEnabled || ( // When in comment editor, we need the scaling percent to be 40% while tableWithFixedColumnWidthsOption is not visible
  options === null || options === void 0 ? void 0 : options.isCommentEditor));
  const isTableSelectorEnabled =
  // eslint-disable-next-line @atlaskit/platform/no-preconditioning
  !(options !== null && options !== void 0 && options.isChromelessEditor) && !(options !== null && options !== void 0 && options.isCommentEditor) && (options === null || options === void 0 ? void 0 : (_options$getEditorFea2 = options.getEditorFeatureFlags) === null || _options$getEditorFea2 === void 0 ? void 0 : _options$getEditorFea2.call(options).tableSelector) && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_table_picker');
  return {
    name: 'table',
    // Use getSharedState to store fullWidthEnabled and wasFullWidthModeEnabled to guarantee access
    // to most up to date values - passing to createPluginState will not re-initialise the state
    getSharedState: editorState => {
      var _tablePluginState$tab, _tableWidthResizingPl;
      if (!editorState) {
        return undefined;
      }

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const tablePluginState = pluginKey.getState(editorState);
      const tableResizingPluginState = getFlexiResizingPlugin(editorState);
      const tableWidthResizingPluginState = tableWidthPluginKey.getState(editorState);
      const stickyHeadersState = stickyHeadersPluginKey.getState(editorState);
      const stickyHeader = stickyHeadersState ? findStickyHeaderForTable(stickyHeadersState, tablePluginState === null || tablePluginState === void 0 ? void 0 : tablePluginState.tablePos) : undefined;
      const dragAndDropState = dragAndDropPluginKey.getState(editorState);
      const sharedStateInternal = {
        isFullWidthModeEnabled: !!(options !== null && options !== void 0 && options.fullWidthEnabled),
        wasFullWidthModeEnabled: !!(options !== null && options !== void 0 && options.wasFullWidthEnabled),
        isHeaderRowEnabled: tablePluginState.isHeaderRowEnabled,
        isHeaderColumnEnabled: tablePluginState.isHeaderColumnEnabled,
        ordering: tablePluginState.ordering,
        isResizing: !!(tableResizingPluginState !== null && tableResizingPluginState !== void 0 && tableResizingPluginState.dragging || tableWidthResizingPluginState !== null && tableWidthResizingPluginState !== void 0 && tableWidthResizingPluginState.resizing),
        isTableResizing: tableWidthResizingPluginState === null || tableWidthResizingPluginState === void 0 ? void 0 : tableWidthResizingPluginState.resizing,
        isInDanger: tablePluginState.isInDanger,
        hoveredRows: tablePluginState.hoveredRows,
        hoveredColumns: tablePluginState.hoveredColumns,
        hoveredCell: tablePluginState.hoveredCell,
        isTableHovered: tablePluginState.isTableHovered,
        isWholeTableInDanger: tablePluginState.isWholeTableInDanger,
        // IMPORTANT: Need to continue to pass tableNode to control re-renders
        // TableComponent listens for node attribute changes to update colgroups
        tableNode: tablePluginState.tableNode,
        widthToWidest: tablePluginState.widthToWidest,
        resizingTableLocalId: tableWidthResizingPluginState === null || tableWidthResizingPluginState === void 0 ? void 0 : tableWidthResizingPluginState.tableLocalId,
        tableRef: (_tablePluginState$tab = tablePluginState === null || tablePluginState === void 0 ? void 0 : tablePluginState.tableRef) !== null && _tablePluginState$tab !== void 0 ? _tablePluginState$tab : undefined,
        resizingTableRef: (_tableWidthResizingPl = tableWidthResizingPluginState === null || tableWidthResizingPluginState === void 0 ? void 0 : tableWidthResizingPluginState.tableRef) !== null && _tableWidthResizingPl !== void 0 ? _tableWidthResizingPl : undefined,
        tablePos: tablePluginState.tablePos,
        targetCellPosition: tablePluginState.targetCellPosition,
        isContextualMenuOpen: tablePluginState.isContextualMenuOpen,
        pluginConfig: tablePluginState.pluginConfig,
        insertColumnButtonIndex: tablePluginState.insertColumnButtonIndex,
        insertRowButtonIndex: tablePluginState.insertRowButtonIndex,
        isDragAndDropEnabled: tablePluginState.isDragAndDropEnabled,
        tableWrapperTarget: tablePluginState.tableWrapperTarget,
        isCellMenuOpenByKeyboard: tablePluginState.isCellMenuOpenByKeyboard,
        stickyHeader,
        dragMenuDirection: dragAndDropState === null || dragAndDropState === void 0 ? void 0 : dragAndDropState.dragMenuDirection,
        dragMenuIndex: dragAndDropState === null || dragAndDropState === void 0 ? void 0 : dragAndDropState.dragMenuIndex,
        isDragMenuOpen: dragAndDropState === null || dragAndDropState === void 0 ? void 0 : dragAndDropState.isDragMenuOpen
      };
      return sharedStateInternal;
    },
    actions: {
      insertTable: analyticsPayload => (state, dispatch) => {
        var _options$tableOptions;
        if (options !== null && options !== void 0 && (_options$tableOptions = options.tableOptions) !== null && _options$tableOptions !== void 0 && _options$tableOptions.allowNestedTables && fg('platform_editor_use_nested_table_pm_nodes')) {
          return editorCommandToPMCommand(insertTableWithNestingSupport({
            isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
            isTableAlignmentEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableAlignment,
            isFullWidthModeEnabled: options === null || options === void 0 ? void 0 : options.fullWidthEnabled,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor,
            isChromelessEditor: options === null || options === void 0 ? void 0 : options.isChromelessEditor,
            isTableResizingEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing
          }, api, analyticsPayload))(state, dispatch);
        } else {
          var _api$contentInsertion, _api$contentInsertion2, _api$contentInsertion3;
          const node = createTableWithWidth({
            isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
            isTableAlignmentEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableAlignment,
            isFullWidthModeEnabled: options === null || options === void 0 ? void 0 : options.fullWidthEnabled,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor,
            isChromelessEditor: options === null || options === void 0 ? void 0 : options.isChromelessEditor,
            isTableResizingEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing
          })(state.schema);
          return (_api$contentInsertion = api === null || api === void 0 ? void 0 : (_api$contentInsertion2 = api.contentInsertion) === null || _api$contentInsertion2 === void 0 ? void 0 : (_api$contentInsertion3 = _api$contentInsertion2.actions) === null || _api$contentInsertion3 === void 0 ? void 0 : _api$contentInsertion3.insert({
            state,
            dispatch,
            node,
            options: {
              selectNodeInserted: false,
              analyticsPayload: {
                ...analyticsPayload,
                attributes: {
                  ...analyticsPayload.attributes,
                  localId: node.attrs.localId
                }
              }
            }
          })) !== null && _api$contentInsertion !== void 0 ? _api$contentInsertion : false;
        }
      }
    },
    commands: {
      insertTableWithSize: fg('platform_editor_use_nested_table_pm_nodes') ? (rowsCount, colsCount, inputMethod) => insertTableWithNestingSupport({
        isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
        isTableAlignmentEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableAlignment,
        isFullWidthModeEnabled: options === null || options === void 0 ? void 0 : options.fullWidthEnabled,
        isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor,
        isChromelessEditor: options === null || options === void 0 ? void 0 : options.isChromelessEditor,
        isTableResizingEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing,
        createTableProps: {
          rowsCount,
          colsCount
        }
      }, api, {
        action: ACTION.INSERTED,
        actionSubject: ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: ACTION_SUBJECT_ID.TABLE,
        attributes: {
          inputMethod: inputMethod !== null && inputMethod !== void 0 ? inputMethod : INPUT_METHOD.PICKER,
          totalRowCount: rowsCount,
          totalColumnCount: colsCount
        },
        eventType: EVENT_TYPE.TRACK
      }) : insertTableWithSize(options === null || options === void 0 ? void 0 : options.fullWidthEnabled, options === null || options === void 0 ? void 0 : options.isTableScalingEnabled, options === null || options === void 0 ? void 0 : options.tableOptions.allowTableAlignment, api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, options === null || options === void 0 ? void 0 : options.isCommentEditor)
    },
    nodes() {
      var _options$tableOptions2;
      const {
        allowColumnResizing
      } = pluginConfig(options === null || options === void 0 ? void 0 : options.tableOptions);
      // TODO: ED-25901 - We need to move this into a plugin config option so we don't accidentally enable nested nodes in Jira
      const isNestingSupported = Boolean(options === null || options === void 0 ? void 0 : (_options$tableOptions2 = options.tableOptions) === null || _options$tableOptions2 === void 0 ? void 0 : _options$tableOptions2.allowNestedTables);
      return isNestingSupported ? [{
        name: 'table',
        node: tableNodeSpecWithFixedToDOM({
          allowColumnResizing: Boolean(allowColumnResizing),
          tableResizingEnabled: Boolean(options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing),
          getEditorContainerWidth: defaultGetEditorContainerWidth,
          isNestingSupported
        })
      }, {
        name: 'tableHeader',
        node: tableHeaderWithNestedTable
      }, {
        name: 'tableRow',
        node: tableRowWithNestedTable
      }, {
        name: 'tableCell',
        node: tableCellWithNestedTable
      }] : [{
        name: 'table',
        node: tableNodeSpecWithFixedToDOM({
          allowColumnResizing: Boolean(allowColumnResizing),
          tableResizingEnabled: Boolean(options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing),
          getEditorContainerWidth: defaultGetEditorContainerWidth,
          isNestingSupported
        })
      }, {
        name: 'tableHeader',
        node: tableHeader
      }, {
        name: 'tableRow',
        node: tableRow
      }, {
        name: 'tableCell',
        node: tableCell
      }];
    },
    pmPlugins() {
      const plugins = [{
        name: 'table',
        plugin: ({
          dispatchAnalyticsEvent,
          dispatch,
          portalProviderAPI,
          nodeViewPortalProviderAPI,
          eventDispatcher,
          getIntl
        }) => {
          const {
            fullWidthEnabled,
            wasFullWidthEnabled,
            tableOptions,
            getEditorFeatureFlags,
            dragAndDropEnabled,
            isTableScalingEnabled,
            isCommentEditor,
            isChromelessEditor
          } = options || {};
          return createPlugin(dispatchAnalyticsEvent, dispatch, portalProviderAPI, nodeViewPortalProviderAPI, eventDispatcher, pluginConfig(tableOptions), defaultGetEditorContainerWidth, getEditorFeatureFlags || defaultGetEditorFeatureFlags, getIntl, fullWidthEnabled, wasFullWidthEnabled, dragAndDropEnabled, editorAnalyticsAPI, api, isTableScalingEnabled, shouldUseIncreasedScalingPercent, isCommentEditor, isChromelessEditor);
        }
      }, {
        name: 'tablePMColResizing',
        plugin: ({
          dispatch,
          nodeViewPortalProviderAPI
        }) => {
          const {
            fullWidthEnabled,
            tableOptions,
            getEditorFeatureFlags,
            isTableScalingEnabled
          } = options || {};
          const {
            allowColumnResizing
          } = pluginConfig(tableOptions);
          return allowColumnResizing ? createFlexiResizingPlugin(dispatch, {
            lastColumnResizable: !fullWidthEnabled
          }, defaultGetEditorContainerWidth, getEditorFeatureFlags || defaultGetEditorFeatureFlags, api, nodeViewPortalProviderAPI, editorAnalyticsAPI, isTableScalingEnabled || false, !!(options !== null && options !== void 0 && options.isCommentEditor)) : undefined;
        }
      }, {
        name: 'tableEditing',
        plugin: () => createDecorationsPlugin()
      },
      // Needs to be lower priority than editor-tables.tableEditing
      // plugin as it is currently swallowing backspace events inside tables
      {
        name: 'tableKeymap',
        plugin: ({
          getIntl,
          nodeViewPortalProviderAPI
        }) => {
          const {
            dragAndDropEnabled,
            isTableScalingEnabled = false,
            fullWidthEnabled = false,
            isCommentEditor = false,
            isChromelessEditor = false,
            tableOptions
          } = options || {};
          return keymapPlugin(defaultGetEditorContainerWidth, api, nodeViewPortalProviderAPI, editorAnalyticsAPI, dragAndDropEnabled, isTableScalingEnabled, tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.allowTableAlignment, fullWidthEnabled, api, getIntl, isTableFixedColumnWidthsOptionEnabled, shouldUseIncreasedScalingPercent, isCommentEditor, isChromelessEditor, tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.allowTableResizing);
        }
      }, {
        name: 'tableSelectionKeymap',
        plugin: ({
          getIntl
        }) => tableSelectionKeymapPlugin(api, getIntl)
      }, {
        name: 'tableEditing',
        plugin: () => {
          const {
            dragAndDropEnabled
          } = options || {};
          return tableEditing({
            reportFixedTable: ({
              tr,
              reason
            }) => {
              editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 ? void 0 : editorAnalyticsAPI.attachAnalyticsEvent({
                action: TABLE_ACTION.FIXED,
                actionSubject: ACTION_SUBJECT.TABLE,
                actionSubjectId: null,
                attributes: {
                  reason
                },
                eventType: EVENT_TYPE.TRACK
              })(tr);
            },
            dragAndDropEnabled
          });
        }
      }, {
        name: 'tableStickyHeaders',
        plugin: ({
          dispatch,
          eventDispatcher
        }) => options && options.tableOptions.stickyHeaders ? createStickyHeadersPlugin(dispatch, () => []) : undefined
      }, {
        name: 'tableDragAndDrop',
        plugin: ({
          dispatch
        }) => {
          return options !== null && options !== void 0 && options.dragAndDropEnabled ? createDragAndDropPlugin(dispatch, editorAnalyticsAPI, options === null || options === void 0 ? void 0 : options.isTableScalingEnabled, isTableFixedColumnWidthsOptionEnabled, options.isCommentEditor) : undefined;
        }
      }, {
        name: 'tableViewModeSort',
        plugin: ({
          nodeViewPortalProviderAPI
        }) => {
          return api !== null && api !== void 0 && api.editorViewMode ? createViewModeSortPlugin(api, nodeViewPortalProviderAPI) : undefined;
        }
      }, {
        name: 'tableLocalId',
        plugin: ({
          dispatch
        }) => createTableLocalIdPlugin(dispatch)
      }, {
        name: 'tableWidth',
        plugin: ({
          dispatchAnalyticsEvent,
          dispatch
        }) => {
          var _options$fullWidthEna, _options$isTableScali, _options$tableOptions3, _options$isCommentEdi;
          return options !== null && options !== void 0 && options.tableOptions.allowTableResizing ? createTableWidthPlugin(dispatch, dispatchAnalyticsEvent, (_options$fullWidthEna = options.fullWidthEnabled) !== null && _options$fullWidthEna !== void 0 ? _options$fullWidthEna : false, (_options$isTableScali = options.isTableScalingEnabled) !== null && _options$isTableScali !== void 0 ? _options$isTableScali : false, (_options$tableOptions3 = options.tableOptions.allowTableResizing) !== null && _options$tableOptions3 !== void 0 ? _options$tableOptions3 : false, (_options$isCommentEdi = options.isCommentEditor) !== null && _options$isCommentEdi !== void 0 ? _options$isCommentEdi : false) : undefined;
        }
      }, {
        name: 'tableWidthInCommentFix',
        plugin: ({
          dispatch
        }) => {
          var _options$tableOptions4;
          return options !== null && options !== void 0 && options.tableOptions.allowTableResizing && options !== null && options !== void 0 && options.isCommentEditor ? createTableWidthInCommentFixPlugin(dispatch, (_options$tableOptions4 = options.tableOptions.allowTableAlignment) !== null && _options$tableOptions4 !== void 0 ? _options$tableOptions4 : false) : undefined;
        }
      },
      // TODO: ED-26961 - should be deprecated and eventually replaced with 'tableAnalyticsPlugin'
      {
        name: 'tableOverflowAnalyticsPlugin',
        plugin: ({
          dispatch,
          dispatchAnalyticsEvent
        }) => {
          var _options$tableOptions5;
          return createTableOverflowAnalyticsPlugin(dispatch, dispatchAnalyticsEvent, (_options$tableOptions5 = options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing) !== null && _options$tableOptions5 !== void 0 ? _options$tableOptions5 : false);
        }
      }, {
        name: 'tableAnalyticsPlugin',
        plugin: ({
          dispatch,
          dispatchAnalyticsEvent
        }) => createTableAnalyticsPlugin(dispatch, dispatchAnalyticsEvent)
      }, {
        name: 'tableGetEditorViewReferencePlugin',
        plugin: () => {
          return new SafePlugin({
            view: editorView => {
              editorViewRef.current = editorView;
              return {
                destroy: () => {
                  editorViewRef.current = null;
                }
              };
            }
          });
        }
      }, {
        name: 'tableSizeSelectorPlugin',
        plugin: ({
          dispatch
        }) => isTableSelectorEnabled ? createSizeSelectorPlugin(dispatch) : undefined
      }];

      // Workaround for table element breaking issue caused by composition event with an inputType of deleteCompositionText.
      // https://github.com/ProseMirror/prosemirror/issues/934
      if (browser.safari) {
        plugins.push({
          name: 'tableSafariDeleteCompositionTextIssueWorkaround',
          plugin: () => {
            return createTableSafariDeleteCompositionTextIssueWorkaroundPlugin();
          }
        });
      }
      return plugins;
    },
    contentComponent({
      editorView,
      popupsMountPoint,
      popupsBoundariesElement,
      popupsScrollableElement,
      dispatchAnalyticsEvent
    }) {
      var _api$featureFlags;
      if (editorExperiment('platform_editor_usesharedpluginstateselector', true)) {
        return /*#__PURE__*/React.createElement(ContentComponent, {
          api: api,
          editorView: editorView,
          dispatchAnalyticsEvent: dispatchAnalyticsEvent,
          options: options,
          popupsMountPoint: popupsMountPoint,
          popupsBoundariesElement: popupsBoundariesElement,
          popupsScrollableElement: popupsScrollableElement,
          defaultGetEditorContainerWidth: defaultGetEditorContainerWidth,
          defaultGetEditorFeatureFlags: defaultGetEditorFeatureFlags
        });
      }
      return /*#__PURE__*/React.createElement(ErrorBoundary, {
        component: ACTION_SUBJECT.TABLES_PLUGIN,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent,
        fallbackComponent: null
      }, /*#__PURE__*/React.createElement(GlobalStylesWrapper, {
        featureFlags: api === null || api === void 0 ? void 0 : (_api$featureFlags = api.featureFlags) === null || _api$featureFlags === void 0 ? void 0 : _api$featureFlags.sharedState.currentState(),
        isDragAndDropEnabledOption: options === null || options === void 0 ? void 0 : options.dragAndDropEnabled,
        api: api
      }), /*#__PURE__*/React.createElement(WithPluginState, {
        plugins: {
          tableAnalyticsPluginState: tableAnalyticsPluginKey,
          tablePluginState: pluginKey,
          tableWidthPluginState: tableWidthPluginKey,
          tableResizingPluginState: tableResizingPluginKey,
          stickyHeadersState: stickyHeadersPluginKey,
          dragAndDropState: dragAndDropPluginKey,
          sizeSelectorPluginState: sizeSelectorPluginKey
        },
        render: ({
          tableResizingPluginState: resizingPluginState,
          stickyHeadersState,
          tablePluginState,
          tableWidthPluginState,
          dragAndDropState,
          sizeSelectorPluginState
        }) => {
          var _sizeSelectorPluginSt, _api$analytics3;
          const isColumnResizing = resizingPluginState === null || resizingPluginState === void 0 ? void 0 : resizingPluginState.dragging;
          const isTableResizing = tableWidthPluginState === null || tableWidthPluginState === void 0 ? void 0 : tableWidthPluginState.resizing;
          const resizingTableLocalId = tableWidthPluginState === null || tableWidthPluginState === void 0 ? void 0 : tableWidthPluginState.tableLocalId;
          const resizingTableRef = tableWidthPluginState === null || tableWidthPluginState === void 0 ? void 0 : tableWidthPluginState.tableRef;
          const isResizing = isColumnResizing || isTableResizing;
          const widthToWidest = tablePluginState === null || tablePluginState === void 0 ? void 0 : tablePluginState.widthToWidest;
          const isSizeSelectorOpen = sizeSelectorPluginState === null || sizeSelectorPluginState === void 0 ? void 0 : sizeSelectorPluginState.isSelectorOpen;
          const {
            tableNode,
            tablePos,
            targetCellPosition,
            isContextualMenuOpen,
            tableRef,
            pluginConfig,
            insertColumnButtonIndex,
            insertRowButtonIndex,
            isHeaderColumnEnabled,
            isHeaderRowEnabled,
            isDragAndDropEnabled,
            tableWrapperTarget,
            isCellMenuOpenByKeyboard
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = tablePluginState;
          const {
            allowControls
          } = pluginConfig;
          const stickyHeader = stickyHeadersState ? findStickyHeaderForTable(stickyHeadersState, tablePos) : undefined;
          return /*#__PURE__*/React.createElement(React.Fragment, null, targetCellPosition && (tableRef || isCellMenuOpenByKeyboard) && !isResizing && options && options.allowContextualMenu && /*#__PURE__*/React.createElement(FloatingContextualButton, {
            isNumberColumnEnabled: tableNode && tableNode.attrs.isNumberColumnEnabled,
            editorView: editorView,
            tableNode: tableNode,
            mountPoint: popupsMountPoint,
            targetCellPosition: targetCellPosition,
            scrollableElement: popupsScrollableElement,
            dispatchAnalyticsEvent: dispatchAnalyticsEvent,
            isContextualMenuOpen: isContextualMenuOpen,
            stickyHeader: stickyHeader,
            tableWrapper: tableWrapperTarget,
            isCellMenuOpenByKeyboard: isCellMenuOpenByKeyboard
          }), allowControls && /*#__PURE__*/React.createElement(FloatingInsertButton, {
            tableNode: tableNode,
            tableRef: tableRef,
            insertColumnButtonIndex: insertColumnButtonIndex,
            insertRowButtonIndex: insertRowButtonIndex,
            isHeaderColumnEnabled: isHeaderColumnEnabled,
            isHeaderRowEnabled: isHeaderRowEnabled,
            isDragAndDropEnabled: isDragAndDropEnabled,
            isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
            editorView: editorView,
            mountPoint: popupsMountPoint,
            boundariesElement: popupsBoundariesElement,
            scrollableElement: popupsScrollableElement,
            hasStickyHeaders: stickyHeader && stickyHeader.sticky,
            dispatchAnalyticsEvent: dispatchAnalyticsEvent,
            editorAnalyticsAPI: editorAnalyticsAPI,
            getEditorContainerWidth: defaultGetEditorContainerWidth,
            getEditorFeatureFlags: (options === null || options === void 0 ? void 0 : options.getEditorFeatureFlags) || defaultGetEditorFeatureFlags,
            isChromelessEditor: options === null || options === void 0 ? void 0 : options.isChromelessEditor,
            api: api,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor
          }), (options === null || options === void 0 ? void 0 : options.allowContextualMenu) && /*#__PURE__*/React.createElement(FloatingContextualMenu, {
            editorView: editorView,
            mountPoint: popupsMountPoint,
            boundariesElement: popupsBoundariesElement,
            targetCellPosition: targetCellPosition,
            isOpen: Boolean(isContextualMenuOpen) && !isResizing,
            pluginConfig: pluginConfig,
            editorAnalyticsAPI: editorAnalyticsAPI,
            getEditorContainerWidth: defaultGetEditorContainerWidth,
            getEditorFeatureFlags: (options === null || options === void 0 ? void 0 : options.getEditorFeatureFlags) || defaultGetEditorFeatureFlags,
            isCellMenuOpenByKeyboard: isCellMenuOpenByKeyboard,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor,
            api: api
          }), isDragAndDropEnabled && /*#__PURE__*/React.createElement(FloatingDragMenu, {
            editorView: editorView,
            mountPoint: popupsMountPoint,
            boundariesElement: popupsBoundariesElement,
            tableRef: tableRef,
            tableNode: tableNode,
            targetCellPosition: targetCellPosition,
            direction: dragAndDropState === null || dragAndDropState === void 0 ? void 0 : dragAndDropState.dragMenuDirection,
            index: dragAndDropState === null || dragAndDropState === void 0 ? void 0 : dragAndDropState.dragMenuIndex,
            isOpen: !!(dragAndDropState !== null && dragAndDropState !== void 0 && dragAndDropState.isDragMenuOpen) && !isResizing,
            getEditorContainerWidth: defaultGetEditorContainerWidth,
            editorAnalyticsAPI: editorAnalyticsAPI,
            stickyHeaders: stickyHeader,
            pluginConfig: pluginConfig,
            isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
            getEditorFeatureFlags: (options === null || options === void 0 ? void 0 : options.getEditorFeatureFlags) || defaultGetEditorFeatureFlags,
            ariaNotifyPlugin: ariaNotifyPlugin,
            api: api,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor
          }), allowControls && !isDragAndDropEnabled && !isResizing && /*#__PURE__*/React.createElement(FloatingDeleteButton, {
            editorView: editorView,
            selection: editorView.state.selection,
            tableRef: tableRef,
            mountPoint: popupsMountPoint,
            boundariesElement: popupsBoundariesElement,
            scrollableElement: popupsScrollableElement,
            stickyHeaders: stickyHeader,
            isNumberColumnEnabled: tableNode && tableNode.attrs.isNumberColumnEnabled,
            editorAnalyticsAPI: editorAnalyticsAPI,
            api: api
          }), ((options === null || options === void 0 ? void 0 : options.isTableScalingEnabled) || (options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing) && options.isCommentEditor) && isTableResizing && widthToWidest && resizingTableLocalId && resizingTableRef && widthToWidest[resizingTableLocalId] && /*#__PURE__*/React.createElement(FloatingToolbarLabel, {
            target: resizingTableRef,
            content: editorExperiment('single_column_layouts', true) ? /*#__PURE__*/React.createElement(ResizerBreakoutModeLabel, {
              layout: "full-width"
            }) : /*#__PURE__*/React.createElement(FullWidthDisplay, null),
            alignX: 'center',
            alignY: 'bottom',
            stick: true,
            forcePlacement: true,
            zIndex: akEditorFloatingPanelZIndex,
            offset: [0, 10]
          }), isTableSelectorEnabled && isSizeSelectorOpen && /*#__PURE__*/React.createElement(SizeSelector, {
            api: api,
            isOpenedByKeyboard: false,
            popupsMountPoint: popupsMountPoint,
            target: (_sizeSelectorPluginSt = sizeSelectorPluginState === null || sizeSelectorPluginState === void 0 ? void 0 : sizeSelectorPluginState.targetRef) !== null && _sizeSelectorPluginSt !== void 0 ? _sizeSelectorPluginSt : getDomRefFromSelection(editorView, ACTION_SUBJECT_ID.PICKER_TABLE_SIZE, api === null || api === void 0 ? void 0 : (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions.fireAnalyticsEvent),
            popupsBoundariesElement: popupsBoundariesElement,
            popupsScrollableElement: popupsScrollableElement
          }));
        }
      }));
    },
    pluginsOptions: {
      quickInsert: ({
        formatMessage
      }) => [{
        id: 'table',
        title: formatMessage(messages.table),
        description: formatMessage(messages.tableDescription),
        keywords: ['cell', 'table'],
        priority: 600,
        keyshortcut: tooltip(toggleTable),
        icon: () => /*#__PURE__*/React.createElement(IconTable, null),
        action(insert, state) {
          var _api$table, _options$tableOptions6;
          if (isTableSelectorEnabled) {
            const tr = insert('');
            tr.setMeta(sizeSelectorPluginKey, {
              isSelectorOpen: true
            });
            return tr;
          }

          // see comment on tablesPlugin.getSharedState on usage
          const tableState = api === null || api === void 0 ? void 0 : (_api$table = api.table) === null || _api$table === void 0 ? void 0 : _api$table.sharedState.currentState();
          const tableNodeProps = {
            isTableScalingEnabled: options === null || options === void 0 ? void 0 : options.isTableScalingEnabled,
            isTableAlignmentEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableAlignment,
            isFullWidthModeEnabled: tableState === null || tableState === void 0 ? void 0 : tableState.isFullWidthModeEnabled,
            isCommentEditor: options === null || options === void 0 ? void 0 : options.isCommentEditor,
            isChromelessEditor: options === null || options === void 0 ? void 0 : options.isChromelessEditor,
            isTableResizingEnabled: options === null || options === void 0 ? void 0 : options.tableOptions.allowTableResizing
          };
          let tableNode = createTableWithWidth(tableNodeProps)(state.schema);
          let {
            tr
          } = state;
          // If the cursor is inside a table
          if (hasParentNodeOfType(state.schema.nodes.table)(state.selection) && options !== null && options !== void 0 && (_options$tableOptions6 = options.tableOptions) !== null && _options$tableOptions6 !== void 0 && _options$tableOptions6.allowNestedTables && fg('platform_editor_use_nested_table_pm_nodes')) {
            // If the experiment is disabled, or we're trying to nest deeper than one level, we insert the table after the top table
            if (editorExperiment('nested-tables-in-tables', false, {
              exposure: true
            }) || getParentOfTypeCount(state.schema.nodes.table)(state.selection.$from) > 1) {
              // Nesting is too deep insert table after the top parent table
              const positionAfterTopTable = getPositionAfterTopParentNodeOfType(state.schema.nodes.table)(state.selection.$from);
              tr = safeInsert(tableNode, positionAfterTopTable)(tr);
              tr.scrollIntoView();
            } else {
              // Table can be nested in parent table
              tableNode = createTableWithWidth({
                ...tableNodeProps,
                isNestedTable: true
              })(state.schema);
              tr = insert(tableNode);
            }
          } else {
            tr = insert(tableNode);
          }
          editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 ? void 0 : editorAnalyticsAPI.attachAnalyticsEvent({
            action: ACTION.INSERTED,
            actionSubject: ACTION_SUBJECT.DOCUMENT,
            actionSubjectId: ACTION_SUBJECT_ID.TABLE,
            attributes: {
              inputMethod: INPUT_METHOD.QUICK_INSERT,
              localId: tableNode.attrs.localId
            },
            eventType: EVENT_TYPE.TRACK
          })(tr);
          return tr;
        }
      }],
      floatingToolbar: getToolbarConfig(defaultGetEditorContainerWidth, api, editorAnalyticsAPI, () => editorViewRef.current, options, isTableFixedColumnWidthsOptionEnabled, shouldUseIncreasedScalingPercent)(pluginConfig(options === null || options === void 0 ? void 0 : options.tableOptions))
    },
    usePluginHook({
      editorView
    }) {
      const {
        editorViewModeState
      } = useSharedPluginState(api, ['editorViewMode']);
      const mode = editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode;
      useEffect(() => {
        const {
          state,
          dispatch
        } = editorView;
        const tr = state.tr;
        tr.setMeta('viewModeState', mode);
        if (dispatch) {
          dispatch(tr);
        }
      }, [editorView, mode]);
    }
  };
};
export default tablePlugin;