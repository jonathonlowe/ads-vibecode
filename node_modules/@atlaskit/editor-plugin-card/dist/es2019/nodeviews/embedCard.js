import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import rafSchedule from 'raf-schd';
import uuid from 'uuid/v4';
import { SetAttrsStep } from '@atlaskit/adf-schema/steps';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import { findOverflowScrollParent, MediaSingle as RichMediaWrapper, UnsupportedBlock } from '@atlaskit/editor-common/ui';
import { floatingLayouts, isRichMediaInsideOfBlockNode } from '@atlaskit/editor-common/utils';
import { DEFAULT_EMBED_CARD_HEIGHT, DEFAULT_EMBED_CARD_WIDTH } from '@atlaskit/editor-shared-styles';
import { fg } from '@atlaskit/platform-feature-flags';
import { EmbedResizeMessageListener, Card as SmartCard } from '@atlaskit/smart-card';
import { registerCard, removeCard } from '../pm-plugins/actions';
import ResizableEmbedCard from '../ui/ResizableEmbedCard';
import { Card } from './genericCard';
const CardInner = ({
  pluginInjectionApi,
  getPosSafely,
  getLineLength,
  view,
  smartCard,
  eventDispatcher,
  updateSize,
  getPos,
  aspectRatio,
  allowResizing,
  hasPreview,
  heightAlone,
  cardProps,
  dispatchAnalyticsEvent
}) => {
  const {
    widthState,
    editorDisabledState
  } = useSharedPluginState(pluginInjectionApi, ['width', 'editorDisabled']);
  const widthStateLineLength = (widthState === null || widthState === void 0 ? void 0 : widthState.lineLength) || 0;
  const widthStateWidth = (widthState === null || widthState === void 0 ? void 0 : widthState.width) || 0;
  const pos = getPosSafely();
  if (pos === undefined) {
    return null;
  }
  const lineLength = getLineLength(view, pos, widthStateLineLength);
  const containerWidth = isRichMediaInsideOfBlockNode(view, pos) ? lineLength : widthStateWidth;
  if (!allowResizing || !hasPreview) {
    // There are two ways `width` and `height` can be defined here:
    // 1) Either as `heightAlone` as height value and no width
    // 2) or as `1` for height and aspectRation (defined or a default one) as a width
    // See above for how aspectRation is calculated.
    const defaultAspectRatio = DEFAULT_EMBED_CARD_WIDTH / DEFAULT_EMBED_CARD_HEIGHT;
    let richMediaWrapperHeight = 1;
    let richMediaWrapperWidth = aspectRatio || defaultAspectRatio;
    if (heightAlone) {
      richMediaWrapperHeight = heightAlone;
      richMediaWrapperWidth = undefined;
    }
    return /*#__PURE__*/React.createElement(RichMediaWrapper
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, cardProps, {
      height: richMediaWrapperHeight,
      width: richMediaWrapperWidth,
      nodeType: "embedCard",
      hasFallbackContainer: hasPreview,
      lineLength: lineLength,
      containerWidth: containerWidth
    }), smartCard);
  }
  const displayGrid = (visible, gridType, highlight) => {
    var _pluginInjectionApi$g, _pluginInjectionApi$g2;
    return pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$g = pluginInjectionApi.grid) === null || _pluginInjectionApi$g === void 0 ? void 0 : (_pluginInjectionApi$g2 = _pluginInjectionApi$g.actions) === null || _pluginInjectionApi$g2 === void 0 ? void 0 : _pluginInjectionApi$g2.displayGrid(view)({
      visible,
      gridType,
      highlight: highlight
    });
  };
  return /*#__PURE__*/React.createElement(ResizableEmbedCard
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, cardProps, {
    height: heightAlone,
    aspectRatio: aspectRatio,
    view: view,
    getPos: getPos,
    lineLength: lineLength,
    gridSize: 12,
    containerWidth: containerWidth,
    displayGrid: displayGrid,
    updateSize: updateSize,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    isResizeDisabled: editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled
  }), smartCard);
};
// eslint-disable-next-line @repo/internal/react/no-class-components
export class EmbedCardComponent extends React.PureComponent {
  constructor(props) {
    super(props);
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    _defineProperty(this, "embedIframeRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "state", {
      hasPreview: true
    });
    _defineProperty(this, "getPosSafely", () => {
      const {
        getPos
      } = this.props;
      if (!getPos || typeof getPos === 'boolean') {
        return;
      }
      try {
        return getPos();
      } catch (e) {
        // Can blow up in rare cases, when node has been removed.
      }
    });
    _defineProperty(this, "onResolve", data => {
      const {
        view
      } = this.props;
      const {
        title,
        url,
        aspectRatio
      } = data;
      const {
        originalHeight,
        originalWidth
      } = this.props.node.attrs;
      if (aspectRatio && !originalHeight && !originalWidth) {
        // Assumption here is if ADF already have both height and width set,
        // we will going to use that later on in this class as aspectRatio
        // Most likely we dealing with an embed that received aspectRatio via onResolve previously
        // and now this information already stored in ADF.
        this.setState({
          initialAspectRatio: aspectRatio
        });
        this.saveOriginalDimensionsAttributes(DEFAULT_EMBED_CARD_HEIGHT, DEFAULT_EMBED_CARD_HEIGHT * aspectRatio);
      }

      // don't dispatch immediately since we might be in the middle of
      // rendering a nodeview
      rafSchedule(() => {
        const pos = this.getPosSafely();
        if (pos === undefined) {
          return;
        }
        return view.dispatch(registerCard({
          title,
          url,
          pos,
          id: this.props.id
        })(view.state.tr));
      })();
      try {
        var _this$props$cardConte, _this$props$cardConte2;
        const cardContext = (_this$props$cardConte = this.props.cardContext) !== null && _this$props$cardConte !== void 0 && _this$props$cardConte.value ? (_this$props$cardConte2 = this.props.cardContext) === null || _this$props$cardConte2 === void 0 ? void 0 : _this$props$cardConte2.value : undefined;
        const hasPreview = url && cardContext && cardContext.extractors.getPreview(url, 'web');
        if (!hasPreview) {
          this.setState({
            hasPreview: false
          });
        }
      } catch (e) {}
    });
    _defineProperty(this, "updateSize", (pctWidth, layout) => {
      const {
        state,
        dispatch
      } = this.props.view;
      const pos = this.getPosSafely();
      if (pos === undefined) {
        return;
      }
      const tr = state.tr.setNodeMarkup(pos, undefined, {
        ...this.props.node.attrs,
        width: pctWidth,
        layout
      });
      tr.setMeta('scrollIntoView', false);
      dispatch(tr);
      return true;
    });
    _defineProperty(this, "getLineLength", (view, pos, originalLineLength) => {
      if (typeof pos === 'number' && isRichMediaInsideOfBlockNode(view, pos)) {
        const $pos = view.state.doc.resolve(pos);
        const domNode = view.nodeDOM($pos.pos);
        if ($pos.nodeAfter && floatingLayouts.indexOf($pos.nodeAfter.attrs.layout) > -1 && domNode && domNode.parentElement) {
          return domNode.parentElement.offsetWidth;
        }
        if (domNode instanceof HTMLElement) {
          return domNode.offsetWidth;
        }
      }
      return originalLineLength;
    });
    /**
     * Even though render is capable of listening and reacting to iframely wrapper iframe sent `resize` events
     * it's good idea to store latest actual height in ADF, so that when renderer (well, editor as well) is loading
     * we will show embed window of appropriate size and avoid unnecessary content jumping.
     */
    _defineProperty(this, "saveOriginalDimensionsAttributes", (height, width) => {
      const {
        view
      } = this.props;

      // Please, do not copy or use this kind of code below
      // @ts-ignore
      const fakeTableResizePluginKey = {
        key: 'tableFlexiColumnResizing$',
        getState: state => {
          // eslint-disable-next-line
          return state['tableFlexiColumnResizing$'];
        }
      };
      const fakeTableResizeState = fakeTableResizePluginKey.getState(view.state);

      // We are not updating ADF when this function fired while table is resizing.
      // Changing ADF in the middle of resize will break table resize plugin logic
      // (tables will be considered different at the end of the drag and cell size won't be stored)
      // But this is not a big problem, editor user will be seeing latest height anyway (via updated state)
      // And even if page to be saved with slightly outdated height, renderer is capable of reading latest height value
      // when embed loads, and so it won't be a problem.
      if (fakeTableResizeState !== null && fakeTableResizeState !== void 0 && fakeTableResizeState.dragging) {
        return;
      }
      rafSchedule(() => {
        const pos = this.getPosSafely();
        if (pos === undefined) {
          return;
        }
        view.dispatch(view.state.tr.step(new SetAttrsStep(pos, {
          originalHeight: height,
          originalWidth: width
        })).setMeta('addToHistory', false));
      })();
    });
    _defineProperty(this, "onHeightUpdate", height => {
      this.setState({
        liveHeight: height
      });
      this.saveOriginalDimensionsAttributes(height, undefined);
    });
    _defineProperty(this, "onError", ({
      err
    }) => {
      if (err) {
        throw err;
      }
    });
    this.scrollContainer = findOverflowScrollParent(props.view.dom) || undefined;
  }
  render() {
    const {
      node,
      allowResizing,
      fullWidthMode,
      view,
      dispatchAnalyticsEvent,
      getPos,
      pluginInjectionApi,
      actionOptions,
      onClick
    } = this.props;
    const {
      url,
      width: pctWidth,
      layout,
      originalHeight,
      originalWidth
    } = node.attrs;
    const {
      hasPreview,
      liveHeight,
      initialAspectRatio
    } = this.state;

    // We don't want to use `originalHeight` when `originalWidth` also present,
    // since `heightAlone` is defined only when just height is available.
    const heightAlone = liveHeight !== null && liveHeight !== void 0 ? liveHeight : !originalWidth && originalHeight || undefined;
    const aspectRatio = !heightAlone && (
    // No need getting aspectRatio if heightAlone defined already
    initialAspectRatio ||
    // If we have initialAspectRatio (coming from iframely) we should go with that
    originalHeight && originalWidth && originalWidth / originalHeight) ||
    // If ADF contains both width and height we get ratio from that
    undefined;
    const cardProps = {
      layout,
      pctWidth,
      fullWidthMode
    };
    const smartCard = /*#__PURE__*/React.createElement(SmartCard, {
      key: url,
      url: url,
      appearance: "embed",
      onClick: onClick,
      onResolve: this.onResolve,
      onError: this.onError,
      frameStyle: "show",
      inheritDimensions: true,
      platform: 'web',
      container: this.scrollContainer,
      embedIframeRef: this.embedIframeRef,
      actionOptions: actionOptions
    });
    return /*#__PURE__*/React.createElement(EmbedResizeMessageListener, {
      embedIframeRef: this.embedIframeRef,
      onHeightUpdate: this.onHeightUpdate
    }, /*#__PURE__*/React.createElement(CardInner, {
      pluginInjectionApi: pluginInjectionApi,
      smartCard: smartCard,
      hasPreview: hasPreview,
      getPosSafely: this.getPosSafely,
      view: view,
      getLineLength: this.getLineLength,
      eventDispatcher: this.props.eventDispatcher,
      updateSize: this.updateSize,
      getPos: getPos,
      aspectRatio: aspectRatio,
      allowResizing: allowResizing,
      heightAlone: heightAlone,
      cardProps: cardProps,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent
    }));
  }
}
const WrappedBlockCard = Card(EmbedCardComponent, UnsupportedBlock);
export class EmbedCard extends ReactNodeView {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "id", uuid());
    _defineProperty(this, "updateContentEditable", (editorViewModeState, divElement) => {
      divElement.contentEditable = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view' ? 'false' : 'true';
    });
  }
  viewShouldUpdate(nextNode) {
    if (this.node.attrs !== nextNode.attrs) {
      return true;
    }
    return super.viewShouldUpdate(nextNode);
  }
  createDomRef() {
    const domRef = document.createElement('div');
    // It is a tradeoff for the bug mentioned that occurs in Chrome: https://product-fabric.atlassian.net/browse/ED-5379, https://github.com/ProseMirror/prosemirror/issues/884
    if (fg('linking-platform-contenteditable-false-live-view')) {
      var _this$reactComponentP, _this$reactComponentP2, _this$reactComponentP3, _this$reactComponentP4;
      this.unsubscribe = (_this$reactComponentP = this.reactComponentProps.pluginInjectionApi) === null || _this$reactComponentP === void 0 ? void 0 : (_this$reactComponentP2 = _this$reactComponentP.editorViewMode) === null || _this$reactComponentP2 === void 0 ? void 0 : _this$reactComponentP2.sharedState.onChange(({
        nextSharedState
      }) => this.updateContentEditable(nextSharedState, domRef));
      this.updateContentEditable((_this$reactComponentP3 = this.reactComponentProps.pluginInjectionApi) === null || _this$reactComponentP3 === void 0 ? void 0 : (_this$reactComponentP4 = _this$reactComponentP3.editorViewMode) === null || _this$reactComponentP4 === void 0 ? void 0 : _this$reactComponentP4.sharedState.currentState(), domRef);
    } else {
      domRef.contentEditable = 'true';
    }
    domRef.setAttribute('spellcheck', 'false');
    return domRef;
  }
  render() {
    const {
      eventDispatcher,
      allowResizing,
      fullWidthMode,
      dispatchAnalyticsEvent,
      pluginInjectionApi,
      onClickCallback
    } = this.reactComponentProps;
    return /*#__PURE__*/React.createElement(WrappedBlockCard, {
      node: this.node,
      view: this.view,
      eventDispatcher: eventDispatcher,
      getPos: this.getPos,
      allowResizing: allowResizing,
      fullWidthMode: fullWidthMode,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      pluginInjectionApi: pluginInjectionApi,
      onClickCallback: onClickCallback,
      id: this.id
    });
  }
  destroy() {
    var _this$unsubscribe;
    (_this$unsubscribe = this.unsubscribe) === null || _this$unsubscribe === void 0 ? void 0 : _this$unsubscribe.call(this);
    if (fg('platform_editor_fix_card_plugin_state')) {
      this.removeCard();
    }
  }
  removeCard() {
    const {
      tr
    } = this.view.state;
    removeCard({
      id: this.id
    })(tr);
    this.view.dispatch(tr);
  }
}
export const embedCardNodeView = ({
  allowResizing,
  fullWidthMode,
  pmPluginFactoryParams,
  pluginInjectionApi,
  actionOptions,
  onClickCallback
}) => (node, view, getPos) => {
  const {
    portalProviderAPI,
    eventDispatcher,
    dispatchAnalyticsEvent
  } = pmPluginFactoryParams;
  const reactComponentProps = {
    eventDispatcher,
    allowResizing,
    fullWidthMode,
    dispatchAnalyticsEvent,
    pluginInjectionApi,
    actionOptions,
    onClickCallback: onClickCallback
  };
  return new EmbedCard(node, view, getPos, portalProviderAPI, eventDispatcher, reactComponentProps, undefined).init();
};