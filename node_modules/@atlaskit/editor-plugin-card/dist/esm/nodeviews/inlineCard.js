import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import rafSchedule from 'raf-schd';
import uuid from 'uuid/v4';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { handleNavigation } from '@atlaskit/editor-common/link';
import { findOverflowScrollParent, UnsupportedInline } from '@atlaskit/editor-common/ui';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { Card as SmartCard } from '@atlaskit/smart-card';
import { CardSSR } from '@atlaskit/smart-card/ssr';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { registerCard, removeCard } from '../pm-plugins/actions';
import { getAwarenessProps } from '../pm-plugins/utils';
import OverlayWrapper from '../ui/ConfigureOverlay';
import { Card } from './genericCard';
import { InlineCardWithAwareness } from './inlineCardWithAwareness';
export var InlineCard = /*#__PURE__*/memo(function (_ref) {
  var node = _ref.node,
    cardContext = _ref.cardContext,
    actionOptions = _ref.actionOptions,
    useAlternativePreloader = _ref.useAlternativePreloader,
    view = _ref.view,
    getPos = _ref.getPos,
    onClick = _ref.onClick,
    onRes = _ref.onResolve,
    isHovered = _ref.isHovered,
    showHoverPreview = _ref.showHoverPreview,
    hoverPreviewOptions = _ref.hoverPreviewOptions,
    isPageSSRed = _ref.isPageSSRed;
  var _node$attrs = node.attrs,
    url = _node$attrs.url,
    data = _node$attrs.data;
  var refId = useRef(uuid());
  useEffect(function () {
    var id = refId.current;
    return function () {
      if (fg('platform_editor_fix_card_plugin_state')) {
        var tr = view.state.tr;
        removeCard({
          id: id
        })(tr);
        view.dispatch(tr);
      }
    };
  }, [getPos, view]);
  var scrollContainer = useMemo(
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  function () {
    return findOverflowScrollParent(view.dom) || undefined;
  }, [view.dom]);
  var onResolve = useCallback(function (data) {
    if (!getPos || typeof getPos === 'boolean') {
      return;
    }
    var title = data.title,
      url = data.url;
    // don't dispatch immediately since we might be in the middle of
    // rendering a nodeview
    rafSchedule(function () {
      // prosemirror-bump-fix
      var pos = getPos();
      if (typeof pos !== 'number') {
        return;
      }
      var tr = view.state.tr;
      registerCard({
        title: title,
        url: url,
        pos: pos,
        id: refId.current
      })(tr);
      onRes === null || onRes === void 0 || onRes(tr, title);
      view.dispatch(tr);
    })();
  }, [getPos, view, onRes]);
  var onError = useCallback(function (data) {
    var url = data.url,
      err = data.err;
    if (err) {
      throw err;
    }
    onResolve({
      url: url
    });
  }, [onResolve]);
  var card = useMemo(function () {
    if (isPageSSRed && url && fg('platform_ssr_smartlinks_editor')) {
      return /*#__PURE__*/React.createElement(CardSSR, {
        key: url,
        url: url,
        appearance: "inline",
        onClick: onClick,
        container: scrollContainer,
        onResolve: onResolve,
        onError: onError,
        inlinePreloaderStyle: useAlternativePreloader ? 'on-right-without-skeleton' : undefined,
        actionOptions: actionOptions,
        isHovered: isHovered,
        showHoverPreview: showHoverPreview,
        hoverPreviewOptions: hoverPreviewOptions
      });
    }
    return /*#__PURE__*/React.createElement(SmartCard, {
      key: url,
      url: url !== null && url !== void 0 ? url : data.url,
      appearance: "inline",
      onClick: onClick,
      container: scrollContainer,
      onResolve: onResolve,
      onError: onError,
      inlinePreloaderStyle: useAlternativePreloader ? 'on-right-without-skeleton' : undefined,
      actionOptions: actionOptions,
      isHovered: isHovered,
      showHoverPreview: showHoverPreview,
      hoverPreviewOptions: hoverPreviewOptions
    });
  }, [url, data, onClick, scrollContainer, onResolve, onError, useAlternativePreloader, actionOptions, isHovered, showHoverPreview, hoverPreviewOptions, isPageSSRed]);

  // [WS-2307]: we only render card wrapped into a Provider when the value is ready,
  // otherwise if we got data, we can render the card directly since it doesn't need the Provider
  return cardContext && cardContext.value ? /*#__PURE__*/React.createElement(cardContext.Provider, {
    value: cardContext.value
  }, card) : data ? card : null;
});
var WrappedInlineCardWithAwareness = Card(InlineCardWithAwareness, UnsupportedInline);
var WrappedInlineCard = Card(InlineCard, UnsupportedInline);
export function InlineCardNodeView(props) {
  var useAlternativePreloader = props.useAlternativePreloader,
    node = props.node,
    view = props.view,
    getPos = props.getPos,
    actionOptions = props.actionOptions,
    allowEmbeds = props.allowEmbeds,
    allowBlockCards = props.allowBlockCards,
    enableInlineUpgradeFeatures = props.enableInlineUpgradeFeatures,
    pluginInjectionApi = props.pluginInjectionApi,
    onClickCallback = props.onClickCallback,
    __livePage = props.__livePage,
    isPageSSRed = props.isPageSSRed;
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isOverlayHovered = _useState2[0],
    setIsOverlayHovered = _useState2[1];
  var _useSharedPluginState = useSharedPluginState(pluginInjectionApi, ['selection', 'editorViewMode']),
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    selectionState = _useSharedPluginState.selectionState;
  var floatingToolbarNode = (selectionState === null || selectionState === void 0 ? void 0 : selectionState.selection) instanceof NodeSelection && (selectionState === null || selectionState === void 0 ? void 0 : selectionState.selection.node);
  if (__livePage && fg('linking_platform_smart_links_in_live_pages')) {
    var showHoverPreview = floatingToolbarNode !== node;
    var livePagesHoverCardFadeInDelay = 800;
    var inlineCard = /*#__PURE__*/React.createElement(WrappedInlineCard, {
      isHovered: isOverlayHovered,
      node: node,
      view: view,
      getPos: getPos,
      actionOptions: actionOptions,
      useAlternativePreloader: useAlternativePreloader,
      onClickCallback: onClickCallback,
      showHoverPreview: showHoverPreview,
      hoverPreviewOptions: {
        fadeInDelay: livePagesHoverCardFadeInDelay
      },
      isPageSSRed: isPageSSRed
    });
    return (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view' ? inlineCard : /*#__PURE__*/React.createElement(OverlayWrapper, {
      targetElementPos: getPos(),
      view: view,
      isHoveredCallback: setIsOverlayHovered,
      onOpenLinkClick: function onOpenLinkClick(event) {
        var _pluginInjectionApi$a;
        handleNavigation({
          fireAnalyticsEvent: pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$a = pluginInjectionApi.analytics) === null || _pluginInjectionApi$a === void 0 ? void 0 : _pluginInjectionApi$a.actions.fireAnalyticsEvent,
          onClickCallback: onClickCallback,
          url: node.attrs.url,
          event: event
        });
      }
    }, inlineCard);
  }
  return /*#__PURE__*/React.createElement(WrappedInlineCardWithAwareness, _extends({
    node: node,
    view: view,
    getPos: getPos,
    actionOptions: actionOptions,
    useAlternativePreloader: useAlternativePreloader,
    pluginInjectionApi: pluginInjectionApi,
    onClickCallback: onClickCallback,
    isPageSSRed: isPageSSRed,
    appearance: "inline"
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, enableInlineUpgradeFeatures && getAwarenessProps(view.state, getPos, allowEmbeds, allowBlockCards, !editorExperiment('live_pages_graceful_edit', 'control') ? true : (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view')));
}
export var inlineCardNodeView = function inlineCardNodeView(_ref2) {
  var inlineCardViewProducer = _ref2.inlineCardViewProducer;
  return function (node, view, getPos, decorations) {
    return inlineCardViewProducer(node, view, getPos, decorations);
  };
};