import { appearanceForNodeType } from '../../pm-plugins/utils';
import { EVENT_SUBJECT } from './types';
export function isDatasourceNode(node) {
  return 'datasource' in node.attrs && !!node.attrs.datasource;
}

/**
 * Determine if a node is considered to be a link
 */
export var isLinkNode = function isLinkNode(node) {
  if (isDatasourceNode(node)) {
    return false;
  }
  if (!!appearanceForNodeType(node.type)) {
    return true;
  }
  return hasLinkMark(node);
};
export function getNodeSubject(node) {
  if (isDatasourceNode(node)) {
    return EVENT_SUBJECT.DATASOURCE;
  }
  if (isLinkNode(node)) {
    return EVENT_SUBJECT.LINK;
  }
  return null;
}

/**
 * Analytics appearance for link object
 */
export function appearanceForLink(node) {
  var appearance = appearanceForNodeType(node.type);
  if (appearance) {
    return appearance;
  }
  return 'url';
}
var getLinkMark = function getLinkMark(node) {
  if (node.marks) {
    for (var i = 0; i < node.marks.length; i++) {
      var mark = node.marks[i];
      if (mark.type.name === 'link') {
        return mark;
      }
    }
  }
};
var hasLinkMark = function hasLinkMark(node) {
  return !!getLinkMark(node);
};
export function getUrl(node) {
  var _node$attrs$url, _node$attrs, _getLinkMark;
  return (_node$attrs$url = (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.url) !== null && _node$attrs$url !== void 0 ? _node$attrs$url : (_getLinkMark = getLinkMark(node)) === null || _getLinkMark === void 0 || (_getLinkMark = _getLinkMark.attrs) === null || _getLinkMark === void 0 ? void 0 : _getLinkMark.href;
}
export var getNodeContext = function getNodeContext(doc, pos) {
  var $pos = doc.resolve(pos);
  var maxDepth = 3;
  for (var i = 0; i <= maxDepth; i++) {
    var node = $pos.node($pos.depth - i);
    if (node && node.type.name !== 'paragraph') {
      return node.type.name;
    }
  }
  return 'unknown';
};
export var findAtPositions = function findAtPositions(tr, positions) {
  var entities = [];
  for (var i = 0; i < positions.length; i++) {
    var pos = positions[i];
    var node = tr.doc.nodeAt(pos);
    if (!node) {
      continue;
    }
    var nodeContext = getNodeContext(tr.doc, pos);
    entities.push({
      pos: pos,
      node: node,
      nodeContext: nodeContext
    });
  }
  return entities;
};
export var findInNodeRange = function findInNodeRange(doc, from, to, predicate) {
  var entities = [];
  doc.nodesBetween(from, to, function (node, pos) {
    if (predicate(node)) {
      var entirelyInRange = pos >= from && pos + node.nodeSize <= to;
      if (entirelyInRange) {
        var nodeContext = getNodeContext(doc, pos);
        entities.push({
          pos: pos,
          node: node,
          nodeContext: nodeContext
        });
      }
    }
  });
  return entities;
};

/**
 * Returns whether or not two sets of links appear to likely be the same set of links
 * That they are in the same order and that both their hrefs and appearances match
 */
export var areSameNodes = function areSameNodes(setA, setB) {
  if (setA.length !== setB.length) {
    return false;
  }
  for (var i = 0; i < setA.length; i++) {
    var a = setA[i];
    var b = setB[i];
    if (getUrl(a.node) !== getUrl(b.node) || appearanceForLink(a.node) !== appearanceForLink(b.node)) {
      return false;
    }
  }
  return true;
};