import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React from 'react';
import { ACTION, buildEditLinkPayload, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { commandWithMetadata } from '@atlaskit/editor-common/card';
import { HyperlinkAddToolbar as HyperlinkToolbar } from '@atlaskit/editor-common/link';
import { linkToolbarMessages } from '@atlaskit/editor-common/messages';
import { LINKPICKER_HEIGHT_IN_PX, RECENT_SEARCH_HEIGHT_IN_PX, RECENT_SEARCH_WIDTH_IN_PX } from '@atlaskit/editor-common/ui';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { hideLinkToolbar as _hideLinkToolbar, showLinkToolbar } from '../pm-plugins/actions';
import { changeSelectedCardToLink, updateCard } from '../pm-plugins/doc';
import { displayInfoForCard, findCardInfo } from '../pm-plugins/utils';
export function HyperlinkAddToolbarWithState(_ref) {
  var _ref$linkPickerOption = _ref.linkPickerOptions,
    linkPickerOptions = _ref$linkPickerOption === void 0 ? {} : _ref$linkPickerOption,
    onSubmit = _ref.onSubmit,
    displayText = _ref.displayText,
    displayUrl = _ref.displayUrl,
    providerFactory = _ref.providerFactory,
    view = _ref.view,
    onCancel = _ref.onCancel,
    invokeMethod = _ref.invokeMethod,
    lpLinkPicker = _ref.lpLinkPicker,
    onClose = _ref.onClose,
    onEscapeCallback = _ref.onEscapeCallback,
    onClickAwayCallback = _ref.onClickAwayCallback;
  return /*#__PURE__*/React.createElement(HyperlinkToolbar, {
    linkPickerOptions: linkPickerOptions,
    onSubmit: onSubmit,
    displayText: displayText,
    displayUrl: displayUrl,
    providerFactory: providerFactory,
    view: view,
    onCancel: onCancel,
    invokeMethod: invokeMethod,
    lpLinkPicker: lpLinkPicker,
    onClose: onClose,
    onEscapeCallback: onEscapeCallback,
    onClickAwayCallback: onClickAwayCallback
  });
}

// eslint-disable-next-line @repo/internal/react/no-class-components
export var EditLinkToolbar = /*#__PURE__*/function (_React$Component) {
  function EditLinkToolbar() {
    _classCallCheck(this, EditLinkToolbar);
    return _callSuper(this, EditLinkToolbar, arguments);
  }
  _inherits(EditLinkToolbar, _React$Component);
  return _createClass(EditLinkToolbar, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.node !== this.props.node) {
        this.hideLinkToolbar();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.hideLinkToolbar();
    }
  }, {
    key: "hideLinkToolbar",
    value: function hideLinkToolbar() {
      var view = this.props.view;
      view.dispatch(_hideLinkToolbar(view.state.tr));
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;
      var _this$props = this.props,
        linkPickerOptions = _this$props.linkPickerOptions,
        providerFactory = _this$props.providerFactory,
        url = _this$props.url,
        text = _this$props.text,
        view = _this$props.view,
        _onSubmit = _this$props.onSubmit,
        forceFocusSelector = _this$props.forceFocusSelector,
        lpLinkPicker = _this$props.lpLinkPicker;
      return /*#__PURE__*/React.createElement(HyperlinkAddToolbarWithState, {
        view: view,
        linkPickerOptions: linkPickerOptions,
        providerFactory: providerFactory,
        displayUrl: url,
        displayText: text
        // Assumes that the smart card link picker can only ever be invoked by clicking "edit"
        // via the floating toolbar
        ,
        invokeMethod: INPUT_METHOD.FLOATING_TB,
        lpLinkPicker: lpLinkPicker,
        onSubmit: function onSubmit(href, title, displayText, inputMethod, analytic) {
          _this.hideLinkToolbar();
          if (_onSubmit) {
            _onSubmit(href, displayText || title, inputMethod, analytic);
          }
        },
        onEscapeCallback: function onEscapeCallback(state, dispatch) {
          var tr = state.tr;
          _hideLinkToolbar(tr);
          forceFocusSelector === null || forceFocusSelector === void 0 || forceFocusSelector("[aria-label=\"".concat(linkToolbarMessages.editLink.defaultMessage, "\"]"))(tr);
          if (dispatch) {
            dispatch(tr);
            return true;
          }
          return false;
        },
        onClickAwayCallback: function onClickAwayCallback(state, dispatch) {
          var tr = state.tr;
          if (dispatch) {
            dispatch(tr);
            return true;
          }
          return false;
        }
      });
    }
  }]);
}(React.Component);
export var getEditLinkCallback = function getEditLinkCallback(editorAnalyticsApi, scrollIntoView) {
  return function (state, dispatch) {
    var type = 'hyperlink';
    if (state.selection instanceof NodeSelection) {
      type = state.selection.node.type.name;
    }
    if (dispatch) {
      var tr = state.tr;
      showLinkToolbar(tr);
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent(buildEditLinkPayload(type))(tr);
      tr.setMeta('scrollIntoView', scrollIntoView);
      dispatch(tr);
      return true;
    }
    return false;
  };
};
export var buildEditLinkToolbar = function buildEditLinkToolbar(_ref2) {
  var providerFactory = _ref2.providerFactory,
    node = _ref2.node,
    pluginInjectionApi = _ref2.pluginInjectionApi,
    linkPicker = _ref2.linkPicker,
    lpLinkPicker = _ref2.lpLinkPicker;
  return {
    type: 'custom',
    disableArrowNavigation: true,
    fallback: [],
    render: function render(view, idx) {
      var _pluginInjectionApi$f;
      if (!view || !providerFactory) {
        return null;
      }
      var displayInfo = displayInfoForCard(node, findCardInfo(view.state));
      return /*#__PURE__*/React.createElement(EditLinkToolbar, {
        key: idx,
        view: view,
        linkPickerOptions: linkPicker,
        providerFactory: providerFactory,
        url: displayInfo.url,
        text: displayInfo.title || '',
        node: node,
        lpLinkPicker: lpLinkPicker,
        forceFocusSelector: pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$f = pluginInjectionApi.floatingToolbar) === null || _pluginInjectionApi$f === void 0 || (_pluginInjectionApi$f = _pluginInjectionApi$f.actions) === null || _pluginInjectionApi$f === void 0 ? void 0 : _pluginInjectionApi$f.forceFocusSelector,
        onSubmit: function onSubmit(newHref, newText, inputMethod, analytic) {
          var urlChanged = newHref !== displayInfo.url;
          var titleChanged = newText !== displayInfo.title;

          // If the title is changed in a smartlink, convert to standard blue hyperlink
          // (even if the url was also changed) - we don't want to lose the custom title.
          if (titleChanged) {
            var _pluginInjectionApi$a;
            return commandWithMetadata(changeSelectedCardToLink(newText, newHref, undefined, undefined, undefined, pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$a = pluginInjectionApi.analytics) === null || _pluginInjectionApi$a === void 0 ? void 0 : _pluginInjectionApi$a.actions), {
              action: ACTION.UPDATED,
              inputMethod: inputMethod,
              sourceEvent: analytic
            })(view.state, view.dispatch);
          }
          if (urlChanged) {
            // If *only* the url is changed in a smart link, reresolve
            return updateCard(newHref, analytic)(view.state, view.dispatch);
          }
        }
      });
    }
  };
};
export var editLinkToolbarConfig = function editLinkToolbarConfig(showLinkingToolbar, lpLinkPicker) {
  return showLinkingToolbar ? {
    height: lpLinkPicker ? LINKPICKER_HEIGHT_IN_PX : RECENT_SEARCH_HEIGHT_IN_PX,
    width: RECENT_SEARCH_WIDTH_IN_PX,
    forcePlacement: true
  } : {};
};