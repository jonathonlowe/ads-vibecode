import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { calcColumnsFromPx, calcMediaPxWidth, calcPctFromPx, calcPxFromColumns, handleSides, imageAlignmentMap, Resizer, snapTo, wrappedLayouts, wrapperStyle } from '@atlaskit/editor-common/ui';
import { findParentNodeOfTypeClosestToPos, hasParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { akEditorBreakoutPadding, akEditorMediaResizeHandlerPadding, akEditorWideLayoutWidth, breakoutWideScaleRatio, DEFAULT_EMBED_CARD_HEIGHT, DEFAULT_EMBED_CARD_WIDTH } from '@atlaskit/editor-shared-styles';
import { embedHeaderHeight } from '@atlaskit/smart-card';
// eslint-disable-next-line @repo/internal/react/no-class-components
var ResizableEmbedCard = /*#__PURE__*/function (_React$Component) {
  function ResizableEmbedCard() {
    var _this;
    _classCallCheck(this, ResizableEmbedCard);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, ResizableEmbedCard, [].concat(args));
    _defineProperty(_this, "state", {
      offsetLeft: _this.calcOffsetLeft()
    });
    _defineProperty(_this, "calcNewSize", function (newWidth, stop) {
      var _this$props = _this.props,
        layout = _this$props.layout,
        state = _this$props.view.state;
      var newPct = calcPctFromPx(newWidth, _this.props.lineLength) * 100;
      _this.setState({
        resizedPctWidth: newPct
      });
      var newLayout = hasParentNodeOfType(state.schema.nodes.table)(state.selection) ? layout : _this.calcUnwrappedLayout(newPct, newWidth);
      if (newPct <= 100) {
        if (_this.wrappedLayout && (stop ? newPct !== 100 : true)) {
          newLayout = layout;
        }
        return {
          width: newPct,
          layout: newLayout
        };
      } else {
        return {
          width: _this.props.pctWidth || null,
          layout: newLayout
        };
      }
    });
    _defineProperty(_this, "calcUnwrappedLayout", function (pct, width) {
      if (pct <= 100) {
        return 'center';
      }
      if (width <= _this.wideLayoutWidth) {
        return 'wide';
      }
      return 'full-width';
    });
    _defineProperty(_this, "calcColumnLeftOffset", function () {
      var offsetLeft = _this.state.offsetLeft;
      return _this.insideInlineLike ? calcColumnsFromPx(offsetLeft, _this.props.lineLength, _this.props.gridSize) : 0;
    });
    _defineProperty(_this, "calcPxWidth", function (useLayout) {
      var _this$props2 = _this.props,
        layout = _this$props2.layout,
        pctWidth = _this$props2.pctWidth,
        lineLength = _this$props2.lineLength,
        containerWidth = _this$props2.containerWidth,
        fullWidthMode = _this$props2.fullWidthMode,
        getPos = _this$props2.getPos,
        state = _this$props2.view.state;
      var resizedPctWidth = _this.state.resizedPctWidth;
      var pos = typeof getPos === 'function' ? getPos() : undefined;
      return calcMediaPxWidth({
        origWidth: DEFAULT_EMBED_CARD_WIDTH,
        origHeight: DEFAULT_EMBED_CARD_HEIGHT,
        pctWidth: pctWidth,
        state: state,
        containerWidth: {
          width: containerWidth,
          lineLength: lineLength
        },
        isFullWidthModeEnabled: fullWidthMode,
        layout: useLayout || layout,
        pos: pos,
        resizedPctWidth: resizedPctWidth
      });
    });
    _defineProperty(_this, "highlights", function (newWidth, snapPoints) {
      var snapWidth = snapTo(newWidth, snapPoints);
      var _this$props$view$stat = _this.props.view.state.schema.nodes,
        layoutColumn = _this$props$view$stat.layoutColumn,
        table = _this$props$view$stat.table,
        expand = _this$props$view$stat.expand,
        nestedExpand = _this$props$view$stat.nestedExpand;
      if (_this.$pos && !!findParentNodeOfTypeClosestToPos(_this.$pos, [layoutColumn, table, expand, nestedExpand].filter(Boolean))) {
        return [];
      }
      if (snapWidth > _this.wideLayoutWidth) {
        return ['full-width'];
      }
      var _this$props3 = _this.props,
        layout = _this$props3.layout,
        lineLength = _this$props3.lineLength,
        gridSize = _this$props3.gridSize;
      var columns = calcColumnsFromPx(snapWidth, lineLength, gridSize);
      var columnWidth = Math.round(columns);
      var highlight = [];
      if (layout === 'wrap-left' || layout === 'align-start') {
        highlight.push(0, columnWidth);
      } else if (layout === 'wrap-right' || layout === 'align-end') {
        highlight.push(gridSize, gridSize - columnWidth);
      } else if (_this.insideInlineLike) {
        highlight.push(Math.round(columns + _this.calcColumnLeftOffset()));
      } else {
        highlight.push(Math.floor((gridSize - columnWidth) / 2), Math.ceil((gridSize + columnWidth) / 2));
      }
      return highlight;
    });
    return _this;
  }
  _inherits(ResizableEmbedCard, _React$Component);
  return _createClass(ResizableEmbedCard, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var offsetLeft = this.calcOffsetLeft();
      if (offsetLeft !== this.state.offsetLeft && offsetLeft >= 0) {
        this.setState({
          offsetLeft: offsetLeft
        });
      }
      if (this.props.layout !== prevProps.layout) {
        this.checkLayout(prevProps.layout, this.props.layout);
      }
    }
  }, {
    key: "wrappedLayout",
    get: function get() {
      return wrappedLayouts.indexOf(this.props.layout) > -1;
    }

    /**
     * When returning to center layout from a wrapped/aligned layout, it might actually
     * be wide or full-width
     */
  }, {
    key: "checkLayout",
    value: function checkLayout(oldLayout, newLayout) {
      var resizedPctWidth = this.state.resizedPctWidth;
      if (wrappedLayouts.indexOf(oldLayout) > -1 && newLayout === 'center' && resizedPctWidth) {
        var layout = this.calcUnwrappedLayout(resizedPctWidth, this.calcPxWidth(newLayout));
        this.props.updateSize(resizedPctWidth, layout);
      }
    }
  }, {
    key: "$pos",
    get: function get() {
      if (typeof this.props.getPos !== 'function') {
        return null;
      }
      var pos = this.props.getPos();
      if (Number.isNaN(pos) || typeof pos !== 'number') {
        return null;
      }

      // need to pass view because we may not get updated props in time
      return this.props.view.state.doc.resolve(pos);
    }

    /**
     * The maxmimum number of grid columns this node can resize to.
     */
  }, {
    key: "gridWidth",
    get: function get() {
      var gridSize = this.props.gridSize;
      return !(this.wrappedLayout || this.insideInlineLike) ? gridSize / 2 : gridSize;
    }
  }, {
    key: "calcOffsetLeft",
    value: function calcOffsetLeft() {
      var offsetLeft = 0;
      if (this.wrapper && this.insideInlineLike) {
        var currentNode = this.wrapper;
        var boundingRect = currentNode.getBoundingClientRect();
        var pmRect = this.props.view.dom.getBoundingClientRect();
        offsetLeft = boundingRect.left - pmRect.left;
      }
      return offsetLeft;
    }
  }, {
    key: "wideLayoutWidth",
    get: function get() {
      var lineLength = this.props.lineLength;
      if (lineLength) {
        return Math.ceil(lineLength * breakoutWideScaleRatio);
      } else {
        return akEditorWideLayoutWidth;
      }
    }

    // check if is inside of a table
  }, {
    key: "isNestedInTable",
    value: function isNestedInTable() {
      var table = this.props.view.state.schema.nodes.table;
      if (!this.$pos) {
        return false;
      }
      return !!findParentNodeOfTypeClosestToPos(this.$pos, table);
    }
  }, {
    key: "calcSnapPoints",
    value: function calcSnapPoints() {
      var offsetLeft = this.state.offsetLeft;
      var _this$props4 = this.props,
        containerWidth = _this$props4.containerWidth,
        lineLength = _this$props4.lineLength;
      var snapTargets = [];
      for (var i = 0; i < this.gridWidth; i++) {
        snapTargets.push(calcPxFromColumns(i, lineLength, this.gridWidth) - offsetLeft);
      }
      // full width
      snapTargets.push(lineLength - offsetLeft);
      var minimumWidth = calcPxFromColumns(this.wrappedLayout || this.insideInlineLike ? 1 : 2, lineLength, this.props.gridSize);
      var snapPoints = snapTargets.filter(function (width) {
        return width >= minimumWidth;
      });
      var $pos = this.$pos;
      if (!$pos) {
        return snapPoints;
      }
      var isTopLevel = $pos.parent.type.name === 'doc';
      if (isTopLevel) {
        snapPoints.push(this.wideLayoutWidth);
        var fullWidthPoint = containerWidth - akEditorBreakoutPadding;
        if (fullWidthPoint > this.wideLayoutWidth) {
          snapPoints.push(fullWidthPoint);
        }
      }
      return snapPoints;
    }
  }, {
    key: "insideInlineLike",
    get: function get() {
      var $pos = this.$pos;
      if (!$pos) {
        return false;
      }
      var listItem = this.props.view.state.schema.nodes.listItem;
      return !!findParentNodeOfTypeClosestToPos($pos, [listItem]);
    }
  }, {
    key: "getHeightDefiningComponent",
    value:
    /**
     * Previously height of the box was controlled with paddingTop/paddingBottom trick inside Wrapper.
     * It allowed height to be defined by a given percent ratio and so absolute value was defined by actual width.
     * Also, it was part of styled component, which was fine because it was static through out life time of component.
     *
     * Now, two things changed:
     * 1. If `height` is present we take it as actual height of the box, and hence we don't need
     * (or even can't have, due to lack of width value) paddingTop trick.
     * 2. Since `height` can be changing through out life time of a component, we can't have it as part of styled component,
     * and hence we use `style` prop.
     */
    function getHeightDefiningComponent() {
      var _this$props5 = this.props,
        height = _this$props5.height,
        aspectRatio = _this$props5.aspectRatio;
      var heightDefiningStyles;
      if (height) {
        heightDefiningStyles = {
          height: "".concat(height, "px")
        };
      } else {
        // paddingBottom css trick defines ratio of `iframe height (y) + header (32)` to `width (x)`,
        // where is `aspectRatio` defines iframe aspectRatio alone
        // So, visually:
        //
        //            x
        //       ┌──────────┐
        //       │  header  │ 32
        //       ├──────────┤
        //       │          │
        //       │  iframe  │ y
        //       │          │
        //       └──────────┘
        //
        // aspectRatio = x / y
        // paddingBottom = (y + 32) / x
        // which can be achieved with css calc() as (1 / (x/y)) * 100)% + 32px
        heightDefiningStyles = {
          paddingBottom: "calc(".concat((1 / aspectRatio * 100).toFixed(3), "% + ").concat(embedHeaderHeight, "px)")
        };
      }
      return jsx("span", {
        "data-testid": 'resizable-embed-card-height-definer',
        style: _objectSpread({
          // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
          display: 'block',
          /* Fixes extra padding problem in Firefox */
          // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop, @atlaskit/design-system/use-tokens-typography -- Ignored via go/DSP-18766
          fontSize: 0,
          // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop, @atlaskit/design-system/use-tokens-typography -- Ignored via go/DSP-18766
          lineHeight: 0
        }, heightDefiningStyles)
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props6 = this.props,
        layout = _this$props6.layout,
        pctWidth = _this$props6.pctWidth,
        containerWidth = _this$props6.containerWidth,
        fullWidthMode = _this$props6.fullWidthMode,
        isResizeDisabled = _this$props6.isResizeDisabled,
        children = _this$props6.children;
      var resizerProps = {
        width: this.calcPxWidth(),
        innerPadding: akEditorMediaResizeHandlerPadding
      };
      var enable = {};
      handleSides.forEach(function (side) {
        if (isResizeDisabled) {
          enable[side] = false;
          return;
        }
        var oppositeSide = side === 'left' ? 'right' : 'left';
        enable[side] = ['full-width', 'wide', 'center'].concat("wrap-".concat(oppositeSide)).concat("align-".concat(imageAlignmentMap[oppositeSide])).indexOf(layout) > -1;
        if (side === 'left' && _this2.insideInlineLike) {
          enable[side] = false;
        }
      });
      var nestedInTableHandleStyles = function nestedInTableHandleStyles(isNestedInTable) {
        if (!isNestedInTable) {
          return;
        }
        return {
          left: {
            left: "calc(".concat("var(--ds-space-negative-025, -0.125em)", " * 0.5)"),
            paddingLeft: '0px'
          },
          right: {
            right: "calc(".concat("var(--ds-space-negative-025, -0.125em)", " * 0.5)"),
            paddingRight: '0px'
          }
        };
      };

      /* eslint-disable  @atlaskit/design-system/consistent-css-prop-usage */
      return jsx("div", {
        "data-testid": "resizable-embed-card-spacing"
      }, jsx("div", {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        css: wrapperStyle({
          layout: layout,
          isResized: !!pctWidth,
          // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
          containerWidth: containerWidth || DEFAULT_EMBED_CARD_WIDTH,
          fullWidthMode: fullWidthMode
        })
      }, jsx(Resizer
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
      , _extends({}, this.props, {
        enable: enable,
        calcNewSize: this.calcNewSize,
        snapPoints: this.calcSnapPoints(),
        scaleFactor: !this.wrappedLayout && !this.insideInlineLike ? 2 : 1,
        highlights: this.highlights,
        nodeType: "embed",
        handleStyles: nestedInTableHandleStyles(this.isNestedInTable())
        // Ignored via go/ees005
        // eslint-disable-next-line react/jsx-props-no-spreading
      }, resizerProps), children, this.getHeightDefiningComponent())));
      /* eslint-enable @atlaskit/design-system/consistent-css-prop-usage */
    }
  }]);
}(React.Component);
_defineProperty(ResizableEmbedCard, "defaultProps", {
  aspectRatio: DEFAULT_EMBED_CARD_WIDTH / DEFAULT_EMBED_CARD_HEIGHT
});
export { ResizableEmbedCard as default };