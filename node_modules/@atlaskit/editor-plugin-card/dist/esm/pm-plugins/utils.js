import _typeof from "@babel/runtime/helpers/typeof";
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { getResolvedAttributes } from '@atlaskit/link-analytics/resolved-attributes';
import { ASSETS_LIST_OF_LINKS_DATASOURCE_ID, CONFLUENCE_SEARCH_DATASOURCE_ID, JIRA_LIST_OF_LINKS_DATASOURCE_ID } from '@atlaskit/link-datasource';
import { pluginKey } from './plugin-key';
export var appearanceForNodeType = function appearanceForNodeType(spec) {
  if (spec.name === 'inlineCard') {
    return 'inline';
  } else if (spec.name === 'blockCard') {
    return 'block';
  } else if (spec.name === 'embedCard') {
    return 'embed';
  }
  return;
};
export var selectedCardAppearance = function selectedCardAppearance(state) {
  if (state.selection instanceof NodeSelection) {
    return appearanceForNodeType(state.selection.node.type);
  }
};
export var titleUrlPairFromNode = function titleUrlPairFromNode(node) {
  var attrs = node.attrs;
  return {
    url: attrs.url || attrs.data && attrs.data.url,
    title: attrs.data && attrs.data.title
  };
};

/**
 * Merges the title and url from attributes and CardInfo from the resolved view, preferring the CardInfo.
 * @param titleUrlPair title and url information from the node attributes
 * @param info information stored in state from the resolved UI component view
 */
export var mergeCardInfo = function mergeCardInfo(titleUrlPair, info) {
  return {
    title: info && info.title || titleUrlPair.title,
    url: info && info.url || titleUrlPair.url
  };
};
export var displayInfoForCard = function displayInfoForCard(node, info) {
  return mergeCardInfo(titleUrlPairFromNode(node), info);
};
export var findCardInfo = function findCardInfo(state) {
  var pluginState = pluginKey.getState(state);
  if (!pluginState) {
    return undefined;
  }
  return pluginState.cards.find(function (cardInfo) {
    return cardInfo.pos === state.selection.from;
  });
};
var isAppearanceSupportedInParent = function isAppearanceSupportedInParent(currentNodePosition, editorState, fragment, currentAppearance) {
  var resolvedPosition = editorState.doc.resolve(currentNodePosition);
  var parent = currentAppearance === 'embed' || currentAppearance === 'block' ? resolvedPosition.node() : resolvedPosition.node(-1);
  return parent && parent.type.validContent(fragment);
};
export var isEmbedSupportedAtPosition = function isEmbedSupportedAtPosition(currentNodePosition, editorState, currentAppearance) {
  return isAppearanceSupportedInParent(currentNodePosition, editorState, Fragment.from(editorState.schema.nodes.embedCard.createChecked({})), currentAppearance);
};
export var isBlockSupportedAtPosition = function isBlockSupportedAtPosition(currentNodePosition, editorState, currentAppearance) {
  return isAppearanceSupportedInParent(currentNodePosition, editorState, Fragment.from(editorState.schema.nodes.blockCard.createChecked({})), currentAppearance);
};
export var getResolvedAttributesFromStore = function getResolvedAttributesFromStore(url, display, store) {
  if (!store) {
    return {};
  }
  var urlState = store === null || store === void 0 ? void 0 : store.getState()[url];
  var displayCategory = display === 'url' ? 'link' : undefined;
  return getResolvedAttributes({
    url: url,
    displayCategory: displayCategory
  }, urlState === null || urlState === void 0 ? void 0 : urlState.details);
};
export var isDatasourceConfigEditable = function isDatasourceConfigEditable(datasourceId) {
  var datasourcesWithConfigModal = [JIRA_LIST_OF_LINKS_DATASOURCE_ID, ASSETS_LIST_OF_LINKS_DATASOURCE_ID, CONFLUENCE_SEARCH_DATASOURCE_ID];
  return datasourcesWithConfigModal.includes(datasourceId);
};

/**
 * Typeguard that checks node attributes are datasource node attributes
 * ** WARNING ** Typeguards are not a guarantee, if the asserted type changes
 * this function will not be updated automatically
 */
export var isDatasourceAdfAttributes = function isDatasourceAdfAttributes(attrs) {
  // Check is attributes object
  if (!(_typeof(attrs) === 'object' && attrs !== null)) {
    return false;
  }

  // Check datasource attribute is an object
  if (!('datasource' in attrs)) {
    return false;
  }
  if (_typeof(attrs.datasource) !== 'object' || attrs.datasource === null) {
    return false;
  }
  var hasId = 'id' in attrs.datasource && typeof attrs.datasource.id === 'string';
  var hasParameters = 'parameters' in attrs.datasource && _typeof(attrs.datasource.parameters) === 'object' && attrs.datasource.parameters !== null && !Array.isArray(attrs.datasource.parameters);
  var hasViews = 'views' in attrs.datasource && Array.isArray(attrs.datasource.views);
  return hasId && hasParameters && hasViews;
};

/**
 * Typeguard that checks a node is a datasource node (blockCard and has datasource attributes)
 * ** WARNING ** Typeguards are not a guarantee, if the asserted type changes
 * this function will not be updated automatically
 */
export var isDatasourceNode = function isDatasourceNode(node) {
  if (!node) {
    return false;
  }
  return node.type.name === 'blockCard' && isDatasourceAdfAttributes(node.attrs);
};

/**
 * Focuses the editorView if it's not already focused.
 * @param editorView The editor view to focus.
 */
export var focusEditorView = function focusEditorView(editorView) {
  if (!editorView.hasFocus()) {
    editorView.focus();
  }
};
export var getAwarenessProps = function getAwarenessProps(editorState, getPos, allowEmbeds, allowBlockCards) {
  var _editorState$selectio, _editorState$selectio2;
  var disableOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var getPosFunction = typeof getPos !== 'boolean' ? getPos : undefined;
  var linkPosition = getPosFunction === null || getPosFunction === void 0 ? void 0 : getPosFunction();
  var canBeUpgradedToEmbed = !!linkPosition && allowEmbeds ? isEmbedSupportedAtPosition(linkPosition, editorState, 'inline') : false;
  var canBeUpgradedToBlock = !!linkPosition && allowBlockCards ? isBlockSupportedAtPosition(linkPosition, editorState, 'inline') : false;
  var isSelected = editorState.selection instanceof NodeSelection && ((_editorState$selectio = editorState.selection) === null || _editorState$selectio === void 0 || (_editorState$selectio = _editorState$selectio.node) === null || _editorState$selectio === void 0 ? void 0 : _editorState$selectio.type) === editorState.schema.nodes.inlineCard && ((_editorState$selectio2 = editorState.selection) === null || _editorState$selectio2 === void 0 ? void 0 : _editorState$selectio2.from) === (getPosFunction === null || getPosFunction === void 0 ? void 0 : getPosFunction());
  return {
    isPulseEnabled: canBeUpgradedToEmbed,
    isOverlayEnabled: !disableOverlay && (canBeUpgradedToEmbed || canBeUpgradedToBlock),
    isSelected: isSelected
  };
};