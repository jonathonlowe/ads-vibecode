"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InlineCard = void 0;
exports.InlineCardNodeView = InlineCardNodeView;
exports.inlineCardNodeView = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _rafSchd = _interopRequireDefault(require("raf-schd"));
var _v = _interopRequireDefault(require("uuid/v4"));
var _hooks = require("@atlaskit/editor-common/hooks");
var _link = require("@atlaskit/editor-common/link");
var _ui = require("@atlaskit/editor-common/ui");
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _smartCard = require("@atlaskit/smart-card");
var _ssr = require("@atlaskit/smart-card/ssr");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _actions = require("../pm-plugins/actions");
var _utils = require("../pm-plugins/utils");
var _ConfigureOverlay = _interopRequireDefault(require("../ui/ConfigureOverlay"));
var _genericCard = require("./genericCard");
var _inlineCardWithAwareness = require("./inlineCardWithAwareness");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var InlineCard = exports.InlineCard = /*#__PURE__*/(0, _react.memo)(function (_ref) {
  var node = _ref.node,
    cardContext = _ref.cardContext,
    actionOptions = _ref.actionOptions,
    useAlternativePreloader = _ref.useAlternativePreloader,
    view = _ref.view,
    getPos = _ref.getPos,
    onClick = _ref.onClick,
    onRes = _ref.onResolve,
    isHovered = _ref.isHovered,
    showHoverPreview = _ref.showHoverPreview,
    hoverPreviewOptions = _ref.hoverPreviewOptions,
    isPageSSRed = _ref.isPageSSRed;
  var _node$attrs = node.attrs,
    url = _node$attrs.url,
    data = _node$attrs.data;
  var refId = (0, _react.useRef)((0, _v.default)());
  (0, _react.useEffect)(function () {
    var id = refId.current;
    return function () {
      if ((0, _platformFeatureFlags.fg)('platform_editor_fix_card_plugin_state')) {
        var tr = view.state.tr;
        (0, _actions.removeCard)({
          id: id
        })(tr);
        view.dispatch(tr);
      }
    };
  }, [getPos, view]);
  var scrollContainer = (0, _react.useMemo)(
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  function () {
    return (0, _ui.findOverflowScrollParent)(view.dom) || undefined;
  }, [view.dom]);
  var onResolve = (0, _react.useCallback)(function (data) {
    if (!getPos || typeof getPos === 'boolean') {
      return;
    }
    var title = data.title,
      url = data.url;
    // don't dispatch immediately since we might be in the middle of
    // rendering a nodeview
    (0, _rafSchd.default)(function () {
      // prosemirror-bump-fix
      var pos = getPos();
      if (typeof pos !== 'number') {
        return;
      }
      var tr = view.state.tr;
      (0, _actions.registerCard)({
        title: title,
        url: url,
        pos: pos,
        id: refId.current
      })(tr);
      onRes === null || onRes === void 0 || onRes(tr, title);
      view.dispatch(tr);
    })();
  }, [getPos, view, onRes]);
  var onError = (0, _react.useCallback)(function (data) {
    var url = data.url,
      err = data.err;
    if (err) {
      throw err;
    }
    onResolve({
      url: url
    });
  }, [onResolve]);
  var card = (0, _react.useMemo)(function () {
    if (isPageSSRed && url && (0, _platformFeatureFlags.fg)('platform_ssr_smartlinks_editor')) {
      return /*#__PURE__*/_react.default.createElement(_ssr.CardSSR, {
        key: url,
        url: url,
        appearance: "inline",
        onClick: onClick,
        container: scrollContainer,
        onResolve: onResolve,
        onError: onError,
        inlinePreloaderStyle: useAlternativePreloader ? 'on-right-without-skeleton' : undefined,
        actionOptions: actionOptions,
        isHovered: isHovered,
        showHoverPreview: showHoverPreview,
        hoverPreviewOptions: hoverPreviewOptions
      });
    }
    return /*#__PURE__*/_react.default.createElement(_smartCard.Card, {
      key: url,
      url: url !== null && url !== void 0 ? url : data.url,
      appearance: "inline",
      onClick: onClick,
      container: scrollContainer,
      onResolve: onResolve,
      onError: onError,
      inlinePreloaderStyle: useAlternativePreloader ? 'on-right-without-skeleton' : undefined,
      actionOptions: actionOptions,
      isHovered: isHovered,
      showHoverPreview: showHoverPreview,
      hoverPreviewOptions: hoverPreviewOptions
    });
  }, [url, data, onClick, scrollContainer, onResolve, onError, useAlternativePreloader, actionOptions, isHovered, showHoverPreview, hoverPreviewOptions, isPageSSRed]);

  // [WS-2307]: we only render card wrapped into a Provider when the value is ready,
  // otherwise if we got data, we can render the card directly since it doesn't need the Provider
  return cardContext && cardContext.value ? /*#__PURE__*/_react.default.createElement(cardContext.Provider, {
    value: cardContext.value
  }, card) : data ? card : null;
});
var WrappedInlineCardWithAwareness = (0, _genericCard.Card)(_inlineCardWithAwareness.InlineCardWithAwareness, _ui.UnsupportedInline);
var WrappedInlineCard = (0, _genericCard.Card)(InlineCard, _ui.UnsupportedInline);
function InlineCardNodeView(props) {
  var useAlternativePreloader = props.useAlternativePreloader,
    node = props.node,
    view = props.view,
    getPos = props.getPos,
    actionOptions = props.actionOptions,
    allowEmbeds = props.allowEmbeds,
    allowBlockCards = props.allowBlockCards,
    enableInlineUpgradeFeatures = props.enableInlineUpgradeFeatures,
    pluginInjectionApi = props.pluginInjectionApi,
    onClickCallback = props.onClickCallback,
    __livePage = props.__livePage,
    isPageSSRed = props.isPageSSRed;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    isOverlayHovered = _useState2[0],
    setIsOverlayHovered = _useState2[1];
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(pluginInjectionApi, ['selection', 'editorViewMode']),
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    selectionState = _useSharedPluginState.selectionState;
  var floatingToolbarNode = (selectionState === null || selectionState === void 0 ? void 0 : selectionState.selection) instanceof _state.NodeSelection && (selectionState === null || selectionState === void 0 ? void 0 : selectionState.selection.node);
  if (__livePage && (0, _platformFeatureFlags.fg)('linking_platform_smart_links_in_live_pages')) {
    var showHoverPreview = floatingToolbarNode !== node;
    var livePagesHoverCardFadeInDelay = 800;
    var inlineCard = /*#__PURE__*/_react.default.createElement(WrappedInlineCard, {
      isHovered: isOverlayHovered,
      node: node,
      view: view,
      getPos: getPos,
      actionOptions: actionOptions,
      useAlternativePreloader: useAlternativePreloader,
      onClickCallback: onClickCallback,
      showHoverPreview: showHoverPreview,
      hoverPreviewOptions: {
        fadeInDelay: livePagesHoverCardFadeInDelay
      },
      isPageSSRed: isPageSSRed
    });
    return (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view' ? inlineCard : /*#__PURE__*/_react.default.createElement(_ConfigureOverlay.default, {
      targetElementPos: getPos(),
      view: view,
      isHoveredCallback: setIsOverlayHovered,
      onOpenLinkClick: function onOpenLinkClick(event) {
        var _pluginInjectionApi$a;
        (0, _link.handleNavigation)({
          fireAnalyticsEvent: pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$a = pluginInjectionApi.analytics) === null || _pluginInjectionApi$a === void 0 ? void 0 : _pluginInjectionApi$a.actions.fireAnalyticsEvent,
          onClickCallback: onClickCallback,
          url: node.attrs.url,
          event: event
        });
      }
    }, inlineCard);
  }
  return /*#__PURE__*/_react.default.createElement(WrappedInlineCardWithAwareness, (0, _extends2.default)({
    node: node,
    view: view,
    getPos: getPos,
    actionOptions: actionOptions,
    useAlternativePreloader: useAlternativePreloader,
    pluginInjectionApi: pluginInjectionApi,
    onClickCallback: onClickCallback,
    isPageSSRed: isPageSSRed,
    appearance: "inline"
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, enableInlineUpgradeFeatures && (0, _utils.getAwarenessProps)(view.state, getPos, allowEmbeds, allowBlockCards, !(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') ? true : (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view')));
}
var inlineCardNodeView = exports.inlineCardNodeView = function inlineCardNodeView(_ref2) {
  var inlineCardViewProducer = _ref2.inlineCardViewProducer;
  return function (node, view, getPos, decorations) {
    return inlineCardViewProducer(node, view, getPos, decorations);
  };
};