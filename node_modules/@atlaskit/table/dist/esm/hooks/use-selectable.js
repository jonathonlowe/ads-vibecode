import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useCallback, useReducer } from 'react';
export var defaultSelectableState = {
  checked: [],
  allChecked: false,
  anyChecked: false,
  maxChecked: 0,
  selectionStart: -1,
  previousSelection: []
};
var arrayFromRange = function arrayFromRange(from, to) {
  var startIdx = from;
  var stopIdx = to;
  var increment = 1;
  if (from > to) {
    startIdx = to;
    stopIdx = from;
    increment = 0;
  }

  // Create an array with values between `from` and `to` - either ascending or descending
  return Array.from({
    length: stopIdx - startIdx
  }, function (_, i) {
    return startIdx + i + increment;
  });
};
function reducer(_ref, action) {
  var checked = _ref.checked,
    anyChecked = _ref.anyChecked,
    maxChecked = _ref.maxChecked,
    selectionStart = _ref.selectionStart,
    previousSelection = _ref.previousSelection;
  switch (action.type) {
    case 'toggle_selection':
      {
        var _action$value = action.value,
          id = _action$value.id,
          shiftHeld = _action$value.shiftHeld;
        var updated = checked.slice();
        var newSelectionStart = selectionStart;
        var newPreviousSelection = previousSelection.slice();
        if (shiftHeld) {
          if (checked.length > 0) {
            var newIds = arrayFromRange(selectionStart, id); // create an array of the new ids

            // Uncheck ids from the previous selection.
            // This is done to maintain consistency with Shift-select behaviour elsewhere (e.g. macOS)
            // TODO: Code could be improved to only remove ids that are not included in the new range, avoiding needing to re-add them below
            updated = updated.filter(function (id) {
              return !previousSelection.includes(id);
            });
            newIds.forEach(function (id) {
              return updated.indexOf(id) === -1 && updated.push(id);
            } // If the new id is not already checked, check it
            );
            newPreviousSelection = newIds; // Maintain an array of the previous selection to allow for consistent Shift-select behaviour
          }
        } else {
          var checkedIndex = checked.indexOf(id); // is index already checked

          if (checkedIndex !== -1) {
            updated.splice(checkedIndex, 1); // if index is already checked, uncheck
          } else {
            updated.push(id); // if index is not checked, check
          }
          newSelectionStart = id; // Reset selection start id to this non-shift-selected id
          newPreviousSelection = []; // Reset previous selection as it is no longer relevant once a new non-shift-selected id is added
        }
        var _anyChecked = updated.length > 0;
        return {
          checked: updated,
          allChecked: updated.length === maxChecked,
          anyChecked: _anyChecked || Boolean(updated[id]),
          maxChecked: maxChecked,
          selectionStart: newSelectionStart,
          previousSelection: newPreviousSelection
        };
      }
    case 'set_root':
      return {
        checked: action.value ? Array.from(Array(maxChecked).keys()) : [],
        allChecked: action.value,
        anyChecked: Boolean(action.value),
        maxChecked: maxChecked,
        selectionStart: selectionStart,
        previousSelection: previousSelection
      };
    case 'set_max':
      {
        var max = action.value;
        return {
          maxChecked: max,
          allChecked: checked.length === max,
          anyChecked: anyChecked,
          checked: checked,
          selectionStart: selectionStart,
          previousSelection: previousSelection
        };
      }
    default:
      throw new Error();
  }
}
function useSelectable() {
  var _useReducer = useReducer(reducer, defaultSelectableState),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    state = _useReducer2[0],
    dispatch = _useReducer2[1];
  var toggleSelection = useCallback(function (id, shiftHeld) {
    dispatch({
      type: 'toggle_selection',
      value: {
        id: id,
        shiftHeld: shiftHeld
      }
    });
  }, []);
  var setAll = useCallback(function () {
    dispatch({
      type: 'set_root',
      value: true
    });
  }, []);
  var removeAll = useCallback(function () {
    dispatch({
      type: 'set_root',
      value: false
    });
  }, []);
  var setMax = useCallback(function (max) {
    dispatch({
      type: 'set_max',
      value: max
    });
  }, []);
  return [state, {
    setAll: setAll,
    removeAll: removeAll,
    toggleSelection: toggleSelection,
    setMax: setMax
  }];
}
export default useSelectable;