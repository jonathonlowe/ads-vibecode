import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import { breakout } from '@atlaskit/adf-schema';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { BreakoutCssClassName } from '@atlaskit/editor-common/styles';
import { akEditorSwoopCubicBezier } from '@atlaskit/editor-shared-styles';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { pluginKey } from './pm-plugins/plugin-key';
import { findSupportedNodeForBreakout } from './pm-plugins/utils/find-breakout-node';
import LayoutButton from './ui/LayoutButton';
var BreakoutView = /*#__PURE__*/_createClass(function BreakoutView(
/**
 * Note: this is actually a PMMark -- however our version
 * of the prosemirror and prosemirror types mean using PMNode
 * is not problematic.
 */
mark, view) {
  _classCallCheck(this, BreakoutView);
  var dom = document.createElement('div');
  var contentDOM = document.createElement('div');
  contentDOM.className = BreakoutCssClassName.BREAKOUT_MARK_DOM;
  contentDOM.setAttribute('data-testid', 'ak-editor-breakout-mark-dom');
  dom.className = BreakoutCssClassName.BREAKOUT_MARK;
  dom.setAttribute('data-layout', mark.attrs.mode);
  dom.setAttribute('data-testid', 'ak-editor-breakout-mark');
  dom.appendChild(contentDOM);
  dom.style.transform = 'none';
  dom.style.display = 'flex';
  dom.style.justifyContent = 'center';
  contentDOM.style.transition = "min-width 0.5s ".concat(akEditorSwoopCubicBezier);
  if (editorExperiment('advanced_layouts', true)) {
    if (mark.attrs.width) {
      contentDOM.style.minWidth = "min(".concat(mark.attrs.width, "px, calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding)))");
    } else {
      // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
      if (mark.attrs.mode === 'full-width') {
        contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
      }
      if (mark.attrs.mode === 'wide') {
        contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
      }
    }
  } else {
    // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
    if (mark.attrs.mode === 'full-width') {
      contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
    }
    if (mark.attrs.mode === 'wide') {
      contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
    }
  }
  this.dom = dom;
  this.mark = mark;
  this.view = view;
  this.contentDOM = contentDOM;
});
function shouldPluginStateUpdate(newBreakoutNode, currentBreakoutNode) {
  if (newBreakoutNode && currentBreakoutNode) {
    return newBreakoutNode !== currentBreakoutNode;
  }
  return newBreakoutNode || currentBreakoutNode ? true : false;
}
function createPlugin(pluginInjectionApi, _ref) {
  var dispatch = _ref.dispatch;
  return new SafePlugin({
    state: {
      init: function init() {
        return {
          breakoutNode: undefined
        };
      },
      apply: function apply(tr, pluginState) {
        var breakoutNode = findSupportedNodeForBreakout(tr.selection);
        if (shouldPluginStateUpdate(breakoutNode, pluginState.breakoutNode)) {
          var nextPluginState = _objectSpread(_objectSpread({}, pluginState), {}, {
            breakoutNode: breakoutNode
          });
          dispatch(pluginKey, nextPluginState);
          return nextPluginState;
        }
        return pluginState;
      }
    },
    key: pluginKey,
    props: {
      nodeViews: {
        // Note: When we upgrade to prosemirror 1.27.2 -- we should
        // move this to markViews.
        // See the following link for more details:
        // https://prosemirror.net/docs/ref/#view.EditorProps.nodeViews.
        breakout: function breakout(mark, view) {
          return new BreakoutView(mark, view);
        }
      }
    }
  });
}
var LayoutButtonWrapper = function LayoutButtonWrapper(_ref2) {
  var _breakoutState$breako, _breakoutState$breako2;
  var api = _ref2.api,
    editorView = _ref2.editorView,
    boundariesElement = _ref2.boundariesElement,
    scrollableElement = _ref2.scrollableElement,
    mountPoint = _ref2.mountPoint;
  // Re-render with `width` (but don't use state) due to https://bitbucket.org/atlassian/%7Bc8e2f021-38d2-46d0-9b7a-b3f7b428f724%7D/pull-requests/24272
  var _useSharedPluginState = useSharedPluginState(api, ['width', 'breakout', 'editorViewMode', 'editorDisabled', 'blockControls']),
    breakoutState = _useSharedPluginState.breakoutState,
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    editorDisabledState = _useSharedPluginState.editorDisabledState,
    blockControlsState = _useSharedPluginState.blockControlsState;
  if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isDragging || blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isPMDragging) {
    if (editorExperiment('advanced_layouts', true)) {
      return null;
    }
  }
  var isViewMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  var isEditMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'edit';
  return !isViewMode && editorDisabledState !== undefined && !(editorDisabledState !== null && editorDisabledState !== void 0 && editorDisabledState.editorDisabled) ? /*#__PURE__*/React.createElement(LayoutButton, {
    editorView: editorView,
    mountPoint: mountPoint,
    boundariesElement: boundariesElement,
    scrollableElement: scrollableElement,
    node: (_breakoutState$breako = breakoutState === null || breakoutState === void 0 || (_breakoutState$breako2 = breakoutState.breakoutNode) === null || _breakoutState$breako2 === void 0 ? void 0 : _breakoutState$breako2.node) !== null && _breakoutState$breako !== void 0 ? _breakoutState$breako : null,
    isLivePage: isEditMode
  }) : null;
};
export var breakoutPlugin = function breakoutPlugin(_ref3) {
  var options = _ref3.config,
    api = _ref3.api;
  return {
    name: 'breakout',
    pmPlugins: function pmPlugins() {
      return [{
        name: 'breakout',
        plugin: function plugin(props) {
          return createPlugin(api, props);
        }
      }];
    },
    marks: function marks() {
      return [{
        name: 'breakout',
        mark: breakout
      }];
    },
    getSharedState: function getSharedState(editorState) {
      if (!editorState) {
        return {
          breakoutNode: undefined
        };
      }
      var pluginState = pluginKey.getState(editorState);
      if (!pluginState) {
        return {
          breakoutNode: undefined
        };
      }
      return pluginState;
    },
    contentComponent: function contentComponent(_ref4) {
      var editorView = _ref4.editorView,
        popupsMountPoint = _ref4.popupsMountPoint,
        popupsBoundariesElement = _ref4.popupsBoundariesElement,
        popupsScrollableElement = _ref4.popupsScrollableElement;
      // This is a bit crappy, but should be resolved once we move to a static schema.
      if (options && !options.allowBreakoutButton) {
        return null;
      }
      return /*#__PURE__*/React.createElement(LayoutButtonWrapper, {
        api: api,
        mountPoint: popupsMountPoint,
        editorView: editorView,
        boundariesElement: popupsBoundariesElement,
        scrollableElement: popupsScrollableElement
      });
    }
  };
};