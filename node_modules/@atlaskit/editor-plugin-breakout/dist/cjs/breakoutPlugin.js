"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breakoutPlugin = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _react = _interopRequireDefault(require("react"));
var _adfSchema = require("@atlaskit/adf-schema");
var _hooks = require("@atlaskit/editor-common/hooks");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _styles = require("@atlaskit/editor-common/styles");
var _editorSharedStyles = require("@atlaskit/editor-shared-styles");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _pluginKey = require("./pm-plugins/plugin-key");
var _findBreakoutNode = require("./pm-plugins/utils/find-breakout-node");
var _LayoutButton = _interopRequireDefault(require("./ui/LayoutButton"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var BreakoutView = /*#__PURE__*/(0, _createClass2.default)(function BreakoutView(
/**
 * Note: this is actually a PMMark -- however our version
 * of the prosemirror and prosemirror types mean using PMNode
 * is not problematic.
 */
mark, view) {
  (0, _classCallCheck2.default)(this, BreakoutView);
  var dom = document.createElement('div');
  var contentDOM = document.createElement('div');
  contentDOM.className = _styles.BreakoutCssClassName.BREAKOUT_MARK_DOM;
  contentDOM.setAttribute('data-testid', 'ak-editor-breakout-mark-dom');
  dom.className = _styles.BreakoutCssClassName.BREAKOUT_MARK;
  dom.setAttribute('data-layout', mark.attrs.mode);
  dom.setAttribute('data-testid', 'ak-editor-breakout-mark');
  dom.appendChild(contentDOM);
  dom.style.transform = 'none';
  dom.style.display = 'flex';
  dom.style.justifyContent = 'center';
  contentDOM.style.transition = "min-width 0.5s ".concat(_editorSharedStyles.akEditorSwoopCubicBezier);
  if ((0, _experiments.editorExperiment)('advanced_layouts', true)) {
    if (mark.attrs.width) {
      contentDOM.style.minWidth = "min(".concat(mark.attrs.width, "px, calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding)))");
    } else {
      // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
      if (mark.attrs.mode === 'full-width') {
        contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
      }
      if (mark.attrs.mode === 'wide') {
        contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
      }
    }
  } else {
    // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
    if (mark.attrs.mode === 'full-width') {
      contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
    }
    if (mark.attrs.mode === 'wide') {
      contentDOM.style.minWidth = "max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))";
    }
  }
  this.dom = dom;
  this.mark = mark;
  this.view = view;
  this.contentDOM = contentDOM;
});
function shouldPluginStateUpdate(newBreakoutNode, currentBreakoutNode) {
  if (newBreakoutNode && currentBreakoutNode) {
    return newBreakoutNode !== currentBreakoutNode;
  }
  return newBreakoutNode || currentBreakoutNode ? true : false;
}
function createPlugin(pluginInjectionApi, _ref) {
  var dispatch = _ref.dispatch;
  return new _safePlugin.SafePlugin({
    state: {
      init: function init() {
        return {
          breakoutNode: undefined
        };
      },
      apply: function apply(tr, pluginState) {
        var breakoutNode = (0, _findBreakoutNode.findSupportedNodeForBreakout)(tr.selection);
        if (shouldPluginStateUpdate(breakoutNode, pluginState.breakoutNode)) {
          var nextPluginState = _objectSpread(_objectSpread({}, pluginState), {}, {
            breakoutNode: breakoutNode
          });
          dispatch(_pluginKey.pluginKey, nextPluginState);
          return nextPluginState;
        }
        return pluginState;
      }
    },
    key: _pluginKey.pluginKey,
    props: {
      nodeViews: {
        // Note: When we upgrade to prosemirror 1.27.2 -- we should
        // move this to markViews.
        // See the following link for more details:
        // https://prosemirror.net/docs/ref/#view.EditorProps.nodeViews.
        breakout: function breakout(mark, view) {
          return new BreakoutView(mark, view);
        }
      }
    }
  });
}
var LayoutButtonWrapper = function LayoutButtonWrapper(_ref2) {
  var _breakoutState$breako, _breakoutState$breako2;
  var api = _ref2.api,
    editorView = _ref2.editorView,
    boundariesElement = _ref2.boundariesElement,
    scrollableElement = _ref2.scrollableElement,
    mountPoint = _ref2.mountPoint;
  // Re-render with `width` (but don't use state) due to https://bitbucket.org/atlassian/%7Bc8e2f021-38d2-46d0-9b7a-b3f7b428f724%7D/pull-requests/24272
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(api, ['width', 'breakout', 'editorViewMode', 'editorDisabled', 'blockControls']),
    breakoutState = _useSharedPluginState.breakoutState,
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    editorDisabledState = _useSharedPluginState.editorDisabledState,
    blockControlsState = _useSharedPluginState.blockControlsState;
  if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isDragging || blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isPMDragging) {
    if ((0, _experiments.editorExperiment)('advanced_layouts', true)) {
      return null;
    }
  }
  var isViewMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  var isEditMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'edit';
  return !isViewMode && editorDisabledState !== undefined && !(editorDisabledState !== null && editorDisabledState !== void 0 && editorDisabledState.editorDisabled) ? /*#__PURE__*/_react.default.createElement(_LayoutButton.default, {
    editorView: editorView,
    mountPoint: mountPoint,
    boundariesElement: boundariesElement,
    scrollableElement: scrollableElement,
    node: (_breakoutState$breako = breakoutState === null || breakoutState === void 0 || (_breakoutState$breako2 = breakoutState.breakoutNode) === null || _breakoutState$breako2 === void 0 ? void 0 : _breakoutState$breako2.node) !== null && _breakoutState$breako !== void 0 ? _breakoutState$breako : null,
    isLivePage: isEditMode
  }) : null;
};
var breakoutPlugin = exports.breakoutPlugin = function breakoutPlugin(_ref3) {
  var options = _ref3.config,
    api = _ref3.api;
  return {
    name: 'breakout',
    pmPlugins: function pmPlugins() {
      return [{
        name: 'breakout',
        plugin: function plugin(props) {
          return createPlugin(api, props);
        }
      }];
    },
    marks: function marks() {
      return [{
        name: 'breakout',
        mark: _adfSchema.breakout
      }];
    },
    getSharedState: function getSharedState(editorState) {
      if (!editorState) {
        return {
          breakoutNode: undefined
        };
      }
      var pluginState = _pluginKey.pluginKey.getState(editorState);
      if (!pluginState) {
        return {
          breakoutNode: undefined
        };
      }
      return pluginState;
    },
    contentComponent: function contentComponent(_ref4) {
      var editorView = _ref4.editorView,
        popupsMountPoint = _ref4.popupsMountPoint,
        popupsBoundariesElement = _ref4.popupsBoundariesElement,
        popupsScrollableElement = _ref4.popupsScrollableElement;
      // This is a bit crappy, but should be resolved once we move to a static schema.
      if (options && !options.allowBreakoutButton) {
        return null;
      }
      return /*#__PURE__*/_react.default.createElement(LayoutButtonWrapper, {
        api: api,
        mountPoint: popupsMountPoint,
        editorView: editorView,
        boundariesElement: popupsBoundariesElement,
        scrollableElement: popupsScrollableElement
      });
    }
  };
};