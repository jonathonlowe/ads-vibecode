import React from 'react';
import { breakout } from '@atlaskit/adf-schema';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { BreakoutCssClassName } from '@atlaskit/editor-common/styles';
import { akEditorSwoopCubicBezier } from '@atlaskit/editor-shared-styles';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { pluginKey } from './pm-plugins/plugin-key';
import { findSupportedNodeForBreakout } from './pm-plugins/utils/find-breakout-node';
import LayoutButton from './ui/LayoutButton';
class BreakoutView {
  constructor(
  /**
   * Note: this is actually a PMMark -- however our version
   * of the prosemirror and prosemirror types mean using PMNode
   * is not problematic.
   */
  mark, view) {
    const dom = document.createElement('div');
    const contentDOM = document.createElement('div');
    contentDOM.className = BreakoutCssClassName.BREAKOUT_MARK_DOM;
    contentDOM.setAttribute('data-testid', 'ak-editor-breakout-mark-dom');
    dom.className = BreakoutCssClassName.BREAKOUT_MARK;
    dom.setAttribute('data-layout', mark.attrs.mode);
    dom.setAttribute('data-testid', 'ak-editor-breakout-mark');
    dom.appendChild(contentDOM);
    dom.style.transform = 'none';
    dom.style.display = 'flex';
    dom.style.justifyContent = 'center';
    contentDOM.style.transition = `min-width 0.5s ${akEditorSwoopCubicBezier}`;
    if (editorExperiment('advanced_layouts', true)) {
      if (mark.attrs.width) {
        contentDOM.style.minWidth = `min(${mark.attrs.width}px, calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding)))`;
      } else {
        // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
        if (mark.attrs.mode === 'full-width') {
          contentDOM.style.minWidth = `max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))`;
        }
        if (mark.attrs.mode === 'wide') {
          contentDOM.style.minWidth = `max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))`;
        }
      }
    } else {
      // original breakout algorithm is in calcBreakoutWidth from platform/packages/editor/editor-common/src/utils/breakout.ts
      if (mark.attrs.mode === 'full-width') {
        contentDOM.style.minWidth = `max(var(--ak-editor--line-length), min(var(--ak-editor--full-width-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))`;
      }
      if (mark.attrs.mode === 'wide') {
        contentDOM.style.minWidth = `max(var(--ak-editor--line-length), min(var(--ak-editor--breakout-wide-layout-width), calc(100cqw - var(--ak-editor--breakout-full-page-guttering-padding))))`;
      }
    }
    this.dom = dom;
    this.mark = mark;
    this.view = view;
    this.contentDOM = contentDOM;
  }
}
function shouldPluginStateUpdate(newBreakoutNode, currentBreakoutNode) {
  if (newBreakoutNode && currentBreakoutNode) {
    return newBreakoutNode !== currentBreakoutNode;
  }
  return newBreakoutNode || currentBreakoutNode ? true : false;
}
function createPlugin(pluginInjectionApi, {
  dispatch
}) {
  return new SafePlugin({
    state: {
      init() {
        return {
          breakoutNode: undefined
        };
      },
      apply(tr, pluginState) {
        const breakoutNode = findSupportedNodeForBreakout(tr.selection);
        if (shouldPluginStateUpdate(breakoutNode, pluginState.breakoutNode)) {
          const nextPluginState = {
            ...pluginState,
            breakoutNode
          };
          dispatch(pluginKey, nextPluginState);
          return nextPluginState;
        }
        return pluginState;
      }
    },
    key: pluginKey,
    props: {
      nodeViews: {
        // Note: When we upgrade to prosemirror 1.27.2 -- we should
        // move this to markViews.
        // See the following link for more details:
        // https://prosemirror.net/docs/ref/#view.EditorProps.nodeViews.
        breakout: (mark, view) => {
          return new BreakoutView(mark, view);
        }
      }
    }
  });
}
const LayoutButtonWrapper = ({
  api,
  editorView,
  boundariesElement,
  scrollableElement,
  mountPoint
}) => {
  var _breakoutState$breako, _breakoutState$breako2;
  // Re-render with `width` (but don't use state) due to https://bitbucket.org/atlassian/%7Bc8e2f021-38d2-46d0-9b7a-b3f7b428f724%7D/pull-requests/24272
  const {
    breakoutState,
    editorViewModeState,
    editorDisabledState,
    blockControlsState
  } = useSharedPluginState(api, ['width', 'breakout', 'editorViewMode', 'editorDisabled', 'blockControls']);
  if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isDragging || blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isPMDragging) {
    if (editorExperiment('advanced_layouts', true)) {
      return null;
    }
  }
  const isViewMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  const isEditMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'edit';
  return !isViewMode && editorDisabledState !== undefined && !(editorDisabledState !== null && editorDisabledState !== void 0 && editorDisabledState.editorDisabled) ? /*#__PURE__*/React.createElement(LayoutButton, {
    editorView: editorView,
    mountPoint: mountPoint,
    boundariesElement: boundariesElement,
    scrollableElement: scrollableElement,
    node: (_breakoutState$breako = breakoutState === null || breakoutState === void 0 ? void 0 : (_breakoutState$breako2 = breakoutState.breakoutNode) === null || _breakoutState$breako2 === void 0 ? void 0 : _breakoutState$breako2.node) !== null && _breakoutState$breako !== void 0 ? _breakoutState$breako : null,
    isLivePage: isEditMode
  }) : null;
};
export const breakoutPlugin = ({
  config: options,
  api
}) => ({
  name: 'breakout',
  pmPlugins() {
    return [{
      name: 'breakout',
      plugin: props => createPlugin(api, props)
    }];
  },
  marks() {
    return [{
      name: 'breakout',
      mark: breakout
    }];
  },
  getSharedState(editorState) {
    if (!editorState) {
      return {
        breakoutNode: undefined
      };
    }
    const pluginState = pluginKey.getState(editorState);
    if (!pluginState) {
      return {
        breakoutNode: undefined
      };
    }
    return pluginState;
  },
  contentComponent({
    editorView,
    popupsMountPoint,
    popupsBoundariesElement,
    popupsScrollableElement
  }) {
    // This is a bit crappy, but should be resolved once we move to a static schema.
    if (options && !options.allowBreakoutButton) {
      return null;
    }
    return /*#__PURE__*/React.createElement(LayoutButtonWrapper, {
      api: api,
      mountPoint: popupsMountPoint,
      editorView: editorView,
      boundariesElement: popupsBoundariesElement,
      scrollableElement: popupsScrollableElement
    });
  }
});