import React, { useEffect } from 'react';
import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { ElementBrowser } from '@atlaskit/editor-common/element-browser';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { ToolbarSize } from '@atlaskit/editor-common/types';
import { BLOCK_QUOTE, CODE_BLOCK, PANEL } from '@atlaskit/editor-plugin-block-type/consts';
import { fg } from '@atlaskit/platform-feature-flags';
import { toggleInsertBlockPmKey, toggleInsertBlockPmPlugin } from './pm-plugins/toggleInsertBlock';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import ToolbarInsertBlock from './ui/ToolbarInsertBlock';
export const toolbarSizeToButtons = (toolbarSize, appearance) => {
  // Different button numbers for full-page to better match full page toolbar breakpoints
  if (appearance === 'full-page' && fg('platform_editor_toolbar_responsive_fixes')) {
    switch (toolbarSize) {
      case ToolbarSize.XXL:
      case ToolbarSize.XL:
      case ToolbarSize.L:
        return 7;
      case ToolbarSize.M:
        return 3;
      default:
        return 0;
    }
  }
  if (fg('platform_editor_toolbar_responsive_fixes')) {
    switch (toolbarSize) {
      case ToolbarSize.XXL:
      case ToolbarSize.XL:
        return 7;
      case ToolbarSize.L:
        return 5;
      case ToolbarSize.M:
      case ToolbarSize.S:
        return 2;
      default:
        return 0;
    }
  } else {
    switch (toolbarSize) {
      case ToolbarSize.XXL:
      case ToolbarSize.XL:
      case ToolbarSize.L:
      case ToolbarSize.M:
        return 7;
      case ToolbarSize.S:
        return 2;
      default:
        return 0;
    }
  }
};

/**
 * Wrapper over insertBlockTypeWithAnalytics to autobind toolbar input method
 * @param name Block name
 */
function handleInsertBlockType(insertCodeBlock, insertPanel, insertBlockQuote) {
  return name => {
    if (name === CODE_BLOCK.name && insertCodeBlock) {
      return insertCodeBlock(INPUT_METHOD.TOOLBAR);
    }
    if (name === PANEL.name && insertPanel) {
      return insertPanel(INPUT_METHOD.TOOLBAR);
    }
    if (name === BLOCK_QUOTE.name && insertBlockQuote) {
      return insertBlockQuote(INPUT_METHOD.INSERT_MENU);
    }
    return () => false;
  };
}
function delayUntilIdle(cb) {
  if (typeof window === 'undefined') {
    return;
  }
  // eslint-disable-next-line compat/compat
  if (window.requestIdleCallback !== undefined) {
    // eslint-disable-next-line compat/compat
    return window.requestIdleCallback(() => cb(), {
      timeout: 500
    });
  }
  return window.requestAnimationFrame(() => cb());
}
export const insertBlockPlugin = ({
  config: options = {},
  api
}) => {
  var _api$primaryToolbar;
  const primaryToolbarComponent = ({
    editorView,
    editorActions,
    dispatchAnalyticsEvent,
    providerFactory,
    popupsMountPoint,
    popupsBoundariesElement,
    popupsScrollableElement,
    toolbarSize,
    disabled,
    isToolbarReducedSpacing,
    isLastItem
  }) => {
    const renderNode = providers => {
      return /*#__PURE__*/React.createElement(ToolbarInsertBlockWithInjectionApi, {
        pluginInjectionApi: api,
        editorView: editorView,
        editorActions: editorActions,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent,
        providerFactory: providerFactory,
        popupsMountPoint: popupsMountPoint,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsScrollableElement: popupsScrollableElement,
        toolbarSize: toolbarSize,
        disabled: disabled,
        isToolbarReducedSpacing: isToolbarReducedSpacing,
        isLastItem: isLastItem,
        providers: providers,
        options: options,
        appearance: options.appearance
      });
    };
    return /*#__PURE__*/React.createElement(WithProviders, {
      providerFactory: providerFactory,
      providers: ['emojiProvider'],
      renderNode: renderNode
    });
  };
  api === null || api === void 0 ? void 0 : (_api$primaryToolbar = api.primaryToolbar) === null || _api$primaryToolbar === void 0 ? void 0 : _api$primaryToolbar.actions.registerComponent({
    name: 'insertBlock',
    component: primaryToolbarComponent
  });
  const plugin = {
    name: 'insertBlock',
    actions: {
      toggleAdditionalMenu: () => {
        var _api$core;
        api === null || api === void 0 ? void 0 : (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(({
          tr
        }) => {
          return tr.setMeta(toggleInsertBlockPmKey, true);
        });
      }
    },
    getSharedState: editorState => {
      var _options$appearance;
      if (!editorState || !['full-page', 'full-width'].includes((_options$appearance = options.appearance) !== null && _options$appearance !== void 0 ? _options$appearance : '')) {
        return;
      }
      const toggleInsertBlockPluginState = toggleInsertBlockPmKey.getState(editorState);
      return {
        showElementBrowser: (toggleInsertBlockPluginState === null || toggleInsertBlockPluginState === void 0 ? void 0 : toggleInsertBlockPluginState.showElementBrowser) || false
      };
    },
    usePluginHook() {
      useEffect(() => {
        // This is to optimise the UI so that when the user first clicks on the insert
        // menu it opens instantly. As we're delaying the loading this won't affect the
        // initial editor rendering metrics.
        delayUntilIdle(() => {
          ElementBrowser.preload();
        });
      }, []);
    },
    pmPlugins: () => {
      var _options$appearance2;
      if (!['full-page', 'full-width'].includes((_options$appearance2 = options.appearance) !== null && _options$appearance2 !== void 0 ? _options$appearance2 : '')) {
        [];
      }
      const plugins = [];
      plugins.push({
        name: 'toggleInsertBlockPmPlugin',
        plugin: () => toggleInsertBlockPmPlugin()
      });
      return plugins;
    },
    pluginsOptions: {},
    primaryToolbarComponent: !(api !== null && api !== void 0 && api.primaryToolbar) ? primaryToolbarComponent : undefined
  };
  return plugin;
};
function ToolbarInsertBlockWithInjectionApi({
  editorView,
  editorActions,
  dispatchAnalyticsEvent,
  popupsMountPoint,
  popupsBoundariesElement,
  popupsScrollableElement,
  toolbarSize,
  disabled,
  isToolbarReducedSpacing,
  isLastItem,
  providers,
  pluginInjectionApi,
  options,
  appearance
}) {
  var _ref, _pluginInjectionApi$i, _pluginInjectionApi$c2, _pluginInjectionApi$p, _pluginInjectionApi$b, _pluginInjectionApi$e;
  const buttons = toolbarSizeToButtons(toolbarSize, appearance);
  const {
    dateState,
    hyperlinkState,
    imageUploadState,
    mentionState,
    emojiState,
    blockTypeState,
    mediaState,
    typeAheadState,
    placeholderTextState,
    insertBlockState,
    connectivityState
  } = useSharedPluginState(pluginInjectionApi, ['hyperlink', 'date', 'imageUpload', 'mention', 'emoji', 'blockType', 'media', 'typeAhead', 'placeholderText', 'insertBlock', 'connectivity']);
  const getEmojiProvider = () => {
    if (emojiState !== null && emojiState !== void 0 && emojiState.emojiProvider) {
      return Promise.resolve(emojiState === null || emojiState === void 0 ? void 0 : emojiState.emojiProvider);
    }
  };
  const emojiProvider = getEmojiProvider();
  const onShowMediaPicker = mountInfo => {
    if (!mediaState) {
      return;
    }
    if (fg('platform_editor_add_media_from_url_rollout')) {
      var _pluginInjectionApi$c, _pluginInjectionApi$m;
      pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$c = pluginInjectionApi.core) === null || _pluginInjectionApi$c === void 0 ? void 0 : _pluginInjectionApi$c.actions.execute(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$m = pluginInjectionApi.mediaInsert) === null || _pluginInjectionApi$m === void 0 ? void 0 : _pluginInjectionApi$m.commands.showMediaInsertPopup(mountInfo));
    } else {
      mediaState.showMediaPicker();
    }
  };
  return /*#__PURE__*/React.createElement(ToolbarInsertBlock, {
    showElementBrowser: (insertBlockState === null || insertBlockState === void 0 ? void 0 : insertBlockState.showElementBrowser) || false,
    pluginInjectionApi: pluginInjectionApi,
    buttons: buttons,
    isReducedSpacing: isToolbarReducedSpacing,
    isDisabled: disabled,
    isTypeAheadAllowed: Boolean(typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isAllowed),
    editorView: editorView,
    tableSupported: !!editorView.state.schema.nodes.table,
    tableSelectorSupported: options.tableSelectorSupported && !!editorView.state.schema.nodes.table,
    actionSupported: !!editorView.state.schema.nodes.taskItem,
    mentionsSupported: !!(mentionState && mentionState.mentionProvider),
    mentionsDisabled: !!(mentionState && !mentionState.canInsertMention),
    decisionSupported: !!editorView.state.schema.nodes.decisionItem,
    dateEnabled: !!dateState,
    placeholderTextEnabled: placeholderTextState && placeholderTextState.allowInserting,
    layoutSectionEnabled: Boolean(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : pluginInjectionApi.layout),
    expandEnabled: !!options.allowExpand,
    mediaUploadsEnabled: (_ref = mediaState && mediaState.allowsUploads) !== null && _ref !== void 0 ? _ref : undefined,
    onShowMediaPicker: onShowMediaPicker,
    mediaSupported: !!mediaState,
    isEditorOffline: (connectivityState === null || connectivityState === void 0 ? void 0 : connectivityState.mode) === 'offline',
    imageUploadSupported: !!(pluginInjectionApi !== null && pluginInjectionApi !== void 0 && pluginInjectionApi.imageUpload),
    imageUploadEnabled: imageUploadState === null || imageUploadState === void 0 ? void 0 : imageUploadState.enabled,
    handleImageUpload: pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$i = pluginInjectionApi.imageUpload) === null || _pluginInjectionApi$i === void 0 ? void 0 : _pluginInjectionApi$i.actions.startUpload,
    availableWrapperBlockTypes: blockTypeState && blockTypeState.availableWrapperBlockTypes,
    linkSupported: !!hyperlinkState,
    linkDisabled: !hyperlinkState || !hyperlinkState.canInsertLink || !!hyperlinkState.activeLinkMark,
    emojiDisabled: !emojiState || !emojiProvider,
    emojiProvider: emojiProvider,
    nativeStatusSupported: options.nativeStatusSupported,
    horizontalRuleEnabled: options.horizontalRuleEnabled,
    onInsertBlockType: handleInsertBlockType(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$c2 = pluginInjectionApi.codeBlock) === null || _pluginInjectionApi$c2 === void 0 ? void 0 : _pluginInjectionApi$c2.actions.insertCodeBlock, pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$p = pluginInjectionApi.panel) === null || _pluginInjectionApi$p === void 0 ? void 0 : _pluginInjectionApi$p.actions.insertPanel, pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$b = pluginInjectionApi.blockType) === null || _pluginInjectionApi$b === void 0 ? void 0 : _pluginInjectionApi$b.actions.insertBlockQuote),
    onInsertMacroFromMacroBrowser: pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$e = pluginInjectionApi.extension) === null || _pluginInjectionApi$e === void 0 ? void 0 : _pluginInjectionApi$e.actions.insertMacroFromMacroBrowser,
    popupsMountPoint: popupsMountPoint,
    popupsBoundariesElement: popupsBoundariesElement,
    popupsScrollableElement: popupsScrollableElement,
    insertMenuItems: options.insertMenuItems,
    editorActions: editorActions,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    showElementBrowserLink: options.showElementBrowserLink,
    showSeparator: !isLastItem && toolbarSize <= ToolbarSize.S,
    editorAppearance: options.appearance
  });
}