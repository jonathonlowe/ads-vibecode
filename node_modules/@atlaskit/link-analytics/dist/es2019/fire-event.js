import { getDomainFromUrl, mergeAttributes } from './utils';
import { resolveAttributes } from './utils';
import { EVENT_CHANNEL } from './common/utils/constants';
import createEventPayload from './common/utils/analytics/create-event-payload';
import { getStatus } from '@atlaskit/linking-common';
import { DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE } from '@atlaskit/link-client-extension';
const PACKAGE_DATA = {
  packageName: "@atlaskit/link-analytics",
  packageVersion: "9.1.1"
};
const fireEvent = (action, createAnalyticsEvent, client, store) => {
  return async (details, sourceEvent, attributes = {}) => {
    const resolvedAttributes = await resolveAttributes(details, client, store);
    const mergedAttributes = mergeAttributes(action, details, sourceEvent, {
      ...attributes,
      ...resolvedAttributes
    });
    const payload = createEventPayload(`track.link.${action}`, mergedAttributes);
    const event = createAnalyticsEvent({
      ...payload,
      nonPrivacySafeAttributes: {
        domainName: getDomainFromUrl(details.url)
      }
    });
    event.context.push(PACKAGE_DATA);
    event.fire(EVENT_CHANNEL);
  };
};
export default fireEvent;
export const fireDatasourceEvent = (action, createAnalyticsEvent, getDatasourceData) => {
  return async (details, sourceEvent, attributes = {}) => {
    var _schema$defaultProper, _schema$defaultProper2, _schema$properties, _details$url;
    const {
      data: {
        totalCount: totalItemCount,
        schema
      },
      meta,
      meta: {
        extensionKey,
        destinationObjectTypes
      }
    } = await getDatasourceData(details.datasourceId, {
      parameters: details.parameters,
      // Currently, pageSize doesn't change the values we are interested in
      pageSize: DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE,
      includeSchema: true,
      fields: []
    });
    const status = getStatus({
      meta
    });
    const resolvedAttributes = {
      extensionKey,
      status: status,
      destinationObjectTypes,
      totalItemCount,
      displayedColumnCount: (_schema$defaultProper = schema === null || schema === void 0 ? void 0 : (_schema$defaultProper2 = schema.defaultProperties) === null || _schema$defaultProper2 === void 0 ? void 0 : _schema$defaultProper2.length) !== null && _schema$defaultProper !== void 0 ? _schema$defaultProper : schema === null || schema === void 0 ? void 0 : (_schema$properties = schema.properties) === null || _schema$properties === void 0 ? void 0 : _schema$properties.length
    };
    const mergedAttributes = mergeAttributes(action, {
      ...details,
      url: (_details$url = details.url) !== null && _details$url !== void 0 ? _details$url : 'unknown'
    }, sourceEvent, {
      ...resolvedAttributes,
      ...attributes
    });
    const payload = createEventPayload(`track.datasource.${action}`, mergedAttributes);
    const event = createAnalyticsEvent({
      ...payload,
      nonPrivacySafeAttributes: {
        domainName: details.url ? getDomainFromUrl(details.url) : ''
      }
    });
    if (extensionKey === 'jira-object-provider' && action === 'created') {
      // macro inserted event name is consistent with what confluence uses for JIM inserts
      const payload = createEventPayload(`track.macro.inserted`, {
        ...mergedAttributes
      });
      createAnalyticsEvent({
        ...payload,
        actionSubjectId: 'jlol'
      }).fire(EVENT_CHANNEL);
    }
    event.context.push(PACKAGE_DATA);
    event.fire(EVENT_CHANNEL);
  };
};