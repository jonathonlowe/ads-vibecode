import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { isOptionsGrouped } from '@atlaskit/select';
import { ALLOWED_LOGGED_MACRO_PARAMS, ALLOWED_PARAM_TYPES } from './constants';
import { ValidationError } from './types';
export var validate = function validate(field, value) {
  return validateRequired(field, value);
};
var isEmptyString = function isEmptyString(value) {
  return typeof value === 'string' && value === '';
};
var isEmptyArray = function isEmptyArray(value) {
  return Array.isArray(value) && value.length === 0;
};
var getUngroupedOptions = function getUngroupedOptions(groupedOptions) {
  return groupedOptions.flatMap(function (option) {
    return option.options;
  });
};
export var validateRequired = function validateRequired(_ref, value) {
  var isRequired = _ref.isRequired,
    isMultiple = _ref.isMultiple;
  if (isRequired) {
    var isUndefined = typeof value === 'undefined';
    var isEmpty = isEmptyString(value) || isMultiple && isEmptyArray(value) || false;
    return isUndefined || isEmpty ? ValidationError.Required : undefined;
  }
  return undefined;
};
export var getOptionFromValue = function getOptionFromValue(options, value) {
  if (!Array.isArray(options) || options.length === 0) {
    return undefined;
  }
  if (Array.isArray(value)) {
    if (isOptionsGrouped(options)) {
      return getUngroupedOptions(options).filter(function (option) {
        return value.includes(option.value);
      });
    }
    return options.filter(function (option) {
      return value.includes(option.value);
    });
  }
  if (isOptionsGrouped(options)) {
    return getUngroupedOptions(options).find(function (option) {
      return value === option.value;
    });
  }
  return options.find(function (option) {
    return value === option.value;
  });
};

// Atlaskit uses final-form to power the form.
// Final-form will create nesting in the tree if a dot (.) is used in the name of the field.
// A parent is provided from a <Fieldset /> and is appended to the name here for simplicity
export var getSafeParentedName = function getSafeParentedName(name, parentName) {
  if (parentName && name.indexOf("".concat(parentName, ".")) === -1) {
    return "".concat(parentName, ".").concat(name);
  }
  return name;
};

// Ignored via go/ees005
// eslint-disable-next-line require-unicode-regexp
var duplicateFieldRegex = /:[0-9]+$/;
export var isDuplicateField = function isDuplicateField(key) {
  return duplicateFieldRegex.test(key);
};
export var getNameFromDuplicateField = function getNameFromDuplicateField(key) {
  return key.replace(duplicateFieldRegex, '');
};

// An overly cautious parser for sanitizing configuration parameters of UGC
export var parseParamType = function parseParamType(paramValue, paramField) {
  if (paramValue && paramField) {
    if (paramField.type === 'string') {
      if (paramField.name === 'types') {
        // Parse types field as an array of valid content types
        var contentTypes = ['page', 'blogpost', 'comment', 'attachment'];
        return paramValue && paramValue.split(',').map(function (type) {
          return type.trim();
        }).filter(function (type) {
          return contentTypes.includes(type);
        });
      }
      if (paramField.name === 'width') {
        return parseFloat(paramValue);
      }
      // Strings are very risky - return empty string in case anything slips through
      return '';
    }
    if (ALLOWED_PARAM_TYPES.includes(paramField.type)) {
      // The param types defined here are already parsed and safe to log
      return paramValue;
    }
  }
  // Safety net
  return null;
};
export var getLoggedParameters = function getLoggedParameters(macroKey, currentParams, macroFields) {
  // Get the parameters only defined in the allowlist of logged macro/parameter keys
  return Object.keys(currentParams).filter(function (paramKey) {
    var _ALLOWED_LOGGED_MACRO;
    return (_ALLOWED_LOGGED_MACRO = ALLOWED_LOGGED_MACRO_PARAMS[macroKey]) === null || _ALLOWED_LOGGED_MACRO === void 0 ? void 0 : _ALLOWED_LOGGED_MACRO.includes(paramKey);
  }).reduce(function (obj, param) {
    return _objectSpread(_objectSpread({}, obj), {}, _defineProperty({}, param, parseParamType(currentParams[param], macroFields === null || macroFields === void 0 ? void 0 : macroFields.find(function (field) {
      return field.name === param;
    }))));
  }, {});
};