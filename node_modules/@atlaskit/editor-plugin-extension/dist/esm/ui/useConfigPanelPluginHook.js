import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useEffect } from 'react';
import { getExtensionKeyAndNodeKey } from '@atlaskit/editor-common/extensions';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { Box } from '@atlaskit/primitives/compiled';
import { clearEditingContext, forceAutoSave } from '../editor-commands/commands';
import { getPluginState } from '../pm-plugins/plugin-factory';
import { getSelectedExtension } from '../pm-plugins/utils';
import ConfigPanelLoader from './ConfigPanel/ConfigPanelLoader';
import { CONFIG_PANEL_ID, CONFIG_PANEL_WIDTH } from './ConfigPanel/constants';
import HeaderAfterIconElement from './ConfigPanel/Header/HeaderAfterIconElement';
import HeaderIcon from './ConfigPanel/Header/HeaderIcon';
import { onChangeAction } from './context-panel';
import { SaveIndicator } from './SaveIndicator/SaveIndicator';
export function useConfigPanelPluginHook(_ref) {
  var editorView = _ref.editorView,
    api = _ref.api;
  var editorState = editorView.state;
  var _useSharedPluginState = useSharedPluginState(api, ['extension']),
    extensionState = _useSharedPluginState.extensionState;
  useEffect(function () {
    var nodeWithPos = getSelectedExtension(editorState, true);
    // Adding checks to bail out early
    if (!nodeWithPos || !extensionState) {
      hideConfigPanel(api);
      return;
    }
    if (extensionState) {
      var showContextPanel = extensionState.showContextPanel,
        extensionProvider = extensionState.extensionProvider,
        processParametersAfter = extensionState.processParametersAfter;
      if (showContextPanel && extensionProvider && processParametersAfter) {
        showConfigPanel({
          api: api,
          editorView: editorView,
          extensionProvider: extensionProvider,
          nodeWithPos: nodeWithPos
        });
      } else {
        hideConfigPanel(api);
      }
    }
  }, [api, editorState, editorView, extensionState]);
  useEffect(function () {
    return function () {
      hideConfigPanel(api);
    };
  }, [api]);
}
export function hideConfigPanel(api) {
  var _api$contextPanel;
  var closePanelById = api === null || api === void 0 || (_api$contextPanel = api.contextPanel) === null || _api$contextPanel === void 0 || (_api$contextPanel = _api$contextPanel.actions) === null || _api$contextPanel === void 0 ? void 0 : _api$contextPanel.closePanelById;
  if (closePanelById) {
    closePanelById(CONFIG_PANEL_ID);
  }
}
export function showConfigPanel(_ref2) {
  var _api$contextPanel2;
  var api = _ref2.api,
    editorView = _ref2.editorView,
    extensionProvider = _ref2.extensionProvider,
    nodeWithPos = _ref2.nodeWithPos;
  var showContextPanel = api === null || api === void 0 || (_api$contextPanel2 = api.contextPanel) === null || _api$contextPanel2 === void 0 || (_api$contextPanel2 = _api$contextPanel2.actions) === null || _api$contextPanel2 === void 0 ? void 0 : _api$contextPanel2.showPanel;
  if (showContextPanel) {
    var nodeAttrs = nodeWithPos === null || nodeWithPos === void 0 ? void 0 : nodeWithPos.node.attrs;
    var extensionType = nodeAttrs === null || nodeAttrs === void 0 ? void 0 : nodeAttrs.extensionType;
    var extensionKey = nodeAttrs === null || nodeAttrs === void 0 ? void 0 : nodeAttrs.extensionKey;

    /**
     * Loading extension manifest fails when using
     * 	extensionKey directly from nodeAttrs.
     * Always get extensionKey from getExtensionKeyAndNodeKey to load
     * 	extension manifest successfully.
     */
    var _getExtensionKeyAndNo = getExtensionKeyAndNodeKey(extensionKey, extensionType),
      _getExtensionKeyAndNo2 = _slicedToArray(_getExtensionKeyAndNo, 2),
      extKey = _getExtensionKeyAndNo2[0],
      _ = _getExtensionKeyAndNo2[1];
    var HeadeIconWrapper = function HeadeIconWrapper() {
      return /*#__PURE__*/React.createElement(HeaderIcon, {
        extensionProvider: extensionProvider,
        extensionKey: extKey,
        extensionType: extensionType
      });
    };
    var HeaderAfterIconElementWrapper = function HeaderAfterIconElementWrapper() {
      return /*#__PURE__*/React.createElement(HeaderAfterIconElement, {
        extensionProvider: extensionProvider,
        extensionKey: extKey,
        extensionType: extensionType
      });
    };
    var BodyComponent = getContextPanelBodyComponent({
      api: api,
      editorView: editorView,
      extensionProvider: extensionProvider,
      nodeWithPos: nodeWithPos
    });
    showContextPanel({
      id: CONFIG_PANEL_ID,
      headerComponentElements: {
        HeaderIcon: HeadeIconWrapper,
        HeaderAfterIconElement: HeaderAfterIconElementWrapper
      },
      BodyComponent: BodyComponent,
      closeOptions: {
        canClosePanel: function canClosePanel() {
          // When navigating away from the editor, the editorView is destroyed.
          if (editorView.isDestroyed) {
            return true;
          }
          var extensionState = getPluginState(editorView.state);
          /**
           * 	If context panel is open, then first update extension plugin state.
           * 	Updating extension plugin state will trigger useEffect in useConfigPanelPluginHook,
           * 		which will call hideConfigPanel.
           */
          if (extensionState !== null && extensionState !== void 0 && extensionState.showContextPanel) {
            startClosingConfigPanel({
              api: api,
              editorView: editorView
            });
            return false;
          }

          // Return true if extension plugin state has been updated and hideConfigPanel has been called.
          return true;
        }
      }
    }, 'push', CONFIG_PANEL_WIDTH);
  }
}
export function startClosingConfigPanel(_x) {
  return _startClosingConfigPanel.apply(this, arguments);
}
function _startClosingConfigPanel() {
  _startClosingConfigPanel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {
    var _api$contextPanel3;
    var api, editorView, applyChange;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          api = _ref3.api, editorView = _ref3.editorView;
          applyChange = api === null || api === void 0 || (_api$contextPanel3 = api.contextPanel) === null || _api$contextPanel3 === void 0 ? void 0 : _api$contextPanel3.actions.applyChange; // Even if the save failed, we should proceed with closing the panel
          clearEditingContext(applyChange)(editorView.state, editorView.dispatch);
          _context2.prev = 3;
          _context2.next = 6;
          return new Promise(function (resolve, reject) {
            forceAutoSave(applyChange)(resolve, reject)(editorView.state, editorView.dispatch);
          });
        case 6:
          _context2.next = 11;
          break;
        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2["catch"](3);
          // Even if the save failed, we should proceed with closing the panel
          // eslint-disable-next-line no-console
          console.error("Autosave failed with error", _context2.t0);
        case 11:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[3, 8]]);
  }));
  return _startClosingConfigPanel.apply(this, arguments);
}
export var getContextPanelBodyComponent = function getContextPanelBodyComponent(_ref4) {
  var _api$featureFlags;
  var api = _ref4.api,
    editorView = _ref4.editorView,
    extensionProvider = _ref4.extensionProvider,
    nodeWithPos = _ref4.nodeWithPos;
  var featureFlags = (api === null || api === void 0 || (_api$featureFlags = api.featureFlags) === null || _api$featureFlags === void 0 ? void 0 : _api$featureFlags.sharedState.currentState()) || {};
  var editorState = editorView.state;
  var extensionState = getPluginState(editorState);
  var autoSaveResolve = extensionState.autoSaveResolve,
    autoSaveReject = extensionState.autoSaveReject,
    processParametersBefore = extensionState.processParametersBefore;
  var _nodeWithPos$node$att = nodeWithPos.node.attrs,
    extensionType = _nodeWithPos$node$att.extensionType,
    extensionKey = _nodeWithPos$node$att.extensionKey,
    parameters = _nodeWithPos$node$att.parameters;
  var _getExtensionKeyAndNo3 = getExtensionKeyAndNodeKey(extensionKey, extensionType),
    _getExtensionKeyAndNo4 = _slicedToArray(_getExtensionKeyAndNo3, 2),
    extKey = _getExtensionKeyAndNo4[0],
    nodeKey = _getExtensionKeyAndNo4[1];
  var configParams = processParametersBefore ? processParametersBefore(parameters || {}) : parameters;
  return function () {
    return /*#__PURE__*/React.createElement(Box, {
      padding: "space.200"
    }, /*#__PURE__*/React.createElement(SaveIndicator, {
      duration: 5000,
      visible: true
    }, function (_ref5) {
      var onSaveStarted = _ref5.onSaveStarted,
        onSaveEnded = _ref5.onSaveEnded;
      return /*#__PURE__*/React.createElement(ConfigPanelLoader, {
        api: api,
        showHeader: true,
        closeOnEsc: true,
        extensionType: extensionType,
        extensionKey: extKey,
        nodeKey: nodeKey,
        extensionParameters: parameters,
        parameters: configParams,
        extensionProvider: extensionProvider,
        autoSaveTrigger: autoSaveResolve,
        autoSaveReject: autoSaveReject,
        onChange: ( /*#__PURE__*/function () {
          var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(updatedParameters) {
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return onChangeAction(editorView, updatedParameters, parameters, nodeWithPos, onSaveStarted);
                case 2:
                  onSaveEnded();
                  if (autoSaveResolve) {
                    autoSaveResolve();
                  }
                case 4:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x2) {
            return _ref6.apply(this, arguments);
          };
        }()),
        onCancel: function onCancel() {
          return startClosingConfigPanel({
            api: api,
            editorView: editorView
          });
        },
        featureFlags: featureFlags
        // Remove below prop when cleaning platform_editor_ai_object_sidebar_injection FG
        // Becuase it will always be true
        ,
        usingObjectSidebarPanel: true
      });
    }));
  };
};