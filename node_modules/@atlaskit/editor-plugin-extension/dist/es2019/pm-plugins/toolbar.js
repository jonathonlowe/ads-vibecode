import React from 'react';
import { messages } from '@atlaskit/editor-common/extensions';
import commonMessages from '@atlaskit/editor-common/messages';
import { BODIED_EXT_MBE_MARGIN_TOP } from '@atlaskit/editor-common/styles';
import { getChildrenInfo, getNodeName, isReferencedSource } from '@atlaskit/editor-common/utils';
import { findParentNodeOfType, hasParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { akEditorSelectedNodeClassName } from '@atlaskit/editor-shared-styles';
import ContentWidthNarrowIcon from '@atlaskit/icon/core/content-width-narrow';
import ContentWidthWideIcon from '@atlaskit/icon/core/content-width-wide';
import CopyIcon from '@atlaskit/icon/core/copy';
import DeleteIcon from '@atlaskit/icon/core/delete';
import ExpandHorizontalIcon from '@atlaskit/icon/core/expand-horizontal';
import EditIcon from '@atlaskit/icon/core/migration/edit--editor-edit';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { editExtension } from '../editor-actions/actions';
import { removeDescendantNodes, removeExtension, updateExtensionLayout } from '../editor-commands/commands';
import { pluginKey as macroPluginKey } from './macro/plugin-key';
import { getPluginState } from './plugin-factory';
import { getSelectedExtension } from './utils';

// non-bodied extensions nested inside panels, blockquotes and lists do not support layouts
const isNestedNBM = (state, selectedExtNode) => {
  const {
    schema: {
      nodes: {
        extension,
        panel,
        blockquote,
        listItem
      }
    },
    selection
  } = state;
  if (!editorExperiment('platform_editor_nested_non_bodied_macros', 'test')) {
    return false;
  }
  if (!selectedExtNode) {
    return false;
  }
  return selectedExtNode.node.type === extension && hasParentNodeOfType([panel, blockquote, listItem].filter(Boolean))(selection);
};
const isLayoutSupported = (state, selectedExtNode) => {
  const {
    schema: {
      nodes: {
        bodiedExtension,
        extension,
        layoutSection,
        table,
        expand,
        multiBodiedExtension
      }
    },
    selection
  } = state;
  if (!selectedExtNode) {
    return false;
  }
  const isMultiBodiedExtension = selectedExtNode.node.type === multiBodiedExtension;
  const isNonEmbeddedBodiedExtension = selectedExtNode.node.type === bodiedExtension && !hasParentNodeOfType([multiBodiedExtension].filter(Boolean))(selection);
  const isNonEmbeddedExtension = selectedExtNode.node.type === extension && !hasParentNodeOfType([bodiedExtension, table, expand, multiBodiedExtension].filter(Boolean))(selection);

  // if selection belongs to layout supported extension category
  // and not inside a layoutSection
  return !!((isMultiBodiedExtension || isNonEmbeddedBodiedExtension || isNonEmbeddedExtension) && !hasParentNodeOfType([layoutSection])(selection));
};
const breakoutButtonListOptions = (state, formatMessage, extensionState, breakoutEnabled, editorAnalyticsAPI) => {
  const nodeWithPos = getSelectedExtension(state, true);

  // we should only return breakout options when breakouts are enabled and the node supports them
  if (nodeWithPos && breakoutEnabled && isLayoutSupported(state, nodeWithPos) && !isNestedNBM(state, nodeWithPos)) {
    const {
      layout
    } = nodeWithPos.node.attrs;
    return [{
      type: 'button',
      icon: () => /*#__PURE__*/React.createElement(ContentWidthNarrowIcon, {
        label: formatMessage(commonMessages.layoutFixedWidth),
        spacing: "spacious"
      }),
      iconFallback: ContentWidthNarrowIcon,
      onClick: updateExtensionLayout('default', editorAnalyticsAPI),
      selected: layout === 'default',
      title: formatMessage(commonMessages.layoutFixedWidth),
      tabIndex: null
    }, {
      type: 'button',
      icon: () => /*#__PURE__*/React.createElement(ContentWidthWideIcon, {
        label: formatMessage(commonMessages.layoutWide),
        spacing: "spacious"
      }),
      iconFallback: ContentWidthWideIcon,
      onClick: updateExtensionLayout('wide', editorAnalyticsAPI),
      selected: layout === 'wide',
      title: formatMessage(commonMessages.layoutWide),
      tabIndex: null
    }, {
      type: 'button',
      icon: () => /*#__PURE__*/React.createElement(ExpandHorizontalIcon, {
        label: formatMessage(commonMessages.layoutFullWidth),
        spacing: "spacious"
      }),
      iconFallback: ExpandHorizontalIcon,
      onClick: updateExtensionLayout('full-width', editorAnalyticsAPI),
      selected: layout === 'full-width',
      title: formatMessage(commonMessages.layoutFullWidth),
      tabIndex: null
    }];
  }
  return [];
};
const breakoutDropdownOptions = (state, formatMessage, breakoutEnabled, editorAnalyticsAPI) => {
  const nodeWithPos = getSelectedExtension(state, true);

  // we should only return breakout options when breakouts are enabled and the node supports them
  if (!nodeWithPos || !breakoutEnabled || !isLayoutSupported(state, nodeWithPos) || isNestedNBM(state, nodeWithPos)) {
    return [];
  }
  const {
    layout
  } = nodeWithPos.node.attrs;
  let title = '';
  let IconComponent;
  switch (layout) {
    case 'wide':
      title = formatMessage(commonMessages.layoutStateWide);
      IconComponent = ContentWidthWideIcon;
      break;
    case 'full-width':
      title = formatMessage(commonMessages.layoutStateFullWidth);
      IconComponent = ExpandHorizontalIcon;
      break;
    case 'default':
    default:
      title = formatMessage(commonMessages.layoutStateFixedWidth);
      IconComponent = ContentWidthNarrowIcon;
      break;
  }
  const options = [{
    id: 'editor.extensions.width.default',
    title: formatMessage(commonMessages.layoutFixedWidth),
    onClick: updateExtensionLayout('default', editorAnalyticsAPI),
    selected: layout === 'default',
    icon: /*#__PURE__*/React.createElement(ContentWidthNarrowIcon, {
      color: "currentColor",
      spacing: "spacious",
      label: formatMessage(commonMessages.layoutFixedWidth)
    })
  }, {
    id: 'editor.extensions.width.wide',
    title: formatMessage(commonMessages.layoutWide),
    onClick: updateExtensionLayout('wide', editorAnalyticsAPI),
    selected: layout === 'wide',
    icon: /*#__PURE__*/React.createElement(ContentWidthWideIcon, {
      color: "currentColor",
      spacing: "spacious",
      label: formatMessage(commonMessages.layoutWide)
    })
  }, {
    id: 'editor.extensions.width.full-width',
    title: formatMessage(commonMessages.layoutFullWidth),
    onClick: updateExtensionLayout('full-width', editorAnalyticsAPI),
    selected: layout === 'full-width',
    icon: /*#__PURE__*/React.createElement(ExpandHorizontalIcon, {
      color: "currentColor",
      spacing: "spacious",
      label: formatMessage(commonMessages.layoutFullWidth)
    })
  }];
  return [{
    id: 'extensions-width-options-toolbar-item',
    testId: 'extensions-width-options-toolbar-dropdown',
    type: 'dropdown',
    options: options,
    title,
    iconBefore: () => /*#__PURE__*/React.createElement(IconComponent, {
      color: "currentColor",
      spacing: "spacious",
      label: title
    })
  }];
};
const breakoutOptions = (state, formatMessage, extensionState, breakoutEnabled, editorAnalyticsAPI) => {
  return editorExperiment('platform_editor_controls', 'variant1') ? breakoutDropdownOptions(state, formatMessage, breakoutEnabled, editorAnalyticsAPI) : breakoutButtonListOptions(state, formatMessage, extensionState, breakoutEnabled, editorAnalyticsAPI);
};
const editButton = (formatMessage, extensionState, applyChangeToContextPanel, editorAnalyticsAPI, isDisabled = false) => {
  if (!extensionState.showEditButton) {
    return [];
  }
  const editButtonItems = [{
    id: 'editor.extension.edit',
    type: 'button',
    icon: EditIcon,
    iconFallback: EditIcon,
    testId: 'extension-toolbar-edit-button',
    // Taking the latest `updateExtension` from plugin state to avoid race condition @see ED-8501
    onClick: (state, dispatch, view) => {
      const macroState = macroPluginKey.getState(state);
      const {
        updateExtension
      } = getPluginState(state);
      editExtension(macroState && macroState.macroProvider, applyChangeToContextPanel, editorAnalyticsAPI, updateExtension)(state, dispatch, view);
      return true;
    },
    title: formatMessage(messages.edit),
    tabIndex: null,
    focusEditoronEnter: true,
    disabled: isDisabled
  }];
  if (editorExperiment('platform_editor_controls', 'variant1')) {
    editButtonItems.push({
      type: 'separator',
      fullHeight: true
    });
  }
  return editButtonItems;
};

/**
 * Calculates the position for the toolbar when dealing with nested extensions
 */
const calculateToolbarPosition = (editorView, nextPos, state, extensionNode) => {
  const {
    state: {
      schema,
      selection
    }
  } = editorView;
  const possibleMbeParent = findParentNodeOfType(schema.nodes.extensionFrame)(selection);
  // We only want to use calculated position in case of a bodiedExtension present inside an MBE node
  const isBodiedExtensionInsideMBE = possibleMbeParent && (extensionNode === null || extensionNode === void 0 ? void 0 : extensionNode.node.type.name) === 'bodiedExtension';
  let scrollWrapper = editorView.dom.closest('.fabric-editor-popup-scroll-parent') || document.body;
  if (fg('platform_editor_legacy_content_macro')) {
    if (!extensionNode) {
      return nextPos;
    }
    const isInsideEditableExtensionArea = !!editorView.dom.closest('.extension-editable-area');
    if (!isBodiedExtensionInsideMBE && !isInsideEditableExtensionArea) {
      return nextPos;
    }
    if (isInsideEditableExtensionArea && scrollWrapper.parentElement) {
      // The editable extension area may have its own scroll wrapper, so we want to keep searching up the tree for the page level scroll wrapper.

      scrollWrapper = scrollWrapper.parentElement.closest('.fabric-editor-popup-scroll-parent') || scrollWrapper;
    }
  } else {
    if (!isBodiedExtensionInsideMBE) {
      return nextPos;
    }
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const nestedBodiedExtensionDomElement = editorView.nodeDOM(extensionNode.pos);
  const nestedBodiedExtensionRect = nestedBodiedExtensionDomElement === null || nestedBodiedExtensionDomElement === void 0 ? void 0 : nestedBodiedExtensionDomElement.getBoundingClientRect();
  const wrapperBounds = scrollWrapper.getBoundingClientRect();
  const toolbarTopPos = nestedBodiedExtensionRect.bottom - wrapperBounds.top + scrollWrapper.scrollTop + BODIED_EXT_MBE_MARGIN_TOP;
  return {
    top: toolbarTopPos,
    left: nextPos.left
  };
};
export const getToolbarConfig = ({
  breakoutEnabled = true,
  hoverDecoration,
  applyChangeToContextPanel,
  editorAnalyticsAPI,
  extensionApi
}) => (state, intl) => {
  var _extensionApi$connect, _extensionApi$connect2, _extensionApi$connect3, _hoverDecoration5, _hoverDecoration6, _hoverDecoration7, _hoverDecoration8;
  const {
    formatMessage
  } = intl;
  const extensionState = getPluginState(state);
  if (fg('platform_editor_legacy_content_macro')) {
    var _extensionApi$decorat, _extensionApi$context, _extensionApi$analyti;
    // TODO: ED-26962 - Change these all to const upon removal of the above FG. Remove the function params also.
    hoverDecoration = extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$decorat = extensionApi.decorations) === null || _extensionApi$decorat === void 0 ? void 0 : _extensionApi$decorat.actions.hoverDecoration;
    applyChangeToContextPanel = extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$context = extensionApi.contextPanel) === null || _extensionApi$context === void 0 ? void 0 : _extensionApi$context.actions.applyChange;
    editorAnalyticsAPI = extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$analyti = extensionApi.analytics) === null || _extensionApi$analyti === void 0 ? void 0 : _extensionApi$analyti.actions;
  }
  if (!extensionState || extensionState.showContextPanel || !extensionState.element) {
    return;
  }
  const nodeType = [state.schema.nodes.extension, state.schema.nodes.inlineExtension, state.schema.nodes.bodiedExtension, state.schema.nodes.multiBodiedExtension];
  const editButtonItems = editButton(formatMessage, extensionState, applyChangeToContextPanel, editorAnalyticsAPI, editorExperiment('platform_editor_offline_editing_web', true) && (extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$connect = extensionApi.connectivity) === null || _extensionApi$connect === void 0 ? void 0 : (_extensionApi$connect2 = _extensionApi$connect.sharedState) === null || _extensionApi$connect2 === void 0 ? void 0 : (_extensionApi$connect3 = _extensionApi$connect2.currentState()) === null || _extensionApi$connect3 === void 0 ? void 0 : _extensionApi$connect3.mode) === 'offline');
  const breakoutItems = breakoutOptions(state, formatMessage, extensionState, breakoutEnabled, editorAnalyticsAPI);
  const extensionObj = getSelectedExtension(state, true);

  // Check if we need to show confirm dialog for delete button
  let confirmDialog;
  if (isReferencedSource(state, extensionObj === null || extensionObj === void 0 ? void 0 : extensionObj.node)) {
    confirmDialog = () => {
      const localSourceName = formatMessage(messages.unnamedSource);
      return {
        title: formatMessage(messages.deleteElementTitle),
        okButtonLabel: formatMessage(messages.confirmDeleteLinkedModalOKButton),
        message: formatMessage(messages.confirmDeleteLinkedModalMessage, {
          nodeName: getNodeName(state, extensionObj === null || extensionObj === void 0 ? void 0 : extensionObj.node) || localSourceName
        }),
        isReferentialityDialog: true,
        getChildrenInfo: () => getChildrenInfo(state, extensionObj === null || extensionObj === void 0 ? void 0 : extensionObj.node),
        checkboxLabel: formatMessage(messages.confirmModalCheckboxLabel),
        onConfirm: (isChecked = false) => clickWithCheckboxHandler(isChecked, extensionObj === null || extensionObj === void 0 ? void 0 : extensionObj.node)
      };
    };
  }
  const hoverDecorationProps = (nodeType, className) => {
    var _hoverDecoration, _hoverDecoration2, _hoverDecoration3, _hoverDecoration4;
    return {
      onMouseEnter: (_hoverDecoration = hoverDecoration) === null || _hoverDecoration === void 0 ? void 0 : _hoverDecoration(nodeType, true, className),
      onMouseLeave: (_hoverDecoration2 = hoverDecoration) === null || _hoverDecoration2 === void 0 ? void 0 : _hoverDecoration2(nodeType, false, className),
      onFocus: (_hoverDecoration3 = hoverDecoration) === null || _hoverDecoration3 === void 0 ? void 0 : _hoverDecoration3(nodeType, true, className),
      onBlur: (_hoverDecoration4 = hoverDecoration) === null || _hoverDecoration4 === void 0 ? void 0 : _hoverDecoration4(nodeType, false, className)
    };
  };
  return {
    title: 'Extension floating controls',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    getDomRef: () => extensionState.element.parentElement || undefined,
    nodeType,
    onPositionCalculated: (editorView, nextPos) => calculateToolbarPosition(editorView, nextPos, state, extensionObj),
    items: [...editButtonItems, ...breakoutItems, ...(editorExperiment('platform_editor_controls', 'control') || fg('platform_editor_controls_patch_2') ? [{
      type: 'separator',
      hidden: editButtonItems.length === 0 && breakoutItems.length === 0
    }, {
      type: 'extensions-placeholder',
      separator: 'end'
    }, {
      type: 'copy-button',
      items: [{
        state,
        formatMessage: intl.formatMessage,
        nodeType
      }]
    }, {
      type: 'separator'
    }, {
      id: 'editor.extension.delete',
      type: 'button',
      icon: () => /*#__PURE__*/React.createElement(DeleteIcon, {
        label: formatMessage(commonMessages.remove),
        spacing: "spacious"
      }),
      iconFallback: DeleteIcon,
      appearance: 'danger',
      onClick: removeExtension(editorAnalyticsAPI),
      onMouseEnter: (_hoverDecoration5 = hoverDecoration) === null || _hoverDecoration5 === void 0 ? void 0 : _hoverDecoration5(nodeType, true),
      onMouseLeave: (_hoverDecoration6 = hoverDecoration) === null || _hoverDecoration6 === void 0 ? void 0 : _hoverDecoration6(nodeType, false),
      onFocus: (_hoverDecoration7 = hoverDecoration) === null || _hoverDecoration7 === void 0 ? void 0 : _hoverDecoration7(nodeType, true),
      onBlur: (_hoverDecoration8 = hoverDecoration) === null || _hoverDecoration8 === void 0 ? void 0 : _hoverDecoration8(nodeType, false),
      focusEditoronEnter: true,
      title: formatMessage(commonMessages.remove),
      tabIndex: null,
      confirmDialog
    }] : [breakoutItems.length > 0 && {
      type: 'separator',
      fullHeight: true
    }, {
      type: 'extensions-placeholder',
      separator: breakoutItems.length > 0 ? 'both' : 'end'
    }, {
      type: 'overflow-dropdown',
      options: [{
        title: formatMessage(commonMessages.copyToClipboard),
        onClick: () => {
          var _extensionApi$core, _extensionApi$floatin;
          extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$core = extensionApi.core) === null || _extensionApi$core === void 0 ? void 0 : _extensionApi$core.actions.execute( // @ts-ignore
          extensionApi === null || extensionApi === void 0 ? void 0 : (_extensionApi$floatin = extensionApi.floatingToolbar) === null || _extensionApi$floatin === void 0 ? void 0 : _extensionApi$floatin.commands.copyNode(nodeType));
          return true;
        },
        icon: /*#__PURE__*/React.createElement(CopyIcon, {
          label: ""
        }),
        ...hoverDecorationProps(nodeType, akEditorSelectedNodeClassName)
      }, {
        title: formatMessage(commonMessages.delete),
        onClick: removeExtension(editorAnalyticsAPI),
        icon: /*#__PURE__*/React.createElement(DeleteIcon, {
          label: ""
        }),
        ...hoverDecorationProps(nodeType)
      }]
    }])],
    scrollable: true
  };
};
const clickWithCheckboxHandler = (isChecked, node) => (state, dispatch) => {
  if (!node) {
    return false;
  }
  if (!isChecked) {
    removeExtension()(state, dispatch);
  } else {
    removeDescendantNodes(node)(state, dispatch);
  }
  return true;
};