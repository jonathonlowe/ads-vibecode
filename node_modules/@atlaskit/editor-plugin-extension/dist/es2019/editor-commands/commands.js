import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, TARGET_SELECTION_SOURCE } from '@atlaskit/editor-common/analytics';
import { removeConnectedNodes } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeOfType, removeParentNodeOfType, removeSelectedNode } from '@atlaskit/editor-prosemirror/utils';
import { createCommand } from '../pm-plugins/plugin-factory';
import { getSelectedExtension } from '../pm-plugins/utils';

// AFP-2532 TODO: Fix automatic suppressions below
// eslint-disable-next-line @atlassian/tangerine/import/entry-points

export function updateState(state) {
  return createCommand({
    type: 'UPDATE_STATE',
    data: state
  });
}
export function setEditingContextToContextPanel(processParametersBefore, processParametersAfter, applyChangeToContextPanel) {
  return createCommand({
    type: 'UPDATE_STATE',
    data: {
      showContextPanel: true,
      processParametersBefore,
      processParametersAfter
    }
  }, applyChangeToContextPanel);
}
export const clearEditingContext = applyChangeToContextPanel => createCommand({
  type: 'UPDATE_STATE',
  data: {
    showContextPanel: false,
    processParametersBefore: undefined,
    processParametersAfter: undefined
  }
}, applyChangeToContextPanel);
export const forceAutoSave = applyChangeToContextPanel => (resolve, reject) => createCommand({
  type: 'UPDATE_STATE',
  data: {
    autoSaveResolve: resolve,
    autoSaveReject: reject
  }
}, applyChangeToContextPanel);
export const updateExtensionLayout = (layout, analyticsApi) => createCommand({
  type: 'UPDATE_STATE',
  data: {
    layout
  }
}, (tr, state) => {
  const selectedExtension = getSelectedExtension(state, true);
  if (selectedExtension) {
    const trWithNewNodeMarkup = tr.setNodeMarkup(selectedExtension.pos, undefined, {
      ...selectedExtension.node.attrs,
      layout
    });
    trWithNewNodeMarkup.setMeta('scrollIntoView', false);
    if (analyticsApi) {
      analyticsApi.attachAnalyticsEvent({
        action: ACTION.UPDATED,
        actionSubject: ACTION_SUBJECT.EXTENSION,
        actionSubjectId: ACTION_SUBJECT_ID.EXTENSION,
        eventType: EVENT_TYPE.TRACK,
        attributes: {
          extensionType: selectedExtension.node.attrs.extensionType,
          extensionKey: selectedExtension.node.attrs.extensionKey,
          localId: selectedExtension.node.attrs.localId,
          layout,
          selection: tr.selection.toJSON(),
          targetSelectionSource: TARGET_SELECTION_SOURCE.CURRENT_SELECTION
        }
      })(tr);
    }
    return trWithNewNodeMarkup;
  }
  return tr;
});
export const removeExtension = editorAnalyticsAPI => createCommand({
  type: 'UPDATE_STATE',
  data: {
    element: undefined
  }
}, (tr, state) => {
  if (getSelectedExtension(state)) {
    return removeSelectedNodeWithAnalytics(state, tr, editorAnalyticsAPI);
  } else {
    return checkAndRemoveExtensionNode(state, tr, editorAnalyticsAPI);
  }
});
export const removeDescendantNodes = sourceNode => createCommand({
  type: 'UPDATE_STATE',
  data: {
    element: undefined
  }
}, (tr, state) => {
  return sourceNode ? removeConnectedNodes(state, sourceNode) : tr;
});
export const removeSelectedNodeWithAnalytics = (state, tr, analyticsApi) => {
  if (state.selection instanceof NodeSelection) {
    const node = state.selection.node;
    if (analyticsApi) {
      analyticsApi.attachAnalyticsEvent({
        action: ACTION.DELETED,
        actionSubject: ACTION_SUBJECT.EXTENSION,
        actionSubjectId: ACTION_SUBJECT_ID.EXTENSION,
        eventType: EVENT_TYPE.TRACK,
        attributes: {
          extensionType: node.attrs.extensionType,
          extensionKey: node.attrs.extensionKey,
          localId: node.attrs.localId
        }
      })(tr);
    }
  }
  return removeSelectedNode(tr);
};
export const checkAndRemoveExtensionNode = (state, tr, analyticsApi) => {
  let nodeType = state.schema.nodes.bodiedExtension;
  const maybeMBENode = findParentNodeOfType(state.schema.nodes.multiBodiedExtension)(state.selection);
  if (maybeMBENode) {
    nodeType = state.schema.nodes.multiBodiedExtension;
    if (analyticsApi) {
      analyticsApi.attachAnalyticsEvent({
        action: ACTION.DELETED,
        actionSubject: ACTION_SUBJECT.MULTI_BODIED_EXTENSION,
        eventType: EVENT_TYPE.TRACK,
        attributes: {
          extensionType: maybeMBENode.node.attrs.extensionType,
          extensionKey: maybeMBENode.node.attrs.extensionKey,
          localId: maybeMBENode.node.attrs.localId,
          currentFramesCount: maybeMBENode.node.content.childCount
        }
      })(tr);
    }
  }
  const bodiedExtensionNode = findParentNodeOfType(state.schema.nodes.bodiedExtension)(state.selection);
  if (bodiedExtensionNode) {
    if (analyticsApi) {
      analyticsApi.attachAnalyticsEvent({
        action: ACTION.DELETED,
        actionSubject: ACTION_SUBJECT.EXTENSION,
        actionSubjectId: ACTION_SUBJECT_ID.EXTENSION_BODIED,
        eventType: EVENT_TYPE.TRACK,
        attributes: {
          extensionType: bodiedExtensionNode.node.attrs.extensionType,
          extensionKey: bodiedExtensionNode.node.attrs.extensionKey,
          localId: bodiedExtensionNode.node.attrs.localId
        }
      })(tr);
    }
  }
  return removeParentNodeOfType(nodeType)(tr);
};