import { createPlugin, initialPluginState, metricsKey } from './pm-plugins/main';
import { getAnalyticsPayload } from './pm-plugins/utils/analytics';
/**
 * Metrics plugin to be added to an `EditorPresetBuilder` and used with `ComposableEditor`
 * from `@atlaskit/editor-core`.
 */

export const metricsPlugin = ({
  api
}) => ({
  name: 'metrics',
  pmPlugins() {
    return [{
      name: 'metrics',
      plugin: () => createPlugin(api)
    }];
  },
  commands: {
    setContentMoved: () => ({
      tr
    }) => {
      return tr.setMeta(metricsKey, {
        contentMoved: true
      });
    },
    startActiveSessionTimer: () => ({
      tr
    }) => {
      const pluginState = api === null || api === void 0 ? void 0 : api.metrics.sharedState.currentState();
      if (!(pluginState !== null && pluginState !== void 0 && pluginState.intentToStartEditTime)) {
        return tr;
      }
      return tr.setMeta(metricsKey, {
        shouldStartTimer: true,
        shouldPersistActiveSession: false
      });
    },
    stopActiveSession: () => ({
      tr
    }) => {
      if (!api) {
        return tr;
      }
      const pluginState = api === null || api === void 0 ? void 0 : api.metrics.sharedState.currentState();
      if (pluginState !== null && pluginState !== void 0 && pluginState.shouldPersistActiveSession) {
        return tr;
      }
      if (pluginState && pluginState.totalActionCount > 0 && pluginState.activeSessionTime > 0) {
        var _api$analytics;
        const payloadToSend = getAnalyticsPayload({
          currentContent: tr.doc.content,
          pluginState
        });
        api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions.attachAnalyticsEvent(payloadToSend)(tr);
      }
      tr.setMeta(metricsKey, {
        stopActiveSession: true
      });
      tr.setMeta('scrollIntoView', false);
      return tr;
    },
    handleIntentToStartEdit: ({
      newSelection,
      shouldStartTimer = true,
      shouldPersistActiveSession
    }) => ({
      tr
    }) => {
      if (!api) {
        return tr;
      }
      const pluginState = api === null || api === void 0 ? void 0 : api.metrics.sharedState.currentState();
      if (shouldPersistActiveSession && pluginState !== null && pluginState !== void 0 && pluginState.intentToStartEditTime) {
        return tr.setMeta(metricsKey, {
          shouldPersistActiveSession
        });
      }
      if (!pluginState || pluginState.intentToStartEditTime) {
        return tr;
      }
      tr.setMeta(metricsKey, {
        intentToStartEditTime: performance.now(),
        shouldStartTimer,
        newSelection,
        shouldPersistActiveSession
      });
      return tr;
    }
  },
  getSharedState(editorState) {
    if (!editorState) {
      return initialPluginState;
    }
    return metricsKey.getState(editorState);
  }
});