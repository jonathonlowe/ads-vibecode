import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { bind } from 'bind-event-listener';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { PluginKey } from '@atlaskit/editor-prosemirror/state';
import { ActiveSessionTimer } from './utils/active-session-timer';
import { getAnalyticsPayload } from './utils/analytics';
import { getNewPluginState } from './utils/get-new-plugin-state';
import { isTrWithDocChanges } from './utils/is-tr-with-doc-changes';
import { shouldSkipTr } from './utils/should-skip-tr';
export var metricsKey = new PluginKey('metricsPlugin');
export var initialPluginState = {
  intentToStartEditTime: undefined,
  lastSelection: undefined,
  activeSessionTime: 0,
  totalActionCount: 0,
  contentSizeChanged: 0,
  shouldPersistActiveSession: undefined,
  timeOfLastTextInput: undefined,
  initialContent: undefined,
  actionTypeCount: {
    textInputCount: 0,
    nodeInsertionCount: 0,
    nodeAttributeChangeCount: 0,
    contentMovedCount: 0,
    nodeDeletionCount: 0,
    undoCount: 0,
    markChangeCount: 0,
    contentDeletedCount: 0
  },
  repeatedActionCount: 0,
  safeInsertCount: 0
};
export var createPlugin = function createPlugin(api) {
  var timer = new ActiveSessionTimer(api);
  return new SafePlugin({
    key: metricsKey,
    state: {
      init: function init(_, state) {
        return _objectSpread(_objectSpread({}, initialPluginState), {}, {
          initialContent: state.doc.content
        });
      },
      // eslint-disable-next-line @typescript-eslint/max-params
      apply: function apply(tr, pluginState, oldState, newState) {
        var _meta$shouldPersistAc;
        // Return if transaction is remote or replaceDocument is set
        if (tr.getMeta('isRemote') || tr.getMeta('replaceDocument')) {
          return pluginState;
        }
        var meta = tr.getMeta(metricsKey);

        // If the active session is stopped, reset the plugin state, and set initialContent to new doc content
        if (meta && meta.stopActiveSession) {
          return _objectSpread(_objectSpread({}, initialPluginState), {}, {
            initialContent: newState.doc.content
          });
        }
        var shouldPersistActiveSession = (_meta$shouldPersistAc = meta === null || meta === void 0 ? void 0 : meta.shouldPersistActiveSession) !== null && _meta$shouldPersistAc !== void 0 ? _meta$shouldPersistAc : pluginState.shouldPersistActiveSession;
        var hasDocChanges = isTrWithDocChanges(tr);
        var intentToStartEditTime = (meta === null || meta === void 0 ? void 0 : meta.intentToStartEditTime) || pluginState.intentToStartEditTime;
        var now = performance.now();
        // If there is no intentToStartEditTime and there are no doc changes, return the plugin state
        if (!intentToStartEditTime && !hasDocChanges && !tr.storedMarksSet) {
          return _objectSpread(_objectSpread({}, pluginState), {}, {
            shouldPersistActiveSession: shouldPersistActiveSession
          });
        }

        // Set intentToStartEditTime if it is not set and there are doc changes or marks are set
        if (!intentToStartEditTime && (hasDocChanges || tr.storedMarksSet)) {
          intentToStartEditTime = now;
        }

        // Start active session timer if intentToStartEditTime is defined, shouldStartTimer is true and shouldPersistActiveSession is false
        // shouldPersistActiveSession is true when dragging block controls and when insert menu is open as user is interacting with the editor without making doc changes
        // Timer should start when menu closes or dragging stops
        if (intentToStartEditTime && meta !== null && meta !== void 0 && meta.shouldStartTimer && !shouldPersistActiveSession) {
          timer.startTimer();
        }
        if (hasDocChanges) {
          timer.startTimer();
          if (shouldSkipTr(tr)) {
            return _objectSpread(_objectSpread({}, pluginState), {}, {
              shouldPersistActiveSession: shouldPersistActiveSession
            });
          }
          var newPluginState = getNewPluginState({
            now: now,
            intentToStartEditTime: intentToStartEditTime,
            shouldPersistActiveSession: shouldPersistActiveSession,
            tr: tr,
            pluginState: pluginState,
            oldState: oldState,
            newState: newState
          });
          return newPluginState;
        }
        return _objectSpread(_objectSpread({}, pluginState), {}, {
          lastSelection: (meta === null || meta === void 0 ? void 0 : meta.newSelection) || pluginState.lastSelection,
          intentToStartEditTime: intentToStartEditTime,
          shouldPersistActiveSession: shouldPersistActiveSession
        });
      }
    },
    view: function view(_view) {
      var fireAnalyticsEvent = function fireAnalyticsEvent() {
        var pluginState = metricsKey.getState(_view.state);
        if (!pluginState) {
          return;
        }
        var payloadToSend = getAnalyticsPayload({
          currentContent: _view.state.doc.content,
          pluginState: pluginState
        });
        if (pluginState && pluginState.totalActionCount > 0 && pluginState.activeSessionTime > 0) {
          var _api$analytics;
          api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 || _api$analytics.actions.fireAnalyticsEvent(payloadToSend, undefined, {
            immediate: true
          });
        }
      };
      var unbindBeforeUnload = bind(window, {
        type: 'beforeunload',
        listener: function listener() {
          fireAnalyticsEvent();
        }
      });
      return {
        destroy: function destroy() {
          fireAnalyticsEvent();
          timer.cleanupTimer();
          unbindBeforeUnload();
        }
      };
    },
    props: {
      handleDOMEvents: {
        click: function click(view) {
          var _pluginState$lastSele, _pluginState$lastSele2;
          var newSelection = view.state.tr.selection;
          var pluginState = api === null || api === void 0 ? void 0 : api.metrics.sharedState.currentState();
          if ((pluginState === null || pluginState === void 0 || (_pluginState$lastSele = pluginState.lastSelection) === null || _pluginState$lastSele === void 0 ? void 0 : _pluginState$lastSele.from) !== newSelection.from && (pluginState === null || pluginState === void 0 || (_pluginState$lastSele2 = pluginState.lastSelection) === null || _pluginState$lastSele2 === void 0 ? void 0 : _pluginState$lastSele2.to) !== newSelection.to) {
            api === null || api === void 0 || api.core.actions.execute(api === null || api === void 0 ? void 0 : api.metrics.commands.handleIntentToStartEdit({
              newSelection: newSelection
            }));
          }
          return false;
        }
      }
    }
  });
};