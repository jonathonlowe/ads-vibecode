import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { checkTrActionType } from './check-tr-actions/check-tr-action-type';
import { ActionType } from './check-tr-actions/types';
import { isNonTextUndo } from './is-non-text-undo';
import { isSafeInsert } from './is-safe-insert';
var textInputActions = [ActionType.TEXT_INPUT, ActionType.EMPTY_LINE_ADDED_OR_DELETED];
var listActions = [ActionType.UPDATING_NEW_LIST_TYPE_ITEM, ActionType.INSERTING_NEW_LIST_TYPE_NODE];
var continuousActions = [].concat(textInputActions, listActions, [ActionType.UPDATING_STATUS]);
var checkIsDesiredAction = function checkIsDesiredAction(trType, desiredActions) {
  return trType && desiredActions.includes(trType.type);
};
var getNewActionTypeCount = function getNewActionTypeCount(shouldIncrement, currentCount) {
  return shouldIncrement ? currentCount + 1 : currentCount;
};
export var getNewPluginState = function getNewPluginState(_ref) {
  var _trType$extraData, _previousTrType$extra;
  var now = _ref.now,
    intentToStartEditTime = _ref.intentToStartEditTime,
    shouldPersistActiveSession = _ref.shouldPersistActiveSession,
    tr = _ref.tr,
    pluginState = _ref.pluginState,
    oldState = _ref.oldState,
    newState = _ref.newState;
  var actionTypeCount = pluginState.actionTypeCount,
    timeOfLastTextInput = pluginState.timeOfLastTextInput,
    totalActionCount = pluginState.totalActionCount,
    previousTrType = pluginState.previousTrType,
    safeInsertCount = pluginState.safeInsertCount,
    contentSizeChanged = pluginState.contentSizeChanged;
  var newPluginState = _objectSpread(_objectSpread({}, pluginState), {}, {
    activeSessionTime: now - intentToStartEditTime,
    contentSizeChanged: contentSizeChanged + Math.abs(newState.doc.content.size - oldState.doc.content.size),
    intentToStartEditTime: intentToStartEditTime,
    shouldPersistActiveSession: shouldPersistActiveSession
  });
  var trType = checkTrActionType(tr);
  var newSafeInsertCount = getNewActionTypeCount(isSafeInsert(tr, oldState.tr.selection.from, trType === null || trType === void 0 ? void 0 : trType.type), safeInsertCount);
  var newUndoCount = getNewActionTypeCount(isNonTextUndo(tr), actionTypeCount.undoCount);
  if (!trType) {
    return _objectSpread(_objectSpread({}, newPluginState), {}, {
      totalActionCount: totalActionCount + 1,
      timeOfLastTextInput: undefined,
      actionTypeCount: _objectSpread(_objectSpread({}, actionTypeCount), {}, {
        undoCount: newUndoCount
      }),
      previousTrType: trType,
      safeInsertCount: newSafeInsertCount
    });
  }

  // Below are conditions for special cases which should not increase action count if the previous action was the same or was textInput
  // Check if tr is updating the same status node
  var isNotNewStatus = trType.type === ActionType.UPDATING_STATUS && (previousTrType === null || previousTrType === void 0 ? void 0 : previousTrType.type) === ActionType.UPDATING_STATUS && (trType === null || trType === void 0 || (_trType$extraData = trType.extraData) === null || _trType$extraData === void 0 ? void 0 : _trType$extraData.statusId) === (previousTrType === null || previousTrType === void 0 || (_previousTrType$extra = previousTrType.extraData) === null || _previousTrType$extra === void 0 ? void 0 : _previousTrType$extra.statusId);

  // Check if tr is adding text after adding a list node
  var isAddingTextToListNode = trType.type === ActionType.TEXT_INPUT && checkIsDesiredAction(previousTrType, listActions);

  // Check if tr is adding new list item after text input
  var isAddingNewListItemAfterTextInput = (previousTrType === null || previousTrType === void 0 ? void 0 : previousTrType.type) === ActionType.TEXT_INPUT && trType.type === ActionType.UPDATING_NEW_LIST_TYPE_ITEM;

  // Check if tr is textInput
  var isTextInput = textInputActions.includes(trType.type);

  // Don't increment action count if tr is text input, not a new status, adding text to list node or adding new list item if timeOfLastTextInput is set
  var shouldNotIncrementActionCount = timeOfLastTextInput && (isTextInput || isNotNewStatus || isAddingTextToListNode || isAddingNewListItemAfterTextInput);
  var newTotalActionCount = getNewActionTypeCount(!shouldNotIncrementActionCount, totalActionCount);

  // Increment textInputCount if tr is text input and previous action was not text input or list action
  var newTextInputCount = getNewActionTypeCount(isTextInput && !(timeOfLastTextInput && checkIsDesiredAction(previousTrType, [].concat(textInputActions, listActions))), actionTypeCount.textInputCount);
  var newNodeAttrCount = getNewActionTypeCount((trType === null || trType === void 0 ? void 0 : trType.type) === ActionType.CHANGING_ATTRS, actionTypeCount.nodeAttributeChangeCount);
  var isRepeatedAttrAction = (trType === null || trType === void 0 ? void 0 : trType.type) === ActionType.CHANGING_ATTRS && (previousTrType === null || previousTrType === void 0 ? void 0 : previousTrType.type) === ActionType.CHANGING_ATTRS && trType.extraData.attr === previousTrType.extraData.attr && trType.extraData.from === previousTrType.extraData.from && trType.extraData.to === previousTrType.extraData.to;
  var newRepeatedActionCount = getNewActionTypeCount(isRepeatedAttrAction, pluginState.repeatedActionCount);
  var contentMoved = getNewActionTypeCount((trType === null || trType === void 0 ? void 0 : trType.type) === ActionType.MOVING_CONTENT, actionTypeCount.contentMovedCount);
  var newMarkChangeCount = getNewActionTypeCount((trType === null || trType === void 0 ? void 0 : trType.type) === ActionType.CHANGING_MARK, actionTypeCount.markChangeCount);
  var newContentDeletedCount = getNewActionTypeCount((trType === null || trType === void 0 ? void 0 : trType.type) === ActionType.DELETING_CONTENT, actionTypeCount.contentDeletedCount);

  // timeOfLastTextInput should be set if tr includes continuous text input on the same node
  var shouldSetTimeOfLastTextInput = continuousActions.includes(trType.type) || isNotNewStatus;
  return _objectSpread(_objectSpread({}, newPluginState), {}, {
    totalActionCount: newTotalActionCount,
    timeOfLastTextInput: shouldSetTimeOfLastTextInput ? now : undefined,
    actionTypeCount: _objectSpread(_objectSpread({}, actionTypeCount), {}, {
      textInputCount: newTextInputCount,
      undoCount: newUndoCount,
      nodeAttributeChangeCount: newNodeAttrCount,
      contentMovedCount: contentMoved,
      markChangeCount: newMarkChangeCount,
      contentDeletedCount: newContentDeletedCount
    }),
    previousTrType: trType,
    repeatedActionCount: newRepeatedActionCount,
    safeInsertCount: newSafeInsertCount
  });
};