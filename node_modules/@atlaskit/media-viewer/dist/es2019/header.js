import React, { useEffect, useRef, useState } from 'react';
import { isExternalImageIdentifier, isErrorFileState, toCommonMediaClientError } from '@atlaskit/media-client';
import { hideControlsClassName, messages, toHumanReadableMediaSize, MediaButton } from '@atlaskit/media-ui';
import { getLanguageType, getExtension, isCodeViewerItem } from '@atlaskit/media-ui/codeViewer';
import { FormattedMessage, injectIntl } from 'react-intl-next';
import { Outcome } from './domain';
import { Header as HeaderWrapper, LeftHeader, RightHeader, MetadataWrapper, MetadataSubText, MedatadataTextWrapper, MetadataIconWrapper, MetadataFileName, FormattedMessageWrapper } from './styleWrappers';
import { ToolbarDownloadButton, DisabledToolbarDownloadButton } from './download';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { MimeTypeIcon } from '@atlaskit/media-ui/mime-type-icon';
import { getFormat } from './viewers/codeViewer/util';
import { MediaViewerError } from './errors';
export const Header = ({
  isArchiveSideBarVisible = false,
  extensions,
  isSidebarVisible,
  onSidebarButtonClick,
  identifier,
  onSetArchiveSideBarVisible,
  traceContext
}) => {
  // States
  const [item, setItem] = useState(Outcome.pending());

  // Refs and Hooks
  const mediaClient = useMediaClient();
  const {
    id,
    collectionName,
    occurrenceKey
  } = identifier;
  const {
    fileState
  } = useFileState(id, {
    collectionName,
    occurrenceKey
  });
  const onSetArchiveSideBarVisibleRef = useRef(onSetArchiveSideBarVisible);
  onSetArchiveSideBarVisibleRef.current = onSetArchiveSideBarVisible;

  // previous values
  useEffect(() => {
    if (isExternalImageIdentifier(identifier)) {
      const {
        name = identifier.dataURI
      } = identifier;

      // Simulate a processing file state to render right metadata
      const fileState = {
        status: 'processing',
        id: name,
        mediaType: 'image',
        mimeType: 'image/',
        name,
        representations: {},
        size: 0
      };
      setItem(Outcome.successful(fileState));
      return;
    }
    if (!fileState) {
      return;
    }
    if (fileState.status !== 'error') {
      var _onSetArchiveSideBarV;
      (_onSetArchiveSideBarV = onSetArchiveSideBarVisibleRef.current) === null || _onSetArchiveSideBarV === void 0 ? void 0 : _onSetArchiveSideBarV.call(onSetArchiveSideBarVisibleRef, !isErrorFileState(fileState) && fileState.mediaType === 'archive');
      setItem(Outcome.successful(fileState));
    } else {
      setItem(Outcome.failed(new MediaViewerError('header-fetch-metadata', toCommonMediaClientError(fileState))));
    }
  }, [fileState, identifier]);
  const renderFileTypeText = item => {
    // render appropriate header if its a code/email item and the feature flag is enabled
    if (isCodeViewerItem(item.name, item.mimeType)) {
      // gather language and extension
      // i.e test.py would have a language of 'python' and an extension of 'py'
      const language = getLanguageType(item.name, item.mimeType);
      const ext = getExtension(item.name);

      // specific cases for if we want a certain word translated in other languages
      switch (ext) {
        case 'msg':
          return /*#__PURE__*/React.createElement(FormattedMessage, messages.email);
        case 'txt':
          return /*#__PURE__*/React.createElement(FormattedMessage, messages.text);
      }

      // no need for translations in other languages
      return /*#__PURE__*/React.createElement(React.Fragment, null, getFormat(language || 'unknown', ext));
    }
    const {
      mediaType
    } = item;
    const mediaTypeTranslationMap = {
      doc: messages.document,
      audio: messages.audio,
      video: messages.video,
      image: messages.image,
      archive: messages.archive,
      unknown: messages.unknown
    };
    const message = mediaTypeTranslationMap[mediaType || 'unknown'];

    // Defaulting to unknown again since backend has more mediaTypes than the current supported ones
    return /*#__PURE__*/React.createElement(FormattedMessage, message || messages.unknown);
  };
  return /*#__PURE__*/React.createElement(HeaderWrapper, {
    isArchiveSideBarVisible: isArchiveSideBarVisible
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: hideControlsClassName
  }, /*#__PURE__*/React.createElement(LeftHeader, null, item.match({
    successful: item => !isErrorFileState(item) && /*#__PURE__*/React.createElement(MetadataWrapper, null, /*#__PURE__*/React.createElement(MetadataIconWrapper, null, /*#__PURE__*/React.createElement(MimeTypeIcon, {
      testId: 'media-viewer-file-type-icon',
      mediaType: item.mediaType,
      mimeType: item.mimeType,
      name: item.name
    })), /*#__PURE__*/React.createElement(MedatadataTextWrapper, null, /*#__PURE__*/React.createElement(MetadataFileName, {
      "data-testid": "media-viewer-file-name"
    }, item.name || /*#__PURE__*/React.createElement(FormattedMessage, messages.unknown)), /*#__PURE__*/React.createElement(MetadataSubText, {
      "data-testid": "media-viewer-file-metadata-text"
    }, /*#__PURE__*/React.createElement(FormattedMessageWrapper, null, renderFileTypeText(item)), item.size ? ' Â· ' + toHumanReadableMediaSize(item.size) : ''))),
    pending: () => null,
    failed: () => null
  })), /*#__PURE__*/React.createElement(RightHeader, null, (extensions === null || extensions === void 0 ? void 0 : extensions.sidebar) && /*#__PURE__*/React.createElement(MediaButton, {
    isSelected: isSidebarVisible,
    testId: "media-viewer-sidebar-button",
    onClick: onSidebarButtonClick,
    iconBefore: extensions.sidebar.icon
  }), item.match({
    pending: () => DisabledToolbarDownloadButton,
    failed: () => DisabledToolbarDownloadButton,
    successful: item => /*#__PURE__*/React.createElement(ToolbarDownloadButton, {
      state: item,
      identifier: identifier,
      mediaClient: mediaClient,
      traceContext: traceContext
    })
  })));
};
export default injectIntl(Header);