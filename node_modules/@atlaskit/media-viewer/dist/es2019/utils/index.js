import { isFileIdentifier } from '@atlaskit/media-client';
import { getMediaTypeFromMimeType } from '@atlaskit/media-common';
import { getType } from 'mime';
export const isSameIdentifier = (id1, id2) => {
  if (isFileIdentifier(id1) && isFileIdentifier(id2)) {
    return id1.id === id2.id;
  }
  if (!isFileIdentifier(id1) && !isFileIdentifier(id2)) {
    return id1.dataURI === id2.dataURI;
  }
  return false;
};

// TODO MS-1752 - current implementation makes viewer navigation to misbehave
// if passed a file with the same id (with different occurrenceKeys) or with the same dataURI twice
export const getSelectedIndex = (items, selectedItem) => {
  return items.findIndex(item => isSameIdentifier(item, selectedItem));
};
export const getMediaTypeFromFilename = filename => {
  const mimeType = getMimeTypeFromFilename(filename);
  return getMediaTypeFromMimeType(mimeType);
};
export const getMimeTypeFromFilename = filename => {
  const extension = filename.split('.').pop();
  if (!extension) {
    return '';
  }
  const mimeType = getType(extension);
  if (!mimeType) {
    return '';
  }
  return mimeType;
};
export const getFolderParent = path => {
  const pathParts = path.substring(0, path.length - 1).split('/');
  pathParts.pop();
  const parent = pathParts.at(-1);
  if (!parent) {
    return ''; // root
  }
  return pathParts.join('/') + '/';
};
export const extractArchiveFolderName = folderName => {
  const index = folderName.lastIndexOf('.');
  return index > -1 ? folderName.substring(0, index) + '/' : folderName + '/';
};
export const getFormattedFolderName = folderName => {
  // We assume name ends with '/' unless it is the root directory
  if (folderName === '') {
    return '';
  }
  const name = folderName.substring(0, folderName.length - 1);
  const index = name.lastIndexOf('/');
  if (index === -1) {
    return name;
  }
  return name.substring(index + 1);
};
export const isMacPrivateFile = fileName => {
  return fileName.startsWith('__MACOSX') || fileName.includes('.DS_Store');
};
export const rejectAfter = (fn, delay = 5000) => {
  return new Promise(async (resolve, reject) => {
    const timeoutId = setTimeout(() => reject(new Error('timed out')), delay);
    try {
      resolve(await fn());
    } catch (error) {
      reject(error);
    } finally {
      clearTimeout(timeoutId);
    }
  });
};