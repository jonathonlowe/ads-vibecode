import { MediaViewerError } from '../../errors';
import { useCallback, useEffect, useState } from 'react';
import React from 'react';
import { Spinner } from '../../loading';
export const CustomViewer = ({
  mediaClient,
  item,
  customRendererConfig,
  collectionName,
  onSuccess,
  onError
}) => {
  const [getBinaryContent, setGetBinaryContent] = useState();
  useEffect(() => {
    setGetBinaryContent(undefined);
    const abortController = new AbortController();
    // This sets the 'getBinaryContent' to an async function that fetches the binary content of the file
    // The 'getBinaryContent' function has to be updated when the item changes
    // This approach handles aborting in-progress request outside of the custom-renderer concern
    if (item.status === 'processed' || item.status === 'failed-processing') {
      setGetBinaryContent(() => () => mediaClient.mediaStore.getFileBinary(item.id, collectionName, abortController));
    }
    return () => abortController.abort();
  }, [collectionName, item, mediaClient]);
  const onLoadFailed = useCallback(error => {
    const mediaError = new MediaViewerError('custom-viewer-error', error);
    onError(mediaError, item);
  }, [item, onError]);
  if (!getBinaryContent) {
    return /*#__PURE__*/React.createElement(Spinner, null);
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, customRendererConfig.renderContent({
    fileItem: item,
    getBinaryContent,
    onLoad: onSuccess,
    onError: onLoadFailed
  }));
};