import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { globalMediaEventEmitter } from '@atlaskit/media-client';
import AudioIcon from '@atlaskit/icon/core/migration/audio--media-services-audio';
import { Outcome } from '../domain';
import { MediaViewerError } from '../errors';
import { AudioPlayer, AudioCover, Audio, DefaultCoverWrapper, CustomAudioPlayerWrapper } from '../styleWrappers';
import { BaseViewer } from './base-viewer';
import { isIE } from '../utils/isIE';
import { CustomMediaPlayer } from '@atlaskit/media-ui';
import { getObjectUrlFromFileState } from '../utils/getObjectUrlFromFileState';
const defaultCover = /*#__PURE__*/React.createElement(DefaultCoverWrapper, null, /*#__PURE__*/React.createElement(AudioIcon, {
  label: "cover",
  LEGACY_size: "xlarge",
  color: "currentColor"
  // eslint-disable-next-line @atlaskit/design-system/ensure-design-token-usage
  ,
  LEGACY_primaryColor: "#22272B"
  // eslint-disable-next-line @atlaskit/design-system/ensure-design-token-usage
  ,
  LEGACY_secondaryColor: "#9FADBC"
}));
const getCoverUrl = (item, mediaClient, collectionName) => mediaClient.getImageUrl(item.id, {
  collection: collectionName
});
export class AudioViewer extends BaseViewer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "renderCover", () => {
      const {
        item
      } = this.props;
      const {
        coverUrl
      } = this.state;
      if (coverUrl && item.status !== 'error') {
        return /*#__PURE__*/React.createElement(AudioCover, {
          src: coverUrl,
          alt: item.name
        });
      } else {
        return defaultCover;
      }
    });
    _defineProperty(this, "saveAudioElement", audioElement => {
      if (!audioElement) {
        return;
      }
      audioElement.setAttribute('controlsList', 'nodownload');
    });
    _defineProperty(this, "onFirstPlay", () => {
      const {
        item
      } = this.props;
      globalMediaEventEmitter.emit('media-viewed', {
        fileId: item.id,
        viewingLevel: 'full'
      });
    });
    _defineProperty(this, "onError", () => {
      const {
        onError
      } = this.props;
      onError && onError(new MediaViewerError('audioviewer-playback'));
    });
    _defineProperty(this, "loadCover", coverUrl => {
      return new Promise(async (resolve, reject) => {
        const img = new Image();
        img.src = coverUrl;
        img.onload = resolve;
        img.onerror = reject;
      });
    });
    _defineProperty(this, "setCoverUrl", async () => {
      const {
        mediaClient,
        item,
        collectionName
      } = this.props;
      if (item.status !== 'processed') {
        return;
      }
      const coverUrl = await getCoverUrl(item, mediaClient, collectionName);
      try {
        await this.loadCover(coverUrl);
        this.safeSetState({
          coverUrl
        });
      } catch (e) {}
    });
  }
  get initialState() {
    return {
      content: Outcome.pending()
    };
  }
  renderSuccessful(src) {
    const {
      item,
      showControls,
      previewCount,
      onCanPlay
    } = this.props;
    const useCustomAudioPlayer = !isIE();
    const isAutoPlay = previewCount === 0;
    return useCustomAudioPlayer ? /*#__PURE__*/React.createElement(AudioPlayer, {
      "data-testid": "media-viewer-audio-content"
    }, this.renderCover(), /*#__PURE__*/React.createElement(CustomAudioPlayerWrapper, null, /*#__PURE__*/React.createElement(CustomMediaPlayer, {
      type: "audio",
      isAutoPlay: isAutoPlay,
      src: src,
      fileId: item.id,
      isShortcutEnabled: true,
      showControls: showControls,
      onCanPlay: onCanPlay,
      onFirstPlay: this.onFirstPlay,
      onError: this.onError
    }))) : /*#__PURE__*/React.createElement(AudioPlayer, null, this.renderCover(), /*#__PURE__*/React.createElement(CustomAudioPlayerWrapper, null, /*#__PURE__*/React.createElement(Audio, {
      autoPlay: isAutoPlay,
      controls: true,
      ref: this.saveAudioElement,
      src: src,
      preload: "metadata"
    })));
  }
  async init() {
    const {
      mediaClient,
      item,
      collectionName
    } = this.props;
    try {
      let audioUrl;
      if (item.status === 'processed') {
        audioUrl = await mediaClient.file.getArtifactURL(item.artifacts, 'audio.mp3', collectionName);
        if (!audioUrl) {
          throw new MediaViewerError('audioviewer-missing-artefact');
        }
      } else {
        audioUrl = await getObjectUrlFromFileState(item);
        if (!audioUrl) {
          this.safeSetState({
            content: Outcome.pending()
          });
          return;
        }
      }
      this.setCoverUrl();
      this.safeSetState({
        content: Outcome.successful(audioUrl)
      });
    } catch (error) {
      this.safeSetState({
        content: Outcome.failed(new MediaViewerError('audioviewer-fetch-url', error instanceof Error ? error : undefined))
      });
    }
  }
  release() {
    const {
      content
    } = this.state;
    if (!content.data) {
      return;
    }
    URL.revokeObjectURL(content.data);
  }
}