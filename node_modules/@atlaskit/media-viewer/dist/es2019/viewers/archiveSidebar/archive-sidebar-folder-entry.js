import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { ButtonItem } from '@atlaskit/side-navigation';
import Folder24Icon from '@atlaskit/icon-file-type/glyph/folder/24';
import { downloadUrl } from '@atlaskit/media-common';
import { MediaTypeIcon } from '@atlaskit/media-ui/media-type-icon';
import { ArchiveSidebarFolderWrapper, ArchiveSidebarFileEntryWrapper, SidebarItemWrapper } from './styleWrappers';
import { getMediaTypeFromFilename, isMacPrivateFile, rejectAfter } from '../../utils';
import { itemStyle } from './styles';
import { messages } from '@atlaskit/media-ui';
import { ArchiveDownloadButton } from './archive-download-button';
import { injectIntl } from 'react-intl-next';
class ArchiveSidebarFolderEntryBase extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", {
      isAbuseModalOpen: false
    });
    _defineProperty(this, "renderEntry", entry => {
      const {
        root,
        onEntrySelected,
        mediaClient
      } = this.props;
      const onClick = () => onEntrySelected(entry);
      return /*#__PURE__*/React.createElement(ArchiveSidebarFileEntryWrapper, {
        key: entry.name,
        index: entry.name
      }, /*#__PURE__*/React.createElement(SidebarItemWrapper, null, /*#__PURE__*/React.createElement(ButtonItem, {
        iconBefore: this.renderEntryIcon(entry),
        onClick: onClick
        // eslint-disable-next-line @atlaskit/design-system/no-deprecated-apis
        ,
        cssFn: () => itemStyle
      }, this.formatName(root, entry.name))), entry.isDirectory ? null : this.renderDownloadButton(entry, root, mediaClient.config.enforceDataSecurityPolicy));
    });
    _defineProperty(this, "renderEntryIcon", entry => {
      if (entry.isDirectory) {
        return /*#__PURE__*/React.createElement(Folder24Icon, {
          label: "Folder"
        });
      }
      const mediaType = getMediaTypeFromFilename(entry.name);
      return /*#__PURE__*/React.createElement(MediaTypeIcon, {
        type: mediaType
      });
    });
    _defineProperty(this, "renderDownloadButton", (entry, root, enforceDataSecurityPolicy) => {
      const {
        shouldRenderAbuseModal,
        intl
      } = this.props;
      const tooltip = intl.formatMessage(messages.download_disabled_security_policy);
      const downloadFn = () => this.downloadZipEntry(entry, root);
      return /*#__PURE__*/React.createElement(ArchiveDownloadButton, {
        downloadFn: downloadFn,
        shouldRenderAbuseModal: shouldRenderAbuseModal,
        isDisabled: enforceDataSecurityPolicy,
        tooltip: tooltip
      });
    });
    _defineProperty(this, "downloadZipEntry", async (entry, root) => {
      try {
        const blob = await rejectAfter(() => entry.blob());
        const name = this.formatName(root, entry.name);
        downloadUrl(URL.createObjectURL(blob), {
          name
        });
      } catch (error) {
        this.props.onError(error, entry);
      }
    });
  }
  formatName(root, name) {
    return name.replace(root, '');
  }
  renderSidebarContent(root, entries) {
    const navItems = new Map();
    for (const value of Object.values(entries)) {
      const {
        name
      } = value;
      if (!name.startsWith(root) || isMacPrivateFile(name)) {
        continue;
      }
      const paths = name.replace(root, '').split('/').filter(Boolean);
      if (paths.length > 1) {
        if (!navItems.has(paths[0])) {
          navItems.set(paths[0], {
            name: `${root}${paths[0]}/`,
            isDirectory: true
          });
        }
      } else if (paths.length === 1) {
        navItems.set(paths[0], value);
      }
    }
    return Array.from(navItems.values()).map(this.renderEntry);
  }
  render() {
    const {
      root,
      entries
    } = this.props;
    return /*#__PURE__*/React.createElement(ArchiveSidebarFolderWrapper, null, this.renderSidebarContent(root, entries));
  }
}
export const ArchiveSidebarFolderEntry = injectIntl(ArchiveSidebarFolderEntryBase);