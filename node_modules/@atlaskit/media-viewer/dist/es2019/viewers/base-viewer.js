import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Fragment } from 'react';
import { FormattedMessage } from 'react-intl-next';
import { messages } from '@atlaskit/media-ui';
import deepEqual from 'deep-equal';
import { globalMediaEventEmitter } from '@atlaskit/media-client';
import ErrorMessage from '../errorMessage';
import { Spinner } from '../loading';
import { ErrorViewDownloadButton } from '../download';
export class BaseViewer extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", this.getInitialState());
    _defineProperty(this, "mounted", false);
    _defineProperty(this, "onMediaDisplayed", () => {
      const {
        item
      } = this.props;
      globalMediaEventEmitter.emit('media-viewed', {
        fileId: item.id,
        viewingLevel: 'full'
      });
    });
  }
  componentDidMount() {
    this.mounted = true;
    this.init();
  }
  componentWillUnmount() {
    this.mounted = false;
    this.release();
  }
  safeSetState(newState) {
    if (this.mounted) {
      this.setState({
        ...this.state,
        ...newState
      });
    }
  }

  // NOTE: We've moved parts of the logic to reset a component into this method
  // to optimise the performance. Resetting the state before the `componentDidUpdate`
  // lifecycle event allows us avoid one additional render cycle.
  // However, this lifecycle method might eventually be deprecated, so be careful
  // when working with it.
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.needsReset(nextProps, this.props)) {
      this.release();
      this.setState(this.initialState);
    }
  }
  componentDidUpdate(prevProps) {
    if (this.needsReset(prevProps, this.props)) {
      this.init();
    }
  }
  render() {
    return this.state.content.match({
      pending: () => /*#__PURE__*/React.createElement(Spinner, null),
      successful: content => /*#__PURE__*/React.createElement(Fragment, null, this.renderSuccessful(content)),
      failed: error => {
        const {
          item
        } = this.props;
        return /*#__PURE__*/React.createElement(ErrorMessage, {
          fileId: item.id,
          fileState: item,
          error: error,
          supressAnalytics: true // item-viewer.tsx will send
        }, /*#__PURE__*/React.createElement("p", null, /*#__PURE__*/React.createElement(FormattedMessage, messages.try_downloading_file)), this.renderDownloadButton(error));
      }
    });
  }

  // Accessing abstract getters in a constructor is not allowed
  getInitialState() {
    return this.initialState;
  }
  renderDownloadButton(error) {
    const {
      item,
      mediaClient,
      collectionName,
      traceContext
    } = this.props;
    return /*#__PURE__*/React.createElement(ErrorViewDownloadButton, {
      fileState: item,
      mediaClient: mediaClient,
      error: error,
      collectionName: collectionName,
      traceContext: traceContext
    });
  }
  needsReset(propsA, propsB) {
    return !deepEqual(propsA.item, propsB.item) || propsA.collectionName !== propsB.collectionName;
  }
}