import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useEffect, useRef, useState } from 'react';
import { isExternalImageIdentifier, isErrorFileState, toCommonMediaClientError } from '@atlaskit/media-client';
import { hideControlsClassName, messages, toHumanReadableMediaSize, MediaButton } from '@atlaskit/media-ui';
import { getLanguageType, getExtension, isCodeViewerItem } from '@atlaskit/media-ui/codeViewer';
import { FormattedMessage, injectIntl } from 'react-intl-next';
import { Outcome } from './domain';
import { Header as HeaderWrapper, LeftHeader, RightHeader, MetadataWrapper, MetadataSubText, MedatadataTextWrapper, MetadataIconWrapper, MetadataFileName, FormattedMessageWrapper } from './styleWrappers';
import { ToolbarDownloadButton, DisabledToolbarDownloadButton } from './download';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { MimeTypeIcon } from '@atlaskit/media-ui/mime-type-icon';
import { getFormat } from './viewers/codeViewer/util';
import { MediaViewerError } from './errors';
export var Header = function Header(_ref) {
  var _ref$isArchiveSideBar = _ref.isArchiveSideBarVisible,
    isArchiveSideBarVisible = _ref$isArchiveSideBar === void 0 ? false : _ref$isArchiveSideBar,
    extensions = _ref.extensions,
    isSidebarVisible = _ref.isSidebarVisible,
    onSidebarButtonClick = _ref.onSidebarButtonClick,
    identifier = _ref.identifier,
    onSetArchiveSideBarVisible = _ref.onSetArchiveSideBarVisible,
    traceContext = _ref.traceContext;
  // States
  var _useState = useState(Outcome.pending()),
    _useState2 = _slicedToArray(_useState, 2),
    item = _useState2[0],
    setItem = _useState2[1];

  // Refs and Hooks
  var mediaClient = useMediaClient();
  var _ref2 = identifier,
    id = _ref2.id,
    collectionName = _ref2.collectionName,
    occurrenceKey = _ref2.occurrenceKey;
  var _useFileState = useFileState(id, {
      collectionName: collectionName,
      occurrenceKey: occurrenceKey
    }),
    fileState = _useFileState.fileState;
  var onSetArchiveSideBarVisibleRef = useRef(onSetArchiveSideBarVisible);
  onSetArchiveSideBarVisibleRef.current = onSetArchiveSideBarVisible;

  // previous values
  useEffect(function () {
    if (isExternalImageIdentifier(identifier)) {
      var _identifier$name = identifier.name,
        name = _identifier$name === void 0 ? identifier.dataURI : _identifier$name;

      // Simulate a processing file state to render right metadata
      var _fileState = {
        status: 'processing',
        id: name,
        mediaType: 'image',
        mimeType: 'image/',
        name: name,
        representations: {},
        size: 0
      };
      setItem(Outcome.successful(_fileState));
      return;
    }
    if (!fileState) {
      return;
    }
    if (fileState.status !== 'error') {
      var _onSetArchiveSideBarV;
      (_onSetArchiveSideBarV = onSetArchiveSideBarVisibleRef.current) === null || _onSetArchiveSideBarV === void 0 || _onSetArchiveSideBarV.call(onSetArchiveSideBarVisibleRef, !isErrorFileState(fileState) && fileState.mediaType === 'archive');
      setItem(Outcome.successful(fileState));
    } else {
      setItem(Outcome.failed(new MediaViewerError('header-fetch-metadata', toCommonMediaClientError(fileState))));
    }
  }, [fileState, identifier]);
  var renderFileTypeText = function renderFileTypeText(item) {
    // render appropriate header if its a code/email item and the feature flag is enabled
    if (isCodeViewerItem(item.name, item.mimeType)) {
      // gather language and extension
      // i.e test.py would have a language of 'python' and an extension of 'py'
      var language = getLanguageType(item.name, item.mimeType);
      var ext = getExtension(item.name);

      // specific cases for if we want a certain word translated in other languages
      switch (ext) {
        case 'msg':
          return /*#__PURE__*/React.createElement(FormattedMessage, messages.email);
        case 'txt':
          return /*#__PURE__*/React.createElement(FormattedMessage, messages.text);
      }

      // no need for translations in other languages
      return /*#__PURE__*/React.createElement(React.Fragment, null, getFormat(language || 'unknown', ext));
    }
    var mediaType = item.mediaType;
    var mediaTypeTranslationMap = {
      doc: messages.document,
      audio: messages.audio,
      video: messages.video,
      image: messages.image,
      archive: messages.archive,
      unknown: messages.unknown
    };
    var message = mediaTypeTranslationMap[mediaType || 'unknown'];

    // Defaulting to unknown again since backend has more mediaTypes than the current supported ones
    return /*#__PURE__*/React.createElement(FormattedMessage, message || messages.unknown);
  };
  return /*#__PURE__*/React.createElement(HeaderWrapper, {
    isArchiveSideBarVisible: isArchiveSideBarVisible
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: hideControlsClassName
  }, /*#__PURE__*/React.createElement(LeftHeader, null, item.match({
    successful: function successful(item) {
      return !isErrorFileState(item) && /*#__PURE__*/React.createElement(MetadataWrapper, null, /*#__PURE__*/React.createElement(MetadataIconWrapper, null, /*#__PURE__*/React.createElement(MimeTypeIcon, {
        testId: 'media-viewer-file-type-icon',
        mediaType: item.mediaType,
        mimeType: item.mimeType,
        name: item.name
      })), /*#__PURE__*/React.createElement(MedatadataTextWrapper, null, /*#__PURE__*/React.createElement(MetadataFileName, {
        "data-testid": "media-viewer-file-name"
      }, item.name || /*#__PURE__*/React.createElement(FormattedMessage, messages.unknown)), /*#__PURE__*/React.createElement(MetadataSubText, {
        "data-testid": "media-viewer-file-metadata-text"
      }, /*#__PURE__*/React.createElement(FormattedMessageWrapper, null, renderFileTypeText(item)), item.size ? ' Â· ' + toHumanReadableMediaSize(item.size) : '')));
    },
    pending: function pending() {
      return null;
    },
    failed: function failed() {
      return null;
    }
  })), /*#__PURE__*/React.createElement(RightHeader, null, (extensions === null || extensions === void 0 ? void 0 : extensions.sidebar) && /*#__PURE__*/React.createElement(MediaButton, {
    isSelected: isSidebarVisible,
    testId: "media-viewer-sidebar-button",
    onClick: onSidebarButtonClick,
    iconBefore: extensions.sidebar.icon
  }), item.match({
    pending: function pending() {
      return DisabledToolbarDownloadButton;
    },
    failed: function failed() {
      return DisabledToolbarDownloadButton;
    },
    successful: function successful(item) {
      return /*#__PURE__*/React.createElement(ToolbarDownloadButton, {
        state: item,
        identifier: identifier,
        mediaClient: mediaClient,
        traceContext: traceContext
      });
    }
  })));
};
export default injectIntl(Header);