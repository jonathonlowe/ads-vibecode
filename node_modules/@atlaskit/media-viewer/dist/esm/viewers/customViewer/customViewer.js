import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { MediaViewerError } from '../../errors';
import { useCallback, useEffect, useState } from 'react';
import React from 'react';
import { Spinner } from '../../loading';
export var CustomViewer = function CustomViewer(_ref) {
  var mediaClient = _ref.mediaClient,
    item = _ref.item,
    customRendererConfig = _ref.customRendererConfig,
    collectionName = _ref.collectionName,
    onSuccess = _ref.onSuccess,
    onError = _ref.onError;
  var _useState = useState(),
    _useState2 = _slicedToArray(_useState, 2),
    getBinaryContent = _useState2[0],
    setGetBinaryContent = _useState2[1];
  useEffect(function () {
    setGetBinaryContent(undefined);
    var abortController = new AbortController();
    // This sets the 'getBinaryContent' to an async function that fetches the binary content of the file
    // The 'getBinaryContent' function has to be updated when the item changes
    // This approach handles aborting in-progress request outside of the custom-renderer concern
    if (item.status === 'processed' || item.status === 'failed-processing') {
      setGetBinaryContent(function () {
        return function () {
          return mediaClient.mediaStore.getFileBinary(item.id, collectionName, abortController);
        };
      });
    }
    return function () {
      return abortController.abort();
    };
  }, [collectionName, item, mediaClient]);
  var onLoadFailed = useCallback(function (error) {
    var mediaError = new MediaViewerError('custom-viewer-error', error);
    onError(mediaError, item);
  }, [item, onError]);
  if (!getBinaryContent) {
    return /*#__PURE__*/React.createElement(Spinner, null);
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, customRendererConfig.renderContent({
    fileItem: item,
    getBinaryContent: getBinaryContent,
    onLoad: onSuccess,
    onError: onLoadFailed
  }));
};