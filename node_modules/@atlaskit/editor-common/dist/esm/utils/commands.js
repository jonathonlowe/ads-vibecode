import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { NodeSelection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '../analytics';
import { withAnalytics } from '../editor-analytics';
import { GapCursorSelection } from '../selection';
import { isEmptyParagraph } from './editor-core-utils';
import { isMediaNode } from './nodes';
export var filter = function filter(predicates, cmd) {
  return function (state, dispatch, view) {
    if (!Array.isArray(predicates)) {
      predicates = [predicates];
    }
    if (predicates.some(function (pred) {
      return !pred(state, view);
    })) {
      return false;
    }
    return cmd(state, dispatch, view) || false;
  };
};

/**
 * Walk forwards from a position until we encounter the (inside) start of
 * the next node, or reach the end of the document.
 *
 * @param $startPos Position to start walking from.
 */
export var walkNextNode = function walkNextNode($startPos) {
  var $pos = $startPos;

  // invariant 1: don't walk past the end of the document
  // invariant 2: we are at the beginning or
  //              we haven't walked to the start of *any* node
  //              parentOffset includes textOffset.
  while ($pos.pos < $pos.doc.nodeSize - 2 && ($pos.pos === $startPos.pos || $pos.parentOffset > 0)) {
    $pos = $pos.doc.resolve($pos.pos + 1);
  }
  return {
    $pos: $pos,
    foundNode: $pos.pos < $pos.doc.nodeSize - 2
  };
};

/**
 * Walk backwards from a position until we encounter the (inside) end of
 * the previous node, or reach the start of the document.
 *
 * @param $startPos Position to start walking from.
 */
export var walkPrevNode = function walkPrevNode($startPos) {
  var $pos = $startPos;
  while ($pos.pos > 0 && ($pos.pos === $startPos.pos || $pos.parentOffset < $pos.parent.nodeSize - 2)) {
    $pos = $pos.doc.resolve($pos.pos - 1);
  }
  return {
    $pos: $pos,
    foundNode: $pos.pos > 0
  };
};
export function insertNewLine() {
  return function (state, dispatch) {
    var $from = state.selection.$from;
    var parent = $from.parent;
    var hardBreak = state.schema.nodes.hardBreak;
    if (hardBreak) {
      var hardBreakNode = hardBreak.createChecked();
      if (parent && parent.type.validContent(Fragment.from(hardBreakNode))) {
        if (dispatch) {
          dispatch(state.tr.replaceSelectionWith(hardBreakNode, false));
        }
        return true;
      }
    }
    if (state.selection instanceof TextSelection) {
      if (dispatch) {
        dispatch(state.tr.insertText('\n'));
      }
      return true;
    }
    return false;
  };
}
export var insertNewLineWithAnalytics = function insertNewLineWithAnalytics(editorAnalyticsAPI) {
  return withAnalytics(editorAnalyticsAPI, {
    action: ACTION.INSERTED,
    actionSubject: ACTION_SUBJECT.TEXT,
    actionSubjectId: ACTION_SUBJECT_ID.LINE_BREAK,
    eventType: EVENT_TYPE.TRACK
  })(insertNewLine());
};
export var createNewParagraphAbove = function createNewParagraphAbove(state, dispatch) {
  var append = false;
  if (!canMoveUp(state) && canCreateParagraphNear(state)) {
    createParagraphNear(append)(state, dispatch);
    return true;
  }
  return false;
};
export var createNewParagraphBelow = function createNewParagraphBelow(state, dispatch) {
  var append = true;
  if (!canMoveDown(state) && canCreateParagraphNear(state)) {
    createParagraphNear(append)(state, dispatch);
    return true;
  }
  return false;
};
function canCreateParagraphNear(state) {
  var $from = state.selection.$from;
  var node = $from.node($from.depth);
  var insideCodeBlock = !!node && node.type === state.schema.nodes.codeBlock;
  var isNodeSelection = state.selection instanceof NodeSelection;
  return $from.depth > 1 || isNodeSelection || insideCodeBlock;
}
export function createParagraphNear() {
  var append = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return function (state, dispatch) {
    var paragraph = state.schema.nodes.paragraph;
    if (!paragraph) {
      return false;
    }
    var insertPos;
    if (state.selection instanceof TextSelection) {
      if (topLevelNodeIsEmptyTextBlock(state)) {
        return false;
      }
      insertPos = getInsertPosFromTextBlock(state, append);
    } else {
      insertPos = getInsertPosFromNonTextBlock(state, append);
    }
    var tr = state.tr.insert(insertPos, paragraph.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, insertPos + 1));
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  };
}
function getInsertPosFromTextBlock(state, append) {
  var _state$selection = state.selection,
    $from = _state$selection.$from,
    $to = _state$selection.$to;
  var pos;
  if (!append) {
    pos = $from.start(0);
  } else {
    pos = $to.end(0);
  }
  return pos;
}
function getInsertPosFromNonTextBlock(state, append) {
  var _state$selection2 = state.selection,
    $from = _state$selection2.$from,
    $to = _state$selection2.$to;
  var nodeAtSelection = state.selection instanceof NodeSelection && state.doc.nodeAt(state.selection.$anchor.pos);
  var isMediaSelection = nodeAtSelection && nodeAtSelection.type.name === 'mediaGroup';
  var pos;
  if (!append) {
    // The start position is different with text block because it starts from 0
    pos = $from.start($from.depth);
    // The depth is different with text block because it starts from 0
    pos = $from.depth > 0 && !isMediaSelection ? pos - 1 : pos;
  } else {
    pos = $to.end($to.depth);
    pos = $to.depth > 0 && !isMediaSelection ? pos + 1 : pos;
  }
  return pos;
}
function topLevelNodeIsEmptyTextBlock(state) {
  var topLevelNode = state.selection.$from.node(1);
  return topLevelNode.isTextblock && topLevelNode.type !== state.schema.nodes.codeBlock && topLevelNode.nodeSize === 2;
}
function canMoveUp(state) {
  var selection = state.selection;
  /**
   * If there's a media element on the selection it will use a gap cursor to move
   */
  if (selection instanceof NodeSelection && isMediaNode(selection.node)) {
    return true;
  }
  if (selection instanceof TextSelection) {
    if (!selection.empty) {
      return true;
    }
  }
  return !atTheBeginningOfDoc(state);
}
function canMoveDown(state) {
  var selection = state.selection;

  /**
   * If there's a media element on the selection it will use a gap cursor to move
   */
  if (selection instanceof NodeSelection && isMediaNode(selection.node)) {
    return true;
  }
  if (selection instanceof TextSelection) {
    if (!selection.empty) {
      return true;
    }
  }
  return !atTheEndOfDoc(state);
}
export function atTheEndOfDoc(state) {
  var selection = state.selection,
    doc = state.doc;
  return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;
}
export function atTheBeginningOfDoc(state) {
  var selection = state.selection;
  return selection.$from.pos === selection.$from.depth;
}

/**
 * If the selection is empty, is inside a paragraph node and `canNextNodeMoveUp` is true then delete current paragraph
 * and move the node below it up. The selection will be retained, to be placed in the moved node.
 *
 * @param canNextNodeMoveUp check if node directly after the selection is able to be brought up to selection
 * @returns PM Command
 */
export var deleteEmptyParagraphAndMoveBlockUp = function deleteEmptyParagraphAndMoveBlockUp(canNextNodeMoveUp) {
  return function (state, dispatch, view) {
    var _state$selection3 = state.selection,
      _state$selection3$$fr = _state$selection3.$from,
      pos = _state$selection3$$fr.pos,
      parent = _state$selection3$$fr.parent,
      $head = _state$selection3.$head,
      empty = _state$selection3.empty,
      tr = state.tr,
      doc = state.doc;
    var _walkNextNode = walkNextNode($head),
      $pos = _walkNextNode.$pos;
    var nextPMNode = doc.nodeAt($pos.pos - 1);
    if (empty && nextPMNode && canNextNodeMoveUp(nextPMNode) && isEmptyParagraph(parent) && view !== null && view !== void 0 && view.endOfTextblock('right')) {
      tr.deleteRange(pos - 1, pos + 1);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    }
    return false;
  };
};
export var insertContentDeleteRange = function insertContentDeleteRange(tr, getSelectionResolvedPos, insertions, deletions) {
  insertions.forEach(function (contentInsert) {
    var _contentInsert = _slicedToArray(contentInsert, 2),
      content = _contentInsert[0],
      pos = _contentInsert[1];
    tr.insert(tr.mapping.map(pos), content);
  });
  deletions.forEach(function (deleteRange) {
    var _deleteRange = _slicedToArray(deleteRange, 2),
      firstPos = _deleteRange[0],
      lastPos = _deleteRange[1];
    tr.delete(tr.mapping.map(firstPos), tr.mapping.map(lastPos));
  });
  tr.setSelection(new TextSelection(getSelectionResolvedPos(tr)));
};
export var isEmptySelectionAtStart = function isEmptySelectionAtStart(state) {
  var _state$selection4 = state.selection,
    empty = _state$selection4.empty,
    $from = _state$selection4.$from;
  return empty && ($from.parentOffset === 0 || state.selection instanceof GapCursorSelection);
};
export var isEmptySelectionAtEnd = function isEmptySelectionAtEnd(state) {
  var _state$selection5 = state.selection,
    empty = _state$selection5.empty,
    $from = _state$selection5.$from;
  return empty && ($from.end() === $from.pos || state.selection instanceof GapCursorSelection);
};
export { filter as filterCommand };