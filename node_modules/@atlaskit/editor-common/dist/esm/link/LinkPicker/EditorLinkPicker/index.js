import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["view", "onCancel", "invokeMethod", "editorAppearance", "onClose", "onEscapeCallback", "onClickAwayCallback"];
import React, { useCallback, useEffect, useMemo, useRef } from 'react';
import AnalyticsContext from '@atlaskit/analytics-next/AnalyticsContext';
import { LazyLinkPicker } from '@atlaskit/link-picker/lazy';
import { getAnalyticsEditorAppearance } from '../../../utils';
import { useEscapeClickaway } from './useEscapeClickaway';

/**
 * Returns a type that matches T but where keys (K) are now optional
 */

export var EditorLinkPicker = function EditorLinkPicker(_ref) {
  var view = _ref.view,
    onCancel = _ref.onCancel,
    _ref$invokeMethod = _ref.invokeMethod,
    invokeMethod = _ref$invokeMethod === void 0 ? '_unknown' : _ref$invokeMethod,
    editorAppearance = _ref.editorAppearance,
    onClose = _ref.onClose,
    onEscapeCallback = _ref.onEscapeCallback,
    onClickAwayCallback = _ref.onClickAwayCallback,
    restProps = _objectWithoutProperties(_ref, _excluded);
  /**
   * Track onClose handler in a
   * ref so that we void needing it in the dependency array
   * below
   */
  var onCloseRef = useRef(onClose);
  useEffect(function () {
    onCloseRef.current = onClose;
  });

  /**
   * Call onClose on mount, usefull to provide
   * a handler for performing an action after the component has been
   * unmounted (e.g. return focus to the editors)
   */
  useEffect(function () {
    return function () {
      var _onCloseRef$current;
      return (_onCloseRef$current = onCloseRef.current) === null || _onCloseRef$current === void 0 ? void 0 : _onCloseRef$current.call(onCloseRef);
    };
  }, []);
  var onEscape = useCallback(function () {
    var state = view.state,
      dispatch = view.dispatch;
    onEscapeCallback === null || onEscapeCallback === void 0 || onEscapeCallback(state, dispatch);
    onCancel === null || onCancel === void 0 || onCancel();
  }, [view, onCancel, onEscapeCallback]);
  var onClickAway = useCallback(function () {
    var state = view.state,
      dispatch = view.dispatch;
    onClickAwayCallback === null || onClickAwayCallback === void 0 || onClickAwayCallback(state, dispatch);
    onCancel === null || onCancel === void 0 || onCancel();
  }, [view, onCancel, onClickAwayCallback]);
  var ref = useEscapeClickaway(onEscape, onClickAway);
  var analyticsEditorAppearance = getAnalyticsEditorAppearance(editorAppearance);
  var analyticsData = useMemo(function () {
    return {
      attributes: {
        invokeMethod: invokeMethod,
        location: analyticsEditorAppearance
      },
      // Below is added for the future implementation of Linking Platform namespaced analytic context
      location: analyticsEditorAppearance
    };
  }, [invokeMethod, analyticsEditorAppearance]);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  }, /*#__PURE__*/React.createElement(AnalyticsContext, {
    data: analyticsData
  }, /*#__PURE__*/React.createElement(LazyLinkPicker
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, restProps, {
    onCancel: onEscape
  }))));
};