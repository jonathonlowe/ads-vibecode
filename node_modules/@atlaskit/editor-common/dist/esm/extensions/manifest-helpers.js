import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
export var FORGE_EXTENSION_TYPE = 'com.atlassian.ecosystem';
export var getExtensionKeyAndNodeKey = function getExtensionKeyAndNodeKey(extensionKey, extensionType) {
  // Forge macro extensionKey has a user generated string, so splitting on
  // a colon is unstable for their particular use case. They only have one
  // node in the relevant manifest so we can hardcode nodeKey to 'default'.
  if (extensionType === FORGE_EXTENSION_TYPE) {
    return [extensionKey, 'default'];
  }
  var _extensionKey$split = extensionKey.split(':'),
    _extensionKey$split2 = _slicedToArray(_extensionKey$split, 2),
    extKey = _extensionKey$split2[0],
    _extensionKey$split2$ = _extensionKey$split2[1],
    nodeKey = _extensionKey$split2$ === void 0 ? 'default' : _extensionKey$split2$;
  return [extKey, nodeKey];
};
export var buildExtensionKeyAndNodeKey = function buildExtensionKeyAndNodeKey(extensionKey, nodeKey) {
  if (!nodeKey || nodeKey === 'default') {
    return extensionKey;
  }
  return "".concat(extensionKey, ":").concat(nodeKey);
};
export function buildAction(action, manifest) {
  if (typeof action === 'function') {
    return action;
  }
  if (action.type === 'node' && manifest.modules.nodes) {
    return buildNode(action, manifest);
  }
}
export var resolveImport = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(importPromise) {
    var importedModule;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return importPromise;
        case 2:
          importedModule = _context.sent;
          return _context.abrupt("return", importedModule && importedModule.__esModule ? importedModule.default : importedModule);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveImport(_x) {
    return _ref.apply(this, arguments);
  };
}();
export function buildNode(action, manifest) {
  if (!manifest.modules.nodes) {
    return;
  }
  var node = manifest.modules.nodes[action.key];
  var extensionKey = buildExtensionKeyAndNodeKey(manifest.key, action.key);
  var extension = {
    type: node.type,
    attrs: {
      extensionType: manifest.type,
      extensionKey: extensionKey,
      parameters: action.parameters
    }
  };
  if (node.type === 'bodiedExtension') {
    return _objectSpread(_objectSpread({}, extension), {}, {
      content: [{
        type: 'paragraph',
        content: []
      }]
    });
  } else if (node.type === 'multiBodiedExtension') {
    return _objectSpread(_objectSpread({}, extension), {}, {
      content: [{
        type: 'extensionFrame',
        content: [{
          type: 'paragraph',
          content: []
        }]
      }]
    });
  }
  return extension;
}