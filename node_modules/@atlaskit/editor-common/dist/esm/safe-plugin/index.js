import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _toArray from "@babel/runtime/helpers/toArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { Plugin } from '@atlaskit/editor-prosemirror/state';
import { createProseMirrorMetadata } from '../prosemirror-dom-metadata';
/**
 * ðŸ§± Internal Helper Function: Editor FE Platform
 *
 * Attaches generic ProseMirror metadata attributes to a given DOM element based on the properties of a ProseMirror node.
 * This function is useful for annotating DOM elements with metadata that describes the type and characteristics of the ProseMirror node.
 *
 *
 * @param {Object} params - The parameters for the function.
 * @param {PMNode} params.node - The ProseMirror node from which to derive metadata.
 * @param {HTMLElement} params.dom - The DOM element to which the metadata attributes will be attached.
 */
export var attachGenericProseMirrorMetadata = function attachGenericProseMirrorMetadata(_ref) {
  var nodeOrMark = _ref.nodeOrMark,
    dom = _ref.dom;
  var metadata = createProseMirrorMetadata(nodeOrMark);
  Object.entries(metadata).forEach(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      name = _ref3[0],
      value = _ref3[1];
    dom.setAttribute(name, value);
  });
};

// Wraper to avoid any exception during the get pos operation
// See this https://hello.atlassian.net/wiki/spaces/EDITOR/pages/2849713193/ED-19672+Extensions+Regression
// And this https://discuss.prosemirror.net/t/possible-bug-on-viewdesc-posbeforechild/5783
var wrapGetPosExceptions = function wrapGetPosExceptions(spec) {
  var _spec$props;
  if (!(spec !== null && spec !== void 0 && (_spec$props = spec.props) !== null && _spec$props !== void 0 && _spec$props.nodeViews)) {
    return spec;
  }
  var unsafeNodeViews = spec.props.nodeViews;
  var safeNodeViews = new Proxy(unsafeNodeViews, {
    get: function get(target, prop, receiver) {
      var safeNodeView = new Proxy(Reflect.get(target, prop, receiver), {
        apply: function apply(target, thisArg, argumentsList) {
          var _argumentsList = _toArray(argumentsList),
            node = _argumentsList[0],
            view = _argumentsList[1],
            unsafeGetPos = _argumentsList[2],
            more = _argumentsList.slice(3);
          var safeGetPos = function () {
            try {
              return unsafeGetPos();
            } catch (e) {
              return;
            }
            return;
            // eslint-disable-next-line no-extra-bind
          }.bind(thisArg);
          var result = Reflect.apply(target, thisArg, [node, view, safeGetPos].concat(_toConsumableArray(more)));
          if ((result === null || result === void 0 ? void 0 : result.dom) instanceof HTMLElement) {
            attachGenericProseMirrorMetadata({
              nodeOrMark: node,
              dom: result.dom
            });
          }
          return result;
        }
      });
      return safeNodeView;
    }
  });
  spec.props.nodeViews = safeNodeViews;
  return spec;
};

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export var SafePlugin = /*#__PURE__*/function (_Plugin) {
  // This variable isn't (and shouldn't) be used anywhere. Its purpose is
  // to distinguish Plugin from SafePlugin, thus ensuring that an 'unsafe'
  // Plugin cannot be assigned as an item in EditorPlugin â†’ pmPlugins.

  function SafePlugin(spec) {
    _classCallCheck(this, SafePlugin);
    return _callSuper(this, SafePlugin, [wrapGetPosExceptions(spec)]);
  }
  _inherits(SafePlugin, _Plugin);
  return _createClass(SafePlugin);
}(Plugin);