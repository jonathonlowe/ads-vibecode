import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useCallback, useMemo, useState } from 'react';
import { akEditorGutterPadding, akEditorGutterPaddingDynamic, breakoutWideScaleRatio } from '@atlaskit/editor-shared-styles';
export var SNAP_GAP = 8;
var roundToNearest = function roundToNearest(value) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
  return Math.round(value / interval) * interval;
};
export function useBreakoutGuidelines(getEditorWidth, isResizing) {
  var widthState = getEditorWidth();
  var _useMemo = useMemo(function () {
      if (!isResizing) {
        return {};
      }
      var _ref = widthState || {},
        width = _ref.width,
        lineLength = _ref.lineLength;
      var wide = lineLength ? Math.round(lineLength * breakoutWideScaleRatio) : undefined;
      var fullWidth = width ? Math.min(width - akEditorGutterPaddingDynamic() * 2) : undefined;
      return {
        wide: wide,
        fullWidth: fullWidth,
        lineLength: lineLength
      };
    }, [widthState, isResizing]),
    lineLength = _useMemo.lineLength,
    wide = _useMemo.wide,
    fullWidth = _useMemo.fullWidth;
  var snaps = useMemo(function () {
    if (!isResizing) {
      return null;
    }
    var xSnaps = [];
    if (typeof lineLength === 'number') {
      xSnaps.push(lineLength);
    }
    if (typeof wide === 'number') {
      xSnaps.push(wide);
    }
    if (typeof fullWidth === 'number') {
      xSnaps.push(fullWidth - akEditorGutterPadding);
    }
    return {
      x: xSnaps
    };
  }, [isResizing, wide, fullWidth, lineLength]);
  var _useState = useState(null),
    _useState2 = _slicedToArray(_useState, 2),
    currentLayout = _useState2[0],
    setCurrentLayout = _useState2[1];
  var guidelines = useMemo(function () {
    var guidelines = [];
    if (!isResizing) {
      return guidelines;
    }
    if (lineLength) {
      guidelines.push({
        key: 'grid_left',
        position: {
          x: -roundToNearest(lineLength / 2)
        },
        active: currentLayout === 'center'
      });
      guidelines.push({
        key: 'grid_right',
        position: {
          x: roundToNearest(lineLength / 2)
        },
        active: currentLayout === 'center'
      });
    }
    if (wide) {
      guidelines.push({
        key: 'wide_left',
        position: {
          x: -roundToNearest(wide / 2)
        },
        active: currentLayout === 'wide'
      });
      guidelines.push({
        key: 'wide_right',
        position: {
          x: roundToNearest(wide / 2)
        },
        active: currentLayout === 'wide'
      });
    }
    if (fullWidth) {
      guidelines.push({
        key: 'full_width_left',
        position: {
          x: -roundToNearest(fullWidth / 2)
        },
        active: currentLayout === 'full-width'
      });
      guidelines.push({
        key: 'full_width_right',
        position: {
          x: roundToNearest(fullWidth) / 2
        },
        active: currentLayout === 'full-width'
      });
    }
    return guidelines;
  }, [isResizing, lineLength, wide, fullWidth, currentLayout]);
  var setCurrentWidth = useCallback(function (newWidth) {
    if (typeof newWidth !== 'number') {
      setCurrentLayout(null);
      return;
    }
    if (lineLength && Math.abs(newWidth - lineLength) < SNAP_GAP / 2) {
      setCurrentLayout('center');
    } else if (wide && Math.abs(newWidth - wide) < SNAP_GAP / 2) {
      setCurrentLayout('wide');
    } else if (fullWidth && (Math.abs(newWidth - fullWidth + akEditorGutterPadding) < SNAP_GAP / 2 || newWidth >= fullWidth)) {
      setCurrentLayout('full-width');
    } else {
      setCurrentLayout(null);
    }
  }, [lineLength, wide, fullWidth]);
  return {
    snaps: snaps,
    currentLayout: currentLayout,
    guidelines: guidelines,
    setCurrentWidth: setCurrentWidth
  };
}