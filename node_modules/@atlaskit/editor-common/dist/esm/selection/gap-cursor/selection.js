import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { Slice } from '@atlaskit/editor-prosemirror/model';
import { Selection } from '@atlaskit/editor-prosemirror/state';
import { isValidTargetNode } from './utils/is-valid-target-node';
export var Side = /*#__PURE__*/function (Side) {
  Side["LEFT"] = "left";
  Side["RIGHT"] = "right";
  return Side;
}({});
export var JSON_ID = 'gapcursor';
export var GapCursorSelection = /*#__PURE__*/function (_Selection) {
  /**
   * Construct a GapCursorSelection
   * @param {ResolvedPos} $pos resolved position
   * @param {Side} side side where the gap cursor is drawn
   */
  function GapCursorSelection($pos) {
    var _this;
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Side.LEFT;
    _classCallCheck(this, GapCursorSelection);
    _this = _callSuper(this, GapCursorSelection, [$pos, $pos]);
    _defineProperty(_this, "visible", false);
    _this.side = side;
    return _this;
  }
  _inherits(GapCursorSelection, _Selection);
  return _createClass(GapCursorSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var $pos = doc.resolve(mapping.map(this.head));
      return GapCursorSelection.valid($pos) ? new GapCursorSelection($pos, this.side) : Selection.near($pos);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof GapCursorSelection && other.head === this.head;
    }
  }, {
    key: "content",
    value: function content() {
      return Slice.empty;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new GapBookmark(this.anchor);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        pos: this.head,
        type: JSON_ID,
        side: this.side
      };
    }
  }], [{
    key: "valid",
    value: function valid($pos) {
      var parent = $pos.parent,
        nodeBefore = $pos.nodeBefore,
        nodeAfter = $pos.nodeAfter;
      var targetNode = isValidTargetNode(nodeBefore) ? nodeBefore : isValidTargetNode(nodeAfter) ? nodeAfter : null;
      if (!targetNode || parent.isTextblock) {
        return false;
      }

      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
  }, {
    key: "findFrom",
    value: function findFrom($pos, dir) {
      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var side = dir === 1 ? Side.RIGHT : Side.LEFT;
      if (!mustMove && GapCursorSelection.valid($pos)) {
        return new GapCursorSelection($pos, side);
      }
      var pos = $pos.pos;

      // TODO: ED-5048 - Fix any, potential issue.
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var next = null;

      // Scan up from this position
      for (var d = $pos.depth;; d--) {
        var parent = $pos.node(d);
        if (side === Side.RIGHT ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.maybeChild(side === Side.RIGHT ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d === 0) {
          return null;
        }
        pos += dir;
        var $cur = $pos.doc.resolve(pos);
        if (GapCursorSelection.valid($cur)) {
          return new GapCursorSelection($cur, side);
        }
      }

      // And then down into the next node
      for (;;) {
        next = side === Side.RIGHT ? next.firstChild : next.lastChild;
        if (next === null) {
          break;
        }
        pos += dir;
        var _$cur = $pos.doc.resolve(pos);
        if (GapCursorSelection.valid(_$cur)) {
          return new GapCursorSelection(_$cur, side);
        }
      }
      return null;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      return new GapCursorSelection(doc.resolve(json.pos), json.side);
    }
  }]);
}(Selection);
Selection.jsonID(JSON_ID, GapCursorSelection);
export var GapBookmark = /*#__PURE__*/function () {
  function GapBookmark(pos) {
    _classCallCheck(this, GapBookmark);
    this.pos = pos;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return _createClass(GapBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursorSelection.valid($pos) ? new GapCursorSelection($pos) : Selection.near($pos);
    }
  }]);
}();