import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import Fuse from 'fuse.js';
import memoizeOne from 'memoize-one';
import { fg } from '@atlaskit/platform-feature-flags';
var processQuickInsertItems = function processQuickInsertItems(items, intl) {
  return items.reduce(function (acc, item) {
    if (typeof item === 'function' &&
    // we preserve handler items with disableMemo so that we
    // can process them in a later step outside of memoizations
    !item.disableMemo) {
      var quickInsertItems = item(intl);
      return acc.concat(quickInsertItems);
    }
    return acc.concat(item);
  }, []);
};
var memoizedProcessQuickInsertItems = memoizeOne(processQuickInsertItems);
export var memoProcessQuickInsertItems = function memoProcessQuickInsertItems(items, intl) {
  var memoizedResults = memoizedProcessQuickInsertItems(items, intl);
  var hasDisabledMemos = items.some(function (item) {
    return typeof item === 'function' && item.disableMemo;
  });
  if (!hasDisabledMemos) {
    return memoizedResults;
  }
  return memoizedResults.flatMap(function (item) {
    return typeof item === 'function' && item.disableMemo ? item(intl) : item;
  });
};
var options = {
  threshold: 0.3,
  includeScore: true,
  keys: [{
    name: 'title',
    weight: 0.57
  }, {
    name: 'priority',
    weight: 0.3
  }, {
    name: 'keywords',
    weight: 0.08
  }, {
    name: 'description',
    weight: 0.04
  }, {
    name: 'keyshortcut',
    weight: 0.01
  }]
};
var optionsWithPriorityRemoved = {
  threshold: 0.3,
  includeScore: true,
  keys: [{
    name: 'title',
    weight: 0.57
  }, {
    name: 'keywords',
    weight: 0.08
  }, {
    name: 'description',
    weight: 0.04
  }, {
    name: 'keyshortcut',
    weight: 0.01
  }]
};

/**
 * This function is used to find and sort QuickInsertItems based on a given query string.
 *
 * @export
 * @param {string} query - The query string to be used in the search.
 * @param {QuickInsertItem[]} items - An array of QuickInsertItems to be searched.
 * @returns {QuickInsertItem[]} - Returns a sorted array of QuickInsertItems based on the priority. If the query string is empty, it will return the array sorted by priority. If a query string is provided, it will return an array of QuickInsertItems that match the query string, sorted by relevance to the query.
 */
export function find(query, items, prioritySortingFn) {
  if (query === '') {
    // Copy and sort list by priority
    return items.slice(0).sort(function (a, b) {
      return (a.priority || Number.POSITIVE_INFINITY) - (b.priority || Number.POSITIVE_INFINITY);
    });
  }
  var fuseOptions = _objectSpread({}, fg('platform_editor_remove_quick_insert_priority_key') ? optionsWithPriorityRemoved : options);
  if (prioritySortingFn) {
    var sortFn = prioritySortingFn(items);
    // prioritySortingFn will trigger the experiment exposure, but sortFn
    // will be undefined for the control group.
    if (sortFn) {
      fuseOptions.sortFn = sortFn;
    }
  }
  var fuse = new Fuse(items, fuseOptions);
  return fuse.search(query).map(function (result) {
    return result.item;
  });
}