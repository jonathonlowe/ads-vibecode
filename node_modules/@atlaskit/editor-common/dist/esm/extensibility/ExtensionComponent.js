import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["extensionProvider", "showLivePagesBodiedMacrosRendererView", "node"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable @repo/internal/react/no-class-components */
import React, { Component, useEffect, useLayoutEffect, useRef, useState } from 'react';
import memoizeOne from 'memoize-one';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { getExtensionModuleNodePrivateProps, getNodeRenderer } from '../extensions';
import { getExtensionRenderer, nodeToJSON, toJSON } from '../utils';
import Extension from './Extension/Extension';
import { isEmptyBodiedMacro } from './Extension/Extension/extension-utils';
import InlineExtension from './Extension/InlineExtension';
import MultiBodiedExtension from './MultiBodiedExtension';

/* temporary type until FG cleaned up */

/* temporary type until FG cleaned up */

var getBodiedExtensionContent = function getBodiedExtensionContent(node) {
  var bodiedExtensionContent = [];
  node.content.forEach(function (childNode) {
    bodiedExtensionContent.push(nodeToJSON(childNode));
  });
  return !!bodiedExtensionContent.length ? bodiedExtensionContent : node.attrs.text;
};
export var ExtensionComponent = function ExtensionComponent(props) {
  var extensionProviderResolver = props.extensionProvider,
    showLivePagesBodiedMacrosRendererView = props.showLivePagesBodiedMacrosRendererView,
    node = props.node,
    restProps = _objectWithoutProperties(props, _excluded);
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    extensionProvider = _useState2[0],
    setExtensionProvider = _useState2[1];
  var _useState3 = useState(!!(showLivePagesBodiedMacrosRendererView !== null && showLivePagesBodiedMacrosRendererView !== void 0 && showLivePagesBodiedMacrosRendererView(nodeToJSON(node))) && !isEmptyBodiedMacro(node)),
    _useState4 = _slicedToArray(_useState3, 2),
    showBodiedExtensionRendererView = _useState4[0],
    setShowBodiedExtensionRendererView = _useState4[1];
  var mountedRef = useRef(true);
  useLayoutEffect(function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  }, []);
  useEffect(function () {
    extensionProviderResolver === null || extensionProviderResolver === void 0 || extensionProviderResolver.then(function (provider) {
      if (mountedRef.current) {
        setExtensionProvider(provider);
      }
    });
  }, [extensionProviderResolver]);
  return /*#__PURE__*/React.createElement(ExtensionComponentInner
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, restProps, {
    extensionProvider: extensionProvider,
    node: node,
    showLivePagesBodiedMacrosRendererView: showLivePagesBodiedMacrosRendererView,
    showBodiedExtensionRendererView: showBodiedExtensionRendererView,
    setShowBodiedExtensionRendererView: setShowBodiedExtensionRendererView
  }));
};
var ExtensionComponentInner = /*#__PURE__*/function (_Component) {
  function ExtensionComponentInner() {
    var _this;
    _classCallCheck(this, ExtensionComponentInner);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, ExtensionComponentInner, [].concat(args));
    _defineProperty(_this, "privatePropsParsed", false);
    _defineProperty(_this, "state", {});
    // memoized to avoid rerender on extension state changes
    _defineProperty(_this, "getNodeRenderer", memoizeOne(getNodeRenderer));
    _defineProperty(_this, "getExtensionModuleNodePrivateProps", memoizeOne(getExtensionModuleNodePrivateProps));
    _defineProperty(_this, "setIsNodeHovered", function (isHovered) {
      // Don't want to show hover interactions for live page view mode
      if (!_this.props.isLivePageViewMode) {
        _this.setState({
          isNodeHovered: isHovered
        });
      }
    });
    /**
     * Parses any private nodes once an extension provider is available.
     *
     * We do this separately from resolving a node renderer component since the
     * private props come from extension provider, rather than an extension
     * handler which only handles `render`/component concerns.
     */
    _defineProperty(_this, "parsePrivateNodePropsIfNeeded", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _this$props$node$attr, extensionType, extensionKey, privateProps;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(_this.privatePropsParsed || !_this.props.extensionProvider)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            _this.privatePropsParsed = true;
            _this$props$node$attr = _this.props.node.attrs, extensionType = _this$props$node$attr.extensionType, extensionKey = _this$props$node$attr.extensionKey;
            /**
             * getExtensionModuleNodePrivateProps can throw if there are issues in the
             * manifest
             */
            _context.prev = 4;
            _context.next = 7;
            return _this.getExtensionModuleNodePrivateProps(_this.props.extensionProvider, extensionType, extensionKey);
          case 7:
            privateProps = _context.sent;
            _this.setState({
              _privateProps: privateProps
            });
            _context.next = 14;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](4);
            // eslint-disable-next-line no-console
            console.error('Provided extension handler has thrown an error\n', _context.t0);
            /** We don't want this error to block renderer */
            /** We keep rendering the default content */
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[4, 11]]);
    })));
    _defineProperty(_this, "handleExtension", function (pmNode, actions) {
      var _pmNode$marks;
      var _this$props = _this.props,
        extensionHandlers = _this$props.extensionHandlers,
        editorView = _this$props.editorView,
        showBodiedExtensionRendererView = _this$props.showBodiedExtensionRendererView,
        rendererExtensionHandlers = _this$props.rendererExtensionHandlers;
      var _pmNode$attrs = pmNode.attrs,
        extensionType = _pmNode$attrs.extensionType,
        extensionKey = _pmNode$attrs.extensionKey,
        parameters = _pmNode$attrs.parameters,
        text = _pmNode$attrs.text;
      var isBodiedExtension = pmNode.type.name === 'bodiedExtension';
      if (isBodiedExtension && !showBodiedExtensionRendererView) {
        return;
      }
      var fragmentLocalId = pmNode === null || pmNode === void 0 || (_pmNode$marks = pmNode.marks) === null || _pmNode$marks === void 0 || (_pmNode$marks = _pmNode$marks.find(function (m) {
        return m.type.name === 'fragment';
      })) === null || _pmNode$marks === void 0 || (_pmNode$marks = _pmNode$marks.attrs) === null || _pmNode$marks === void 0 ? void 0 : _pmNode$marks.localId;
      var content = isBodiedExtension ? getBodiedExtensionContent(pmNode) : text;
      var node = {
        type: pmNode.type.name,
        extensionType: extensionType,
        extensionKey: extensionKey,
        parameters: parameters,
        content: content,
        localId: pmNode.attrs.localId,
        fragmentLocalId: fragmentLocalId
      };
      if (isBodiedExtension) {
        var rendererExtensionHandler = rendererExtensionHandlers === null || rendererExtensionHandlers === void 0 ? void 0 : rendererExtensionHandlers[extensionType];
        // Forge bodied extensions don't get rendererExtensionHandlers passed in and use extensionHandlerFromProvider from the below logic instead
        if (rendererExtensionHandler) {
          return getExtensionRenderer(rendererExtensionHandler)(node, toJSON(editorView.state.doc));
        }
      }
      var result;
      if (extensionHandlers && extensionHandlers[extensionType]) {
        var render = getExtensionRenderer(extensionHandlers[extensionType]);
        result = render(node, editorView.state.doc, actions);
      }
      if (!result) {
        var extensionHandlerFromProvider = _this.props.extensionProvider && _this.getNodeRenderer(_this.props.extensionProvider, extensionType, extensionKey);
        if (extensionHandlerFromProvider) {
          var NodeRenderer = extensionHandlerFromProvider;
          if (node.type === 'multiBodiedExtension') {
            return /*#__PURE__*/React.createElement(NodeRenderer, {
              node: node,
              references: _this.props.references,
              actions: actions
            });
          } else {
            return /*#__PURE__*/React.createElement(NodeRenderer, {
              node: node,
              references: _this.props.references
            });
          }
        }
      }
      return result;
    });
    return _this;
  }
  _inherits(ExtensionComponentInner, _Component);
  return _createClass(ExtensionComponentInner, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.parsePrivateNodePropsIfNeeded();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state$_privateP2;
      var _this$props2 = this.props,
        node = _this$props2.node,
        handleContentDOMRef = _this$props2.handleContentDOMRef,
        editorView = _this$props2.editorView,
        references = _this$props2.references,
        editorAppearance = _this$props2.editorAppearance,
        pluginInjectionApi = _this$props2.pluginInjectionApi,
        getPos = _this$props2.getPos,
        eventDispatcher = _this$props2.eventDispatcher,
        macroInteractionDesignFeatureFlags = _this$props2.macroInteractionDesignFeatureFlags,
        extensionProvider = _this$props2.extensionProvider,
        showLivePagesBodiedMacrosRendererView = _this$props2.showLivePagesBodiedMacrosRendererView,
        showUpdatedLivePages1PBodiedExtensionUI = _this$props2.showUpdatedLivePages1PBodiedExtensionUI,
        showBodiedExtensionRendererView = _this$props2.showBodiedExtensionRendererView,
        setShowBodiedExtensionRendererView = _this$props2.setShowBodiedExtensionRendererView,
        isLivePageViewMode = _this$props2.isLivePageViewMode;
      var selection = editorView.state.selection;
      var selectedNode = selection instanceof NodeSelection && selection.node;
      var position = typeof getPos === 'function' && getPos();
      var resolvedPosition = position && editorView.state.doc.resolve(position);
      var isNodeNested = !!(resolvedPosition && resolvedPosition.depth > 0);
      if (node.type.name === 'multiBodiedExtension') {
        var _this$state$_privateP;
        var allowBodiedOverride = ((_this$state$_privateP = this.state._privateProps) === null || _this$state$_privateP === void 0 ? void 0 : _this$state$_privateP.__allowBodiedOverride) && fg('platform_editor_multi_body_extension_extensibility');
        return /*#__PURE__*/React.createElement(MultiBodiedExtension, {
          node: node,
          editorView: editorView,
          getPos: getPos,
          handleContentDOMRef: handleContentDOMRef,
          tryExtensionHandler: this.tryExtensionHandler.bind(this),
          eventDispatcher: eventDispatcher,
          pluginInjectionApi: pluginInjectionApi,
          editorAppearance: editorAppearance,
          macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
          isNodeSelected: selectedNode === node,
          isNodeNested: isNodeNested,
          isNodeHovered: this.state.isNodeHovered,
          setIsNodeHovered: this.setIsNodeHovered,
          isLivePageViewMode: isLivePageViewMode,
          allowBodiedOverride: allowBodiedOverride
        });
      }
      var extensionHandlerResult = this.tryExtensionHandler(undefined);
      switch (node.type.name) {
        case 'extension':
        case 'bodiedExtension':
          return /*#__PURE__*/React.createElement(Extension, {
            node: node,
            getPos: this.props.getPos,
            references: references,
            extensionProvider: extensionProvider,
            handleContentDOMRef: handleContentDOMRef,
            view: editorView,
            editorAppearance: editorAppearance,
            hideFrame: (_this$state$_privateP2 = this.state._privateProps) === null || _this$state$_privateP2 === void 0 ? void 0 : _this$state$_privateP2.__hideFrame,
            pluginInjectionApi: pluginInjectionApi,
            macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
            isNodeSelected: selectedNode === node,
            isNodeHovered: this.state.isNodeHovered,
            isNodeNested: isNodeNested,
            setIsNodeHovered: this.setIsNodeHovered,
            showLivePagesBodiedMacrosRendererView: !!(showLivePagesBodiedMacrosRendererView !== null && showLivePagesBodiedMacrosRendererView !== void 0 && showLivePagesBodiedMacrosRendererView(nodeToJSON(node))),
            showUpdatedLivePages1PBodiedExtensionUI: !!(showUpdatedLivePages1PBodiedExtensionUI !== null && showUpdatedLivePages1PBodiedExtensionUI !== void 0 && showUpdatedLivePages1PBodiedExtensionUI(nodeToJSON(node))),
            showBodiedExtensionRendererView: showBodiedExtensionRendererView,
            setShowBodiedExtensionRendererView: setShowBodiedExtensionRendererView,
            isLivePageViewMode: isLivePageViewMode
          }, extensionHandlerResult);
        case 'inlineExtension':
          return /*#__PURE__*/React.createElement(InlineExtension, {
            node: node,
            macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
            isNodeSelected: selectedNode === node,
            pluginInjectionApi: pluginInjectionApi,
            isNodeHovered: this.state.isNodeHovered,
            setIsNodeHovered: this.setIsNodeHovered,
            isLivePageViewMode: isLivePageViewMode
          }, extensionHandlerResult);
        default:
          return null;
      }
    }
  }, {
    key: "tryExtensionHandler",
    value: function tryExtensionHandler(actions) {
      var node = this.props.node;
      try {
        var extensionContent = this.handleExtension(node, actions);
        if (extensionContent && /*#__PURE__*/React.isValidElement(extensionContent)) {
          return extensionContent;
        }
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('Provided extension handler has thrown an error\n', e);
        /** We don't want this error to block renderer */
        /** We keep rendering the default content */
      }
      return null;
    }
  }]);
}(Component);