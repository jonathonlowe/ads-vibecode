import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { EventEmitter } from 'events';
export var SharedAnnotationManager = /*#__PURE__*/function () {
  function SharedAnnotationManager() {
    _classCallCheck(this, SharedAnnotationManager);
    /**
     * This is the event emitter that is used to emit events from the manager. It is used to communicate with
     * other parts of the application.
     */
    _defineProperty(this, "emitter", new EventEmitter());
    /**
     * This is the map of hooks that can be added to the manager. Hooks are a 1:1 mapping of methods that can be
     * called on the manager. They are used to extend the functionality of the manager.
     */
    _defineProperty(this, "hooks", new Map());
    _defineProperty(this, "preemptiveGate", function () {
      return Promise.resolve(true);
    });
    _defineProperty(this, "activePreemptiveGate", undefined);
  }
  return _createClass(SharedAnnotationManager, [{
    key: "setPreemptiveGate",
    value: function setPreemptiveGate(handler) {
      this.preemptiveGate = handler;
      return this;
    }
  }, {
    key: "checkPreemptiveGate",
    value: function checkPreemptiveGate() {
      var _this = this;
      if (this.activePreemptiveGate) {
        // If the preemptive gate check already in flight then just return the promise
        // and don't call the preemptive gate again.
        // This is to prevent multiple calls to the preemptive gate creating multiple
        // promises that will resolve at different times.
        return Promise.resolve(this.activePreemptiveGate);
      }
      var gate = this.activePreemptiveGate = this.preemptiveGate().then(function (result) {
        _this.activePreemptiveGate = undefined;
        return result;
      });
      return gate;
    }
  }, {
    key: "onDraftAnnotationStarted",
    value: function onDraftAnnotationStarted(handler) {
      this.emitter.on('draftAnnotationStarted', handler);
      return this;
    }
  }, {
    key: "offDraftAnnotationStarted",
    value: function offDraftAnnotationStarted(handler) {
      this.emitter.off('draftAnnotationStarted', handler);
      return this;
    }
  }, {
    key: "onAnnotationSelectionChange",
    value: function onAnnotationSelectionChange(handler) {
      this.emitter.on('annotationSelectionChanged', handler);
      return this;
    }
  }, {
    key: "offAnnotationSelectionChange",
    value: function offAnnotationSelectionChange(handler) {
      this.emitter.off('annotationSelectionChanged', handler);
      return this;
    }
  }, {
    key: "emit",
    value: function emit(event) {
      this.emitter.emit(event.name, event.data);
      return this;
    }
  }, {
    key: "hook",
    value: function hook(method, handler) {
      this.hooks.set(method, handler);
      return this;
    }
  }, {
    key: "unhook",
    value: function unhook(method, handler) {
      if (!this.hooks.has(method) || this.hooks.get(method) !== handler) {
        return this;
      }
      this.hooks.delete(method);
      return this;
    }
  }, {
    key: "allowAnnotation",
    value: function allowAnnotation() {
      var fn = this.hooks.get('allowAnnotation');
      if (!fn) {
        return false;
      }
      try {
        return fn();
      } catch (error) {
        return false;
      }
    }
  }, {
    key: "startDraft",
    value: function startDraft() {
      var fn = this.hooks.get('startDraft');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn();
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "clearDraft",
    value: function clearDraft() {
      var fn = this.hooks.get('clearDraft');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn();
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "applyDraft",
    value: function applyDraft(id) {
      var fn = this.hooks.get('applyDraft');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn(id);
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "getDraft",
    value: function getDraft() {
      var fn = this.hooks.get('getDraft');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn();
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "setIsAnnotationSelected",
    value: function setIsAnnotationSelected(id, isSelected) {
      var fn = this.hooks.get('setIsAnnotationSelected');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        // NOTE: The hook needs to manage the firing the annotationSelectionChanged event when a change is made. This is
        // because the hook is responsible for the state of the selection. The manager is not responsible for the state of
        // the selection.
        return fn(id, isSelected);
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "setIsAnnotationHovered",
    value: function setIsAnnotationHovered(id, isHovered) {
      var fn = this.hooks.get('setIsAnnotationHovered');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn(id, isHovered);
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }, {
    key: "clearAnnotation",
    value: function clearAnnotation(id) {
      var fn = this.hooks.get('clearAnnotation');
      if (!fn) {
        return {
          success: false,
          reason: 'manager-not-initialized'
        };
      }
      try {
        return fn(id);
      } catch (error) {
        return {
          success: false,
          reason: 'hook-execution-error'
        };
      }
    }
  }]);
}();