import { Fragment, type Node as PMNode, type ResolvedPos } from '@atlaskit/editor-prosemirror/model';
import { type EditorState, type Transaction } from '@atlaskit/editor-prosemirror/state';
import { type EditorAnalyticsAPI } from '../analytics';
import type { Command, Predicate } from '../types';
export type WalkNode = {
    $pos: ResolvedPos;
    foundNode: boolean;
};
export declare const filter: (predicates: Predicate[] | Predicate, cmd: Command) => Command;
/**
 * Walk forwards from a position until we encounter the (inside) start of
 * the next node, or reach the end of the document.
 *
 * @param $startPos Position to start walking from.
 */
export declare const walkNextNode: ($startPos: ResolvedPos) => WalkNode;
/**
 * Walk backwards from a position until we encounter the (inside) end of
 * the previous node, or reach the start of the document.
 *
 * @param $startPos Position to start walking from.
 */
export declare const walkPrevNode: ($startPos: ResolvedPos) => WalkNode;
export declare function insertNewLine(): Command;
export declare const insertNewLineWithAnalytics: (editorAnalyticsAPI: EditorAnalyticsAPI | undefined) => Command;
export declare const createNewParagraphAbove: Command;
export declare const createNewParagraphBelow: Command;
export declare function createParagraphNear(append?: boolean): Command;
export declare function atTheEndOfDoc(state: EditorState): boolean;
export declare function atTheBeginningOfDoc(state: EditorState): boolean;
/**
 * If the selection is empty, is inside a paragraph node and `canNextNodeMoveUp` is true then delete current paragraph
 * and move the node below it up. The selection will be retained, to be placed in the moved node.
 *
 * @param canNextNodeMoveUp check if node directly after the selection is able to be brought up to selection
 * @returns PM Command
 */
export declare const deleteEmptyParagraphAndMoveBlockUp: (canNextNodeMoveUp: (nextNode: PMNode) => boolean) => Command;
export declare const insertContentDeleteRange: (tr: Transaction, getSelectionResolvedPos: (tr: Transaction) => ResolvedPos, insertions: [
    Fragment,
    number
][], deletions: [
    number,
    number
][]) => void;
export declare const isEmptySelectionAtStart: (state: EditorState) => boolean;
export declare const isEmptySelectionAtEnd: (state: EditorState) => boolean;
export { filter as filterCommand };
