import type React from 'react';
import { type Node as PMNode } from '@atlaskit/editor-prosemirror/model';
import { type EditorView } from '@atlaskit/editor-prosemirror/view';
import { type EventDispatcher } from '../event-dispatcher';
import { type PortalProviderAPI } from '../portal';
import ReactNodeView, { type getPosHandler, type ReactComponentProps, type shouldUpdate } from '../react-node-view';
/**
 * A ReactNodeView that handles React components sensitive
 * to selection changes.
 *
 * If the selection changes, it will attempt to re-render the
 * React component. Otherwise it does nothing.
 *
 * You can subclass `viewShouldUpdate` to include other
 * props that your component might want to consider before
 * entering the React lifecycle. These are usually props you
 * compare in `shouldComponentUpdate`.
 *
 * An example:
 *
 * ```
 * viewShouldUpdate(nextNode) {
 *   if (nextNode.attrs !== this.node.attrs) {
 *     return true;
 *   }
 *
 *   return super.viewShouldUpdate(nextNode);
 * }```
 */
export declare class SelectionBasedNodeView<P = ReactComponentProps> extends ReactNodeView<P> {
    protected isSelectedNode: boolean;
    pos: number | undefined;
    posEnd: number | undefined;
    constructor(node: PMNode, view: EditorView, getPos: getPosHandler, portalProviderAPI: PortalProviderAPI, eventDispatcher: EventDispatcher, reactComponentProps: P, reactComponent?: React.ComponentType<React.PropsWithChildren<any>>, viewShouldUpdate?: shouldUpdate);
    /**
     * Update current node's start and end positions.
     *
     * Prefer `this.pos` rather than getPos(), because calling getPos is
     * expensive, unless you know you're definitely going to render.
     */
    private updatePos;
    private getPositionsWithDefault;
    private isNodeInsideSelection;
    private isSelectionInsideNode;
    insideSelection: () => boolean;
    nodeInsideSelection: () => boolean;
    selectNode(): void;
    deselectNode(): void;
}
