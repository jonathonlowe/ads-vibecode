"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtensionComponent = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _extensions = require("../extensions");
var _utils = require("../utils");
var _Extension = _interopRequireDefault(require("./Extension/Extension"));
var _extensionUtils = require("./Extension/Extension/extension-utils");
var _InlineExtension = _interopRequireDefault(require("./Extension/InlineExtension"));
var _MultiBodiedExtension = _interopRequireDefault(require("./MultiBodiedExtension"));
var _excluded = ["extensionProvider", "showLivePagesBodiedMacrosRendererView", "node"];
/* eslint-disable @repo/internal/react/no-class-components */
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* temporary type until FG cleaned up */

/* temporary type until FG cleaned up */

var getBodiedExtensionContent = function getBodiedExtensionContent(node) {
  var bodiedExtensionContent = [];
  node.content.forEach(function (childNode) {
    bodiedExtensionContent.push((0, _utils.nodeToJSON)(childNode));
  });
  return !!bodiedExtensionContent.length ? bodiedExtensionContent : node.attrs.text;
};
var ExtensionComponent = exports.ExtensionComponent = function ExtensionComponent(props) {
  var extensionProviderResolver = props.extensionProvider,
    showLivePagesBodiedMacrosRendererView = props.showLivePagesBodiedMacrosRendererView,
    node = props.node,
    restProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  var _useState = (0, _react.useState)(undefined),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    extensionProvider = _useState2[0],
    setExtensionProvider = _useState2[1];
  var _useState3 = (0, _react.useState)(!!(showLivePagesBodiedMacrosRendererView !== null && showLivePagesBodiedMacrosRendererView !== void 0 && showLivePagesBodiedMacrosRendererView((0, _utils.nodeToJSON)(node))) && !(0, _extensionUtils.isEmptyBodiedMacro)(node)),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    showBodiedExtensionRendererView = _useState4[0],
    setShowBodiedExtensionRendererView = _useState4[1];
  var mountedRef = (0, _react.useRef)(true);
  (0, _react.useLayoutEffect)(function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  }, []);
  (0, _react.useEffect)(function () {
    extensionProviderResolver === null || extensionProviderResolver === void 0 || extensionProviderResolver.then(function (provider) {
      if (mountedRef.current) {
        setExtensionProvider(provider);
      }
    });
  }, [extensionProviderResolver]);
  return /*#__PURE__*/_react.default.createElement(ExtensionComponentInner
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , (0, _extends2.default)({}, restProps, {
    extensionProvider: extensionProvider,
    node: node,
    showLivePagesBodiedMacrosRendererView: showLivePagesBodiedMacrosRendererView,
    showBodiedExtensionRendererView: showBodiedExtensionRendererView,
    setShowBodiedExtensionRendererView: setShowBodiedExtensionRendererView
  }));
};
var ExtensionComponentInner = /*#__PURE__*/function (_Component) {
  function ExtensionComponentInner() {
    var _this;
    (0, _classCallCheck2.default)(this, ExtensionComponentInner);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, ExtensionComponentInner, [].concat(args));
    (0, _defineProperty2.default)(_this, "privatePropsParsed", false);
    (0, _defineProperty2.default)(_this, "state", {});
    // memoized to avoid rerender on extension state changes
    (0, _defineProperty2.default)(_this, "getNodeRenderer", (0, _memoizeOne.default)(_extensions.getNodeRenderer));
    (0, _defineProperty2.default)(_this, "getExtensionModuleNodePrivateProps", (0, _memoizeOne.default)(_extensions.getExtensionModuleNodePrivateProps));
    (0, _defineProperty2.default)(_this, "setIsNodeHovered", function (isHovered) {
      // Don't want to show hover interactions for live page view mode
      if (!_this.props.isLivePageViewMode) {
        _this.setState({
          isNodeHovered: isHovered
        });
      }
    });
    /**
     * Parses any private nodes once an extension provider is available.
     *
     * We do this separately from resolving a node renderer component since the
     * private props come from extension provider, rather than an extension
     * handler which only handles `render`/component concerns.
     */
    (0, _defineProperty2.default)(_this, "parsePrivateNodePropsIfNeeded", /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var _this$props$node$attr, extensionType, extensionKey, privateProps;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(_this.privatePropsParsed || !_this.props.extensionProvider)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            _this.privatePropsParsed = true;
            _this$props$node$attr = _this.props.node.attrs, extensionType = _this$props$node$attr.extensionType, extensionKey = _this$props$node$attr.extensionKey;
            /**
             * getExtensionModuleNodePrivateProps can throw if there are issues in the
             * manifest
             */
            _context.prev = 4;
            _context.next = 7;
            return _this.getExtensionModuleNodePrivateProps(_this.props.extensionProvider, extensionType, extensionKey);
          case 7:
            privateProps = _context.sent;
            _this.setState({
              _privateProps: privateProps
            });
            _context.next = 14;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](4);
            // eslint-disable-next-line no-console
            console.error('Provided extension handler has thrown an error\n', _context.t0);
            /** We don't want this error to block renderer */
            /** We keep rendering the default content */
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[4, 11]]);
    })));
    (0, _defineProperty2.default)(_this, "handleExtension", function (pmNode, actions) {
      var _pmNode$marks;
      var _this$props = _this.props,
        extensionHandlers = _this$props.extensionHandlers,
        editorView = _this$props.editorView,
        showBodiedExtensionRendererView = _this$props.showBodiedExtensionRendererView,
        rendererExtensionHandlers = _this$props.rendererExtensionHandlers;
      var _pmNode$attrs = pmNode.attrs,
        extensionType = _pmNode$attrs.extensionType,
        extensionKey = _pmNode$attrs.extensionKey,
        parameters = _pmNode$attrs.parameters,
        text = _pmNode$attrs.text;
      var isBodiedExtension = pmNode.type.name === 'bodiedExtension';
      if (isBodiedExtension && !showBodiedExtensionRendererView) {
        return;
      }
      var fragmentLocalId = pmNode === null || pmNode === void 0 || (_pmNode$marks = pmNode.marks) === null || _pmNode$marks === void 0 || (_pmNode$marks = _pmNode$marks.find(function (m) {
        return m.type.name === 'fragment';
      })) === null || _pmNode$marks === void 0 || (_pmNode$marks = _pmNode$marks.attrs) === null || _pmNode$marks === void 0 ? void 0 : _pmNode$marks.localId;
      var content = isBodiedExtension ? getBodiedExtensionContent(pmNode) : text;
      var node = {
        type: pmNode.type.name,
        extensionType: extensionType,
        extensionKey: extensionKey,
        parameters: parameters,
        content: content,
        localId: pmNode.attrs.localId,
        fragmentLocalId: fragmentLocalId
      };
      if (isBodiedExtension) {
        var rendererExtensionHandler = rendererExtensionHandlers === null || rendererExtensionHandlers === void 0 ? void 0 : rendererExtensionHandlers[extensionType];
        // Forge bodied extensions don't get rendererExtensionHandlers passed in and use extensionHandlerFromProvider from the below logic instead
        if (rendererExtensionHandler) {
          return (0, _utils.getExtensionRenderer)(rendererExtensionHandler)(node, (0, _utils.toJSON)(editorView.state.doc));
        }
      }
      var result;
      if (extensionHandlers && extensionHandlers[extensionType]) {
        var render = (0, _utils.getExtensionRenderer)(extensionHandlers[extensionType]);
        result = render(node, editorView.state.doc, actions);
      }
      if (!result) {
        var extensionHandlerFromProvider = _this.props.extensionProvider && _this.getNodeRenderer(_this.props.extensionProvider, extensionType, extensionKey);
        if (extensionHandlerFromProvider) {
          var NodeRenderer = extensionHandlerFromProvider;
          if (node.type === 'multiBodiedExtension') {
            return /*#__PURE__*/_react.default.createElement(NodeRenderer, {
              node: node,
              references: _this.props.references,
              actions: actions
            });
          } else {
            return /*#__PURE__*/_react.default.createElement(NodeRenderer, {
              node: node,
              references: _this.props.references
            });
          }
        }
      }
      return result;
    });
    return _this;
  }
  (0, _inherits2.default)(ExtensionComponentInner, _Component);
  return (0, _createClass2.default)(ExtensionComponentInner, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.parsePrivateNodePropsIfNeeded();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state$_privateP2;
      var _this$props2 = this.props,
        node = _this$props2.node,
        handleContentDOMRef = _this$props2.handleContentDOMRef,
        editorView = _this$props2.editorView,
        references = _this$props2.references,
        editorAppearance = _this$props2.editorAppearance,
        pluginInjectionApi = _this$props2.pluginInjectionApi,
        getPos = _this$props2.getPos,
        eventDispatcher = _this$props2.eventDispatcher,
        macroInteractionDesignFeatureFlags = _this$props2.macroInteractionDesignFeatureFlags,
        extensionProvider = _this$props2.extensionProvider,
        showLivePagesBodiedMacrosRendererView = _this$props2.showLivePagesBodiedMacrosRendererView,
        showUpdatedLivePages1PBodiedExtensionUI = _this$props2.showUpdatedLivePages1PBodiedExtensionUI,
        showBodiedExtensionRendererView = _this$props2.showBodiedExtensionRendererView,
        setShowBodiedExtensionRendererView = _this$props2.setShowBodiedExtensionRendererView,
        isLivePageViewMode = _this$props2.isLivePageViewMode;
      var selection = editorView.state.selection;
      var selectedNode = selection instanceof _state.NodeSelection && selection.node;
      var position = typeof getPos === 'function' && getPos();
      var resolvedPosition = position && editorView.state.doc.resolve(position);
      var isNodeNested = !!(resolvedPosition && resolvedPosition.depth > 0);
      if (node.type.name === 'multiBodiedExtension') {
        var _this$state$_privateP;
        var allowBodiedOverride = ((_this$state$_privateP = this.state._privateProps) === null || _this$state$_privateP === void 0 ? void 0 : _this$state$_privateP.__allowBodiedOverride) && (0, _platformFeatureFlags.fg)('platform_editor_multi_body_extension_extensibility');
        return /*#__PURE__*/_react.default.createElement(_MultiBodiedExtension.default, {
          node: node,
          editorView: editorView,
          getPos: getPos,
          handleContentDOMRef: handleContentDOMRef,
          tryExtensionHandler: this.tryExtensionHandler.bind(this),
          eventDispatcher: eventDispatcher,
          pluginInjectionApi: pluginInjectionApi,
          editorAppearance: editorAppearance,
          macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
          isNodeSelected: selectedNode === node,
          isNodeNested: isNodeNested,
          isNodeHovered: this.state.isNodeHovered,
          setIsNodeHovered: this.setIsNodeHovered,
          isLivePageViewMode: isLivePageViewMode,
          allowBodiedOverride: allowBodiedOverride
        });
      }
      var extensionHandlerResult = this.tryExtensionHandler(undefined);
      switch (node.type.name) {
        case 'extension':
        case 'bodiedExtension':
          return /*#__PURE__*/_react.default.createElement(_Extension.default, {
            node: node,
            getPos: this.props.getPos,
            references: references,
            extensionProvider: extensionProvider,
            handleContentDOMRef: handleContentDOMRef,
            view: editorView,
            editorAppearance: editorAppearance,
            hideFrame: (_this$state$_privateP2 = this.state._privateProps) === null || _this$state$_privateP2 === void 0 ? void 0 : _this$state$_privateP2.__hideFrame,
            pluginInjectionApi: pluginInjectionApi,
            macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
            isNodeSelected: selectedNode === node,
            isNodeHovered: this.state.isNodeHovered,
            isNodeNested: isNodeNested,
            setIsNodeHovered: this.setIsNodeHovered,
            showLivePagesBodiedMacrosRendererView: !!(showLivePagesBodiedMacrosRendererView !== null && showLivePagesBodiedMacrosRendererView !== void 0 && showLivePagesBodiedMacrosRendererView((0, _utils.nodeToJSON)(node))),
            showUpdatedLivePages1PBodiedExtensionUI: !!(showUpdatedLivePages1PBodiedExtensionUI !== null && showUpdatedLivePages1PBodiedExtensionUI !== void 0 && showUpdatedLivePages1PBodiedExtensionUI((0, _utils.nodeToJSON)(node))),
            showBodiedExtensionRendererView: showBodiedExtensionRendererView,
            setShowBodiedExtensionRendererView: setShowBodiedExtensionRendererView,
            isLivePageViewMode: isLivePageViewMode
          }, extensionHandlerResult);
        case 'inlineExtension':
          return /*#__PURE__*/_react.default.createElement(_InlineExtension.default, {
            node: node,
            macroInteractionDesignFeatureFlags: macroInteractionDesignFeatureFlags,
            isNodeSelected: selectedNode === node,
            pluginInjectionApi: pluginInjectionApi,
            isNodeHovered: this.state.isNodeHovered,
            setIsNodeHovered: this.setIsNodeHovered,
            isLivePageViewMode: isLivePageViewMode
          }, extensionHandlerResult);
        default:
          return null;
      }
    }
  }, {
    key: "tryExtensionHandler",
    value: function tryExtensionHandler(actions) {
      var node = this.props.node;
      try {
        var extensionContent = this.handleExtension(node, actions);
        if (extensionContent && /*#__PURE__*/_react.default.isValidElement(extensionContent)) {
          return extensionContent;
        }
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('Provided extension handler has thrown an error\n', e);
        /** We don't want this error to block renderer */
        /** We keep rendering the default content */
      }
      return null;
    }
  }]);
}(_react.Component);