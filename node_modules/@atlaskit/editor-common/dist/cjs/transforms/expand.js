"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformSliceToRemoveOpenNestedExpand = exports.transformSliceToRemoveOpenExpand = exports.transformSliceNestedExpandToExpand = exports.transformSliceExpandToNestedExpand = exports.findExpand = void 0;
var _model = require("@atlaskit/editor-prosemirror/model");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _slice = require("../utils/slice");
var findExpand = exports.findExpand = function findExpand(state, selection) {
  var _state$schema$nodes = state.schema.nodes,
    expand = _state$schema$nodes.expand,
    nestedExpand = _state$schema$nodes.nestedExpand;
  return (0, _utils.findSelectedNodeOfType)([expand, nestedExpand])(selection || state.selection) || (0, _utils.findParentNodeOfType)([expand, nestedExpand])(selection || state.selection);
};

// If the top level is a single expand, and the expand is not
// a part of copied content, then return unwrap contents.
// This is needed for handling content copied from expand.
// https://product-fabric.atlassian.net/browse/ED-9146
var transformSliceToRemoveOpenExpand = exports.transformSliceToRemoveOpenExpand = function transformSliceToRemoveOpenExpand(slice, schema) {
  if (slice.openStart > 1 && slice.openEnd > 1 && slice.content.childCount === 1 && slice.content.firstChild && slice.content.firstChild.type === schema.nodes.expand) {
    return new _model.Slice(slice.content.firstChild.content, slice.openStart - 1, slice.openEnd - 1);
  }
  return slice;
};
var transformSliceToRemoveOpenNestedExpand = exports.transformSliceToRemoveOpenNestedExpand = function transformSliceToRemoveOpenNestedExpand(slice, schema) {
  if (slice.openStart > 1 && slice.openEnd > 1 && slice.content.childCount === 1 && slice.content.firstChild && slice.content.firstChild.type === schema.nodes.nestedExpand) {
    return new _model.Slice(slice.content.firstChild.content, slice.openStart - 1, slice.openEnd - 1);
  }
  return slice;
};
var transformSliceNestedExpandToExpand = exports.transformSliceNestedExpandToExpand = function transformSliceNestedExpandToExpand(slice, schema) {
  var _schema$nodes = schema.nodes,
    expand = _schema$nodes.expand,
    nestedExpand = _schema$nodes.nestedExpand;
  var children = [];
  (0, _slice.mapChildren)(slice.content, function (node) {
    if (node.type === nestedExpand) {
      children.push(expand.createChecked(node.attrs, node.content, node.marks));
    } else {
      children.push(node);
    }
  });
  return new _model.Slice(_model.Fragment.fromArray(children), slice.openStart, slice.openEnd);
};
var transformSliceExpandToNestedExpand = exports.transformSliceExpandToNestedExpand = function transformSliceExpandToNestedExpand(slice) {
  var children = [];
  try {
    (0, _slice.mapChildren)(slice.content, function (currentNode) {
      var _currentNode$type$sch = currentNode.type.schema.nodes,
        expand = _currentNode$type$sch.expand,
        nestedExpand = _currentNode$type$sch.nestedExpand;
      if (currentNode.type === expand) {
        var nestedExpandNode = nestedExpand.createChecked(currentNode.attrs, currentNode.content, currentNode.marks);
        if (nestedExpandNode) {
          children.push(nestedExpandNode);
        }
      } else {
        children.push(currentNode);
      }
    });
  } catch (e) {
    // Will throw error if unable to convert expand to nested expand.
    // Example: expand containing a table being converted to nested expand containing table.
    return null;
  }
  return new _model.Slice(_model.Fragment.fromArray(children), slice.openStart, slice.openEnd);
};