"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLayoutFromFirstChild = removeLayoutFromFirstChild;
exports.removeLayoutFromLastChild = removeLayoutFromLastChild;
exports.transformSingleColumnLayout = void 0;
exports.transformSliceToRemoveOpenLayoutNodes = transformSliceToRemoveOpenLayoutNodes;
exports.unwrapContentFromLayout = unwrapContentFromLayout;
var _model = require("@atlaskit/editor-prosemirror/model");
var _slice = require("../utils/slice");
var isLayoutNode = function isLayoutNode(node) {
  return node.type === node.type.schema.nodes.layoutSection || node.type === node.type.schema.nodes.layoutColumn;
};
function unwrapContentFromLayout(maybeLayoutSection) {
  var fragment = (0, _slice.mapFragment)(_model.Fragment.from(maybeLayoutSection), function (node) {
    return isLayoutNode(node) ? node.content : node;
  });
  var nodes = [];
  fragment.forEach(function (i) {
    return nodes.push(i);
  });
  return nodes;
}
function removeLayoutFromFirstChild(node, i) {
  return i === 0 ? unwrapContentFromLayout(node) : node;
}
function removeLayoutFromLastChild(node, i, fragment) {
  return i === fragment.childCount - 1 ? unwrapContentFromLayout(node) : node;
}
var transformSingleColumnLayout = exports.transformSingleColumnLayout = function transformSingleColumnLayout(slice, schema) {
  if (slice.content.childCount === 1 && slice.openStart === 0 && slice.openEnd === 0) {
    var _slice$content$firstC, _slice$content$firstC2, _slice$content$firstC3;
    if (((_slice$content$firstC = slice.content.firstChild) === null || _slice$content$firstC === void 0 ? void 0 : _slice$content$firstC.type) === schema.nodes.layoutColumn) {
      var newSlice = new _model.Slice(slice.content.firstChild.content, 0, 0);
      return newSlice;
    } else if (((_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.type) === schema.nodes.layoutSection && slice.content.firstChild.childCount === 1 && ((_slice$content$firstC3 = slice.content.firstChild.firstChild) === null || _slice$content$firstC3 === void 0 ? void 0 : _slice$content$firstC3.type) === schema.nodes.layoutColumn) {
      var _newSlice = new _model.Slice(slice.content.firstChild.firstChild.content, 0, 0);
      return _newSlice;
    }
  }
  return slice;
};

/**
 * When we have a slice that cuts across a layoutSection/layoutColumn
 * we can end up with unexpected behaviour on paste/drop where a user
 * is able to add columns to a layoutSection. By 'lifting' any content
 * inside an 'open' layoutSection/layoutColumn to the top level, we
 * can ensure prevent this.
 *
 * We only care about slices with non-zero openStart / openEnd's here
 * as we're totally fine for people to copy/paste a full layoutSection
 */
function transformSliceToRemoveOpenLayoutNodes(slice, schema) {
  // Case 1: A slice entirely within a single layoutSection
  if (slice.openStart && slice.openEnd && slice.content.childCount === 1) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var maybeLayoutSection = slice.content.firstChild;
    if (maybeLayoutSection.type === schema.nodes.layoutSection) {
      return new _model.Slice((0, _slice.flatmap)(slice.content, removeLayoutFromFirstChild),
      // '-2' here because we've removed the layoutSection/layoutColumn; reducing the open depth.
      slice.openStart - 2, slice.openEnd - 2);
    }
  }

  // Case 2: A slice starting inside a layoutSection and finishing outside
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  if (slice.openStart && slice.content.firstChild.type === schema.nodes.layoutSection) {
    slice = new _model.Slice((0, _slice.flatmap)(slice.content, removeLayoutFromFirstChild), slice.openStart - 2, slice.openEnd);
  }

  // Case 3: A slice starting outside a layoutSection and finishing inside
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  if (slice.openEnd && slice.content.lastChild.type === schema.nodes.layoutSection) {
    slice = new _model.Slice((0, _slice.flatmap)(slice.content, removeLayoutFromLastChild), slice.openStart, slice.openEnd - 2);
  }

  // Case 2 & 3 also handles a slice starting in one layoutSection & finishing in a different layoutSection

  return slice;
}