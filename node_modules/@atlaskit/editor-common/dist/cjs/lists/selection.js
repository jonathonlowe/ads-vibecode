"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.numberNestedLists = exports.normalizeListItemsSelection = exports.getListItemAttributes = void 0;
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _utils2 = require("../utils");
var numberNestedLists = exports.numberNestedLists = function numberNestedLists(resolvedPos) {
  var count = 0;
  for (var i = resolvedPos.depth - 1; i > 0; i--) {
    var node = resolvedPos.node(i);
    if ((0, _utils2.isListNode)(node)) {
      count += 1;
    }
  }
  return count;
};
var getListItemAttributes = exports.getListItemAttributes = function getListItemAttributes($pos) {
  // Get level for the correct indent of nesting
  var indentLevel = numberNestedLists($pos) - 1;
  var itemAtPos = (0, _utils.findParentNodeClosestToPos)($pos, _utils2.isListItemNode);

  // Get the index of the current item relative to parent (parent is at item depth - 1)
  var itemIndex = $pos.index(itemAtPos ? itemAtPos.depth - 1 : undefined);
  return {
    indentLevel: indentLevel,
    itemIndex: itemIndex
  };
};
var normalizeListItemsSelection = exports.normalizeListItemsSelection = function normalizeListItemsSelection(_ref) {
  var selection = _ref.selection,
    doc = _ref.doc;
  if (selection.empty) {
    return selection;
  }
  var $from = selection.$from,
    $to = selection.$to;
  if (selection instanceof _state.NodeSelection) {
    var _head = resolvePositionToStartOfListItem($from);
    return new _state.TextSelection(_head, _head);
  }
  var head = resolvePositionToStartOfListItem($from);
  var anchor = resolvePositionToEndOfListItem($to);
  return new _state.TextSelection(anchor, head);
};
var resolvePositionToStartOfListItem = function resolvePositionToStartOfListItem($pos) {
  var fromRange = $pos.blockRange($pos, _utils2.isListItemNode);
  var fromPosition = fromRange && $pos.textOffset === 0 && fromRange.end - 1 === $pos.pos ? _state.Selection.near($pos.doc.resolve(fromRange.end + 1), 1).$from : $pos;
  return fromPosition;
};
var resolvePositionToEndOfListItem = function resolvePositionToEndOfListItem($pos) {
  var toRange = $pos.blockRange($pos, _utils2.isListItemNode);
  var toPosition = toRange && $pos.textOffset === 0 && toRange.start + 1 === $pos.pos ? _state.Selection.near($pos.doc.resolve(toRange.start - 1), -1).$to : $pos;
  return toPosition;
};