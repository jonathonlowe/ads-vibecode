"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnalyticsPayload = exports.copyToClipboard = exports.copyHTMLToClipboardPolyfill = exports.copyHTMLToClipboard = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var clipboard = _interopRequireWildcard(require("clipboard-polyfill"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _analytics = require("../analytics");
var _selection = require("../selection");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof3(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Ignored via go/ees005
// eslint-disable-next-line import/no-namespace

var isClipboardApiSupported = function isClipboardApiSupported() {
  return !!navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
};
var isIEClipboardApiSupported = function isIEClipboardApiSupported() {
  return (
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    window.clipboardData && typeof window.clipboardData.setData === 'function'
  );
};
var isExtensionNode = function isExtensionNode(node) {
  if (node === 'extension' || node === 'bodiedExtension' || node === 'inlineExtension' || node === 'multiBodiedExtension') {
    return true;
  }
  return false;
};
var copyToClipboard = exports.copyToClipboard = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(textToCopy) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!isClipboardApiSupported()) {
            _context.next = 11;
            break;
          }
          _context.prev = 1;
          _context.next = 4;
          return navigator.clipboard.writeText(textToCopy);
        case 4:
          _context.next = 9;
          break;
        case 6:
          _context.prev = 6;
          _context.t0 = _context["catch"](1);
          throw new Error('Clipboard api is not supported');
        case 9:
          _context.next = 23;
          break;
        case 11:
          if (!isIEClipboardApiSupported()) {
            _context.next = 22;
            break;
          }
          _context.prev = 12;
          _context.next = 15;
          return window.clipboardData.setData('text', textToCopy);
        case 15:
          _context.next = 20;
          break;
        case 17:
          _context.prev = 17;
          _context.t1 = _context["catch"](12);
          throw new Error('IE clipboard api is not supported');
        case 20:
          _context.next = 23;
          break;
        case 22:
          throw new Error('Clipboard api is not supported');
        case 23:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 6], [12, 17]]);
  }));
  return function copyToClipboard(_x) {
    return _ref.apply(this, arguments);
  };
}();
var copyHTMLToClipboard = exports.copyHTMLToClipboard = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(elementToCopy, plainTextToCopy) {
    var data;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(isClipboardApiSupported() && typeof ClipboardItem !== 'undefined')) {
            _context2.next = 12;
            break;
          }
          _context2.prev = 1;
          data = new ClipboardItem({
            'text/plain': new Blob([plainTextToCopy || elementToCopy.innerText], {
              type: 'text/plain'
            }),
            'text/html': new Blob([elementToCopy.innerHTML], {
              type: 'text/html'
            })
          }); // @ts-ignore
          _context2.next = 5;
          return navigator.clipboard.write([data]);
        case 5:
          _context2.next = 10;
          break;
        case 7:
          _context2.prev = 7;
          _context2.t0 = _context2["catch"](1);
          throw new Error('Clipboard api is not supported');
        case 10:
          _context2.next = 13;
          break;
        case 12:
          if (!!document && (typeof document === "undefined" ? "undefined" : (0, _typeof2.default)(document)) === 'object') {
            try {
              // ED-17083 extension copy seems have issue with ClipboardItem API
              // Hence of use of this polyfill
              copyHTMLToClipboardPolyfill(elementToCopy, plainTextToCopy);
            } catch (error) {
              // eslint-disable-next-line no-console
              console.log(error);
            }
          }
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[1, 7]]);
  }));
  return function copyHTMLToClipboard(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

// At the time of development, Firefox doesn't support ClipboardItem API
// Hence of use of this polyfill
var copyHTMLToClipboardPolyfill = exports.copyHTMLToClipboardPolyfill = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(elementToCopy, plainTextToCopy) {
    var dt;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          dt = new clipboard.ClipboardItem({
            'text/html': new Blob([elementToCopy.innerHTML], {
              type: 'text/html'
            }),
            'text/plain': new Blob([plainTextToCopy || elementToCopy.innerText], {
              type: 'text/plain'
            })
          });
          _context3.next = 3;
          return clipboard.write([dt]);
        case 3:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function copyHTMLToClipboardPolyfill(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();
var getAnalyticsPayload = exports.getAnalyticsPayload = function getAnalyticsPayload(state, action) {
  var selection = state.selection,
    doc = state.doc;
  var selectionAnalyticsPayload = (0, _selection.getNodeSelectionAnalyticsPayload)(selection) || (0, _selection.getRangeSelectionAnalyticsPayload)(selection, doc) || (0, _selection.getAllSelectionAnalyticsPayload)(selection) || (0, _selection.getCellSelectionAnalyticsPayload)(state);
  if (selectionAnalyticsPayload) {
    var _attributes;
    var selectionActionSubjectId = selectionAnalyticsPayload.actionSubjectId;
    var node = (_attributes = selectionAnalyticsPayload.attributes) === null || _attributes === void 0 ? void 0 : _attributes.node;
    var content = [];
    var extensionType;
    var extensionKey;
    switch (selectionActionSubjectId) {
      case _analytics.ACTION_SUBJECT_ID.NODE:
        if (node) {
          content.push(node);
          if (isExtensionNode(node)) {
            extensionType = selection.node.attrs.extensionType;
            extensionKey = selection.node.attrs.extensionKey;
          }
        }
        break;
      case _analytics.ACTION_SUBJECT_ID.RANGE:
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        content.push.apply(content, (0, _toConsumableArray2.default)(selectionAnalyticsPayload.attributes.nodes));
        break;
      case _analytics.ACTION_SUBJECT_ID.ALL:
        content.push('all');
        break;
      case _analytics.ACTION_SUBJECT_ID.CELL:
        {
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          var _ref4 = selectionAnalyticsPayload.attributes,
            selectedCells = _ref4.selectedCells;
          content.push.apply(content, (0, _toConsumableArray2.default)(Array(selectedCells).fill('tableCell')));
          break;
        }
    }
    if (isExtensionNode(node)) {
      return {
        eventType: _analytics.EVENT_TYPE.TRACK,
        action: action,
        actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
        attributes: {
          content: content,
          extensionKey: extensionKey,
          extensionType: extensionType
        }
      };
    }
    return {
      eventType: _analytics.EVENT_TYPE.TRACK,
      action: action,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      attributes: {
        content: content
      }
    };
  }
  if (selection instanceof _state.TextSelection && selection.$cursor) {
    return {
      eventType: _analytics.EVENT_TYPE.TRACK,
      action: action,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      attributes: {
        content: ['caret']
      }
    };
  }
};