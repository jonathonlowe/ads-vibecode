"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.atTheBeginningOfBlock = atTheBeginningOfBlock;
exports.atTheBeginningOfDoc = atTheBeginningOfDoc;
exports.atTheEndOfBlock = atTheEndOfBlock;
exports.atTheEndOfDoc = atTheEndOfDoc;
exports.endPositionOfParent = endPositionOfParent;
exports.isSelectionAtStartOfNode = exports.isSelectionAtEndOfNode = exports.expandSelectionBounds = void 0;
exports.startPositionOfParent = startPositionOfParent;
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _selection = require("./gap-cursor/selection");
var isSelectionAtStartOfNode = exports.isSelectionAtStartOfNode = function isSelectionAtStartOfNode($pos, parentNode) {
  if (!parentNode) {
    return false;
  }
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = $pos.node(i);
    if (node && node.eq(parentNode)) {
      break;
    }
    if (i > 1 && $pos.before(i) !== $pos.before(i - 1) + 1) {
      return false;
    }
  }
  return true;
};
var isSelectionAtEndOfNode = exports.isSelectionAtEndOfNode = function isSelectionAtEndOfNode($pos, parentNode) {
  if (!parentNode) {
    return false;
  }
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = $pos.node(i);
    if (node && node.eq(parentNode)) {
      break;
    }
    if (i > 1 && $pos.after(i) !== $pos.after(i - 1) - 1) {
      return false;
    }
  }
  return true;
};
function atTheEndOfDoc(state) {
  var selection = state.selection,
    doc = state.doc;
  return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;
}
function atTheBeginningOfDoc(state) {
  var selection = state.selection;
  return selection.$from.pos === selection.$from.depth;
}
function atTheEndOfBlock(state) {
  var selection = state.selection;
  var $to = selection.$to;
  if (selection instanceof _selection.GapCursorSelection) {
    return false;
  }
  if (selection instanceof _state.NodeSelection && selection.node.isBlock) {
    return true;
  }
  return endPositionOfParent($to) === $to.pos + 1;
}
function atTheBeginningOfBlock(state) {
  var selection = state.selection;
  var $from = selection.$from;
  if (selection instanceof _selection.GapCursorSelection) {
    return false;
  }
  if (selection instanceof _state.NodeSelection && selection.node.isBlock) {
    return true;
  }
  return startPositionOfParent($from) === $from.pos;
}
function startPositionOfParent(resolvedPos) {
  return resolvedPos.start(resolvedPos.depth);
}
function endPositionOfParent(resolvedPos) {
  return resolvedPos.end(resolvedPos.depth) + 1;
}

/**
 *
 * @param $anchor Resolved selection anchor position
 * @param $head Resolved selection head position
 * @returns An expanded selection encompassing surrounding nodes. Hoists up to the shared depth anchor/head depths differ.
 */
var expandSelectionBounds = exports.expandSelectionBounds = function expandSelectionBounds($anchor, $head) {
  var sharedDepth = $anchor.sharedDepth($head.pos) + 1;
  var $from = $anchor.min($head);
  var $to = $anchor.max($head);
  var fromDepth = $from.depth;
  var toDepth = $to.depth;
  var selectionStart;
  var selectionEnd;
  var selectionHasGrandparent = toDepth > 1 && fromDepth > 1;
  var selectionIsAcrossDiffParents = selectionHasGrandparent && !$to.parent.isTextblock && !$to.sameParent($from);
  var selectionIsAcrossTextBlocksWithDiffParents = selectionHasGrandparent && $to.parent.isTextblock && $to.before(toDepth - 1) !== $from.before(fromDepth - 1);
  if (toDepth > fromDepth) {
    if ((0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_multi_select_patch_1')) {
      selectionStart = $from.before(sharedDepth);
      selectionEnd = $to.after(sharedDepth);
    } else {
      selectionStart = fromDepth ? $from.before() : $from.pos;
      selectionEnd = fromDepth ? $to.after(fromDepth) : $to.after(1);
    }
  } else if (toDepth < fromDepth) {
    if ((0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_multi_select_patch_1')) {
      selectionStart = $from.before(sharedDepth);
      selectionEnd = $to.after(sharedDepth);
    } else {
      selectionStart = toDepth ? $from.before(toDepth) : $from.before(1);
      selectionEnd = toDepth ? $to.after() : $to.pos;
    }
  } else if (selectionIsAcrossDiffParents || selectionIsAcrossTextBlocksWithDiffParents) {
    // when selection from/to share same depth with different parents, hoist up the selection to the parent of the highest depth in the selection
    if ((0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_multi_select_patch_1')) {
      selectionStart = $from.before(sharedDepth);
      selectionEnd = $to.after(sharedDepth);
    } else {
      selectionStart = $from.before(fromDepth - 1);
      selectionEnd = $to.after(toDepth - 1);
    }
  } else if (!$from.node().inlineContent) {
    // when selection might be a Node selection, return what was passed in
    return {
      $anchor: $anchor,
      $head: $head
    };
  } else {
    selectionStart = fromDepth ? $from.before() : $from.pos;
    selectionEnd = toDepth ? $to.after() : $to.pos;
  }
  var $expandedFrom = $anchor.doc.resolve(selectionStart);
  var $expandedTo = $anchor.doc.resolve(selectionEnd);
  return {
    $anchor: $anchor === $from ? $expandedFrom : $expandedTo,
    $head: $head === $to ? $expandedTo : $expandedFrom
  };
};