"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "GapBookmark", {
  enumerable: true,
  get: function get() {
    return _selection.GapBookmark;
  }
});
Object.defineProperty(exports, "GapCursorSelection", {
  enumerable: true,
  get: function get() {
    return _selection.GapCursorSelection;
  }
});
Object.defineProperty(exports, "JSON_ID", {
  enumerable: true,
  get: function get() {
    return _selection.JSON_ID;
  }
});
Object.defineProperty(exports, "RelativeSelectionPos", {
  enumerable: true,
  get: function get() {
    return _types.RelativeSelectionPos;
  }
});
Object.defineProperty(exports, "Side", {
  enumerable: true,
  get: function get() {
    return _selection.Side;
  }
});
Object.defineProperty(exports, "atTheBeginningOfBlock", {
  enumerable: true,
  get: function get() {
    return _utils2.atTheBeginningOfBlock;
  }
});
Object.defineProperty(exports, "atTheBeginningOfDoc", {
  enumerable: true,
  get: function get() {
    return _utils2.atTheBeginningOfDoc;
  }
});
Object.defineProperty(exports, "atTheEndOfBlock", {
  enumerable: true,
  get: function get() {
    return _utils2.atTheEndOfBlock;
  }
});
Object.defineProperty(exports, "atTheEndOfDoc", {
  enumerable: true,
  get: function get() {
    return _utils2.atTheEndOfDoc;
  }
});
exports.createSelectionClickHandler = createSelectionClickHandler;
Object.defineProperty(exports, "endPositionOfParent", {
  enumerable: true,
  get: function get() {
    return _utils2.endPositionOfParent;
  }
});
Object.defineProperty(exports, "expandSelectionBounds", {
  enumerable: true,
  get: function get() {
    return _utils2.expandSelectionBounds;
  }
});
Object.defineProperty(exports, "gapCursorStyles", {
  enumerable: true,
  get: function get() {
    return _styles.gapCursorStyles;
  }
});
exports.getAllSelectionAnalyticsPayload = getAllSelectionAnalyticsPayload;
exports.getCellSelectionAnalyticsPayload = getCellSelectionAnalyticsPayload;
exports.getNodeSelectionAnalyticsPayload = getNodeSelectionAnalyticsPayload;
exports.getRangeSelectionAnalyticsPayload = getRangeSelectionAnalyticsPayload;
Object.defineProperty(exports, "hideCaretModifier", {
  enumerable: true,
  get: function get() {
    return _styles.hideCaretModifier;
  }
});
Object.defineProperty(exports, "isIgnored", {
  enumerable: true,
  get: function get() {
    return _isIgnored.isIgnored;
  }
});
Object.defineProperty(exports, "isSelectionAtEndOfNode", {
  enumerable: true,
  get: function get() {
    return _utils2.isSelectionAtEndOfNode;
  }
});
Object.defineProperty(exports, "isSelectionAtStartOfNode", {
  enumerable: true,
  get: function get() {
    return _utils2.isSelectionAtStartOfNode;
  }
});
Object.defineProperty(exports, "isValidTargetNode", {
  enumerable: true,
  get: function get() {
    return _isValidTargetNode.isValidTargetNode;
  }
});
exports.selectNode = void 0;
Object.defineProperty(exports, "setGapCursorAtPos", {
  enumerable: true,
  get: function get() {
    return _actions.setGapCursorAtPos;
  }
});
Object.defineProperty(exports, "setGapCursorSelection", {
  enumerable: true,
  get: function get() {
    return _setGapCursorSelection.setGapCursorSelection;
  }
});
Object.defineProperty(exports, "setSelectionTopLevelBlocks", {
  enumerable: true,
  get: function get() {
    return _actions.setSelectionTopLevelBlocks;
  }
});
Object.defineProperty(exports, "startPositionOfParent", {
  enumerable: true,
  get: function get() {
    return _utils2.startPositionOfParent;
  }
});
var _state = require("@atlaskit/editor-prosemirror/state");
var _editorTables = require("@atlaskit/editor-tables");
var _utils = require("@atlaskit/editor-tables/utils");
var _analytics = require("../analytics");
var _types = require("./types");
var _selection = require("./gap-cursor/selection");
var _actions = require("./gap-cursor/actions");
var _isIgnored = require("./gap-cursor/utils/is-ignored");
var _isValidTargetNode = require("./gap-cursor/utils/is-valid-target-node");
var _setGapCursorSelection = require("./gap-cursor/utils/setGapCursorSelection");
var _styles = require("./gap-cursor/styles");
var _utils2 = require("./utils");
// Disable no-re-export rule for entry point files
/* eslint-disable @atlaskit/editor/no-re-export */

function getNodeSelectionAnalyticsPayload(selection) {
  if (selection instanceof _state.NodeSelection) {
    return {
      action: _analytics.ACTION.SELECTED,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.NODE,
      eventType: _analytics.EVENT_TYPE.TRACK,
      attributes: {
        node: selection.node.type.name
      }
    };
  }
}
function getAllSelectionAnalyticsPayload(selection) {
  if (selection instanceof _state.AllSelection) {
    return {
      action: _analytics.ACTION.SELECTED,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.ALL,
      eventType: _analytics.EVENT_TYPE.TRACK
    };
  }
}
function getCellSelectionAnalyticsPayload(state) {
  if (state.selection instanceof _editorTables.CellSelection) {
    var rect = (0, _utils.selectedRect)(state);
    var selectedCells = rect.map.cellsInRect(rect).length;
    var totalCells = rect.map.map.length;
    return {
      action: _analytics.ACTION.SELECTED,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.CELL,
      eventType: _analytics.EVENT_TYPE.TRACK,
      attributes: {
        selectedCells: selectedCells,
        totalCells: totalCells
      }
    };
  }
}
function getRangeSelectionAnalyticsPayload(selection, doc) {
  if (selection instanceof _state.TextSelection && selection.from !== selection.to) {
    var from = selection.from,
      to = selection.to,
      anchor = selection.anchor,
      head = selection.head;
    var nodes = [];
    doc.nodesBetween(from, to, function (node, pos) {
      // We want to send top-level nodes only, ie.the nodes that would have the selection styling
      // We allow text nodes that are not fully covered as they are a special case
      if (node.isText || pos >= from && pos + node.nodeSize <= to) {
        nodes.push(node.type.name);
        return false;
      }
    });
    return {
      action: _analytics.ACTION.SELECTED,
      actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.RANGE,
      eventType: _analytics.EVENT_TYPE.TRACK,
      attributes: {
        from: anchor,
        to: head,
        nodes: nodes
      }
    };
  }
}

/**
 * Insert content, delete a range and create a new selection
 * This function automatically handles the mapping of positions for insertion and deletion.
 * The new selection is handled as a function since it may not always be necessary to resolve a position to the transactions mapping
 *
 * @param getSelectionResolvedPos get the resolved position to create a new selection
 * @param insertions content to insert at the specified position
 * @param deletions the ranges to delete
 */

var selectNode = exports.selectNode = function selectNode(pos) {
  return function (state, dispatch) {
    if (dispatch) {
      dispatch(state.tr.setSelection(new _state.NodeSelection(state.doc.resolve(pos))));
    }
    return true;
  };
};
function createSelectionClickHandler(nodes, isValidTarget, options) {
  return function handleClickOn(view, pos, node, nodePos, event, direct) {
    if (options.useLongPressSelection) {
      return false;
    }
    if (direct && nodes.indexOf(node.type.name) !== -1) {
      var target = event.target;
      if (target instanceof HTMLElement && isValidTarget(target)) {
        var selectionPos = options.getNodeSelectionPos ? options.getNodeSelectionPos(view.state, nodePos) : nodePos;
        selectNode(selectionPos)(view.state, view.dispatch);
        return true;
      }
    }
    return false;
  };
}