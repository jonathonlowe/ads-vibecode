"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FORGE_EXTENSION_TYPE = void 0;
exports.buildAction = buildAction;
exports.buildExtensionKeyAndNodeKey = void 0;
exports.buildNode = buildNode;
exports.resolveImport = exports.getExtensionKeyAndNodeKey = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var FORGE_EXTENSION_TYPE = exports.FORGE_EXTENSION_TYPE = 'com.atlassian.ecosystem';
var getExtensionKeyAndNodeKey = exports.getExtensionKeyAndNodeKey = function getExtensionKeyAndNodeKey(extensionKey, extensionType) {
  // Forge macro extensionKey has a user generated string, so splitting on
  // a colon is unstable for their particular use case. They only have one
  // node in the relevant manifest so we can hardcode nodeKey to 'default'.
  if (extensionType === FORGE_EXTENSION_TYPE) {
    return [extensionKey, 'default'];
  }
  var _extensionKey$split = extensionKey.split(':'),
    _extensionKey$split2 = (0, _slicedToArray2.default)(_extensionKey$split, 2),
    extKey = _extensionKey$split2[0],
    _extensionKey$split2$ = _extensionKey$split2[1],
    nodeKey = _extensionKey$split2$ === void 0 ? 'default' : _extensionKey$split2$;
  return [extKey, nodeKey];
};
var buildExtensionKeyAndNodeKey = exports.buildExtensionKeyAndNodeKey = function buildExtensionKeyAndNodeKey(extensionKey, nodeKey) {
  if (!nodeKey || nodeKey === 'default') {
    return extensionKey;
  }
  return "".concat(extensionKey, ":").concat(nodeKey);
};
function buildAction(action, manifest) {
  if (typeof action === 'function') {
    return action;
  }
  if (action.type === 'node' && manifest.modules.nodes) {
    return buildNode(action, manifest);
  }
}
var resolveImport = exports.resolveImport = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(importPromise) {
    var importedModule;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return importPromise;
        case 2:
          importedModule = _context.sent;
          return _context.abrupt("return", importedModule && importedModule.__esModule ? importedModule.default : importedModule);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveImport(_x) {
    return _ref.apply(this, arguments);
  };
}();
function buildNode(action, manifest) {
  if (!manifest.modules.nodes) {
    return;
  }
  var node = manifest.modules.nodes[action.key];
  var extensionKey = buildExtensionKeyAndNodeKey(manifest.key, action.key);
  var extension = {
    type: node.type,
    attrs: {
      extensionType: manifest.type,
      extensionKey: extensionKey,
      parameters: action.parameters
    }
  };
  if (node.type === 'bodiedExtension') {
    return _objectSpread(_objectSpread({}, extension), {}, {
      content: [{
        type: 'paragraph',
        content: []
      }]
    });
  } else if (node.type === 'multiBodiedExtension') {
    return _objectSpread(_objectSpread({}, extension), {}, {
      content: [{
        type: 'extensionFrame',
        content: [{
          type: 'paragraph',
          content: []
        }]
      }]
    });
  }
  return extension;
}