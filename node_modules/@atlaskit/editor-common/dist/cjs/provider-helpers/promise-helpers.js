"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForFirstFulfilledPromise = exports.waitForAllPromises = exports.getOnlyFulfilled = exports.ResultStatus = void 0;
var ResultStatus = exports.ResultStatus = /*#__PURE__*/function (ResultStatus) {
  ResultStatus["FULFILLED"] = "fulfilled";
  ResultStatus["FAILED"] = "failed";
  return ResultStatus;
}({});
var isFullfilled = function isFullfilled(result) {
  return result.status === ResultStatus.FULFILLED;
};
var markFullfilled = function markFullfilled(value) {
  return {
    status: ResultStatus.FULFILLED,
    value: value
  };
};

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var markRejected = function markRejected(error) {
  return {
    status: ResultStatus.FAILED,
    reason: error
  };
};

/**
 * Will wait for all promises to resolve or reject, wrapping their real results in
 * object containing the status so it's easy to filter it later. Loosely inspired by
 * [Promise.allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)
 * which can replace this implementation once it makes to the browsers.
 * @param promises
 */
var waitForAllPromises = exports.waitForAllPromises = function waitForAllPromises(promises) {
  return Promise.all(promises.map(function (result) {
    return result.then(markFullfilled).catch(markRejected);
  }));
};

/**
 * Will resolve on the first fulfilled promise and disregard the remaining ones. Similar to `Promise.race` but won't
 * care about rejected promises.
 * @param promises
 */
var waitForFirstFulfilledPromise = exports.waitForFirstFulfilledPromise = function waitForFirstFulfilledPromise(promises) {
  var rejectReasons = [];
  return new Promise(function (resolve, reject) {
    promises.forEach(function (promise) {
      return promise.then(function (value) {
        if (typeof value === 'undefined' || value === null) {
          throw new Error("Result was not found but the method didn't reject/throw. Please ensure that it doesn't return null or undefined.");
        }
        resolve(value);
      }).catch(function (reason) {
        rejectReasons.push(reason);
        if (rejectReasons.length === promises.length) {
          reject(reason);
        }
      });
    });
  });
};

/**
 * Find all fullfilled promises and return their values
 * @param results
 */
var getOnlyFulfilled = exports.getOnlyFulfilled = function getOnlyFulfilled(results) {
  return results.filter(isFullfilled).map(function (result) {
    return result.value;
  });
};