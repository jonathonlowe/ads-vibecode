"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _promiseHelpers = require("./promise-helpers");
var flatten = function flatten(arr) {
  var _ref;
  return (_ref = []).concat.apply(_ref, (0, _toConsumableArray2.default)(arr));
};

/**
 * Allow to run methods from the given provider interface across all providers seamlessly.
 * Handles promise racing and discards rejected promises safely.
 */
var _default = exports.default = function _default(providers) {
  if (providers.length === 0) {
    throw new Error('At least one provider must be provided');
  }
  var getFulfilledProviders = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var results;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _promiseHelpers.waitForAllPromises)(providers.map(function (result) {
              return Promise.resolve(result);
            }));
          case 2:
            results = _context.sent;
            return _context.abrupt("return", (0, _promiseHelpers.getOnlyFulfilled)(results));
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getFulfilledProviders() {
      return _ref2.apply(this, arguments);
    };
  }();
  var runInAllProviders = /*#__PURE__*/function () {
    var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(mapFunction) {
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getFulfilledProviders();
          case 2:
            return _context2.abrupt("return", _context2.sent.map(function (provider) {
              return mapFunction(provider);
            }));
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function runInAllProviders(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var createCallback = function createCallback(methodName, args) {
    return function (provider) {
      var method = provider[methodName];
      if (typeof method === 'function') {
        return method.apply(provider, args);
      }
      throw new Error("\"".concat(String(methodName), "\" isn't a function of the provider"));
    };
  };

  /**
   * Run a method from the provider which expects to return a single item
   * @param methodName
   * @param args
   */
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var invokeSingle = /*#__PURE__*/function () {
    var _ref4 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(methodName, args) {
      var callback;
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            callback = createCallback(methodName, args);
            _context3.t0 = _promiseHelpers.waitForFirstFulfilledPromise;
            _context3.next = 4;
            return runInAllProviders(callback);
          case 4:
            _context3.t1 = _context3.sent;
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function invokeSingle(_x2, _x3) {
      return _ref4.apply(this, arguments);
    };
  }();

  /**
   * Run a method in the provider which expectes to return a list of items
   * @param methodName
   * @param args
   */
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var invokeList = /*#__PURE__*/function () {
    var _ref5 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(methodName, args) {
      var callback, results, fulfilledResults;
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            callback = createCallback(methodName, args);
            _context4.t0 = _promiseHelpers.waitForAllPromises;
            _context4.next = 4;
            return runInAllProviders(callback);
          case 4:
            _context4.t1 = _context4.sent;
            _context4.next = 7;
            return (0, _context4.t0)(_context4.t1);
          case 7:
            results = _context4.sent;
            fulfilledResults = (0, _promiseHelpers.getOnlyFulfilled)(results);
            return _context4.abrupt("return", flatten(fulfilledResults).filter(function (result) {
              return result;
            }));
          case 10:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function invokeList(_x4, _x5) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    invokeSingle: invokeSingle,
    invokeList: invokeList
  };
};