"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackUnsupportedContentTooltipDisplayedFor = exports.fireUnsupportedEvent = exports.findAndTrackUnsupportedContentNodes = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _analytics = require("../analytics");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var whitelistedAttributes = ['align', 'annotationType', 'extensionKey', 'extensionType', 'layout', 'type', 'localId', 'mode', 'language', 'timestamp', 'state', 'originalWidth', 'originalHeight', 'height', 'width', 'shortName', 'level', 'userType', 'order', 'panelType', 'color', 'style', 'isNumberColumnEnabled', 'colspan', 'rowspan', 'colwidth', 'background'];
function concatAncestorHierarchy(node, ancestoryHierarchy) {
  var name = node.type.name;
  // Space concatenator used to reduce analytics payload size
  return ancestoryHierarchy ? "".concat(ancestoryHierarchy, " ").concat(name) : name;
}

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var sanitizeMarks = function sanitizeMarks() {
  var marks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var sanitizedMarks = [];
  marks.forEach(function (mark) {
    if (mark.attrs) {
      var attrs = sanitizeAttributes(mark.attrs);
      sanitizedMarks.push(_objectSpread(_objectSpread({}, mark), {}, {
        attrs: attrs
      }));
    } else {
      sanitizedMarks.push(_objectSpread({}, mark));
    }
  });
  return sanitizedMarks;
};
var sanitizeAttributes = function sanitizeAttributes() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var sanitizedAttrs = Object.assign({}, attrs);
  Object.keys(attrs).filter(function (key) {
    return !whitelistedAttributes.includes(key);
  }).forEach(function (key) {
    sanitizedAttrs[key] !== null ? sanitizedAttrs[key] = '' : sanitizedAttrs[key] = 'null';
  });
  return sanitizedAttrs;
};
var trackUnsupportedContentTooltipActionFor = function trackUnsupportedContentTooltipActionFor(action, dispatchAnalyticsEvent, unsupportedContentType, originalNodeType) {
  dispatchAnalyticsEvent({
    action: action,
    actionSubjectId: unsupportedContentType,
    actionSubject: _analytics.ACTION_SUBJECT.TOOLTIP,
    eventType: _analytics.EVENT_TYPE.UI,
    attributes: {
      unsupportedNodeType: originalNodeType
    }
  });
};
var _findAndTrackUnsupportedContentNodes = exports.findAndTrackUnsupportedContentNodes = function findAndTrackUnsupportedContentNodes(node, schema, dispatchAnalyticsEvent) {
  var ancestorHierarchy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var nodeType = node.type,
    nodeMarks = node.marks;
  var _schema$marks = schema.marks,
    unsupportedMark = _schema$marks.unsupportedMark,
    unsupportedNodeAttribute = _schema$marks.unsupportedNodeAttribute;
  var _schema$nodes = schema.nodes,
    unsupportedInline = _schema$nodes.unsupportedInline,
    unsupportedBlock = _schema$nodes.unsupportedBlock;
  var parentType = ancestorHierarchy.split(' ').pop() || '';
  if (nodeMarks.length) {
    nodeMarks.forEach(function (mark) {
      if (mark.type === unsupportedMark) {
        var _ref = mark.attrs || {},
          originalValue = _ref.originalValue;
        var _ref2 = originalValue || {},
          type = _ref2.type;
        var unsupportedNode = {
          type: type || '',
          ancestry: ancestorHierarchy,
          parentType: parentType,
          marks: [],
          attrs: originalValue.attrs || {}
        };
        fireUnsupportedEvent(dispatchAnalyticsEvent, _analytics.ACTION_SUBJECT_ID.UNSUPPORTED_MARK, unsupportedNode);
      } else if (mark.type === unsupportedNodeAttribute) {
        var _ref3 = mark.attrs || {},
          unsupported = _ref3.unsupported;
        var _unsupportedNodeAttribute = {
          type: nodeType.name || '',
          ancestry: ancestorHierarchy,
          parentType: parentType,
          marks: [],
          attrs: unsupported || {}
        };
        fireUnsupportedEvent(dispatchAnalyticsEvent, _analytics.ACTION_SUBJECT_ID.UNSUPPORTED_NODE_ATTRIBUTE, _unsupportedNodeAttribute);
      }
    });
  }
  if (nodeType === unsupportedInline || nodeType === unsupportedBlock) {
    var _ref4 = node.attrs || {},
      originalValue = _ref4.originalValue;
    var _ref5 = originalValue || [],
      marks = _ref5.marks;
    var _ref6 = originalValue || {},
      attrs = _ref6.attrs;
    var _ref7 = originalValue || {},
      type = _ref7.type;
    var unsupportedNode = {
      type: type || '',
      ancestry: ancestorHierarchy,
      parentType: parentType,
      marks: marks || [],
      attrs: attrs || {}
    };
    var actionSubjectId = nodeType === unsupportedInline ? _analytics.ACTION_SUBJECT_ID.UNSUPPORTED_INLINE : _analytics.ACTION_SUBJECT_ID.UNSUPPORTED_BLOCK;
    fireUnsupportedEvent(dispatchAnalyticsEvent, actionSubjectId, unsupportedNode);
  } else {
    // Recursive check for nested content
    node.content.forEach(function (childNode) {
      return _findAndTrackUnsupportedContentNodes(childNode, schema, dispatchAnalyticsEvent, concatAncestorHierarchy(node, ancestorHierarchy));
    });
  }
};
var fireUnsupportedEvent = exports.fireUnsupportedEvent = function fireUnsupportedEvent(dispatchAnalyticsEvent, actionSubjectId, unsupportedNode, errorCode) {
  var sanitizedAttrs = sanitizeAttributes(unsupportedNode.attrs);
  var sanitizedMarks = sanitizeMarks(unsupportedNode.marks);
  var sanitizedUnsupportedNode = {
    type: unsupportedNode.type,
    ancestry: unsupportedNode.ancestry,
    parentType: unsupportedNode.parentType,
    attrs: sanitizedAttrs,
    marks: sanitizedMarks
  };
  var payload = {
    action: _analytics.ACTION.UNSUPPORTED_CONTENT_ENCOUNTERED,
    actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: actionSubjectId,
    attributes: _objectSpread({
      unsupportedNode: sanitizedUnsupportedNode
    }, !!errorCode && {
      errorCode: errorCode
    }),
    eventType: _analytics.EVENT_TYPE.TRACK
  };
  dispatchAnalyticsEvent(payload);
};
var trackUnsupportedContentTooltipDisplayedFor = exports.trackUnsupportedContentTooltipDisplayedFor = function trackUnsupportedContentTooltipDisplayedFor(dispatchAnalyticsEvent, unsupportedContentType, originalNodeType) {
  trackUnsupportedContentTooltipActionFor(_analytics.ACTION.UNSUPPORTED_TOOLTIP_VIEWED, dispatchAnalyticsEvent, unsupportedContentType, originalNodeType);
};