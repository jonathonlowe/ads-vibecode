"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractSliceFromStep = void 0;
exports.filterChildrenBetween = filterChildrenBetween;
exports.isElementInTableCell = void 0;
exports.isEmptyParagraph = isEmptyParagraph;
exports.isValidPosition = exports.isTextSelection = exports.isLastItemMediaGroup = exports.isInLayoutColumn = void 0;
exports.nonNullable = nonNullable;
exports.removeBlockMarks = void 0;
exports.setAllSelection = setAllSelection;
exports.setCellSelection = setCellSelection;
exports.setNodeSelection = void 0;
exports.setTextSelection = setTextSelection;
exports.stepAddsOneOf = stepAddsOneOf;
exports.stepHasSlice = void 0;
var _state = require("@atlaskit/editor-prosemirror/state");
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _cellSelection = require("@atlaskit/editor-tables/cell-selection");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _dom = require("./dom");
/**
 * Checks if node is an empty paragraph.
 */
function isEmptyParagraph(node) {
  return !!node && node.type.name === 'paragraph' && !node.childCount;
}
var stepHasSlice = exports.stepHasSlice = function stepHasSlice(step) {
  return step && step.hasOwnProperty('slice');
};

/**
 * Checks whether a given step is adding nodes of given nodeTypes
 *
 * @param step Step to check
 * @param nodeTypes NodeTypes being added
 */
function stepAddsOneOf(step, nodeTypes) {
  var adds = false;
  if (!stepHasSlice(step)) {
    return adds;
  }
  step.slice.content.descendants(function (node) {
    if (nodeTypes.has(node.type)) {
      adds = true;
    }
    return !adds;
  });
  return adds;
}
var extractSliceFromStep = exports.extractSliceFromStep = function extractSliceFromStep(step) {
  if (!(step instanceof _transform.ReplaceStep) && !(step instanceof _transform.ReplaceAroundStep)) {
    return null;
  }

  // @ts-ignore This is by design. Slice is a private property, but accesible, from ReplaceStep.
  // However, we need to read it to found if the step was adding a newline
  var slice = step.slice;
  return slice;
};
var isTextSelection = exports.isTextSelection = function isTextSelection(selection) {
  return selection instanceof _state.TextSelection;
};
var isElementInTableCell = exports.isElementInTableCell = function isElementInTableCell(element) {
  if ((0, _platformFeatureFlags.fg)('platform_editor_nested_tables_column_drag_fix')) {
    return (0, _dom.closest)(element, 'td, th');
  } else {
    return (0, _dom.closest)(element, 'td') || (0, _dom.closest)(element, 'th');
  }
};
var isLastItemMediaGroup = exports.isLastItemMediaGroup = function isLastItemMediaGroup(node) {
  var content = node.content;
  return !!content.lastChild && content.lastChild.type.name === 'mediaGroup';
};
var setNodeSelection = exports.setNodeSelection = function setNodeSelection(view, pos) {
  var state = view.state,
    dispatch = view.dispatch;
  if (!isFinite(pos)) {
    return;
  }
  var tr = state.tr.setSelection(_state.NodeSelection.create(state.doc, pos));
  dispatch(tr);
};
function setTextSelection(view, anchor, head) {
  var state = view.state,
    dispatch = view.dispatch;
  var tr = state.tr.setSelection(_state.TextSelection.create(state.doc, anchor, head));
  dispatch(tr);
}
function setAllSelection(view) {
  var state = view.state,
    dispatch = view.dispatch;
  var tr = state.tr.setSelection(new _state.AllSelection(view.state.doc));
  dispatch(tr);
}
function setCellSelection(view, anchor, head) {
  var state = view.state,
    dispatch = view.dispatch;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  dispatch(state.tr.setSelection(_cellSelection.CellSelection.create(state.doc, anchor, head)));
}
function nonNullable(value) {
  return value !== null && value !== undefined;
}

// checks if the given position is within the ProseMirror document
var isValidPosition = exports.isValidPosition = function isValidPosition(pos, state) {
  if (typeof pos !== 'number') {
    return false;
  }
  if (pos >= 0 && pos <= state.doc.resolve(0).end()) {
    return true;
  }
  return false;
};
var isInLayoutColumn = exports.isInLayoutColumn = function isInLayoutColumn(state) {
  return (0, _utils.hasParentNodeOfType)(state.schema.nodes.layoutSection)(state.selection);
};
function filterChildrenBetween(doc, from, to, predicate) {
  var results = [];
  doc.nodesBetween(from, to, function (node, pos, parent) {
    if (predicate(node, pos, parent)) {
      results.push({
        node: node,
        pos: pos
      });
    }
  });
  return results;
}
var removeBlockMarks = exports.removeBlockMarks = function removeBlockMarks(state, marks) {
  var selection = state.selection,
    schema = state.schema;
  var tr = state.tr;

  // Marks might not exist in Schema
  var marksToRemove = marks.filter(Boolean);
  if (marksToRemove.length === 0) {
    return undefined;
  }

  /** Saves an extra dispatch */
  var blockMarksExists = false;
  var hasMark = function hasMark(mark) {
    return marksToRemove.indexOf(mark.type) > -1;
  };
  /**
   * When you need to toggle the selection
   * when another type which does not allow alignment is applied
   */
  state.doc.nodesBetween(selection.from, selection.to, function (node, pos) {
    if (node.type === schema.nodes.paragraph && node.marks.some(hasMark)) {
      blockMarksExists = true;
      var resolvedPos = state.doc.resolve(pos);
      var withoutBlockMarks = node.marks.filter(not(hasMark));
      tr = tr.setNodeMarkup(resolvedPos.pos, undefined, node.attrs, withoutBlockMarks);
    }
  });
  return blockMarksExists ? tr : undefined;
};
var not = function not(fn) {
  return function (arg) {
    return !fn(arg);
  };
};