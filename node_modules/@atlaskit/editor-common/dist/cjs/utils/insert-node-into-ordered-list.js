"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformNodeIntoListItem = transformNodeIntoListItem;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _list = require("./list");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// Taken from `editor-plugin-content-insertion`
function setSelectionToValidTextNode(tr, node, from) {
  var sliceInserted = _model.Slice.maxOpen(_model.Fragment.from(node));
  var openPosition = Math.min(from + (node.isAtom ? node.nodeSize : sliceInserted.openStart), tr.doc.content.size);
  var FORWARD_DIRECTION = 1;
  var nextSelection = _state.TextSelection.findFrom(tr.doc.resolve(openPosition), FORWARD_DIRECTION, true);
  if (nextSelection) {
    return tr.setSelection(nextSelection);
  }
}
function transformNodeIntoListItem(tr, node) {
  var _tr$doc$nodeAt;
  var _tr$selection = tr.selection,
    $to = _tr$selection.$to,
    $from = _tr$selection.$from,
    to = _tr$selection.to,
    from = _tr$selection.from;
  var _tr$doc$type$schema$n = tr.doc.type.schema.nodes,
    orderedList = _tr$doc$type$schema$n.orderedList,
    bulletList = _tr$doc$type$schema$n.bulletList,
    listItem = _tr$doc$type$schema$n.listItem;
  var startLinePosition = $from.start();
  var parentStartPosition = $from.depth === 0 ? 0 : $from.before();

  // Setting the start position
  var startMapped = startLinePosition === from ? parentStartPosition : from;

  // Selected nodes
  var selectionParentListItemNode = (0, _utils.findParentNodeOfType)(listItem)(tr.selection);
  var selectionParentListNodeWithPos = (0, _utils.findParentNodeOfType)([bulletList, orderedList])(tr.selection);
  var selectionParentListNode = selectionParentListNodeWithPos === null || selectionParentListNodeWithPos === void 0 ? void 0 : selectionParentListNodeWithPos.node;
  if (!selectionParentListNodeWithPos) {
    return tr;
  }

  // Offsets
  var listWrappingOffset = $to.depth - selectionParentListNodeWithPos.depth + 1; // difference in depth between to position and list node
  var listItemWrappingOffset = $to.depth - selectionParentListNodeWithPos.depth; // difference in depth between to position and list item node

  // Anything to do with nested lists should safeInsert and not be handled here
  var grandParentListNode = (0, _utils.findParentNodeOfTypeClosestToPos)(tr.doc.resolve(selectionParentListNodeWithPos.pos), [bulletList, orderedList]);
  var selectionIsInNestedList = !!grandParentListNode;
  var selectedListItemHasNestedList = false;
  selectionParentListItemNode === null || selectionParentListItemNode === void 0 || selectionParentListItemNode.node.content.forEach(function (child) {
    if ((0, _list.isListNode)(child)) {
      selectedListItemHasNestedList = true;
    }
  });
  if (selectedListItemHasNestedList || selectionIsInNestedList) {
    return (0, _utils.safeInsert)(node)(tr).scrollIntoView();
  }

  // Check if node after the insert position is listItem
  var isNodeAfterInsertPositionIsListItem = ((_tr$doc$nodeAt = tr.doc.nodeAt(to + listItemWrappingOffset)) === null || _tr$doc$nodeAt === void 0 ? void 0 : _tr$doc$nodeAt.type) === listItem;
  var replaceTo;
  if (isNodeAfterInsertPositionIsListItem) {
    replaceTo = to + listItemWrappingOffset;
  } else if (!isNodeAfterInsertPositionIsListItem) {
    replaceTo = to;
  } else {
    replaceTo = to + listWrappingOffset;
  }

  // handle the insertion of the slice
  tr.replaceWith(startMapped, replaceTo, node).scrollIntoView();

  // Get the next list items position (used later to find the split out ordered list)
  var indexOfNextListItem = $to.indexAfter($to.depth - listItemWrappingOffset);
  var positionOfNextListItem = tr.doc.resolve(selectionParentListNodeWithPos.pos + 1).posAtIndex(indexOfNextListItem);

  // Place the selection at the replaced location
  setSelectionToValidTextNode(tr, node, from);

  // Find the ordered list node after the pasted content so we can set it's order
  var mappedPositionOfNextListItem = tr.mapping.map(positionOfNextListItem);
  if (mappedPositionOfNextListItem > tr.doc.nodeSize) {
    return tr;
  }
  var nodeAfterPastedContentResolvedPos = (0, _utils.findParentNodeOfTypeClosestToPos)(tr.doc.resolve(mappedPositionOfNextListItem), [orderedList]);

  // Work out the new split out lists 'order' (the number it starts from)
  var originalParentOrderedListNodeOrder = selectionParentListNode === null || selectionParentListNode === void 0 ? void 0 : selectionParentListNode.attrs.order;
  var nodeOfOriginalList = (0, _utils.findParentNodeOfTypeClosestToPos)(tr.doc.resolve(from - 1), [orderedList]);
  var numOfListItemsInOriginalList = nodeOfOriginalList === null || nodeOfOriginalList === void 0 ? void 0 : nodeOfOriginalList.node.childCount;

  // Set the new split out lists order attribute
  if (typeof originalParentOrderedListNodeOrder === 'number' && numOfListItemsInOriginalList && nodeAfterPastedContentResolvedPos &&
  // We only want to apply the node markup if we're referring to the split
  // list rather than the original
  (nodeOfOriginalList === null || nodeOfOriginalList === void 0 ? void 0 : nodeOfOriginalList.node) !== (nodeAfterPastedContentResolvedPos === null || nodeAfterPastedContentResolvedPos === void 0 ? void 0 : nodeAfterPastedContentResolvedPos.node)) {
    tr.setNodeMarkup(nodeAfterPastedContentResolvedPos.pos, orderedList, _objectSpread(_objectSpread({}, nodeAfterPastedContentResolvedPos.node.attrs), {}, {
      order: originalParentOrderedListNodeOrder + numOfListItemsInOriginalList
    }));
  }
  return tr;
}