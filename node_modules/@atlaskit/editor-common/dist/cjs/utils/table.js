"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcTableColumnWidths = calcTableColumnWidths;
exports.convertProsemirrorTableNodeToArrayOfRows = convertProsemirrorTableNodeToArrayOfRows;
exports.getColumnWidths = getColumnWidths;
exports.hasMergedCell = hasMergedCell;
exports.isPositionNearTableRow = isPositionNearTableRow;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
/**
 * Looks at every table row to find the correct number of columns for table, which
 * accounts for tables with uneven rows.
 *
 * Returns an array of column widths if defined otherwise 0, positions respect table order.
 */
function getColumnWidths(node) {
  var tableColumnWidths = [];
  node.forEach(function (row) {
    var currentTableWidth = [];
    row.forEach(function (cell) {
      var _ref = cell.attrs,
        colspan = _ref.colspan,
        colwidth = _ref.colwidth;
      // column has been resized, colWidth will be an array, can safely take values even if cell is merged
      if (Array.isArray(colwidth)) {
        currentTableWidth.push.apply(currentTableWidth, (0, _toConsumableArray2.default)(colwidth));
        // table has merged cells but no colWidth, so columns haven't been resized, default to 0
      } else if (colspan !== undefined && colspan > 1) {
        currentTableWidth.push.apply(currentTableWidth, (0, _toConsumableArray2.default)(Array(colspan).fill(0)));
        // no merged cells, no column resized, default to 0
      } else {
        currentTableWidth.push(0);
      }
    });
    if (currentTableWidth.length > tableColumnWidths.length) {
      tableColumnWidths = currentTableWidth;
    }
  });
  return tableColumnWidths;
}
function calcTableColumnWidths(node) {
  // Ignored via go/ees007
  // eslint-disable-next-line @atlaskit/editor/enforce-todo-comment-format
  // TODO: replaced with getColumnWidths, which correctly scans entire table for column widths
  if ((0, _platformFeatureFlags.fg)('platform_editor_table_row_span_fix')) {
    var _firstRow = node.firstChild;
    var _tableColumnWidths = [];
    if (_firstRow) {
      _firstRow.forEach(function (cell) {
        var _cell$attrs = cell.attrs,
          colspan = _cell$attrs.colspan,
          colwidth = _cell$attrs.colwidth;
        // column has been resized, colWidth will be an array, can safely take values even if cell is merged
        if (Array.isArray(colwidth)) {
          _tableColumnWidths.push.apply(_tableColumnWidths, (0, _toConsumableArray2.default)(colwidth));
          // table has merged cells but no colWidth, so columns haven't been resized, default to 0
        } else if (colspan > 1) {
          _tableColumnWidths.push.apply(_tableColumnWidths, (0, _toConsumableArray2.default)(Array(colspan).fill(0)));
          // no merged cells, no column resized, default to 0
        } else {
          _tableColumnWidths.push(0);
        }
      });
    }
    return _tableColumnWidths;
  }
  var tableColumnWidths = [];
  var firstRow = node.firstChild;
  if (firstRow) {
    // Sanity validation, but it should always have a first row
    // Iterate for the cells in the first row
    firstRow.forEach(function (colNode) {
      var colwidth = colNode.attrs.colwidth || [0];

      // If we have colwidth, we added it
      if (colwidth) {
        tableColumnWidths = [].concat((0, _toConsumableArray2.default)(tableColumnWidths), (0, _toConsumableArray2.default)(colwidth));
      }
    });
  }
  return tableColumnWidths;
}
function hasMergedCell(tableNode) {
  var hasSpan = false;
  tableNode.descendants(function (node) {
    if (node.type.name === 'tableRow') {
      return true;
    }
    var _node$attrs = node.attrs,
      colspan = _node$attrs.colspan,
      rowspan = _node$attrs.rowspan;
    if (colspan > 1 || rowspan > 1) {
      hasSpan = true;
    }
    return false;
  });
  return hasSpan;
}
function convertProsemirrorTableNodeToArrayOfRows(tableNode) {
  var result = [];
  tableNode.forEach(function (rowNode) {
    if (rowNode.type.name === 'tableRow') {
      var row = [];
      rowNode.forEach(function (n) {
        return row.push(n);
      });
      result.push(row);
    }
  });
  return result;
}

/*
  isPositionNearTableRow()
  Returns true when a sibling node, or any  of the parent's sibling
  nodes are a tableRow
 */
function isPositionNearTableRow(pos, schema, direction) {
  if (!schema.nodes.tableRow) {
    return false;
  }
  var doc = pos.doc;
  var resolved = pos;
  var sibling = direction === 'before' ? 'nodeBefore' : 'nodeAfter';
  while (resolved.depth > 0) {
    var _resolved$sibling;
    var siblingType = (_resolved$sibling = resolved[sibling]) === null || _resolved$sibling === void 0 ? void 0 : _resolved$sibling.type;
    if (siblingType === schema.nodes.tableRow) {
      return true;
    }
    resolved = doc.resolve(resolved[direction]());
  }
  return false;
}