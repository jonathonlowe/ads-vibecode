import { isNestedTableExtension } from '@atlaskit/adf-utils/transforms';
import { reduce } from '@atlaskit/adf-utils/traverse';
/**
 * Traverses a JSON document and counts the number of unique elements, text formatting and macros.
 *
 **/
export const getPageElementCounts = doc => {
  const pageElementCounts = {
    elements: {},
    textFormats: {},
    macros: {},
    unexpectedElements: {}
  };
  reduce(doc, (acc, node) => {
    if (node.type === 'text') {
      var _acc$elements$node$ty;
      if (node.marks) {
        node.marks.forEach(mark => {
          var _acc$textFormats$mark;
          const markType = mark.type;
          acc.textFormats[markType] = ((_acc$textFormats$mark = acc.textFormats[markType]) !== null && _acc$textFormats$mark !== void 0 ? _acc$textFormats$mark : 0) + 1;
        });
      }
      acc.elements[node.type] = ((_acc$elements$node$ty = acc.elements[node.type]) !== null && _acc$elements$node$ty !== void 0 ? _acc$elements$node$ty : 0) + 1;
    }
    // If the node is a 'macro'or extension
    else if (node.type === 'extension' || node.type === 'inlineExtension' || node.type === 'bodiedExtension' || node.type === 'multiBodiedExtension' || node.type === 'extensionFrame') {
      if ('attrs' in node && node.attrs && 'extensionKey' in node.attrs && node.attrs.extensionKey) {
        var _acc$macros$extension;
        let extensionKey = node.attrs.extensionKey;

        // If there is a nested table extension
        if (isNestedTableExtension(node)) {
          if ('parameters' in node.attrs && node.attrs.parameters && 'adf' in node.attrs.parameters) {
            // Check to see if the ADF contains a nested table
            const adfString = node.attrs.parameters.adf;
            const adf = JSON.parse(adfString);
            if (adfString.includes('{"type":"table"')) {
              if (getHasNestedTable(adf)) {
                var _acc$unexpectedElemen;
                acc.unexpectedElements['tablesNestedMoreThanOnce'] = ((_acc$unexpectedElemen = acc.unexpectedElements['tablesNestedMoreThanOnce']) !== null && _acc$unexpectedElemen !== void 0 ? _acc$unexpectedElemen : 0) + 1;
              }
            }
          }
        }

        // If macros extensionKey has <UUID>/<UUID>/static/ prepended to it, remove the prefix
        if (extensionKey.includes('/static/')) {
          const extensionKeyParts = extensionKey.split('/');
          extensionKey = extensionKeyParts[extensionKeyParts.length - 1];
        }
        acc.macros[extensionKey] = ((_acc$macros$extension = acc.macros[extensionKey]) !== null && _acc$macros$extension !== void 0 ? _acc$macros$extension : 0) + 1;
      }
    } else {
      var _acc$elements$node$ty2;
      acc.elements[node.type] = ((_acc$elements$node$ty2 = acc.elements[node.type]) !== null && _acc$elements$node$ty2 !== void 0 ? _acc$elements$node$ty2 : 0) + 1;
    }
    return acc;
  }, pageElementCounts);
  return pageElementCounts;
};

/**
 * Return true is the JSON document contains a table nested within a table
 */
const getHasNestedTable = node => {
  return reduce(node, (hasNestedTable, node) => {
    if (hasNestedTable) {
      return hasNestedTable;
    }
    if (node.type === 'table') {
      // The first node that we pass into the reduce function is a table node, and we need to ignore it
      let foundFirstTable = false;
      return reduce(node, (hasNestedTable, node) => {
        if (hasNestedTable) {
          return hasNestedTable;
        }
        if (node.type === 'table' && foundFirstTable) {
          return true;
        } else if (node.type === 'table') {
          foundFirstTable = true;
        }
        return hasNestedTable;
      }, false);
    }
    return hasNestedTable;
  }, false);
};