import React from 'react';
import type { PluginKey } from '@atlaskit/editor-prosemirror/state';
import type { EditorView } from '@atlaskit/editor-prosemirror/view';
import type { EventDispatcher } from '../event-dispatcher';
import type { NamedPluginKeys, NamedPluginStates } from './types';
export type PerformanceOptions = {
    samplingRate: number;
    slowThreshold: number;
    trackingEnabled: boolean;
};
export interface State {
    [name: string]: any;
}
type ContextUpdateHandler = (editorView: EditorView, eventDispatcher: EventDispatcher) => void;
export type EditorActionsPrivateAccess = {
    _privateGetEditorView: () => EditorView;
    _privateGetEventDispatcher: () => EventDispatcher;
    _privateSubscribe: (cb: ContextUpdateHandler) => void;
    _privateUnsubscribe: (cb: ContextUpdateHandler) => void;
};
export type PluginsConfig = {
    [name: string]: PluginKey;
};
export interface Props<P extends NamedPluginKeys> {
    debounce?: boolean;
    eventDispatcher?: EventDispatcher;
    editorView?: EditorView;
    plugins: P;
    render: (pluginState: NamedPluginStates<P>) => React.ReactElement | null;
}
/**
 * @private
 * @deprecated
 *
 * Using this component is deprecated. It should be replaced with `useSharedPluginState`.
 * This requires having access to the injection API from the plugin itself.
 *
 * An example of the refactor with the new hook (using hyperlink as an example) is:
 *
 * Before:
 * ```ts
 * <WithPluginState
 *   editorView={editorView}
 *   plugins={{
 *     hyperlinkState: hyperlinkPluginKey
 *   }}
 *   render={({ hyperlinkState }) =>
 *     renderComponent({ hyperlinkState })
 *   }
 * />
 * ```
 *
 * After:
 * ```ts
 * import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
 * import type { ExtractInjectionAPI } from '@atlaskit/editor-common/types';
 *
 * function ComponentWithState(
 *   api: ExtractInjectionAPI<typeof hyperlinkPlugin> | undefined
 * ) {
 *   const { hyperlinkState } = useSharedPluginState(api, ['hyperlink']);
 *   return renderComponent({ hyperlinkState })
 * }
 * ```
 *
 */
declare class WithPluginState<P extends NamedPluginKeys> extends React.Component<WithPluginStateInnerProps<P>, State> {
    constructor(props: WithPluginStateInnerProps<P>);
    render(): React.JSX.Element;
}
type WithPluginStateInnerProps<P extends NamedPluginKeys> = Props<P> & {
    editorActions?: EditorActionsPrivateAccess;
};
export declare class WithPluginStateInner<P extends NamedPluginKeys> extends React.Component<WithPluginStateInnerProps<P>, State> {
    static displayName: string;
    private listeners;
    private debounce;
    private notAppliedState;
    private isSubscribed;
    private callsCount;
    state: NamedPluginStates<P>;
    constructor(props: Props<P>);
    private getEditorView;
    private getEventDispatcher;
    private handlePluginStateChange;
    /**
     * Debounces setState calls in order to reduce number of re-renders caused by several plugin state changes.
     */
    private updateState;
    private dispatchAnalyticsEvent;
    private getPluginsStates;
    private subscribe;
    private unsubscribe;
    private subscribeToContextUpdates;
    private unsubscribeFromContextUpdates;
    componentDidMount(): void;
    UNSAFE_componentWillReceiveProps(nextProps: Props<P>): void;
    componentWillUnmount(): void;
    render(): React.ReactElement<any, string | React.JSXElementConstructor<any>> | null;
}
export { WithPluginState };
