import React from 'react';
import type { Position } from './utils';
export interface Props {
    zIndex?: number;
    alignX?: 'left' | 'right' | 'center' | 'end';
    alignY?: 'top' | 'bottom' | 'start';
    target?: HTMLElement;
    fitHeight?: number;
    fitWidth?: number;
    boundariesElement?: HTMLElement;
    mountTo?: HTMLElement;
    offset?: number[];
    onUnmount?: () => void;
    onPositionCalculated?: (position: Position) => Position;
    onPlacementChanged?: (placement: [string, string]) => void;
    shouldRenderPopup?: (position: Position) => boolean;
    scrollableElement?: HTMLElement;
    stick?: boolean;
    /** `null` should only be used if we provide enough context to screen readers to exclude aria-label attribute */
    ariaLabel?: string | null;
    forcePlacement?: boolean;
    allowOutOfBounds?: boolean;
    rect?: DOMRect;
    style?: React.CSSProperties;
    /** Enable focus trap to contain the user's focus within the popup */
    focusTrap?: boolean;
    preventOverflow?: boolean;
    absoluteOffset?: Position;
    children?: React.ReactNode;
}
export interface State {
    popup?: HTMLElement;
    position?: Position;
    validPosition: boolean;
}
export default class Popup extends React.Component<Props, State> {
    scrollElement: undefined | false | HTMLElement;
    scrollParentElement: undefined | false | HTMLElement;
    rafIds: Set<number>;
    static defaultProps: {
        offset: number[];
        allowOutOfBound: boolean;
    };
    state: State;
    private popupRef;
    private focusTrap?;
    private placement;
    /**
     * Calculates new popup position
     */
    private calculatePosition;
    private updatePosition;
    private cannotSetPopup;
    /**
     * Popup initialization.
     * Checks whether it's possible to position popup along given target, and if it's not throws an error.
     */
    private initPopup;
    private handleRef;
    private scheduledUpdatePosition;
    onResize: () => void;
    resizeObserver: ResizeObserver | undefined;
    /**
     * Raf scheduled so that it also occurs after the initial update position
     */
    private initFocusTrap;
    /**
     * Cancels the initialisation of the focus trap if it has not yet occured
     * Deactivates the focus trap if it exists
     */
    private destroyFocusTrap;
    /**
     * Handle pausing, unpausing, and initialising (if not yet initialised) of the focus trap
     */
    handleChangedFocusTrapProp(prevProps: Props): void;
    componentDidUpdate(prevProps: Props): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    private renderPopup;
    render(): React.JSX.Element | null;
}
