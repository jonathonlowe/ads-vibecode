import React from 'react';
import { useIntl } from 'react-intl-next';
import { memoProcessQuickInsertItems } from '@atlaskit/editor-common/quick-insert';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { TypeAheadAvailableNodes } from '@atlaskit/editor-common/type-ahead';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { createInsertItem, openElementBrowserModal } from './pm-plugins/commands';
import { pluginKey } from './pm-plugins/plugin-key';
import ModalElementBrowser from './ui/ModalElementBrowser';
import { getQuickInsertSuggestions } from './ui/search';
export const quickInsertPlugin = ({
  config: options,
  api
}) => {
  const onInsert = item => {
    var _options$onInsert;
    options === null || options === void 0 ? void 0 : (_options$onInsert = options.onInsert) === null || _options$onInsert === void 0 ? void 0 : _options$onInsert.call(options, item);
  };
  const typeAhead = {
    id: TypeAheadAvailableNodes.QUICK_INSERT,
    trigger: '/',
    headless: options === null || options === void 0 ? void 0 : options.headless,
    getItems({
      query,
      editorState
    }) {
      const quickInsertState = pluginKey.getState(editorState);
      const queryAllItems = '';
      return Promise.resolve(getQuickInsertSuggestions({
        query: editorExperiment('platform_editor_insertion', 'control') ? query : queryAllItems,
        disableDefaultItems: options === null || options === void 0 ? void 0 : options.disableDefaultItems,
        prioritySortingFn: options === null || options === void 0 ? void 0 : options.prioritySortingFn
      }, quickInsertState === null || quickInsertState === void 0 ? void 0 : quickInsertState.lazyDefaultItems, quickInsertState === null || quickInsertState === void 0 ? void 0 : quickInsertState.providedItems));
    },
    selectItem: (state, item, insert) => {
      const quickInsertItem = item;
      const result = quickInsertItem.action(insert, state);
      if (result) {
        onInsert(quickInsertItem);
      }
      return result;
    },
    // @ts-ignore
    // This is used by typeahead plugin to trigger element browser modal without introducing circular dependency.
    // Given it's only temporarily needed to roll out toolbar&menus separate to quick insert/right rail change
    // skip updating `TypeAheadHandler` to avoid unnecessary breaking change.
    openElementBrowserModal: options !== null && options !== void 0 && options.enableElementBrowser ? () => {
      api === null || api === void 0 ? void 0 : api.core.actions.execute(({
        tr
      }) => {
        if (fg('platform_editor_ease_of_use_metrics')) {
          var _api$metrics;
          api === null || api === void 0 ? void 0 : (_api$metrics = api.metrics) === null || _api$metrics === void 0 ? void 0 : _api$metrics.commands.handleIntentToStartEdit({
            shouldStartTimer: false,
            shouldPersistActiveSession: true
          })({
            tr
          });
        }
        openElementBrowserModal({
          tr
        });
        return tr;
      });
    } : undefined
  };
  let intl;
  return {
    name: 'quickInsert',
    pmPlugins(defaultItems) {
      return [{
        name: 'quickInsert',
        // It's important that this plugin is above TypeAheadPlugin
        plugin: ({
          providerFactory,
          getIntl,
          dispatch
        }) => quickInsertPluginFactory(defaultItems, providerFactory, getIntl, dispatch, options === null || options === void 0 ? void 0 : options.emptyStateHandler)
      }];
    },
    pluginsOptions: {
      typeAhead
    },
    contentComponent({
      editorView
    }) {
      if (options !== null && options !== void 0 && options.enableElementBrowser) {
        return /*#__PURE__*/React.createElement(ModalElementBrowser, {
          editorView: editorView,
          helpUrl: options === null || options === void 0 ? void 0 : options.elementBrowserHelpUrl,
          pluginInjectionAPI: api
        });
      }
      return null;
    },
    getSharedState(editorState) {
      if (!editorState) {
        return null;
      }
      const quickInsertState = pluginKey.getState(editorState);
      if (!quickInsertState) {
        return null;
      }
      return {
        typeAheadHandler: typeAhead,
        lazyDefaultItems: quickInsertState.lazyDefaultItems,
        emptyStateHandler: quickInsertState.emptyStateHandler,
        providedItems: quickInsertState.providedItems,
        isElementBrowserModalOpen: quickInsertState.isElementBrowserModalOpen
      };
    },
    actions: {
      insertItem: createInsertItem(onInsert),
      openTypeAhead(inputMethod, removePrefixTriggerOnCancel) {
        var _api$typeAhead;
        return Boolean(api === null || api === void 0 ? void 0 : (_api$typeAhead = api.typeAhead) === null || _api$typeAhead === void 0 ? void 0 : _api$typeAhead.actions.open({
          triggerHandler: typeAhead,
          inputMethod,
          removePrefixTriggerOnCancel: removePrefixTriggerOnCancel
        }));
      },
      getSuggestions: searchOptions => {
        var _api$quickInsert$shar, _api$quickInsert;
        const {
          lazyDefaultItems,
          providedItems
        } = (_api$quickInsert$shar = api === null || api === void 0 ? void 0 : (_api$quickInsert = api.quickInsert) === null || _api$quickInsert === void 0 ? void 0 : _api$quickInsert.sharedState.currentState()) !== null && _api$quickInsert$shar !== void 0 ? _api$quickInsert$shar : {};
        if (options !== null && options !== void 0 && options.prioritySortingFn) {
          searchOptions = {
            ...searchOptions,
            prioritySortingFn: options.prioritySortingFn
          };
        }
        return getQuickInsertSuggestions(searchOptions, lazyDefaultItems, providedItems);
      }
    },
    commands: {
      openElementBrowserModal: ({
        tr
      }) => {
        if (fg('platform_editor_ease_of_use_metrics')) {
          var _api$metrics2;
          api === null || api === void 0 ? void 0 : (_api$metrics2 = api.metrics) === null || _api$metrics2 === void 0 ? void 0 : _api$metrics2.commands.handleIntentToStartEdit({
            shouldStartTimer: false,
            shouldPersistActiveSession: true
          })({
            tr
          });
        }
        return openElementBrowserModal({
          tr
        });
      },
      addQuickInsertItem: item => ({
        tr
      }) => {
        var _api$quickInsert$shar2, _api$quickInsert2;
        const {
          lazyDefaultItems
        } = (_api$quickInsert$shar2 = api === null || api === void 0 ? void 0 : (_api$quickInsert2 = api.quickInsert) === null || _api$quickInsert2 === void 0 ? void 0 : _api$quickInsert2.sharedState.currentState()) !== null && _api$quickInsert$shar2 !== void 0 ? _api$quickInsert$shar2 : {};
        const defaultItems = lazyDefaultItems ? lazyDefaultItems() : [];
        const memoisedNewItems = memoProcessQuickInsertItems([item], intl);
        return tr.setMeta(pluginKey, {
          lazyDefaultItems: () => [...defaultItems, ...memoisedNewItems]
        });
      }
    },
    usePluginHook: () => {
      intl = useIntl();
    }
  };
};
const setProviderState = providerState => (state, dispatch) => {
  if (dispatch) {
    dispatch(state.tr.setMeta(pluginKey, providerState));
  }
  return true;
};
function quickInsertPluginFactory(defaultItems, providerFactory, getIntl, dispatch, emptyStateHandler) {
  return new SafePlugin({
    key: pluginKey,
    state: {
      init() {
        return {
          isElementBrowserModalOpen: false,
          emptyStateHandler,
          // lazy so it doesn't run on editor initialization
          // memo here to avoid using a singleton cache, avoids editor
          // getting confused when two editors exist within the same page.
          lazyDefaultItems: () => memoProcessQuickInsertItems(defaultItems || [], getIntl())
        };
      },
      apply(tr, pluginState) {
        const meta = tr.getMeta(pluginKey);
        if (meta) {
          const keys = Object.keys(meta);
          const changed = keys.some(key => {
            return pluginState[key] !== meta[key];
          });
          if (changed) {
            const newState = {
              ...pluginState,
              ...meta
            };
            dispatch(pluginKey, newState);
            return newState;
          }
        }
        return pluginState;
      }
    },
    view(editorView) {
      const providerHandler = async (_name, providerPromise) => {
        if (providerPromise) {
          try {
            const provider = await providerPromise;
            const providedItems = await provider.getItems();
            setProviderState({
              provider,
              providedItems
            })(editorView.state, editorView.dispatch);
          } catch (e) {
            // eslint-disable-next-line no-console
            console.error('Error getting items from quick insert provider', e);
          }
        }
      };
      providerFactory.subscribe('quickInsertProvider', providerHandler);
      return {
        destroy() {
          providerFactory.unsubscribe('quickInsertProvider', providerHandler);
        }
      };
    }
  });
}