import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import { useIntl } from 'react-intl-next';
import { memoProcessQuickInsertItems } from '@atlaskit/editor-common/quick-insert';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { TypeAheadAvailableNodes } from '@atlaskit/editor-common/type-ahead';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { createInsertItem, openElementBrowserModal as _openElementBrowserModal } from './pm-plugins/commands';
import { pluginKey } from './pm-plugins/plugin-key';
import ModalElementBrowser from './ui/ModalElementBrowser';
import { getQuickInsertSuggestions } from './ui/search';
export var quickInsertPlugin = function quickInsertPlugin(_ref) {
  var options = _ref.config,
    api = _ref.api;
  var onInsert = function onInsert(item) {
    var _options$onInsert;
    options === null || options === void 0 || (_options$onInsert = options.onInsert) === null || _options$onInsert === void 0 || _options$onInsert.call(options, item);
  };
  var typeAhead = {
    id: TypeAheadAvailableNodes.QUICK_INSERT,
    trigger: '/',
    headless: options === null || options === void 0 ? void 0 : options.headless,
    getItems: function getItems(_ref2) {
      var query = _ref2.query,
        editorState = _ref2.editorState;
      var quickInsertState = pluginKey.getState(editorState);
      var queryAllItems = '';
      return Promise.resolve(getQuickInsertSuggestions({
        query: editorExperiment('platform_editor_insertion', 'control') ? query : queryAllItems,
        disableDefaultItems: options === null || options === void 0 ? void 0 : options.disableDefaultItems,
        prioritySortingFn: options === null || options === void 0 ? void 0 : options.prioritySortingFn
      }, quickInsertState === null || quickInsertState === void 0 ? void 0 : quickInsertState.lazyDefaultItems, quickInsertState === null || quickInsertState === void 0 ? void 0 : quickInsertState.providedItems));
    },
    selectItem: function selectItem(state, item, insert) {
      var quickInsertItem = item;
      var result = quickInsertItem.action(insert, state);
      if (result) {
        onInsert(quickInsertItem);
      }
      return result;
    },
    // @ts-ignore
    // This is used by typeahead plugin to trigger element browser modal without introducing circular dependency.
    // Given it's only temporarily needed to roll out toolbar&menus separate to quick insert/right rail change
    // skip updating `TypeAheadHandler` to avoid unnecessary breaking change.
    openElementBrowserModal: options !== null && options !== void 0 && options.enableElementBrowser ? function () {
      api === null || api === void 0 || api.core.actions.execute(function (_ref3) {
        var tr = _ref3.tr;
        if (fg('platform_editor_ease_of_use_metrics')) {
          var _api$metrics;
          api === null || api === void 0 || (_api$metrics = api.metrics) === null || _api$metrics === void 0 || _api$metrics.commands.handleIntentToStartEdit({
            shouldStartTimer: false,
            shouldPersistActiveSession: true
          })({
            tr: tr
          });
        }
        _openElementBrowserModal({
          tr: tr
        });
        return tr;
      });
    } : undefined
  };
  var intl;
  return {
    name: 'quickInsert',
    pmPlugins: function pmPlugins(defaultItems) {
      return [{
        name: 'quickInsert',
        // It's important that this plugin is above TypeAheadPlugin
        plugin: function plugin(_ref4) {
          var providerFactory = _ref4.providerFactory,
            getIntl = _ref4.getIntl,
            dispatch = _ref4.dispatch;
          return quickInsertPluginFactory(defaultItems, providerFactory, getIntl, dispatch, options === null || options === void 0 ? void 0 : options.emptyStateHandler);
        }
      }];
    },
    pluginsOptions: {
      typeAhead: typeAhead
    },
    contentComponent: function contentComponent(_ref5) {
      var editorView = _ref5.editorView;
      if (options !== null && options !== void 0 && options.enableElementBrowser) {
        return /*#__PURE__*/React.createElement(ModalElementBrowser, {
          editorView: editorView,
          helpUrl: options === null || options === void 0 ? void 0 : options.elementBrowserHelpUrl,
          pluginInjectionAPI: api
        });
      }
      return null;
    },
    getSharedState: function getSharedState(editorState) {
      if (!editorState) {
        return null;
      }
      var quickInsertState = pluginKey.getState(editorState);
      if (!quickInsertState) {
        return null;
      }
      return {
        typeAheadHandler: typeAhead,
        lazyDefaultItems: quickInsertState.lazyDefaultItems,
        emptyStateHandler: quickInsertState.emptyStateHandler,
        providedItems: quickInsertState.providedItems,
        isElementBrowserModalOpen: quickInsertState.isElementBrowserModalOpen
      };
    },
    actions: {
      insertItem: createInsertItem(onInsert),
      openTypeAhead: function openTypeAhead(inputMethod, removePrefixTriggerOnCancel) {
        var _api$typeAhead;
        return Boolean(api === null || api === void 0 || (_api$typeAhead = api.typeAhead) === null || _api$typeAhead === void 0 ? void 0 : _api$typeAhead.actions.open({
          triggerHandler: typeAhead,
          inputMethod: inputMethod,
          removePrefixTriggerOnCancel: removePrefixTriggerOnCancel
        }));
      },
      getSuggestions: function getSuggestions(searchOptions) {
        var _api$quickInsert$shar, _api$quickInsert;
        var _ref6 = (_api$quickInsert$shar = api === null || api === void 0 || (_api$quickInsert = api.quickInsert) === null || _api$quickInsert === void 0 ? void 0 : _api$quickInsert.sharedState.currentState()) !== null && _api$quickInsert$shar !== void 0 ? _api$quickInsert$shar : {},
          lazyDefaultItems = _ref6.lazyDefaultItems,
          providedItems = _ref6.providedItems;
        if (options !== null && options !== void 0 && options.prioritySortingFn) {
          searchOptions = _objectSpread(_objectSpread({}, searchOptions), {}, {
            prioritySortingFn: options.prioritySortingFn
          });
        }
        return getQuickInsertSuggestions(searchOptions, lazyDefaultItems, providedItems);
      }
    },
    commands: {
      openElementBrowserModal: function openElementBrowserModal(_ref7) {
        var tr = _ref7.tr;
        if (fg('platform_editor_ease_of_use_metrics')) {
          var _api$metrics2;
          api === null || api === void 0 || (_api$metrics2 = api.metrics) === null || _api$metrics2 === void 0 || _api$metrics2.commands.handleIntentToStartEdit({
            shouldStartTimer: false,
            shouldPersistActiveSession: true
          })({
            tr: tr
          });
        }
        return _openElementBrowserModal({
          tr: tr
        });
      },
      addQuickInsertItem: function addQuickInsertItem(item) {
        return function (_ref8) {
          var _api$quickInsert$shar2, _api$quickInsert2;
          var tr = _ref8.tr;
          var _ref9 = (_api$quickInsert$shar2 = api === null || api === void 0 || (_api$quickInsert2 = api.quickInsert) === null || _api$quickInsert2 === void 0 ? void 0 : _api$quickInsert2.sharedState.currentState()) !== null && _api$quickInsert$shar2 !== void 0 ? _api$quickInsert$shar2 : {},
            lazyDefaultItems = _ref9.lazyDefaultItems;
          var defaultItems = lazyDefaultItems ? lazyDefaultItems() : [];
          var memoisedNewItems = memoProcessQuickInsertItems([item], intl);
          return tr.setMeta(pluginKey, {
            lazyDefaultItems: function lazyDefaultItems() {
              return [].concat(_toConsumableArray(defaultItems), _toConsumableArray(memoisedNewItems));
            }
          });
        };
      }
    },
    usePluginHook: function usePluginHook() {
      intl = useIntl();
    }
  };
};
var setProviderState = function setProviderState(providerState) {
  return function (state, dispatch) {
    if (dispatch) {
      dispatch(state.tr.setMeta(pluginKey, providerState));
    }
    return true;
  };
};
function quickInsertPluginFactory(defaultItems, providerFactory, getIntl, dispatch, emptyStateHandler) {
  return new SafePlugin({
    key: pluginKey,
    state: {
      init: function init() {
        return {
          isElementBrowserModalOpen: false,
          emptyStateHandler: emptyStateHandler,
          // lazy so it doesn't run on editor initialization
          // memo here to avoid using a singleton cache, avoids editor
          // getting confused when two editors exist within the same page.
          lazyDefaultItems: function lazyDefaultItems() {
            return memoProcessQuickInsertItems(defaultItems || [], getIntl());
          }
        };
      },
      apply: function apply(tr, pluginState) {
        var meta = tr.getMeta(pluginKey);
        if (meta) {
          var keys = Object.keys(meta);
          var changed = keys.some(function (key) {
            return pluginState[key] !== meta[key];
          });
          if (changed) {
            var newState = _objectSpread(_objectSpread({}, pluginState), meta);
            dispatch(pluginKey, newState);
            return newState;
          }
        }
        return pluginState;
      }
    },
    view: function view(editorView) {
      var providerHandler = /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_name, providerPromise) {
          var provider, providedItems;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!providerPromise) {
                  _context.next = 14;
                  break;
                }
                _context.prev = 1;
                _context.next = 4;
                return providerPromise;
              case 4:
                provider = _context.sent;
                _context.next = 7;
                return provider.getItems();
              case 7:
                providedItems = _context.sent;
                setProviderState({
                  provider: provider,
                  providedItems: providedItems
                })(editorView.state, editorView.dispatch);
                _context.next = 14;
                break;
              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](1);
                // eslint-disable-next-line no-console
                console.error('Error getting items from quick insert provider', _context.t0);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[1, 11]]);
        }));
        return function providerHandler(_x, _x2) {
          return _ref10.apply(this, arguments);
        };
      }();
      providerFactory.subscribe('quickInsertProvider', providerHandler);
      return {
        destroy: function destroy() {
          providerFactory.unsubscribe('quickInsertProvider', providerHandler);
        }
      };
    }
  });
}