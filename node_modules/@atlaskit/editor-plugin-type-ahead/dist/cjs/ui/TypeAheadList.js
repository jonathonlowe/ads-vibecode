"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeAheadList = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _react2 = require("@emotion/react");
var _reactIntlNext = require("react-intl-next");
var _CellMeasurer = require("react-virtualized/dist/commonjs/CellMeasurer");
var _List = require("react-virtualized/dist/commonjs/List");
var _analytics = require("@atlaskit/editor-common/analytics");
var _messages = require("@atlaskit/editor-common/messages");
var _typeAhead = require("@atlaskit/editor-common/type-ahead");
var _ui = require("@atlaskit/editor-common/ui");
var _menu = require("@atlaskit/menu");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _compiled = require("@atlaskit/primitives/compiled");
var _updateSelectedIndex = require("../pm-plugins/commands/update-selected-index");
var _constants = require("../pm-plugins/constants");
var _utils = require("../pm-plugins/utils");
var _ListRow = require("./ListRow");
var _TypeAheadListItem = require("./TypeAheadListItem");
var _ViewMore = require("./ViewMore");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766

var LIST_ITEM_ESTIMATED_HEIGHT = 64;
var LIST_WIDTH = 320;
var list = (0, _react2.css)({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  button: {
    padding: "var(--ds-space-100, 8px)".concat(" ", "var(--ds-space-150, 12px)")
  }
});
var TypeaheadAssistiveTextPureComponent = /*#__PURE__*/_react.default.memo(function (_ref) {
  var numberOfResults = _ref.numberOfResults;
  var intl = (0, _reactIntlNext.useIntl)();
  return (0, _react2.jsx)(_ui.AssistiveText, {
    assistiveText: intl.formatMessage(_typeAhead.typeAheadListMessages.searchResultsLabel, {
      itemsLength: numberOfResults
    })
    // when the popup is open its always in focus
    ,
    isInFocus: true,
    id: _constants.TYPE_AHEAD_DECORATION_ELEMENT_ID + '__popup'
  });
});
var TypeAheadListComponent = /*#__PURE__*/_react.default.memo(function (_ref2) {
  var _decorationElement$qu2;
  var items = _ref2.items,
    selectedIndex = _ref2.selectedIndex,
    editorView = _ref2.editorView,
    onItemClick = _ref2.onItemClick,
    intl = _ref2.intl,
    fitHeight = _ref2.fitHeight,
    decorationElement = _ref2.decorationElement,
    triggerHandler = _ref2.triggerHandler,
    moreElementsInQuickInsertViewEnabled = _ref2.moreElementsInQuickInsertViewEnabled,
    api = _ref2.api,
    showViewMore = _ref2.showViewMore,
    onViewMoreClick = _ref2.onViewMoreClick;
  var listRef = (0, _react.useRef)();
  var listContainerRef = (0, _react.useRef)(null);
  var lastVisibleIndexes = (0, _react.useRef)({
    overscanStartIndex: 0,
    overscanStopIndex: 0,
    startIndex: 0,
    stopIndex: 0
  });

  // Exclude view more item from the count
  var itemsLength = showViewMore ? items.length - 1 : items.length;
  var estimatedHeight = itemsLength * LIST_ITEM_ESTIMATED_HEIGHT;
  var _useState = (0, _react.useState)(Math.min(estimatedHeight, fitHeight)),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    height = _useState2[0],
    setHeight = _useState2[1];
  var _useState3 = (0, _react.useState)(new _CellMeasurer.CellMeasurerCache({
      fixedWidth: true,
      defaultHeight: LIST_ITEM_ESTIMATED_HEIGHT
    })),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    cache = _useState4[0],
    setCache = _useState4[1];
  var onItemsRendered = (0, _react.useCallback)(function (props) {
    lastVisibleIndexes.current = props;
  }, []);
  var actions = (0, _react.useMemo)(function () {
    return {
      onItemClick: onItemClick
    };
  }, [onItemClick]);
  var isNavigationKey = function isNavigationKey(event) {
    return ['ArrowDown', 'ArrowUp', 'Tab', 'Enter'].includes(event.key);
  };
  var focusTargetElement = (0, _react.useCallback)(function () {
    var _decorationElement$qu;
    //To reset the selected index
    (0, _updateSelectedIndex.updateSelectedIndex)(-1, api)(editorView.state, editorView.dispatch);
    listRef.current.scrollToRow(0);
    decorationElement === null || decorationElement === void 0 || (_decorationElement$qu = decorationElement.querySelector("[role='combobox']")) === null || _decorationElement$qu === void 0 || _decorationElement$qu.focus();
  }, [editorView, listRef, decorationElement, api]);
  var selectNextItem = (0, _react.useMemo)(function () {
    return (0, _utils.moveSelectedIndex)({
      editorView: editorView,
      direction: 'next',
      api: api
    });
  }, [editorView, api]);
  var selectPreviousItem = (0, _react.useMemo)(function () {
    return (0, _utils.moveSelectedIndex)({
      editorView: editorView,
      direction: 'previous',
      api: api
    });
  }, [editorView, api]);
  var lastVisibleStartIndex = lastVisibleIndexes.current.startIndex;
  var lastVisibleStopIndex = lastVisibleIndexes.current.stopIndex;
  var onScroll = (0, _react.useCallback)(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function (_ref3) {
    var scrollUpdateWasRequested = _ref3.scrollUpdateWasRequested;
    if (!scrollUpdateWasRequested) {
      return;
    }

    // In case the user scroll to a non-visible item like press ArrowUp from the first index
    // We will force the scroll calling the scrollToItem in the useEffect hook
    // When the scroll happens and we render the elements,
    // we still need calculate the items height and re-draw the List.
    // It is possible the item selected became invisible again (because the items height changed)
    // So, we need to wait for height to be calculated. Then we need to check
    // if the selected item is visible or not. If it isn't visible we call the scrollToItem again.
    //
    // We can't do this check in the first frame because that frame is being used by the resetScreenThrottled
    // to calculate each height. THen, we can schedule a new frame when this one finishs.
    requestAnimationFrame(function () {
      requestAnimationFrame(function () {
        var isViewMoreSelected = showViewMore && selectedIndex === itemsLength;
        var isSelectedItemVisible = selectedIndex >= lastVisibleStartIndex && selectedIndex <= lastVisibleStopIndex ||
        // view more is always visible, hence no scrolling
        isViewMoreSelected;

        //Should scroll to the list item only when the selectedIndex >= 0 and item is not visible
        if (!isSelectedItemVisible && selectedIndex !== -1) {
          listRef.current.scrollToRow(selectedIndex);
        } else if (selectedIndex === -1) {
          listRef.current.scrollToRow(0);
        }
      });
    });
  }, [selectedIndex, lastVisibleStartIndex, lastVisibleStopIndex, itemsLength, showViewMore]);
  var _onMouseMove = function onMouseMove(event, index) {
    event.preventDefault();
    event.stopPropagation();
    if (selectedIndex === index) {
      return;
    }
    (0, _updateSelectedIndex.updateSelectedIndex)(index, api)(editorView.state, editorView.dispatch);
  };
  (0, _react.useLayoutEffect)(function () {
    if (!listRef.current) {
      return;
    }
    var isViewMoreSelected = showViewMore && selectedIndex === itemsLength;
    var isSelectedItemVisible = selectedIndex >= lastVisibleStartIndex && selectedIndex <= lastVisibleStopIndex ||
    // view more is always visible, hence no scrolling
    isViewMoreSelected;

    //Should scroll to the list item only when the selectedIndex >= 0 and item is not visible
    if (!isSelectedItemVisible && selectedIndex !== -1) {
      listRef.current.scrollToRow(selectedIndex);
    } else if (selectedIndex === -1) {
      listRef.current.scrollToRow(0);
    }
  }, [selectedIndex, lastVisibleStartIndex, lastVisibleStopIndex, itemsLength, showViewMore]);
  (0, _react.useLayoutEffect)(function () {
    setCache(new _CellMeasurer.CellMeasurerCache({
      fixedWidth: true,
      defaultHeight: LIST_ITEM_ESTIMATED_HEIGHT
    }));
    // When query is updated, sometimes the scroll position of the menu is not at the top
    // Scrolling back to top for consistency
    requestAnimationFrame(function () {
      var _listContainerRef$cur;
      if ((_listContainerRef$cur = listContainerRef.current) !== null && _listContainerRef$cur !== void 0 && _listContainerRef$cur.firstChild) {
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        listContainerRef.current.firstChild.scrollTo(0, 0);
      }
    });
  }, [items]);
  (0, _react.useLayoutEffect)(function () {
    // Exclude view more item from the count
    var itemsToRender = showViewMore ? items.slice(0, -1) : items;
    var height = Math.min(itemsToRender.reduce(function (prevValue, currentValue, index) {
      return prevValue + cache.rowHeight({
        index: index
      });
    }, 0), fitHeight);
    setHeight(height);
  }, [items, cache, fitHeight, showViewMore]);
  (0, _react.useLayoutEffect)(function () {
    if (!listContainerRef.current) {
      return;
    }
    var element = listContainerRef.current;
    /**
     * To handle the key events on the list
     * @param event
     */
    var handleKeyDown = function handleKeyDown(event) {
      if (isNavigationKey(event)) {
        switch (event.key) {
          case 'ArrowDown':
            selectNextItem();
            event.preventDefault();
            event.stopPropagation();
            break;
          case 'ArrowUp':
            selectPreviousItem();
            event.preventDefault();
            event.stopPropagation();
            break;

          // TODO: DTR-1401 - why is this calling item click when hitting tab? fix this in DTR-1401
          case 'Tab':
            //Tab key quick inserts the selected item.
            onItemClick(_typeAhead.SelectItemMode.TAB, selectedIndex, _analytics.INPUT_METHOD.KEYBOARD);
            event.preventDefault();
            break;
          case 'Enter':
            //Enter key quick inserts the selected item.
            if (!event.isComposing || event.which !== 229 && event.keyCode !== 229) {
              onItemClick(event.shiftKey ? _typeAhead.SelectItemMode.SHIFT_ENTER : _typeAhead.SelectItemMode.ENTER, selectedIndex, _analytics.INPUT_METHOD.KEYBOARD);
              event.preventDefault();
            }
            break;
          default:
            event.preventDefault();
        }
      } else {
        //All the remaining keys sets focus on the typeahead query(inputQuery.tsx))
        focusTargetElement();
      }
    };
    // Ignored via go/ees005
    // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
    element === null || element === void 0 || element.addEventListener('keydown', handleKeyDown);
    return function () {
      // Ignored via go/ees005
      // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
      element === null || element === void 0 || element.removeEventListener('keydown', handleKeyDown);
    };
  }, [editorView.state, focusTargetElement, selectNextItem, selectPreviousItem, selectedIndex, onItemClick, itemsLength]);
  var firstOnlineSupportedRow = (0, _react.useMemo)(function () {
    return items.findIndex(function (item) {
      return item.isDisabledOffline !== true;
    });
  }, [items]);
  var renderRow = function renderRow(_ref4) {
    var index = _ref4.index,
      key = _ref4.key,
      style = _ref4.style,
      parent = _ref4.parent,
      isScrolling = _ref4.isScrolling,
      isVisible = _ref4.isVisible;
    var currentItem = items[index];
    return (0, _react2.jsx)(_CellMeasurer.CellMeasurer, {
      key: key,
      cache: cache,
      parent: parent,
      columnIndex: 0,
      rowIndex: index
    }, (0, _platformFeatureFlags.fg)('platform_editor_typeahead_dynamic_height_fix') ? function (_ref5) {
      var measure = _ref5.measure,
        registerChild = _ref5.registerChild;
      return (0, _react2.jsx)(_ListRow.ListRow, {
        registerChild: registerChild,
        measure: measure,
        index: index
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        ,
        style: style,
        isVisible: isVisible,
        isScrolling: isScrolling,
        onMouseMove: function onMouseMove(e) {
          return _onMouseMove(e, index);
        }
      }, (0, _react2.jsx)(_TypeAheadListItem.TypeAheadListItem, {
        key: items[index].title,
        item: currentItem,
        firstOnlineSupportedIndex: firstOnlineSupportedRow,
        itemsLength: itemsLength,
        itemIndex: index,
        selectedIndex: selectedIndex,
        onItemClick: function onItemClick(mode, index) {
          actions.onItemClick(mode, index, _analytics.INPUT_METHOD.MOUSE);
        },
        ariaLabel: (0, _utils.getTypeAheadListAriaLabels)(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl, currentItem).listItemAriaLabel,
        moreElementsInQuickInsertViewEnabled: moreElementsInQuickInsertViewEnabled,
        api: api
      }));
    } : (0, _react2.jsx)("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      style: style,
      "data-index": index
    }, (0, _react2.jsx)("div", {
      "data-testid": "list-item-height-observed-".concat(index),
      onMouseMove: function onMouseMove(e) {
        return _onMouseMove(e, index);
      }
    }, (0, _react2.jsx)(_TypeAheadListItem.TypeAheadListItem, {
      key: items[index].title,
      item: currentItem,
      firstOnlineSupportedIndex: firstOnlineSupportedRow,
      itemsLength: itemsLength,
      itemIndex: index,
      selectedIndex: selectedIndex,
      onItemClick: function onItemClick(mode, index) {
        actions.onItemClick(mode, index, _analytics.INPUT_METHOD.MOUSE);
      },
      ariaLabel: (0, _utils.getTypeAheadListAriaLabels)(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl, currentItem).listItemAriaLabel,
      moreElementsInQuickInsertViewEnabled: moreElementsInQuickInsertViewEnabled,
      api: api
    }))));
  };
  var popupAriaLabel = (0, _utils.getTypeAheadListAriaLabels)(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl).popupAriaLabel;
  if (!Array.isArray(items)) {
    return null;
  }
  var menuGroupId = ((_decorationElement$qu2 = decorationElement.querySelector("[role='combobox']")) === null || _decorationElement$qu2 === void 0 ? void 0 : _decorationElement$qu2.getAttribute('aria-controls')) || _constants.TYPE_AHEAD_DECORATION_ELEMENT_ID;
  var EmptyResultView = (0, _react2.jsx)(_compiled.Box, {
    paddingBlock: "space.150",
    paddingInline: "space.250"
  }, (0, _react2.jsx)(_compiled.Text, {
    align: "center",
    as: "p"
  }, intl.formatMessage(_typeAhead.typeAheadListMessages.emptySearchResults)), (0, _react2.jsx)(_compiled.Text, {
    align: "center",
    as: "p"
  }, intl.formatMessage(_typeAhead.typeAheadListMessages.emptySearchResultsSuggestion, {
    buttonName: (0, _react2.jsx)(_compiled.Text, {
      weight: "medium"
    }, intl.formatMessage(_messages.toolbarInsertBlockMessages.viewMore))
  })));
  var ListContent = (0, _react2.jsx)(_List.List, {
    rowRenderer: renderRow,
    ref: listRef
    // Skip rendering the view more button in the list
    ,
    rowCount: itemsLength,
    rowHeight: cache.rowHeight,
    onRowsRendered: onItemsRendered,
    width: LIST_WIDTH,
    onScroll: onScroll,
    height: height,
    overscanRowCount: 3
    // We need to make this walkaround to make TS happy, cannot pass undefined otherwise ReactVirualized will make it equal to "grid" which we want to avoid
    // https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/Grid.js#L260
    ,
    "aria-label": null,
    containerRole: "presentation",
    role: "listbox"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    ,
    css: [
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values
    (0, _react2.css)({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors -- Ignored via go/DSP-18766
      button: {
        padding: "var(--ds-space-150, 12px)".concat(" ", "var(--ds-space-150, 12px)", " 11px"),
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
        'span:last-child span:last-child': {
          whiteSpace: 'normal'
        }
      }
    }), moreElementsInQuickInsertViewEnabled && list]
  });
  return (0, _react2.jsx)(_menu.MenuGroup, {
    "aria-label": popupAriaLabel,
    "aria-relevant": "additions removals"
  }, (0, _react2.jsx)("div", {
    id: menuGroupId,
    ref: listContainerRef
  }, !showViewMore || itemsLength ? ListContent : EmptyResultView, showViewMore && onViewMoreClick && (0, _react2.jsx)(_ViewMore.ViewMore, {
    onClick: onViewMoreClick,
    isFocused: selectedIndex === itemsLength
  }), (0, _react2.jsx)(TypeaheadAssistiveTextPureComponent, {
    numberOfResults: itemsLength.toString()
  })));
});
var TypeAheadList = exports.TypeAheadList = (0, _reactIntlNext.injectIntl)(TypeAheadListComponent);
TypeAheadList.displayName = 'TypeAheadList';