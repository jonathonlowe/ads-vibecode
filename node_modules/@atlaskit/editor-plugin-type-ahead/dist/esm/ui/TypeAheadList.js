import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

import React, { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { injectIntl, useIntl } from 'react-intl-next';
import { CellMeasurer, CellMeasurerCache } from 'react-virtualized/dist/commonjs/CellMeasurer';
import { List } from 'react-virtualized/dist/commonjs/List';
import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { toolbarInsertBlockMessages as messages } from '@atlaskit/editor-common/messages';
import { SelectItemMode, typeAheadListMessages } from '@atlaskit/editor-common/type-ahead';
import { AssistiveText } from '@atlaskit/editor-common/ui';
import { MenuGroup } from '@atlaskit/menu';
import { fg } from '@atlaskit/platform-feature-flags';
import { Text, Box } from '@atlaskit/primitives/compiled';
import { updateSelectedIndex } from '../pm-plugins/commands/update-selected-index';
import { TYPE_AHEAD_DECORATION_ELEMENT_ID } from '../pm-plugins/constants';
import { getTypeAheadListAriaLabels, moveSelectedIndex } from '../pm-plugins/utils';
import { ListRow } from './ListRow';
import { TypeAheadListItem } from './TypeAheadListItem';
import { ViewMore } from './ViewMore';
var LIST_ITEM_ESTIMATED_HEIGHT = 64;
var LIST_WIDTH = 320;
var list = css({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  button: {
    padding: "var(--ds-space-100, 8px)".concat(" ", "var(--ds-space-150, 12px)")
  }
});
var TypeaheadAssistiveTextPureComponent = /*#__PURE__*/React.memo(function (_ref) {
  var numberOfResults = _ref.numberOfResults;
  var intl = useIntl();
  return jsx(AssistiveText, {
    assistiveText: intl.formatMessage(typeAheadListMessages.searchResultsLabel, {
      itemsLength: numberOfResults
    })
    // when the popup is open its always in focus
    ,
    isInFocus: true,
    id: TYPE_AHEAD_DECORATION_ELEMENT_ID + '__popup'
  });
});
var TypeAheadListComponent = /*#__PURE__*/React.memo(function (_ref2) {
  var _decorationElement$qu2;
  var items = _ref2.items,
    selectedIndex = _ref2.selectedIndex,
    editorView = _ref2.editorView,
    onItemClick = _ref2.onItemClick,
    intl = _ref2.intl,
    fitHeight = _ref2.fitHeight,
    decorationElement = _ref2.decorationElement,
    triggerHandler = _ref2.triggerHandler,
    moreElementsInQuickInsertViewEnabled = _ref2.moreElementsInQuickInsertViewEnabled,
    api = _ref2.api,
    showViewMore = _ref2.showViewMore,
    onViewMoreClick = _ref2.onViewMoreClick;
  var listRef = useRef();
  var listContainerRef = useRef(null);
  var lastVisibleIndexes = useRef({
    overscanStartIndex: 0,
    overscanStopIndex: 0,
    startIndex: 0,
    stopIndex: 0
  });

  // Exclude view more item from the count
  var itemsLength = showViewMore ? items.length - 1 : items.length;
  var estimatedHeight = itemsLength * LIST_ITEM_ESTIMATED_HEIGHT;
  var _useState = useState(Math.min(estimatedHeight, fitHeight)),
    _useState2 = _slicedToArray(_useState, 2),
    height = _useState2[0],
    setHeight = _useState2[1];
  var _useState3 = useState(new CellMeasurerCache({
      fixedWidth: true,
      defaultHeight: LIST_ITEM_ESTIMATED_HEIGHT
    })),
    _useState4 = _slicedToArray(_useState3, 2),
    cache = _useState4[0],
    setCache = _useState4[1];
  var onItemsRendered = useCallback(function (props) {
    lastVisibleIndexes.current = props;
  }, []);
  var actions = useMemo(function () {
    return {
      onItemClick: onItemClick
    };
  }, [onItemClick]);
  var isNavigationKey = function isNavigationKey(event) {
    return ['ArrowDown', 'ArrowUp', 'Tab', 'Enter'].includes(event.key);
  };
  var focusTargetElement = useCallback(function () {
    var _decorationElement$qu;
    //To reset the selected index
    updateSelectedIndex(-1, api)(editorView.state, editorView.dispatch);
    listRef.current.scrollToRow(0);
    decorationElement === null || decorationElement === void 0 || (_decorationElement$qu = decorationElement.querySelector("[role='combobox']")) === null || _decorationElement$qu === void 0 || _decorationElement$qu.focus();
  }, [editorView, listRef, decorationElement, api]);
  var selectNextItem = useMemo(function () {
    return moveSelectedIndex({
      editorView: editorView,
      direction: 'next',
      api: api
    });
  }, [editorView, api]);
  var selectPreviousItem = useMemo(function () {
    return moveSelectedIndex({
      editorView: editorView,
      direction: 'previous',
      api: api
    });
  }, [editorView, api]);
  var lastVisibleStartIndex = lastVisibleIndexes.current.startIndex;
  var lastVisibleStopIndex = lastVisibleIndexes.current.stopIndex;
  var onScroll = useCallback(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function (_ref3) {
    var scrollUpdateWasRequested = _ref3.scrollUpdateWasRequested;
    if (!scrollUpdateWasRequested) {
      return;
    }

    // In case the user scroll to a non-visible item like press ArrowUp from the first index
    // We will force the scroll calling the scrollToItem in the useEffect hook
    // When the scroll happens and we render the elements,
    // we still need calculate the items height and re-draw the List.
    // It is possible the item selected became invisible again (because the items height changed)
    // So, we need to wait for height to be calculated. Then we need to check
    // if the selected item is visible or not. If it isn't visible we call the scrollToItem again.
    //
    // We can't do this check in the first frame because that frame is being used by the resetScreenThrottled
    // to calculate each height. THen, we can schedule a new frame when this one finishs.
    requestAnimationFrame(function () {
      requestAnimationFrame(function () {
        var isViewMoreSelected = showViewMore && selectedIndex === itemsLength;
        var isSelectedItemVisible = selectedIndex >= lastVisibleStartIndex && selectedIndex <= lastVisibleStopIndex ||
        // view more is always visible, hence no scrolling
        isViewMoreSelected;

        //Should scroll to the list item only when the selectedIndex >= 0 and item is not visible
        if (!isSelectedItemVisible && selectedIndex !== -1) {
          listRef.current.scrollToRow(selectedIndex);
        } else if (selectedIndex === -1) {
          listRef.current.scrollToRow(0);
        }
      });
    });
  }, [selectedIndex, lastVisibleStartIndex, lastVisibleStopIndex, itemsLength, showViewMore]);
  var _onMouseMove = function onMouseMove(event, index) {
    event.preventDefault();
    event.stopPropagation();
    if (selectedIndex === index) {
      return;
    }
    updateSelectedIndex(index, api)(editorView.state, editorView.dispatch);
  };
  useLayoutEffect(function () {
    if (!listRef.current) {
      return;
    }
    var isViewMoreSelected = showViewMore && selectedIndex === itemsLength;
    var isSelectedItemVisible = selectedIndex >= lastVisibleStartIndex && selectedIndex <= lastVisibleStopIndex ||
    // view more is always visible, hence no scrolling
    isViewMoreSelected;

    //Should scroll to the list item only when the selectedIndex >= 0 and item is not visible
    if (!isSelectedItemVisible && selectedIndex !== -1) {
      listRef.current.scrollToRow(selectedIndex);
    } else if (selectedIndex === -1) {
      listRef.current.scrollToRow(0);
    }
  }, [selectedIndex, lastVisibleStartIndex, lastVisibleStopIndex, itemsLength, showViewMore]);
  useLayoutEffect(function () {
    setCache(new CellMeasurerCache({
      fixedWidth: true,
      defaultHeight: LIST_ITEM_ESTIMATED_HEIGHT
    }));
    // When query is updated, sometimes the scroll position of the menu is not at the top
    // Scrolling back to top for consistency
    requestAnimationFrame(function () {
      var _listContainerRef$cur;
      if ((_listContainerRef$cur = listContainerRef.current) !== null && _listContainerRef$cur !== void 0 && _listContainerRef$cur.firstChild) {
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        listContainerRef.current.firstChild.scrollTo(0, 0);
      }
    });
  }, [items]);
  useLayoutEffect(function () {
    // Exclude view more item from the count
    var itemsToRender = showViewMore ? items.slice(0, -1) : items;
    var height = Math.min(itemsToRender.reduce(function (prevValue, currentValue, index) {
      return prevValue + cache.rowHeight({
        index: index
      });
    }, 0), fitHeight);
    setHeight(height);
  }, [items, cache, fitHeight, showViewMore]);
  useLayoutEffect(function () {
    if (!listContainerRef.current) {
      return;
    }
    var element = listContainerRef.current;
    /**
     * To handle the key events on the list
     * @param event
     */
    var handleKeyDown = function handleKeyDown(event) {
      if (isNavigationKey(event)) {
        switch (event.key) {
          case 'ArrowDown':
            selectNextItem();
            event.preventDefault();
            event.stopPropagation();
            break;
          case 'ArrowUp':
            selectPreviousItem();
            event.preventDefault();
            event.stopPropagation();
            break;

          // TODO: DTR-1401 - why is this calling item click when hitting tab? fix this in DTR-1401
          case 'Tab':
            //Tab key quick inserts the selected item.
            onItemClick(SelectItemMode.TAB, selectedIndex, INPUT_METHOD.KEYBOARD);
            event.preventDefault();
            break;
          case 'Enter':
            //Enter key quick inserts the selected item.
            if (!event.isComposing || event.which !== 229 && event.keyCode !== 229) {
              onItemClick(event.shiftKey ? SelectItemMode.SHIFT_ENTER : SelectItemMode.ENTER, selectedIndex, INPUT_METHOD.KEYBOARD);
              event.preventDefault();
            }
            break;
          default:
            event.preventDefault();
        }
      } else {
        //All the remaining keys sets focus on the typeahead query(inputQuery.tsx))
        focusTargetElement();
      }
    };
    // Ignored via go/ees005
    // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
    element === null || element === void 0 || element.addEventListener('keydown', handleKeyDown);
    return function () {
      // Ignored via go/ees005
      // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
      element === null || element === void 0 || element.removeEventListener('keydown', handleKeyDown);
    };
  }, [editorView.state, focusTargetElement, selectNextItem, selectPreviousItem, selectedIndex, onItemClick, itemsLength]);
  var firstOnlineSupportedRow = useMemo(function () {
    return items.findIndex(function (item) {
      return item.isDisabledOffline !== true;
    });
  }, [items]);
  var renderRow = function renderRow(_ref4) {
    var index = _ref4.index,
      key = _ref4.key,
      style = _ref4.style,
      parent = _ref4.parent,
      isScrolling = _ref4.isScrolling,
      isVisible = _ref4.isVisible;
    var currentItem = items[index];
    return jsx(CellMeasurer, {
      key: key,
      cache: cache,
      parent: parent,
      columnIndex: 0,
      rowIndex: index
    }, fg('platform_editor_typeahead_dynamic_height_fix') ? function (_ref5) {
      var measure = _ref5.measure,
        registerChild = _ref5.registerChild;
      return jsx(ListRow, {
        registerChild: registerChild,
        measure: measure,
        index: index
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
        ,
        style: style,
        isVisible: isVisible,
        isScrolling: isScrolling,
        onMouseMove: function onMouseMove(e) {
          return _onMouseMove(e, index);
        }
      }, jsx(TypeAheadListItem, {
        key: items[index].title,
        item: currentItem,
        firstOnlineSupportedIndex: firstOnlineSupportedRow,
        itemsLength: itemsLength,
        itemIndex: index,
        selectedIndex: selectedIndex,
        onItemClick: function onItemClick(mode, index) {
          actions.onItemClick(mode, index, INPUT_METHOD.MOUSE);
        },
        ariaLabel: getTypeAheadListAriaLabels(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl, currentItem).listItemAriaLabel,
        moreElementsInQuickInsertViewEnabled: moreElementsInQuickInsertViewEnabled,
        api: api
      }));
    } : jsx("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      style: style,
      "data-index": index
    }, jsx("div", {
      "data-testid": "list-item-height-observed-".concat(index),
      onMouseMove: function onMouseMove(e) {
        return _onMouseMove(e, index);
      }
    }, jsx(TypeAheadListItem, {
      key: items[index].title,
      item: currentItem,
      firstOnlineSupportedIndex: firstOnlineSupportedRow,
      itemsLength: itemsLength,
      itemIndex: index,
      selectedIndex: selectedIndex,
      onItemClick: function onItemClick(mode, index) {
        actions.onItemClick(mode, index, INPUT_METHOD.MOUSE);
      },
      ariaLabel: getTypeAheadListAriaLabels(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl, currentItem).listItemAriaLabel,
      moreElementsInQuickInsertViewEnabled: moreElementsInQuickInsertViewEnabled,
      api: api
    }))));
  };
  var popupAriaLabel = getTypeAheadListAriaLabels(triggerHandler === null || triggerHandler === void 0 ? void 0 : triggerHandler.trigger, intl).popupAriaLabel;
  if (!Array.isArray(items)) {
    return null;
  }
  var menuGroupId = ((_decorationElement$qu2 = decorationElement.querySelector("[role='combobox']")) === null || _decorationElement$qu2 === void 0 ? void 0 : _decorationElement$qu2.getAttribute('aria-controls')) || TYPE_AHEAD_DECORATION_ELEMENT_ID;
  var EmptyResultView = jsx(Box, {
    paddingBlock: "space.150",
    paddingInline: "space.250"
  }, jsx(Text, {
    align: "center",
    as: "p"
  }, intl.formatMessage(typeAheadListMessages.emptySearchResults)), jsx(Text, {
    align: "center",
    as: "p"
  }, intl.formatMessage(typeAheadListMessages.emptySearchResultsSuggestion, {
    buttonName: jsx(Text, {
      weight: "medium"
    }, intl.formatMessage(messages.viewMore))
  })));
  var ListContent = jsx(List, {
    rowRenderer: renderRow,
    ref: listRef
    // Skip rendering the view more button in the list
    ,
    rowCount: itemsLength,
    rowHeight: cache.rowHeight,
    onRowsRendered: onItemsRendered,
    width: LIST_WIDTH,
    onScroll: onScroll,
    height: height,
    overscanRowCount: 3
    // We need to make this walkaround to make TS happy, cannot pass undefined otherwise ReactVirualized will make it equal to "grid" which we want to avoid
    // https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/Grid.js#L260
    ,
    "aria-label": null,
    containerRole: "presentation",
    role: "listbox"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    ,
    css: [
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values
    css({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors -- Ignored via go/DSP-18766
      button: {
        padding: "var(--ds-space-150, 12px)".concat(" ", "var(--ds-space-150, 12px)", " 11px"),
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
        'span:last-child span:last-child': {
          whiteSpace: 'normal'
        }
      }
    }), moreElementsInQuickInsertViewEnabled && list]
  });
  return jsx(MenuGroup, {
    "aria-label": popupAriaLabel,
    "aria-relevant": "additions removals"
  }, jsx("div", {
    id: menuGroupId,
    ref: listContainerRef
  }, !showViewMore || itemsLength ? ListContent : EmptyResultView, showViewMore && onViewMoreClick && jsx(ViewMore, {
    onClick: onViewMoreClick,
    isFocused: selectedIndex === itemsLength
  }), jsx(TypeaheadAssistiveTextPureComponent, {
    numberOfResults: itemsLength.toString()
  })));
});
export var TypeAheadList = injectIntl(TypeAheadListComponent);
TypeAheadList.displayName = 'TypeAheadList';