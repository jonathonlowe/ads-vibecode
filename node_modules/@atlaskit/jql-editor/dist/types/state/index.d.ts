import { type FocusEvent, type MouseEvent } from 'react';
import { type IntlShape } from 'react-intl-next';
import { type Action } from 'react-sweet-state';
import { type Observable } from 'rxjs/Observable';
import { type EditorState, type Transaction } from '@atlaskit/editor-prosemirror/state';
import { EditorView } from '@atlaskit/editor-prosemirror/view';
import { type JQLParseError } from '@atlaskit/jql-ast';
import { type JQLRuleSuggestion } from '@atlaskit/jql-autocomplete';
import { type JqlEditorAnalyticsEvent } from '../analytics';
import { type AutocompleteOptionGroup, type AutocompleteOptions, type AutocompleteOptionType, type SelectableAutocompleteOption } from '../plugins/autocomplete/components/types';
import { type AutocompleteProvider } from '../plugins/types';
import { type PortalActions } from '../ui/jql-editor-portal-provider/types';
import { type HydratedDeprecatedField, type HydratedUser, type HydratedValue } from '../ui/jql-editor/types';
import { type AutocompletePosition, type AutocompleteState, type ContextAwareJQLSuggestions, type CustomErrorComponent, type ExternalMessagesNormalized, type OptionsKey, type Props, type State } from './types';
export declare const initialState: State;
export declare const actions: {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
};
export declare const useStoreActions: import("react-sweet-state").HookFunction<null, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useEditorState: import("react-sweet-state").HookFunction<EditorState, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useEditorView: import("react-sweet-state").HookFunction<EditorView | undefined, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useIsSearching: import("react-sweet-state").HookFunction<boolean | undefined, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useIntl: import("react-sweet-state").HookFunction<IntlShape, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocompleteProvider: import("react-sweet-state").HookFunction<AutocompleteProvider, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useScopedId: import("react-sweet-state").HookFunction<string, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, string>;
export declare const useIdPrefix: import("react-sweet-state").HookFunction<string, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useEditorViewHasFocus: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useLineNumbersVisible: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocomplete: import("react-sweet-state").HookFunction<AutocompleteState, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
/**
 * Returns the JQL error from the last query that was searched, or {@code null} if there were none.
 */
export declare const useJqlError: import("react-sweet-state").HookFunction<JQLParseError | null, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
/**
 * Returns whether there are any JQL errors in the current Prosemirror editor state.
 */
export declare const useEditorStateHasJqlError: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useExternalMessages: import("react-sweet-state").HookFunction<ExternalMessagesNormalized, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useCustomErrorComponent: import("react-sweet-state").HookFunction<CustomErrorComponent | undefined, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocompleteOptions: import("react-sweet-state").HookFunction<SelectableAutocompleteOption[], import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocompleteLoading: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocompleteIsOpen: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useAutocompletePosition: import("react-sweet-state").HookFunction<AutocompletePosition, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useHydratedValue: import("react-sweet-state").HookFunction<HydratedValue | undefined, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, {
    fieldName: string;
    id: string;
}>;
export declare const useHydratedUser: import("react-sweet-state").HookFunction<HydratedUser | undefined, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, {
    fieldName: string;
    id: string;
}>;
export declare const useHydratedDeprecations: import("react-sweet-state").HookFunction<HydratedDeprecatedField[], import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useRichInlineNodesEnabled: import("react-sweet-state").HookFunction<boolean, import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const useOnSyntaxHelp: import("react-sweet-state").HookFunction<void | ((e: MouseEvent<HTMLElement>) => boolean), import("react-sweet-state").BoundActions<State, {
    onEditorViewBlur: () => Action<State>;
    onEditorViewFocus: (event: FocusEvent<HTMLElement>) => Action<State, Props>;
    openAutocompleteOnNextUpdate: () => Action<State>;
    closeAutocomplete: () => Action<State>;
    setSelectedAutocompleteOptionId: (selectedOptionId: string | undefined) => Action<State>;
    getAutocompleteSuggestions: (editorState: EditorState) => Action<State>;
    getAutocompleteOptions: (suggestions: ContextAwareJQLSuggestions) => Action<State>;
    appendOptionsForObservable: (key: OptionsKey, observable: Observable<AutocompleteOptions>, rule: JQLRuleSuggestion, type: AutocompleteOptionType) => Action<State, void, Observable<AutocompleteOptions>>;
    cancelSubscription: () => Action<State>;
    setLoading: (loading: boolean) => Action<State>;
    setAutocompleteOptions: (options: AutocompleteOptionGroup) => Action<State>;
    setAutocompleteContainer: (container: HTMLElement | null) => Action<State>;
    callAutocompleteProviders: ({ rules, tokens }: ContextAwareJQLSuggestions) => Action<State>;
    updateValidationState: () => Action<State>;
    initialiseEditorState: () => Action<State, Props>;
    configurePlugins: (portalActions: PortalActions | void) => Action<State, Props>;
    onApplyEditorTransaction: (transaction: Transaction) => Action<State, Props>;
    resetEditorState: (query: string, addToHistory?: boolean) => Action<State>;
    initialiseEditorView: (editorViewNode: HTMLElement, attributes: {
        [key: string]: string;
    }, portalActions: PortalActions) => Action<State, Props>;
    updateEditorView: (attributes: {
        [key: string]: string;
    }) => Action<State, Props>;
    setEditorViewContainer: (editorViewContainer: HTMLElement) => Action<State>;
    setEditorViewContainerScroll: (scroll: number) => Action<State>;
    onSearch: () => Action<State>;
    onSearchCommand: (pmState: EditorState, pmDispatch: ((tr: Transaction) => void) | undefined, pmView: EditorView | undefined, keyboardShortcut: boolean) => Action<State, Props, boolean>;
    externalErrorMessageViewed: () => Action<State, Props>;
    createAndFireAnalyticsEvent: (payload: JqlEditorAnalyticsEvent) => Action<State, Props>;
}>, void>;
export declare const EditorStateContainer: import("react-sweet-state").OverrideContainerComponent<Props>;
