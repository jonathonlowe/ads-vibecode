import _defineProperty from "@babel/runtime/helpers/defineProperty";
import escapeRegExp from 'lodash/escapeRegExp';
import uuidv5 from 'uuid/v5';
import { AbstractJastVisitor } from '@atlaskit/jql-ast';
import getDocumentPosition from '../plugins/common/get-document-position';
import { getNodeText } from '../utils/document-text';
// Unique namespace to identify JQL autocomplete options!
const UUID_NAMESPACE = '9a90299c-aa58-494b-b6a1-e93206e3fdd6';
export const getAutocompleteOptionId = value => uuidv5(value, UUID_NAMESPACE);
export const tokensToAutocompleteOptions = tokens => {
  let tokensToDisplay = tokens.values;
  if (tokens.matchedText !== '') {
    // Candidates that start with last token text but are not an exact match (case insensitive)
    const regex = new RegExp(`^${escapeRegExp(tokens.matchedText)}[^$]`, 'i');
    tokensToDisplay = tokens.values.filter(token => regex.test(token));
  }
  return tokensToDisplay.map(token => {
    var _tokens$context;
    return {
      id: getAutocompleteOptionId(token),
      name: token,
      value: token,
      replacePosition: tokens.replacePosition,
      matchedText: tokens.matchedText,
      context: (_tokens$context = tokens.context) !== null && _tokens$context !== void 0 ? _tokens$context : null,
      type: 'keyword'
    };
  });
};
export const getReplacePositionStart = ({
  rules,
  tokens
}) => {
  // Matching tokens should be prioritized over rules when calculating autocomplete dropdown position
  if (tokens.values.length) {
    return tokens.replacePosition[0];
  }

  // Same precedence as `useAutocompleteOptions`, this may change in future if we don't limit suggestions to one rule
  const rulePrecedence = ['value', 'function', 'list', 'operator', 'field'];
  for (const rule of rulePrecedence) {
    if (Object.prototype.hasOwnProperty.call(rules, rule)) {
      return rules[rule].replacePosition[0];
    }
  }
  return tokens.replacePosition[0];
};
export const getAutocompletePosition = (editorView, replacePositionStart) => {
  const {
    doc,
    selection
  } = editorView.state;
  const documentPosition = getDocumentPosition(doc, replacePositionStart);
  const {
    left
  } = editorView.coordsAtPos(documentPosition);
  // Vertically position autocomplete relative to selection end
  const {
    bottom
  } = editorView.coordsAtPos(selection.to);
  return {
    top: bottom,
    left
  };
};
const getDebugSelectionAttributes = () => {
  var _selection$anchorNode, _selection$anchorNode2, _selection$focusNode, _selection$focusNode2;
  const selection = document.getSelection();
  if (selection === null || selection.type === 'None') {
    return {};
  }
  return {
    anchorOffset: selection.anchorOffset,
    anchorNodeText: (_selection$anchorNode = selection.anchorNode) === null || _selection$anchorNode === void 0 ? void 0 : _selection$anchorNode.textContent,
    anchorNodeName: (_selection$anchorNode2 = selection.anchorNode) === null || _selection$anchorNode2 === void 0 ? void 0 : _selection$anchorNode2.nodeName,
    focusOffset: selection.focusOffset,
    focusNodeText: (_selection$focusNode = selection.focusNode) === null || _selection$focusNode === void 0 ? void 0 : _selection$focusNode.textContent,
    focusNodeName: (_selection$focusNode2 = selection.focusNode) === null || _selection$focusNode2 === void 0 ? void 0 : _selection$focusNode2.nodeName
  };
};
export const sendDebugMessage = (message, editorView, editorState, onDebugUnsafeMessage, eventAttributes) => {
  if (!onDebugUnsafeMessage) {
    return;
  }
  try {
    const editorViewStateText = getNodeText(editorView.state.doc, 0, editorView.state.doc.content.size);
    const editorViewStateJson = JSON.stringify(editorView.state.toJSON());
    const editorStateJson = JSON.stringify(editorState.toJSON());
    const editorViewHtml = editorView.dom.innerHTML;
    onDebugUnsafeMessage(message, {
      editorStateJson,
      editorViewStateText,
      editorViewStateJson,
      editorViewHtml,
      ...getDebugSelectionAttributes(),
      ...eventAttributes
    });
  } catch (ignored) {
    // Do nothing
  }
};
export const getFieldNodes = ast => {
  if (!ast.query) {
    return new Set();
  }
  const visitor = new FindFieldsVisitor();
  ast.query.accept(visitor);
  return visitor.fields;
};
class FindFieldsVisitor extends AbstractJastVisitor {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "fields", new Set());
    _defineProperty(this, "visitQuery", query => {
      if (query.where !== undefined) {
        query.where.accept(this);
      }
      if (query.orderBy !== undefined) {
        query.orderBy.accept(this);
      }
    });
    _defineProperty(this, "visitOrderBy", orderBy => {
      orderBy.fields.map(orderByField => orderByField.accept(this));
    });
    _defineProperty(this, "visitOrderByField", orderByField => {
      orderByField.field.accept(this);
    });
    _defineProperty(this, "visitCompoundClause", compoundClause => {
      compoundClause.clauses.map(clause => clause.accept(this));
    });
    _defineProperty(this, "visitTerminalClause", terminalClause => {
      terminalClause.field.accept(this);
    });
    _defineProperty(this, "visitNotClause", notClause => {
      notClause.clause.accept(this);
    });
    _defineProperty(this, "visitField", field => {
      this.fields.add(field.value.toLowerCase());
    });
  }
  defaultResult() {
    return;
  }
}