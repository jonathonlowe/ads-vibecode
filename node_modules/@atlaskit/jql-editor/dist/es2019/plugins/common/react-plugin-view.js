import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { useEffect, useState } from 'react';
import { Subject } from 'rxjs/Subject';
/**
 * Abstract class for Prosemirror plugin views which need to mount a React component. Concrete subclasses must implement
 * {@link ReactPluginView#getComponent} which specifies the React component to render, along with
 * {@link ReactPluginView#getInitialComponentProps} which returns any props to pass to the component on initial render.
 *
 * After the class is constructed, the caller must invoke {@link ReactPluginView#init} in order to mount the component.
 *
 * If there are external changes which the component needs to respond to, {@link ReactPluginView#componentSubject} can
 * be used to trigger a re-render of the component with updated props. For example:
 * ```
 * update = (view: EditorView) => {
 *   this.componentSubject.next(this.getComponentProps(view));
 * };
 *
 * getComponentProps = (view: EditorView) => {
 *   // Some logic to get props from the Prosemirror view
 * }
 * ```
 */
export default class ReactPluginView {
  /**
   * Construct a Prosemirror plugin view which will render a React component in a portal.
   *
   * @param portalActions Provides callback functions which can be invoked to create and destroy a portal.
   * @param portalKey Unique identifier for the plugin component.
   * @param containerKey Key representing the HTML container the React component will be portalled into.
   * @protected
   */
  constructor(portalActions, portalKey, containerKey) {
    _defineProperty(this, "componentSubject", new Subject());
    _defineProperty(this, "init", () => {
      const Component = this.getComponent();
      const PortallingComponent = () => {
        const [state, setState] = useState(() => this.getInitialComponentProps());
        useEffect(() => {
          // Subscribe to the RxJS subject so concrete subclasses can emit events to re-render the plugin component.
          const subscription = this.componentSubject.subscribe(updatedProps => {
            setState(updatedProps);
          });
          return () => subscription.unsubscribe();
        }, []);
        return /*#__PURE__*/React.createElement(Component, state);
      };

      // Dispatch onCreatePortal which will allow the handler to create a new portalled React component
      this.portalActions.onCreatePortal(this.portalKey, /*#__PURE__*/React.createElement(PortallingComponent, null), this.containerKey);
    });
    this.portalActions = portalActions;
    this.portalKey = portalKey;
    this.containerKey = containerKey;
  }
  destroy() {
    // Dispatch onDestroyPortal which will allow the handler to remove the portalled React component.
    this.portalActions.onDestroyPortal(this.portalKey);
  }

  /**
   * Return a React component to render for the plugin.
   */

  /**
   * Return props to set on the component for initial render.
   */
}