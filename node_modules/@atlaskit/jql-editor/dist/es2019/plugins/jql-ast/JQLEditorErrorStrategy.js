import { DefaultErrorStrategy } from 'antlr4ts';
import padStart from 'lodash/padStart';
import { normaliseJqlString } from '@atlaskit/jql-ast';
import { JQLAutocomplete } from '@atlaskit/jql-autocomplete';
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import { ignoredTokens, preferredRules } from './constants';
import { handleCustomFieldRuleError } from './error-handlers/CustomFieldRuleErrorHandler';
import { handleExpectedTokensError } from './error-handlers/ExpectedTokensErrorHandler';
import { handleFieldPropertyIdRuleError } from './error-handlers/FieldPropertyIdErrorHandler';
import { handleFieldRuleError } from './error-handlers/FieldRuleErrorHandler';
import { handleFunctionArgumentRuleError } from './error-handlers/FunctionArgumentRuleErrorHandler';
import { handleOperandRuleError } from './error-handlers/OperandRuleErrorHandler';
import { handleOperatorRuleError } from './error-handlers/OperatorRuleErrorHandler';
import { errorMessages } from './messages';
import { getExpectedTokensFromParserOrException } from './utils';
const isEscape = char => char === '\\';
export const getPrintableChar = char => {
  const hex = char.charCodeAt(0).toString(16).toUpperCase();
  return `U+${padStart(hex, 4, '0')}`;
};
export const getJavaCodeFromChar = char => {
  const hex = char.charCodeAt(0).toString(16);
  return `\\u${padStart(hex, 4, '0')}`;
};
export default class JQLEditorErrorStrategy extends DefaultErrorStrategy {
  constructor(intlRef) {
    super();
    this.intlRef = intlRef;
  }
  reportInputMismatch(recognizer, exception) {
    this.handleSyntaxError(recognizer, recognizer.currentToken, exception);
  }
  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    this.handleSyntaxError(recognizer, recognizer.currentToken);
  }
  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);

    // This is called when single token insertion is a viable recovery strategy for the error. In this case we can
    // use expected tokens from the parser to display an error to the user. If there are no viable tokens to show then
    // we should fallback to syntax error handling.
    if (getExpectedTokensFromParserOrException(recognizer).length > 0) {
      const message = handleExpectedTokensError(recognizer, recognizer.currentToken,
      // We want to derive expectedTokens from the parser state
      [], this.intlRef.current);
      recognizer.notifyErrorListeners(message, recognizer.currentToken, undefined);
    } else {
      this.handleSyntaxError(recognizer, recognizer.currentToken);
    }
  }
  reportNoViableAlternative(recognizer, exception) {
    var _exception$getOffendi;
    // There are some cases, like "status was", where parser is unable to provide viable alternatives for current
    // token, but autocomplete engine is still able to provide meaningful suggestions at offending token index
    const currentToken = (_exception$getOffendi = exception === null || exception === void 0 ? void 0 : exception.getOffendingToken()) !== null && _exception$getOffendi !== void 0 ? _exception$getOffendi : recognizer.currentToken;
    this.handleSyntaxError(recognizer, currentToken, exception);
  }
  reportFailedPredicate(recognizer, e) {
    // TODO: Don't know how to produce this error. Monitor if this happens and defer to default implementation
    super.reportFailedPredicate(recognizer, e);
  }
  handleSyntaxError(recognizer, currentToken, exception) {
    let message;
    switch (currentToken.type) {
      /*
       * This is called when ANTLR finds a character that the grammar does not recognise. The grammar lexer uses
       * a DFA to decide if a character is in error or not. This can mean that legal characters come as an error
       * because they do not form a valid token. Because of this we have to do some extra checks here.
       */
      case JQLLexer.ERRORCHAR:
      case JQLLexer.INVALID_QUOTE_STRING:
      case JQLLexer.INVALID_SQUOTE_STRING:
        {
          let currentText = currentToken.text;

          // These tokens are returned when an illegal character appears at the end of a quote string, but the token
          // includes the entire quoted text. We take the last character from our text as that's the offending token.
          if (currentToken.type === JQLLexer.INVALID_QUOTE_STRING || currentToken.type === JQLLexer.INVALID_SQUOTE_STRING) {
            var _currentText;
            currentText = (_currentText = currentText) === null || _currentText === void 0 ? void 0 : _currentText.slice(-1);
          }

          // This can happen (e.g. comment ~ \)
          if (isEscape(currentText)) {
            const nextToken = recognizer.inputStream.get(currentToken.tokenIndex + 1);
            if (nextToken.type === JQLLexer.MATCHWS || nextToken.type === JQLLexer.EOF) {
              message = this.intlRef.current.formatMessage(errorMessages.illegalEscapeBlank);
            } else {
              var _currentText2, _nextToken$text;
              // Show the escaped character sequence in the message
              const received = `${(_currentText2 = currentText) !== null && _currentText2 !== void 0 ? _currentText2 : ''}${(_nextToken$text = nextToken.text) !== null && _nextToken$text !== void 0 ? _nextToken$text : ''}`;
              message = this.intlRef.current.formatMessage(errorMessages.illegalEscape, {
                received
              });
            }
          } else {
            var _currentText3, _currentText4;
            message = this.intlRef.current.formatMessage(errorMessages.illegalChar, {
              char: getPrintableChar((_currentText3 = currentText) !== null && _currentText3 !== void 0 ? _currentText3 : ''),
              escapedChar: getJavaCodeFromChar((_currentText4 = currentText) !== null && _currentText4 !== void 0 ? _currentText4 : '')
            });
          }
          break;
        }
      // Special tokens that get created every time there is an unfinished string (i.e. without matching closing quote)
      case JQLLexer.UNCLOSED_QUOTE_STRING:
      case JQLLexer.UNCLOSED_SQUOTE_STRING:
        {
          var _currentToken$text;
          const received = normaliseJqlString((_currentToken$text = currentToken.text) !== null && _currentToken$text !== void 0 ? _currentToken$text : '');
          if (received === '') {
            message = this.intlRef.current.formatMessage(errorMessages.unfinishedStringBlank);
          } else {
            message = this.intlRef.current.formatMessage(errorMessages.unfinishedString, {
              received
            });
          }
          break;
        }
      case JQLLexer.RESERVED_WORD:
        {
          message = this.intlRef.current.formatMessage(errorMessages.reservedWord, {
            word: currentToken.text
          });
          break;
        }
      case JQLLexer.ERROR_RESERVED:
        {
          var _currentToken$text2;
          message = this.intlRef.current.formatMessage(errorMessages.reservedChar, {
            char: currentToken.text,
            escapedChar: getJavaCodeFromChar((_currentToken$text2 = currentToken.text) !== null && _currentToken$text2 !== void 0 ? _currentToken$text2 : '')
          });
          break;
        }
      default:
        {
          const autocomplete = JQLAutocomplete.fromParser(recognizer, ignoredTokens, preferredRules, new Set());
          const {
            tokens,
            rules
          } = autocomplete.getJQLSuggestionsForTokenIndex(currentToken.tokenIndex);
          if (rules.value || rules.list ||
          // Restrict function rules to only be shown if we are currently INSIDE a function rule. Otherwise this error
          // message would be shown for incomplete tokens following an operand, e.g. `status = open ord`.
          rules.function && recognizer.context.ruleIndex === JQLParser.RULE_jqlFunction) {
            message = handleOperandRuleError(recognizer, currentToken, tokens.values, rules, this.intlRef.current, exception);
          } else if (tokens.values.includes('EMPTY')) {
            message = handleExpectedTokensError(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
          } else if (rules.operator) {
            message = handleOperatorRuleError(currentToken, this.intlRef.current);
          } else if (rules.field) {
            message = handleFieldRuleError(currentToken, this.intlRef.current);
          } else if (rules.customField) {
            message = handleCustomFieldRuleError(this.intlRef.current);
          }
          // Restrict field property rules to only be shown if we are currently INSIDE a field property. Otherwise this
          // error message would be shown for incomplete tokens following a field, e.g. `ORDER BY issuetype as`.
          else if (rules.fieldProperty && recognizer.context.ruleIndex === JQLParser.RULE_jqlFieldProperty) {
            // Shows the correct message when a field property rule hasn't been completed, e.g. `issuetype[abc!`
            message = handleExpectedTokensError(recognizer, currentToken,
            // We want to derive expectedTokens from the exception/parser state
            [], this.intlRef.current, exception);
          } else if (rules.fieldPropertyId) {
            message = handleFieldPropertyIdRuleError(currentToken, this.intlRef.current);
          } else if (rules.functionArgument) {
            message = handleFunctionArgumentRuleError(currentToken, this.intlRef.current);
          } else {
            message = handleExpectedTokensError(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
          }
          break;
        }
    }
    recognizer.notifyErrorListeners(message, currentToken, undefined);
  }
}