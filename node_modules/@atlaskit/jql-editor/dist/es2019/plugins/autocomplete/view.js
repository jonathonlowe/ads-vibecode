import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { Fragment, Slice } from '@atlaskit/editor-prosemirror/model';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { isListOperator } from '@atlaskit/jql-ast';
import getDocumentPosition from '../common/get-document-position';
import ReactPluginView from '../common/react-plugin-view';
import Autocomplete from './components/autocomplete';
import { AUTOCOMPLETE_PLUGIN_NAME, JQLAutocompletePluginKey } from './constants';

/**
 * Returns whether an opening parenthesis should be automatically inserted for this option (e.g. after a list operator)
 */
const shouldInsertOpeningParenthesis = ({
  type,
  context,
  isListFunction
}) => {
  if (type === 'value' || type === 'function' || type === 'keyword') {
    const operator = context === null || context === void 0 ? void 0 : context.operator;
    if (operator && isListOperator(operator) && !(context !== null && context !== void 0 && context.isList) && !isListFunction) {
      return true;
    }
  }
  return false;
};
export default class AutocompletePluginView extends ReactPluginView {
  constructor(view, keymap, portalActions, enableRichInlineNodes) {
    super(portalActions, AUTOCOMPLETE_PLUGIN_NAME, 'main');
    _defineProperty(this, "getComponent", () => {
      return Autocomplete;
    });
    _defineProperty(this, "getInitialComponentProps", () => {
      return {
        keymap: this.keymap,
        onClick: this.onReplaceSuggestion
      };
    });
    _defineProperty(this, "onReplaceSuggestion", option => {
      const [from, to] = option.replacePosition;
      const transaction = this.view.state.tr;
      transaction.setMeta(JQLAutocompletePluginKey, true);

      // Request query hydration if we are inserting a user node
      if (this.enableRichInlineNodes && option.type === 'value' && option.valueType === 'user') {
        transaction.setMeta('hydrate', true);
      }
      const documentFrom = getDocumentPosition(transaction.doc, from);
      const documentTo = getDocumentPosition(transaction.doc, to);

      // Change current selection to the mapped replace position
      transaction.setSelection(TextSelection.create(transaction.doc, documentTo, documentFrom));

      // Replace selected range with the selected autocomplete option
      transaction.replaceSelection(this.getSliceForSuggestion(option));
      this.view.focus();
      this.view.dispatch(transaction);
    });
    _defineProperty(this, "getSliceForSuggestion", option => {
      const {
        value,
        name,
        nameOnRichInlineNode,
        valueType,
        context
      } = option;
      const nodes = [];
      if (shouldInsertOpeningParenthesis(option)) {
        nodes.push(this.view.state.schema.text('('));
      }
      const textContent = this.view.state.schema.text(value);
      if (!this.enableRichInlineNodes) {
        nodes.push(textContent);
      } else {
        switch (valueType) {
          case 'user':
            {
              const attributes = {
                type: 'user',
                id: value,
                name: nameOnRichInlineNode !== null && nameOnRichInlineNode !== void 0 ? nameOnRichInlineNode : name,
                fieldName: context === null || context === void 0 ? void 0 : context.field
              };
              nodes.push(this.view.state.schema.nodes.user.create(attributes, textContent));
              break;
            }
          default:
            {
              nodes.push(textContent);
              break;
            }
        }
      }
      return new Slice(Fragment.from(nodes), 0, 0);
    });
    this.view = view;
    this.keymap = keymap;
    this.enableRichInlineNodes = enableRichInlineNodes;
  }
  isSameState(state, prevState) {
    return prevState.doc.eq(state.doc) && prevState.selection.eq(state.selection);
  }
}