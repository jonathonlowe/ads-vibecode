import mapValues from 'lodash/mapValues';
import { baseKeymap } from '@atlaskit/editor-prosemirror/commands';
import { history, redo, undo } from '@atlaskit/editor-prosemirror/history';
import { keydownHandler, keymap } from '@atlaskit/editor-prosemirror/keymap';
import { DOMParser, Schema } from '@atlaskit/editor-prosemirror/model';
import { EditorState, Plugin } from '@atlaskit/editor-prosemirror/state';
import { autocompletePlugin, jqlAstPlugin, jqlSyntaxHighlightingPlugin, richInlineNodesPlugin, validationTooltipPlugin } from '../plugins';
import { RICH_INLINE_NODE } from '../plugins/rich-inline-nodes/constants';
import { richInlineNodes } from '../plugins/rich-inline-nodes/nodes';
import { createNodeSpec } from '../plugins/rich-inline-nodes/util/create-node-spec';
import { getFragmentText } from '../utils/document-text';
import { splitTextByNewLine } from '../utils/split-text-by-new-line';
const createMarkWithStyle = tokenType => {
  const mark = document.createElement('span');
  mark.className = `mark-token-${tokenType}`;
  mark.setAttribute('data-token-type', tokenType);
  mark.setAttribute('spellcheck', 'false');
  return mark;
};
export const JQLEditorSchema = new Schema({
  nodes: {
    doc: {
      content: 'paragraph+'
    },
    paragraph: {
      content: `(text|${RICH_INLINE_NODE})*`,
      toDOM: () => ['p', {
        spellcheck: 'false'
      }, 0],
      parseDOM: [{
        tag: 'p'
      }]
    },
    text: {},
    ...mapValues(richInlineNodes, (spec, name) => createNodeSpec(name, spec.attrs))
  },
  marks: {
    token: {
      toDOM: ({
        attrs
      }) => createMarkWithStyle(attrs.tokenType),
      attrs: {
        tokenType: {}
      }
    },
    cursor: {
      toDOM: () => {
        return document.createElement('span');
      }
    }
  }
});
const domParser = DOMParser.fromSchema(JQLEditorSchema);

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextSerializer but
 * preserves consecutive empty block nodes.
 */
export const clipboardTextSerializer = slice => {
  return getFragmentText(slice.content, 0, slice.content.size);
};

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextParser but
 * preserves consecutive empty lines.
 */
export const clipboardTextParser = (text, $context) => {
  const dom = document.createElement('div');
  // Split each line of text and wrap each in a p tag.
  splitTextByNewLine(text).forEach(block => {
    dom.appendChild(document.createElement('p')).textContent = block;
  });
  return domParser.parseSlice(dom, {
    context: $context,
    preserveWhitespace: true
  });
};
export const defaultEditorState = EditorState.create({
  schema: JQLEditorSchema
});

// @types/prosemirror-commands@1.0.1 does not export Command and Keymap types
// TODO: update to Command<JQLEditorSchemaType> and Keymap<JQLEditorSchemaType> if types are bumped to a newer version

export const configurePlugins = (editorState, onSearchCommand, intlRef, mainId, portalActions, enableRichInlineNodes) => {
  return editorState.reconfigure({
    plugins: [history(),
    // Other plugins rely on having AST as part of the state during a transaction, this plugin should be kept first
    jqlAstPlugin(intlRef), jqlSyntaxHighlightingPlugin(), ...(portalActions !== undefined ? [autocompletePlugin(portalActions, enableRichInlineNodes), ...(enableRichInlineNodes ? [richInlineNodesPlugin(portalActions)] : [])] : []), validationTooltipPlugin(mainId),
    // Keeping these at the bottom allows plugins to define custom key bindings to override default behavior
    keymap({
      'Mod-z': undo,
      'Mod-Shift-z': redo,
      'Mod-y': redo,
      // Mimic default Enter behavior in PM's base keymap, allowing to insert new lines even when autocomplete is open
      'Shift-Enter': baseKeymap.Enter
    }), ...(!onSearchCommand ? [] : [keymapNoRepeat({
      'Mod-Enter': onSearchCommand,
      Enter: onSearchCommand
    })]), keymap(baseKeymap)]
  });
};
const noopCommand = () => true;
function keymapNoRepeat(bindings) {
  const handler = keydownHandler(bindings);
  const proxyBindings = mapValues(bindings, () => noopCommand);
  const proxyHandler = keydownHandler(proxyBindings);
  return new Plugin({
    props: {
      handleKeyDown: (view, event) => {
        if (event.repeat) {
          return proxyHandler(view, event);
        }
        return handler(view, event);
      }
    }
  });
}