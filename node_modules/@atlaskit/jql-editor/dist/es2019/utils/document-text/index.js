/**
 * Get all text between positions `from` and `to` with a newline char between block nodes.
 */
export const getNodeText = (node, from, to) => {
  return getFragmentText(node.content, from, to);
};

/**
 * Get all text between positions `from` and `to` with a newline char between block nodes.
 */
export const getFragmentText = (fragment, from, to) => {
  return textBetween(fragment, from, to, '\n');
};

/**
 * A modified version of {@link Fragment#textBetween}. The default implementation does not insert `blockSeparator` for
 * consecutive empty block nodes (i.e. empty blocks are collapsed into one).
 */
const textBetween = (fragment, from, to, blockSeparator, leafText) => {
  let text = '';
  let enteredInitialBlock = false;
  fragment.nodesBetween(from, to, (innerNode, pos) => {
    if (innerNode.isText) {
      var _innerNode$text;
      text += (_innerNode$text = innerNode.text) === null || _innerNode$text === void 0 ? void 0 : _innerNode$text.slice(Math.max(from, pos) - pos, to - pos);
    } else if (innerNode.isLeaf && leafText) {
      text += leafText;
    } else if (innerNode.isBlock) {
      if (enteredInitialBlock) {
        text += blockSeparator;
      } else {
        enteredInitialBlock = true;
      }
    }
  }, 0);
  return text;
};