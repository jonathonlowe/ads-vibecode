import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import mapValues from 'lodash/mapValues';
import { baseKeymap } from '@atlaskit/editor-prosemirror/commands';
import { history, redo, undo } from '@atlaskit/editor-prosemirror/history';
import { keydownHandler, keymap } from '@atlaskit/editor-prosemirror/keymap';
import { DOMParser, Schema } from '@atlaskit/editor-prosemirror/model';
import { EditorState, Plugin } from '@atlaskit/editor-prosemirror/state';
import { autocompletePlugin, jqlAstPlugin, jqlSyntaxHighlightingPlugin, richInlineNodesPlugin, validationTooltipPlugin } from '../plugins';
import { RICH_INLINE_NODE } from '../plugins/rich-inline-nodes/constants';
import { richInlineNodes } from '../plugins/rich-inline-nodes/nodes';
import { createNodeSpec } from '../plugins/rich-inline-nodes/util/create-node-spec';
import { getFragmentText } from '../utils/document-text';
import { splitTextByNewLine } from '../utils/split-text-by-new-line';
var createMarkWithStyle = function createMarkWithStyle(tokenType) {
  var mark = document.createElement('span');
  mark.className = "mark-token-".concat(tokenType);
  mark.setAttribute('data-token-type', tokenType);
  mark.setAttribute('spellcheck', 'false');
  return mark;
};
export var JQLEditorSchema = new Schema({
  nodes: _objectSpread({
    doc: {
      content: 'paragraph+'
    },
    paragraph: {
      content: "(text|".concat(RICH_INLINE_NODE, ")*"),
      toDOM: function toDOM() {
        return ['p', {
          spellcheck: 'false'
        }, 0];
      },
      parseDOM: [{
        tag: 'p'
      }]
    },
    text: {}
  }, mapValues(richInlineNodes, function (spec, name) {
    return createNodeSpec(name, spec.attrs);
  })),
  marks: {
    token: {
      toDOM: function toDOM(_ref) {
        var attrs = _ref.attrs;
        return createMarkWithStyle(attrs.tokenType);
      },
      attrs: {
        tokenType: {}
      }
    },
    cursor: {
      toDOM: function toDOM() {
        return document.createElement('span');
      }
    }
  }
});
var domParser = DOMParser.fromSchema(JQLEditorSchema);

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextSerializer but
 * preserves consecutive empty block nodes.
 */
export var clipboardTextSerializer = function clipboardTextSerializer(slice) {
  return getFragmentText(slice.content, 0, slice.content.size);
};

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextParser but
 * preserves consecutive empty lines.
 */
export var clipboardTextParser = function clipboardTextParser(text, $context) {
  var dom = document.createElement('div');
  // Split each line of text and wrap each in a p tag.
  splitTextByNewLine(text).forEach(function (block) {
    dom.appendChild(document.createElement('p')).textContent = block;
  });
  return domParser.parseSlice(dom, {
    context: $context,
    preserveWhitespace: true
  });
};
export var defaultEditorState = EditorState.create({
  schema: JQLEditorSchema
});

// @types/prosemirror-commands@1.0.1 does not export Command and Keymap types
// TODO: update to Command<JQLEditorSchemaType> and Keymap<JQLEditorSchemaType> if types are bumped to a newer version

export var configurePlugins = function configurePlugins(editorState, onSearchCommand, intlRef, mainId, portalActions, enableRichInlineNodes) {
  return editorState.reconfigure({
    plugins: [history(),
    // Other plugins rely on having AST as part of the state during a transaction, this plugin should be kept first
    jqlAstPlugin(intlRef), jqlSyntaxHighlightingPlugin()].concat(_toConsumableArray(portalActions !== undefined ? [autocompletePlugin(portalActions, enableRichInlineNodes)].concat(_toConsumableArray(enableRichInlineNodes ? [richInlineNodesPlugin(portalActions)] : [])) : []), [validationTooltipPlugin(mainId),
    // Keeping these at the bottom allows plugins to define custom key bindings to override default behavior
    keymap({
      'Mod-z': undo,
      'Mod-Shift-z': redo,
      'Mod-y': redo,
      // Mimic default Enter behavior in PM's base keymap, allowing to insert new lines even when autocomplete is open
      'Shift-Enter': baseKeymap.Enter
    })], _toConsumableArray(!onSearchCommand ? [] : [keymapNoRepeat({
      'Mod-Enter': onSearchCommand,
      Enter: onSearchCommand
    })]), [keymap(baseKeymap)])
  });
};
var noopCommand = function noopCommand() {
  return true;
};
function keymapNoRepeat(bindings) {
  var handler = keydownHandler(bindings);
  var proxyBindings = mapValues(bindings, function () {
    return noopCommand;
  });
  var proxyHandler = keydownHandler(proxyBindings);
  return new Plugin({
    props: {
      handleKeyDown: function handleKeyDown(view, event) {
        if (event.repeat) {
          return proxyHandler(view, event);
        }
        return handler(view, event);
      }
    }
  });
}