import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import mapValues from 'lodash/mapValues';
import { Plugin, PluginKey } from '@atlaskit/editor-prosemirror/state';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { JQLSyntaxError } from '@atlaskit/jql-ast';
import getDocumentPosition from '../common/get-document-position';
import { getJastFromState } from '../jql-ast';
import { ERROR_NODE, RICH_INLINE_NODE, SELECTED_NODE } from './constants';
import { richInlineNodes } from './nodes';
import { ReactNodeView } from './util/react-node-view';
var decorateNodesInRange = function decorateNodesInRange(state, decoration, from, to) {
  var decorations = [];
  state.doc.nodesBetween(from, to, function (node, pos) {
    if (node.type.spec.group === RICH_INLINE_NODE) {
      decorations.push(Decoration.node(pos, pos + node.nodeSize, {}, {
        type: decoration
      }));
    }
  });
  return decorations;
};
var RichInlineNodesPluginKey = new PluginKey('rich-inline-nodes-plugin');
var richInlineNodesPlugin = function richInlineNodesPlugin(portalActions) {
  return new Plugin({
    key: RichInlineNodesPluginKey,
    props: {
      decorations: function decorations(state) {
        var _decorations;
        var decorations = [];

        // Apply selected decoration to node views when they are part of a text selection
        var _state$selection = state.selection,
          from = _state$selection.from,
          to = _state$selection.to;
        (_decorations = decorations).push.apply(_decorations, _toConsumableArray(decorateNodesInRange(state, SELECTED_NODE, from, to)));

        // Apply error decoration to node views when they are part of AST error range
        var ast = getJastFromState(state);
        var _ast$errors = _slicedToArray(ast.errors, 1),
          error = _ast$errors[0];
        if (error instanceof JQLSyntaxError) {
          var _decorations2;
          var documentFrom = getDocumentPosition(state.doc, error.start);
          var documentTo = getDocumentPosition(state.doc, error.stop);
          (_decorations2 = decorations).push.apply(_decorations2, _toConsumableArray(decorateNodesInRange(state, ERROR_NODE, documentFrom, documentTo)));
        }
        return DecorationSet.create(state.doc, decorations);
      },
      nodeViews: mapValues(richInlineNodes, function (jqlNodeSpec) {
        return function (node, _view, _getPos, decorations) {
          return ReactNodeView.for(jqlNodeSpec.component, portalActions, node, decorations);
        };
      })
    }
  });
};
export default richInlineNodesPlugin;