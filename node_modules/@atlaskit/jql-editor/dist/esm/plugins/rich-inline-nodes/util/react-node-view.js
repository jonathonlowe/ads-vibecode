import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React, { useEffect, useLayoutEffect, useState } from 'react';
import { Subject } from 'rxjs/Subject';
import { v4 as uuid } from 'uuid';
import { useEditorViewHasFocus } from '../../../state';
import { ERROR_NODE, SELECTED_NODE } from '../constants';
export var ReactNodeView = /*#__PURE__*/function () {
  function ReactNodeView(component, portalActions, _node) {
    var _this = this;
    _classCallCheck(this, ReactNodeView);
    _defineProperty(this, "componentSubject", new Subject());
    _defineProperty(this, "init", function (decorations) {
      var Component = _this.component;
      var PortallingComponent = function PortallingComponent() {
        var _useState = useState(_objectSpread(_objectSpread({}, _this.getProps(_this.node)), {}, {
            selected: _this.isSelected(decorations),
            error: _this.hasError(decorations)
          })),
          _useState2 = _slicedToArray(_useState, 2),
          state = _useState2[0],
          setState = _useState2[1];

        // ProseMirror keeps decorations on blur (as those are derived from editor state and focus isn't part of it),
        // but we don't want to show node views as selected when that happens. We could build a workaround for this in
        // richInlineNodesPlugin, but this hook will make selection behave more consistently with other focus-related features.
        var _useEditorViewHasFocu = useEditorViewHasFocus(),
          _useEditorViewHasFocu2 = _slicedToArray(_useEditorViewHasFocu, 1),
          hasFocus = _useEditorViewHasFocu2[0];
        useEffect(function () {
          // Subscribe to the RxJS subject so concrete subclasses can emit events to re-render the node view component
          var subscription = _this.componentSubject.subscribe(function (props) {
            setState(props);
          });
          return function () {
            return subscription.unsubscribe();
          };
        }, []);
        useLayoutEffect(function () {
          if (state.error) {
            _this.dom.dataset.tokenType = 'error';
          } else {
            delete _this.dom.dataset.tokenType;
          }
        }, [state]);
        return /*#__PURE__*/React.createElement(Component, _extends({}, state, {
          selected: state.selected && hasFocus
        }));
      };

      // Ok, this is a tricky one. As everything that requires collaboration between ProseMirror and React.
      //
      // If we run `onCreatePortal` synchronously, ProseMirror won't insert the node view container (`this.dom`)
      // immediately into the DOM (as init function hasn't returned yet). This can trigger race conditions in other
      // code paths where ProseMirror may try to get DOM position for this node view before it has been inserted
      // (e.g. calculating new autocomplete position after insertion, or setting selection after the node).
      //
      // With `queueMicrotask` we can schedule this operation to be run after ProseMirror is done with the element
      // insertion, but before control of the execution context is returned to the browser's event loop. This should
      // prevent all conflicts with other pieces of asynchronous code and still render the portal as soon as it is
      // practically possible, so we can avoid flicker in situations where node views are reconstructed by ProseMirror.
      // @see https://github.com/ProseMirror/prosemirror/issues/872
      queueMicrotask(function () {
        _this.portalActions.onCreatePortal(_this.portalKey, /*#__PURE__*/React.createElement(PortallingComponent, null), _this.dom);
      });
      return _this;
    });
    _defineProperty(this, "destroy", function () {
      _this.portalActions.onDestroyPortal(_this.portalKey);
    });
    _defineProperty(this, "update", function (node, decorations) {
      // Update function may be called by ProseMirror with a node that has nothing to do with this node view ¯\_(ツ)_/¯
      // @see https://prosemirror.net/docs/ref/#view.NodeView.update
      if (node !== _this.node) {
        return false;
      }
      _this.componentSubject.next(_objectSpread(_objectSpread({}, _this.getProps(node)), {}, {
        selected: _this.isSelected(decorations),
        error: _this.hasError(decorations)
      }));
      return true;
    });
    _defineProperty(this, "getProps", function (node) {
      return _objectSpread({}, node.attrs);
    });
    _defineProperty(this, "isSelected", function (decorations) {
      return decorations.some(function (decoration) {
        return decoration.spec.type === SELECTED_NODE;
      });
    });
    _defineProperty(this, "hasError", function (decorations) {
      return decorations.some(function (decoration) {
        return decoration.spec.type === ERROR_NODE;
      });
    });
    this.component = component;
    this.portalActions = portalActions;
    this.node = _node;
    // Generate unique portal identifier
    // If you read this comment in the future and TypeScript has added support for Symbols as object keys, please do
    // JQL Editor a favor and replace this library with the native JS functionality that TS was supposed to support.
    this.portalKey = uuid();
    // Creating span under the assumption that all node views will be inline elements in JQL Editor
    this.dom = document.createElement('span');
    this.dom.setAttribute('data-testid', 'jql-editor-node-view');
  }
  return _createClass(ReactNodeView, null, [{
    key: "for",
    value: function _for(component, portalActions, node, decorations) {
      return new ReactNodeView(component, portalActions, node).init(decorations);
    }
  }]);
}();