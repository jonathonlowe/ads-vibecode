import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import { DefaultErrorStrategy } from 'antlr4ts';
import padStart from 'lodash/padStart';
import { normaliseJqlString } from '@atlaskit/jql-ast';
import { JQLAutocomplete } from '@atlaskit/jql-autocomplete';
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import { ignoredTokens, preferredRules } from './constants';
import { handleCustomFieldRuleError } from './error-handlers/CustomFieldRuleErrorHandler';
import { handleExpectedTokensError } from './error-handlers/ExpectedTokensErrorHandler';
import { handleFieldPropertyIdRuleError } from './error-handlers/FieldPropertyIdErrorHandler';
import { handleFieldRuleError } from './error-handlers/FieldRuleErrorHandler';
import { handleFunctionArgumentRuleError } from './error-handlers/FunctionArgumentRuleErrorHandler';
import { handleOperandRuleError } from './error-handlers/OperandRuleErrorHandler';
import { handleOperatorRuleError } from './error-handlers/OperatorRuleErrorHandler';
import { errorMessages } from './messages';
import { getExpectedTokensFromParserOrException } from './utils';
var isEscape = function isEscape(char) {
  return char === '\\';
};
export var getPrintableChar = function getPrintableChar(char) {
  var hex = char.charCodeAt(0).toString(16).toUpperCase();
  return "U+".concat(padStart(hex, 4, '0'));
};
export var getJavaCodeFromChar = function getJavaCodeFromChar(char) {
  var hex = char.charCodeAt(0).toString(16);
  return "\\u".concat(padStart(hex, 4, '0'));
};
var JQLEditorErrorStrategy = /*#__PURE__*/function (_DefaultErrorStrategy) {
  function JQLEditorErrorStrategy(intlRef) {
    var _this;
    _classCallCheck(this, JQLEditorErrorStrategy);
    _this = _callSuper(this, JQLEditorErrorStrategy);
    _this.intlRef = intlRef;
    return _this;
  }
  _inherits(JQLEditorErrorStrategy, _DefaultErrorStrategy);
  return _createClass(JQLEditorErrorStrategy, [{
    key: "reportInputMismatch",
    value: function reportInputMismatch(recognizer, exception) {
      this.handleSyntaxError(recognizer, recognizer.currentToken, exception);
    }
  }, {
    key: "reportUnwantedToken",
    value: function reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      this.handleSyntaxError(recognizer, recognizer.currentToken);
    }
  }, {
    key: "reportMissingToken",
    value: function reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);

      // This is called when single token insertion is a viable recovery strategy for the error. In this case we can
      // use expected tokens from the parser to display an error to the user. If there are no viable tokens to show then
      // we should fallback to syntax error handling.
      if (getExpectedTokensFromParserOrException(recognizer).length > 0) {
        var message = handleExpectedTokensError(recognizer, recognizer.currentToken,
        // We want to derive expectedTokens from the parser state
        [], this.intlRef.current);
        recognizer.notifyErrorListeners(message, recognizer.currentToken, undefined);
      } else {
        this.handleSyntaxError(recognizer, recognizer.currentToken);
      }
    }
  }, {
    key: "reportNoViableAlternative",
    value: function reportNoViableAlternative(recognizer, exception) {
      var _exception$getOffendi;
      // There are some cases, like "status was", where parser is unable to provide viable alternatives for current
      // token, but autocomplete engine is still able to provide meaningful suggestions at offending token index
      var currentToken = (_exception$getOffendi = exception === null || exception === void 0 ? void 0 : exception.getOffendingToken()) !== null && _exception$getOffendi !== void 0 ? _exception$getOffendi : recognizer.currentToken;
      this.handleSyntaxError(recognizer, currentToken, exception);
    }
  }, {
    key: "reportFailedPredicate",
    value: function reportFailedPredicate(recognizer, e) {
      // TODO: Don't know how to produce this error. Monitor if this happens and defer to default implementation
      _superPropGet(JQLEditorErrorStrategy, "reportFailedPredicate", this, 3)([recognizer, e]);
    }
  }, {
    key: "handleSyntaxError",
    value: function handleSyntaxError(recognizer, currentToken, exception) {
      var message;
      switch (currentToken.type) {
        /*
         * This is called when ANTLR finds a character that the grammar does not recognise. The grammar lexer uses
         * a DFA to decide if a character is in error or not. This can mean that legal characters come as an error
         * because they do not form a valid token. Because of this we have to do some extra checks here.
         */
        case JQLLexer.ERRORCHAR:
        case JQLLexer.INVALID_QUOTE_STRING:
        case JQLLexer.INVALID_SQUOTE_STRING:
          {
            var currentText = currentToken.text;

            // These tokens are returned when an illegal character appears at the end of a quote string, but the token
            // includes the entire quoted text. We take the last character from our text as that's the offending token.
            if (currentToken.type === JQLLexer.INVALID_QUOTE_STRING || currentToken.type === JQLLexer.INVALID_SQUOTE_STRING) {
              var _currentText;
              currentText = (_currentText = currentText) === null || _currentText === void 0 ? void 0 : _currentText.slice(-1);
            }

            // This can happen (e.g. comment ~ \)
            if (isEscape(currentText)) {
              var nextToken = recognizer.inputStream.get(currentToken.tokenIndex + 1);
              if (nextToken.type === JQLLexer.MATCHWS || nextToken.type === JQLLexer.EOF) {
                message = this.intlRef.current.formatMessage(errorMessages.illegalEscapeBlank);
              } else {
                var _nextToken$text;
                // Show the escaped character sequence in the message
                var received = "".concat(currentText !== null && currentText !== void 0 ? currentText : '').concat((_nextToken$text = nextToken.text) !== null && _nextToken$text !== void 0 ? _nextToken$text : '');
                message = this.intlRef.current.formatMessage(errorMessages.illegalEscape, {
                  received: received
                });
              }
            } else {
              message = this.intlRef.current.formatMessage(errorMessages.illegalChar, {
                char: getPrintableChar(currentText !== null && currentText !== void 0 ? currentText : ''),
                escapedChar: getJavaCodeFromChar(currentText !== null && currentText !== void 0 ? currentText : '')
              });
            }
            break;
          }
        // Special tokens that get created every time there is an unfinished string (i.e. without matching closing quote)
        case JQLLexer.UNCLOSED_QUOTE_STRING:
        case JQLLexer.UNCLOSED_SQUOTE_STRING:
          {
            var _currentToken$text;
            var _received = normaliseJqlString((_currentToken$text = currentToken.text) !== null && _currentToken$text !== void 0 ? _currentToken$text : '');
            if (_received === '') {
              message = this.intlRef.current.formatMessage(errorMessages.unfinishedStringBlank);
            } else {
              message = this.intlRef.current.formatMessage(errorMessages.unfinishedString, {
                received: _received
              });
            }
            break;
          }
        case JQLLexer.RESERVED_WORD:
          {
            message = this.intlRef.current.formatMessage(errorMessages.reservedWord, {
              word: currentToken.text
            });
            break;
          }
        case JQLLexer.ERROR_RESERVED:
          {
            var _currentToken$text2;
            message = this.intlRef.current.formatMessage(errorMessages.reservedChar, {
              char: currentToken.text,
              escapedChar: getJavaCodeFromChar((_currentToken$text2 = currentToken.text) !== null && _currentToken$text2 !== void 0 ? _currentToken$text2 : '')
            });
            break;
          }
        default:
          {
            var autocomplete = JQLAutocomplete.fromParser(recognizer, ignoredTokens, preferredRules, new Set());
            var _autocomplete$getJQLS = autocomplete.getJQLSuggestionsForTokenIndex(currentToken.tokenIndex),
              tokens = _autocomplete$getJQLS.tokens,
              rules = _autocomplete$getJQLS.rules;
            if (rules.value || rules.list ||
            // Restrict function rules to only be shown if we are currently INSIDE a function rule. Otherwise this error
            // message would be shown for incomplete tokens following an operand, e.g. `status = open ord`.
            rules.function && recognizer.context.ruleIndex === JQLParser.RULE_jqlFunction) {
              message = handleOperandRuleError(recognizer, currentToken, tokens.values, rules, this.intlRef.current, exception);
            } else if (tokens.values.includes('EMPTY')) {
              message = handleExpectedTokensError(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
            } else if (rules.operator) {
              message = handleOperatorRuleError(currentToken, this.intlRef.current);
            } else if (rules.field) {
              message = handleFieldRuleError(currentToken, this.intlRef.current);
            } else if (rules.customField) {
              message = handleCustomFieldRuleError(this.intlRef.current);
            }
            // Restrict field property rules to only be shown if we are currently INSIDE a field property. Otherwise this
            // error message would be shown for incomplete tokens following a field, e.g. `ORDER BY issuetype as`.
            else if (rules.fieldProperty && recognizer.context.ruleIndex === JQLParser.RULE_jqlFieldProperty) {
              // Shows the correct message when a field property rule hasn't been completed, e.g. `issuetype[abc!`
              message = handleExpectedTokensError(recognizer, currentToken,
              // We want to derive expectedTokens from the exception/parser state
              [], this.intlRef.current, exception);
            } else if (rules.fieldPropertyId) {
              message = handleFieldPropertyIdRuleError(currentToken, this.intlRef.current);
            } else if (rules.functionArgument) {
              message = handleFunctionArgumentRuleError(currentToken, this.intlRef.current);
            } else {
              message = handleExpectedTokensError(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
            }
            break;
          }
      }
      recognizer.notifyErrorListeners(message, currentToken, undefined);
    }
  }]);
}(DefaultErrorStrategy);
export { JQLEditorErrorStrategy as default };