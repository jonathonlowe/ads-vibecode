import { JQLLexer } from '@atlaskit/jql-parser';
import { commonMessages } from '../../../common/messages';
import { lowPriorityTokens } from '../constants';
import { errorMessages } from '../messages';
import { getExpectedTokensFromParserOrException, getTokenDisplayNames } from '../utils';

/**
 * Show the appropriate error message when parsing JQL fails and 0 or more tokens were expected.
 *
 * If no `expectedTokens` were provided then we'll attempt to find viable tokens to suggest from the provided
 * exception/parser state.
 */
export var handleExpectedTokensError = function handleExpectedTokensError(recognizer, currentToken, expectedTokens, intl, exception) {
  // If there are no expected autocomplete tokens, then attempt to find viable tokens from the exception/parser.
  if (expectedTokens.length === 0) {
    expectedTokens = getTokenDisplayNames(recognizer, getExpectedTokensFromParserOrException(recognizer, exception));
  }
  var lowPriorityTokenNames = getTokenDisplayNames(recognizer, lowPriorityTokens);

  // Only include tokens that are NOT low priority
  var highPriorityTokens = expectedTokens.filter(function (tokenType) {
    return !lowPriorityTokenNames.includes(tokenType);
  });

  // If we have any tokens that are high priority then we want to show them (without low priority suggestions).
  if (highPriorityTokens.length > 0) {
    expectedTokens = highPriorityTokens;
  }
  var isEOF = currentToken.type === JQLLexer.EOF;
  if (expectedTokens.length > 1) {
    var firstExpectedTokens = expectedTokens.slice(0, -1)
    // Need to wrap tokens in single quotes ourselves as we cannot do it in the message descriptor
    .map(function (token) {
      return "'".concat(token, "'");
    }).join(', ');
    var lastExpectedToken = expectedTokens[expectedTokens.length - 1];
    return isEOF ? intl.formatMessage(errorMessages.expectingMultipleTokensBeforeEOF, {
      firstExpectedTokens: firstExpectedTokens,
      lastExpectedToken: lastExpectedToken
    }) : intl.formatMessage(errorMessages.expectingMultipleTokensButReceived, {
      firstExpectedTokens: firstExpectedTokens,
      lastExpectedToken: lastExpectedToken,
      received: currentToken.text
    });
  } else if (expectedTokens.length === 1) {
    return isEOF ? intl.formatMessage(errorMessages.expectingTokenBeforeEOF, {
      expectedToken: expectedTokens[0]
    }) : intl.formatMessage(errorMessages.expectingTokenButReceived, {
      expectedToken: expectedTokens[0],
      received: currentToken.text
    });
  } else {
    return isEOF ? intl.formatMessage(commonMessages.unknownError) : intl.formatMessage(errorMessages.unknownErrorAtToken, {
      received: currentToken.text
    });
  }
};