import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { useEffect, useState } from 'react';
import { Subject } from 'rxjs/Subject';
/**
 * Abstract class for Prosemirror plugin views which need to mount a React component. Concrete subclasses must implement
 * {@link ReactPluginView#getComponent} which specifies the React component to render, along with
 * {@link ReactPluginView#getInitialComponentProps} which returns any props to pass to the component on initial render.
 *
 * After the class is constructed, the caller must invoke {@link ReactPluginView#init} in order to mount the component.
 *
 * If there are external changes which the component needs to respond to, {@link ReactPluginView#componentSubject} can
 * be used to trigger a re-render of the component with updated props. For example:
 * ```
 * update = (view: EditorView) => {
 *   this.componentSubject.next(this.getComponentProps(view));
 * };
 *
 * getComponentProps = (view: EditorView) => {
 *   // Some logic to get props from the Prosemirror view
 * }
 * ```
 */
var ReactPluginView = /*#__PURE__*/function () {
  /**
   * Construct a Prosemirror plugin view which will render a React component in a portal.
   *
   * @param portalActions Provides callback functions which can be invoked to create and destroy a portal.
   * @param portalKey Unique identifier for the plugin component.
   * @param containerKey Key representing the HTML container the React component will be portalled into.
   * @protected
   */
  function ReactPluginView(portalActions, portalKey, containerKey) {
    var _this = this;
    _classCallCheck(this, ReactPluginView);
    _defineProperty(this, "componentSubject", new Subject());
    _defineProperty(this, "init", function () {
      var Component = _this.getComponent();
      var PortallingComponent = function PortallingComponent() {
        var _useState = useState(function () {
            return _this.getInitialComponentProps();
          }),
          _useState2 = _slicedToArray(_useState, 2),
          state = _useState2[0],
          setState = _useState2[1];
        useEffect(function () {
          // Subscribe to the RxJS subject so concrete subclasses can emit events to re-render the plugin component.
          var subscription = _this.componentSubject.subscribe(function (updatedProps) {
            setState(updatedProps);
          });
          return function () {
            return subscription.unsubscribe();
          };
        }, []);
        return /*#__PURE__*/React.createElement(Component, state);
      };

      // Dispatch onCreatePortal which will allow the handler to create a new portalled React component
      _this.portalActions.onCreatePortal(_this.portalKey, /*#__PURE__*/React.createElement(PortallingComponent, null), _this.containerKey);
    });
    this.portalActions = portalActions;
    this.portalKey = portalKey;
    this.containerKey = containerKey;
  }
  return _createClass(ReactPluginView, [{
    key: "destroy",
    value: function destroy() {
      // Dispatch onDestroyPortal which will allow the handler to remove the portalled React component.
      this.portalActions.onDestroyPortal(this.portalKey);
    }

    /**
     * Return a React component to render for the plugin.
     */

    /**
     * Return props to set on the component for initial render.
     */
  }]);
}();
export { ReactPluginView as default };