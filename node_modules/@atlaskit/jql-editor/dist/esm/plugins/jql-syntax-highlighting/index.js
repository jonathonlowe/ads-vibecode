import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { Plugin, PluginKey } from '@atlaskit/editor-prosemirror/state';
import { JQLSyntaxError } from '@atlaskit/jql-ast';
import getDocumentPosition from '../common/get-document-position';
import { getJastFromState } from '../jql-ast';
import { SyntaxHighlightingVisitor } from './visitor';
var getHighlights = function getHighlights(state) {
  var ast = getJastFromState(state);
  // Get highlights for AST nodes
  var visitor = new SyntaxHighlightingVisitor(state);
  var highlights = ast.query ? visitor.visit(ast.query) : [];
  // Create a highlight for the first syntax error encountered
  var _ast$errors = _slicedToArray(ast.errors, 1),
    error = _ast$errors[0];
  if (error instanceof JQLSyntaxError) {
    var documentFrom = getDocumentPosition(state.doc, error.start);
    var documentTo = getDocumentPosition(state.doc, error.stop);
    highlights.push({
      tokenType: 'error',
      documentFrom: documentFrom,
      documentTo: documentTo
    });
  }
  return highlights;
};
var JQLSyntaxHighlightingPluginKey = new PluginKey('jql-syntax-highlighting-plugin');
var jqlSyntaxHighlightingPlugin = function jqlSyntaxHighlightingPlugin() {
  return new Plugin({
    key: JQLSyntaxHighlightingPluginKey,
    appendTransaction: function appendTransaction(_, oldState, newState) {
      // Avoid unnecessary transactions if document hasn't changed in the current transaction
      if (oldState.doc === newState.doc) {
        return;
      }
      var transaction = newState.tr;

      // Remove token marks from all inline nodes so they can be recomputed
      transaction.removeMark(0, newState.doc.content.size);

      // Create marks for computed highlights
      var highlights = getHighlights(newState);
      highlights.forEach(function (_ref) {
        var tokenType = _ref.tokenType,
          documentFrom = _ref.documentFrom,
          documentTo = _ref.documentTo;
        // Apply mark to all text nodes within the highlighted range
        newState.doc.nodesBetween(documentFrom, documentTo, function (node, pos) {
          if (node.isText) {
            var from = Math.max(pos, documentFrom);
            var to = Math.min(pos + node.nodeSize, documentTo);
            var mark = newState.schema.marks.token.create({
              tokenType: tokenType
            });
            transaction.addMark(from, to, mark);
          }
        });
      });
      return transaction;
    }
  });
};
export default jqlSyntaxHighlightingPlugin;