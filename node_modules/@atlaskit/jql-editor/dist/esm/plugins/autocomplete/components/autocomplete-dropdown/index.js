import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import Spinner from '@atlaskit/spinner';
import { ScreenReaderText } from '../../../../accessibility';
import { JQL_EDITOR_AUTOCOMPLETE_ID } from '../../../../common/constants';
import { useAutocomplete, useAutocompleteIsOpen, useAutocompletePosition, useIntl, useRichInlineNodesEnabled, useScopedId, useStoreActions } from '../../../../state';
import { ARROW_DOWN_KEY, ARROW_UP_KEY, CMD_ARROW_DOWN_KEY, CMD_ARROW_UP_KEY, END_KEY, ENTER_KEY, ESCAPE_KEY, HOME_KEY, TAB_KEY } from '../../constants';
import { messages } from '../../messages';
import AutocompleteOption from '../autocomplete-option';
import { AutocompleteContainer, AutocompleteLoadingFooter, AutocompleteOptionsContainer, OptionList } from './styled';
var getPreviousOptionId = function getPreviousOptionId(options, selectedOptionId) {
  if (!selectedOptionId) {
    return options[options.length - 1].id;
  }
  var index = options.findIndex(function (option) {
    return option.id === selectedOptionId;
  });
  if (index === -1) {
    return options[options.length - 1].id;
  }
  if (index > 0) {
    return options[index - 1].id;
  }
  return undefined;
};
var getNextOptionId = function getNextOptionId(options, selectedOptionId) {
  if (!selectedOptionId) {
    return options[0].id;
  }
  var index = options.findIndex(function (option) {
    return option.id === selectedOptionId;
  });
  if (index === -1) {
    return options[0].id;
  }
  if (index < options.length - 1) {
    return options[index + 1].id;
  }
  return undefined;
};
var AutocompleteDropdown = function AutocompleteDropdown(_ref) {
  var options = _ref.options,
    loading = _ref.loading,
    keymap = _ref.keymap,
    onClick = _ref.onClick;
  var containerRef = useRef(null);
  var scrollContainerRef = useRef(null);
  var selectedItemRef = useRef(null);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    navigatingWithKeyboard = _useState2[0],
    setNavigatingWithKeyboard = _useState2[1];
  var _useIntl = useIntl(),
    _useIntl2 = _slicedToArray(_useIntl, 1),
    intl = _useIntl2[0];
  var _useStoreActions = useStoreActions(),
    _useStoreActions2 = _slicedToArray(_useStoreActions, 2),
    _useStoreActions2$ = _useStoreActions2[1],
    onEditorViewFocus = _useStoreActions2$.onEditorViewFocus,
    onEditorViewBlur = _useStoreActions2$.onEditorViewBlur;
  var _useAutocomplete = useAutocomplete(),
    _useAutocomplete2 = _slicedToArray(_useAutocomplete, 2),
    selectedOptionId = _useAutocomplete2[0].selectedOptionId,
    _useAutocomplete2$ = _useAutocomplete2[1],
    closeAutocomplete = _useAutocomplete2$.closeAutocomplete,
    setAutocompleteContainer = _useAutocomplete2$.setAutocompleteContainer,
    setSelectedAutocompleteOptionId = _useAutocomplete2$.setSelectedAutocompleteOptionId;
  var _useAutocompleteIsOpe = useAutocompleteIsOpen(),
    _useAutocompleteIsOpe2 = _slicedToArray(_useAutocompleteIsOpe, 1),
    isAutocompleteOpen = _useAutocompleteIsOpe2[0];
  var _useAutocompletePosit = useAutocompletePosition(),
    _useAutocompletePosit2 = _slicedToArray(_useAutocompletePosit, 1),
    _useAutocompletePosit3 = _useAutocompletePosit2[0],
    top = _useAutocompletePosit3.top,
    left = _useAutocompletePosit3.left;
  var _useRichInlineNodesEn = useRichInlineNodesEnabled(),
    _useRichInlineNodesEn2 = _slicedToArray(_useRichInlineNodesEn, 1),
    areRichInlineNodesEnabled = _useRichInlineNodesEn2[0];
  var _useScopedId = useScopedId(JQL_EDITOR_AUTOCOMPLETE_ID),
    _useScopedId2 = _slicedToArray(_useScopedId, 1),
    autocompleteId = _useScopedId2[0];
  var onContainerRef = useCallback(function (container) {
    containerRef.current = container;
    setAutocompleteContainer(container);
  }, [containerRef, setAutocompleteContainer]);
  var onScrollContainerRef = useCallback(function (container) {
    scrollContainerRef.current = container;
  }, [scrollContainerRef]);
  var handleClick = useCallback(function (option, optionIndex, keyboard) {
    closeAutocomplete();
    onClick(option, {
      keyboard: keyboard,
      numberOfOptions: options.length,
      optionIndex: optionIndex,
      optionType: option.type,
      queryLength: option.matchedText.length,
      nodeType: areRichInlineNodesEnabled && option.valueType !== undefined ? option.valueType : 'text'
    });
  }, [options, onClick, closeAutocomplete, areRichInlineNodesEnabled]);
  var onMouseMove = useCallback(function () {
    if (navigatingWithKeyboard) {
      setNavigatingWithKeyboard(false);
    }
  }, [navigatingWithKeyboard, setNavigatingWithKeyboard]);
  useEffect(function () {
    keymap.bindKey(ARROW_UP_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      var previousOptionId = getPreviousOptionId(options, selectedOptionId);
      setSelectedAutocompleteOptionId(previousOptionId);
      return true;
    });
    keymap.bindKey(ARROW_DOWN_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      var nextOptionId = getNextOptionId(options, selectedOptionId);
      setSelectedAutocompleteOptionId(nextOptionId);
      return true;
    });
    keymap.bindMultipleKeys([ENTER_KEY, TAB_KEY], function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      var selectedOptionIndex = options.findIndex(function (option) {
        return option.id === selectedOptionId;
      });
      if (selectedOptionId && selectedOptionIndex !== -1) {
        if (options[selectedOptionIndex].isDeprecated) {
          return true;
        }
        handleClick(options[selectedOptionIndex], selectedOptionIndex, true);
        return true;
      }
      // Open with no option selected, so we let PM do its stuff (a.k.a. keep inserting new lines)
      return false;
    });
    keymap.bindKey(ESCAPE_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      closeAutocomplete();
      return true;
    });
    keymap.bindMultipleKeys([HOME_KEY, CMD_ARROW_UP_KEY], function () {
      var _options$;
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      setSelectedAutocompleteOptionId((_options$ = options[0]) === null || _options$ === void 0 ? void 0 : _options$.id);
      return true;
    });
    keymap.bindMultipleKeys([END_KEY, CMD_ARROW_DOWN_KEY], function () {
      var _options;
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      setSelectedAutocompleteOptionId((_options = options[options.length - 1]) === null || _options === void 0 ? void 0 : _options.id);
      return true;
    });

    // New bindings should also be registered in plugins/autocomplete/index.tsx

    return function () {
      keymap.unbindKey(ARROW_UP_KEY);
      keymap.unbindKey(ARROW_DOWN_KEY);
      keymap.unbindKey(ENTER_KEY);
      keymap.unbindKey(TAB_KEY);
      keymap.unbindKey(ESCAPE_KEY);
      keymap.unbindKey(HOME_KEY);
      keymap.unbindKey(END_KEY);
      keymap.unbindKey(CMD_ARROW_UP_KEY);
      keymap.unbindKey(CMD_ARROW_DOWN_KEY);
    };
  }, [keymap, isAutocompleteOpen, closeAutocomplete, navigatingWithKeyboard, setNavigatingWithKeyboard, options, selectedOptionId, setSelectedAutocompleteOptionId, handleClick]);
  useEffect(function () {
    // Reset to no selection when:
    // - autocomplete is closed
    // - we get new options and those don't include the currently selected option
    if (!isAutocompleteOpen || !options.some(function (option) {
      return option.id === selectedOptionId;
    })) {
      setSelectedAutocompleteOptionId(undefined);
    }
  }, [isAutocompleteOpen, options, selectedOptionId, setSelectedAutocompleteOptionId]);
  useLayoutEffect(function () {
    requestAnimationFrame(function () {
      if (containerRef.current) {
        containerRef.current.style.top = "".concat(top, "px");
        containerRef.current.style.left = "".concat(left, "px");
      }
    });
  }, [top, left]);
  useLayoutEffect(function () {
    if (navigatingWithKeyboard) {
      var _selectedItemRef$curr;
      (_selectedItemRef$curr = selectedItemRef.current) === null || _selectedItemRef$curr === void 0 || _selectedItemRef$curr.scrollIntoView({
        block: 'nearest'
      });
    }
  }, [navigatingWithKeyboard, selectedOptionId, selectedItemRef]);
  useLayoutEffect(function () {
    var _selectedItemRef$curr2;
    (_selectedItemRef$curr2 = selectedItemRef.current) === null || _selectedItemRef$curr2 === void 0 || _selectedItemRef$curr2.scrollIntoView({
      block: 'nearest'
    });
  }, [options, selectedItemRef]);
  useLayoutEffect(function () {
    if (isAutocompleteOpen && !selectedOptionId && scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = 0;
    }
  }, [isAutocompleteOpen, selectedOptionId]);
  var announcedMessage = useMemo(function () {
    if (!isAutocompleteOpen || !options.length) {
      return '';
    }
    return intl.formatMessage(messages.optionsFound);
  }, [isAutocompleteOpen, intl, options]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(AutocompleteContainer, {
    "data-testid": "jql-editor-autocomplete",
    tabIndex: -1,
    ref: onContainerRef,
    isOpen: isAutocompleteOpen,
    onBlur: onEditorViewBlur,
    onFocus: onEditorViewFocus
  }, /*#__PURE__*/React.createElement(AutocompleteOptionsContainer, {
    ref: onScrollContainerRef,
    onMouseMove: onMouseMove
  }, /*#__PURE__*/React.createElement(OptionList, {
    role: "listbox",
    id: autocompleteId
  }, options.map(function (option, index) {
    var isSelected = option.id === selectedOptionId;
    return /*#__PURE__*/React.createElement(AutocompleteOption, _extends({
      key: option.value,
      isSelected: isSelected
    }, isSelected && {
      ref: selectedItemRef
    }, {
      option: option,
      onClick: function onClick() {
        return handleClick(option, index, false);
      },
      onMouseMove: function onMouseMove() {
        var _options$index;
        if (((_options$index = options[index]) === null || _options$index === void 0 ? void 0 : _options$index.id) !== selectedOptionId) {
          var _options$index2;
          setSelectedAutocompleteOptionId((_options$index2 = options[index]) === null || _options$index2 === void 0 ? void 0 : _options$index2.id);
        }
      }
    }));
  }))), loading && /*#__PURE__*/React.createElement(AutocompleteLoadingFooter, {
    "data-testid": "jql-editor-autocomplete-loading",
    hasOptions: !!options.length
  }, /*#__PURE__*/React.createElement(Spinner, {
    size: "small"
  }))), /*#__PURE__*/React.createElement(ScreenReaderText, {
    role: "status",
    "aria-live": "polite"
  }, announcedMessage));
};
export default AutocompleteDropdown;