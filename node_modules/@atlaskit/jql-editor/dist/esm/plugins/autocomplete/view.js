import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { Fragment, Slice } from '@atlaskit/editor-prosemirror/model';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { isListOperator } from '@atlaskit/jql-ast';
import getDocumentPosition from '../common/get-document-position';
import ReactPluginView from '../common/react-plugin-view';
import Autocomplete from './components/autocomplete';
import { AUTOCOMPLETE_PLUGIN_NAME, JQLAutocompletePluginKey } from './constants';

/**
 * Returns whether an opening parenthesis should be automatically inserted for this option (e.g. after a list operator)
 */
var shouldInsertOpeningParenthesis = function shouldInsertOpeningParenthesis(_ref) {
  var type = _ref.type,
    context = _ref.context,
    isListFunction = _ref.isListFunction;
  if (type === 'value' || type === 'function' || type === 'keyword') {
    var operator = context === null || context === void 0 ? void 0 : context.operator;
    if (operator && isListOperator(operator) && !(context !== null && context !== void 0 && context.isList) && !isListFunction) {
      return true;
    }
  }
  return false;
};
var AutocompletePluginView = /*#__PURE__*/function (_ReactPluginView) {
  function AutocompletePluginView(view, keymap, portalActions, enableRichInlineNodes) {
    var _this;
    _classCallCheck(this, AutocompletePluginView);
    _this = _callSuper(this, AutocompletePluginView, [portalActions, AUTOCOMPLETE_PLUGIN_NAME, 'main']);
    _defineProperty(_this, "getComponent", function () {
      return Autocomplete;
    });
    _defineProperty(_this, "getInitialComponentProps", function () {
      return {
        keymap: _this.keymap,
        onClick: _this.onReplaceSuggestion
      };
    });
    _defineProperty(_this, "onReplaceSuggestion", function (option) {
      var _option$replacePositi = _slicedToArray(option.replacePosition, 2),
        from = _option$replacePositi[0],
        to = _option$replacePositi[1];
      var transaction = _this.view.state.tr;
      transaction.setMeta(JQLAutocompletePluginKey, true);

      // Request query hydration if we are inserting a user node
      if (_this.enableRichInlineNodes && option.type === 'value' && option.valueType === 'user') {
        transaction.setMeta('hydrate', true);
      }
      var documentFrom = getDocumentPosition(transaction.doc, from);
      var documentTo = getDocumentPosition(transaction.doc, to);

      // Change current selection to the mapped replace position
      transaction.setSelection(TextSelection.create(transaction.doc, documentTo, documentFrom));

      // Replace selected range with the selected autocomplete option
      transaction.replaceSelection(_this.getSliceForSuggestion(option));
      _this.view.focus();
      _this.view.dispatch(transaction);
    });
    _defineProperty(_this, "getSliceForSuggestion", function (option) {
      var value = option.value,
        name = option.name,
        nameOnRichInlineNode = option.nameOnRichInlineNode,
        valueType = option.valueType,
        context = option.context;
      var nodes = [];
      if (shouldInsertOpeningParenthesis(option)) {
        nodes.push(_this.view.state.schema.text('('));
      }
      var textContent = _this.view.state.schema.text(value);
      if (!_this.enableRichInlineNodes) {
        nodes.push(textContent);
      } else {
        switch (valueType) {
          case 'user':
            {
              var attributes = {
                type: 'user',
                id: value,
                name: nameOnRichInlineNode !== null && nameOnRichInlineNode !== void 0 ? nameOnRichInlineNode : name,
                fieldName: context === null || context === void 0 ? void 0 : context.field
              };
              nodes.push(_this.view.state.schema.nodes.user.create(attributes, textContent));
              break;
            }
          default:
            {
              nodes.push(textContent);
              break;
            }
        }
      }
      return new Slice(Fragment.from(nodes), 0, 0);
    });
    _this.view = view;
    _this.keymap = keymap;
    _this.enableRichInlineNodes = enableRichInlineNodes;
    return _this;
  }
  _inherits(AutocompletePluginView, _ReactPluginView);
  return _createClass(AutocompletePluginView, [{
    key: "isSameState",
    value: function isSameState(state, prevState) {
      return prevState.doc.eq(state.doc) && prevState.selection.eq(state.selection);
    }
  }]);
}(ReactPluginView);
export { AutocompletePluginView as default };