import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["Component"];
import React, { useEffect } from 'react';
import { di } from 'react-magnetic-di';
import { ErrorMessage } from '@atlaskit/form';
import { JQLSyntaxError } from '@atlaskit/jql-ast';
import { fg } from '@atlaskit/platform-feature-flags';
import { JQL_EDITOR_INPUT_ID, JQL_EDITOR_VALIDATION_ID } from '../../../../common/constants';
import { commonMessages } from '../../../../common/messages';
import { useEditorThemeContext } from '../../../../hooks/use-editor-theme';
import { useEditorViewIsInvalid } from '../../../../hooks/use-editor-view-is-invalid';
import { useCustomErrorComponent, useExternalMessages, useIntl, useJqlError, useScopedId, useStoreActions } from '../../../../state';
import { extractMessageNodes, FormatMessages, MessageContainer } from '../format';
import { messages } from './messages';

/**
 * This function maps client side validation errors and external messages into a unified format
 * This is so that the output of this function can then be processed in a unified manner by different renderers
 */
var useErrorMessages = function useErrorMessages() {
  var _useIntl = useIntl(),
    _useIntl2 = _slicedToArray(_useIntl, 1),
    formatMessage = _useIntl2[0].formatMessage;
  var _useJqlError = useJqlError(),
    _useJqlError2 = _slicedToArray(_useJqlError, 1),
    jqlError = _useJqlError2[0];
  var _useExternalMessages = useExternalMessages(),
    _useExternalMessages2 = _slicedToArray(_useExternalMessages, 1),
    externalErrors = _useExternalMessages2[0].errors;
  var _useStoreActions = useStoreActions(),
    _useStoreActions2 = _slicedToArray(_useStoreActions, 2),
    externalErrorMessageViewed = _useStoreActions2[1].externalErrorMessageViewed;
  var editorViewIsInvalid = useEditorViewIsInvalid();
  useEffect(function () {
    // Emit a UI event whenever external errors has changed
    externalErrorMessageViewed();
  }, [externalErrorMessageViewed, externalErrors]);
  if (!editorViewIsInvalid) {
    return null;
  }

  /**
   * Transform a string message to take the form of an ExternalMessage,
   * so that we can reduce a bunch of conditionals when processing the output of useErrorMessages
   */
  var toExternalMessageShape = function toExternalMessageShape(message) {
    return [{
      type: 'error',
      message: message
    }];
  };

  // Prioritise client errors over external errors
  if (jqlError instanceof JQLSyntaxError) {
    return toExternalMessageShape("".concat(jqlError.message, " ").concat(formatMessage(messages.jqlErrorPosition, {
      lineNumber: jqlError.line,
      charPosition: jqlError.charPositionInLine + 1
    })));
  }
  if (externalErrors.length > 0) {
    return externalErrors;
  }
  if (jqlError !== null) {
    return toExternalMessageShape(formatMessage(commonMessages.unknownError));
  }
  return null;
};

/**
 * This is a decorator component to include the editorTheme prop to the already passed list of props
 */
var CustomComponentDecoratedWithEditorTheme = function CustomComponentDecoratedWithEditorTheme(props) {
  var Component = props.Component,
    rest = _objectWithoutProperties(props, _excluded);
  var editorThemeContext = useEditorThemeContext();

  // This is a slightly redundant condition.
  // Technically, CustomErrorMessage component should never be called with an undefined Component
  // This is enforced by the static types. Adding this condition as an extra layer of protection
  if (!Component) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, "props.children");
  }
  return /*#__PURE__*/React.createElement(Component, _extends({
    editorTheme: editorThemeContext
  }, rest));
};
export var ErrorMessages = function ErrorMessages() {
  var _useScopedId = useScopedId(JQL_EDITOR_INPUT_ID),
    _useScopedId2 = _slicedToArray(_useScopedId, 1),
    editorId = _useScopedId2[0];
  var _useScopedId3 = useScopedId(JQL_EDITOR_VALIDATION_ID),
    _useScopedId4 = _slicedToArray(_useScopedId3, 1),
    validationId = _useScopedId4[0];
  var errorMessages = useErrorMessages();
  var _useCustomErrorCompon = useCustomErrorComponent(),
    _useCustomErrorCompon2 = _slicedToArray(_useCustomErrorCompon, 1),
    CustomErrorComponent = _useCustomErrorCompon2[0];
  var childrenToRender = errorMessages != null ? /*#__PURE__*/React.createElement(MessageContainer, null, /*#__PURE__*/React.createElement(ErrorMessage, {
    testId: JQL_EDITOR_VALIDATION_ID
  }, fg('jql_editor_a11y') ? /*#__PURE__*/React.createElement("span", {
    role: "alert",
    id: validationId
  }, /*#__PURE__*/React.createElement(FormatMessages, {
    messages: errorMessages
  })) : /*#__PURE__*/React.createElement("span", {
    role: "alert",
    "aria-describedby": editorId
  }, /*#__PURE__*/React.createElement(FormatMessages, {
    messages: errorMessages
  })))) : null;

  // Only render CustomErrorComponent if there is an errorMessage
  if (errorMessages != null && CustomErrorComponent) {
    return /*#__PURE__*/React.createElement(CustomComponentDecoratedWithEditorTheme, {
      testId: JQL_EDITOR_VALIDATION_ID,
      editorId: editorId,
      validationId: validationId,
      Component: CustomErrorComponent,
      errorMessages: extractMessageNodes(errorMessages)
    }, childrenToRender);
  }
  return childrenToRender;
};