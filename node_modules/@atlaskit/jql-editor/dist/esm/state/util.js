import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import escapeRegExp from 'lodash/escapeRegExp';
import uuidv5 from 'uuid/v5';
import { AbstractJastVisitor } from '@atlaskit/jql-ast';
import getDocumentPosition from '../plugins/common/get-document-position';
import { getNodeText } from '../utils/document-text';
// Unique namespace to identify JQL autocomplete options!
var UUID_NAMESPACE = '9a90299c-aa58-494b-b6a1-e93206e3fdd6';
export var getAutocompleteOptionId = function getAutocompleteOptionId(value) {
  return uuidv5(value, UUID_NAMESPACE);
};
export var tokensToAutocompleteOptions = function tokensToAutocompleteOptions(tokens) {
  var tokensToDisplay = tokens.values;
  if (tokens.matchedText !== '') {
    // Candidates that start with last token text but are not an exact match (case insensitive)
    var regex = new RegExp("^".concat(escapeRegExp(tokens.matchedText), "[^$]"), 'i');
    tokensToDisplay = tokens.values.filter(function (token) {
      return regex.test(token);
    });
  }
  return tokensToDisplay.map(function (token) {
    var _tokens$context;
    return {
      id: getAutocompleteOptionId(token),
      name: token,
      value: token,
      replacePosition: tokens.replacePosition,
      matchedText: tokens.matchedText,
      context: (_tokens$context = tokens.context) !== null && _tokens$context !== void 0 ? _tokens$context : null,
      type: 'keyword'
    };
  });
};
export var getReplacePositionStart = function getReplacePositionStart(_ref) {
  var rules = _ref.rules,
    tokens = _ref.tokens;
  // Matching tokens should be prioritized over rules when calculating autocomplete dropdown position
  if (tokens.values.length) {
    return tokens.replacePosition[0];
  }

  // Same precedence as `useAutocompleteOptions`, this may change in future if we don't limit suggestions to one rule
  var rulePrecedence = ['value', 'function', 'list', 'operator', 'field'];
  for (var _i = 0, _rulePrecedence = rulePrecedence; _i < _rulePrecedence.length; _i++) {
    var rule = _rulePrecedence[_i];
    if (Object.prototype.hasOwnProperty.call(rules, rule)) {
      return rules[rule].replacePosition[0];
    }
  }
  return tokens.replacePosition[0];
};
export var getAutocompletePosition = function getAutocompletePosition(editorView, replacePositionStart) {
  var _editorView$state = editorView.state,
    doc = _editorView$state.doc,
    selection = _editorView$state.selection;
  var documentPosition = getDocumentPosition(doc, replacePositionStart);
  var _editorView$coordsAtP = editorView.coordsAtPos(documentPosition),
    left = _editorView$coordsAtP.left;
  // Vertically position autocomplete relative to selection end
  var _editorView$coordsAtP2 = editorView.coordsAtPos(selection.to),
    bottom = _editorView$coordsAtP2.bottom;
  return {
    top: bottom,
    left: left
  };
};
var getDebugSelectionAttributes = function getDebugSelectionAttributes() {
  var _selection$anchorNode, _selection$anchorNode2, _selection$focusNode, _selection$focusNode2;
  var selection = document.getSelection();
  if (selection === null || selection.type === 'None') {
    return {};
  }
  return {
    anchorOffset: selection.anchorOffset,
    anchorNodeText: (_selection$anchorNode = selection.anchorNode) === null || _selection$anchorNode === void 0 ? void 0 : _selection$anchorNode.textContent,
    anchorNodeName: (_selection$anchorNode2 = selection.anchorNode) === null || _selection$anchorNode2 === void 0 ? void 0 : _selection$anchorNode2.nodeName,
    focusOffset: selection.focusOffset,
    focusNodeText: (_selection$focusNode = selection.focusNode) === null || _selection$focusNode === void 0 ? void 0 : _selection$focusNode.textContent,
    focusNodeName: (_selection$focusNode2 = selection.focusNode) === null || _selection$focusNode2 === void 0 ? void 0 : _selection$focusNode2.nodeName
  };
};
export var sendDebugMessage = function sendDebugMessage(message, editorView, editorState, onDebugUnsafeMessage, eventAttributes) {
  if (!onDebugUnsafeMessage) {
    return;
  }
  try {
    var editorViewStateText = getNodeText(editorView.state.doc, 0, editorView.state.doc.content.size);
    var editorViewStateJson = JSON.stringify(editorView.state.toJSON());
    var editorStateJson = JSON.stringify(editorState.toJSON());
    var editorViewHtml = editorView.dom.innerHTML;
    onDebugUnsafeMessage(message, _objectSpread(_objectSpread({
      editorStateJson: editorStateJson,
      editorViewStateText: editorViewStateText,
      editorViewStateJson: editorViewStateJson,
      editorViewHtml: editorViewHtml
    }, getDebugSelectionAttributes()), eventAttributes));
  } catch (ignored) {
    // Do nothing
  }
};
export var getFieldNodes = function getFieldNodes(ast) {
  if (!ast.query) {
    return new Set();
  }
  var visitor = new FindFieldsVisitor();
  ast.query.accept(visitor);
  return visitor.fields;
};
var FindFieldsVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function FindFieldsVisitor() {
    var _this;
    _classCallCheck(this, FindFieldsVisitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, FindFieldsVisitor, [].concat(args));
    _defineProperty(_this, "fields", new Set());
    _defineProperty(_this, "visitQuery", function (query) {
      if (query.where !== undefined) {
        query.where.accept(_this);
      }
      if (query.orderBy !== undefined) {
        query.orderBy.accept(_this);
      }
    });
    _defineProperty(_this, "visitOrderBy", function (orderBy) {
      orderBy.fields.map(function (orderByField) {
        return orderByField.accept(_this);
      });
    });
    _defineProperty(_this, "visitOrderByField", function (orderByField) {
      orderByField.field.accept(_this);
    });
    _defineProperty(_this, "visitCompoundClause", function (compoundClause) {
      compoundClause.clauses.map(function (clause) {
        return clause.accept(_this);
      });
    });
    _defineProperty(_this, "visitTerminalClause", function (terminalClause) {
      terminalClause.field.accept(_this);
    });
    _defineProperty(_this, "visitNotClause", function (notClause) {
      notClause.clause.accept(_this);
    });
    _defineProperty(_this, "visitField", function (field) {
      _this.fields.add(field.value.toLowerCase());
    });
    return _this;
  }
  _inherits(FindFieldsVisitor, _AbstractJastVisitor);
  return _createClass(FindFieldsVisitor, [{
    key: "defaultResult",
    value: function defaultResult() {
      return;
    }
  }]);
}(AbstractJastVisitor);