import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { AbstractJastVisitor } from '@atlaskit/jql-ast';

/**
 * Given an AST with parse errors, this visitor returns a valid query that is equivalent for hydration purposes
 * (i.e. just fields, operators and values). Resulting query is generated on a best-effort basis and depends on
 * a successful parser error recovery.
 *
 * Example 1:
 * - Original query: "assignee in (abc-123-def"
 * - Equivalent query: "assignee in (abc-123-def)"
 *
 * Example 2:
 * - Original query: "project = EM and status in (Done, currentUser(), EMPTY) and reporter in"
 * - Equivalent query: "project = EM and status in (Done)"
 */
export var ValidQueryVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function ValidQueryVisitor() {
    var _this;
    _classCallCheck(this, ValidQueryVisitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, ValidQueryVisitor, [].concat(args));
    _defineProperty(_this, "visitQuery", function (query) {
      if (!query.where) {
        return '';
      }
      return query.where.accept(_this);
    });
    _defineProperty(_this, "visitCompoundClause", function (compoundClause) {
      return compoundClause.clauses.map(function (clause) {
        return clause.accept(_this);
      }).filter(function (value) {
        return !!value;
      }).join(' and ');
    });
    _defineProperty(_this, "visitTerminalClause", function (terminalClause) {
      var field = terminalClause.field,
        operator = terminalClause.operator,
        operand = terminalClause.operand;
      if (!operator || !operand) {
        return '';
      }
      var operandValue = operand.accept(_this);
      if (!operandValue) {
        return '';
      }
      return "".concat(field.text, " ").concat(operator.value, " ").concat(operandValue);
    });
    _defineProperty(_this, "visitNotClause", function (notClause) {
      return notClause.clause.accept(_this);
    });
    _defineProperty(_this, "visitValueOperand", function (valueOperand) {
      return valueOperand.text;
    });
    _defineProperty(_this, "visitListOperand", function (listOperand) {
      return "(".concat(listOperand.values.map(function (value) {
        return value.accept(_this);
      }).filter(function (value) {
        return !!value;
      }).join(', '), ")");
    });
    return _this;
  }
  _inherits(ValidQueryVisitor, _AbstractJastVisitor);
  return _createClass(ValidQueryVisitor, [{
    key: "defaultResult",
    value: function defaultResult() {
      return '';
    }
  }]);
}(AbstractJastVisitor);