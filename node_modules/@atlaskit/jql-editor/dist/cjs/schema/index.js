"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultEditorState = exports.configurePlugins = exports.clipboardTextSerializer = exports.clipboardTextParser = exports.JQLEditorSchema = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mapValues = _interopRequireDefault(require("lodash/mapValues"));
var _commands = require("@atlaskit/editor-prosemirror/commands");
var _history = require("@atlaskit/editor-prosemirror/history");
var _keymap = require("@atlaskit/editor-prosemirror/keymap");
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _plugins = require("../plugins");
var _constants = require("../plugins/rich-inline-nodes/constants");
var _nodes = require("../plugins/rich-inline-nodes/nodes");
var _createNodeSpec = require("../plugins/rich-inline-nodes/util/create-node-spec");
var _documentText = require("../utils/document-text");
var _splitTextByNewLine = require("../utils/split-text-by-new-line");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var createMarkWithStyle = function createMarkWithStyle(tokenType) {
  var mark = document.createElement('span');
  mark.className = "mark-token-".concat(tokenType);
  mark.setAttribute('data-token-type', tokenType);
  mark.setAttribute('spellcheck', 'false');
  return mark;
};
var JQLEditorSchema = exports.JQLEditorSchema = new _model.Schema({
  nodes: _objectSpread({
    doc: {
      content: 'paragraph+'
    },
    paragraph: {
      content: "(text|".concat(_constants.RICH_INLINE_NODE, ")*"),
      toDOM: function toDOM() {
        return ['p', {
          spellcheck: 'false'
        }, 0];
      },
      parseDOM: [{
        tag: 'p'
      }]
    },
    text: {}
  }, (0, _mapValues.default)(_nodes.richInlineNodes, function (spec, name) {
    return (0, _createNodeSpec.createNodeSpec)(name, spec.attrs);
  })),
  marks: {
    token: {
      toDOM: function toDOM(_ref) {
        var attrs = _ref.attrs;
        return createMarkWithStyle(attrs.tokenType);
      },
      attrs: {
        tokenType: {}
      }
    },
    cursor: {
      toDOM: function toDOM() {
        return document.createElement('span');
      }
    }
  }
});
var domParser = _model.DOMParser.fromSchema(JQLEditorSchema);

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextSerializer but
 * preserves consecutive empty block nodes.
 */
var clipboardTextSerializer = exports.clipboardTextSerializer = function clipboardTextSerializer(slice) {
  return (0, _documentText.getFragmentText)(slice.content, 0, slice.content.size);
};

/**
 * Emulate the behaviour of the default https://prosemirror.net/docs/ref/#view.EditorProps.clipboardTextParser but
 * preserves consecutive empty lines.
 */
var clipboardTextParser = exports.clipboardTextParser = function clipboardTextParser(text, $context) {
  var dom = document.createElement('div');
  // Split each line of text and wrap each in a p tag.
  (0, _splitTextByNewLine.splitTextByNewLine)(text).forEach(function (block) {
    dom.appendChild(document.createElement('p')).textContent = block;
  });
  return domParser.parseSlice(dom, {
    context: $context,
    preserveWhitespace: true
  });
};
var defaultEditorState = exports.defaultEditorState = _state.EditorState.create({
  schema: JQLEditorSchema
});

// @types/prosemirror-commands@1.0.1 does not export Command and Keymap types
// TODO: update to Command<JQLEditorSchemaType> and Keymap<JQLEditorSchemaType> if types are bumped to a newer version

var configurePlugins = exports.configurePlugins = function configurePlugins(editorState, onSearchCommand, intlRef, mainId, portalActions, enableRichInlineNodes) {
  return editorState.reconfigure({
    plugins: [(0, _history.history)(),
    // Other plugins rely on having AST as part of the state during a transaction, this plugin should be kept first
    (0, _plugins.jqlAstPlugin)(intlRef), (0, _plugins.jqlSyntaxHighlightingPlugin)()].concat((0, _toConsumableArray2.default)(portalActions !== undefined ? [(0, _plugins.autocompletePlugin)(portalActions, enableRichInlineNodes)].concat((0, _toConsumableArray2.default)(enableRichInlineNodes ? [(0, _plugins.richInlineNodesPlugin)(portalActions)] : [])) : []), [(0, _plugins.validationTooltipPlugin)(mainId),
    // Keeping these at the bottom allows plugins to define custom key bindings to override default behavior
    (0, _keymap.keymap)({
      'Mod-z': _history.undo,
      'Mod-Shift-z': _history.redo,
      'Mod-y': _history.redo,
      // Mimic default Enter behavior in PM's base keymap, allowing to insert new lines even when autocomplete is open
      'Shift-Enter': _commands.baseKeymap.Enter
    })], (0, _toConsumableArray2.default)(!onSearchCommand ? [] : [keymapNoRepeat({
      'Mod-Enter': onSearchCommand,
      Enter: onSearchCommand
    })]), [(0, _keymap.keymap)(_commands.baseKeymap)])
  });
};
var noopCommand = function noopCommand() {
  return true;
};
function keymapNoRepeat(bindings) {
  var handler = (0, _keymap.keydownHandler)(bindings);
  var proxyBindings = (0, _mapValues.default)(bindings, function () {
    return noopCommand;
  });
  var proxyHandler = (0, _keymap.keydownHandler)(proxyBindings);
  return new _state.Plugin({
    props: {
      handleKeyDown: function handleKeyDown(view, event) {
        if (event.repeat) {
          return proxyHandler(view, event);
        }
        return handler(view, event);
      }
    }
  });
}