"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodeText = exports.getFragmentText = void 0;
/**
 * Get all text between positions `from` and `to` with a newline char between block nodes.
 */
var getNodeText = exports.getNodeText = function getNodeText(node, from, to) {
  return getFragmentText(node.content, from, to);
};

/**
 * Get all text between positions `from` and `to` with a newline char between block nodes.
 */
var getFragmentText = exports.getFragmentText = function getFragmentText(fragment, from, to) {
  return textBetween(fragment, from, to, '\n');
};

/**
 * A modified version of {@link Fragment#textBetween}. The default implementation does not insert `blockSeparator` for
 * consecutive empty block nodes (i.e. empty blocks are collapsed into one).
 */
var textBetween = function textBetween(fragment, from, to, blockSeparator, leafText) {
  var text = '';
  var enteredInitialBlock = false;
  fragment.nodesBetween(from, to, function (innerNode, pos) {
    if (innerNode.isText) {
      var _innerNode$text;
      text += (_innerNode$text = innerNode.text) === null || _innerNode$text === void 0 ? void 0 : _innerNode$text.slice(Math.max(from, pos) - pos, to - pos);
    } else if (innerNode.isLeaf && leafText) {
      text += leafText;
    } else if (innerNode.isBlock) {
      if (enteredInitialBlock) {
        text += blockSeparator;
      } else {
        enteredInitialBlock = true;
      }
    }
  }, 0);
  return text;
};