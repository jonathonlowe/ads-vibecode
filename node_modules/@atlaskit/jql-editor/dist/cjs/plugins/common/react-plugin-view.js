"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _Subject = require("rxjs/Subject");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Abstract class for Prosemirror plugin views which need to mount a React component. Concrete subclasses must implement
 * {@link ReactPluginView#getComponent} which specifies the React component to render, along with
 * {@link ReactPluginView#getInitialComponentProps} which returns any props to pass to the component on initial render.
 *
 * After the class is constructed, the caller must invoke {@link ReactPluginView#init} in order to mount the component.
 *
 * If there are external changes which the component needs to respond to, {@link ReactPluginView#componentSubject} can
 * be used to trigger a re-render of the component with updated props. For example:
 * ```
 * update = (view: EditorView) => {
 *   this.componentSubject.next(this.getComponentProps(view));
 * };
 *
 * getComponentProps = (view: EditorView) => {
 *   // Some logic to get props from the Prosemirror view
 * }
 * ```
 */
var ReactPluginView = exports.default = /*#__PURE__*/function () {
  /**
   * Construct a Prosemirror plugin view which will render a React component in a portal.
   *
   * @param portalActions Provides callback functions which can be invoked to create and destroy a portal.
   * @param portalKey Unique identifier for the plugin component.
   * @param containerKey Key representing the HTML container the React component will be portalled into.
   * @protected
   */
  function ReactPluginView(portalActions, portalKey, containerKey) {
    var _this = this;
    (0, _classCallCheck2.default)(this, ReactPluginView);
    (0, _defineProperty2.default)(this, "componentSubject", new _Subject.Subject());
    (0, _defineProperty2.default)(this, "init", function () {
      var Component = _this.getComponent();
      var PortallingComponent = function PortallingComponent() {
        var _useState = (0, _react.useState)(function () {
            return _this.getInitialComponentProps();
          }),
          _useState2 = (0, _slicedToArray2.default)(_useState, 2),
          state = _useState2[0],
          setState = _useState2[1];
        (0, _react.useEffect)(function () {
          // Subscribe to the RxJS subject so concrete subclasses can emit events to re-render the plugin component.
          var subscription = _this.componentSubject.subscribe(function (updatedProps) {
            setState(updatedProps);
          });
          return function () {
            return subscription.unsubscribe();
          };
        }, []);
        return /*#__PURE__*/_react.default.createElement(Component, state);
      };

      // Dispatch onCreatePortal which will allow the handler to create a new portalled React component
      _this.portalActions.onCreatePortal(_this.portalKey, /*#__PURE__*/_react.default.createElement(PortallingComponent, null), _this.containerKey);
    });
    this.portalActions = portalActions;
    this.portalKey = portalKey;
    this.containerKey = containerKey;
  }
  return (0, _createClass2.default)(ReactPluginView, [{
    key: "destroy",
    value: function destroy() {
      // Dispatch onDestroyPortal which will allow the handler to remove the portalled React component.
      this.portalActions.onDestroyPortal(this.portalKey);
    }

    /**
     * Return a React component to render for the plugin.
     */

    /**
     * Return props to set on the component for initial render.
     */
  }]);
}();