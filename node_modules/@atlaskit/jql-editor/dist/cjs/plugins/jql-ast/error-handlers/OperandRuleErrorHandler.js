"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleOperandRuleError = void 0;
var _jqlParser = require("@atlaskit/jql-parser");
var _messages = require("../messages");
var _utils = require("../utils");
var _ExpectedTokensErrorHandler = require("./ExpectedTokensErrorHandler");
/**
 * Show the appropriate error message when parsing JQL fails and an operand rule was expected.
 */
var handleOperandRuleError = exports.handleOperandRuleError = function handleOperandRuleError(recognizer, currentToken, expectedTokens, rules, intl, exception) {
  // If there are no expected autocomplete tokens, then attempt to find viable tokens from the exception/parser.
  if (expectedTokens.length === 0) {
    expectedTokens = (0, _utils.getTokenDisplayNames)(recognizer, (0, _utils.getExpectedTokensFromParserOrException)(recognizer, exception));
  }
  var isEOF = currentToken.type === _jqlParser.JQLLexer.EOF;
  if (rules.value && rules.list && rules.function) {
    return isEOF ? intl.formatMessage(_messages.errorMessages.expectingOperandBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingOperandButReceived, {
      received: currentToken.text
    });
  }
  if (rules.value && rules.function) {
    return isEOF ? intl.formatMessage(_messages.errorMessages.expectingValueOrFunctionBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingValueOrFunctionButReceived, {
      received: currentToken.text
    });
  }
  if (rules.list && rules.function) {
    // Lists and functions are the only operands that contain structural tokens (i.e. LPAREN, RPAREN and COMMA).
    // So, if there are specific expected tokens, we prioritize those over generic rule messages.
    if (expectedTokens.length) {
      return (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken, expectedTokens, intl, exception);
    }
    return isEOF ? intl.formatMessage(_messages.errorMessages.expectingListOrFunctionBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingListOrFunctionButReceived, {
      received: currentToken.text
    });
  }

  // Value or list combination is not possible with current grammar definition

  if (rules.function) {
    // Lists and functions are the only operands that contain structural tokens (i.e. LPAREN, RPAREN and COMMA).
    // So, if there are specific expected tokens, we prioritize those over generic rule messages.
    if (expectedTokens.length) {
      return (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken, expectedTokens, intl, exception);
    }
    return isEOF ? intl.formatMessage(_messages.errorMessages.expectingFunctionBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingFunctionButReceived, {
      received: currentToken.text
    });
  }
  if (rules.list) {
    // Lists and functions are the only operands that contain structural tokens (i.e. LPAREN, RPAREN and COMMA).
    // So, if there are specific expected tokens, we prioritize those over generic rule messages.
    if (expectedTokens.length) {
      return (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken, expectedTokens, intl, exception);
    }
    return isEOF ? intl.formatMessage(_messages.errorMessages.expectingListBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingListButReceived, {
      received: currentToken.text
    });
  }
  return isEOF ? intl.formatMessage(_messages.errorMessages.expectingValueBeforeEOF) : intl.formatMessage(_messages.errorMessages.expectingValueButReceived, {
    received: currentToken.text
  });
};