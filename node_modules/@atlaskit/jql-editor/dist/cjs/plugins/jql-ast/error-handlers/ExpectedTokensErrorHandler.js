"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleExpectedTokensError = void 0;
var _jqlParser = require("@atlaskit/jql-parser");
var _messages = require("../../../common/messages");
var _constants = require("../constants");
var _messages2 = require("../messages");
var _utils = require("../utils");
/**
 * Show the appropriate error message when parsing JQL fails and 0 or more tokens were expected.
 *
 * If no `expectedTokens` were provided then we'll attempt to find viable tokens to suggest from the provided
 * exception/parser state.
 */
var handleExpectedTokensError = exports.handleExpectedTokensError = function handleExpectedTokensError(recognizer, currentToken, expectedTokens, intl, exception) {
  // If there are no expected autocomplete tokens, then attempt to find viable tokens from the exception/parser.
  if (expectedTokens.length === 0) {
    expectedTokens = (0, _utils.getTokenDisplayNames)(recognizer, (0, _utils.getExpectedTokensFromParserOrException)(recognizer, exception));
  }
  var lowPriorityTokenNames = (0, _utils.getTokenDisplayNames)(recognizer, _constants.lowPriorityTokens);

  // Only include tokens that are NOT low priority
  var highPriorityTokens = expectedTokens.filter(function (tokenType) {
    return !lowPriorityTokenNames.includes(tokenType);
  });

  // If we have any tokens that are high priority then we want to show them (without low priority suggestions).
  if (highPriorityTokens.length > 0) {
    expectedTokens = highPriorityTokens;
  }
  var isEOF = currentToken.type === _jqlParser.JQLLexer.EOF;
  if (expectedTokens.length > 1) {
    var firstExpectedTokens = expectedTokens.slice(0, -1)
    // Need to wrap tokens in single quotes ourselves as we cannot do it in the message descriptor
    .map(function (token) {
      return "'".concat(token, "'");
    }).join(', ');
    var lastExpectedToken = expectedTokens[expectedTokens.length - 1];
    return isEOF ? intl.formatMessage(_messages2.errorMessages.expectingMultipleTokensBeforeEOF, {
      firstExpectedTokens: firstExpectedTokens,
      lastExpectedToken: lastExpectedToken
    }) : intl.formatMessage(_messages2.errorMessages.expectingMultipleTokensButReceived, {
      firstExpectedTokens: firstExpectedTokens,
      lastExpectedToken: lastExpectedToken,
      received: currentToken.text
    });
  } else if (expectedTokens.length === 1) {
    return isEOF ? intl.formatMessage(_messages2.errorMessages.expectingTokenBeforeEOF, {
      expectedToken: expectedTokens[0]
    }) : intl.formatMessage(_messages2.errorMessages.expectingTokenButReceived, {
      expectedToken: expectedTokens[0],
      received: currentToken.text
    });
  } else {
    return isEOF ? intl.formatMessage(_messages.commonMessages.unknownError) : intl.formatMessage(_messages2.errorMessages.unknownErrorAtToken, {
      received: currentToken.text
    });
  }
};