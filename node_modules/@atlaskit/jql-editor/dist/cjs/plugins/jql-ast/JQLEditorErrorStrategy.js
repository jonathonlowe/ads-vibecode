"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPrintableChar = exports.getJavaCodeFromChar = exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _antlr4ts = require("antlr4ts");
var _padStart = _interopRequireDefault(require("lodash/padStart"));
var _jqlAst = require("@atlaskit/jql-ast");
var _jqlAutocomplete = require("@atlaskit/jql-autocomplete");
var _jqlParser = require("@atlaskit/jql-parser");
var _constants = require("./constants");
var _CustomFieldRuleErrorHandler = require("./error-handlers/CustomFieldRuleErrorHandler");
var _ExpectedTokensErrorHandler = require("./error-handlers/ExpectedTokensErrorHandler");
var _FieldPropertyIdErrorHandler = require("./error-handlers/FieldPropertyIdErrorHandler");
var _FieldRuleErrorHandler = require("./error-handlers/FieldRuleErrorHandler");
var _FunctionArgumentRuleErrorHandler = require("./error-handlers/FunctionArgumentRuleErrorHandler");
var _OperandRuleErrorHandler = require("./error-handlers/OperandRuleErrorHandler");
var _OperatorRuleErrorHandler = require("./error-handlers/OperatorRuleErrorHandler");
var _messages = require("./messages");
var _utils = require("./utils");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
var isEscape = function isEscape(char) {
  return char === '\\';
};
var getPrintableChar = exports.getPrintableChar = function getPrintableChar(char) {
  var hex = char.charCodeAt(0).toString(16).toUpperCase();
  return "U+".concat((0, _padStart.default)(hex, 4, '0'));
};
var getJavaCodeFromChar = exports.getJavaCodeFromChar = function getJavaCodeFromChar(char) {
  var hex = char.charCodeAt(0).toString(16);
  return "\\u".concat((0, _padStart.default)(hex, 4, '0'));
};
var JQLEditorErrorStrategy = exports.default = /*#__PURE__*/function (_DefaultErrorStrategy) {
  function JQLEditorErrorStrategy(intlRef) {
    var _this;
    (0, _classCallCheck2.default)(this, JQLEditorErrorStrategy);
    _this = _callSuper(this, JQLEditorErrorStrategy);
    _this.intlRef = intlRef;
    return _this;
  }
  (0, _inherits2.default)(JQLEditorErrorStrategy, _DefaultErrorStrategy);
  return (0, _createClass2.default)(JQLEditorErrorStrategy, [{
    key: "reportInputMismatch",
    value: function reportInputMismatch(recognizer, exception) {
      this.handleSyntaxError(recognizer, recognizer.currentToken, exception);
    }
  }, {
    key: "reportUnwantedToken",
    value: function reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      this.handleSyntaxError(recognizer, recognizer.currentToken);
    }
  }, {
    key: "reportMissingToken",
    value: function reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);

      // This is called when single token insertion is a viable recovery strategy for the error. In this case we can
      // use expected tokens from the parser to display an error to the user. If there are no viable tokens to show then
      // we should fallback to syntax error handling.
      if ((0, _utils.getExpectedTokensFromParserOrException)(recognizer).length > 0) {
        var message = (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, recognizer.currentToken,
        // We want to derive expectedTokens from the parser state
        [], this.intlRef.current);
        recognizer.notifyErrorListeners(message, recognizer.currentToken, undefined);
      } else {
        this.handleSyntaxError(recognizer, recognizer.currentToken);
      }
    }
  }, {
    key: "reportNoViableAlternative",
    value: function reportNoViableAlternative(recognizer, exception) {
      var _exception$getOffendi;
      // There are some cases, like "status was", where parser is unable to provide viable alternatives for current
      // token, but autocomplete engine is still able to provide meaningful suggestions at offending token index
      var currentToken = (_exception$getOffendi = exception === null || exception === void 0 ? void 0 : exception.getOffendingToken()) !== null && _exception$getOffendi !== void 0 ? _exception$getOffendi : recognizer.currentToken;
      this.handleSyntaxError(recognizer, currentToken, exception);
    }
  }, {
    key: "reportFailedPredicate",
    value: function reportFailedPredicate(recognizer, e) {
      // TODO: Don't know how to produce this error. Monitor if this happens and defer to default implementation
      _superPropGet(JQLEditorErrorStrategy, "reportFailedPredicate", this, 3)([recognizer, e]);
    }
  }, {
    key: "handleSyntaxError",
    value: function handleSyntaxError(recognizer, currentToken, exception) {
      var message;
      switch (currentToken.type) {
        /*
         * This is called when ANTLR finds a character that the grammar does not recognise. The grammar lexer uses
         * a DFA to decide if a character is in error or not. This can mean that legal characters come as an error
         * because they do not form a valid token. Because of this we have to do some extra checks here.
         */
        case _jqlParser.JQLLexer.ERRORCHAR:
        case _jqlParser.JQLLexer.INVALID_QUOTE_STRING:
        case _jqlParser.JQLLexer.INVALID_SQUOTE_STRING:
          {
            var currentText = currentToken.text;

            // These tokens are returned when an illegal character appears at the end of a quote string, but the token
            // includes the entire quoted text. We take the last character from our text as that's the offending token.
            if (currentToken.type === _jqlParser.JQLLexer.INVALID_QUOTE_STRING || currentToken.type === _jqlParser.JQLLexer.INVALID_SQUOTE_STRING) {
              var _currentText;
              currentText = (_currentText = currentText) === null || _currentText === void 0 ? void 0 : _currentText.slice(-1);
            }

            // This can happen (e.g. comment ~ \)
            if (isEscape(currentText)) {
              var nextToken = recognizer.inputStream.get(currentToken.tokenIndex + 1);
              if (nextToken.type === _jqlParser.JQLLexer.MATCHWS || nextToken.type === _jqlParser.JQLLexer.EOF) {
                message = this.intlRef.current.formatMessage(_messages.errorMessages.illegalEscapeBlank);
              } else {
                var _nextToken$text;
                // Show the escaped character sequence in the message
                var received = "".concat(currentText !== null && currentText !== void 0 ? currentText : '').concat((_nextToken$text = nextToken.text) !== null && _nextToken$text !== void 0 ? _nextToken$text : '');
                message = this.intlRef.current.formatMessage(_messages.errorMessages.illegalEscape, {
                  received: received
                });
              }
            } else {
              message = this.intlRef.current.formatMessage(_messages.errorMessages.illegalChar, {
                char: getPrintableChar(currentText !== null && currentText !== void 0 ? currentText : ''),
                escapedChar: getJavaCodeFromChar(currentText !== null && currentText !== void 0 ? currentText : '')
              });
            }
            break;
          }
        // Special tokens that get created every time there is an unfinished string (i.e. without matching closing quote)
        case _jqlParser.JQLLexer.UNCLOSED_QUOTE_STRING:
        case _jqlParser.JQLLexer.UNCLOSED_SQUOTE_STRING:
          {
            var _currentToken$text;
            var _received = (0, _jqlAst.normaliseJqlString)((_currentToken$text = currentToken.text) !== null && _currentToken$text !== void 0 ? _currentToken$text : '');
            if (_received === '') {
              message = this.intlRef.current.formatMessage(_messages.errorMessages.unfinishedStringBlank);
            } else {
              message = this.intlRef.current.formatMessage(_messages.errorMessages.unfinishedString, {
                received: _received
              });
            }
            break;
          }
        case _jqlParser.JQLLexer.RESERVED_WORD:
          {
            message = this.intlRef.current.formatMessage(_messages.errorMessages.reservedWord, {
              word: currentToken.text
            });
            break;
          }
        case _jqlParser.JQLLexer.ERROR_RESERVED:
          {
            var _currentToken$text2;
            message = this.intlRef.current.formatMessage(_messages.errorMessages.reservedChar, {
              char: currentToken.text,
              escapedChar: getJavaCodeFromChar((_currentToken$text2 = currentToken.text) !== null && _currentToken$text2 !== void 0 ? _currentToken$text2 : '')
            });
            break;
          }
        default:
          {
            var autocomplete = _jqlAutocomplete.JQLAutocomplete.fromParser(recognizer, _constants.ignoredTokens, _constants.preferredRules, new Set());
            var _autocomplete$getJQLS = autocomplete.getJQLSuggestionsForTokenIndex(currentToken.tokenIndex),
              tokens = _autocomplete$getJQLS.tokens,
              rules = _autocomplete$getJQLS.rules;
            if (rules.value || rules.list ||
            // Restrict function rules to only be shown if we are currently INSIDE a function rule. Otherwise this error
            // message would be shown for incomplete tokens following an operand, e.g. `status = open ord`.
            rules.function && recognizer.context.ruleIndex === _jqlParser.JQLParser.RULE_jqlFunction) {
              message = (0, _OperandRuleErrorHandler.handleOperandRuleError)(recognizer, currentToken, tokens.values, rules, this.intlRef.current, exception);
            } else if (tokens.values.includes('EMPTY')) {
              message = (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
            } else if (rules.operator) {
              message = (0, _OperatorRuleErrorHandler.handleOperatorRuleError)(currentToken, this.intlRef.current);
            } else if (rules.field) {
              message = (0, _FieldRuleErrorHandler.handleFieldRuleError)(currentToken, this.intlRef.current);
            } else if (rules.customField) {
              message = (0, _CustomFieldRuleErrorHandler.handleCustomFieldRuleError)(this.intlRef.current);
            }
            // Restrict field property rules to only be shown if we are currently INSIDE a field property. Otherwise this
            // error message would be shown for incomplete tokens following a field, e.g. `ORDER BY issuetype as`.
            else if (rules.fieldProperty && recognizer.context.ruleIndex === _jqlParser.JQLParser.RULE_jqlFieldProperty) {
              // Shows the correct message when a field property rule hasn't been completed, e.g. `issuetype[abc!`
              message = (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken,
              // We want to derive expectedTokens from the exception/parser state
              [], this.intlRef.current, exception);
            } else if (rules.fieldPropertyId) {
              message = (0, _FieldPropertyIdErrorHandler.handleFieldPropertyIdRuleError)(currentToken, this.intlRef.current);
            } else if (rules.functionArgument) {
              message = (0, _FunctionArgumentRuleErrorHandler.handleFunctionArgumentRuleError)(currentToken, this.intlRef.current);
            } else {
              message = (0, _ExpectedTokensErrorHandler.handleExpectedTokensError)(recognizer, currentToken, tokens.values, this.intlRef.current, exception);
            }
            break;
          }
      }
      recognizer.notifyErrorListeners(message, currentToken, undefined);
    }
  }]);
}(_antlr4ts.DefaultErrorStrategy);