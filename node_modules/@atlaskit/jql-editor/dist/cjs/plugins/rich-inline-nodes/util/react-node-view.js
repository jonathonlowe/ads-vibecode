"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactNodeView = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _Subject = require("rxjs/Subject");
var _uuid = require("uuid");
var _state = require("../../../state");
var _constants = require("../constants");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var ReactNodeView = exports.ReactNodeView = /*#__PURE__*/function () {
  function ReactNodeView(component, portalActions, _node) {
    var _this = this;
    (0, _classCallCheck2.default)(this, ReactNodeView);
    (0, _defineProperty2.default)(this, "componentSubject", new _Subject.Subject());
    (0, _defineProperty2.default)(this, "init", function (decorations) {
      var Component = _this.component;
      var PortallingComponent = function PortallingComponent() {
        var _useState = (0, _react.useState)(_objectSpread(_objectSpread({}, _this.getProps(_this.node)), {}, {
            selected: _this.isSelected(decorations),
            error: _this.hasError(decorations)
          })),
          _useState2 = (0, _slicedToArray2.default)(_useState, 2),
          state = _useState2[0],
          setState = _useState2[1];

        // ProseMirror keeps decorations on blur (as those are derived from editor state and focus isn't part of it),
        // but we don't want to show node views as selected when that happens. We could build a workaround for this in
        // richInlineNodesPlugin, but this hook will make selection behave more consistently with other focus-related features.
        var _useEditorViewHasFocu = (0, _state.useEditorViewHasFocus)(),
          _useEditorViewHasFocu2 = (0, _slicedToArray2.default)(_useEditorViewHasFocu, 1),
          hasFocus = _useEditorViewHasFocu2[0];
        (0, _react.useEffect)(function () {
          // Subscribe to the RxJS subject so concrete subclasses can emit events to re-render the node view component
          var subscription = _this.componentSubject.subscribe(function (props) {
            setState(props);
          });
          return function () {
            return subscription.unsubscribe();
          };
        }, []);
        (0, _react.useLayoutEffect)(function () {
          if (state.error) {
            _this.dom.dataset.tokenType = 'error';
          } else {
            delete _this.dom.dataset.tokenType;
          }
        }, [state]);
        return /*#__PURE__*/_react.default.createElement(Component, (0, _extends2.default)({}, state, {
          selected: state.selected && hasFocus
        }));
      };

      // Ok, this is a tricky one. As everything that requires collaboration between ProseMirror and React.
      //
      // If we run `onCreatePortal` synchronously, ProseMirror won't insert the node view container (`this.dom`)
      // immediately into the DOM (as init function hasn't returned yet). This can trigger race conditions in other
      // code paths where ProseMirror may try to get DOM position for this node view before it has been inserted
      // (e.g. calculating new autocomplete position after insertion, or setting selection after the node).
      //
      // With `queueMicrotask` we can schedule this operation to be run after ProseMirror is done with the element
      // insertion, but before control of the execution context is returned to the browser's event loop. This should
      // prevent all conflicts with other pieces of asynchronous code and still render the portal as soon as it is
      // practically possible, so we can avoid flicker in situations where node views are reconstructed by ProseMirror.
      // @see https://github.com/ProseMirror/prosemirror/issues/872
      queueMicrotask(function () {
        _this.portalActions.onCreatePortal(_this.portalKey, /*#__PURE__*/_react.default.createElement(PortallingComponent, null), _this.dom);
      });
      return _this;
    });
    (0, _defineProperty2.default)(this, "destroy", function () {
      _this.portalActions.onDestroyPortal(_this.portalKey);
    });
    (0, _defineProperty2.default)(this, "update", function (node, decorations) {
      // Update function may be called by ProseMirror with a node that has nothing to do with this node view ¯\_(ツ)_/¯
      // @see https://prosemirror.net/docs/ref/#view.NodeView.update
      if (node !== _this.node) {
        return false;
      }
      _this.componentSubject.next(_objectSpread(_objectSpread({}, _this.getProps(node)), {}, {
        selected: _this.isSelected(decorations),
        error: _this.hasError(decorations)
      }));
      return true;
    });
    (0, _defineProperty2.default)(this, "getProps", function (node) {
      return _objectSpread({}, node.attrs);
    });
    (0, _defineProperty2.default)(this, "isSelected", function (decorations) {
      return decorations.some(function (decoration) {
        return decoration.spec.type === _constants.SELECTED_NODE;
      });
    });
    (0, _defineProperty2.default)(this, "hasError", function (decorations) {
      return decorations.some(function (decoration) {
        return decoration.spec.type === _constants.ERROR_NODE;
      });
    });
    this.component = component;
    this.portalActions = portalActions;
    this.node = _node;
    // Generate unique portal identifier
    // If you read this comment in the future and TypeScript has added support for Symbols as object keys, please do
    // JQL Editor a favor and replace this library with the native JS functionality that TS was supposed to support.
    this.portalKey = (0, _uuid.v4)();
    // Creating span under the assumption that all node views will be inline elements in JQL Editor
    this.dom = document.createElement('span');
    this.dom.setAttribute('data-testid', 'jql-editor-node-view');
  }
  return (0, _createClass2.default)(ReactNodeView, null, [{
    key: "for",
    value: function _for(component, portalActions, node, decorations) {
      return new ReactNodeView(component, portalActions, node).init(decorations);
    }
  }]);
}();