"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _spinner = _interopRequireDefault(require("@atlaskit/spinner"));
var _accessibility = require("../../../../accessibility");
var _constants = require("../../../../common/constants");
var _state = require("../../../../state");
var _constants2 = require("../../constants");
var _messages = require("../../messages");
var _autocompleteOption = _interopRequireDefault(require("../autocomplete-option"));
var _styled = require("./styled");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var getPreviousOptionId = function getPreviousOptionId(options, selectedOptionId) {
  if (!selectedOptionId) {
    return options[options.length - 1].id;
  }
  var index = options.findIndex(function (option) {
    return option.id === selectedOptionId;
  });
  if (index === -1) {
    return options[options.length - 1].id;
  }
  if (index > 0) {
    return options[index - 1].id;
  }
  return undefined;
};
var getNextOptionId = function getNextOptionId(options, selectedOptionId) {
  if (!selectedOptionId) {
    return options[0].id;
  }
  var index = options.findIndex(function (option) {
    return option.id === selectedOptionId;
  });
  if (index === -1) {
    return options[0].id;
  }
  if (index < options.length - 1) {
    return options[index + 1].id;
  }
  return undefined;
};
var AutocompleteDropdown = function AutocompleteDropdown(_ref) {
  var options = _ref.options,
    loading = _ref.loading,
    keymap = _ref.keymap,
    onClick = _ref.onClick;
  var containerRef = (0, _react.useRef)(null);
  var scrollContainerRef = (0, _react.useRef)(null);
  var selectedItemRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    navigatingWithKeyboard = _useState2[0],
    setNavigatingWithKeyboard = _useState2[1];
  var _useIntl = (0, _state.useIntl)(),
    _useIntl2 = (0, _slicedToArray2.default)(_useIntl, 1),
    intl = _useIntl2[0];
  var _useStoreActions = (0, _state.useStoreActions)(),
    _useStoreActions2 = (0, _slicedToArray2.default)(_useStoreActions, 2),
    _useStoreActions2$ = _useStoreActions2[1],
    onEditorViewFocus = _useStoreActions2$.onEditorViewFocus,
    onEditorViewBlur = _useStoreActions2$.onEditorViewBlur;
  var _useAutocomplete = (0, _state.useAutocomplete)(),
    _useAutocomplete2 = (0, _slicedToArray2.default)(_useAutocomplete, 2),
    selectedOptionId = _useAutocomplete2[0].selectedOptionId,
    _useAutocomplete2$ = _useAutocomplete2[1],
    closeAutocomplete = _useAutocomplete2$.closeAutocomplete,
    setAutocompleteContainer = _useAutocomplete2$.setAutocompleteContainer,
    setSelectedAutocompleteOptionId = _useAutocomplete2$.setSelectedAutocompleteOptionId;
  var _useAutocompleteIsOpe = (0, _state.useAutocompleteIsOpen)(),
    _useAutocompleteIsOpe2 = (0, _slicedToArray2.default)(_useAutocompleteIsOpe, 1),
    isAutocompleteOpen = _useAutocompleteIsOpe2[0];
  var _useAutocompletePosit = (0, _state.useAutocompletePosition)(),
    _useAutocompletePosit2 = (0, _slicedToArray2.default)(_useAutocompletePosit, 1),
    _useAutocompletePosit3 = _useAutocompletePosit2[0],
    top = _useAutocompletePosit3.top,
    left = _useAutocompletePosit3.left;
  var _useRichInlineNodesEn = (0, _state.useRichInlineNodesEnabled)(),
    _useRichInlineNodesEn2 = (0, _slicedToArray2.default)(_useRichInlineNodesEn, 1),
    areRichInlineNodesEnabled = _useRichInlineNodesEn2[0];
  var _useScopedId = (0, _state.useScopedId)(_constants.JQL_EDITOR_AUTOCOMPLETE_ID),
    _useScopedId2 = (0, _slicedToArray2.default)(_useScopedId, 1),
    autocompleteId = _useScopedId2[0];
  var onContainerRef = (0, _react.useCallback)(function (container) {
    containerRef.current = container;
    setAutocompleteContainer(container);
  }, [containerRef, setAutocompleteContainer]);
  var onScrollContainerRef = (0, _react.useCallback)(function (container) {
    scrollContainerRef.current = container;
  }, [scrollContainerRef]);
  var handleClick = (0, _react.useCallback)(function (option, optionIndex, keyboard) {
    closeAutocomplete();
    onClick(option, {
      keyboard: keyboard,
      numberOfOptions: options.length,
      optionIndex: optionIndex,
      optionType: option.type,
      queryLength: option.matchedText.length,
      nodeType: areRichInlineNodesEnabled && option.valueType !== undefined ? option.valueType : 'text'
    });
  }, [options, onClick, closeAutocomplete, areRichInlineNodesEnabled]);
  var onMouseMove = (0, _react.useCallback)(function () {
    if (navigatingWithKeyboard) {
      setNavigatingWithKeyboard(false);
    }
  }, [navigatingWithKeyboard, setNavigatingWithKeyboard]);
  (0, _react.useEffect)(function () {
    keymap.bindKey(_constants2.ARROW_UP_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      var previousOptionId = getPreviousOptionId(options, selectedOptionId);
      setSelectedAutocompleteOptionId(previousOptionId);
      return true;
    });
    keymap.bindKey(_constants2.ARROW_DOWN_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      var nextOptionId = getNextOptionId(options, selectedOptionId);
      setSelectedAutocompleteOptionId(nextOptionId);
      return true;
    });
    keymap.bindMultipleKeys([_constants2.ENTER_KEY, _constants2.TAB_KEY], function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      var selectedOptionIndex = options.findIndex(function (option) {
        return option.id === selectedOptionId;
      });
      if (selectedOptionId && selectedOptionIndex !== -1) {
        if (options[selectedOptionIndex].isDeprecated) {
          return true;
        }
        handleClick(options[selectedOptionIndex], selectedOptionIndex, true);
        return true;
      }
      // Open with no option selected, so we let PM do its stuff (a.k.a. keep inserting new lines)
      return false;
    });
    keymap.bindKey(_constants2.ESCAPE_KEY, function () {
      if (!isAutocompleteOpen) {
        return false;
      }
      closeAutocomplete();
      return true;
    });
    keymap.bindMultipleKeys([_constants2.HOME_KEY, _constants2.CMD_ARROW_UP_KEY], function () {
      var _options$;
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      setSelectedAutocompleteOptionId((_options$ = options[0]) === null || _options$ === void 0 ? void 0 : _options$.id);
      return true;
    });
    keymap.bindMultipleKeys([_constants2.END_KEY, _constants2.CMD_ARROW_DOWN_KEY], function () {
      var _options;
      if (!isAutocompleteOpen) {
        return false;
      }
      !navigatingWithKeyboard && setNavigatingWithKeyboard(true);
      setSelectedAutocompleteOptionId((_options = options[options.length - 1]) === null || _options === void 0 ? void 0 : _options.id);
      return true;
    });

    // New bindings should also be registered in plugins/autocomplete/index.tsx

    return function () {
      keymap.unbindKey(_constants2.ARROW_UP_KEY);
      keymap.unbindKey(_constants2.ARROW_DOWN_KEY);
      keymap.unbindKey(_constants2.ENTER_KEY);
      keymap.unbindKey(_constants2.TAB_KEY);
      keymap.unbindKey(_constants2.ESCAPE_KEY);
      keymap.unbindKey(_constants2.HOME_KEY);
      keymap.unbindKey(_constants2.END_KEY);
      keymap.unbindKey(_constants2.CMD_ARROW_UP_KEY);
      keymap.unbindKey(_constants2.CMD_ARROW_DOWN_KEY);
    };
  }, [keymap, isAutocompleteOpen, closeAutocomplete, navigatingWithKeyboard, setNavigatingWithKeyboard, options, selectedOptionId, setSelectedAutocompleteOptionId, handleClick]);
  (0, _react.useEffect)(function () {
    // Reset to no selection when:
    // - autocomplete is closed
    // - we get new options and those don't include the currently selected option
    if (!isAutocompleteOpen || !options.some(function (option) {
      return option.id === selectedOptionId;
    })) {
      setSelectedAutocompleteOptionId(undefined);
    }
  }, [isAutocompleteOpen, options, selectedOptionId, setSelectedAutocompleteOptionId]);
  (0, _react.useLayoutEffect)(function () {
    requestAnimationFrame(function () {
      if (containerRef.current) {
        containerRef.current.style.top = "".concat(top, "px");
        containerRef.current.style.left = "".concat(left, "px");
      }
    });
  }, [top, left]);
  (0, _react.useLayoutEffect)(function () {
    if (navigatingWithKeyboard) {
      var _selectedItemRef$curr;
      (_selectedItemRef$curr = selectedItemRef.current) === null || _selectedItemRef$curr === void 0 || _selectedItemRef$curr.scrollIntoView({
        block: 'nearest'
      });
    }
  }, [navigatingWithKeyboard, selectedOptionId, selectedItemRef]);
  (0, _react.useLayoutEffect)(function () {
    var _selectedItemRef$curr2;
    (_selectedItemRef$curr2 = selectedItemRef.current) === null || _selectedItemRef$curr2 === void 0 || _selectedItemRef$curr2.scrollIntoView({
      block: 'nearest'
    });
  }, [options, selectedItemRef]);
  (0, _react.useLayoutEffect)(function () {
    if (isAutocompleteOpen && !selectedOptionId && scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = 0;
    }
  }, [isAutocompleteOpen, selectedOptionId]);
  var announcedMessage = (0, _react.useMemo)(function () {
    if (!isAutocompleteOpen || !options.length) {
      return '';
    }
    return intl.formatMessage(_messages.messages.optionsFound);
  }, [isAutocompleteOpen, intl, options]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_styled.AutocompleteContainer, {
    "data-testid": "jql-editor-autocomplete",
    tabIndex: -1,
    ref: onContainerRef,
    isOpen: isAutocompleteOpen,
    onBlur: onEditorViewBlur,
    onFocus: onEditorViewFocus
  }, /*#__PURE__*/_react.default.createElement(_styled.AutocompleteOptionsContainer, {
    ref: onScrollContainerRef,
    onMouseMove: onMouseMove
  }, /*#__PURE__*/_react.default.createElement(_styled.OptionList, {
    role: "listbox",
    id: autocompleteId
  }, options.map(function (option, index) {
    var isSelected = option.id === selectedOptionId;
    return /*#__PURE__*/_react.default.createElement(_autocompleteOption.default, (0, _extends2.default)({
      key: option.value,
      isSelected: isSelected
    }, isSelected && {
      ref: selectedItemRef
    }, {
      option: option,
      onClick: function onClick() {
        return handleClick(option, index, false);
      },
      onMouseMove: function onMouseMove() {
        var _options$index;
        if (((_options$index = options[index]) === null || _options$index === void 0 ? void 0 : _options$index.id) !== selectedOptionId) {
          var _options$index2;
          setSelectedAutocompleteOptionId((_options$index2 = options[index]) === null || _options$index2 === void 0 ? void 0 : _options$index2.id);
        }
      }
    }));
  }))), loading && /*#__PURE__*/_react.default.createElement(_styled.AutocompleteLoadingFooter, {
    "data-testid": "jql-editor-autocomplete-loading",
    hasOptions: !!options.length
  }, /*#__PURE__*/_react.default.createElement(_spinner.default, {
    size: "small"
  }))), /*#__PURE__*/_react.default.createElement(_accessibility.ScreenReaderText, {
    role: "status",
    "aria-live": "polite"
  }, announcedMessage));
};
var _default = exports.default = AutocompleteDropdown;