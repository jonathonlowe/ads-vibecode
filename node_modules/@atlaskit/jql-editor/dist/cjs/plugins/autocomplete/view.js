"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _jqlAst = require("@atlaskit/jql-ast");
var _getDocumentPosition = _interopRequireDefault(require("../common/get-document-position"));
var _reactPluginView = _interopRequireDefault(require("../common/react-plugin-view"));
var _autocomplete = _interopRequireDefault(require("./components/autocomplete"));
var _constants = require("./constants");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * Returns whether an opening parenthesis should be automatically inserted for this option (e.g. after a list operator)
 */
var shouldInsertOpeningParenthesis = function shouldInsertOpeningParenthesis(_ref) {
  var type = _ref.type,
    context = _ref.context,
    isListFunction = _ref.isListFunction;
  if (type === 'value' || type === 'function' || type === 'keyword') {
    var operator = context === null || context === void 0 ? void 0 : context.operator;
    if (operator && (0, _jqlAst.isListOperator)(operator) && !(context !== null && context !== void 0 && context.isList) && !isListFunction) {
      return true;
    }
  }
  return false;
};
var AutocompletePluginView = exports.default = /*#__PURE__*/function (_ReactPluginView) {
  function AutocompletePluginView(view, keymap, portalActions, enableRichInlineNodes) {
    var _this;
    (0, _classCallCheck2.default)(this, AutocompletePluginView);
    _this = _callSuper(this, AutocompletePluginView, [portalActions, _constants.AUTOCOMPLETE_PLUGIN_NAME, 'main']);
    (0, _defineProperty2.default)(_this, "getComponent", function () {
      return _autocomplete.default;
    });
    (0, _defineProperty2.default)(_this, "getInitialComponentProps", function () {
      return {
        keymap: _this.keymap,
        onClick: _this.onReplaceSuggestion
      };
    });
    (0, _defineProperty2.default)(_this, "onReplaceSuggestion", function (option) {
      var _option$replacePositi = (0, _slicedToArray2.default)(option.replacePosition, 2),
        from = _option$replacePositi[0],
        to = _option$replacePositi[1];
      var transaction = _this.view.state.tr;
      transaction.setMeta(_constants.JQLAutocompletePluginKey, true);

      // Request query hydration if we are inserting a user node
      if (_this.enableRichInlineNodes && option.type === 'value' && option.valueType === 'user') {
        transaction.setMeta('hydrate', true);
      }
      var documentFrom = (0, _getDocumentPosition.default)(transaction.doc, from);
      var documentTo = (0, _getDocumentPosition.default)(transaction.doc, to);

      // Change current selection to the mapped replace position
      transaction.setSelection(_state.TextSelection.create(transaction.doc, documentTo, documentFrom));

      // Replace selected range with the selected autocomplete option
      transaction.replaceSelection(_this.getSliceForSuggestion(option));
      _this.view.focus();
      _this.view.dispatch(transaction);
    });
    (0, _defineProperty2.default)(_this, "getSliceForSuggestion", function (option) {
      var value = option.value,
        name = option.name,
        nameOnRichInlineNode = option.nameOnRichInlineNode,
        valueType = option.valueType,
        context = option.context;
      var nodes = [];
      if (shouldInsertOpeningParenthesis(option)) {
        nodes.push(_this.view.state.schema.text('('));
      }
      var textContent = _this.view.state.schema.text(value);
      if (!_this.enableRichInlineNodes) {
        nodes.push(textContent);
      } else {
        switch (valueType) {
          case 'user':
            {
              var attributes = {
                type: 'user',
                id: value,
                name: nameOnRichInlineNode !== null && nameOnRichInlineNode !== void 0 ? nameOnRichInlineNode : name,
                fieldName: context === null || context === void 0 ? void 0 : context.field
              };
              nodes.push(_this.view.state.schema.nodes.user.create(attributes, textContent));
              break;
            }
          default:
            {
              nodes.push(textContent);
              break;
            }
        }
      }
      return new _model.Slice(_model.Fragment.from(nodes), 0, 0);
    });
    _this.view = view;
    _this.keymap = keymap;
    _this.enableRichInlineNodes = enableRichInlineNodes;
    return _this;
  }
  (0, _inherits2.default)(AutocompletePluginView, _ReactPluginView);
  return (0, _createClass2.default)(AutocompletePluginView, [{
    key: "isSameState",
    value: function isSameState(state, prevState) {
      return prevState.doc.eq(state.doc) && prevState.selection.eq(state.selection);
    }
  }]);
}(_reactPluginView.default);