"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _jqlAst = require("@atlaskit/jql-ast");
var _getDocumentPosition = _interopRequireDefault(require("../common/get-document-position"));
var _jqlAst2 = require("../jql-ast");
var _visitor = require("./visitor");
var getHighlights = function getHighlights(state) {
  var ast = (0, _jqlAst2.getJastFromState)(state);
  // Get highlights for AST nodes
  var visitor = new _visitor.SyntaxHighlightingVisitor(state);
  var highlights = ast.query ? visitor.visit(ast.query) : [];
  // Create a highlight for the first syntax error encountered
  var _ast$errors = (0, _slicedToArray2.default)(ast.errors, 1),
    error = _ast$errors[0];
  if (error instanceof _jqlAst.JQLSyntaxError) {
    var documentFrom = (0, _getDocumentPosition.default)(state.doc, error.start);
    var documentTo = (0, _getDocumentPosition.default)(state.doc, error.stop);
    highlights.push({
      tokenType: 'error',
      documentFrom: documentFrom,
      documentTo: documentTo
    });
  }
  return highlights;
};
var JQLSyntaxHighlightingPluginKey = new _state.PluginKey('jql-syntax-highlighting-plugin');
var jqlSyntaxHighlightingPlugin = function jqlSyntaxHighlightingPlugin() {
  return new _state.Plugin({
    key: JQLSyntaxHighlightingPluginKey,
    appendTransaction: function appendTransaction(_, oldState, newState) {
      // Avoid unnecessary transactions if document hasn't changed in the current transaction
      if (oldState.doc === newState.doc) {
        return;
      }
      var transaction = newState.tr;

      // Remove token marks from all inline nodes so they can be recomputed
      transaction.removeMark(0, newState.doc.content.size);

      // Create marks for computed highlights
      var highlights = getHighlights(newState);
      highlights.forEach(function (_ref) {
        var tokenType = _ref.tokenType,
          documentFrom = _ref.documentFrom,
          documentTo = _ref.documentTo;
        // Apply mark to all text nodes within the highlighted range
        newState.doc.nodesBetween(documentFrom, documentTo, function (node, pos) {
          if (node.isText) {
            var from = Math.max(pos, documentFrom);
            var to = Math.min(pos + node.nodeSize, documentTo);
            var mark = newState.schema.marks.token.create({
              tokenType: tokenType
            });
            transaction.addMark(from, to, mark);
          }
        });
      });
      return transaction;
    }
  });
};
var _default = exports.default = jqlSyntaxHighlightingPlugin;