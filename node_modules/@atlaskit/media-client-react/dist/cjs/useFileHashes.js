"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFileHashes = useFileHashes;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = require("react");
var _mediaClient = require("@atlaskit/media-client");
var _MediaClientProvider = require("./MediaClientProvider");
var _useMediaStore = require("./useMediaStore");
var _usePrevious = require("./utils/usePrevious");
var areFilesPotentiallyDuplicated = function areFilesPotentiallyDuplicated(file1, file2) {
  return file1.status === file2.status && file1.name === file2.name && file1.size === file2.size && file1.mimeType === file2.mimeType && file1.id !== file2.id;
};
function useFileHashes(ids) {
  var nonErrorFiles = (0, _useMediaStore.useMediaStore)(function (state) {
    return Object.values(state.files).filter(_mediaClient.isNonErrorFinalFileState);
  });
  var mediaClient = (0, _MediaClientProvider.useMediaClient)();
  var collections = (0, _react.useMemo)(function () {
    return Object.fromEntries(ids.map(function (_ref) {
      var id = _ref.id,
        collectionName = _ref.collectionName;
      return [id, collectionName];
    }));
  }, [ids]);
  var files = (0, _react.useMemo)(function () {
    return nonErrorFiles.filter(function (file) {
      return ids.some(function (_ref2) {
        var id = _ref2.id;
        return file.id === id;
      });
    });
  }, [nonErrorFiles, ids]);
  var prevFiles = (0, _usePrevious.usePrevious)(files);
  (0, _react.useEffect)(function () {
    var prev = prevFiles !== null && prevFiles !== void 0 ? prevFiles : [];

    // Get the files that have been added or whose status has changed since last time.
    var addedOrChangedFiles = files.filter(function (file) {
      return file && prev.every(function (prevFile) {
        return prevFile.id !== file.id || prevFile.status !== file.status;
      });
    });

    // Get the files from the list that are duplicates of the added / changed files
    var potentialDuplicates = files.filter(function (file) {
      return addedOrChangedFiles.some(function (addedFile) {
        return areFilesPotentiallyDuplicated(file, addedFile);
      });
    });
    if (potentialDuplicates.length) {
      // if any duplicates are found then fetch their hashes along with the added files
      [].concat((0, _toConsumableArray2.default)(addedOrChangedFiles), (0, _toConsumableArray2.default)(potentialDuplicates)).forEach(function (file) {
        var collectionName = collections[file.id];
        mediaClient.file.getFileState(file.id, {
          collectionName: collectionName,
          includeHashForDuplicateFiles: true,
          forceRefresh: true
        });
      });
    }
  }, [files, prevFiles, mediaClient, collections]);
  var hashMap = (0, _react.useMemo)(function () {
    return Object.fromEntries(files.map(function (file) {
      return [file.id, file.hash];
    }));
  }, [files]);
  return hashMap;
}