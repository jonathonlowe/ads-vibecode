import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { useEffect, useMemo } from 'react';
import { isNonErrorFinalFileState } from '@atlaskit/media-client';
import { useMediaClient } from './MediaClientProvider';
import { useMediaStore } from './useMediaStore';
import { usePrevious } from './utils/usePrevious';
var areFilesPotentiallyDuplicated = function areFilesPotentiallyDuplicated(file1, file2) {
  return file1.status === file2.status && file1.name === file2.name && file1.size === file2.size && file1.mimeType === file2.mimeType && file1.id !== file2.id;
};
export function useFileHashes(ids) {
  var nonErrorFiles = useMediaStore(function (state) {
    return Object.values(state.files).filter(isNonErrorFinalFileState);
  });
  var mediaClient = useMediaClient();
  var collections = useMemo(function () {
    return Object.fromEntries(ids.map(function (_ref) {
      var id = _ref.id,
        collectionName = _ref.collectionName;
      return [id, collectionName];
    }));
  }, [ids]);
  var files = useMemo(function () {
    return nonErrorFiles.filter(function (file) {
      return ids.some(function (_ref2) {
        var id = _ref2.id;
        return file.id === id;
      });
    });
  }, [nonErrorFiles, ids]);
  var prevFiles = usePrevious(files);
  useEffect(function () {
    var prev = prevFiles !== null && prevFiles !== void 0 ? prevFiles : [];

    // Get the files that have been added or whose status has changed since last time.
    var addedOrChangedFiles = files.filter(function (file) {
      return file && prev.every(function (prevFile) {
        return prevFile.id !== file.id || prevFile.status !== file.status;
      });
    });

    // Get the files from the list that are duplicates of the added / changed files
    var potentialDuplicates = files.filter(function (file) {
      return addedOrChangedFiles.some(function (addedFile) {
        return areFilesPotentiallyDuplicated(file, addedFile);
      });
    });
    if (potentialDuplicates.length) {
      // if any duplicates are found then fetch their hashes along with the added files
      [].concat(_toConsumableArray(addedOrChangedFiles), _toConsumableArray(potentialDuplicates)).forEach(function (file) {
        var collectionName = collections[file.id];
        mediaClient.file.getFileState(file.id, {
          collectionName: collectionName,
          includeHashForDuplicateFiles: true,
          forceRefresh: true
        });
      });
    }
  }, [files, prevFiles, mediaClient, collections]);
  var hashMap = useMemo(function () {
    return Object.fromEntries(files.map(function (file) {
      return [file.id, file.hash];
    }));
  }, [files]);
  return hashMap;
}