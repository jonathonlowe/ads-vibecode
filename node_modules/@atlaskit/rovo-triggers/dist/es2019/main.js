import { useCallback, useEffect, useLayoutEffect, useRef } from 'react';
const ignoredTriggerLatestEvents = new Set(['editor-context-payload', 'agent-changed']);
const createPubSub = () => {
  let subscribedEvents = {};
  let publishQueue = {};
  let wildcardEvents = [];
  const subscribe = ({
    topic,
    triggerLatest
  }, callback) => {
    var _subscribedEvents$top;
    const events = (_subscribedEvents$top = subscribedEvents[topic]) !== null && _subscribedEvents$top !== void 0 ? _subscribedEvents$top : [];
    const subId = events.length.toString();
    const subExists = events.some(({
      id
    }) => id === subId);

    // Push to Topic stack if not already there
    if (!subExists) {
      subscribedEvents = {
        ...subscribedEvents,
        [topic]: [...events, {
          callback,
          id: subId
        }]
      };
      // If this Topic already has a published event and `triggerLatest` is true, trigger the callback then clear the publishQueue for that Topic
      if (triggerLatest && !!publishQueue[topic]) {
        const payload = publishQueue[topic];
        callback(payload);
        delete publishQueue[topic];
      }
    }
    return () => {
      // Remove from Topic stack
      subscribedEvents = {
        ...subscribedEvents,
        [topic]: (subscribedEvents[topic] || []).filter(({
          id
        }) => id !== subId)
      };
    };
  };
  const subscribeAll = callback => {
    const subId = wildcardEvents.length.toString();
    wildcardEvents = [...wildcardEvents, {
      callback,
      id: subId
    }];
    return () => {
      wildcardEvents = wildcardEvents.filter(({
        id
      }) => id !== subId);
    };
  };
  const publish = (topic, payload) => {
    /**
     * Log that this Topic received a published event, regardless of whether it has subscribers or not.
     * This ensures new subscribers can trigger their callback if `triggerLatest` is true, and the event hasn't already been triggered.
     */
    // This `ignoredTriggerLatestEvents` is a quick fix to prevent triggering the latest event for certain events
    if (!ignoredTriggerLatestEvents.has(payload.type)) {
      publishQueue[topic] = payload;
    }

    // Notify `subscribeAll` subscribers as they are Topic agnostic
    wildcardEvents.forEach(({
      callback
    }) => callback(payload));
    const topicSubs = subscribedEvents[topic] || [];

    // If there are no subscribers for this Topic, nothing to do.
    if (!topicSubs.length) {
      return;
    }

    // Notify all Topic subscribers of this event
    topicSubs.forEach(({
      callback
    }) => callback(payload));
  };
  const flushQueue = () => {
    publishQueue = {};
  };
  return {
    subscribe,
    subscribeAll,
    publish,
    flushQueue
  };
};
const pubSub = createPubSub();
const usePubSub = () => {
  return pubSub;
};
export const useSubscribe = ({
  topic,
  triggerLatest
}, callback) => {
  const {
    subscribe
  } = usePubSub();
  const callbackRef = useRef(callback);
  callbackRef.current = callback;
  useEffect(() => {
    const unsubscribe = subscribe({
      topic,
      triggerLatest
    }, (...args) => callbackRef.current(...args));
    return unsubscribe;
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [topic]);
};
export const useSubscribeAll = callback => {
  const {
    subscribeAll
  } = usePubSub();
  const callbackRef = useRef(callback);
  callbackRef.current = callback;
  useEffect(() => {
    const unsubscribe = subscribeAll((...args) => callbackRef.current(...args));
    return unsubscribe;
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
};
const useFlushOnUnmount = (active = false) => {
  const {
    flushQueue
  } = usePubSub();
  useLayoutEffect(() => {
    return () => {
      if (active) {
        flushQueue();
      }
    };
  }, [active, flushQueue]);
};
export const usePublish = topic => {
  const {
    publish
  } = usePubSub();
  const publishFn = useCallback(payload => publish(topic, payload), [publish, topic]);
  return publishFn;
};
export const Subscriber = ({
  topic,
  triggerLatest,
  onEvent,
  flushQueueOnUnmount
}) => {
  useSubscribe({
    topic,
    triggerLatest
  }, onEvent);
  useFlushOnUnmount(flushQueueOnUnmount);
  return null;
};