import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useCallback, useRef, useState } from 'react';
import { useDatasourceAnalyticsEvents } from '../analytics';
import { validateAql } from '../services/cmdbService';
export var SEARCH_DEBOUNCE = 350;
export var useValidateAqlText = function useValidateAqlText(workspaceId, initialValue) {
  var timeout = useRef();
  var lastValue = useRef('');
  var lastResult = useRef(Promise.resolve(undefined));
  var _useState = useState(initialValue.trim() === '' ? {
      type: 'idle'
    } : {
      type: 'loading'
    }),
    _useState2 = _slicedToArray(_useState, 2),
    lastValidationResult = _useState2[0],
    setLastValidationResult = _useState2[1];
  var _useDatasourceAnalyti = useDatasourceAnalyticsEvents(),
    fireEvent = _useDatasourceAnalyti.fireEvent;

  // We return undefined when valid and 'error' when invalid
  var validateAqlText = useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(aql) {
      var validateAqlResponse, _validateAqlResponse$, _validateAqlResponse$2;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(aql !== null && aql !== void 0 && aql.trim())) {
              _context.next = 18;
              break;
            }
            _context.prev = 1;
            _context.next = 4;
            return validateAql(workspaceId, {
              qlQuery: aql
            }, fireEvent);
          case 4:
            validateAqlResponse = _context.sent;
            if (!validateAqlResponse.isValid) {
              _context.next = 10;
              break;
            }
            setLastValidationResult({
              type: 'valid',
              validatedAql: aql
            });
            return _context.abrupt("return", undefined);
          case 10:
            setLastValidationResult({
              type: 'invalid',
              error: (_validateAqlResponse$ = (_validateAqlResponse$2 = validateAqlResponse.errors) === null || _validateAqlResponse$2 === void 0 ? void 0 : _validateAqlResponse$2.iql) !== null && _validateAqlResponse$ !== void 0 ? _validateAqlResponse$ : ''
            });
            return _context.abrupt("return", 'error');
          case 12:
            _context.next = 18;
            break;
          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](1);
            setLastValidationResult({
              type: 'invalid',
              error: ''
            });
            return _context.abrupt("return", 'error');
          case 18:
            setLastValidationResult({
              type: 'idle'
            });
            return _context.abrupt("return", undefined);
          case 20:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 14]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [workspaceId, fireEvent]);

  /* Debounce async validation for input, validation is also called on every field change
   in a form so we need to also memoize. The async validate function is expected to either:
   Immediately return a promise (which is then collected into an array, every single time validation is run),
   or immediately return either undefined or an error message */
  var debouncedValidation = function debouncedValidation(value) {
    return new Promise(function (resolve) {
      if (timeout.current) {
        timeout.current();
      }
      if (value !== lastValue.current) {
        setLastValidationResult({
          type: 'loading'
        });
        var timerId = setTimeout(function () {
          lastValue.current = value;
          lastResult.current = validateAqlText(value);
          resolve(lastResult.current);
        }, SEARCH_DEBOUNCE);
        timeout.current = function () {
          clearTimeout(timerId);
          resolve('debouncing');
        };
      } else {
        resolve(lastResult.current);
      }
    });
  };
  return {
    debouncedValidation: debouncedValidation,
    validateAqlText: validateAqlText,
    lastValidationResult: lastValidationResult
  };
};