import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useCallback, useEffect, useRef, useState } from 'react';
import isEqual from 'lodash/isEqual';
import { isFedRamp } from '@atlaskit/atlassian-context';
import { DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE, useDatasourceClientExtension } from '@atlaskit/link-client-extension';
import { useDatasourceAnalyticsEvents } from '../analytics';
import { useDatasourceActions } from '../state';
import { useDiscoverActions } from '../state/actions';
import useErrorLogger from './useErrorLogger';
export var useDatasourceTableState = function useDatasourceTableState(_ref) {
  var datasourceId = _ref.datasourceId,
    parameters = _ref.parameters,
    _ref$fieldKeys = _ref.fieldKeys,
    fieldKeys = _ref$fieldKeys === void 0 ? [] : _ref$fieldKeys;
  var _useDatasourceAnalyti = useDatasourceAnalyticsEvents(),
    fireEvent = _useDatasourceAnalyti.fireEvent;
  var _useErrorLogger = useErrorLogger({
      datasourceId: datasourceId
    }),
    captureError = _useErrorLogger.captureError;
  var _useDatasourceActions = useDatasourceActions(),
    onAddItems = _useDatasourceActions.onAddItems;
  var _useDiscoverActions = useDiscoverActions({
      captureError: captureError,
      fireEvent: fireEvent
    }),
    discoverActions = _useDiscoverActions.discoverActions;
  var idFieldCount = 1;
  var keyFieldCount = 1;
  var _useState = useState([]),
    _useState2 = _slicedToArray(_useState, 1),
    initialEmptyArray = _useState2[0];
  var _useState3 = useState([]),
    _useState4 = _slicedToArray(_useState3, 2),
    defaultVisibleColumnKeys = _useState4[0],
    setDefaultVisibleColumnKeys = _useState4[1];
  var _useState5 = useState([]),
    _useState6 = _slicedToArray(_useState5, 2),
    lastRequestedFieldKeys = _useState6[0],
    setLastRequestedFieldKeys = _useState6[1];
  var _useState7 = useState({
      properties: []
    }),
    _useState8 = _slicedToArray(_useState7, 2),
    fullSchema = _useState8[0],
    setFullSchema = _useState8[1];
  var _useState9 = useState('empty'),
    _useState10 = _slicedToArray(_useState9, 2),
    status = _useState10[0],
    setStatus = _useState10[1];
  var _useState11 = useState([]),
    _useState12 = _slicedToArray(_useState11, 2),
    authDetails = _useState12[0],
    setAuthDetails = _useState12[1];
  var _useState13 = useState(initialEmptyArray),
    _useState14 = _slicedToArray(_useState13, 2),
    responseItems = _useState14[0],
    setResponseItems = _useState14[1];
  var _useState15 = useState(initialEmptyArray),
    _useState16 = _slicedToArray(_useState15, 2),
    responseItemIds = _useState16[0],
    setResponseItemIds = _useState16[1];
  var _useState17 = useState(true),
    _useState18 = _slicedToArray(_useState17, 2),
    hasNextPage = _useState18[0],
    setHasNextPage = _useState18[1];
  var _useState19 = useState(undefined),
    _useState20 = _slicedToArray(_useState19, 2),
    nextCursor = _useState20[0],
    setNextCursor = _useState20[1];
  var _useState21 = useState([]),
    _useState22 = _slicedToArray(_useState21, 2),
    columns = _useState22[0],
    setColumns = _useState22[1];
  var _useState23 = useState(undefined),
    _useState24 = _slicedToArray(_useState23, 2),
    totalCount = _useState24[0],
    setTotalCount = _useState24[1];
  var _useState25 = useState(false),
    _useState26 = _slicedToArray(_useState25, 2),
    shouldForceRequest = _useState26[0],
    setShouldForceRequest = _useState26[1];
  var _useState27 = useState([]),
    _useState28 = _slicedToArray(_useState27, 2),
    destinationObjectTypes = _useState28[0],
    setDestinationObjectTypes = _useState28[1];
  var _useState29 = useState(),
    _useState30 = _slicedToArray(_useState29, 2),
    extensionKey = _useState30[0],
    setExtensionKey = _useState30[1];
  var _useState31 = useState(undefined),
    _useState32 = _slicedToArray(_useState31, 2),
    providerName = _useState32[0],
    setProviderName = _useState32[1];
  var abortController = useRef(new AbortController());
  var _useDatasourceClientE = useDatasourceClientExtension(),
    getDatasourceData = _useDatasourceClientE.getDatasourceData,
    getDatasourceDetails = _useDatasourceClientE.getDatasourceDetails;
  var loadDatasourceDetails = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _yield$getDatasourceD, _yield$getDatasourceD2, access, auth, schema, isColumnNotPresentInCurrentColumnsList, allColumns, newColumns;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (parameters) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return");
        case 2:
          _context.prev = 2;
          _context.next = 5;
          return getDatasourceDetails(datasourceId, {
            parameters: parameters
          });
        case 5:
          _yield$getDatasourceD = _context.sent;
          _yield$getDatasourceD2 = _yield$getDatasourceD.meta;
          access = _yield$getDatasourceD2.access;
          auth = _yield$getDatasourceD2.auth;
          schema = _yield$getDatasourceD.data.schema;
          if (!(access === 'unauthorized' || access === 'forbidden')) {
            _context.next = 14;
            break;
          }
          setStatus(access);
          setAuthDetails(auth || initialEmptyArray);
          return _context.abrupt("return");
        case 14:
          isColumnNotPresentInCurrentColumnsList = function isColumnNotPresentInCurrentColumnsList(col) {
            return !columns.find(function (column) {
              return column.key === col.key;
            });
          };
          allColumns = schema.properties;
          newColumns = allColumns.filter(isColumnNotPresentInCurrentColumnsList);
          newColumns.length > 0 && setColumns([].concat(_toConsumableArray(columns), _toConsumableArray(newColumns)));
          _context.next = 30;
          break;
        case 20:
          _context.prev = 20;
          _context.t0 = _context["catch"](2);
          captureError('loadDatasourceDetails', _context.t0);
          if (!(_context.t0 instanceof Response && _context.t0.status === 401)) {
            _context.next = 26;
            break;
          }
          setStatus('unauthorized');
          return _context.abrupt("return");
        case 26:
          if (!(_context.t0 instanceof Response && _context.t0.status === 403)) {
            _context.next = 29;
            break;
          }
          setStatus('forbidden');
          return _context.abrupt("return");
        case 29:
          setStatus('rejected');
        case 30:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[2, 20]]);
  })), [captureError, columns, datasourceId, getDatasourceDetails, parameters, initialEmptyArray]);
  var applySchemaProperties = useCallback(function (schema, fieldKeys) {
    var properties = schema.properties,
      _schema$defaultProper = schema.defaultProperties,
      defaultProperties = _schema$defaultProper === void 0 ? [] : _schema$defaultProper;
    var propertiesToBeUsed = properties;
    var propertyKeysToBeUsed = Array.isArray(fieldKeys) && fieldKeys.length > 0 ? fieldKeys : defaultProperties;
    if (fieldKeys.length > 0 || defaultProperties.length > 0) {
      propertiesToBeUsed = properties.filter(function (property) {
        return propertyKeysToBeUsed.includes(property.key);
      });
    }

    /*Jira adds identifier fields like id and key to all data responses
       Since defaultProperties already send back the keyField, we are accounting only
       for the idField when we are using defaultProperties
       */
    if (properties.length > fieldKeys.length + idFieldCount + keyFieldCount && properties.length > defaultProperties.length + idFieldCount) {
      setFullSchema(schema);
    }
    if (!isEqual(columns, propertiesToBeUsed)) {
      setColumns(propertiesToBeUsed);
    }
    var newProperties = propertiesToBeUsed.map(function (prop) {
      return prop.key;
    });

    // when loading for the first time, we will need to set default visible props as /data does not give you that info
    // also, since we dont pass any fields, we will need to set this info as lastRequestedFieldKeys
    if (!isEqual(defaultVisibleColumnKeys, newProperties)) {
      setDefaultVisibleColumnKeys(newProperties);
    }
    if (!isEqual(lastRequestedFieldKeys, newProperties)) {
      setLastRequestedFieldKeys(newProperties);
    }
  }, [columns, defaultVisibleColumnKeys, lastRequestedFieldKeys]);
  var onNextPage = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var requestInfo,
      currentAbortController,
      _requestInfo$isSchema,
      isSchemaFromData,
      shouldRequestFirstPage,
      _requestInfo$shouldFo,
      shouldForceRequest,
      isFullSchemaLoaded,
      datasourceDataRequest,
      _currentAbortControll,
      _yield$getDatasourceD3,
      _yield$getDatasourceD4,
      access,
      _destinationObjectTypes,
      product,
      _extensionKey,
      auth,
      _providerName,
      objectTypesEntity,
      _yield$getDatasourceD5,
      items,
      nextPageCursor,
      _totalCount,
      schema,
      integrationKey,
      entityType,
      newIds,
      aris,
      isUserLoadingNextPage,
      currentLoadedItemCount,
      newlyLoadedItemCount,
      _args2 = arguments;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          requestInfo = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
          /**
           * Abort whichever request was made before this one.
           */
          abortController.current.abort();
          /**
           * Setup new abort controller for this request.
           */
          abortController.current = new AbortController();
          currentAbortController = abortController.current;
          if (parameters) {
            _context2.next = 6;
            break;
          }
          return _context2.abrupt("return");
        case 6:
          _requestInfo$isSchema = requestInfo.isSchemaFromData, isSchemaFromData = _requestInfo$isSchema === void 0 ? true : _requestInfo$isSchema, shouldRequestFirstPage = requestInfo.shouldRequestFirstPage, _requestInfo$shouldFo = requestInfo.shouldForceRequest, shouldForceRequest = _requestInfo$shouldFo === void 0 ? false : _requestInfo$shouldFo;
          isFullSchemaLoaded = fullSchema.properties.length > 0;
          datasourceDataRequest = {
            parameters: parameters,
            pageSize: DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE,
            pageCursor: shouldRequestFirstPage ? undefined : nextCursor,
            fields: fieldKeys,
            includeSchema: isFullSchemaLoaded ? false : isSchemaFromData
          };
          setStatus('loading');
          _context2.prev = 10;
          _context2.next = 13;
          return getDatasourceData(datasourceId, datasourceDataRequest, shouldForceRequest);
        case 13:
          _yield$getDatasourceD3 = _context2.sent;
          _yield$getDatasourceD4 = _yield$getDatasourceD3.meta;
          access = _yield$getDatasourceD4.access;
          _destinationObjectTypes = _yield$getDatasourceD4.destinationObjectTypes;
          product = _yield$getDatasourceD4.product;
          _extensionKey = _yield$getDatasourceD4.extensionKey;
          auth = _yield$getDatasourceD4.auth;
          _providerName = _yield$getDatasourceD4.providerName;
          objectTypesEntity = _yield$getDatasourceD4.objectTypesEntity;
          _yield$getDatasourceD5 = _yield$getDatasourceD3.data;
          items = _yield$getDatasourceD5.items;
          nextPageCursor = _yield$getDatasourceD5.nextPageCursor;
          _totalCount = _yield$getDatasourceD5.totalCount;
          schema = _yield$getDatasourceD5.schema;
          if (!((_currentAbortControll = currentAbortController) !== null && _currentAbortControll !== void 0 && _currentAbortControll.signal.aborted)) {
            _context2.next = 29;
            break;
          }
          throw new Error('Aborted');
        case 29:
          setExtensionKey(_extensionKey);
          setProviderName(_providerName);
          if (!(access === 'unauthorized' || access === 'forbidden')) {
            _context2.next = 35;
            break;
          }
          setStatus(access);
          setAuthDetails(auth || initialEmptyArray);
          return _context2.abrupt("return");
        case 35:
          setDestinationObjectTypes(_destinationObjectTypes);
          setTotalCount(_totalCount);
          setNextCursor(nextPageCursor);
          setResponseItems(function (currentResponseItems) {
            if (shouldRequestFirstPage) {
              return items;
            }
            return [].concat(_toConsumableArray(currentResponseItems), _toConsumableArray(items));
          });

          /**
           * Product is typed as any.
           */
          integrationKey = product;
          /**
           * When `entityType` is undefined, we should not discover actions it prevents unnecessary requests to Actions service
           */
          entityType = objectTypesEntity;
          newIds = onAddItems(items, typeof integrationKey === 'string' ? integrationKey : undefined, entityType);
          setResponseItemIds(function (currentIds) {
            return [].concat(_toConsumableArray(currentIds), _toConsumableArray(newIds));
          });
          if (!isFedRamp()) {
            if (typeof integrationKey === 'string') {
              aris = items.reduce(function (acc, item) {
                var _item$ari;
                return typeof ((_item$ari = item.ari) === null || _item$ari === void 0 ? void 0 : _item$ari.data) === 'string' ? [].concat(_toConsumableArray(acc), [item.ari.data]) : acc;
              }, []);
              if (aris.length && entityType) {
                discoverActions({
                  aris: aris,
                  integrationKey: integrationKey,
                  fieldKeys: fieldKeys,
                  entityType: entityType
                });
              }
            }
          }
          setHasNextPage(Boolean(nextPageCursor));
          if (fieldKeys.length > 0) {
            setLastRequestedFieldKeys(fieldKeys);
          }
          if ((isSchemaFromData && schema || fullSchema.properties.length > 0) && items.length > 0) {
            applySchemaProperties(schema || fullSchema, fieldKeys);
          }
          isUserLoadingNextPage = responseItems.length !== 0 && !shouldRequestFirstPage;
          if (isUserLoadingNextPage) {
            currentLoadedItemCount = responseItems.length;
            newlyLoadedItemCount = (items === null || items === void 0 ? void 0 : items.length) || 0;
            fireEvent('track.nextItem.loaded', {
              extensionKey: _extensionKey,
              destinationObjectTypes: _destinationObjectTypes,
              loadedItemCount: currentLoadedItemCount + newlyLoadedItemCount
            });
          }
          setStatus('resolved');
          _context2.next = 64;
          break;
        case 52:
          _context2.prev = 52;
          _context2.t0 = _context2["catch"](10);
          if (!(_context2.t0.message === 'Aborted')) {
            _context2.next = 56;
            break;
          }
          return _context2.abrupt("return");
        case 56:
          captureError('onNextPage', _context2.t0);
          if (!(_context2.t0 instanceof Response && _context2.t0.status === 401)) {
            _context2.next = 60;
            break;
          }
          setStatus('unauthorized');
          return _context2.abrupt("return");
        case 60:
          if (!(_context2.t0 instanceof Response && _context2.t0.status === 403)) {
            _context2.next = 63;
            break;
          }
          setStatus('forbidden');
          return _context2.abrupt("return");
        case 63:
          setStatus('rejected');
        case 64:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[10, 52]]);
  })), [captureError, parameters, fieldKeys, nextCursor, responseItems, setResponseItemIds, onAddItems, getDatasourceData, datasourceId, applySchemaProperties, fireEvent, fullSchema, initialEmptyArray, discoverActions]);
  var reset = useCallback(function (options) {
    setResponseItems(initialEmptyArray);
    setResponseItemIds(initialEmptyArray);
    setHasNextPage(true);
    setNextCursor(undefined);
    setTotalCount(undefined);
    setLastRequestedFieldKeys(initialEmptyArray);
    setAuthDetails(initialEmptyArray);
    setFullSchema({
      properties: initialEmptyArray
    });
    setShouldForceRequest((options === null || options === void 0 ? void 0 : options.shouldForceRequest) || false);
    if (options !== null && options !== void 0 && options.shouldResetColumns) {
      setColumns(initialEmptyArray);
      setDefaultVisibleColumnKeys(initialEmptyArray);
    }

    // setting the status earlier is triggering useEffects without all reset state values, hence placing this as the last state reset item
    setStatus('empty');
  }, [initialEmptyArray]);

  // this takes care of requesting /data initially
  useEffect(function () {
    var isEmptyState = Object.keys(parameters || {}).length > 0 && lastRequestedFieldKeys.length === 0 && status === 'empty';
    if (isEmptyState) {
      void onNextPage({
        shouldForceRequest: shouldForceRequest
      });
      setShouldForceRequest(false);
    }
  }, [lastRequestedFieldKeys, onNextPage, parameters, shouldForceRequest, status]);

  // this takes care of requesting /data when user selects/unselects a column
  useEffect(function () {
    var canHaveNewColumns = fieldKeys.length > 0 && lastRequestedFieldKeys.length > 0;
    if (canHaveNewColumns) {
      var hasNewColumns = fieldKeys.some(function (key) {
        return !lastRequestedFieldKeys.includes(key);
      });
      if (!hasNewColumns) {
        return;
      }

      // check if each fieldKey already appears at least once in the object keys of each response item
      var hasDataForColumns = responseItems.some(function (responseItem) {
        var responseItemKeys = Object.keys(responseItem);
        return fieldKeys.every(function (key) {
          return responseItemKeys.includes(key);
        });
      });
      if (!hasDataForColumns) {
        reset();
        void onNextPage({
          isSchemaFromData: false,
          shouldRequestFirstPage: true
        });
      }
    }
  }, [fieldKeys, lastRequestedFieldKeys, responseItems, reset, onNextPage]);
  useEffect(function () {
    return function () {
      return abortController.current.abort();
    };
  }, []);
  return {
    status: status,
    onNextPage: onNextPage,
    responseItems: responseItems,
    responseItemIds: responseItemIds,
    reset: reset,
    loadDatasourceDetails: loadDatasourceDetails,
    hasNextPage: hasNextPage,
    columns: columns,
    defaultVisibleColumnKeys: defaultVisibleColumnKeys,
    totalCount: totalCount,
    extensionKey: extensionKey,
    providerName: providerName,
    destinationObjectTypes: destinationObjectTypes,
    authDetails: authDetails
  };
};