import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { useDebouncedCallback } from 'use-debounce';
import { FilterPopupSelect } from '../../../../common/modal/popup-select';
import { SEARCH_DEBOUNCE_MS } from '../../../../common/modal/popup-select/constants';
import { useCurrentUserInfo } from '../../hooks/useCurrentUserInfo';
import useRecommendation from '../../hooks/useRecommendation';
import { CLOLBasicFilters } from '../../types';
import { editedOrCreatedByMessage } from './messages';
var filterName = "clol-basic-filter-".concat(CLOLBasicFilters.editedOrCreatedBy);
var EditedOrCreatedByFilter = function EditedOrCreatedByFilter(_ref) {
  var cloudId = _ref.cloudId,
    onSelectionChange = _ref.onSelectionChange,
    _ref$selection = _ref.selection,
    selection = _ref$selection === void 0 ? [] : _ref$selection,
    _ref$isHydrating = _ref.isHydrating,
    isHydrating = _ref$isHydrating === void 0 ? false : _ref$isHydrating;
  var _useCurrentUserInfo = useCurrentUserInfo(),
    user = _useCurrentUserInfo.user;
  var _useIntl = useIntl(),
    formatMessage = _useIntl.formatMessage;
  var _useRecommendation = useRecommendation(),
    status = _useRecommendation.status,
    filterOptions = _useRecommendation.filterOptions,
    fetchFilterOptions = _useRecommendation.fetchFilterOptions,
    errors = _useRecommendation.errors,
    resetHook = _useRecommendation.reset;
  var currentSiteCloudId = useRef(cloudId || '');
  var _useState = useState(''),
    _useState2 = _slicedToArray(_useState, 2),
    searchTerm = _useState2[0],
    setSearchTerm = _useState2[1];
  var _useDebouncedCallback = useDebouncedCallback(function (searchTerm) {
      if (cloudId && user !== null && user !== void 0 && user.accountId) {
        fetchFilterOptions({
          searchTerm: searchTerm,
          cloudId: cloudId,
          userId: user.accountId
        });
      }
    }, SEARCH_DEBOUNCE_MS),
    _useDebouncedCallback2 = _slicedToArray(_useDebouncedCallback, 1),
    handleDebouncedFetchFilterOptions = _useDebouncedCallback2[0];
  var handleInputChange = useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newSearchTerm) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            setSearchTerm(newSearchTerm);
            handleDebouncedFetchFilterOptions(newSearchTerm);
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [handleDebouncedFetchFilterOptions]);
  var handleOptionSelection = useCallback(function (newValue) {
    onSelectionChange(CLOLBasicFilters.editedOrCreatedBy, newValue);
  }, [onSelectionChange]);
  var handleMenuOpen = useCallback(function () {
    if ((status === 'empty' || status === 'rejected') && cloudId && user !== null && user !== void 0 && user.accountId) {
      // if user searches and gets status as rejected, we want the dropdown to try load the request with searchString when the user reopens the dropdown
      fetchFilterOptions({
        cloudId: cloudId,
        userId: user.accountId,
        searchTerm: searchTerm
      });
    }
  }, [fetchFilterOptions, status, cloudId, user === null || user === void 0 ? void 0 : user.accountId, searchTerm]);
  var filterOptionsLength = filterOptions.length;
  var isError = status === 'rejected';
  var isLoading = status === 'loading' || status === 'empty';
  var isEmpty = status === 'resolved' && filterOptionsLength === 0;
  var isDisabled = !cloudId || !(user !== null && user !== void 0 && user.accountId);
  useEffect(function () {
    if (cloudId && currentSiteCloudId.current !== cloudId) {
      currentSiteCloudId.current = cloudId;
      if (status === 'resolved') {
        resetHook();
      }
    }
  }, [cloudId, resetHook, status]);
  return /*#__PURE__*/React.createElement(FilterPopupSelect, {
    buttonLabel: formatMessage(editedOrCreatedByMessage.buttonLabel),
    filterName: filterName,
    isDisabled: isDisabled,
    options: filterOptions,
    showLoading: isLoading,
    selectedOptions: selection,
    onSelectionChange: handleOptionSelection,
    onInputChange: handleInputChange,
    showHydrating: isHydrating,
    shouldShowFooter: false,
    status: status,
    onMenuOpen: handleMenuOpen,
    menuListProps: {
      filterName: filterName,
      errors: errors,
      isLoading: isLoading,
      isError: isError,
      isEmpty: isEmpty
    }
  });
};
export default EditedOrCreatedByFilter;