import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["assignee"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useCallback, useEffect, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { OPERAND_EMPTY } from '@atlaskit/jql-ast';
import { useBasicFilterAGG } from '../../../../services/useBasicFilterAGG';
import { extractValuesFromNonComplexJQL } from '../utils/extractValuesFromNonComplexJQL';
import { removeFuzzyCharacter } from '../utils/isClauseTooComplex';
import { mapHydrateResponseData } from '../utils/transformers';
import { getAssigneeUnassignedFilterOption } from './useFilterOptions';
export var useHydrateJqlQuery = function useHydrateJqlQuery(cloudId, jql) {
  var _useState = useState({}),
    _useState2 = _slicedToArray(_useState, 2),
    hydratedOptions = _useState2[0],
    setHydratedOptions = _useState2[1];
  var _useIntl = useIntl(),
    formatMessage = _useIntl.formatMessage;
  var _useState3 = useState('empty'),
    _useState4 = _slicedToArray(_useState3, 2),
    status = _useState4[0],
    setStatus = _useState4[1];
  var _useState5 = useState([]),
    _useState6 = _slicedToArray(_useState5, 2),
    errors = _useState6[0],
    setErrors = _useState6[1];
  var _useBasicFilterAGG = useBasicFilterAGG(),
    getHydratedJQL = _useBasicFilterAGG.getHydratedJQL;
  var fetchHydratedJqlOptions = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var response, _mapHydrateResponseDa, mappedHydratedAssigneeValue, restOfMappedHydratedResponse, _extractValuesFromNon, text, summary, key, extractedAssigneeValue, _ref2, _ref3, textFieldValue, mappedValues;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          setStatus('loading');
          _context.next = 4;
          return getHydratedJQL(cloudId, jql);
        case 4:
          response = _context.sent;
          if (!(response.errors && response.errors.length > 0)) {
            _context.next = 9;
            break;
          }
          setStatus('rejected');
          setErrors(response.errors);
          return _context.abrupt("return");
        case 9:
          _mapHydrateResponseDa = mapHydrateResponseData(response), mappedHydratedAssigneeValue = _mapHydrateResponseDa.assignee, restOfMappedHydratedResponse = _objectWithoutProperties(_mapHydrateResponseDa, _excluded);
          /**
           * Hydrate logic does not return text field, hence we parse and extract value from jql
           */
          _extractValuesFromNon = extractValuesFromNonComplexJQL(jql), text = _extractValuesFromNon.text, summary = _extractValuesFromNon.summary, key = _extractValuesFromNon.key, extractedAssigneeValue = _extractValuesFromNon.assignee;
          _ref2 = text || summary || key || [], _ref3 = _slicedToArray(_ref2, 1), textFieldValue = _ref3[0];
          mappedValues = _objectSpread(_objectSpread({}, restOfMappedHydratedResponse), {}, {
            /**
             * Special handling for assignee as we need to inject Unassigned value if JQL contains EMPTY keyword for assignee
             */
            assignee: [].concat(_toConsumableArray(mappedHydratedAssigneeValue || []), _toConsumableArray(extractedAssigneeValue !== null && extractedAssigneeValue !== void 0 && extractedAssigneeValue.includes(OPERAND_EMPTY) // checks and adds EMPTY filter option if extracted assignee values from jql contains EMPTY
            ? [getAssigneeUnassignedFilterOption(formatMessage)] : []))
          }, textFieldValue ? {
            basicInputTextValue: removeFuzzyCharacter(textFieldValue)
          } : {});
          setHydratedOptions(mappedValues);
          setStatus('resolved');
          _context.next = 21;
          break;
        case 17:
          _context.prev = 17;
          _context.t0 = _context["catch"](0);
          setErrors([_context.t0]);
          setStatus('rejected');
        case 21:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 17]]);
  })), [cloudId, formatMessage, getHydratedJQL, jql]);
  useEffect(function () {
    if (status !== 'rejected' && errors.length !== 0) {
      setErrors([]);
    }
  }, [errors.length, status]);
  return {
    hydratedOptions: hydratedOptions,
    fetchHydratedJqlOptions: fetchHydratedJqlOptions,
    status: status,
    errors: errors
  };
};