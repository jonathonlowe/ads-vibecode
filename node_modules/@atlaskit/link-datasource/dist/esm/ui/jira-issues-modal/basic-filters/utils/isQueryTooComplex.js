import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _wrapNativeSuper from "@babel/runtime/helpers/wrapNativeSuper";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import mergeWith from 'lodash/mergeWith';
import { AbstractJastVisitor, COMPOUND_OPERATOR_AND, COMPOUND_OPERATOR_OR, JastBuilder, OPERATOR_EQUALS, OPERATOR_IN, OPERATOR_LIKE } from '@atlaskit/jql-ast';
import { ALLOWED_ORDER_BY_KEYS } from '../../jira-search-container';
import { isClauseTooComplex } from './isClauseTooComplex';
import { isValidJql } from './index';

// Map of field keys to their respective clauses in the Jast

var allowedFields = [
// basic filter fields
'assignee', 'type', 'project', 'status',
// search input fields
'text', 'summary', 'key'];
var fallbackOperators = [OPERATOR_IN];
var fieldSpecificOperators = {
  text: [OPERATOR_LIKE, OPERATOR_EQUALS],
  summary: [OPERATOR_LIKE, OPERATOR_EQUALS],
  key: [OPERATOR_EQUALS],
  project: [OPERATOR_IN, OPERATOR_EQUALS],
  type: [OPERATOR_IN, OPERATOR_EQUALS],
  status: [OPERATOR_IN, OPERATOR_EQUALS],
  assignee: [OPERATOR_IN, OPERATOR_EQUALS]
};
var JqlClauseCollectingVisitorError = /*#__PURE__*/function (_Error) {
  function JqlClauseCollectingVisitorError() {
    _classCallCheck(this, JqlClauseCollectingVisitorError);
    return _callSuper(this, JqlClauseCollectingVisitorError, arguments);
  }
  _inherits(JqlClauseCollectingVisitorError, _Error);
  return _createClass(JqlClauseCollectingVisitorError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Rather than having to navigate the entire tree structure ourself, we extend AbstractJastVisitor
 * class and implement visitor functions for node types that we wish to process.
 * A list of available visitor can be viewed in packages/jql/jql-ast/src/types/api/jast-visitor.ts
 * more info - https://atlaskit.atlassian.com/packages/jql/jql-ast/docs/traversing-the-ast
 * */
var JqlClauseCollectingVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function JqlClauseCollectingVisitor() {
    var _this;
    _classCallCheck(this, JqlClauseCollectingVisitor);
    _this = _callSuper(this, JqlClauseCollectingVisitor);
    _defineProperty(_this, "visitNotClause", function () {
      throw new JqlClauseCollectingVisitorError('Visited an unsupported node while traversing the AST');
    });
    _defineProperty(_this, "visitOrderByField", function (orderByField) {
      var _orderByField$field$v;
      var fieldValue = (_orderByField$field$v = orderByField.field.value) === null || _orderByField$field$v === void 0 ? void 0 : _orderByField$field$v.toLowerCase();
      if (fieldValue && !ALLOWED_ORDER_BY_KEYS.includes(fieldValue)) {
        throw new JqlClauseCollectingVisitorError("query with order by field '".concat(fieldValue, "' is not supported"));
      }
      return {};
    });
    _defineProperty(_this, "visitCompoundClause", function (compoundClause) {
      var clauseMap = {};
      var operator = compoundClause.operator.value;
      if (operator === COMPOUND_OPERATOR_AND) {
        return compoundClause.clauses.reduce(function (result, clause) {
          return _this.aggregateResult(clause.accept(_this), result);
        }, clauseMap);
      }
      if (operator === COMPOUND_OPERATOR_OR) {
        // this is delt with in isClauseTooComplex
        return _this.aggregateResult({
          text: [compoundClause]
        }, clauseMap);
      }
      throw new JqlClauseCollectingVisitorError("Compound clauses using the operator '".concat(operator, "' is not supported"));
    });
    _defineProperty(_this, "visitTerminalClause", function (terminalClause) {
      var _terminalClause$opera;
      var fieldName = terminalClause.field.value.toLowerCase();
      if (!allowedFields.includes(fieldName)) {
        throw new JqlClauseCollectingVisitorError("Field with name '".concat(fieldName, "' of type ").concat(terminalClause.clauseType, " is not supported"));
      }
      var operator = (_terminalClause$opera = terminalClause.operator) === null || _terminalClause$opera === void 0 ? void 0 : _terminalClause$opera.value;
      var allowedOperators = fieldSpecificOperators[fieldName] || fallbackOperators;
      if (operator && !allowedOperators.includes(operator.toLowerCase())) {
        throw new JqlClauseCollectingVisitorError("Field with name '".concat(fieldName, "' using operator ").concat(operator, " is not supported"));
      }
      return _defineProperty({}, terminalClause.field.value.toLowerCase(), [terminalClause]);
    });
    return _this;
  }
  _inherits(JqlClauseCollectingVisitor, _AbstractJastVisitor);
  return _createClass(JqlClauseCollectingVisitor, [{
    key: "aggregateResult",
    value: function aggregateResult(aggregate, nextResult) {
      return mergeWith(aggregate, nextResult, function (destValue, srcValue) {
        return srcValue.concat(destValue !== null && destValue !== void 0 ? destValue : []);
      });
    }
  }, {
    key: "defaultResult",
    value: function defaultResult() {
      return {};
    }
  }]);
}(AbstractJastVisitor);
export var isQueryTooComplex = function isQueryTooComplex(jql) {
  if (!jql) {
    return false;
  }
  if (!isValidJql(jql)) {
    return true;
  }
  var jast = new JastBuilder().build(jql);
  try {
    var jqlClauseCollectingVisitor = new JqlClauseCollectingVisitor();
    var clauseMap = jast.query ? jast.query.accept(jqlClauseCollectingVisitor) : {}; // jast.query is defined as void | Query, hence the fallback

    var hasAnyKeyWithComplexClause = Object.entries(clauseMap).some(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        clauses = _ref3[1];
      return isClauseTooComplex(clauses, key);
    });
    return hasAnyKeyWithComplexClause;
  } catch (error) {
    return true;
  }
};