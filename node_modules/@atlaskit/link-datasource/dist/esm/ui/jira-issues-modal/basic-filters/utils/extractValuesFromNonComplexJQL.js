import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import mergeWith from 'lodash/mergeWith';
import { AbstractJastVisitor, JastBuilder, NODE_TYPE_ORDER_BY, OPERAND_EMPTY, OPERAND_TYPE_KEYWORD, OPERAND_TYPE_LIST, OPERAND_TYPE_VALUE } from '@atlaskit/jql-ast';
import { isQueryTooComplex } from './isQueryTooComplex';

// Map of field keys to their respective clauses in the Jast

var getFieldValues = function getFieldValues(operand) {
  var mapValuesFromList = function mapValuesFromList(value) {
    if (value.operandType === OPERAND_TYPE_VALUE) {
      return value.value;
    }
    // we only support EMPTY keyword atm, hence making sure if operandType is a KEYWORD, then its an EMPTY keyword
    if (value.operandType === OPERAND_TYPE_KEYWORD && value.value === OPERAND_EMPTY) {
      return value.value;
    }
    return undefined;
  };
  switch (operand.operandType) {
    case OPERAND_TYPE_LIST:
      return operand.values.map(mapValuesFromList).filter(function (value) {
        return !!value;
      });
    case OPERAND_TYPE_VALUE:
      return operand.value ? [operand.value] : [];
    case OPERAND_TYPE_KEYWORD:
      return operand.value === OPERAND_EMPTY ? [operand.value] : [];
    default:
      return [];
  }
};

/**
 * Rather than having to navigate the entire tree structure ourself, we extend AbstractJastVisitor
 * class and implement visitField to walk through each field and value.
 * */
var JqlClauseCollectingVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function JqlClauseCollectingVisitor() {
    var _this;
    _classCallCheck(this, JqlClauseCollectingVisitor);
    _this = _callSuper(this, JqlClauseCollectingVisitor);
    _defineProperty(_this, "visitField", function (field) {
      var _field$value;
      var fieldName = (_field$value = field.value) === null || _field$value === void 0 ? void 0 : _field$value.toLowerCase();
      var fieldParent = field.parent;
      if (!fieldParent) {
        return;
      }

      // we do not want to parse and store the order by field+value
      var fieldGrandParent = fieldParent.parent;
      if (fieldGrandParent.type === NODE_TYPE_ORDER_BY) {
        return;
      }
      var operand = fieldParent.operand;
      var fieldValues = operand && getFieldValues(operand) || [];
      return _defineProperty({}, fieldName, fieldValues);
    });
    return _this;
  }
  _inherits(JqlClauseCollectingVisitor, _AbstractJastVisitor);
  return _createClass(JqlClauseCollectingVisitor, [{
    key: "aggregateResult",
    value: function aggregateResult(aggregate, nextResult) {
      return mergeWith(aggregate, nextResult, function (destValue, srcValue) {
        return srcValue.concat(destValue !== null && destValue !== void 0 ? destValue : []);
      });
    }
  }, {
    key: "defaultResult",
    value: function defaultResult() {
      return {};
    }
  }]);
}(AbstractJastVisitor);
export var extractValuesFromNonComplexJQL = function extractValuesFromNonComplexJQL(jql) {
  if (isQueryTooComplex(jql)) {
    return {};
  }
  var jast = new JastBuilder().build(jql);
  var jqlClauseCollectingVisitor = new JqlClauseCollectingVisitor();
  var mappedValues = jast.query ? jast.query.accept(jqlClauseCollectingVisitor) || {} : {}; // jast.query is defined as void | Query, hence the fallback

  return mappedValues;
};