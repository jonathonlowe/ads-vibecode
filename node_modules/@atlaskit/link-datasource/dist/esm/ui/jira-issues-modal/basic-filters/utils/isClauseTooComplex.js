import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { CLAUSE_TYPE_COMPOUND, CLAUSE_TYPE_TERMINAL, OPERAND_TYPE_VALUE } from '@atlaskit/jql-ast';
import { fuzzyCharacter } from '../../jira-search-container/buildJQL';
export var removeFuzzyCharacter = function removeFuzzyCharacter(value) {
  if (value !== null && value !== void 0 && value.endsWith(fuzzyCharacter)) {
    return value.slice(0, -1);
  }
  return value;
};
var getValueFromTerminalClause = function getValueFromTerminalClause(clause) {
  var operand = clause.operand;
  return operand !== undefined && operand.operandType === OPERAND_TYPE_VALUE && removeFuzzyCharacter(operand.value) || undefined;
};
var areClauseFieldValuesEqual = function areClauseFieldValuesEqual(clauseA, clauseB, clauseC) {
  var valueA = clauseA && getValueFromTerminalClause(clauseA);
  var valueB = clauseB && getValueFromTerminalClause(clauseB);
  var valueC = clauseC && getValueFromTerminalClause(clauseC);
  var values = [valueA, valueB, valueC].filter(Boolean);

  // checks if valid fields, text, summary and key have the same value, if not, its a complex query and cannnot be recreated in basic mode
  return values.length > 1 && values.every(function (value) {
    return value === values[0];
  });
};
var areClauseFieldKeysAllowed = function areClauseFieldKeysAllowed(clauseA, clauseB, clauseC) {
  var fieldA = clauseA.field.value;
  var fieldB = clauseB.field.value;
  var fieldC = clauseC === null || clauseC === void 0 ? void 0 : clauseC.field.value; // clauseC only if jql with 3 OR clauses, 'text ~ "EDM-6023*" or summary ~ "EDM-6023*" or key = EDM-6023 ORDER BY created DESC',

  return [fieldA, fieldB, fieldC].filter(Boolean).every(function (field) {
    return ['summary', 'text', 'key'].includes(field);
  });
};
var doesCompoundClauseContainAllTerminalClauses = function doesCompoundClauseContainAllTerminalClauses(clauses) {
  return clauses.every(function (clauses) {
    return clauses.clauseType === CLAUSE_TYPE_TERMINAL;
  });
};
export var isClauseTooComplex = function isClauseTooComplex(clauses, key) {
  if (key === 'text') {
    var _clauses = _slicedToArray(clauses, 1),
      clause = _clauses[0];
    if (clause.clauseType === CLAUSE_TYPE_COMPOUND) {
      var textClauses = clause.clauses;

      /**
       * valid: text ~ "test*" or summary ~ "test*" ORDER BY created DESC
       * valid: text ~ "EDM-6023*" or summary ~ "EDM-6023*" or key = EDM-6023 ORDER BY created DESC
       * invalid: assignee = "me" or text ~ "EDM-6023*" or summary ~ "EDM-6023*" or key = EDM-6023 ORDER BY created DESC
       */
      if (textClauses.length !== 2 && textClauses.length !== 3) {
        return true;
      }

      /**
       * valid: text ~ "test*" or summary ~ "test*"
       * invalid: text ~ "test" or (summary ~ "test" or key = "test")
       */
      if (!doesCompoundClauseContainAllTerminalClauses(textClauses)) {
        return true;
      }
      var _textClauses = _slicedToArray(textClauses, 3),
        clauseA = _textClauses[0],
        clauseB = _textClauses[1],
        clauseC = _textClauses[2];

      /**
       * valid: text ~ "EDM-6023*" or summary ~ "EDM-6023*" or key = EDM-6023 ORDER BY created DESC
       * invalid: text ~ "EDM-6023*" or summary ~ "anotherValue" ORDER BY created DESC
       * invalid: text ~ "EDM-6023*" or text ~ "anotherValue" ORDER BY created DESC
       */
      if (!areClauseFieldValuesEqual(clauseA, clauseB, clauseC)) {
        return true;
      }

      /**
       * valid: text ~ "EDM-6023*" ORDER BY created DESC
       * invalid: resolution = 40134 ORDER BY created DESC
       */
      if (!areClauseFieldKeysAllowed(clauseA, clauseB, clauseC)) {
        return true;
      }
    }
  }
  return clauses.length > 1;
};