/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./index.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
import React from 'react';
import { useIntl } from 'react-intl-next';
import { Box } from '@atlaskit/primitives/compiled';
import Tooltip from '@atlaskit/tooltip';
import { useDatasourceItem } from '../../../state';
import { useExecuteAtomicAction } from '../../../state/actions';
import { isEditTypeSelectable, isEditTypeSupported } from '../edit-type';
import { stringifyType } from '../render-type';
import { TruncateTextTag } from '../truncate-text-tag';
import { InlineEdit } from './inline-edit';
var styles = {
  readViewStyles: "_1reo15vq _18m915vq _1bto1l2s _1bsb1osq _ae4v1h6o"
};
var TooltipWrapper = function TooltipWrapper(_ref) {
  var columnKey = _ref.columnKey,
    _ref$datasourceTypeWi = _ref.datasourceTypeWithValues,
    type = _ref$datasourceTypeWi.type,
    values = _ref$datasourceTypeWi.values,
    wrappedColumnKeys = _ref.wrappedColumnKeys,
    children = _ref.children;
  var intl = useIntl();
  var stringifiedContent = values.map(function (value) {
    return stringifyType({
      type: type,
      value: value
    }, intl.formatMessage, intl.formatDate);
  }).filter(function (value) {
    return value !== '';
  }).join(', ');
  if (stringifiedContent && !(wrappedColumnKeys !== null && wrappedColumnKeys !== void 0 && wrappedColumnKeys.includes(columnKey))) {
    return /*#__PURE__*/React.createElement(Tooltip
    // @ts-ignore: [PIT-1685] Fails in post-office due to backwards incompatibility issue with React 18
    , {
      tag: TruncateTextTag,
      content: stringifiedContent,
      testId: "issues-table-cell-tooltip"
    }, children);
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, children);
};
export var ReadOnlyCell = function ReadOnlyCell(_ref2) {
  var _useDatasourceItem, _rowData$columnKey;
  var id = _ref2.id,
    columnType = _ref2.columnType,
    _ref2$wrappedColumnKe = _ref2.wrappedColumnKeys,
    wrappedColumnKeys = _ref2$wrappedColumnKe === void 0 ? [] : _ref2$wrappedColumnKe,
    renderItem = _ref2.renderItem,
    columnKey = _ref2.columnKey;
  var rowData = (_useDatasourceItem = useDatasourceItem({
    id: id
  })) === null || _useDatasourceItem === void 0 ? void 0 : _useDatasourceItem.data;
  if (!rowData || !columnKey || !rowData[columnKey]) {
    return null;
  }

  // Need to make sure we keep falsy values like 0 and '', as well as the boolean false.
  var value = (_rowData$columnKey = rowData[columnKey]) === null || _rowData$columnKey === void 0 ? void 0 : _rowData$columnKey.data;
  var values = Array.isArray(value) ? value : [value];
  var datasourceTypeWithValues = {
    type: columnType,
    values: values
  };
  return /*#__PURE__*/React.createElement(TooltipWrapper, {
    columnKey: columnKey,
    datasourceTypeWithValues: datasourceTypeWithValues,
    wrappedColumnKeys: wrappedColumnKeys
  }, renderItem(datasourceTypeWithValues));
};
var InlineEditableCell = function InlineEditableCell(_ref3) {
  var ari = _ref3.ari,
    values = _ref3.values,
    columnKey = _ref3.columnKey,
    columnTitle = _ref3.columnTitle,
    renderItem = _ref3.renderItem,
    integrationKey = _ref3.integrationKey,
    wrappedColumnKeys = _ref3.wrappedColumnKeys;
  // Callbacks are returned only when the ari is editable and the action schemas exist in the store
  var _useExecuteAtomicActi = useExecuteAtomicAction({
      ari: ari,
      fieldKey: columnKey,
      integrationKey: integrationKey
    }),
    execute = _useExecuteAtomicActi.execute,
    executeFetch = _useExecuteAtomicActi.executeFetch;

  // A field is editable when `execute` is returned from the store
  var isEditable = !!execute;
  var readView = /*#__PURE__*/React.createElement(TooltipWrapper, {
    columnKey: columnKey,
    datasourceTypeWithValues: values,
    wrappedColumnKeys: wrappedColumnKeys
  }, /*#__PURE__*/React.createElement(Box, {
    testId: "inline-edit-read-view",
    paddingInline: isEditable ? 'space.075' : 'space.100',
    paddingBlock: "space.050",
    xcss: styles.readViewStyles
    // minHeight here compensates for 2px from both top and bottom taken by InlneEdit (from transparent border in read-view mode and border+padding in edit view)
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      minHeight: 'calc(40px - 2px * 2)'
    }
  }, renderItem(values)));
  if (!isEditable) {
    return readView;
  }

  // if the field requires to fetch options to execute, then is editable only if `executeFetch` is defined
  if (isEditTypeSelectable(values.type) && !executeFetch) {
    return readView;
  }
  return /*#__PURE__*/React.createElement(InlineEdit, {
    ari: ari,
    execute: execute,
    executeFetch: executeFetch,
    readView: readView,
    columnKey: columnKey,
    columnTitle: columnTitle,
    datasourceTypeWithValues: values
  });
};
var toDatasourceTypeWithValues = function toDatasourceTypeWithValues(_ref4) {
  var _rowData$columnKey2;
  var rowData = _ref4.rowData,
    columnKey = _ref4.columnKey,
    columnType = _ref4.columnType;
  // Need to make sure we keep falsy values like 0 and '', as well as the boolean false.
  var value = (_rowData$columnKey2 = rowData[columnKey]) === null || _rowData$columnKey2 === void 0 ? void 0 : _rowData$columnKey2.data;
  var values = !value ? [] : Array.isArray(value) ? value : [value];
  return {
    type: columnType,
    values: values
  };
};
export var TableCellContent = function TableCellContent(_ref5) {
  var id = _ref5.id,
    columnKey = _ref5.columnKey,
    columnTitle = _ref5.columnTitle,
    columnType = _ref5.columnType,
    renderItem = _ref5.renderItem,
    wrappedColumnKeys = _ref5.wrappedColumnKeys;
  var item = useDatasourceItem({
    id: id
  });
  if (item) {
    var integrationKey = item.integrationKey,
      ari = item.ari,
      rowData = item.data;
    var isEditType = !!ari && !!integrationKey && isEditTypeSupported(columnType);
    if (isEditType) {
      return /*#__PURE__*/React.createElement(InlineEditableCell, {
        ari: ari,
        columnKey: columnKey,
        columnTitle: columnTitle,
        renderItem: renderItem,
        integrationKey: integrationKey,
        values: toDatasourceTypeWithValues({
          rowData: rowData,
          columnKey: columnKey,
          columnType: columnType
        }),
        wrappedColumnKeys: wrappedColumnKeys
      });
    }
  }
  return /*#__PURE__*/React.createElement(Box, {
    testId: "inline-edit-read-view",
    paddingInline: "space.100",
    paddingBlock: "space.050",
    xcss: styles.readViewStyles
    // minHeight here compensates for 2px from both top and bottom taken by InlneEdit (from transparent border in read-view mode and border+padding in edit view)
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      minHeight: 'calc(40px - 2px * 2)'
    }
  }, /*#__PURE__*/React.createElement(ReadOnlyCell, {
    id: id,
    columnKey: columnKey,
    columnTitle: columnTitle,
    columnType: columnType,
    wrappedColumnKeys: wrappedColumnKeys,
    renderItem: renderItem
  }));
};