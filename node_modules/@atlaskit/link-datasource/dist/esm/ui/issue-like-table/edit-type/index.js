import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _objectDestructuringEmpty from "@babel/runtime/helpers/objectDestructuringEmpty";
import _extends from "@babel/runtime/helpers/extends";
var _excluded = ["value"];
import React from 'react';
import { fg } from '@atlaskit/platform-feature-flags';
import IconEditType from './icon';
import StatusEditType from './status';
import TextEditType from './text';
import UserEditType from './user';

// This is used in editor-card-plugin to identify if any type of inline edit is active.
var ACTIVE_INLINE_EDIT_ID = 'sllv-active-inline-edit';
export var editType = function editType(_ref) {
  var _toValueType, _value$atlassianUserI;
  var defaultValue = _ref.defaultValue,
    currentValue = _ref.currentValue,
    labelId = _ref.labelId,
    setEditValues = _ref.setEditValues,
    executeFetch = _ref.executeFetch;
  switch (defaultValue.type) {
    case 'string':
      return {
        defaultValue: (_toValueType = toValueType(defaultValue)) !== null && _toValueType !== void 0 ? _toValueType : '',
        editView: function editView(_ref2) {
          var fieldProps = _extends({}, (_objectDestructuringEmpty(_ref2), _ref2));
          return /*#__PURE__*/React.createElement(TextEditType, _extends({}, fieldProps, {
            currentValue: currentValue,
            setEditValues: setEditValues,
            id: ACTIVE_INLINE_EDIT_ID,
            labelId: labelId
          }));
        }
      };
    case 'icon':
      return {
        defaultValue: toValueType(defaultValue),
        editView: function editView(_ref3) {
          var value = _ref3.value,
            fieldProps = _objectWithoutProperties(_ref3, _excluded);
          return /*#__PURE__*/React.createElement(IconEditType, _extends({}, fieldProps, {
            currentValue: currentValue,
            setEditValues: setEditValues,
            id: ACTIVE_INLINE_EDIT_ID,
            executeFetch: executeFetch,
            labelId: labelId
          }));
        }
      };
    case 'status':
      return {
        defaultValue: toValueType(defaultValue),
        editView: function editView(_ref4) {
          var fieldProps = _extends({}, (_objectDestructuringEmpty(_ref4), _ref4));
          return /*#__PURE__*/React.createElement(StatusEditType, _extends({}, fieldProps, {
            currentValue: currentValue,
            setEditValues: setEditValues,
            id: ACTIVE_INLINE_EDIT_ID,
            executeFetch: executeFetch,
            labelId: labelId
          }));
        }
      };
    case 'user':
      var value = toValueType(defaultValue);
      return {
        defaultValue: (_value$atlassianUserI = value === null || value === void 0 ? void 0 : value.atlassianUserId) !== null && _value$atlassianUserI !== void 0 ? _value$atlassianUserI : '',
        editView: function editView(_ref5) {
          var fieldProps = _extends({}, (_objectDestructuringEmpty(_ref5), _ref5));
          return /*#__PURE__*/React.createElement(UserEditType, _extends({}, fieldProps, {
            currentValue: currentValue,
            setEditValues: setEditValues,
            id: ACTIVE_INLINE_EDIT_ID,
            executeFetch: executeFetch,
            labelId: labelId
          }));
        }
      };
  }
  return {
    defaultValue: '',
    editView: function editView() {
      return /*#__PURE__*/React.createElement(React.Fragment, null);
    }
  };
};
export var isEditTypeSupported = function isEditTypeSupported(type) {
  var supportedEditType = ['string'].concat(_toConsumableArray(fg('platform-datasources-enable-two-way-sync-statuses') ? ['status'] : []), _toConsumableArray(fg('platform-datasources-enable-two-way-sync-priority') ? ['icon'] : []), _toConsumableArray(fg('platform-datasources-enable-two-way-sync-assignee') ? ['user'] : []));
  return supportedEditType.includes(type);
};
export var isEditTypeSelectable = function isEditTypeSelectable(type) {
  var selectEditTypes = ['status', 'icon', 'user'];
  return selectEditTypes.includes(type);
};
export var toValueType = function toValueType(typeWithValues) {
  var _typeWithValues$value;
  return (_typeWithValues$value = typeWithValues.values) === null || _typeWithValues$value === void 0 ? void 0 : _typeWithValues$value[0];
};