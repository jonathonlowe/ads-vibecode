import { useEffect, useState } from 'react';
import { useDatasourceAnalyticsEvents } from '../analytics';
import { fetchObjectSchema, fetchObjectSchemas, getWorkspaceId } from '../services/cmdbService';
const handleAssetsClientErrors = (errorSetter, error) => {
  if (error instanceof Error) {
    errorSetter(error);
  } else {
    errorSetter(new Error('Unexpected error occured'));
  }
};
export const useAssetsClient = initialParameters => {
  const [loading, setLoading] = useState(false);
  const [workspaceId, setWorkspaceId] = useState();
  const [workspaceError, setWorkspaceError] = useState();
  const [existingObjectSchema, setExistingObjectSchema] = useState();
  const [existingObjectSchemaError, setExistingObjectSchemaError] = useState();
  const [objectSchemas, setObjectSchemas] = useState();
  const [totalObjectSchemas, setTotalObjectSchemas] = useState();
  const [objectSchemasError, setObjectSchemasError] = useState();
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();

  /*
   * We wrap this in nested try/catch blocks because we want to handle
   * workspaceError/existingObjectSchemaError/objectSchemasError differently
   * if we need to implement more initial data fetching/errors we should look at a store
   */
  useEffect(() => {
    (async () => {
      setLoading(true);
      setWorkspaceError(undefined);
      try {
        const workspaceId = await getWorkspaceId(fireEvent);
        setWorkspaceId(workspaceId);
        // Check schema from initial parameters still exists and fetch name/permissions for schema select
        if (initialParameters !== null && initialParameters !== void 0 && initialParameters.schemaId) {
          try {
            const fetchedObjectSchema = await fetchObjectSchema(workspaceId, initialParameters === null || initialParameters === void 0 ? void 0 : initialParameters.schemaId, fireEvent);
            setExistingObjectSchema(fetchedObjectSchema);
          } catch (fetchObjectSchemaError) {
            handleAssetsClientErrors(setExistingObjectSchemaError, fetchObjectSchemaError);
          }
        }
        try {
          const fetchedObjectSchemasResponse = await fetchObjectSchemas(workspaceId, undefined, fireEvent);
          setObjectSchemas(fetchedObjectSchemasResponse.values);
          setTotalObjectSchemas(fetchedObjectSchemasResponse.total);
        } catch (fetchObjectSchemasError) {
          handleAssetsClientErrors(setObjectSchemasError, fetchObjectSchemasError);
        }
      } catch (getWorkspaceIdError) {
        handleAssetsClientErrors(setWorkspaceError, getWorkspaceIdError);
      } finally {
        setLoading(false);
      }
    })();
  }, [initialParameters, fireEvent]);
  return {
    workspaceId,
    workspaceError,
    existingObjectSchema,
    existingObjectSchemaError,
    objectSchemas,
    totalObjectSchemas,
    objectSchemasError,
    assetsClientLoading: loading
  };
};