import { useCallback, useRef, useState } from 'react';
import { useDatasourceAnalyticsEvents } from '../analytics';
import { validateAql } from '../services/cmdbService';
export const SEARCH_DEBOUNCE = 350;
export const useValidateAqlText = (workspaceId, initialValue) => {
  const timeout = useRef();
  const lastValue = useRef('');
  const lastResult = useRef(Promise.resolve(undefined));
  const [lastValidationResult, setLastValidationResult] = useState(initialValue.trim() === '' ? {
    type: 'idle'
  } : {
    type: 'loading'
  });
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();

  // We return undefined when valid and 'error' when invalid
  const validateAqlText = useCallback(async aql => {
    if (aql !== null && aql !== void 0 && aql.trim()) {
      try {
        const validateAqlResponse = await validateAql(workspaceId, {
          qlQuery: aql
        }, fireEvent);
        if (validateAqlResponse.isValid) {
          setLastValidationResult({
            type: 'valid',
            validatedAql: aql
          });
          return undefined;
        } else {
          var _validateAqlResponse$, _validateAqlResponse$2;
          setLastValidationResult({
            type: 'invalid',
            error: (_validateAqlResponse$ = (_validateAqlResponse$2 = validateAqlResponse.errors) === null || _validateAqlResponse$2 === void 0 ? void 0 : _validateAqlResponse$2.iql) !== null && _validateAqlResponse$ !== void 0 ? _validateAqlResponse$ : ''
          });
          return 'error';
        }
      } catch (err) {
        setLastValidationResult({
          type: 'invalid',
          error: ''
        });
        return 'error';
      }
    }
    setLastValidationResult({
      type: 'idle'
    });
    return undefined;
  }, [workspaceId, fireEvent]);

  /* Debounce async validation for input, validation is also called on every field change
   in a form so we need to also memoize. The async validate function is expected to either:
   Immediately return a promise (which is then collected into an array, every single time validation is run),
   or immediately return either undefined or an error message */
  const debouncedValidation = value => new Promise(resolve => {
    if (timeout.current) {
      timeout.current();
    }
    if (value !== lastValue.current) {
      setLastValidationResult({
        type: 'loading'
      });
      const timerId = setTimeout(() => {
        lastValue.current = value;
        lastResult.current = validateAqlText(value);
        resolve(lastResult.current);
      }, SEARCH_DEBOUNCE);
      timeout.current = () => {
        clearTimeout(timerId);
        resolve('debouncing');
      };
    } else {
      resolve(lastResult.current);
    }
  });
  return {
    debouncedValidation,
    validateAqlText,
    lastValidationResult
  };
};