import { useCallback, useEffect, useRef, useState } from 'react';
import isEqual from 'lodash/isEqual';
import { isFedRamp } from '@atlaskit/atlassian-context';
import { DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE, useDatasourceClientExtension } from '@atlaskit/link-client-extension';
import { useDatasourceAnalyticsEvents } from '../analytics';
import { useDatasourceActions } from '../state';
import { useDiscoverActions } from '../state/actions';
import useErrorLogger from './useErrorLogger';
export const useDatasourceTableState = ({
  datasourceId,
  parameters,
  fieldKeys = []
}) => {
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();
  const {
    captureError
  } = useErrorLogger({
    datasourceId
  });
  const {
    onAddItems
  } = useDatasourceActions();
  const {
    discoverActions
  } = useDiscoverActions({
    captureError,
    fireEvent
  });
  const idFieldCount = 1;
  const keyFieldCount = 1;
  const [initialEmptyArray] = useState([]);
  const [defaultVisibleColumnKeys, setDefaultVisibleColumnKeys] = useState([]);
  const [lastRequestedFieldKeys, setLastRequestedFieldKeys] = useState([]);
  const [fullSchema, setFullSchema] = useState({
    properties: []
  });
  const [status, setStatus] = useState('empty');
  const [authDetails, setAuthDetails] = useState([]);
  const [responseItems, setResponseItems] = useState(initialEmptyArray);
  const [responseItemIds, setResponseItemIds] = useState(initialEmptyArray);
  const [hasNextPage, setHasNextPage] = useState(true);
  const [nextCursor, setNextCursor] = useState(undefined);
  const [columns, setColumns] = useState([]);
  const [totalCount, setTotalCount] = useState(undefined);
  const [shouldForceRequest, setShouldForceRequest] = useState(false);
  const [destinationObjectTypes, setDestinationObjectTypes] = useState([]);
  const [extensionKey, setExtensionKey] = useState();
  const [providerName, setProviderName] = useState(undefined);
  const abortController = useRef(new AbortController());
  const {
    getDatasourceData,
    getDatasourceDetails
  } = useDatasourceClientExtension();
  const loadDatasourceDetails = useCallback(async () => {
    if (!parameters) {
      return;
    }
    try {
      const {
        meta: {
          access,
          auth
        },
        data: {
          schema
        }
      } = await getDatasourceDetails(datasourceId, {
        parameters
      });
      if (access === 'unauthorized' || access === 'forbidden') {
        setStatus(access);
        setAuthDetails(auth || initialEmptyArray);
        return;
      }
      const isColumnNotPresentInCurrentColumnsList = col => !columns.find(column => column.key === col.key);
      const allColumns = schema.properties;
      const newColumns = allColumns.filter(isColumnNotPresentInCurrentColumnsList);
      newColumns.length > 0 && setColumns([...columns, ...newColumns]);
    } catch (e) {
      captureError('loadDatasourceDetails', e);
      if (e instanceof Response && e.status === 401) {
        setStatus('unauthorized');
        return;
      }
      if (e instanceof Response && e.status === 403) {
        setStatus('forbidden');
        return;
      }
      setStatus('rejected');
    }
  }, [captureError, columns, datasourceId, getDatasourceDetails, parameters, initialEmptyArray]);
  const applySchemaProperties = useCallback((schema, fieldKeys) => {
    let {
      properties,
      defaultProperties = []
    } = schema;
    let propertiesToBeUsed = properties;
    const propertyKeysToBeUsed = Array.isArray(fieldKeys) && fieldKeys.length > 0 ? fieldKeys : defaultProperties;
    if (fieldKeys.length > 0 || defaultProperties.length > 0) {
      propertiesToBeUsed = properties.filter(property => {
        return propertyKeysToBeUsed.includes(property.key);
      });
    }

    /*Jira adds identifier fields like id and key to all data responses
       Since defaultProperties already send back the keyField, we are accounting only
       for the idField when we are using defaultProperties
       */
    if (properties.length > fieldKeys.length + idFieldCount + keyFieldCount && properties.length > defaultProperties.length + idFieldCount) {
      setFullSchema(schema);
    }
    if (!isEqual(columns, propertiesToBeUsed)) {
      setColumns(propertiesToBeUsed);
    }
    const newProperties = propertiesToBeUsed.map(prop => prop.key);

    // when loading for the first time, we will need to set default visible props as /data does not give you that info
    // also, since we dont pass any fields, we will need to set this info as lastRequestedFieldKeys
    if (!isEqual(defaultVisibleColumnKeys, newProperties)) {
      setDefaultVisibleColumnKeys(newProperties);
    }
    if (!isEqual(lastRequestedFieldKeys, newProperties)) {
      setLastRequestedFieldKeys(newProperties);
    }
  }, [columns, defaultVisibleColumnKeys, lastRequestedFieldKeys]);
  const onNextPage = useCallback(async (requestInfo = {}) => {
    let currentAbortController;
    /**
     * Abort whichever request was made before this one.
     */
    abortController.current.abort();
    /**
     * Setup new abort controller for this request.
     */
    abortController.current = new AbortController();
    currentAbortController = abortController.current;
    if (!parameters) {
      return;
    }
    const {
      isSchemaFromData = true,
      shouldRequestFirstPage,
      shouldForceRequest = false
    } = requestInfo;
    const isFullSchemaLoaded = fullSchema.properties.length > 0;
    const datasourceDataRequest = {
      parameters,
      pageSize: DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE,
      pageCursor: shouldRequestFirstPage ? undefined : nextCursor,
      fields: fieldKeys,
      includeSchema: isFullSchemaLoaded ? false : isSchemaFromData
    };
    setStatus('loading');
    try {
      var _currentAbortControll;
      const {
        meta: {
          access,
          destinationObjectTypes,
          product,
          extensionKey,
          auth,
          providerName,
          objectTypesEntity
        },
        data: {
          items,
          nextPageCursor,
          totalCount,
          schema
        }
      } = await getDatasourceData(datasourceId, datasourceDataRequest, shouldForceRequest);

      /**
       * Let the response finish and store in cache, but throw error if signal is aborted
       */
      if ((_currentAbortControll = currentAbortController) !== null && _currentAbortControll !== void 0 && _currentAbortControll.signal.aborted) {
        throw new Error('Aborted');
      }
      setExtensionKey(extensionKey);
      setProviderName(providerName);
      if (access === 'unauthorized' || access === 'forbidden') {
        setStatus(access);
        setAuthDetails(auth || initialEmptyArray);
        return;
      }
      setDestinationObjectTypes(destinationObjectTypes);
      setTotalCount(totalCount);
      setNextCursor(nextPageCursor);
      setResponseItems(currentResponseItems => {
        if (shouldRequestFirstPage) {
          return items;
        }
        return [...currentResponseItems, ...items];
      });

      /**
       * Product is typed as any.
       */
      const integrationKey = product;

      /**
       * When `entityType` is undefined, we should not discover actions it prevents unnecessary requests to Actions service
       */
      const entityType = objectTypesEntity;
      const newIds = onAddItems(items, typeof integrationKey === 'string' ? integrationKey : undefined, entityType);
      setResponseItemIds(currentIds => [...currentIds, ...newIds]);
      if (!isFedRamp()) {
        if (typeof integrationKey === 'string') {
          const aris = items.reduce((acc, item) => {
            var _item$ari;
            return typeof ((_item$ari = item.ari) === null || _item$ari === void 0 ? void 0 : _item$ari.data) === 'string' ? [...acc, item.ari.data] : acc;
          }, []);
          if (aris.length && entityType) {
            discoverActions({
              aris,
              integrationKey,
              fieldKeys,
              entityType
            });
          }
        }
      }
      setHasNextPage(Boolean(nextPageCursor));
      if (fieldKeys.length > 0) {
        setLastRequestedFieldKeys(fieldKeys);
      }
      if ((isSchemaFromData && schema || fullSchema.properties.length > 0) && items.length > 0) {
        applySchemaProperties(schema || fullSchema, fieldKeys);
      }
      const isUserLoadingNextPage = responseItems.length !== 0 && !shouldRequestFirstPage;
      if (isUserLoadingNextPage) {
        const currentLoadedItemCount = responseItems.length;
        const newlyLoadedItemCount = (items === null || items === void 0 ? void 0 : items.length) || 0;
        fireEvent('track.nextItem.loaded', {
          extensionKey,
          destinationObjectTypes,
          loadedItemCount: currentLoadedItemCount + newlyLoadedItemCount
        });
      }
      setStatus('resolved');
    } catch (e) {
      if (e.message === 'Aborted') {
        /**
         * If the request was aborted, we don't want to change the status of the table
         * as we are already loading the next request attempt
         *
         * Is not an exceptional state, do not need to captureError
         */
        return;
      }
      captureError('onNextPage', e);
      if (e instanceof Response && e.status === 401) {
        setStatus('unauthorized');
        return;
      }
      if (e instanceof Response && e.status === 403) {
        setStatus('forbidden');
        return;
      }
      setStatus('rejected');
    }
  }, [captureError, parameters, fieldKeys, nextCursor, responseItems, setResponseItemIds, onAddItems, getDatasourceData, datasourceId, applySchemaProperties, fireEvent, fullSchema, initialEmptyArray, discoverActions]);
  const reset = useCallback(options => {
    setResponseItems(initialEmptyArray);
    setResponseItemIds(initialEmptyArray);
    setHasNextPage(true);
    setNextCursor(undefined);
    setTotalCount(undefined);
    setLastRequestedFieldKeys(initialEmptyArray);
    setAuthDetails(initialEmptyArray);
    setFullSchema({
      properties: initialEmptyArray
    });
    setShouldForceRequest((options === null || options === void 0 ? void 0 : options.shouldForceRequest) || false);
    if (options !== null && options !== void 0 && options.shouldResetColumns) {
      setColumns(initialEmptyArray);
      setDefaultVisibleColumnKeys(initialEmptyArray);
    }

    // setting the status earlier is triggering useEffects without all reset state values, hence placing this as the last state reset item
    setStatus('empty');
  }, [initialEmptyArray]);

  // this takes care of requesting /data initially
  useEffect(() => {
    const isEmptyState = Object.keys(parameters || {}).length > 0 && lastRequestedFieldKeys.length === 0 && status === 'empty';
    if (isEmptyState) {
      void onNextPage({
        shouldForceRequest
      });
      setShouldForceRequest(false);
    }
  }, [lastRequestedFieldKeys, onNextPage, parameters, shouldForceRequest, status]);

  // this takes care of requesting /data when user selects/unselects a column
  useEffect(() => {
    const canHaveNewColumns = fieldKeys.length > 0 && lastRequestedFieldKeys.length > 0;
    if (canHaveNewColumns) {
      const hasNewColumns = fieldKeys.some(key => !lastRequestedFieldKeys.includes(key));
      if (!hasNewColumns) {
        return;
      }

      // check if each fieldKey already appears at least once in the object keys of each response item
      const hasDataForColumns = responseItems.some(responseItem => {
        const responseItemKeys = Object.keys(responseItem);
        return fieldKeys.every(key => responseItemKeys.includes(key));
      });
      if (!hasDataForColumns) {
        reset();
        void onNextPage({
          isSchemaFromData: false,
          shouldRequestFirstPage: true
        });
      }
    }
  }, [fieldKeys, lastRequestedFieldKeys, responseItems, reset, onNextPage]);
  useEffect(() => {
    return () => abortController.current.abort();
  }, []);
  return {
    status,
    onNextPage,
    responseItems,
    responseItemIds,
    reset,
    loadDatasourceDetails,
    hasNextPage,
    columns,
    defaultVisibleColumnKeys,
    totalCount,
    extensionKey,
    providerName,
    destinationObjectTypes,
    authDetails
  };
};