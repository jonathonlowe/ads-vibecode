import { useCallback, useMemo } from 'react';
import { createActionsHook, createHook, createStore } from 'react-sweet-state';
import { useDatasourceClientExtension } from '@atlaskit/link-client-extension';
import { fg } from '@atlaskit/platform-feature-flags';
import { useDatasourceAnalyticsEvents } from '../../analytics';
import useErrorLogger from '../../hooks/useErrorLogger';
import { useDatasourceItem } from '../index';

/**
 * Atomic actions available for an integration (by field)
 * @example
 * ```ts
 * {
 *  jira: {
 *    summary: {
 *      actionKey: 'atlassian:work-item:update:summary',
 *      type: 'string'
 *    },
 *    status: {
 *      actionKey: 'atlassian:work-item:update:status',
 *      type: 'string',
 *      fetchAction: {
 *        actionKey: 'atlassian:work-item:get:statuses',
 *        type: 'string',
 *        inputs: {
 *          issueId: {
 *            type: 'string'
 *          }
 *        }
 *      }
 *    }
 *  }
 * }
 * ```
 */

/**
 * Permissions available for a target
 */

/**
 * User permissions for actions on target (ARI) properties
 * @example
 * ```ts
 *	{
 *		'ari:cloud:jira:63cecfe3-16fa-4ee1-8e8d-047cc4b18980:issue/1': {
 *			summary: {
 *				isEditable: true
 *			}
 *		}
 *	}
 * ```
 */

const getInitialState = () => ({
  actionsByIntegration: {},
  permissions: {}
});
export const actions = {
  discoverActions: (captureError, fireEvent, api, request) => async ({
    setState,
    getState
  }) => {
    try {
      const response = await api.getDatasourceActionsAndPermissions(request);
      if ('permissions' in response) {
        const {
          actionsByIntegration: currentActions,
          permissions: currentPermissions
        } = getState();
        const actionsByIntegration = response.actions.reduce((acc, action) => {
          var _action$inputs, _action$inputs$fieldK;
          const fieldKey = action.fieldKey;
          const fetchAction = (_action$inputs = action.inputs) === null || _action$inputs === void 0 ? void 0 : (_action$inputs$fieldK = _action$inputs[fieldKey]) === null || _action$inputs$fieldK === void 0 ? void 0 : _action$inputs$fieldK.fetchAction;
          return {
            ...acc,
            [action.integrationKey]: {
              ...acc[action.integrationKey],
              [fieldKey]: {
                actionKey: action.actionKey,
                type: action.type,
                ...(fetchAction && {
                  fetchAction: {
                    actionKey: fetchAction.actionKey,
                    type: fetchAction.type,
                    inputs: fetchAction.inputs
                  }
                })
              }
            }
          };
        }, currentActions);
        const permissions = response.permissions.data.reduce((acc, permission) => ({
          ...acc,
          [permission.ari]: {
            ...acc[permission.ari],
            [permission.fieldKey]: {
              isEditable: permission.isEditable
            }
          }
        }), currentPermissions);
        setState({
          actionsByIntegration,
          permissions
        });
        fireEvent('operational.actionDiscovery.success', {
          integrationKey: 'integrationKey' in request ? request.integrationKey : null,
          datasourceId: 'datasourceId' in request ? request.datasourceId : null,
          entityType: request.entityType,
          experience: 'datasource'
        });
      }
    } catch (error) {
      /**
       * captureError was already initialised with integrationKey or datasourceId
       */
      captureError('actionDiscovery', error);
    }
  }
};
export const ActionsStore = createStore({
  name: 'actions-store',
  initialState: getInitialState(),
  actions
});
const useActionStoreActions = createActionsHook(ActionsStore);
export const useDiscoverActions = ({
  captureError,
  fireEvent
}) => {
  const {
    getDatasourceActionsAndPermissions
  } = useDatasourceClientExtension();
  const {
    discoverActions
  } = useActionStoreActions();
  return {
    discoverActions: useMemo(() => discoverActions.bind(null, captureError, fireEvent, {
      getDatasourceActionsAndPermissions
    }), [captureError, discoverActions, fireEvent, getDatasourceActionsAndPermissions])
  };
};
const getFieldUpdateActionByAri = (state, {
  ari,
  fieldKey,
  integrationKey
}) => {
  var _state$permissions$ar, _state$permissions$ar2, _state$actionsByInteg, _state$actionsByInteg2, _state$actionsByInteg3;
  const isEditable = (_state$permissions$ar = state.permissions[ari]) === null || _state$permissions$ar === void 0 ? void 0 : (_state$permissions$ar2 = _state$permissions$ar[fieldKey]) === null || _state$permissions$ar2 === void 0 ? void 0 : _state$permissions$ar2.isEditable;
  if (!isEditable) {
    return {};
  }
  return {
    schema: (_state$actionsByInteg = state.actionsByIntegration[integrationKey]) === null || _state$actionsByInteg === void 0 ? void 0 : _state$actionsByInteg[fieldKey],
    fetchSchema: (_state$actionsByInteg2 = state.actionsByIntegration[integrationKey]) === null || _state$actionsByInteg2 === void 0 ? void 0 : (_state$actionsByInteg3 = _state$actionsByInteg2[fieldKey]) === null || _state$actionsByInteg3 === void 0 ? void 0 : _state$actionsByInteg3.fetchAction
  };
};

/**
 * Retrieves the action schema for a given ARI + fieldKey + integrationKey
 */
export const useAtomicUpdateActionSchema = createHook(ActionsStore, {
  selector: getFieldUpdateActionByAri
});
/**
 * Given an ARI + fieldKey + integrationKey
 * Returns an executable action that updates a field on the entity if the user has permissions to do so
 *
 * @example
 * ```tsx
 * const { execute } = useExecuteAtomicAction({ ari, fieldKey: 'summary', integrationKey: 'jira' });
 *
 * return <button onClick={() => execute('New summary')}>Update summary</button>;
 * ```
 */
export const useExecuteAtomicAction = ({
  ari,
  fieldKey,
  integrationKey
}) => {
  const [{
    schema,
    fetchSchema
  }] = useAtomicUpdateActionSchema({
    ari,
    fieldKey,
    integrationKey
  });
  const item = fg('enable_datasource_fetch_action_inputs') ?
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useDatasourceItem({
    id: ari
  }) : undefined;
  const {
    executeAtomicAction: executeAction,
    invalidateDatasourceDataCacheByAri
  } = useDatasourceClientExtension();
  const loggerProps = useMemo(() => ({
    integrationKey
  }), [integrationKey]);
  const {
    captureError
  } = useErrorLogger(loggerProps);
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();
  const execute = useCallback(value => {
    if (!schema) {
      throw new Error('No action schema found.');
    }
    return executeAction({
      integrationKey,
      actionKey: schema.actionKey,
      parameters: {
        inputs: {
          [fieldKey]: value
        },
        target: {
          ari
        }
      }
    }).then(resp => {
      // Force data to refresh after update
      invalidateDatasourceDataCacheByAri(ari);
      fireEvent('operational.actionExecution.success', {
        integrationKey: integrationKey,
        experience: 'datasource'
      });
      return resp;
    }).catch(error => {
      captureError('actionExecution', error);
      // Rethrow up to component for flags and other handling
      throw error;
    });
  }, [schema, executeAction, integrationKey, fieldKey, ari, invalidateDatasourceDataCacheByAri, fireEvent, captureError]);
  const executeFetch = useCallback(controlledInputs => {
    if (!fetchSchema) {
      throw new Error('No supporting action schema found.');
    }

    /**
     * controlled inputs are useful for search fields, where a variable query is passed to the fetchAction
     */
    let inputs = controlledInputs;
    /**
     * When FF is on and `controlledInputs` are not provided we look for required inputs in the fetchSchema
     */
    if (!Object.keys(inputs).length && fetchSchema.inputs && !!Object.keys(fetchSchema.inputs).length && fg('enable_datasource_fetch_action_inputs')) {
      const inputKeys = Object.keys(fetchSchema.inputs);
      /**
       * If present return the input value from the datasource item
       * e.g. this could be the issueKey or projectId of a Jira issue
       */
      inputs = inputKeys.reduce((acc, key) => {
        var _item$data, _item$data$key;
        const value = item === null || item === void 0 ? void 0 : (_item$data = item.data) === null || _item$data === void 0 ? void 0 : (_item$data$key = _item$data[key]) === null || _item$data$key === void 0 ? void 0 : _item$data$key.data;
        if (typeof value === 'string' || typeof value === 'number') {
          acc[key] = value;
        }
        /**
         * This allows for the schema and data from the BE to dynamically set the action inputs
         */
        return acc;
      }, {});
    }

    // A generic type can allow us here to define the inputs and outputs
    return executeAction({
      integrationKey,
      actionKey: fetchSchema.actionKey,
      parameters: {
        inputs,
        target: {
          ari
        }
      }
    }).then(resp => {
      fireEvent('operational.fetchActionExecution.success', {
        integrationKey: integrationKey,
        experience: 'datasource'
      });
      return resp;
    }).catch(error => {
      captureError('fetchActionExecution', error);
      // Rethrow up to component for flags and other handling
      throw error;
    });
  }, [fetchSchema, executeAction, integrationKey, ari, item, fireEvent, captureError]);
  return {
    ...(schema && {
      execute
    }),
    ...(fetchSchema && {
      executeFetch
    })
  };
};