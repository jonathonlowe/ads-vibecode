/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import "./index.compiled.css";
import { forwardRef } from 'react';
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
/* eslint-disable @atlaskit/design-system/use-tokens-typography */

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import debounce from 'lodash/debounce';
import invariant from 'tiny-invariant';
import { FlagsProvider } from '@atlaskit/flag';
import { Skeleton } from '@atlaskit/linking-common';
import { fg } from '@atlaskit/platform-feature-flags';
import { extractClosestEdge } from '@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge';
import { reorderWithEdge } from '@atlaskit/pragmatic-drag-and-drop-hitbox/util/reorder-with-edge';
import { autoScroller } from '@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll';
import { combine } from '@atlaskit/pragmatic-drag-and-drop/combine';
import { monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { Box } from '@atlaskit/primitives/compiled';
import { N40 } from '@atlaskit/theme/colors';
import { fontFallback } from '@atlaskit/theme/typography';
import Tooltip from '@atlaskit/tooltip';
import { WidthObserver } from '@atlaskit/width-detector';
import { startUfoExperience, succeedUfoExperience } from '../../analytics/ufoExperiences';
import { useDatasourceExperienceId } from '../../contexts/datasource-experience-id';
import { ColumnPicker } from './column-picker';
import { DragColumnPreview } from './drag-column-preview';
import { DraggableTableHeading } from './draggable-table-heading';
import TableEmptyState from './empty-state';
import { renderType } from './render-type';
import { TableCellContent } from './table-cell-content';
import { useIsOnScreen } from './useIsOnScreen';
import { COLUMN_BASE_WIDTH, getFieldLabelById, getWidthCss } from './utils';
const tableSidePadding = "var(--ds-space-200, 16px)";
const tableHeadStyles = null;
const columnPickerWidth = 80;
// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled -- To migrate as part of go/ui-styling-standard
const ColumnPickerHeader = forwardRef(({
  as: C = "th",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_1bqmidpf _2eacidpf _1rmlidpf _13xs13hi _19xw13hi _ex0g13hi _1rag1on0 _1ul51on0 _12ch1on0 _12ruusvi _1pmsusvi _7okwusvi _mgulys9h _2k51ys9h _efqoys9h _1xzrzo7u _1ejpzo7u _1fmczo7u _77i31if8 _zjk41if8 _7s0n1if8 _3t471vc6 _9g2k1vc6 _1h0z1vc6 _1o59pxbi _1l3vpxbi _gdprpxbi _ml92nkob _1nfwnkob _11ljnkob _1ixkusic _s1peusic _mowjusic", __cmplp.className])
  }));
});
if (process.env.NODE_ENV !== 'production') {
  ColumnPickerHeader.displayName = 'ColumnPickerHeader';
}
const truncateStyles = null;
const tableContainerStyles = null;

// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled
const Table = forwardRef(({
  as: C = "table",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_1bsb1osq", __cmplp.className])
  }));
});

// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled
if (process.env.NODE_ENV !== 'production') {
  Table.displayName = 'Table';
}
const TableHeading = forwardRef(({
  as: C = "th",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_19itidpf _aks5idpf _1u3bidpf _1s7zl0fh _1o9ml0fh _1oupl0fh _n7zl1on0 _1fqk1on0 _1vvv1on0 _kqswh2mm _rc4eh2mm _q46wh2mm _vchhusvi _1wwnusvi _1gbausvi _vwz41tcg _s99e1tcg _3mvc1tcg _ca0qv77o _7cz2v77o _pcwyv77o _u5f31b66 _1pmc1b66 _11ep1b66 _n3tdv77o _6dd7v77o _191qv77o _19bv1b66 _9iya1b66 _15hu1b66 _4t3iqagn _qccgqagn _xo89qagn _s7n4yfq0 _ntwryfq0 _3eneyfq0 _bfhkchd4 _i7olchd4 _1oe6chd4 _12pn15vq _198v15vq _lura1osq _11681tcg _ab8av77o _11j11b66 _1xanv77o _8lvj1b66 _iscccj1k _1nd0cs5v _1t0u1e54 _1eqz4jg8 _95ex1hna _1hkzidpf _1r3pidpf _10i2idpf _1ls2idpf _ocbzidpf _3tfiidpf _1lhc1b66 _n2z81b66 _3ixo1b66", __cmplp.className])
  }));
});

// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled
if (process.env.NODE_ENV !== 'production') {
  TableHeading.displayName = 'TableHeading';
}
const InlineEditableTableCell = forwardRef(({
  as: C = "td",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_11c82smr _1otx2smr _1wi12smr _19itidpf _1i5zidpf _aifmidpf _1s7z1x13 _1xqp1x13 _mxou1x13 _n7zl1x13 _15lr1x13 _itmm1x13 _ca0qze3t _7jflze3t _1ikkze3t _u5f3ze3t _1cngze3t _1h12ze3t _n3tdze3t _v6nkze3t _jivqze3t _19bvze3t _krvdze3t _1w1yze3t _1ul91wug _1lkc1wug _1jcm1wug _4t3i1ylp _1ugg1ylp _lt6w1ylp _s7n41kw7 _11nx1kw7 _18a21kw7 _vchh1ntv _16601ntv _1qd91ntv _1ls2idpf _1ho1idpf _1y4pidpf _1cimn7od _124in7od", __cmplp.className])
  }));
});

/**
 * Following section deals with slight gradient shadows that we add
 * on all four sides when there is more content in that direction.
 *
 * We do that by applying two gradients to the background -
 * one is "static" ('local') and other is "sticky" ('scroll'). \
 * "Static" one makes a white color gradient, that when window is at the end of scrollable area goes on top
 * of "sticky" (gray) one, dominating and hence disabling sticky one.
 */
if (process.env.NODE_ENV !== 'production') {
  InlineEditableTableCell.displayName = 'InlineEditableTableCell';
}
const scrollableContainerStyles = null;
const tableStyles = null;

// By default tbody and thead have border-bottom: 2px ...
// This removes it, because for header we handle it via `th` styling and footer supply bottom border
const noDefaultBorderStyles = null;
const headerStyles = null;
const headingHoverEffectStyles = null;
function extractIndex(data) {
  const {
    index
  } = data;
  invariant(typeof index === 'number');
  return index;
}
const sortColumns = (firstOption, secondOption) => {
  return firstOption.title.localeCompare(secondOption.title);
};
export const getOrderedColumns = (columns, visibleColumnKeys) => {
  const visibleColumns = columns.filter(column => visibleColumnKeys.includes(column.key)).sort((a, b) => {
    const indexB = visibleColumnKeys.indexOf(b.key);
    const indexA = visibleColumnKeys.indexOf(a.key);
    return indexA - indexB;
  });
  const alphabeticallySortedInvisibleColumns = columns.filter(column => !visibleColumnKeys.includes(column.key)).sort(sortColumns);
  return [...visibleColumns, ...alphabeticallySortedInvisibleColumns];
};
const DEFAULT_WIDTH = COLUMN_BASE_WIDTH * 22;
const keyBasedWidthMap = {
  priority: COLUMN_BASE_WIDTH * 12.5,
  // 100px
  status: COLUMN_BASE_WIDTH * 12.5,
  summary: COLUMN_BASE_WIDTH * 45,
  description: COLUMN_BASE_WIDTH * 31,
  type: COLUMN_BASE_WIDTH * 6,
  key: COLUMN_BASE_WIDTH * 15
};
function getDefaultColumnWidth(key, type) {
  const keyBasedWidth = keyBasedWidthMap[key];
  if (keyBasedWidth) {
    return keyBasedWidth;
  }
  switch (type) {
    case 'date':
      return COLUMN_BASE_WIDTH * 16;
    case 'icon':
      return COLUMN_BASE_WIDTH * 7;
    default:
      return DEFAULT_WIDTH;
  }
}
export const IssueLikeDataTableView = ({
  testId,
  onNextPage,
  onLoadDatasourceDetails,
  items,
  itemIds,
  columns,
  renderItem = renderType,
  visibleColumnKeys,
  onVisibleColumnKeysChange,
  columnCustomSizes,
  onColumnResize,
  wrappedColumnKeys,
  onWrappedColumnChange,
  status,
  hasNextPage,
  scrollableContainerHeight,
  extensionKey
}) => {
  var _containerRef$current;
  const tableId = useMemo(() => Symbol('unique-id'), []);
  const experienceId = useDatasourceExperienceId();
  const tableHeaderRowRef = useRef(null);
  const [lastRowElement, setLastRowElement] = useState(null);
  const [hasFullSchema, setHasFullSchema] = useState(false);
  const isBottomOfTableVisibleRaw = useIsOnScreen(lastRowElement);
  const containerRef = useRef(null);
  const [orderedColumns, setOrderedColumns] = useState(() => getOrderedColumns([...columns], [...visibleColumnKeys]));
  const isJumpingColumnFixEnabled = fg('enable_fix_datasource_jumping_columns');

  // Table container width is used to know if sum of all column widths is bigger of container or not.
  // When sum of all columns is less than container size we make last column stretchable (width: undefined)
  const [tableContainerWidthOld, setTableContainerWidthOld] = useState();
  useEffect(() => {
    const {
      current
    } = containerRef;
    if (!isJumpingColumnFixEnabled) {
      if (containerRef && current) {
        setTableContainerWidthOld(current.getBoundingClientRect().width);
      }
    }
  }, [containerRef, isJumpingColumnFixEnabled]);
  useEffect(() => {
    if (orderedColumns.length !== columns.length) {
      setOrderedColumns(getOrderedColumns([...columns], [...visibleColumnKeys]));
    }
  }, [columns, visibleColumnKeys, orderedColumns]);
  useEffect(() => {
    if (experienceId && status === 'resolved') {
      succeedUfoExperience({
        name: 'datasource-rendered'
      }, experienceId);
    }
  }, [experienceId, status]);
  const visibleSortedColumns = useMemo(() => visibleColumnKeys.map(visibleKey => orderedColumns.find(({
    key
  }) => visibleKey === key)).filter(Boolean), [orderedColumns, visibleColumnKeys]);

  // TODO seems like this component can't handle some combination of incremental data retrieval.
  // If data comes first, then columns and then visibleColumnKeys it blows up,
  // or some other combination.
  const columnsWidthsSum = useMemo(() => visibleSortedColumns.map(({
    key,
    type
  }) => (columnCustomSizes === null || columnCustomSizes === void 0 ? void 0 : columnCustomSizes[key]) || getDefaultColumnWidth(key, type)).reduce((sum, width) => width + sum, 0) + (onVisibleColumnKeysChange ? columnPickerWidth : 0), [columnCustomSizes, onVisibleColumnKeysChange, visibleSortedColumns]);
  const shouldUseWidth = !!(onColumnResize || columnCustomSizes);
  const getColumnWidthOld = useCallback((key, type, isLastCell) => {
    if (isLastCell && shouldUseWidth && (!tableContainerWidthOld || tableContainerWidthOld > columnsWidthsSum)) {
      return undefined;
    } else {
      return (columnCustomSizes === null || columnCustomSizes === void 0 ? void 0 : columnCustomSizes[key]) || getDefaultColumnWidth(key, type);
    }
  }, [columnCustomSizes, columnsWidthsSum, shouldUseWidth, tableContainerWidthOld]);
  const tableContainerWidth = isJumpingColumnFixEnabled ? Math.ceil(((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect().width) || 0) : 0;
  const getColumnWidth = useCallback((key, type, isLastCell) => {
    if (isLastCell && shouldUseWidth && tableContainerWidth && tableContainerWidth > columnsWidthsSum) {
      return undefined;
    } else {
      return (columnCustomSizes === null || columnCustomSizes === void 0 ? void 0 : columnCustomSizes[key]) || getDefaultColumnWidth(key, type);
    }
  }, [columnCustomSizes, columnsWidthsSum, shouldUseWidth, tableContainerWidth]);
  const headerColumns = useMemo(() => visibleSortedColumns.map(({
    key,
    title,
    type
  }, index) => ({
    key,
    content: title,
    shouldTruncate: true,
    width: isJumpingColumnFixEnabled ? getColumnWidth(key, type, index === visibleSortedColumns.length - 1) : getColumnWidthOld(key, type, index === visibleSortedColumns.length - 1)
  })), [getColumnWidth, getColumnWidthOld, isJumpingColumnFixEnabled, visibleSortedColumns]);
  const loadingRow = useMemo(() => ({
    key: 'loading',
    cells: headerColumns.map(column => ({
      content: /*#__PURE__*/React.createElement(Box, {
        paddingInline: "space.100"
      }, /*#__PURE__*/React.createElement(Skeleton, {
        borderRadius: 8,
        width: "100%",
        height: 14,
        testId: "issues-table-row-loading"
      })),
      key: column.key
    }))
  }), [headerColumns]);
  useEffect(() => {
    if (isBottomOfTableVisibleRaw && hasNextPage && status === 'resolved') {
      void onNextPage({
        isSchemaFromData: false,
        shouldForceRequest: true
      });
    }
  }, [isBottomOfTableVisibleRaw, status, hasNextPage, onNextPage]);
  const hasData = items.length > 0;

  // This variable contains initial Y mouse coordinate, so we can restrict
  // autoScroller in X axis only
  const initialAutoScrollerClientY = useRef();
  useEffect(() => {
    if (!onVisibleColumnKeysChange || !hasData) {
      return;
    }
    return combine(monitorForElements({
      onDragStart: ({
        location,
        source
      }) => {
        initialAutoScrollerClientY.current = location.current.input.clientY;
        if (source.data.type === 'table-header') {
          var _containerRef$current2;
          autoScroller.start({
            input: {
              ...location.current.input,
              clientY:
              // The goal is to have clientY the same and in the middle of the scrollable area
              // Since clientY is taken from to of the viewport we need to plus that in order to get
              // middle of the scrollable area in reference to the viewport
              (initialAutoScrollerClientY.current || 0) + (((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.offsetHeight) || 0) / 2
            },
            behavior: 'container-only'
          });
        }
      },
      onDrag: ({
        location,
        source
      }) => {
        if (source.data.type === 'table-header') {
          var _containerRef$current3;
          autoScroller.updateInput({
            input: {
              ...location.current.input,
              clientY: (initialAutoScrollerClientY.current || 0) + (((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.offsetHeight) || 0) / 2
            }
          });
        }
      },
      onDrop({
        source,
        location
      }) {
        autoScroller.stop();
        if (location.current.dropTargets.length === 0) {
          return;
        }
        const target = location.current.dropTargets[0];
        if (source.data.id === target.data.id) {
          return;
        }
        if (source.data.type === 'table-header' && source.data.tableId === tableId) {
          const closestEdgeOfTarget = extractClosestEdge(target.data);
          invariant(closestEdgeOfTarget === 'left' || closestEdgeOfTarget === 'right');
          const startIndex = extractIndex(source.data);
          const indexOfTarget = extractIndex(target.data);
          const newColumnKeyOrder = reorderWithEdge({
            list: visibleColumnKeys,
            closestEdgeOfTarget,
            startIndex,
            indexOfTarget,
            axis: 'horizontal'
          });
          onVisibleColumnKeysChange === null || onVisibleColumnKeysChange === void 0 ? void 0 : onVisibleColumnKeysChange([...newColumnKeyOrder]);

          // We sort columns (whole objects) according to their key order presented in newColumnKeyOrder
          setOrderedColumns(columns => getOrderedColumns([...columns], [...newColumnKeyOrder]));
        }
      }
    }));
  }, [visibleColumnKeys, onVisibleColumnKeysChange, tableId, hasData]);
  const tableRows = useMemo(() => itemIds.map((id, rowIndex) => {
    return {
      key: id,
      cells: visibleSortedColumns.map(({
        key,
        type,
        title
      }, cellIndex) => {
        return {
          key,
          columnKey: key,
          // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
          content: /*#__PURE__*/React.createElement(TableCellContent, {
            id: id,
            columnKey: key,
            columnType: type,
            columnTitle: title,
            wrappedColumnKeys: wrappedColumnKeys,
            renderItem: renderItem
          }),
          width: isJumpingColumnFixEnabled ? getColumnWidth(key, type, cellIndex === visibleSortedColumns.length - 1) : getColumnWidthOld(key, type, cellIndex === visibleSortedColumns.length - 1)
        };
      }),
      ref: rowIndex === items.length - 1 ? el => setLastRowElement(el) : undefined
    };
  }), [items, itemIds, renderItem, wrappedColumnKeys, visibleSortedColumns, getColumnWidth, getColumnWidthOld, isJumpingColumnFixEnabled]);
  const rows = useMemo(() => {
    if (status !== 'loading') {
      return tableRows;
    }
    // if there are table rows, only add 1 loading row
    if (tableRows.length > 0) {
      return [...tableRows, {
        ...loadingRow,
        key: `loading-${tableRows.length}`
      }];
    }
    // if there are no table rows add 14 rows if it is compact (has scrollableContainerHeight or non-modal)
    // add 10 rows if it is modal (no scrollableContainerHeight)
    const loadingRowsCount = scrollableContainerHeight ? 14 : 10;
    return [...Array(loadingRowsCount)].map((_, index) => ({
      ...loadingRow,
      key: `loading-${index}`
    }));
  }, [loadingRow, status, tableRows, scrollableContainerHeight]);
  const onSelectedColumnKeysChange = useCallback(newSelectedColumnKeys => {
    onVisibleColumnKeysChange === null || onVisibleColumnKeysChange === void 0 ? void 0 : onVisibleColumnKeysChange(newSelectedColumnKeys);
  }, [onVisibleColumnKeysChange]);
  const handlePickerOpen = useCallback(async () => {
    if (hasFullSchema) {
      return;
    }
    if (experienceId) {
      startUfoExperience({
        name: 'column-picker-rendered',
        metadata: {
          extensionKey: extensionKey !== null && extensionKey !== void 0 ? extensionKey : undefined
        }
      }, experienceId);
    }
    try {
      await onLoadDatasourceDetails();
      setHasFullSchema(true);
    } catch (e) {
      setHasFullSchema(false);
    }
  }, [experienceId, extensionKey, hasFullSchema, onLoadDatasourceDetails]);
  const isEditable = onVisibleColumnKeysChange && hasData;
  const orderedColumnsAreUpToDate = orderedColumns.length === columns.length;
  const shouldDisplayColumnsInPicker = hasFullSchema && orderedColumnsAreUpToDate;
  const view = /*#__PURE__*/React.createElement("div", {
    /* There is required contentEditable={true} in editor-card-plugin
     * But this brakes how DND works. We set contentEditable={false} to allow DND to work
     * when dragging is initiated on top of a column label.
     */
    contentEditable: false,
    ref: containerRef,
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    style: scrollableContainerHeight ? {
      maxHeight: `${scrollableContainerHeight}px`
    } : undefined,
    "data-testid": 'issue-like-table-container',
    className: ax(["_mrkbidpf _1o0zidpf _kqswh2mm", scrollableContainerHeight && "_1reo1wug _18m91wug _vchhusvi _bfhkchd4 _1itk1sfv _ouxlbac2 _12vemgnk _1lrw1sd4 _qmxj1c00"])
  }, !isJumpingColumnFixEnabled && /*#__PURE__*/React.createElement(WidthObserver, {
    setWidth: debounce(setTableContainerWidthOld, 100)
  }), /*#__PURE__*/React.createElement(Table, {
    "data-testid": testId
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: shouldUseWidth ? {
      tableLayout: 'fixed'
    } : {},
    className: ax(["_19pkidpf _2hwxidpf _otyridpf _18u0idpf _yq5hus1c _btyzidpf"])
  }, /*#__PURE__*/React.createElement("thead", {
    "data-testid": testId && `${testId}--head`,
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    className: ax(["_n7zlidpf", "_bfhkchd4 _kqsw1if8 _154iidpf _1pbyzo7u", !!onVisibleColumnKeysChange ? 'has-column-picker' : ''])
  }, /*#__PURE__*/React.createElement("tr", {
    ref: tableHeaderRowRef
  }, headerColumns.map(({
    key,
    content,
    width
  }, cellIndex) => {
    let heading = /*#__PURE__*/React.createElement(Tooltip, {
      content: content,
      tag: "span",
      position: "bottom-start",
      testId: 'datasource-header-content'
    }, /*#__PURE__*/React.createElement("span", {
      id: getFieldLabelById(key),
      className: ax(["_11c8dcr7 _k48p1wq8"])
    }, content));
    const isHeadingOutsideButton = !isEditable || !onWrappedColumnChange;
    if (isHeadingOutsideButton) {
      heading = /*#__PURE__*/React.createElement("div", {
        className: ax(["_1e0c1txw _4cvr1h6o _o5721q9c _8vu416jk _irr31d5g"])
      }, heading);
    }
    if (isEditable) {
      var _containerRef$current4;
      const previewRows = tableRows.map(({
        cells
      }) => {
        const cell = cells.find(({
          key: cellKey
        }) => cellKey === key);
        if (cell) {
          return cell.content;
        }
      }).slice(0, 5);
      const dragPreview = /*#__PURE__*/React.createElement(DragColumnPreview, {
        title: heading,
        rows: previewRows
      });
      return /*#__PURE__*/React.createElement(DraggableTableHeading, {
        tableId: tableId,
        key: key,
        id: key,
        index: cellIndex,
        width: width,
        onWidthChange: onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize.bind(null, key),
        dndPreviewHeight: ((_containerRef$current4 = containerRef.current) === null || _containerRef$current4 === void 0 ? void 0 : _containerRef$current4.offsetHeight) || 0,
        dragPreview: dragPreview,
        isWrapped: wrappedColumnKeys === null || wrappedColumnKeys === void 0 ? void 0 : wrappedColumnKeys.includes(key),
        onIsWrappedChange: onWrappedColumnChange === null || onWrappedColumnChange === void 0 ? void 0 : onWrappedColumnChange.bind(null, key)
      }, heading);
    } else {
      return /*#__PURE__*/React.createElement(TableHeading, {
        key: key,
        "data-testid": `${key}-column-heading`
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
        ,
        style: getWidthCss({
          shouldUseWidth,
          width
        })
      }, heading);
    }
  }), onVisibleColumnKeysChange && /*#__PURE__*/React.createElement(ColumnPickerHeader, null, /*#__PURE__*/React.createElement(ColumnPicker, {
    columns: shouldDisplayColumnsInPicker ? orderedColumns : [],
    selectedColumnKeys: shouldDisplayColumnsInPicker ? visibleColumnKeys : [],
    onSelectedColumnKeysChange: onSelectedColumnKeysChange,
    onOpen: handlePickerOpen
  })))), /*#__PURE__*/React.createElement("tbody", {
    "data-testid": testId && `${testId}--body`,
    className: ax(["_n7zlidpf"])
  }, rows.map(({
    key,
    cells,
    ref
  }) => /*#__PURE__*/React.createElement("tr", {
    key: key,
    "data-testid": testId && `${testId}--row-${key}`,
    ref: ref
  }, cells.map(({
    key: cellKey,
    content,
    width
  }, cellIndex) => {
    const isLastCell = cellIndex === cells.length - 1;
    let loadingRowStyle = getWidthCss({
      shouldUseWidth,
      width
    });
    return /*#__PURE__*/React.createElement(InlineEditableTableCell, {
      key: cellKey,
      "data-testid": testId && `${testId}--cell-${cellIndex}`,
      colSpan: isEditable && isLastCell ? 2 : undefined
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      ,
      style: loadingRowStyle,
      className: ax([!(wrappedColumnKeys !== null && wrappedColumnKeys !== void 0 && wrappedColumnKeys.includes(cellKey)) && "_1bto1l2s _o5721q9c"])
    }, content);
  }))))));
  return /*#__PURE__*/React.createElement(FlagsProvider, null, view);
};
export const EmptyState = TableEmptyState;