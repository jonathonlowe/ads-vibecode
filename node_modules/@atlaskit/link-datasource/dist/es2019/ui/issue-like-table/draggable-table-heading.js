/* draggable-table-heading.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import "./draggable-table-heading.compiled.css";
import { forwardRef } from 'react';
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
/* eslint-disable @atlaskit/design-system/use-tokens-typography */

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import ReactDOM from 'react-dom';
import { FormattedMessage } from 'react-intl-next';
import invariant from 'tiny-invariant';
import Button from '@atlaskit/button/new';
import DropdownMenu, { DropdownItem } from '@atlaskit/dropdown-menu';
import ChevronDown from '@atlaskit/icon/utility/migration/chevron-down';
import ChevronUp from '@atlaskit/icon/utility/migration/chevron-up';
import { attachClosestEdge, extractClosestEdge } from '@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge';
import { DropIndicator } from '@atlaskit/pragmatic-drag-and-drop-react-drop-indicator/box';
import { combine } from '@atlaskit/pragmatic-drag-and-drop/combine';
import { draggable, dropTargetForElements, monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { disableNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/disable-native-drag-preview';
import { pointerOutsideOfPreview } from '@atlaskit/pragmatic-drag-and-drop/element/pointer-outside-of-preview';
import { setCustomNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview';
import { preventUnhandled } from '@atlaskit/pragmatic-drag-and-drop/prevent-unhandled';
import { N40 } from '@atlaskit/theme/colors';
import { useDatasourceAnalyticsEvents } from '../../analytics';
import { GlyphPlaceholder, UnwrapTextIcon, WrapTextIcon } from './custom-icons';
import { issueLikeTableMessages } from './messages';
import { getColumnMinWidth, getWidthCss } from './utils';

// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled
const TableHeading = forwardRef(({
  as: C = "th",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_19itidpf _aks5idpf _1u3bidpf _1s7zl0fh _1o9ml0fh _1oupl0fh _n7zl1on0 _1fqk1on0 _1vvv1on0 _kqswh2mm _rc4eh2mm _q46wh2mm _vchhusvi _1wwnusvi _1gbausvi _vwz41tcg _s99e1tcg _3mvc1tcg _ca0qv77o _7cz2v77o _pcwyv77o _u5f31b66 _1pmc1b66 _11ep1b66 _n3tdv77o _6dd7v77o _191qv77o _19bv1b66 _9iya1b66 _15hu1b66 _4t3iqagn _qccgqagn _xo89qagn _s7n4yfq0 _ntwryfq0 _3eneyfq0 _bfhkchd4 _i7olchd4 _1oe6chd4 _12pn15vq _198v15vq _lura1osq _11681tcg _ab8av77o _11j11b66 _1xanv77o _8lvj1b66 _iscccj1k _1nd0cs5v _1t0u1e54 _1eqz4jg8 _95ex1hna _1hkzidpf _1r3pidpf _10i2idpf _1ls2idpf _ocbzidpf _3tfiidpf _1lhc1b66 _n2z81b66 _3ixo1b66", __cmplp.className])
  }));
});
if (process.env.NODE_ENV !== 'production') {
  TableHeading.displayName = 'TableHeading';
}
// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled -- To migrate as part of go/ui-styling-standard
const DropdownParent = forwardRef(({
  as: C = "div",
  style: __cmpls,
  ...__cmplp
}, __cmplr) => {
  return /*#__PURE__*/React.createElement(C, _extends({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: ax(["_1e0c1txw _4cvr1h6o _o5721q9c _1wtnze3t _ficf1e5h _jq8g1wug _11lvze3t _yhjmze3t", __cmplp.className])
  }));
});
if (process.env.NODE_ENV !== 'production') {
  DropdownParent.displayName = 'DropdownParent';
}
const dropTargetStyles = null;
const noPointerEventsStyles = null;
const resizerStyles = null;
const resizingStyles = null;
const idleState = {
  type: 'idle'
};
const draggingState = {
  type: 'dragging'
};
export const DraggableTableHeading = ({
  children,
  id,
  index,
  tableId,
  dndPreviewHeight,
  dragPreview,
  width,
  onWidthChange,
  isWrapped,
  onIsWrappedChange
}) => {
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();
  const mainHeaderCellRef = useRef(null);
  const columnResizeHandleRef = useRef(null);
  const [state, setState] = useState(idleState);
  const [isDraggingAnyColumn, setIsDraggingAnyColumn] = useState(false);
  const [closestEdge, setClosestEdge] = useState(null);
  const dropTargetRef = useRef(null);
  /**
   * When width is not set (or callback is not set) we assume not resizing is needed.
   * In our case width won't be set for last cell when table container is bigger than sum of all columns
   */
  const resizeIsEnabled = !!onWidthChange && !!width;
  useEffect(() => {
    const cell = mainHeaderCellRef.current;
    invariant(cell);
    return combine(draggable({
      element: cell,
      getInitialData() {
        return {
          type: 'table-header',
          id,
          index,
          tableId
        };
      },
      onGenerateDragPreview({
        nativeSetDragImage
      }) {
        setCustomNativeDragPreview({
          getOffset: pointerOutsideOfPreview({
            x: '18px',
            y: '18px'
          }),
          render: ({
            container
          }) => {
            // Cause a `react` re-render to create your portal synchronously
            setState({
              type: 'preview',
              container
            });
            // In our cleanup function: cause a `react` re-render to create remove your portal
            // Note: you can also remove the portal in `onDragStart`,
            // which is when the cleanup function is called
            return () => setState(draggingState);
          },
          nativeSetDragImage
        });
      },
      onDragStart() {
        setState(draggingState);
      },
      onDrop() {
        setState(idleState);
      }
    }));
  }, [id, index, tableId]);

  // Here we handle drop target, that in our case is absolutely positioned div that covers full width and height
  // of this column (has height of whole table). It sits on top of everything, but has `pointerEvents: 'none'` by default
  useEffect(() => {
    const dropTarget = dropTargetRef.current;
    invariant(dropTarget);
    return dropTargetForElements({
      element: dropTarget,
      getIsSticky() {
        return true;
      },
      getData({
        input,
        element
      }) {
        const data = {
          id,
          index
        };
        return attachClosestEdge(data, {
          input,
          element,
          allowedEdges: ['left', 'right']
        });
      },
      canDrop(args) {
        return args.source.data.type === 'table-header' && args.source.data.tableId === tableId;
      },
      onDrag(args) {
        if (args.source.data.id !== id) {
          setClosestEdge(extractClosestEdge(args.self.data));
        }
      },
      onDragLeave() {
        setClosestEdge(null);
      },
      onDrop() {
        setClosestEdge(null);
      }
    });
  }, [id, index, tableId]);

  // During dragging anywhere we want to remove `pointerEvents: 'none'` from all the drop targets
  useEffect(() => {
    return monitorForElements({
      canMonitor({
        source
      }) {
        return source.data.type === 'table-header' && source.data.tableId === tableId;
      },
      onDragStart() {
        /**
         * Should cause a synchronous re-render.
         */
        setIsDraggingAnyColumn(true);
      },
      onDrop() {
        setIsDraggingAnyColumn(false);
      }
    });
  }, [tableId]);

  // Handling column resizing
  useEffect(() => {
    if (!resizeIsEnabled) {
      return;
    }
    const resizeHandle = columnResizeHandleRef.current;
    invariant(resizeHandle);
    const mainHeaderCell = mainHeaderCellRef.current;
    invariant(mainHeaderCell);
    return draggable({
      element: resizeHandle,
      getInitialData() {
        // metadata related to currently dragging item (can be read by drop events etc)
        return {
          type: 'column-resize',
          id,
          index,
          tableId
        };
      },
      // Is called when dragging started
      onGenerateDragPreview({
        nativeSetDragImage
      }) {
        // We don't show any preview, since column separator (handle) is moving with the cursor
        disableNativeDragPreview({
          nativeSetDragImage
        });
        // Block drag operations outside `@atlaskit/pragmatic-drag-and-drop`
        preventUnhandled.start();
        setState({
          type: 'resizing',
          initialWidth: width
        });
      },
      onDrag({
        location
      }) {
        const relativeDistanceX = location.current.input.clientX - location.initial.input.clientX;
        invariant(state.type === 'resizing');
        const {
          initialWidth
        } = state;

        // Set the width of our header being resized
        let proposedWidth = initialWidth + relativeDistanceX;
        if (proposedWidth < getColumnMinWidth(id)) {
          proposedWidth = getColumnMinWidth(id);
        }

        // We update width css directly live
        mainHeaderCell.style.setProperty('width', `${proposedWidth}px`);
      },
      onDrop() {
        preventUnhandled.stop();
        setState(idleState);
        if (onWidthChange) {
          let cssWidth = +mainHeaderCell.style.getPropertyValue('width').slice(0, -2);
          onWidthChange(cssWidth);
        }
      }
    });
  }, [id, index, onWidthChange, resizeIsEnabled, state, tableId, width]);
  const [buttonHovered, setButtonHovered] = useState(false);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  // Width is not set when it is a last cell in a wide table.
  // We make assumption thus that there is enough width for chevron.
  const isWideEnoughToHaveChevron = !width || width > 76;
  const shouldShowTriggerIcon = (buttonHovered || isDropdownOpen) && isWideEnoughToHaveChevron;
  const triggerIcon = useMemo(() => shouldShowTriggerIcon ? isDropdownOpen ? ChevronUp : ChevronDown : isWideEnoughToHaveChevron ? GlyphPlaceholder : undefined, [shouldShowTriggerIcon, isDropdownOpen, isWideEnoughToHaveChevron]);
  const getTriggerButton = useCallback(({
    triggerRef,
    ...props
  }) => {
    return /*#__PURE__*/React.createElement(Button, _extends({}, props, {
      testId: `${id}-column-dropdown`,
      shouldFitContainer: true,
      iconAfter: triggerIcon,
      ref: triggerRef,
      appearance: "subtle",
      spacing: "compact",
      onMouseEnter: () => setButtonHovered(true),
      onMouseLeave: () => setButtonHovered(false)
    }), children);
  }, [children, id, triggerIcon]);
  const onDropdownOpenChange = useCallback(({
    isOpen
  }) => setIsDropdownOpen(isOpen), []);
  const toggleWrap = useCallback(() => {
    if (!onIsWrappedChange) {
      return;
    }
    const nextIsWrap = !(isWrapped || false);
    if (nextIsWrap) {
      fireEvent('ui.button.clicked.wrap', {});
    } else {
      fireEvent('ui.button.clicked.unwrap', {});
    }
    onIsWrappedChange(nextIsWrap);
  }, [fireEvent, isWrapped, onIsWrappedChange]);
  return /*#__PURE__*/React.createElement(TableHeading, {
    ref: mainHeaderCellRef,
    "data-testid": `${id}-column-heading`,
    style: {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      cursor: 'grab',
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      ...getWidthCss({
        shouldUseWidth: resizeIsEnabled,
        width
      })
    }
  }, resizeIsEnabled ? /*#__PURE__*/React.createElement("div", {
    ref: columnResizeHandleRef,
    style: {
      height: `${dndPreviewHeight}px`
    },
    "data-testid": "column-resize-handle",
    className: ax(["_1y7c1ejb _1bsbaakz _80om11mm _16jlidpf _kqswstnw _1pbykb7n _1xi2aesa _154iidpf _1tesidpf _pdyk1hrg _154pidpf _dydkssc3 _1kt9b3bt _1cs8stnw _1rusopvu _1mp4atg7 _qneczvxw _1ct3kb7n", state.type === 'resizing' && "_80omn7od _154pkb7n"])
  }) : null, onIsWrappedChange ? /*#__PURE__*/React.createElement(DropdownParent, null, /*#__PURE__*/React.createElement(DropdownMenu, {
    trigger: getTriggerButton,
    onOpenChange: onDropdownOpenChange,
    placement: 'bottom'
  }, /*#__PURE__*/React.createElement(DropdownItem, {
    elemBefore: isWrapped ? /*#__PURE__*/React.createElement(UnwrapTextIcon, null) : /*#__PURE__*/React.createElement(WrapTextIcon, null),
    testId: `${id}-column-dropdown-item-toggle-wrapping`,
    onClick: toggleWrap
  }, isWrapped ? /*#__PURE__*/React.createElement(FormattedMessage, issueLikeTableMessages.unwrapText) : /*#__PURE__*/React.createElement(FormattedMessage, issueLikeTableMessages.wrapText)))) : children, /*#__PURE__*/React.createElement("div", {
    ref: dropTargetRef,
    style: {
      height: `${dndPreviewHeight}px`
    },
    "data-testid": 'column-drop-target',
    className: ax(["_kqswstnw _154iidpf _1ltvidpf _1bsb1osq", !isDraggingAnyColumn && "_lcxvglyw"])
  }, closestEdge && /*#__PURE__*/React.createElement(DropIndicator, {
    edge: closestEdge
  })), state.type === 'preview' ? /*#__PURE__*/ReactDOM.createPortal(dragPreview, state.container) : null);
};