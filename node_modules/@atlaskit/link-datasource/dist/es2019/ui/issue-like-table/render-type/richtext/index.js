/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./index.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { useMemo } from 'react';
import { defaultSchema } from '@atlaskit/adf-schema/schema-default';
import { Node as PMNode, Schema } from '@atlaskit/editor-prosemirror/model';
const rootStyles = null;
const smartLinkNodeToUrl = node => {
  var _node$attrs$url;
  return (_node$attrs$url = node.attrs.url) !== null && _node$attrs$url !== void 0 ? _node$attrs$url : '';
};
const schemaSmartLinkOverride = new Schema({
  nodes: defaultSchema.spec.nodes.update('inlineCard', {
    ...defaultSchema.spec.nodes.get('inlineCard'),
    leafText: smartLinkNodeToUrl
  }).update('blockCard', {
    ...defaultSchema.spec.nodes.get('blockCard'),
    leafText: smartLinkNodeToUrl
  }).update('embedCard', {
    ...defaultSchema.spec.nodes.get('embedCard'),
    leafText: smartLinkNodeToUrl
  }),
  marks: defaultSchema.spec.marks
});
export const parseRichText = value => {
  try {
    if (value.type === 'adf') {
      const adf = JSON.parse(value.text);
      return PMNode.fromJSON(schemaSmartLinkOverride, {
        ...adf,
        content: [...adf.content.slice(0, 2)]
      }).textContent;
    }
    return null;
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error('error parsing adf', e);
    return null;
  }
};
const RichTextType = ({
  value
}) => {
  const adfPlainText = useMemo(() => parseRichText(value), [value]);
  if (adfPlainText) {
    return /*#__PURE__*/React.createElement("span", {
      "data-testid": "richtext-plaintext",
      className: ax(["_kqswh2mm"])
    }, adfPlainText);
  } else {
    return /*#__PURE__*/React.createElement("span", {
      "data-testid": "richtext-unsupported"
    });
  }
};
export default RichTextType;