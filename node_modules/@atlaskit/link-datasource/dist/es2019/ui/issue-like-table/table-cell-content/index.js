/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./index.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
import React from 'react';
import { useIntl } from 'react-intl-next';
import { Box } from '@atlaskit/primitives/compiled';
import Tooltip from '@atlaskit/tooltip';
import { useDatasourceItem } from '../../../state';
import { useExecuteAtomicAction } from '../../../state/actions';
import { isEditTypeSelectable, isEditTypeSupported } from '../edit-type';
import { stringifyType } from '../render-type';
import { TruncateTextTag } from '../truncate-text-tag';
import { InlineEdit } from './inline-edit';
const styles = {
  readViewStyles: "_1reo15vq _18m915vq _1bto1l2s _1bsb1osq _ae4v1h6o"
};
const TooltipWrapper = ({
  columnKey,
  datasourceTypeWithValues: {
    type,
    values
  },
  wrappedColumnKeys,
  children
}) => {
  const intl = useIntl();
  const stringifiedContent = values.map(value => stringifyType({
    type,
    value
  }, intl.formatMessage, intl.formatDate)).filter(value => value !== '').join(', ');
  if (stringifiedContent && !(wrappedColumnKeys !== null && wrappedColumnKeys !== void 0 && wrappedColumnKeys.includes(columnKey))) {
    return /*#__PURE__*/React.createElement(Tooltip
    // @ts-ignore: [PIT-1685] Fails in post-office due to backwards incompatibility issue with React 18
    , {
      tag: TruncateTextTag,
      content: stringifiedContent,
      testId: "issues-table-cell-tooltip"
    }, children);
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, children);
};
export const ReadOnlyCell = ({
  id,
  columnType,
  wrappedColumnKeys = [],
  renderItem,
  columnKey
}) => {
  var _useDatasourceItem, _rowData$columnKey;
  const rowData = (_useDatasourceItem = useDatasourceItem({
    id
  })) === null || _useDatasourceItem === void 0 ? void 0 : _useDatasourceItem.data;
  if (!rowData || !columnKey || !rowData[columnKey]) {
    return null;
  }

  // Need to make sure we keep falsy values like 0 and '', as well as the boolean false.
  const value = (_rowData$columnKey = rowData[columnKey]) === null || _rowData$columnKey === void 0 ? void 0 : _rowData$columnKey.data;
  const values = Array.isArray(value) ? value : [value];
  const datasourceTypeWithValues = {
    type: columnType,
    values
  };
  return /*#__PURE__*/React.createElement(TooltipWrapper, {
    columnKey: columnKey,
    datasourceTypeWithValues: datasourceTypeWithValues,
    wrappedColumnKeys: wrappedColumnKeys
  }, renderItem(datasourceTypeWithValues));
};
const InlineEditableCell = ({
  ari,
  values,
  columnKey,
  columnTitle,
  renderItem,
  integrationKey,
  wrappedColumnKeys
}) => {
  // Callbacks are returned only when the ari is editable and the action schemas exist in the store
  const {
    execute,
    executeFetch
  } = useExecuteAtomicAction({
    ari,
    fieldKey: columnKey,
    integrationKey
  });

  // A field is editable when `execute` is returned from the store
  const isEditable = !!execute;
  const readView = /*#__PURE__*/React.createElement(TooltipWrapper, {
    columnKey: columnKey,
    datasourceTypeWithValues: values,
    wrappedColumnKeys: wrappedColumnKeys
  }, /*#__PURE__*/React.createElement(Box, {
    testId: "inline-edit-read-view",
    paddingInline: isEditable ? 'space.075' : 'space.100',
    paddingBlock: "space.050",
    xcss: styles.readViewStyles
    // minHeight here compensates for 2px from both top and bottom taken by InlneEdit (from transparent border in read-view mode and border+padding in edit view)
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      minHeight: 'calc(40px - 2px * 2)'
    }
  }, renderItem(values)));
  if (!isEditable) {
    return readView;
  }

  // if the field requires to fetch options to execute, then is editable only if `executeFetch` is defined
  if (isEditTypeSelectable(values.type) && !executeFetch) {
    return readView;
  }
  return /*#__PURE__*/React.createElement(InlineEdit, {
    ari: ari,
    execute: execute,
    executeFetch: executeFetch,
    readView: readView,
    columnKey: columnKey,
    columnTitle: columnTitle,
    datasourceTypeWithValues: values
  });
};
const toDatasourceTypeWithValues = ({
  rowData,
  columnKey,
  columnType
}) => {
  var _rowData$columnKey2;
  // Need to make sure we keep falsy values like 0 and '', as well as the boolean false.
  const value = (_rowData$columnKey2 = rowData[columnKey]) === null || _rowData$columnKey2 === void 0 ? void 0 : _rowData$columnKey2.data;
  const values = !value ? [] : Array.isArray(value) ? value : [value];
  return {
    type: columnType,
    values
  };
};
export const TableCellContent = ({
  id,
  columnKey,
  columnTitle,
  columnType,
  renderItem,
  wrappedColumnKeys
}) => {
  const item = useDatasourceItem({
    id
  });
  if (item) {
    const {
      integrationKey,
      ari,
      data: rowData
    } = item;
    const isEditType = !!ari && !!integrationKey && isEditTypeSupported(columnType);
    if (isEditType) {
      return /*#__PURE__*/React.createElement(InlineEditableCell, {
        ari: ari,
        columnKey: columnKey,
        columnTitle: columnTitle,
        renderItem: renderItem,
        integrationKey: integrationKey,
        values: toDatasourceTypeWithValues({
          rowData,
          columnKey,
          columnType
        }),
        wrappedColumnKeys: wrappedColumnKeys
      });
    }
  }
  return /*#__PURE__*/React.createElement(Box, {
    testId: "inline-edit-read-view",
    paddingInline: "space.100",
    paddingBlock: "space.050",
    xcss: styles.readViewStyles
    // minHeight here compensates for 2px from both top and bottom taken by InlneEdit (from transparent border in read-view mode and border+padding in edit view)
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      minHeight: 'calc(40px - 2px * 2)'
    }
  }, /*#__PURE__*/React.createElement(ReadOnlyCell, {
    id: id,
    columnKey: columnKey,
    columnTitle: columnTitle,
    columnType: columnType,
    wrappedColumnKeys: wrappedColumnKeys,
    renderItem: renderItem
  }));
};