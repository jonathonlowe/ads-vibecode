import _defineProperty from "@babel/runtime/helpers/defineProperty";
import mergeWith from 'lodash/mergeWith';
import { AbstractJastVisitor, COMPOUND_OPERATOR_AND, COMPOUND_OPERATOR_OR, JastBuilder, OPERATOR_EQUALS, OPERATOR_IN, OPERATOR_LIKE } from '@atlaskit/jql-ast';
import { ALLOWED_ORDER_BY_KEYS } from '../../jira-search-container';
import { isClauseTooComplex } from './isClauseTooComplex';
import { isValidJql } from './index';

// Map of field keys to their respective clauses in the Jast

const allowedFields = [
// basic filter fields
'assignee', 'type', 'project', 'status',
// search input fields
'text', 'summary', 'key'];
const fallbackOperators = [OPERATOR_IN];
const fieldSpecificOperators = {
  text: [OPERATOR_LIKE, OPERATOR_EQUALS],
  summary: [OPERATOR_LIKE, OPERATOR_EQUALS],
  key: [OPERATOR_EQUALS],
  project: [OPERATOR_IN, OPERATOR_EQUALS],
  type: [OPERATOR_IN, OPERATOR_EQUALS],
  status: [OPERATOR_IN, OPERATOR_EQUALS],
  assignee: [OPERATOR_IN, OPERATOR_EQUALS]
};
class JqlClauseCollectingVisitorError extends Error {}

/**
 * Rather than having to navigate the entire tree structure ourself, we extend AbstractJastVisitor
 * class and implement visitor functions for node types that we wish to process.
 * A list of available visitor can be viewed in packages/jql/jql-ast/src/types/api/jast-visitor.ts
 * more info - https://atlaskit.atlassian.com/packages/jql/jql-ast/docs/traversing-the-ast
 * */
class JqlClauseCollectingVisitor extends AbstractJastVisitor {
  constructor() {
    super();
    _defineProperty(this, "visitNotClause", () => {
      throw new JqlClauseCollectingVisitorError('Visited an unsupported node while traversing the AST');
    });
    _defineProperty(this, "visitOrderByField", orderByField => {
      var _orderByField$field$v;
      const fieldValue = (_orderByField$field$v = orderByField.field.value) === null || _orderByField$field$v === void 0 ? void 0 : _orderByField$field$v.toLowerCase();
      if (fieldValue && !ALLOWED_ORDER_BY_KEYS.includes(fieldValue)) {
        throw new JqlClauseCollectingVisitorError(`query with order by field '${fieldValue}' is not supported`);
      }
      return {};
    });
    _defineProperty(this, "visitCompoundClause", compoundClause => {
      const clauseMap = {};
      const operator = compoundClause.operator.value;
      if (operator === COMPOUND_OPERATOR_AND) {
        return compoundClause.clauses.reduce((result, clause) => this.aggregateResult(clause.accept(this), result), clauseMap);
      }
      if (operator === COMPOUND_OPERATOR_OR) {
        // this is delt with in isClauseTooComplex
        return this.aggregateResult({
          text: [compoundClause]
        }, clauseMap);
      }
      throw new JqlClauseCollectingVisitorError(`Compound clauses using the operator '${operator}' is not supported`);
    });
    _defineProperty(this, "visitTerminalClause", terminalClause => {
      var _terminalClause$opera;
      const fieldName = terminalClause.field.value.toLowerCase();
      if (!allowedFields.includes(fieldName)) {
        throw new JqlClauseCollectingVisitorError(`Field with name '${fieldName}' of type ${terminalClause.clauseType} is not supported`);
      }
      const operator = (_terminalClause$opera = terminalClause.operator) === null || _terminalClause$opera === void 0 ? void 0 : _terminalClause$opera.value;
      const allowedOperators = fieldSpecificOperators[fieldName] || fallbackOperators;
      if (operator && !allowedOperators.includes(operator.toLowerCase())) {
        throw new JqlClauseCollectingVisitorError(`Field with name '${fieldName}' using operator ${operator} is not supported`);
      }
      return {
        [terminalClause.field.value.toLowerCase()]: [terminalClause]
      };
    });
  }
  aggregateResult(aggregate, nextResult) {
    return mergeWith(aggregate, nextResult, (destValue, srcValue) => srcValue.concat(destValue !== null && destValue !== void 0 ? destValue : []));
  }
  defaultResult() {
    return {};
  }
}
export const isQueryTooComplex = jql => {
  if (!jql) {
    return false;
  }
  if (!isValidJql(jql)) {
    return true;
  }
  const jast = new JastBuilder().build(jql);
  try {
    const jqlClauseCollectingVisitor = new JqlClauseCollectingVisitor();
    const clauseMap = jast.query ? jast.query.accept(jqlClauseCollectingVisitor) : {}; // jast.query is defined as void | Query, hence the fallback

    const hasAnyKeyWithComplexClause = Object.entries(clauseMap).some(([key, clauses]) => isClauseTooComplex(clauses, key));
    return hasAnyKeyWithComplexClause;
  } catch (error) {
    return true;
  }
};