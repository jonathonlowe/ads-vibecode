import { useCallback, useEffect, useRef, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { useBasicFilterAGG } from '../../../../services/useBasicFilterAGG';
import { mapFieldValuesToFilterOptions, mapFieldValuesToPageCursor, mapFieldValuesToTotalCount } from '../utils/transformers';
import { filterOptionMessages } from './messages';
export const getAssigneeUnassignedFilterOption = formatMessage => ({
  label: formatMessage(filterOptionMessages.assigneeUnassignedFilterOption),
  optionType: 'avatarLabel',
  value: 'empty'
});
export const useFilterOptions = ({
  filterType,
  site
}) => {
  const {
    formatMessage
  } = useIntl();
  const [filterOptions, setFilterOptions] = useState([]);
  const [totalCount, setTotalCount] = useState(0);
  const [status, setStatus] = useState('empty');
  const [errors, setErrors] = useState([]);
  const [nextPageCursor, setNextPageCursor] = useState(undefined);
  const initialData = useRef();
  const {
    cloudId,
    url: siteUrl
  } = site || {};
  const {
    getFieldValues
  } = useBasicFilterAGG();
  const fetchFilterOptions = useCallback(async ({
    pageCursor,
    searchString
  } = {}) => {
    if (!cloudId) {
      return;
    }
    const isNewSearch = !pageCursor;
    const isRequestLikeInitialSearch = !pageCursor && !searchString;
    const {
      current: initialResponseData
    } = initialData;
    isNewSearch ? setStatus('loading') : setStatus('loadingMore');
    try {
      const response = isRequestLikeInitialSearch && initialResponseData ? initialResponseData : await getFieldValues({
        cloudId,
        jql: '',
        jqlTerm: filterType,
        // @ts-expect-error - Type 'string | undefined' is not assignable to type 'string'
        searchString,
        pageCursor
      });
      if (response.errors && response.errors.length > 0) {
        setStatus('rejected');
        setErrors(response.errors);
        return;
      }
      const mappedResponse = mapFieldValuesToFilterOptions({
        ...response,
        siteUrl
      });
      let mappedTotalCount = mapFieldValuesToTotalCount(response);

      /**
       * For assignee filter option, we want `Unassigned` as an option.
       * Since we add it manually, we also need to update the total count by +1
       */
      if (filterType === 'assignee' && !searchString) {
        mappedTotalCount += 1;
      }
      if (isNewSearch) {
        if (isRequestLikeInitialSearch) {
          /**
           * The initial dataset is used in couple of paths, eg: when a user searches and clears the search text.
           * During these times, we dont want to fetch data again and again, hence a mini cache setup to store and provide the initial dataset
           */
          initialData.current = response;

          /**
           * For assignee filter option, we want `Unassigned` as an option.
           * Since `Unassigned/EMPTY` is not returned by the API, we add it manually, but only for the initial list
           */
          if (filterType === 'assignee') {
            mappedResponse.unshift(getAssigneeUnassignedFilterOption(formatMessage));
          }
        }
        setFilterOptions(mappedResponse);
      } else {
        setFilterOptions([...filterOptions, ...mappedResponse]);
      }
      setTotalCount(mappedTotalCount);
      setNextPageCursor(mapFieldValuesToPageCursor(response));
      setStatus('resolved');
    } catch (error) {
      setStatus('rejected');
      setErrors([error]);
    }
  }, [cloudId, filterOptions, filterType, formatMessage, getFieldValues, siteUrl]);
  useEffect(() => {
    if (status !== 'rejected' && errors.length !== 0) {
      setErrors([]);
    }
  }, [errors.length, status]);
  const reset = useCallback(() => {
    setStatus('empty');
    setFilterOptions([]);
    setErrors([]);
    setTotalCount(0);
    setNextPageCursor(undefined);
    initialData.current = undefined;
  }, []);
  return {
    filterOptions,
    fetchFilterOptions,
    totalCount,
    pageCursor: nextPageCursor,
    status,
    errors,
    reset
  };
};