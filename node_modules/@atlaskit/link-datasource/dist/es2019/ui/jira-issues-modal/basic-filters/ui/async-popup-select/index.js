import React, { useCallback, useEffect, useRef, useState } from 'react';
import isEqual from 'lodash/isEqual';
import { useIntl } from 'react-intl-next';
import { useDebouncedCallback } from 'use-debounce';
import { fg } from '@atlaskit/platform-feature-flags';
import { FilterPopupSelect } from '../../../../common/modal/popup-select';
import { SEARCH_DEBOUNCE_MS } from '../../../../common/modal/popup-select/constants';
import { useFilterOptions } from '../../hooks/useFilterOptions';
import { asyncPopupSelectMessages } from './messages';
const AsyncPopupSelect = ({
  filterType,
  site,
  selection,
  isJQLHydrating,
  onSelectionChange = () => {},
  isDisabled = false
}) => {
  const {
    formatMessage
  } = useIntl();
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedOptions, setSelectedOptions] = useState(selection);
  const {
    cloudId
  } = site || {};
  const currentSiteCloudId = useRef(cloudId || '');
  const {
    filterOptions,
    fetchFilterOptions,
    totalCount,
    status,
    pageCursor,
    reset: resetHook,
    errors
  } = useFilterOptions({
    filterType,
    site
  });
  const [handleDebouncedFetchFilterOptions] = useDebouncedCallback(searchString => {
    fetchFilterOptions({
      searchString
    });
  }, SEARCH_DEBOUNCE_MS);
  const handleInputChange = useCallback(async newSearchTerm => {
    setSearchTerm(newSearchTerm);
    handleDebouncedFetchFilterOptions(newSearchTerm);
  }, [handleDebouncedFetchFilterOptions]);
  const handleOptionSelection = useCallback(newValue => {
    onSelectionChange(filterType, newValue);
  }, [filterType, onSelectionChange]);
  const handleShowMore = useCallback(() => {
    if (pageCursor) {
      fetchFilterOptions({
        pageCursor,
        searchString: searchTerm
      });
    }
  }, [fetchFilterOptions, pageCursor, searchTerm]);
  const handleMenuOpen = useCallback(() => {
    if (status === 'empty' || status === 'rejected') {
      // if user searches and gets status as rejected, we want the dropdown to try load the request with searchString when the user reopens the dropdown
      fetchFilterOptions({
        searchString: searchTerm
      });
    }
  }, [fetchFilterOptions, searchTerm, status]);
  useEffect(() => {
    if (cloudId && currentSiteCloudId.current !== cloudId) {
      currentSiteCloudId.current = cloudId;
      setSearchTerm('');
      resetHook();
    }
  }, [cloudId, resetHook]);
  useEffect(() => {
    if (!isEqual(selection, selectedOptions)) {
      setSelectedOptions(selection);
    }
  }, [selectedOptions, selection]);
  const filterOptionsLength = filterOptions.length;
  const isError = status === 'rejected';
  const isLoading = status === 'loading' || status === 'empty';
  const isLoadingMore = status === 'loadingMore';
  const isEmpty = status === 'resolved' && filterOptionsLength === 0;
  const popupSelectOptions = isLoading || isError ? [] : filterOptions; // if not set to [], then on loading, no loading UI will be shown
  const areAllResultsLoaded = filterOptionsLength === totalCount;
  const filterName = `jlol-basic-filter-${filterType}`;
  const shouldShowFooter = (status === 'resolved' || isLoadingMore) && filterOptionsLength > 0; // footer should not disappear when there is an inline spinner for loading more data
  const shouldDisplayShowMoreButton = status === 'resolved' && !!pageCursor && !areAllResultsLoaded;
  const triggerButtonLabel = formatMessage(!fg('platform-linking-visual-refresh-sllv') && filterType === 'type' ? asyncPopupSelectMessages.typeLabelOld : asyncPopupSelectMessages[`${filterType}Label`]);
  return /*#__PURE__*/React.createElement(FilterPopupSelect, {
    filterName: filterName,
    status: status,
    showLoading: isLoading,
    showHydrating: isJQLHydrating,
    isDisabled: isDisabled,
    totalCount: totalCount,
    shouldShowFooter: shouldShowFooter,
    selectedOptions: selectedOptions,
    options: popupSelectOptions,
    buttonLabel: triggerButtonLabel,
    searchPlaceholder: fg('platform-linking-visual-refresh-sllv') ? formatMessage(asyncPopupSelectMessages[`${filterType}SearchPlaceholder`]) : undefined,
    onInputChange: handleInputChange,
    onSelectionChange: handleOptionSelection,
    onMenuOpen: handleMenuOpen,
    menuListProps: {
      filterName,
      isError,
      isEmpty,
      isLoading,
      isLoadingMore,
      handleShowMore,
      errors,
      showMore: shouldDisplayShowMoreButton
    }
  });
};
export default AsyncPopupSelect;