import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { useDebouncedCallback } from 'use-debounce';
import { FilterPopupSelect } from '../../../../common/modal/popup-select';
import { SEARCH_DEBOUNCE_MS } from '../../../../common/modal/popup-select/constants';
import { useCurrentUserInfo } from '../../hooks/useCurrentUserInfo';
import useRecommendation from '../../hooks/useRecommendation';
import { CLOLBasicFilters } from '../../types';
import { editedOrCreatedByMessage } from './messages';
const filterName = `clol-basic-filter-${CLOLBasicFilters.editedOrCreatedBy}`;
const EditedOrCreatedByFilter = ({
  cloudId,
  onSelectionChange,
  selection = [],
  isHydrating = false
}) => {
  const {
    user
  } = useCurrentUserInfo();
  const {
    formatMessage
  } = useIntl();
  const {
    status,
    filterOptions,
    fetchFilterOptions,
    errors,
    reset: resetHook
  } = useRecommendation();
  const currentSiteCloudId = useRef(cloudId || '');
  const [searchTerm, setSearchTerm] = useState('');
  const [handleDebouncedFetchFilterOptions] = useDebouncedCallback(searchTerm => {
    if (cloudId && user !== null && user !== void 0 && user.accountId) {
      fetchFilterOptions({
        searchTerm,
        cloudId,
        userId: user.accountId
      });
    }
  }, SEARCH_DEBOUNCE_MS);
  const handleInputChange = useCallback(async newSearchTerm => {
    setSearchTerm(newSearchTerm);
    handleDebouncedFetchFilterOptions(newSearchTerm);
  }, [handleDebouncedFetchFilterOptions]);
  const handleOptionSelection = useCallback(newValue => {
    onSelectionChange(CLOLBasicFilters.editedOrCreatedBy, newValue);
  }, [onSelectionChange]);
  const handleMenuOpen = useCallback(() => {
    if ((status === 'empty' || status === 'rejected') && cloudId && user !== null && user !== void 0 && user.accountId) {
      // if user searches and gets status as rejected, we want the dropdown to try load the request with searchString when the user reopens the dropdown
      fetchFilterOptions({
        cloudId,
        userId: user.accountId,
        searchTerm
      });
    }
  }, [fetchFilterOptions, status, cloudId, user === null || user === void 0 ? void 0 : user.accountId, searchTerm]);
  const filterOptionsLength = filterOptions.length;
  const isError = status === 'rejected';
  const isLoading = status === 'loading' || status === 'empty';
  const isEmpty = status === 'resolved' && filterOptionsLength === 0;
  const isDisabled = !cloudId || !(user !== null && user !== void 0 && user.accountId);
  useEffect(() => {
    if (cloudId && currentSiteCloudId.current !== cloudId) {
      currentSiteCloudId.current = cloudId;
      if (status === 'resolved') {
        resetHook();
      }
    }
  }, [cloudId, resetHook, status]);
  return /*#__PURE__*/React.createElement(FilterPopupSelect, {
    buttonLabel: formatMessage(editedOrCreatedByMessage.buttonLabel),
    filterName: filterName,
    isDisabled: isDisabled,
    options: filterOptions,
    showLoading: isLoading,
    selectedOptions: selection,
    onSelectionChange: handleOptionSelection,
    onInputChange: handleInputChange,
    showHydrating: isHydrating,
    shouldShowFooter: false,
    status: status,
    onMenuOpen: handleMenuOpen,
    menuListProps: {
      filterName: filterName,
      errors,
      isLoading,
      isError,
      isEmpty
    }
  });
};
export default EditedOrCreatedByFilter;