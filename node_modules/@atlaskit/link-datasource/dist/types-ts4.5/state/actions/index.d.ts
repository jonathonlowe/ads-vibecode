import { type Action } from 'react-sweet-state';
import { useDatasourceClientExtension } from '@atlaskit/link-client-extension';
import type { ActionsDiscoveryRequest, AtomicActionExecuteRequest, AtomicActionExecuteResponse, AtomicActionInterface } from '@atlaskit/linking-types';
import { type DatasourceOperationFailedAttributesType, type EventKey } from '../../../src/analytics/generated/analytics.types';
import type createEventPayload from '../../../src/analytics/generated/create-event-payload';
type IntegrationKey = string;
type FieldKey = string;
/**
 * Atomic actions available for an integration (by field)
 * @example
 * ```ts
 * {
 *  jira: {
 *    summary: {
 *      actionKey: 'atlassian:work-item:update:summary',
 *      type: 'string'
 *    },
 *    status: {
 *      actionKey: 'atlassian:work-item:update:status',
 *      type: 'string',
 *      fetchAction: {
 *        actionKey: 'atlassian:work-item:get:statuses',
 *        type: 'string',
 *        inputs: {
 *          issueId: {
 *            type: 'string'
 *          }
 *        }
 *      }
 *    }
 *  }
 * }
 * ```
 */
type IntegrationActions = Record<IntegrationKey, Record<FieldKey, Pick<AtomicActionInterface, 'actionKey' | 'type' | 'description'> & {
    fetchAction?: Pick<AtomicActionInterface, 'actionKey' | 'type' | 'inputs'>;
}>>;
/**
 * Permissions available for a target
 */
type TargetPermissions = Record<FieldKey, {
    isEditable: boolean;
}>;
/**
 * User permissions for actions on target (ARI) properties
 * @example
 * ```ts
 *	{
 *		'ari:cloud:jira:63cecfe3-16fa-4ee1-8e8d-047cc4b18980:issue/1': {
 *			summary: {
 *				isEditable: true
 *			}
 *		}
 *	}
 * ```
 */
type ARI = string;
type Permissions = Record<ARI, TargetPermissions>;
export interface ActionsStoreState {
    actionsByIntegration: IntegrationActions;
    permissions: Permissions;
}
interface Client {
    getDatasourceActionsAndPermissions: ReturnType<typeof useDatasourceClientExtension>['getDatasourceActionsAndPermissions'];
}
type AnalyticsCaptureError = (errorLocation: DatasourceOperationFailedAttributesType['errorLocation'], error: unknown) => void;
type AnalyticsFireEvent = <K extends EventKey>(...params: Parameters<typeof createEventPayload<K>>) => void;
interface UseDiscoverActionsProps {
    captureError: AnalyticsCaptureError;
    fireEvent: AnalyticsFireEvent;
}
export declare const actions: {
    discoverActions: (captureError: AnalyticsCaptureError, fireEvent: AnalyticsFireEvent, api: Client, request: ActionsDiscoveryRequest) => Action<ActionsStoreState>;
};
export declare const ActionsStore: import("react-sweet-state").Store<ActionsStoreState, {
    discoverActions: (captureError: AnalyticsCaptureError, fireEvent: AnalyticsFireEvent, api: Client, request: ActionsDiscoveryRequest) => Action<ActionsStoreState>;
}>;
export declare const useDiscoverActions: ({ captureError, fireEvent }: UseDiscoverActionsProps) => {
    discoverActions: (request: ActionsDiscoveryRequest) => void | Promise<void>;
};
/**
 * Retrieves the action schema for a given ARI + fieldKey + integrationKey
 */
export declare const useAtomicUpdateActionSchema: import("react-sweet-state").HookFunction<{
    schema?: undefined;
    fetchSchema?: undefined;
} | {
    schema: Pick<AtomicActionInterface, "actionKey" | "type" | "description"> & {
        fetchAction?: Pick<AtomicActionInterface, "actionKey" | "type" | "inputs"> | undefined;
    };
    fetchSchema: Pick<AtomicActionInterface, "actionKey" | "type" | "inputs"> | undefined;
}, import("react-sweet-state").BoundActions<ActionsStoreState, {
    discoverActions: (captureError: AnalyticsCaptureError, fireEvent: AnalyticsFireEvent, api: Client, request: ActionsDiscoveryRequest) => Action<ActionsStoreState>;
}>, {
    ari: string;
    fieldKey: string;
    integrationKey: string;
}>;
export type ExecuteFetch = <E>(inputs: AtomicActionExecuteRequest['parameters']['inputs']) => Promise<E>;
/**
 * Given an ARI + fieldKey + integrationKey
 * Returns an executable action that updates a field on the entity if the user has permissions to do so
 *
 * @example
 * ```tsx
 * const { execute } = useExecuteAtomicAction({ ari, fieldKey: 'summary', integrationKey: 'jira' });
 *
 * return <button onClick={() => execute('New summary')}>Update summary</button>;
 * ```
 */
export declare const useExecuteAtomicAction: ({ ari, fieldKey, integrationKey, }: {
    ari: string;
    fieldKey: string;
    integrationKey: string;
}) => {
    execute?: ((value: string | number) => Promise<AtomicActionExecuteResponse<unknown>>) | undefined;
    executeFetch?: ExecuteFetch | undefined;
};
export {};
