"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useHydrateJqlQuery = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _reactIntlNext = require("react-intl-next");
var _jqlAst = require("@atlaskit/jql-ast");
var _useBasicFilterAGG2 = require("../../../../services/useBasicFilterAGG");
var _extractValuesFromNonComplexJQL = require("../utils/extractValuesFromNonComplexJQL");
var _isClauseTooComplex = require("../utils/isClauseTooComplex");
var _transformers = require("../utils/transformers");
var _useFilterOptions = require("./useFilterOptions");
var _excluded = ["assignee"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var useHydrateJqlQuery = exports.useHydrateJqlQuery = function useHydrateJqlQuery(cloudId, jql) {
  var _useState = (0, _react.useState)({}),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    hydratedOptions = _useState2[0],
    setHydratedOptions = _useState2[1];
  var _useIntl = (0, _reactIntlNext.useIntl)(),
    formatMessage = _useIntl.formatMessage;
  var _useState3 = (0, _react.useState)('empty'),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    status = _useState4[0],
    setStatus = _useState4[1];
  var _useState5 = (0, _react.useState)([]),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    errors = _useState6[0],
    setErrors = _useState6[1];
  var _useBasicFilterAGG = (0, _useBasicFilterAGG2.useBasicFilterAGG)(),
    getHydratedJQL = _useBasicFilterAGG.getHydratedJQL;
  var fetchHydratedJqlOptions = (0, _react.useCallback)( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var response, _mapHydrateResponseDa, mappedHydratedAssigneeValue, restOfMappedHydratedResponse, _extractValuesFromNon, text, summary, key, extractedAssigneeValue, _ref2, _ref3, textFieldValue, mappedValues;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          setStatus('loading');
          _context.next = 4;
          return getHydratedJQL(cloudId, jql);
        case 4:
          response = _context.sent;
          if (!(response.errors && response.errors.length > 0)) {
            _context.next = 9;
            break;
          }
          setStatus('rejected');
          setErrors(response.errors);
          return _context.abrupt("return");
        case 9:
          _mapHydrateResponseDa = (0, _transformers.mapHydrateResponseData)(response), mappedHydratedAssigneeValue = _mapHydrateResponseDa.assignee, restOfMappedHydratedResponse = (0, _objectWithoutProperties2.default)(_mapHydrateResponseDa, _excluded);
          /**
           * Hydrate logic does not return text field, hence we parse and extract value from jql
           */
          _extractValuesFromNon = (0, _extractValuesFromNonComplexJQL.extractValuesFromNonComplexJQL)(jql), text = _extractValuesFromNon.text, summary = _extractValuesFromNon.summary, key = _extractValuesFromNon.key, extractedAssigneeValue = _extractValuesFromNon.assignee;
          _ref2 = text || summary || key || [], _ref3 = (0, _slicedToArray2.default)(_ref2, 1), textFieldValue = _ref3[0];
          mappedValues = _objectSpread(_objectSpread({}, restOfMappedHydratedResponse), {}, {
            /**
             * Special handling for assignee as we need to inject Unassigned value if JQL contains EMPTY keyword for assignee
             */
            assignee: [].concat((0, _toConsumableArray2.default)(mappedHydratedAssigneeValue || []), (0, _toConsumableArray2.default)(extractedAssigneeValue !== null && extractedAssigneeValue !== void 0 && extractedAssigneeValue.includes(_jqlAst.OPERAND_EMPTY) // checks and adds EMPTY filter option if extracted assignee values from jql contains EMPTY
            ? [(0, _useFilterOptions.getAssigneeUnassignedFilterOption)(formatMessage)] : []))
          }, textFieldValue ? {
            basicInputTextValue: (0, _isClauseTooComplex.removeFuzzyCharacter)(textFieldValue)
          } : {});
          setHydratedOptions(mappedValues);
          setStatus('resolved');
          _context.next = 21;
          break;
        case 17:
          _context.prev = 17;
          _context.t0 = _context["catch"](0);
          setErrors([_context.t0]);
          setStatus('rejected');
        case 21:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 17]]);
  })), [cloudId, formatMessage, getHydratedJQL, jql]);
  (0, _react.useEffect)(function () {
    if (status !== 'rejected' && errors.length !== 0) {
      setErrors([]);
    }
  }, [errors.length, status]);
  return {
    hydratedOptions: hydratedOptions,
    fetchHydratedJqlOptions: fetchHydratedJqlOptions,
    status: status,
    errors: errors
  };
};