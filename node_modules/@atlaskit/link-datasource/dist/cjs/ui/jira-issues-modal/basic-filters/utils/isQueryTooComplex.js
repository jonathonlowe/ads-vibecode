"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isQueryTooComplex = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));
var _jqlAst = require("@atlaskit/jql-ast");
var _jiraSearchContainer = require("../../jira-search-container");
var _isClauseTooComplex = require("./isClauseTooComplex");
var _index = require("./index");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
// Map of field keys to their respective clauses in the Jast

var allowedFields = [
// basic filter fields
'assignee', 'type', 'project', 'status',
// search input fields
'text', 'summary', 'key'];
var fallbackOperators = [_jqlAst.OPERATOR_IN];
var fieldSpecificOperators = {
  text: [_jqlAst.OPERATOR_LIKE, _jqlAst.OPERATOR_EQUALS],
  summary: [_jqlAst.OPERATOR_LIKE, _jqlAst.OPERATOR_EQUALS],
  key: [_jqlAst.OPERATOR_EQUALS],
  project: [_jqlAst.OPERATOR_IN, _jqlAst.OPERATOR_EQUALS],
  type: [_jqlAst.OPERATOR_IN, _jqlAst.OPERATOR_EQUALS],
  status: [_jqlAst.OPERATOR_IN, _jqlAst.OPERATOR_EQUALS],
  assignee: [_jqlAst.OPERATOR_IN, _jqlAst.OPERATOR_EQUALS]
};
var JqlClauseCollectingVisitorError = /*#__PURE__*/function (_Error) {
  function JqlClauseCollectingVisitorError() {
    (0, _classCallCheck2.default)(this, JqlClauseCollectingVisitorError);
    return _callSuper(this, JqlClauseCollectingVisitorError, arguments);
  }
  (0, _inherits2.default)(JqlClauseCollectingVisitorError, _Error);
  return (0, _createClass2.default)(JqlClauseCollectingVisitorError);
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * Rather than having to navigate the entire tree structure ourself, we extend AbstractJastVisitor
 * class and implement visitor functions for node types that we wish to process.
 * A list of available visitor can be viewed in packages/jql/jql-ast/src/types/api/jast-visitor.ts
 * more info - https://atlaskit.atlassian.com/packages/jql/jql-ast/docs/traversing-the-ast
 * */
var JqlClauseCollectingVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function JqlClauseCollectingVisitor() {
    var _this;
    (0, _classCallCheck2.default)(this, JqlClauseCollectingVisitor);
    _this = _callSuper(this, JqlClauseCollectingVisitor);
    (0, _defineProperty2.default)(_this, "visitNotClause", function () {
      throw new JqlClauseCollectingVisitorError('Visited an unsupported node while traversing the AST');
    });
    (0, _defineProperty2.default)(_this, "visitOrderByField", function (orderByField) {
      var _orderByField$field$v;
      var fieldValue = (_orderByField$field$v = orderByField.field.value) === null || _orderByField$field$v === void 0 ? void 0 : _orderByField$field$v.toLowerCase();
      if (fieldValue && !_jiraSearchContainer.ALLOWED_ORDER_BY_KEYS.includes(fieldValue)) {
        throw new JqlClauseCollectingVisitorError("query with order by field '".concat(fieldValue, "' is not supported"));
      }
      return {};
    });
    (0, _defineProperty2.default)(_this, "visitCompoundClause", function (compoundClause) {
      var clauseMap = {};
      var operator = compoundClause.operator.value;
      if (operator === _jqlAst.COMPOUND_OPERATOR_AND) {
        return compoundClause.clauses.reduce(function (result, clause) {
          return _this.aggregateResult(clause.accept(_this), result);
        }, clauseMap);
      }
      if (operator === _jqlAst.COMPOUND_OPERATOR_OR) {
        // this is delt with in isClauseTooComplex
        return _this.aggregateResult({
          text: [compoundClause]
        }, clauseMap);
      }
      throw new JqlClauseCollectingVisitorError("Compound clauses using the operator '".concat(operator, "' is not supported"));
    });
    (0, _defineProperty2.default)(_this, "visitTerminalClause", function (terminalClause) {
      var _terminalClause$opera;
      var fieldName = terminalClause.field.value.toLowerCase();
      if (!allowedFields.includes(fieldName)) {
        throw new JqlClauseCollectingVisitorError("Field with name '".concat(fieldName, "' of type ").concat(terminalClause.clauseType, " is not supported"));
      }
      var operator = (_terminalClause$opera = terminalClause.operator) === null || _terminalClause$opera === void 0 ? void 0 : _terminalClause$opera.value;
      var allowedOperators = fieldSpecificOperators[fieldName] || fallbackOperators;
      if (operator && !allowedOperators.includes(operator.toLowerCase())) {
        throw new JqlClauseCollectingVisitorError("Field with name '".concat(fieldName, "' using operator ").concat(operator, " is not supported"));
      }
      return (0, _defineProperty2.default)({}, terminalClause.field.value.toLowerCase(), [terminalClause]);
    });
    return _this;
  }
  (0, _inherits2.default)(JqlClauseCollectingVisitor, _AbstractJastVisitor);
  return (0, _createClass2.default)(JqlClauseCollectingVisitor, [{
    key: "aggregateResult",
    value: function aggregateResult(aggregate, nextResult) {
      return (0, _mergeWith.default)(aggregate, nextResult, function (destValue, srcValue) {
        return srcValue.concat(destValue !== null && destValue !== void 0 ? destValue : []);
      });
    }
  }, {
    key: "defaultResult",
    value: function defaultResult() {
      return {};
    }
  }]);
}(_jqlAst.AbstractJastVisitor);
var isQueryTooComplex = exports.isQueryTooComplex = function isQueryTooComplex(jql) {
  if (!jql) {
    return false;
  }
  if (!(0, _index.isValidJql)(jql)) {
    return true;
  }
  var jast = new _jqlAst.JastBuilder().build(jql);
  try {
    var jqlClauseCollectingVisitor = new JqlClauseCollectingVisitor();
    var clauseMap = jast.query ? jast.query.accept(jqlClauseCollectingVisitor) : {}; // jast.query is defined as void | Query, hence the fallback

    var hasAnyKeyWithComplexClause = Object.entries(clauseMap).some(function (_ref2) {
      var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
        key = _ref3[0],
        clauses = _ref3[1];
      return (0, _isClauseTooComplex.isClauseTooComplex)(clauses, key);
    });
    return hasAnyKeyWithComplexClause;
  } catch (error) {
    return true;
  }
};