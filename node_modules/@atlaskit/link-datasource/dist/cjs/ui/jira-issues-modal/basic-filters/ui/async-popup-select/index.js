"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _isEqual = _interopRequireDefault(require("lodash/isEqual"));
var _reactIntlNext = require("react-intl-next");
var _useDebounce = require("use-debounce");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _popupSelect = require("../../../../common/modal/popup-select");
var _constants = require("../../../../common/modal/popup-select/constants");
var _useFilterOptions2 = require("../../hooks/useFilterOptions");
var _messages = require("./messages");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var AsyncPopupSelect = function AsyncPopupSelect(_ref) {
  var filterType = _ref.filterType,
    site = _ref.site,
    selection = _ref.selection,
    isJQLHydrating = _ref.isJQLHydrating,
    _ref$onSelectionChang = _ref.onSelectionChange,
    onSelectionChange = _ref$onSelectionChang === void 0 ? function () {} : _ref$onSelectionChang,
    _ref$isDisabled = _ref.isDisabled,
    isDisabled = _ref$isDisabled === void 0 ? false : _ref$isDisabled;
  var _useIntl = (0, _reactIntlNext.useIntl)(),
    formatMessage = _useIntl.formatMessage;
  var _useState = (0, _react.useState)(''),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    searchTerm = _useState2[0],
    setSearchTerm = _useState2[1];
  var _useState3 = (0, _react.useState)(selection),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    selectedOptions = _useState4[0],
    setSelectedOptions = _useState4[1];
  var _ref2 = site || {},
    cloudId = _ref2.cloudId;
  var currentSiteCloudId = (0, _react.useRef)(cloudId || '');
  var _useFilterOptions = (0, _useFilterOptions2.useFilterOptions)({
      filterType: filterType,
      site: site
    }),
    filterOptions = _useFilterOptions.filterOptions,
    fetchFilterOptions = _useFilterOptions.fetchFilterOptions,
    totalCount = _useFilterOptions.totalCount,
    status = _useFilterOptions.status,
    pageCursor = _useFilterOptions.pageCursor,
    resetHook = _useFilterOptions.reset,
    errors = _useFilterOptions.errors;
  var _useDebouncedCallback = (0, _useDebounce.useDebouncedCallback)(function (searchString) {
      fetchFilterOptions({
        searchString: searchString
      });
    }, _constants.SEARCH_DEBOUNCE_MS),
    _useDebouncedCallback2 = (0, _slicedToArray2.default)(_useDebouncedCallback, 1),
    handleDebouncedFetchFilterOptions = _useDebouncedCallback2[0];
  var handleInputChange = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(newSearchTerm) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            setSearchTerm(newSearchTerm);
            handleDebouncedFetchFilterOptions(newSearchTerm);
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }(), [handleDebouncedFetchFilterOptions]);
  var handleOptionSelection = (0, _react.useCallback)(function (newValue) {
    onSelectionChange(filterType, newValue);
  }, [filterType, onSelectionChange]);
  var handleShowMore = (0, _react.useCallback)(function () {
    if (pageCursor) {
      fetchFilterOptions({
        pageCursor: pageCursor,
        searchString: searchTerm
      });
    }
  }, [fetchFilterOptions, pageCursor, searchTerm]);
  var handleMenuOpen = (0, _react.useCallback)(function () {
    if (status === 'empty' || status === 'rejected') {
      // if user searches and gets status as rejected, we want the dropdown to try load the request with searchString when the user reopens the dropdown
      fetchFilterOptions({
        searchString: searchTerm
      });
    }
  }, [fetchFilterOptions, searchTerm, status]);
  (0, _react.useEffect)(function () {
    if (cloudId && currentSiteCloudId.current !== cloudId) {
      currentSiteCloudId.current = cloudId;
      setSearchTerm('');
      resetHook();
    }
  }, [cloudId, resetHook]);
  (0, _react.useEffect)(function () {
    if (!(0, _isEqual.default)(selection, selectedOptions)) {
      setSelectedOptions(selection);
    }
  }, [selectedOptions, selection]);
  var filterOptionsLength = filterOptions.length;
  var isError = status === 'rejected';
  var isLoading = status === 'loading' || status === 'empty';
  var isLoadingMore = status === 'loadingMore';
  var isEmpty = status === 'resolved' && filterOptionsLength === 0;
  var popupSelectOptions = isLoading || isError ? [] : filterOptions; // if not set to [], then on loading, no loading UI will be shown
  var areAllResultsLoaded = filterOptionsLength === totalCount;
  var filterName = "jlol-basic-filter-".concat(filterType);
  var shouldShowFooter = (status === 'resolved' || isLoadingMore) && filterOptionsLength > 0; // footer should not disappear when there is an inline spinner for loading more data
  var shouldDisplayShowMoreButton = status === 'resolved' && !!pageCursor && !areAllResultsLoaded;
  var triggerButtonLabel = formatMessage(!(0, _platformFeatureFlags.fg)('platform-linking-visual-refresh-sllv') && filterType === 'type' ? _messages.asyncPopupSelectMessages.typeLabelOld : _messages.asyncPopupSelectMessages["".concat(filterType, "Label")]);
  return /*#__PURE__*/_react.default.createElement(_popupSelect.FilterPopupSelect, {
    filterName: filterName,
    status: status,
    showLoading: isLoading,
    showHydrating: isJQLHydrating,
    isDisabled: isDisabled,
    totalCount: totalCount,
    shouldShowFooter: shouldShowFooter,
    selectedOptions: selectedOptions,
    options: popupSelectOptions,
    buttonLabel: triggerButtonLabel,
    searchPlaceholder: (0, _platformFeatureFlags.fg)('platform-linking-visual-refresh-sllv') ? formatMessage(_messages.asyncPopupSelectMessages["".concat(filterType, "SearchPlaceholder")]) : undefined,
    onInputChange: handleInputChange,
    onSelectionChange: handleOptionSelection,
    onMenuOpen: handleMenuOpen,
    menuListProps: {
      filterName: filterName,
      isError: isError,
      isEmpty: isEmpty,
      isLoading: isLoading,
      isLoadingMore: isLoadingMore,
      handleShowMore: handleShowMore,
      errors: errors,
      showMore: shouldDisplayShowMoreButton
    }
  });
};
var _default = exports.default = AsyncPopupSelect;