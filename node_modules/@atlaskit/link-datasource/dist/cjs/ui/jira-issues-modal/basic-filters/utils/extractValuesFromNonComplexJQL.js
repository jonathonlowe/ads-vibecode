"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractValuesFromNonComplexJQL = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));
var _jqlAst = require("@atlaskit/jql-ast");
var _isQueryTooComplex = require("./isQueryTooComplex");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
// Map of field keys to their respective clauses in the Jast

var getFieldValues = function getFieldValues(operand) {
  var mapValuesFromList = function mapValuesFromList(value) {
    if (value.operandType === _jqlAst.OPERAND_TYPE_VALUE) {
      return value.value;
    }
    // we only support EMPTY keyword atm, hence making sure if operandType is a KEYWORD, then its an EMPTY keyword
    if (value.operandType === _jqlAst.OPERAND_TYPE_KEYWORD && value.value === _jqlAst.OPERAND_EMPTY) {
      return value.value;
    }
    return undefined;
  };
  switch (operand.operandType) {
    case _jqlAst.OPERAND_TYPE_LIST:
      return operand.values.map(mapValuesFromList).filter(function (value) {
        return !!value;
      });
    case _jqlAst.OPERAND_TYPE_VALUE:
      return operand.value ? [operand.value] : [];
    case _jqlAst.OPERAND_TYPE_KEYWORD:
      return operand.value === _jqlAst.OPERAND_EMPTY ? [operand.value] : [];
    default:
      return [];
  }
};

/**
 * Rather than having to navigate the entire tree structure ourself, we extend AbstractJastVisitor
 * class and implement visitField to walk through each field and value.
 * */
var JqlClauseCollectingVisitor = /*#__PURE__*/function (_AbstractJastVisitor) {
  function JqlClauseCollectingVisitor() {
    var _this;
    (0, _classCallCheck2.default)(this, JqlClauseCollectingVisitor);
    _this = _callSuper(this, JqlClauseCollectingVisitor);
    (0, _defineProperty2.default)(_this, "visitField", function (field) {
      var _field$value;
      var fieldName = (_field$value = field.value) === null || _field$value === void 0 ? void 0 : _field$value.toLowerCase();
      var fieldParent = field.parent;
      if (!fieldParent) {
        return;
      }

      // we do not want to parse and store the order by field+value
      var fieldGrandParent = fieldParent.parent;
      if (fieldGrandParent.type === _jqlAst.NODE_TYPE_ORDER_BY) {
        return;
      }
      var operand = fieldParent.operand;
      var fieldValues = operand && getFieldValues(operand) || [];
      return (0, _defineProperty2.default)({}, fieldName, fieldValues);
    });
    return _this;
  }
  (0, _inherits2.default)(JqlClauseCollectingVisitor, _AbstractJastVisitor);
  return (0, _createClass2.default)(JqlClauseCollectingVisitor, [{
    key: "aggregateResult",
    value: function aggregateResult(aggregate, nextResult) {
      return (0, _mergeWith.default)(aggregate, nextResult, function (destValue, srcValue) {
        return srcValue.concat(destValue !== null && destValue !== void 0 ? destValue : []);
      });
    }
  }, {
    key: "defaultResult",
    value: function defaultResult() {
      return {};
    }
  }]);
}(_jqlAst.AbstractJastVisitor);
var extractValuesFromNonComplexJQL = exports.extractValuesFromNonComplexJQL = function extractValuesFromNonComplexJQL(jql) {
  if ((0, _isQueryTooComplex.isQueryTooComplex)(jql)) {
    return {};
  }
  var jast = new _jqlAst.JastBuilder().build(jql);
  var jqlClauseCollectingVisitor = new JqlClauseCollectingVisitor();
  var mappedValues = jast.query ? jast.query.accept(jqlClauseCollectingVisitor) || {} : {}; // jast.query is defined as void | Query, hence the fallback

  return mappedValues;
};