"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWidthCss = exports.getFieldLabelById = exports.getColumnMinWidth = exports.getColumnAction = exports.getCleanedSelectProps = exports.COLUMN_BASE_WIDTH = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _types = require("../../analytics/types");
var _excluded = ["aria-labelledby"];
var COLUMN_BASE_WIDTH = exports.COLUMN_BASE_WIDTH = 8;
var COLUMN_MIN_WIDTH = COLUMN_BASE_WIDTH * 4;
var keyBasedMinWidthMap = {
  summary: COLUMN_BASE_WIDTH * 26,
  status: COLUMN_BASE_WIDTH * 12.5,
  priority: COLUMN_BASE_WIDTH * 12.5,
  // 100px
  assignee: COLUMN_BASE_WIDTH * 12.5
};
var getColumnMinWidth = exports.getColumnMinWidth = function getColumnMinWidth(key) {
  return keyBasedMinWidthMap[key] || COLUMN_MIN_WIDTH;
};

/**
 * Generate width related portion of css for table cell.
 *
 * @param shouldUseWidth boolean argument defines if a given width is user defined / baked in value
 * or rather default width that should be treated as a maximum width. When table inserted initially
 * and no user custom width defined we set this value to `false`. As soon as user changes any of the
 * column widths we treat all width as custom hardcoded widths.
 * @param width Sometimes set to undefined for last column to make it occupy remainder of the table width
 */
var getWidthCss = exports.getWidthCss = function getWidthCss(_ref) {
  var shouldUseWidth = _ref.shouldUseWidth,
    width = _ref.width;
  if (!width) {
    return {};
  }
  if (shouldUseWidth) {
    return {
      width: width
    };
  } else {
    return {
      maxWidth: width
    };
  }
};

/**
 * This method should be called when one atomic action is performed on columns: adding new item, removing one item, changing items order.
 * The assumption is that since only one action is changed at each time, we don't have to verify the actual contents of the lists.
 */
var getColumnAction = exports.getColumnAction = function getColumnAction(oldVisibleColumnKeys, newVisibleColumnKeys) {
  var newColumnSize = newVisibleColumnKeys.length;
  var oldColumnSize = oldVisibleColumnKeys.length;
  if (newColumnSize > oldColumnSize) {
    return _types.DatasourceAction.COLUMN_ADDED;
  } else if (newColumnSize < oldColumnSize) {
    return _types.DatasourceAction.COLUMN_REMOVED;
  } else {
    return _types.DatasourceAction.COLUMN_REORDERED;
  }
};

/**
 * Remove deprecated `aria-labelledby` prop from select component props.
 */
var getCleanedSelectProps = exports.getCleanedSelectProps = function getCleanedSelectProps(props) {
  // Component Field auto adds `aria-labelledby` prop, which is deprecated and should not be used - https://hello.jira.atlassian.cloud/browse/ENGHEALTH-14529
  var removedLabelByProps = props['aria-labelledby'],
    selectProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  return selectProps;
};

/**
 * Create id for table header to be used as aria-labelledby on form fields.
 */
var getFieldLabelById = exports.getFieldLabelById = function getFieldLabelById(fieldId) {
  return "datasource-header-title-".concat(fieldId);
};