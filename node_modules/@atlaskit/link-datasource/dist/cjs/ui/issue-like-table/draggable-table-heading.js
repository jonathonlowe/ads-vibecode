/* draggable-table-heading.tsx generated by @compiled/babel-plugin v0.36.1 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DraggableTableHeading = void 0;
require("./draggable-table-heading.compiled.css");
var _react = _interopRequireWildcard(require("react"));
var React = _react;
var _runtime = require("@compiled/react/runtime");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _reactIntlNext = require("react-intl-next");
var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));
var _new = _interopRequireDefault(require("@atlaskit/button/new"));
var _dropdownMenu = _interopRequireWildcard(require("@atlaskit/dropdown-menu"));
var _chevronDown = _interopRequireDefault(require("@atlaskit/icon/utility/migration/chevron-down"));
var _chevronUp = _interopRequireDefault(require("@atlaskit/icon/utility/migration/chevron-up"));
var _closestEdge = require("@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge");
var _box = require("@atlaskit/pragmatic-drag-and-drop-react-drop-indicator/box");
var _combine = require("@atlaskit/pragmatic-drag-and-drop/combine");
var _adapter = require("@atlaskit/pragmatic-drag-and-drop/element/adapter");
var _disableNativeDragPreview = require("@atlaskit/pragmatic-drag-and-drop/element/disable-native-drag-preview");
var _pointerOutsideOfPreview = require("@atlaskit/pragmatic-drag-and-drop/element/pointer-outside-of-preview");
var _setCustomNativeDragPreview = require("@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview");
var _preventUnhandled = require("@atlaskit/pragmatic-drag-and-drop/prevent-unhandled");
var _colors = require("@atlaskit/theme/colors");
var _analytics = require("../../analytics");
var _customIcons = require("./custom-icons");
var _messages = require("./messages");
var _utils = require("./utils");
var _excluded = ["as", "style"],
  _excluded2 = ["as", "style"],
  _excluded3 = ["triggerRef"];
/* eslint-disable @atlaskit/design-system/use-tokens-typography */
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled
var TableHeading = (0, _react.forwardRef)(function (_ref, __cmplr) {
  var _ref$as = _ref.as,
    C = _ref$as === void 0 ? "th" : _ref$as,
    __cmpls = _ref.style,
    __cmplp = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  return /*#__PURE__*/React.createElement(C, (0, _extends2.default)({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: (0, _runtime.ax)(["_19itidpf _aks5idpf _1u3bidpf _1s7zl0fh _1o9ml0fh _1oupl0fh _n7zl1on0 _1fqk1on0 _1vvv1on0 _kqswh2mm _rc4eh2mm _q46wh2mm _vchhusvi _1wwnusvi _1gbausvi _vwz41tcg _s99e1tcg _3mvc1tcg _ca0qv77o _7cz2v77o _pcwyv77o _u5f31b66 _1pmc1b66 _11ep1b66 _n3tdv77o _6dd7v77o _191qv77o _19bv1b66 _9iya1b66 _15hu1b66 _4t3iqagn _qccgqagn _xo89qagn _s7n4yfq0 _ntwryfq0 _3eneyfq0 _bfhkchd4 _i7olchd4 _1oe6chd4 _12pn15vq _198v15vq _lura1osq _11681tcg _ab8av77o _11j11b66 _1xanv77o _8lvj1b66 _iscccj1k _1nd0cs5v _1t0u1e54 _1eqz4jg8 _95ex1hna _1hkzidpf _1r3pidpf _10i2idpf _1ls2idpf _ocbzidpf _3tfiidpf _1lhc1b66 _n2z81b66 _3ixo1b66", __cmplp.className])
  }));
});
if (process.env.NODE_ENV !== 'production') {
  TableHeading.displayName = 'TableHeading';
}
// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled -- To migrate as part of go/ui-styling-standard
var DropdownParent = (0, _react.forwardRef)(function (_ref2, __cmplr) {
  var _ref2$as = _ref2.as,
    C = _ref2$as === void 0 ? "div" : _ref2$as,
    __cmpls = _ref2.style,
    __cmplp = (0, _objectWithoutProperties2.default)(_ref2, _excluded2);
  return /*#__PURE__*/React.createElement(C, (0, _extends2.default)({}, __cmplp, {
    style: __cmpls,
    ref: __cmplr,
    className: (0, _runtime.ax)(["_1e0c1txw _4cvr1h6o _o5721q9c _1wtnze3t _ficf1e5h _jq8g1wug _11lvze3t _yhjmze3t", __cmplp.className])
  }));
});
if (process.env.NODE_ENV !== 'production') {
  DropdownParent.displayName = 'DropdownParent';
}
var dropTargetStyles = null;
var noPointerEventsStyles = null;
var resizerStyles = null;
var resizingStyles = null;
var idleState = {
  type: 'idle'
};
var draggingState = {
  type: 'dragging'
};
var DraggableTableHeading = exports.DraggableTableHeading = function DraggableTableHeading(_ref3) {
  var children = _ref3.children,
    id = _ref3.id,
    index = _ref3.index,
    tableId = _ref3.tableId,
    dndPreviewHeight = _ref3.dndPreviewHeight,
    dragPreview = _ref3.dragPreview,
    width = _ref3.width,
    onWidthChange = _ref3.onWidthChange,
    isWrapped = _ref3.isWrapped,
    onIsWrappedChange = _ref3.onIsWrappedChange;
  var _useDatasourceAnalyti = (0, _analytics.useDatasourceAnalyticsEvents)(),
    fireEvent = _useDatasourceAnalyti.fireEvent;
  var mainHeaderCellRef = (0, _react.useRef)(null);
  var columnResizeHandleRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(idleState),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    isDraggingAnyColumn = _useState4[0],
    setIsDraggingAnyColumn = _useState4[1];
  var _useState5 = (0, _react.useState)(null),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    closestEdge = _useState6[0],
    setClosestEdge = _useState6[1];
  var dropTargetRef = (0, _react.useRef)(null);
  /**
   * When width is not set (or callback is not set) we assume not resizing is needed.
   * In our case width won't be set for last cell when table container is bigger than sum of all columns
   */
  var resizeIsEnabled = !!onWidthChange && !!width;
  (0, _react.useEffect)(function () {
    var cell = mainHeaderCellRef.current;
    (0, _tinyInvariant.default)(cell);
    return (0, _combine.combine)((0, _adapter.draggable)({
      element: cell,
      getInitialData: function getInitialData() {
        return {
          type: 'table-header',
          id: id,
          index: index,
          tableId: tableId
        };
      },
      onGenerateDragPreview: function onGenerateDragPreview(_ref4) {
        var nativeSetDragImage = _ref4.nativeSetDragImage;
        (0, _setCustomNativeDragPreview.setCustomNativeDragPreview)({
          getOffset: (0, _pointerOutsideOfPreview.pointerOutsideOfPreview)({
            x: '18px',
            y: '18px'
          }),
          render: function render(_ref5) {
            var container = _ref5.container;
            // Cause a `react` re-render to create your portal synchronously
            setState({
              type: 'preview',
              container: container
            });
            // In our cleanup function: cause a `react` re-render to create remove your portal
            // Note: you can also remove the portal in `onDragStart`,
            // which is when the cleanup function is called
            return function () {
              return setState(draggingState);
            };
          },
          nativeSetDragImage: nativeSetDragImage
        });
      },
      onDragStart: function onDragStart() {
        setState(draggingState);
      },
      onDrop: function onDrop() {
        setState(idleState);
      }
    }));
  }, [id, index, tableId]);

  // Here we handle drop target, that in our case is absolutely positioned div that covers full width and height
  // of this column (has height of whole table). It sits on top of everything, but has `pointerEvents: 'none'` by default
  (0, _react.useEffect)(function () {
    var dropTarget = dropTargetRef.current;
    (0, _tinyInvariant.default)(dropTarget);
    return (0, _adapter.dropTargetForElements)({
      element: dropTarget,
      getIsSticky: function getIsSticky() {
        return true;
      },
      getData: function getData(_ref6) {
        var input = _ref6.input,
          element = _ref6.element;
        var data = {
          id: id,
          index: index
        };
        return (0, _closestEdge.attachClosestEdge)(data, {
          input: input,
          element: element,
          allowedEdges: ['left', 'right']
        });
      },
      canDrop: function canDrop(args) {
        return args.source.data.type === 'table-header' && args.source.data.tableId === tableId;
      },
      onDrag: function onDrag(args) {
        if (args.source.data.id !== id) {
          setClosestEdge((0, _closestEdge.extractClosestEdge)(args.self.data));
        }
      },
      onDragLeave: function onDragLeave() {
        setClosestEdge(null);
      },
      onDrop: function onDrop() {
        setClosestEdge(null);
      }
    });
  }, [id, index, tableId]);

  // During dragging anywhere we want to remove `pointerEvents: 'none'` from all the drop targets
  (0, _react.useEffect)(function () {
    return (0, _adapter.monitorForElements)({
      canMonitor: function canMonitor(_ref7) {
        var source = _ref7.source;
        return source.data.type === 'table-header' && source.data.tableId === tableId;
      },
      onDragStart: function onDragStart() {
        /**
         * Should cause a synchronous re-render.
         */
        setIsDraggingAnyColumn(true);
      },
      onDrop: function onDrop() {
        setIsDraggingAnyColumn(false);
      }
    });
  }, [tableId]);

  // Handling column resizing
  (0, _react.useEffect)(function () {
    if (!resizeIsEnabled) {
      return;
    }
    var resizeHandle = columnResizeHandleRef.current;
    (0, _tinyInvariant.default)(resizeHandle);
    var mainHeaderCell = mainHeaderCellRef.current;
    (0, _tinyInvariant.default)(mainHeaderCell);
    return (0, _adapter.draggable)({
      element: resizeHandle,
      getInitialData: function getInitialData() {
        // metadata related to currently dragging item (can be read by drop events etc)
        return {
          type: 'column-resize',
          id: id,
          index: index,
          tableId: tableId
        };
      },
      // Is called when dragging started
      onGenerateDragPreview: function onGenerateDragPreview(_ref8) {
        var nativeSetDragImage = _ref8.nativeSetDragImage;
        // We don't show any preview, since column separator (handle) is moving with the cursor
        (0, _disableNativeDragPreview.disableNativeDragPreview)({
          nativeSetDragImage: nativeSetDragImage
        });
        // Block drag operations outside `@atlaskit/pragmatic-drag-and-drop`
        _preventUnhandled.preventUnhandled.start();
        setState({
          type: 'resizing',
          initialWidth: width
        });
      },
      onDrag: function onDrag(_ref9) {
        var location = _ref9.location;
        var relativeDistanceX = location.current.input.clientX - location.initial.input.clientX;
        (0, _tinyInvariant.default)(state.type === 'resizing');
        var initialWidth = state.initialWidth;

        // Set the width of our header being resized
        var proposedWidth = initialWidth + relativeDistanceX;
        if (proposedWidth < (0, _utils.getColumnMinWidth)(id)) {
          proposedWidth = (0, _utils.getColumnMinWidth)(id);
        }

        // We update width css directly live
        mainHeaderCell.style.setProperty('width', "".concat(proposedWidth, "px"));
      },
      onDrop: function onDrop() {
        _preventUnhandled.preventUnhandled.stop();
        setState(idleState);
        if (onWidthChange) {
          var cssWidth = +mainHeaderCell.style.getPropertyValue('width').slice(0, -2);
          onWidthChange(cssWidth);
        }
      }
    });
  }, [id, index, onWidthChange, resizeIsEnabled, state, tableId, width]);
  var _useState7 = (0, _react.useState)(false),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    buttonHovered = _useState8[0],
    setButtonHovered = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    isDropdownOpen = _useState10[0],
    setIsDropdownOpen = _useState10[1];
  // Width is not set when it is a last cell in a wide table.
  // We make assumption thus that there is enough width for chevron.
  var isWideEnoughToHaveChevron = !width || width > 76;
  var shouldShowTriggerIcon = (buttonHovered || isDropdownOpen) && isWideEnoughToHaveChevron;
  var triggerIcon = (0, _react.useMemo)(function () {
    return shouldShowTriggerIcon ? isDropdownOpen ? _chevronUp.default : _chevronDown.default : isWideEnoughToHaveChevron ? _customIcons.GlyphPlaceholder : undefined;
  }, [shouldShowTriggerIcon, isDropdownOpen, isWideEnoughToHaveChevron]);
  var getTriggerButton = (0, _react.useCallback)(function (_ref10) {
    var triggerRef = _ref10.triggerRef,
      props = (0, _objectWithoutProperties2.default)(_ref10, _excluded3);
    return /*#__PURE__*/React.createElement(_new.default, (0, _extends2.default)({}, props, {
      testId: "".concat(id, "-column-dropdown"),
      shouldFitContainer: true,
      iconAfter: triggerIcon,
      ref: triggerRef,
      appearance: "subtle",
      spacing: "compact",
      onMouseEnter: function onMouseEnter() {
        return setButtonHovered(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setButtonHovered(false);
      }
    }), children);
  }, [children, id, triggerIcon]);
  var onDropdownOpenChange = (0, _react.useCallback)(function (_ref11) {
    var isOpen = _ref11.isOpen;
    return setIsDropdownOpen(isOpen);
  }, []);
  var toggleWrap = (0, _react.useCallback)(function () {
    if (!onIsWrappedChange) {
      return;
    }
    var nextIsWrap = !(isWrapped || false);
    if (nextIsWrap) {
      fireEvent('ui.button.clicked.wrap', {});
    } else {
      fireEvent('ui.button.clicked.unwrap', {});
    }
    onIsWrappedChange(nextIsWrap);
  }, [fireEvent, isWrapped, onIsWrappedChange]);
  return /*#__PURE__*/React.createElement(TableHeading, {
    ref: mainHeaderCellRef,
    "data-testid": "".concat(id, "-column-heading"),
    style: _objectSpread({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      cursor: 'grab'
    }, (0, _utils.getWidthCss)({
      shouldUseWidth: resizeIsEnabled,
      width: width
    }))
  }, resizeIsEnabled ? /*#__PURE__*/React.createElement("div", {
    ref: columnResizeHandleRef,
    style: {
      height: "".concat(dndPreviewHeight, "px")
    },
    "data-testid": "column-resize-handle",
    className: (0, _runtime.ax)(["_1y7c1ejb _1bsbaakz _80om11mm _16jlidpf _kqswstnw _1pbykb7n _1xi2aesa _154iidpf _1tesidpf _pdyk1hrg _154pidpf _dydkssc3 _1kt9b3bt _1cs8stnw _1rusopvu _1mp4atg7 _qneczvxw _1ct3kb7n", state.type === 'resizing' && "_80omn7od _154pkb7n"])
  }) : null, onIsWrappedChange ? /*#__PURE__*/React.createElement(DropdownParent, null, /*#__PURE__*/React.createElement(_dropdownMenu.default, {
    trigger: getTriggerButton,
    onOpenChange: onDropdownOpenChange,
    placement: 'bottom'
  }, /*#__PURE__*/React.createElement(_dropdownMenu.DropdownItem, {
    elemBefore: isWrapped ? /*#__PURE__*/React.createElement(_customIcons.UnwrapTextIcon, null) : /*#__PURE__*/React.createElement(_customIcons.WrapTextIcon, null),
    testId: "".concat(id, "-column-dropdown-item-toggle-wrapping"),
    onClick: toggleWrap
  }, isWrapped ? /*#__PURE__*/React.createElement(_reactIntlNext.FormattedMessage, _messages.issueLikeTableMessages.unwrapText) : /*#__PURE__*/React.createElement(_reactIntlNext.FormattedMessage, _messages.issueLikeTableMessages.wrapText)))) : children, /*#__PURE__*/React.createElement("div", {
    ref: dropTargetRef,
    style: {
      height: "".concat(dndPreviewHeight, "px")
    },
    "data-testid": 'column-drop-target',
    className: (0, _runtime.ax)(["_kqswstnw _154iidpf _1ltvidpf _1bsb1osq", !isDraggingAnyColumn && "_lcxvglyw"])
  }, closestEdge && /*#__PURE__*/React.createElement(_box.DropIndicator, {
    edge: closestEdge
  })), state.type === 'preview' ? /*#__PURE__*/_reactDom.default.createPortal(dragPreview, state.container) : null);
};