"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useExecuteAtomicAction = exports.useDiscoverActions = exports.useAtomicUpdateActionSchema = exports.actions = exports.ActionsStore = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = require("react");
var _reactSweetState = require("react-sweet-state");
var _linkClientExtension = require("@atlaskit/link-client-extension");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _analytics = require("../../analytics");
var _useErrorLogger2 = _interopRequireDefault(require("../../hooks/useErrorLogger"));
var _index = require("../index");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * Atomic actions available for an integration (by field)
 * @example
 * ```ts
 * {
 *  jira: {
 *    summary: {
 *      actionKey: 'atlassian:work-item:update:summary',
 *      type: 'string'
 *    },
 *    status: {
 *      actionKey: 'atlassian:work-item:update:status',
 *      type: 'string',
 *      fetchAction: {
 *        actionKey: 'atlassian:work-item:get:statuses',
 *        type: 'string',
 *        inputs: {
 *          issueId: {
 *            type: 'string'
 *          }
 *        }
 *      }
 *    }
 *  }
 * }
 * ```
 */

/**
 * Permissions available for a target
 */

/**
 * User permissions for actions on target (ARI) properties
 * @example
 * ```ts
 *	{
 *		'ari:cloud:jira:63cecfe3-16fa-4ee1-8e8d-047cc4b18980:issue/1': {
 *			summary: {
 *				isEditable: true
 *			}
 *		}
 *	}
 * ```
 */

var getInitialState = function getInitialState() {
  return {
    actionsByIntegration: {},
    permissions: {}
  };
};
var actions = exports.actions = {
  discoverActions: function discoverActions(captureError, fireEvent, api, request) {
    return /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {
        var setState, getState, response, _getState, currentActions, currentPermissions, actionsByIntegration, permissions;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              setState = _ref.setState, getState = _ref.getState;
              _context.prev = 1;
              _context.next = 4;
              return api.getDatasourceActionsAndPermissions(request);
            case 4:
              response = _context.sent;
              if ('permissions' in response) {
                _getState = getState(), currentActions = _getState.actionsByIntegration, currentPermissions = _getState.permissions;
                actionsByIntegration = response.actions.reduce(function (acc, action) {
                  var _action$inputs;
                  var fieldKey = action.fieldKey;
                  var fetchAction = (_action$inputs = action.inputs) === null || _action$inputs === void 0 || (_action$inputs = _action$inputs[fieldKey]) === null || _action$inputs === void 0 ? void 0 : _action$inputs.fetchAction;
                  return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2.default)({}, action.integrationKey, _objectSpread(_objectSpread({}, acc[action.integrationKey]), {}, (0, _defineProperty2.default)({}, fieldKey, _objectSpread({
                    actionKey: action.actionKey,
                    type: action.type
                  }, fetchAction && {
                    fetchAction: {
                      actionKey: fetchAction.actionKey,
                      type: fetchAction.type,
                      inputs: fetchAction.inputs
                    }
                  })))));
                }, currentActions);
                permissions = response.permissions.data.reduce(function (acc, permission) {
                  return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2.default)({}, permission.ari, _objectSpread(_objectSpread({}, acc[permission.ari]), {}, (0, _defineProperty2.default)({}, permission.fieldKey, {
                    isEditable: permission.isEditable
                  }))));
                }, currentPermissions);
                setState({
                  actionsByIntegration: actionsByIntegration,
                  permissions: permissions
                });
                fireEvent('operational.actionDiscovery.success', {
                  integrationKey: 'integrationKey' in request ? request.integrationKey : null,
                  datasourceId: 'datasourceId' in request ? request.datasourceId : null,
                  entityType: request.entityType,
                  experience: 'datasource'
                });
              }
              _context.next = 11;
              break;
            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](1);
              /**
               * captureError was already initialised with integrationKey or datasourceId
               */
              captureError('actionDiscovery', _context.t0);
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 8]]);
      }));
      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }();
  }
};
var ActionsStore = exports.ActionsStore = (0, _reactSweetState.createStore)({
  name: 'actions-store',
  initialState: getInitialState(),
  actions: actions
});
var useActionStoreActions = (0, _reactSweetState.createActionsHook)(ActionsStore);
var useDiscoverActions = exports.useDiscoverActions = function useDiscoverActions(_ref3) {
  var captureError = _ref3.captureError,
    fireEvent = _ref3.fireEvent;
  var _useDatasourceClientE = (0, _linkClientExtension.useDatasourceClientExtension)(),
    getDatasourceActionsAndPermissions = _useDatasourceClientE.getDatasourceActionsAndPermissions;
  var _useActionStoreAction = useActionStoreActions(),
    discoverActions = _useActionStoreAction.discoverActions;
  return {
    discoverActions: (0, _react.useMemo)(function () {
      return discoverActions.bind(null, captureError, fireEvent, {
        getDatasourceActionsAndPermissions: getDatasourceActionsAndPermissions
      });
    }, [captureError, discoverActions, fireEvent, getDatasourceActionsAndPermissions])
  };
};
var getFieldUpdateActionByAri = function getFieldUpdateActionByAri(state, _ref4) {
  var _state$permissions$ar, _state$actionsByInteg, _state$actionsByInteg2;
  var ari = _ref4.ari,
    fieldKey = _ref4.fieldKey,
    integrationKey = _ref4.integrationKey;
  var isEditable = (_state$permissions$ar = state.permissions[ari]) === null || _state$permissions$ar === void 0 || (_state$permissions$ar = _state$permissions$ar[fieldKey]) === null || _state$permissions$ar === void 0 ? void 0 : _state$permissions$ar.isEditable;
  if (!isEditable) {
    return {};
  }
  return {
    schema: (_state$actionsByInteg = state.actionsByIntegration[integrationKey]) === null || _state$actionsByInteg === void 0 ? void 0 : _state$actionsByInteg[fieldKey],
    fetchSchema: (_state$actionsByInteg2 = state.actionsByIntegration[integrationKey]) === null || _state$actionsByInteg2 === void 0 || (_state$actionsByInteg2 = _state$actionsByInteg2[fieldKey]) === null || _state$actionsByInteg2 === void 0 ? void 0 : _state$actionsByInteg2.fetchAction
  };
};

/**
 * Retrieves the action schema for a given ARI + fieldKey + integrationKey
 */
var useAtomicUpdateActionSchema = exports.useAtomicUpdateActionSchema = (0, _reactSweetState.createHook)(ActionsStore, {
  selector: getFieldUpdateActionByAri
});
/**
 * Given an ARI + fieldKey + integrationKey
 * Returns an executable action that updates a field on the entity if the user has permissions to do so
 *
 * @example
 * ```tsx
 * const { execute } = useExecuteAtomicAction({ ari, fieldKey: 'summary', integrationKey: 'jira' });
 *
 * return <button onClick={() => execute('New summary')}>Update summary</button>;
 * ```
 */
var useExecuteAtomicAction = exports.useExecuteAtomicAction = function useExecuteAtomicAction(_ref5) {
  var ari = _ref5.ari,
    fieldKey = _ref5.fieldKey,
    integrationKey = _ref5.integrationKey;
  var _useAtomicUpdateActio = useAtomicUpdateActionSchema({
      ari: ari,
      fieldKey: fieldKey,
      integrationKey: integrationKey
    }),
    _useAtomicUpdateActio2 = (0, _slicedToArray2.default)(_useAtomicUpdateActio, 1),
    _useAtomicUpdateActio3 = _useAtomicUpdateActio2[0],
    schema = _useAtomicUpdateActio3.schema,
    fetchSchema = _useAtomicUpdateActio3.fetchSchema;
  var item = (0, _platformFeatureFlags.fg)('enable_datasource_fetch_action_inputs') ?
  // eslint-disable-next-line react-hooks/rules-of-hooks
  (0, _index.useDatasourceItem)({
    id: ari
  }) : undefined;
  var _useDatasourceClientE2 = (0, _linkClientExtension.useDatasourceClientExtension)(),
    executeAction = _useDatasourceClientE2.executeAtomicAction,
    invalidateDatasourceDataCacheByAri = _useDatasourceClientE2.invalidateDatasourceDataCacheByAri;
  var loggerProps = (0, _react.useMemo)(function () {
    return {
      integrationKey: integrationKey
    };
  }, [integrationKey]);
  var _useErrorLogger = (0, _useErrorLogger2.default)(loggerProps),
    captureError = _useErrorLogger.captureError;
  var _useDatasourceAnalyti = (0, _analytics.useDatasourceAnalyticsEvents)(),
    fireEvent = _useDatasourceAnalyti.fireEvent;
  var execute = (0, _react.useCallback)(function (value) {
    if (!schema) {
      throw new Error('No action schema found.');
    }
    return executeAction({
      integrationKey: integrationKey,
      actionKey: schema.actionKey,
      parameters: {
        inputs: (0, _defineProperty2.default)({}, fieldKey, value),
        target: {
          ari: ari
        }
      }
    }).then(function (resp) {
      // Force data to refresh after update
      invalidateDatasourceDataCacheByAri(ari);
      fireEvent('operational.actionExecution.success', {
        integrationKey: integrationKey,
        experience: 'datasource'
      });
      return resp;
    }).catch(function (error) {
      captureError('actionExecution', error);
      // Rethrow up to component for flags and other handling
      throw error;
    });
  }, [schema, executeAction, integrationKey, fieldKey, ari, invalidateDatasourceDataCacheByAri, fireEvent, captureError]);
  var executeFetch = (0, _react.useCallback)(function (controlledInputs) {
    if (!fetchSchema) {
      throw new Error('No supporting action schema found.');
    }

    /**
     * controlled inputs are useful for search fields, where a variable query is passed to the fetchAction
     */
    var inputs = controlledInputs;
    /**
     * When FF is on and `controlledInputs` are not provided we look for required inputs in the fetchSchema
     */
    if (!Object.keys(inputs).length && fetchSchema.inputs && !!Object.keys(fetchSchema.inputs).length && (0, _platformFeatureFlags.fg)('enable_datasource_fetch_action_inputs')) {
      var inputKeys = Object.keys(fetchSchema.inputs);
      /**
       * If present return the input value from the datasource item
       * e.g. this could be the issueKey or projectId of a Jira issue
       */
      inputs = inputKeys.reduce(function (acc, key) {
        var _item$data;
        var value = item === null || item === void 0 || (_item$data = item.data) === null || _item$data === void 0 || (_item$data = _item$data[key]) === null || _item$data === void 0 ? void 0 : _item$data.data;
        if (typeof value === 'string' || typeof value === 'number') {
          acc[key] = value;
        }
        /**
         * This allows for the schema and data from the BE to dynamically set the action inputs
         */
        return acc;
      }, {});
    }

    // A generic type can allow us here to define the inputs and outputs
    return executeAction({
      integrationKey: integrationKey,
      actionKey: fetchSchema.actionKey,
      parameters: {
        inputs: inputs,
        target: {
          ari: ari
        }
      }
    }).then(function (resp) {
      fireEvent('operational.fetchActionExecution.success', {
        integrationKey: integrationKey,
        experience: 'datasource'
      });
      return resp;
    }).catch(function (error) {
      captureError('fetchActionExecution', error);
      // Rethrow up to component for flags and other handling
      throw error;
    });
  }, [fetchSchema, executeAction, integrationKey, ari, item, fireEvent, captureError]);
  return _objectSpread(_objectSpread({}, schema && {
    execute: execute
  }), fetchSchema && {
    executeFetch: executeFetch
  });
};