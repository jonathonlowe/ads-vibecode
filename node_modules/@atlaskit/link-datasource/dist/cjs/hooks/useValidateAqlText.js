"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useValidateAqlText = exports.SEARCH_DEBOUNCE = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _analytics = require("../analytics");
var _cmdbService = require("../services/cmdbService");
var SEARCH_DEBOUNCE = exports.SEARCH_DEBOUNCE = 350;
var useValidateAqlText = exports.useValidateAqlText = function useValidateAqlText(workspaceId, initialValue) {
  var timeout = (0, _react.useRef)();
  var lastValue = (0, _react.useRef)('');
  var lastResult = (0, _react.useRef)(Promise.resolve(undefined));
  var _useState = (0, _react.useState)(initialValue.trim() === '' ? {
      type: 'idle'
    } : {
      type: 'loading'
    }),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    lastValidationResult = _useState2[0],
    setLastValidationResult = _useState2[1];
  var _useDatasourceAnalyti = (0, _analytics.useDatasourceAnalyticsEvents)(),
    fireEvent = _useDatasourceAnalyti.fireEvent;

  // We return undefined when valid and 'error' when invalid
  var validateAqlText = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(aql) {
      var validateAqlResponse, _validateAqlResponse$, _validateAqlResponse$2;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(aql !== null && aql !== void 0 && aql.trim())) {
              _context.next = 18;
              break;
            }
            _context.prev = 1;
            _context.next = 4;
            return (0, _cmdbService.validateAql)(workspaceId, {
              qlQuery: aql
            }, fireEvent);
          case 4:
            validateAqlResponse = _context.sent;
            if (!validateAqlResponse.isValid) {
              _context.next = 10;
              break;
            }
            setLastValidationResult({
              type: 'valid',
              validatedAql: aql
            });
            return _context.abrupt("return", undefined);
          case 10:
            setLastValidationResult({
              type: 'invalid',
              error: (_validateAqlResponse$ = (_validateAqlResponse$2 = validateAqlResponse.errors) === null || _validateAqlResponse$2 === void 0 ? void 0 : _validateAqlResponse$2.iql) !== null && _validateAqlResponse$ !== void 0 ? _validateAqlResponse$ : ''
            });
            return _context.abrupt("return", 'error');
          case 12:
            _context.next = 18;
            break;
          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](1);
            setLastValidationResult({
              type: 'invalid',
              error: ''
            });
            return _context.abrupt("return", 'error');
          case 18:
            setLastValidationResult({
              type: 'idle'
            });
            return _context.abrupt("return", undefined);
          case 20:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 14]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [workspaceId, fireEvent]);

  /* Debounce async validation for input, validation is also called on every field change
   in a form so we need to also memoize. The async validate function is expected to either:
   Immediately return a promise (which is then collected into an array, every single time validation is run),
   or immediately return either undefined or an error message */
  var debouncedValidation = function debouncedValidation(value) {
    return new Promise(function (resolve) {
      if (timeout.current) {
        timeout.current();
      }
      if (value !== lastValue.current) {
        setLastValidationResult({
          type: 'loading'
        });
        var timerId = setTimeout(function () {
          lastValue.current = value;
          lastResult.current = validateAqlText(value);
          resolve(lastResult.current);
        }, SEARCH_DEBOUNCE);
        timeout.current = function () {
          clearTimeout(timerId);
          resolve('debouncing');
        };
      } else {
        resolve(lastResult.current);
      }
    });
  };
  return {
    debouncedValidation: debouncedValidation,
    validateAqlText: validateAqlText,
    lastValidationResult: lastValidationResult
  };
};