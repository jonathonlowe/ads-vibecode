"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logToSentry = exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = require("react");
var _linkingCommon = require("@atlaskit/linking-common");
var _sentry = require("@atlaskit/linking-common/sentry");
var _utils = require("@atlaskit/linking-common/utils");
var _analytics = require("../analytics");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var getNetworkFields = function getNetworkFields(error) {
  switch (true) {
    case error instanceof Response:
      return {
        traceId: (0, _utils.getTraceId)(error),
        status: error.status,
        reason: 'response'
      };
    case error instanceof _linkingCommon.NetworkError:
      return {
        traceId: null,
        status: null,
        reason: 'network'
      };
    case error instanceof Error:
      return {
        traceId: null,
        status: null,
        reason: 'internal'
      };
    default:
      return {
        traceId: null,
        status: null,
        reason: 'unknown'
      };
  }
};
/**
 * This function is just a wrapper around captureException that checks if the enable-sentry-client FF is enabled
 * and error is instanceof Error. We have to override the type of error from captureException to unknown so we use
 * a helper Tail type which removes the first element of the tuple
 */
var logToSentry = exports.logToSentry = function logToSentry(error) {
  if (error instanceof Error) {
    for (var _len = arguments.length, captureExceptionParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      captureExceptionParams[_key - 1] = arguments[_key];
    }
    _sentry.captureException.apply(void 0, [error].concat(captureExceptionParams));
  }
};
var useErrorLogger = function useErrorLogger(loggerProps) {
  var _useDatasourceAnalyti = (0, _analytics.useDatasourceAnalyticsEvents)(),
    fireEvent = _useDatasourceAnalyti.fireEvent;

  /**
   * Sentry is good because it can retrieve name, message, stacktrace of an Error. That's why we will send to Sentry only
   * if an error is instance of `Error`. Sentry is also capable of some PII scrubbing of these risky fields.
   *
   * We will send to Splunk every single time, though, but we won't send PII risky fields.
   */
  var captureError = (0, _react.useCallback)(function (errorLocation, error) {
    var _getNetworkFields = getNetworkFields(error),
      traceId = _getNetworkFields.traceId,
      status = _getNetworkFields.status,
      reason = _getNetworkFields.reason;
    fireEvent('operational.datasource.operationFailed', {
      errorLocation: errorLocation,
      traceId: traceId,
      status: status,
      reason: reason
    });
    logToSentry(error, 'link-datasource', _objectSpread({}, loggerProps));
  }, [fireEvent, loggerProps]);
  return {
    captureError: captureError
  };
};
var _default = exports.default = useErrorLogger;