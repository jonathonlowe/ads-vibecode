"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mention = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _browser = require("@atlaskit/editor-common/browser");
var _mention = require("@atlaskit/editor-common/mention");
var _element = require("@atlaskit/mention/element");
var _resource = require("@atlaskit/mention/resource");
var _types = require("@atlaskit/mention/types");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Workaround for a firefox issue where dom selection is off sync
// https://product-fabric.atlassian.net/browse/ED-12442
var refreshBrowserSelection = function refreshBrowserSelection() {
  var domSelection = window.getSelection();
  if (domSelection) {
    var domRange = domSelection && domSelection.rangeCount === 1 && domSelection.getRangeAt(0).cloneRange();
    if (domRange) {
      domSelection.removeAllRanges();
      domSelection.addRange(domRange);
    }
  }
};
var Mention = exports.Mention = function Mention(props) {
  var accessLevel = props.accessLevel,
    eventHandlers = props.eventHandlers,
    id = props.id,
    text = props.text,
    localId = props.localId,
    mentionProvider = props.mentionProvider,
    profilecardProviderPromise = props.profilecardProvider;
  var _useState = (0, _react.useState)(undefined),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    profilecardProvider = _useState2[0],
    setProfilecardProvider = _useState2[1];
  var resolvedName = useResolvedName(id, text, mentionProvider);

  // Resolve the profilecard provider
  (0, _react.useEffect)(function () {
    var isCancelled = false;
    var resolveProfilecardProvider = /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _profilecardProvider;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return profilecardProviderPromise;
            case 3:
              _profilecardProvider = _context.sent;
              if (!isCancelled) {
                setProfilecardProvider(_profilecardProvider);
              }
              _context.next = 10;
              break;
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);
              if (!isCancelled) {
                setProfilecardProvider(undefined);
              }
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 7]]);
      }));
      return function resolveProfilecardProvider() {
        return _ref.apply(this, arguments);
      };
    }();
    if (profilecardProviderPromise) {
      resolveProfilecardProvider();
    }
    return function () {
      isCancelled = true;
    };
  }, [profilecardProviderPromise]);
  (0, _react.useEffect)(function () {
    // Workaround an issue where the selection is not updated immediately after adding
    // a mention when "sanitizePrivateContent" is enabled in the editor on safari.
    // This affects both insertion and paste behaviour it is applied to the component.
    // https://product-fabric.atlassian.net/browse/ED-14859
    if (_browser.browser.safari) {
      setTimeout(refreshBrowserSelection, 0);
    }
  }, []);
  var actionHandlers = {};
  ['onClick', 'onMouseEnter', 'onMouseLeave'].forEach(function (handler) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    actionHandlers[handler] = eventHandlers && eventHandlers[handler] || function () {};
  });
  if (profilecardProvider) {
    return /*#__PURE__*/_react.default.createElement(_mention.MentionWithProfileCard, (0, _extends2.default)({
      autoFocus: false,
      id: id,
      text: resolvedName,
      accessLevel: accessLevel,
      mentionProvider: mentionProvider,
      profilecardProvider: profilecardProvider,
      localId: localId
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
    }, actionHandlers));
  } else {
    return /*#__PURE__*/_react.default.createElement(_element.ResourcedMention, (0, _extends2.default)({
      id: id,
      text: resolvedName,
      accessLevel: accessLevel,
      mentionProvider: mentionProvider,
      localId: localId
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
    }, actionHandlers));
  }
};
var useResolvedName = function useResolvedName(id, text, mentionProvider) {
  var _useState3 = (0, _react.useState)(text),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    resolvedName = _useState4[0],
    setResolvedName = _useState4[1];
  var processName = function processName(name) {
    if (name.status === _resource.MentionNameStatus.OK) {
      return "@".concat(name.name || '');
    } else {
      return "@_|unknown|_";
    }
  };
  (0, _react.useEffect)(function () {
    if (mentionProvider) {
      mentionProvider.then( /*#__PURE__*/function () {
        var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(provider) {
          var nameDetail;
          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!text && (0, _resource.isResolvingMentionProvider)(provider))) {
                  _context2.next = 13;
                  break;
                }
                nameDetail = provider.resolveMentionName(id);
                if (!(0, _types.isPromise)(nameDetail)) {
                  _context2.next = 10;
                  break;
                }
                _context2.t0 = processName;
                _context2.next = 6;
                return nameDetail;
              case 6:
                _context2.t1 = _context2.sent;
                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1));
              case 10:
                return _context2.abrupt("return", processName(nameDetail));
              case 11:
                _context2.next = 14;
                break;
              case 13:
                return _context2.abrupt("return", text);
              case 14:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }()).then(function (resolvedName) {
        setResolvedName(resolvedName);
      });
    }
  }, [id, text, mentionProvider]);
  return resolvedName;
};