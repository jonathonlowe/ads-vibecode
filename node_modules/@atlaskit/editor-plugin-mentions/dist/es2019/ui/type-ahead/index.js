import React from 'react';
import uuid from 'uuid';
import { TypeAheadAvailableNodes } from '@atlaskit/editor-common/type-ahead';
import { getAnnotationMarksForPos } from '@atlaskit/editor-common/utils';
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { findParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { MENTION_ITEM_HEIGHT, MentionItem } from '@atlaskit/mention/item';
import { isResolvingMentionProvider } from '@atlaskit/mention/resource';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { getMentionPluginState } from '../../pm-plugins/utils';
import InviteItem, { INVITE_ITEM_DESCRIPTION } from '../InviteItem';
import { buildTypeAheadCancelPayload, buildTypeAheadInsertedPayload, buildTypeAheadInviteItemClickedPayload, buildTypeAheadInviteItemViewedPayload, buildTypeAheadRenderedPayload } from './analytics';
import { isInviteItem, isTeamStats, isTeamType, shouldKeepInviteItem } from './utils';
const createInviteItem = ({
  mentionProvider,
  onInviteItemMount
}) => ({
  title: INVITE_ITEM_DESCRIPTION.id,
  render: ({
    isSelected,
    onClick,
    onHover
  }) => /*#__PURE__*/React.createElement(InviteItem, {
    productName: mentionProvider ? mentionProvider.productName : undefined,
    selected: isSelected,
    onMount: onInviteItemMount,
    onMouseEnter: onHover,
    onSelection: onClick,
    userRole: mentionProvider.userRole
  }),
  mention: INVITE_ITEM_DESCRIPTION
});
const withInviteItem = ({
  mentionProvider,
  firstQueryWithoutResults,
  currentQuery,
  onInviteItemMount
}) => mentionItems => {
  const inviteItem = createInviteItem({
    mentionProvider,
    onInviteItemMount
  });
  const keepInviteItem = shouldKeepInviteItem(currentQuery, firstQueryWithoutResults);
  if (mentionItems.length === 0) {
    return keepInviteItem ? [inviteItem] : [];
  }
  return [...mentionItems,
  // invite item should be shown at the bottom
  inviteItem];
};
export const mentionToTypeaheadItem = mention => {
  return {
    title: mention.id,
    render: ({
      isSelected,
      onClick,
      onHover
    }) => /*#__PURE__*/React.createElement(MentionItem, {
      mention: mention,
      selected: isSelected,
      onMouseEnter: onHover,
      onSelection: onClick
    }),
    getCustomComponentHeight: () => {
      return MENTION_ITEM_HEIGHT;
    },
    mention
  };
};
export function memoize(fn) {
  // Cache results here
  const seen = new Map();
  function memoized(mention) {
    // Check cache for hits
    const hit = seen.get(mention.id);
    if (hit) {
      return hit;
    }

    // Generate new result and cache it
    const result = fn(mention);
    seen.set(mention.id, result);
    return result;
  }
  return {
    call: memoized,
    clear: seen.clear.bind(seen)
  };
}
const memoizedToItem = memoize(mentionToTypeaheadItem);
const buildAndSendElementsTypeAheadAnalytics = fireEvent => ({
  query,
  mentions,
  stats
}) => {
  let duration = 0;
  let userOrTeamIds = null;
  let teams = null;
  let xProductMentionsLength = 0;
  if (!isTeamStats(stats)) {
    // is from primary mention endpoint which could be just user mentions or user/team mentions
    duration = stats && stats.duration;
    teams = null;
    userOrTeamIds = mentions.map(mention => mention.id);
    xProductMentionsLength = mentions.filter(mention => mention.isXProductUser).length;
  } else {
    // is from dedicated team-only mention endpoint
    duration = stats && stats.teamMentionDuration;
    userOrTeamIds = null;
    teams = mentions.map(mention => isTeamType(mention.userType) ? {
      teamId: mention.id,
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      includesYou: mention.context.includesYou,
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      memberCount: mention.context.memberCount
    } : null).filter(m => !!m);
  }
  const payload = buildTypeAheadRenderedPayload(duration, userOrTeamIds, query, teams, xProductMentionsLength);
  fireEvent(payload, 'fabric-elements');
};

/**
 * When a team mention is selected, we render a team link and list of member/user mentions
 * in editor content
 */
const buildNodesForTeamMention = (schema, selectedMention, mentionProvider, sanitizePrivateContent) => {
  const {
    nodes,
    marks
  } = schema;
  const {
    name,
    id: teamId,
    accessLevel,
    context
  } = selectedMention;

  // build team link
  const defaultTeamLink = `${window.location.origin}/people/team/${teamId}`;
  const teamLink = context && context.teamLink ? context.teamLink : defaultTeamLink;
  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
  const teamLinkNode = fg('team-mention-inline-smartlink') ? schema.nodes.inlineCard.create({
    url: teamLink
  }) :
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  schema.text(name, [marks.link.create({
    href: teamLink
  })]);
  const openBracketText = schema.text('(');
  const closeBracketText = schema.text(')');
  const emptySpaceText = schema.text(' ');
  const inlineNodes = [teamLinkNode, emptySpaceText, openBracketText];
  const members = context && context.members ? context.members : [];
  members.forEach((member, index) => {
    const {
      name,
      id
    } = member;
    const mentionName = `@${name}`;
    const text = sanitizePrivateContent ? '' : mentionName;
    if (sanitizePrivateContent && isResolvingMentionProvider(mentionProvider)) {
      mentionProvider.cacheMentionName(id, name);
    }
    const userMentionNode = nodes.mention.createChecked({
      text,
      id: member.id,
      accessLevel,
      userType: 'DEFAULT',
      localId: uuid()
    });
    inlineNodes.push(userMentionNode);
    // should not add empty space after the last user mention.
    if (index !== members.length - 1) {
      inlineNodes.push(emptySpaceText);
    }
  });
  inlineNodes.push(closeBracketText);
  return Fragment.fromArray(inlineNodes);
};
export const createTypeAheadConfig = ({
  sanitizePrivateContent,
  mentionInsertDisplayName,
  fireEvent,
  HighlightComponent,
  api,
  handleMentionsChanged
}) => {
  let sessionId = uuid();
  let firstQueryWithoutResults = null;
  const subscriptionKeys = new Set();
  const typeAhead = {
    id: TypeAheadAvailableNodes.MENTION,
    trigger: '@',
    // Custom regex must have a capture group around trigger
    // so it's possible to use it without needing to scan through all triggers again
    customRegex: '\\(?(@)',
    getHighlight: state => {
      const CustomHighlightComponent = HighlightComponent;
      if (CustomHighlightComponent) {
        return /*#__PURE__*/React.createElement(CustomHighlightComponent, null);
      }
      return null;
    },
    getItems({
      query,
      editorState
    }) {
      var _api$contextIdentifie, _api$contextIdentifie2;
      const pluginState = getMentionPluginState(editorState);
      if (!(pluginState !== null && pluginState !== void 0 && pluginState.mentionProvider)) {
        return Promise.resolve([]);
      }
      const {
        mentionProvider
      } = pluginState;
      const {
        contextIdentifierProvider
      } = (_api$contextIdentifie = api === null || api === void 0 ? void 0 : (_api$contextIdentifie2 = api.contextIdentifier) === null || _api$contextIdentifie2 === void 0 ? void 0 : _api$contextIdentifie2.sharedState.currentState()) !== null && _api$contextIdentifie !== void 0 ? _api$contextIdentifie : {};
      return new Promise((resolve, reject) => {
        const key = `loadingMentionsForTypeAhead_${uuid()}`;
        const mentionsSubscribeCallback = (mentions, resultQuery = '', stats) => {
          if (query !== resultQuery) {
            return;
          }
          mentionProvider.unsubscribe(key);
          subscriptionKeys.delete(key);
          const mentionItems = mentions.map(mention => memoizedToItem.call(mention));
          buildAndSendElementsTypeAheadAnalytics(fireEvent)({
            query,
            mentions,
            stats
          });
          if (mentions.length === 0 && firstQueryWithoutResults === null) {
            firstQueryWithoutResults = query;
          }
          if (!mentionProvider.shouldEnableInvite || mentionItems.length > 2) {
            resolve(mentionItems);
          } else {
            const items = withInviteItem({
              mentionProvider,
              firstQueryWithoutResults: firstQueryWithoutResults || '',
              currentQuery: query,
              onInviteItemMount: () => {
                fireEvent(buildTypeAheadInviteItemViewedPayload(sessionId, contextIdentifierProvider, mentionProvider.userRole));
              }
            })(mentionItems);
            resolve(items);
          }
        };
        subscriptionKeys.add(key);
        mentionProvider.subscribe(key, mentionsSubscribeCallback, () => {
          if (editorExperiment('platform_editor_offline_editing_web', true)) {
            mentionProvider.unsubscribe(key);
            subscriptionKeys.delete(key);
            reject('FETCH_ERROR');
          }
        });
        mentionProvider.filter(query || '', {
          ...contextIdentifierProvider,
          sessionId
        });
      });
    },
    onOpen: () => {
      firstQueryWithoutResults = null;
    },
    selectItem(state, item, insert, {
      mode,
      stats,
      query,
      sourceListItem
    }) {
      var _api$contextIdentifie3, _api$contextIdentifie4;
      const {
        schema
      } = state;
      const pluginState = getMentionPluginState(state);
      const {
        mentionProvider
      } = pluginState;
      const {
        id,
        name,
        nickname,
        accessLevel,
        userType,
        isXProductUser
      } = item.mention;
      const trimmedNickname = nickname && nickname.startsWith('@') ? nickname.slice(1) : nickname;
      const renderName = mentionInsertDisplayName || !trimmedNickname ? name : trimmedNickname;
      const {
        contextIdentifierProvider
      } = (_api$contextIdentifie3 = api === null || api === void 0 ? void 0 : (_api$contextIdentifie4 = api.contextIdentifier) === null || _api$contextIdentifie4 === void 0 ? void 0 : _api$contextIdentifie4.sharedState.currentState()) !== null && _api$contextIdentifie3 !== void 0 ? _api$contextIdentifie3 : {};
      const mentionContext = {
        ...contextIdentifierProvider,
        sessionId
      };
      if (mentionProvider && !isInviteItem(item.mention)) {
        mentionProvider.recordMentionSelection(item.mention, mentionContext);
      }

      // use same timer as StatsModifier
      const pickerElapsedTime = stats.startedAt ? performance.now() - stats.startedAt : 0;
      if (mentionProvider && mentionProvider.shouldEnableInvite && isInviteItem(item.mention)) {
        // Don't fire event and the callback with selection by space press
        if (mode !== 'space') {
          fireEvent(buildTypeAheadInviteItemClickedPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, mode, query, contextIdentifierProvider, mentionProvider.userRole));
          if (mentionProvider.onInviteItemClick) {
            mentionProvider.onInviteItemClick('mention');
          }
        }
        return state.tr;
      }
      let taskListId, taskItemId;
      const taskList = findParentNodeOfType(state.schema.nodes.taskList)(state.selection);
      if (taskList) {
        taskListId = taskList.node.attrs.localId;
        const taskItem = findParentNodeOfType(state.schema.nodes.taskItem)(state.selection);
        if (taskItem) {
          taskItemId = taskItem.node.attrs.localId;
        }
      }
      const mentionLocalId = uuid();
      if (handleMentionsChanged) {
        if (taskItemId) {
          handleMentionsChanged([{
            type: 'added',
            localId: mentionLocalId,
            id,
            taskLocalId: taskItemId
          }]);
        } else {
          handleMentionsChanged([{
            type: 'added',
            localId: mentionLocalId,
            id
          }]);
        }
      }
      fireEvent(buildTypeAheadInsertedPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, mode, item.mention, mentionLocalId, sourceListItem.map(x => x.mention), query, contextIdentifierProvider, taskListId, taskItemId));
      sessionId = uuid();
      if (mentionProvider && isTeamType(userType)) {
        return insert(buildNodesForTeamMention(schema, item.mention, mentionProvider, sanitizePrivateContent));
      }
      if (isXProductUser && mentionProvider && mentionProvider.inviteXProductUser) {
        mentionProvider.inviteXProductUser(id, name);
      }

      // Don't insert into document if document data is sanitized.
      const text = sanitizePrivateContent ? '' : `@${renderName}`;
      if (sanitizePrivateContent && isResolvingMentionProvider(mentionProvider)) {
        // Cache (locally) for later rendering
        mentionProvider.cacheMentionName(id, renderName);
      }
      const annotationMarksForPos = fg(
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      'editor_inline_comments_paste_insert_nodes') ? getAnnotationMarksForPos(state.tr.selection.$head) : undefined;
      const mentionNode = schema.nodes.mention.createChecked({
        text,
        id,
        accessLevel,
        userType: userType === 'DEFAULT' ? null : userType,
        localId: mentionLocalId
      }, null,
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
      const space = schema.text(' ',
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
      return insert(Fragment.from([mentionNode, space]));
    },
    dismiss({
      editorState,
      query,
      stats,
      wasItemInserted
    }) {
      firstQueryWithoutResults = null;
      const pickerElapsedTime = stats.startedAt ? performance.now() - stats.startedAt : 0;
      if (!wasItemInserted) {
        fireEvent(buildTypeAheadCancelPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, query || ''), 'fabric-elements');
      }
      const pluginState = getMentionPluginState(editorState);
      if (pluginState !== null && pluginState !== void 0 && pluginState.mentionProvider) {
        const mentionProvider = pluginState.mentionProvider;
        for (const key of subscriptionKeys) {
          mentionProvider.unsubscribe(key);
        }
      }
      subscriptionKeys.clear();
      sessionId = uuid();
    }
  };
  return typeAhead;
};