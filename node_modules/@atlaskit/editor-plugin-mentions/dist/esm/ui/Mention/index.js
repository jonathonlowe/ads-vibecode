import _extends from "@babel/runtime/helpers/extends";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useEffect, useState } from 'react';
import { browser } from '@atlaskit/editor-common/browser';
import { MentionWithProfileCard } from '@atlaskit/editor-common/mention';
import { ResourcedMention } from '@atlaskit/mention/element';
import { isResolvingMentionProvider, MentionNameStatus } from '@atlaskit/mention/resource';
import { isPromise } from '@atlaskit/mention/types';

// Workaround for a firefox issue where dom selection is off sync
// https://product-fabric.atlassian.net/browse/ED-12442
var refreshBrowserSelection = function refreshBrowserSelection() {
  var domSelection = window.getSelection();
  if (domSelection) {
    var domRange = domSelection && domSelection.rangeCount === 1 && domSelection.getRangeAt(0).cloneRange();
    if (domRange) {
      domSelection.removeAllRanges();
      domSelection.addRange(domRange);
    }
  }
};
export var Mention = function Mention(props) {
  var accessLevel = props.accessLevel,
    eventHandlers = props.eventHandlers,
    id = props.id,
    text = props.text,
    localId = props.localId,
    mentionProvider = props.mentionProvider,
    profilecardProviderPromise = props.profilecardProvider;
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    profilecardProvider = _useState2[0],
    setProfilecardProvider = _useState2[1];
  var resolvedName = useResolvedName(id, text, mentionProvider);

  // Resolve the profilecard provider
  useEffect(function () {
    var isCancelled = false;
    var resolveProfilecardProvider = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _profilecardProvider;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return profilecardProviderPromise;
            case 3:
              _profilecardProvider = _context.sent;
              if (!isCancelled) {
                setProfilecardProvider(_profilecardProvider);
              }
              _context.next = 10;
              break;
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);
              if (!isCancelled) {
                setProfilecardProvider(undefined);
              }
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 7]]);
      }));
      return function resolveProfilecardProvider() {
        return _ref.apply(this, arguments);
      };
    }();
    if (profilecardProviderPromise) {
      resolveProfilecardProvider();
    }
    return function () {
      isCancelled = true;
    };
  }, [profilecardProviderPromise]);
  useEffect(function () {
    // Workaround an issue where the selection is not updated immediately after adding
    // a mention when "sanitizePrivateContent" is enabled in the editor on safari.
    // This affects both insertion and paste behaviour it is applied to the component.
    // https://product-fabric.atlassian.net/browse/ED-14859
    if (browser.safari) {
      setTimeout(refreshBrowserSelection, 0);
    }
  }, []);
  var actionHandlers = {};
  ['onClick', 'onMouseEnter', 'onMouseLeave'].forEach(function (handler) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    actionHandlers[handler] = eventHandlers && eventHandlers[handler] || function () {};
  });
  if (profilecardProvider) {
    return /*#__PURE__*/React.createElement(MentionWithProfileCard, _extends({
      autoFocus: false,
      id: id,
      text: resolvedName,
      accessLevel: accessLevel,
      mentionProvider: mentionProvider,
      profilecardProvider: profilecardProvider,
      localId: localId
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
    }, actionHandlers));
  } else {
    return /*#__PURE__*/React.createElement(ResourcedMention, _extends({
      id: id,
      text: resolvedName,
      accessLevel: accessLevel,
      mentionProvider: mentionProvider,
      localId: localId
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
    }, actionHandlers));
  }
};
var useResolvedName = function useResolvedName(id, text, mentionProvider) {
  var _useState3 = useState(text),
    _useState4 = _slicedToArray(_useState3, 2),
    resolvedName = _useState4[0],
    setResolvedName = _useState4[1];
  var processName = function processName(name) {
    if (name.status === MentionNameStatus.OK) {
      return "@".concat(name.name || '');
    } else {
      return "@_|unknown|_";
    }
  };
  useEffect(function () {
    if (mentionProvider) {
      mentionProvider.then( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(provider) {
          var nameDetail;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!text && isResolvingMentionProvider(provider))) {
                  _context2.next = 13;
                  break;
                }
                nameDetail = provider.resolveMentionName(id);
                if (!isPromise(nameDetail)) {
                  _context2.next = 10;
                  break;
                }
                _context2.t0 = processName;
                _context2.next = 6;
                return nameDetail;
              case 6:
                _context2.t1 = _context2.sent;
                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1));
              case 10:
                return _context2.abrupt("return", processName(nameDetail));
              case 11:
                _context2.next = 14;
                break;
              case 13:
                return _context2.abrupt("return", text);
              case 14:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }()).then(function (resolvedName) {
        setResolvedName(resolvedName);
      });
    }
  }, [id, text, mentionProvider]);
  return resolvedName;
};