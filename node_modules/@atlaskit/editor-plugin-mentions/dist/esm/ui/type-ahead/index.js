import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import uuid from 'uuid';
import { TypeAheadAvailableNodes } from '@atlaskit/editor-common/type-ahead';
import { getAnnotationMarksForPos } from '@atlaskit/editor-common/utils';
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { findParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { MENTION_ITEM_HEIGHT, MentionItem } from '@atlaskit/mention/item';
import { isResolvingMentionProvider } from '@atlaskit/mention/resource';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { getMentionPluginState } from '../../pm-plugins/utils';
import InviteItem, { INVITE_ITEM_DESCRIPTION } from '../InviteItem';
import { buildTypeAheadCancelPayload, buildTypeAheadInsertedPayload, buildTypeAheadInviteItemClickedPayload, buildTypeAheadInviteItemViewedPayload, buildTypeAheadRenderedPayload } from './analytics';
import { isInviteItem, isTeamStats, isTeamType, shouldKeepInviteItem } from './utils';
var createInviteItem = function createInviteItem(_ref) {
  var mentionProvider = _ref.mentionProvider,
    onInviteItemMount = _ref.onInviteItemMount;
  return {
    title: INVITE_ITEM_DESCRIPTION.id,
    render: function render(_ref2) {
      var isSelected = _ref2.isSelected,
        onClick = _ref2.onClick,
        onHover = _ref2.onHover;
      return /*#__PURE__*/React.createElement(InviteItem, {
        productName: mentionProvider ? mentionProvider.productName : undefined,
        selected: isSelected,
        onMount: onInviteItemMount,
        onMouseEnter: onHover,
        onSelection: onClick,
        userRole: mentionProvider.userRole
      });
    },
    mention: INVITE_ITEM_DESCRIPTION
  };
};
var withInviteItem = function withInviteItem(_ref3) {
  var mentionProvider = _ref3.mentionProvider,
    firstQueryWithoutResults = _ref3.firstQueryWithoutResults,
    currentQuery = _ref3.currentQuery,
    onInviteItemMount = _ref3.onInviteItemMount;
  return function (mentionItems) {
    var inviteItem = createInviteItem({
      mentionProvider: mentionProvider,
      onInviteItemMount: onInviteItemMount
    });
    var keepInviteItem = shouldKeepInviteItem(currentQuery, firstQueryWithoutResults);
    if (mentionItems.length === 0) {
      return keepInviteItem ? [inviteItem] : [];
    }
    return [].concat(_toConsumableArray(mentionItems), [
    // invite item should be shown at the bottom
    inviteItem]);
  };
};
export var mentionToTypeaheadItem = function mentionToTypeaheadItem(mention) {
  return {
    title: mention.id,
    render: function render(_ref4) {
      var isSelected = _ref4.isSelected,
        onClick = _ref4.onClick,
        onHover = _ref4.onHover;
      return /*#__PURE__*/React.createElement(MentionItem, {
        mention: mention,
        selected: isSelected,
        onMouseEnter: onHover,
        onSelection: onClick
      });
    },
    getCustomComponentHeight: function getCustomComponentHeight() {
      return MENTION_ITEM_HEIGHT;
    },
    mention: mention
  };
};
export function memoize(fn) {
  // Cache results here
  var seen = new Map();
  function memoized(mention) {
    // Check cache for hits
    var hit = seen.get(mention.id);
    if (hit) {
      return hit;
    }

    // Generate new result and cache it
    var result = fn(mention);
    seen.set(mention.id, result);
    return result;
  }
  return {
    call: memoized,
    clear: seen.clear.bind(seen)
  };
}
var memoizedToItem = memoize(mentionToTypeaheadItem);
var buildAndSendElementsTypeAheadAnalytics = function buildAndSendElementsTypeAheadAnalytics(fireEvent) {
  return function (_ref5) {
    var query = _ref5.query,
      mentions = _ref5.mentions,
      stats = _ref5.stats;
    var duration = 0;
    var userOrTeamIds = null;
    var teams = null;
    var xProductMentionsLength = 0;
    if (!isTeamStats(stats)) {
      // is from primary mention endpoint which could be just user mentions or user/team mentions
      duration = stats && stats.duration;
      teams = null;
      userOrTeamIds = mentions.map(function (mention) {
        return mention.id;
      });
      xProductMentionsLength = mentions.filter(function (mention) {
        return mention.isXProductUser;
      }).length;
    } else {
      // is from dedicated team-only mention endpoint
      duration = stats && stats.teamMentionDuration;
      userOrTeamIds = null;
      teams = mentions.map(function (mention) {
        return isTeamType(mention.userType) ? {
          teamId: mention.id,
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          includesYou: mention.context.includesYou,
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          memberCount: mention.context.memberCount
        } : null;
      }).filter(function (m) {
        return !!m;
      });
    }
    var payload = buildTypeAheadRenderedPayload(duration, userOrTeamIds, query, teams, xProductMentionsLength);
    fireEvent(payload, 'fabric-elements');
  };
};

/**
 * When a team mention is selected, we render a team link and list of member/user mentions
 * in editor content
 */
var buildNodesForTeamMention = function buildNodesForTeamMention(schema, selectedMention, mentionProvider, sanitizePrivateContent) {
  var nodes = schema.nodes,
    marks = schema.marks;
  var name = selectedMention.name,
    teamId = selectedMention.id,
    accessLevel = selectedMention.accessLevel,
    context = selectedMention.context;

  // build team link
  var defaultTeamLink = "".concat(window.location.origin, "/people/team/").concat(teamId);
  var teamLink = context && context.teamLink ? context.teamLink : defaultTeamLink;
  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
  var teamLinkNode = fg('team-mention-inline-smartlink') ? schema.nodes.inlineCard.create({
    url: teamLink
  }) :
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  schema.text(name, [marks.link.create({
    href: teamLink
  })]);
  var openBracketText = schema.text('(');
  var closeBracketText = schema.text(')');
  var emptySpaceText = schema.text(' ');
  var inlineNodes = [teamLinkNode, emptySpaceText, openBracketText];
  var members = context && context.members ? context.members : [];
  members.forEach(function (member, index) {
    var name = member.name,
      id = member.id;
    var mentionName = "@".concat(name);
    var text = sanitizePrivateContent ? '' : mentionName;
    if (sanitizePrivateContent && isResolvingMentionProvider(mentionProvider)) {
      mentionProvider.cacheMentionName(id, name);
    }
    var userMentionNode = nodes.mention.createChecked({
      text: text,
      id: member.id,
      accessLevel: accessLevel,
      userType: 'DEFAULT',
      localId: uuid()
    });
    inlineNodes.push(userMentionNode);
    // should not add empty space after the last user mention.
    if (index !== members.length - 1) {
      inlineNodes.push(emptySpaceText);
    }
  });
  inlineNodes.push(closeBracketText);
  return Fragment.fromArray(inlineNodes);
};
export var createTypeAheadConfig = function createTypeAheadConfig(_ref6) {
  var sanitizePrivateContent = _ref6.sanitizePrivateContent,
    mentionInsertDisplayName = _ref6.mentionInsertDisplayName,
    fireEvent = _ref6.fireEvent,
    HighlightComponent = _ref6.HighlightComponent,
    api = _ref6.api,
    handleMentionsChanged = _ref6.handleMentionsChanged;
  var sessionId = uuid();
  var firstQueryWithoutResults = null;
  var subscriptionKeys = new Set();
  var typeAhead = {
    id: TypeAheadAvailableNodes.MENTION,
    trigger: '@',
    // Custom regex must have a capture group around trigger
    // so it's possible to use it without needing to scan through all triggers again
    customRegex: '\\(?(@)',
    getHighlight: function getHighlight(state) {
      var CustomHighlightComponent = HighlightComponent;
      if (CustomHighlightComponent) {
        return /*#__PURE__*/React.createElement(CustomHighlightComponent, null);
      }
      return null;
    },
    getItems: function getItems(_ref7) {
      var _api$contextIdentifie, _api$contextIdentifie2;
      var query = _ref7.query,
        editorState = _ref7.editorState;
      var pluginState = getMentionPluginState(editorState);
      if (!(pluginState !== null && pluginState !== void 0 && pluginState.mentionProvider)) {
        return Promise.resolve([]);
      }
      var mentionProvider = pluginState.mentionProvider;
      var _ref8 = (_api$contextIdentifie = api === null || api === void 0 || (_api$contextIdentifie2 = api.contextIdentifier) === null || _api$contextIdentifie2 === void 0 ? void 0 : _api$contextIdentifie2.sharedState.currentState()) !== null && _api$contextIdentifie !== void 0 ? _api$contextIdentifie : {},
        contextIdentifierProvider = _ref8.contextIdentifierProvider;
      return new Promise(function (resolve, reject) {
        var key = "loadingMentionsForTypeAhead_".concat(uuid());
        var mentionsSubscribeCallback = function mentionsSubscribeCallback(mentions) {
          var resultQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var stats = arguments.length > 2 ? arguments[2] : undefined;
          if (query !== resultQuery) {
            return;
          }
          mentionProvider.unsubscribe(key);
          subscriptionKeys.delete(key);
          var mentionItems = mentions.map(function (mention) {
            return memoizedToItem.call(mention);
          });
          buildAndSendElementsTypeAheadAnalytics(fireEvent)({
            query: query,
            mentions: mentions,
            stats: stats
          });
          if (mentions.length === 0 && firstQueryWithoutResults === null) {
            firstQueryWithoutResults = query;
          }
          if (!mentionProvider.shouldEnableInvite || mentionItems.length > 2) {
            resolve(mentionItems);
          } else {
            var items = withInviteItem({
              mentionProvider: mentionProvider,
              firstQueryWithoutResults: firstQueryWithoutResults || '',
              currentQuery: query,
              onInviteItemMount: function onInviteItemMount() {
                fireEvent(buildTypeAheadInviteItemViewedPayload(sessionId, contextIdentifierProvider, mentionProvider.userRole));
              }
            })(mentionItems);
            resolve(items);
          }
        };
        subscriptionKeys.add(key);
        mentionProvider.subscribe(key, mentionsSubscribeCallback, function () {
          if (editorExperiment('platform_editor_offline_editing_web', true)) {
            mentionProvider.unsubscribe(key);
            subscriptionKeys.delete(key);
            reject('FETCH_ERROR');
          }
        });
        mentionProvider.filter(query || '', _objectSpread(_objectSpread({}, contextIdentifierProvider), {}, {
          sessionId: sessionId
        }));
      });
    },
    onOpen: function onOpen() {
      firstQueryWithoutResults = null;
    },
    selectItem: function selectItem(state, item, insert, _ref9) {
      var _api$contextIdentifie3, _api$contextIdentifie4;
      var mode = _ref9.mode,
        stats = _ref9.stats,
        query = _ref9.query,
        sourceListItem = _ref9.sourceListItem;
      var schema = state.schema;
      var pluginState = getMentionPluginState(state);
      var mentionProvider = pluginState.mentionProvider;
      var _item$mention = item.mention,
        id = _item$mention.id,
        name = _item$mention.name,
        nickname = _item$mention.nickname,
        accessLevel = _item$mention.accessLevel,
        userType = _item$mention.userType,
        isXProductUser = _item$mention.isXProductUser;
      var trimmedNickname = nickname && nickname.startsWith('@') ? nickname.slice(1) : nickname;
      var renderName = mentionInsertDisplayName || !trimmedNickname ? name : trimmedNickname;
      var _ref10 = (_api$contextIdentifie3 = api === null || api === void 0 || (_api$contextIdentifie4 = api.contextIdentifier) === null || _api$contextIdentifie4 === void 0 ? void 0 : _api$contextIdentifie4.sharedState.currentState()) !== null && _api$contextIdentifie3 !== void 0 ? _api$contextIdentifie3 : {},
        contextIdentifierProvider = _ref10.contextIdentifierProvider;
      var mentionContext = _objectSpread(_objectSpread({}, contextIdentifierProvider), {}, {
        sessionId: sessionId
      });
      if (mentionProvider && !isInviteItem(item.mention)) {
        mentionProvider.recordMentionSelection(item.mention, mentionContext);
      }

      // use same timer as StatsModifier
      var pickerElapsedTime = stats.startedAt ? performance.now() - stats.startedAt : 0;
      if (mentionProvider && mentionProvider.shouldEnableInvite && isInviteItem(item.mention)) {
        // Don't fire event and the callback with selection by space press
        if (mode !== 'space') {
          fireEvent(buildTypeAheadInviteItemClickedPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, mode, query, contextIdentifierProvider, mentionProvider.userRole));
          if (mentionProvider.onInviteItemClick) {
            mentionProvider.onInviteItemClick('mention');
          }
        }
        return state.tr;
      }
      var taskListId, taskItemId;
      var taskList = findParentNodeOfType(state.schema.nodes.taskList)(state.selection);
      if (taskList) {
        taskListId = taskList.node.attrs.localId;
        var taskItem = findParentNodeOfType(state.schema.nodes.taskItem)(state.selection);
        if (taskItem) {
          taskItemId = taskItem.node.attrs.localId;
        }
      }
      var mentionLocalId = uuid();
      if (handleMentionsChanged) {
        if (taskItemId) {
          handleMentionsChanged([{
            type: 'added',
            localId: mentionLocalId,
            id: id,
            taskLocalId: taskItemId
          }]);
        } else {
          handleMentionsChanged([{
            type: 'added',
            localId: mentionLocalId,
            id: id
          }]);
        }
      }
      fireEvent(buildTypeAheadInsertedPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, mode, item.mention, mentionLocalId, sourceListItem.map(function (x) {
        return x.mention;
      }), query, contextIdentifierProvider, taskListId, taskItemId));
      sessionId = uuid();
      if (mentionProvider && isTeamType(userType)) {
        return insert(buildNodesForTeamMention(schema, item.mention, mentionProvider, sanitizePrivateContent));
      }
      if (isXProductUser && mentionProvider && mentionProvider.inviteXProductUser) {
        mentionProvider.inviteXProductUser(id, name);
      }

      // Don't insert into document if document data is sanitized.
      var text = sanitizePrivateContent ? '' : "@".concat(renderName);
      if (sanitizePrivateContent && isResolvingMentionProvider(mentionProvider)) {
        // Cache (locally) for later rendering
        mentionProvider.cacheMentionName(id, renderName);
      }
      var annotationMarksForPos = fg(
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      'editor_inline_comments_paste_insert_nodes') ? getAnnotationMarksForPos(state.tr.selection.$head) : undefined;
      var mentionNode = schema.nodes.mention.createChecked({
        text: text,
        id: id,
        accessLevel: accessLevel,
        userType: userType === 'DEFAULT' ? null : userType,
        localId: mentionLocalId
      }, null,
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
      var space = schema.text(' ',
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      fg('editor_inline_comments_paste_insert_nodes') ? annotationMarksForPos : undefined);
      return insert(Fragment.from([mentionNode, space]));
    },
    dismiss: function dismiss(_ref11) {
      var editorState = _ref11.editorState,
        query = _ref11.query,
        stats = _ref11.stats,
        wasItemInserted = _ref11.wasItemInserted;
      firstQueryWithoutResults = null;
      var pickerElapsedTime = stats.startedAt ? performance.now() - stats.startedAt : 0;
      if (!wasItemInserted) {
        fireEvent(buildTypeAheadCancelPayload(pickerElapsedTime, stats.keyCount.arrowUp, stats.keyCount.arrowDown, sessionId, query || ''), 'fabric-elements');
      }
      var pluginState = getMentionPluginState(editorState);
      if (pluginState !== null && pluginState !== void 0 && pluginState.mentionProvider) {
        var mentionProvider = pluginState.mentionProvider;
        var _iterator = _createForOfIteratorHelper(subscriptionKeys),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            mentionProvider.unsubscribe(key);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      subscriptionKeys.clear();
      sessionId = uuid();
    }
  };
  return typeAhead;
};