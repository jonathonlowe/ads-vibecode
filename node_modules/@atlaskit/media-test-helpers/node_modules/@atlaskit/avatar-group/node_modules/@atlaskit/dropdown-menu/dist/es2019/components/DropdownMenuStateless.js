/* eslint-disable react/no-array-index-key */
import React, { Component, Fragment } from 'react';
import { findDOMNode } from 'react-dom';
import { uid } from 'react-uid';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents, } from '@atlaskit/analytics-next';
import Button from '@atlaskit/button';
import Droplist, { Group, Item } from '@atlaskit/droplist';
import ExpandIcon from '@atlaskit/icon/glyph/chevron-down';
import WidthConstrainer from '../styled/WidthConstrainer';
import { KEY_DOWN, KEY_ENTER, KEY_SPACE } from '../util/keys';
import { name as packageName, version as packageVersion, } from '../version.json';
import DropdownItemClickManager from './context/DropdownItemClickManager';
import DropdownItemFocusManager from './context/DropdownItemFocusManager';
import DropdownItemSelectionCache from './context/DropdownItemSelectionCache';
export class DropdownMenuStateless extends Component {
    constructor() {
        super(...arguments);
        this.dropdownListPositioned = false;
        this.state = {
            id: uid({ id: this.constructor.name }),
            autoFocusDropdownItems: false,
        };
        this.componentDidMount = () => {
            if (this.isUsingDeprecatedAPI()) {
                if (process.env.NODE_ENV !== 'test' &&
                    process.env.NODE_ENV !== 'production' &&
                    !process.env.CI) {
                    // eslint-disable-next-line no-console
                    console.log('DropdownMenu.items is deprecated. Please switch to the declarative API.');
                }
                if (this.domItemsList) {
                    this.focusFirstItem();
                }
            }
        };
        this.componentDidUpdate = (prevProp) => {
            if (this.isUsingDeprecatedAPI() && this.props.isOpen && !prevProp.isOpen) {
                this.focusFirstItem();
            }
        };
        this.getNextFocusable = (indexItem, available) => {
            if (!this.domItemsList) {
                return null;
            }
            let currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
            const latestAvailable = typeof available !== 'number' ? currentItem : available;
            if (currentItem < this.domItemsList.length - 1) {
                currentItem++;
                if (this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
                    return currentItem;
                }
                return this.getNextFocusable(currentItem, latestAvailable);
            }
            return latestAvailable;
        };
        this.getPrevFocusable = (indexItem, available) => {
            if (!this.domItemsList) {
                return null;
            }
            let currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
            const latestAvailable = typeof available !== 'number' ? currentItem : available;
            if (currentItem && currentItem > 0) {
                currentItem--;
                if (this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
                    return currentItem;
                }
                return this.getPrevFocusable(currentItem, latestAvailable);
            }
            return latestAvailable || currentItem;
        };
        this.focusFirstItem = () => {
            if (this.sourceOfIsOpen === 'keydown') {
                this.focusItem(this.getNextFocusable());
            }
        };
        this.focusNextItem = () => {
            this.focusItem(this.getNextFocusable(this.focusedItem));
        };
        this.focusPreviousItem = () => {
            this.focusItem(this.getPrevFocusable(this.focusedItem));
        };
        this.focusItem = (index) => {
            if (!this.domItemsList || !index) {
                return;
            }
            this.focusedItem = index;
            this.domItemsList[this.focusedItem].focus();
        };
        this.isTargetChildItem = (target) => {
            if (!target)
                return false;
            const isDroplistItem = target.getAttribute('data-role') === 'droplistItem';
            // eslint-disable-next-line react/no-find-dom-node
            const thisDom = findDOMNode(this);
            return isDroplistItem && thisDom ? thisDom.contains(target) : false;
        };
        this.handleKeyboardInteractionForClosed = (event) => {
            if (this.props.isOpen) {
                return;
            }
            switch (event.key) {
                case KEY_DOWN:
                case KEY_SPACE:
                case KEY_ENTER:
                    event.preventDefault();
                    this.open({ event, source: 'keydown' });
                    break;
                default:
                    break;
            }
        };
        this.handleKeyboardInteractionsDeprecated = (event) => {
            if (this.props.isOpen) {
                if (this.isTargetChildItem(event.target)) {
                    switch (event.key) {
                        case 'ArrowUp':
                            event.preventDefault();
                            this.focusPreviousItem();
                            break;
                        case 'ArrowDown':
                            event.preventDefault();
                            this.focusNextItem();
                            break;
                        case 'Tab':
                            event.preventDefault();
                            this.close({ event });
                            break;
                        default:
                            break;
                    }
                }
                else if (event.key === 'ArrowDown') {
                    this.sourceOfIsOpen = 'keydown';
                    this.focusFirstItem();
                }
                else if (event.key === 'Tab') {
                    this.close({ event });
                }
            }
            else {
                switch (event.key) {
                    case KEY_DOWN:
                    case KEY_SPACE:
                    case KEY_ENTER:
                        event.preventDefault();
                        this.open({ event, source: 'keydown' });
                        break;
                    default:
                        break;
                }
            }
        };
        this.domMenuContainer = null;
        this.isUsingDeprecatedAPI = () => Boolean(this.props.items.length);
        this.handleOpenChange = (args) => {
            this.props.onOpenChange(args);
        };
        this.triggerContent = () => {
            const { children, trigger, isOpen, triggerButtonProps, triggerType, testId, } = this.props;
            const insideTriggerContent = this.isUsingDeprecatedAPI()
                ? children
                : trigger;
            if (triggerType !== 'button') {
                return insideTriggerContent;
            }
            // we probably don't need to object copying
            // ts doesn't like destructuring copy - so converting to object.assign
            const triggerProps = Object.assign({}, triggerButtonProps);
            const defaultButtonProps = {
                'aria-controls': this.state.id,
                'aria-expanded': isOpen,
                'aria-haspopup': true,
                isSelected: isOpen,
            };
            if (!triggerProps.iconAfter && !triggerProps.iconBefore) {
                triggerProps.iconAfter = React.createElement(ExpandIcon, { size: "medium", label: "" });
            }
            return (React.createElement(Button, Object.assign({}, defaultButtonProps, triggerProps, { testId: testId && `${testId}--trigger` }), insideTriggerContent));
        };
        this.open = (attrs) => {
            this.sourceOfIsOpen = attrs.source;
            this.props.onOpenChange({ isOpen: true, event: attrs.event });
            // Dropdown opened via keyboard gets auto focussed
            this.setState({
                autoFocusDropdownItems: this.sourceOfIsOpen === 'keydown',
            });
        };
        this.close = (attrs) => {
            this.sourceOfIsOpen = null;
            this.props.onOpenChange({ isOpen: false, event: attrs.event });
        };
        this.toggle = (attrs) => {
            if (attrs.source === 'keydown')
                return;
            if (this.props.isOpen) {
                this.close(attrs);
            }
            else {
                this.open(attrs);
            }
        };
        this.renderTrigger = () => {
            const triggerContent = this.triggerContent();
            return this.isUsingDeprecatedAPI() ? (triggerContent) : (React.createElement("div", { ref: ref => {
                    this.triggerContainer = ref;
                } }, triggerContent));
        };
        this.renderItems = (items) => items.map((item, itemIndex) => (React.createElement(Item, Object.assign({}, item, { key: itemIndex, onActivate: ({ event }) => {
                this.props.onItemActivated({ item, event });
            } }), item.content)));
        this.renderGroups = (groups) => groups.map((group, groupIndex) => (React.createElement(Group, { heading: group.heading, elemAfter: group.elemAfter, key: groupIndex }, this.renderItems(group.items))));
        this.renderDeprecated = () => {
            const { items, shouldFitContainer } = this.props;
            const { id } = this.state;
            return (React.createElement("div", { id: id, ref: ref => {
                    this.domMenuContainer = ref;
                    this.domItemsList = ref
                        ? ref.querySelectorAll('[data-role="droplistItem"]')
                        : null;
                }, role: "menu", style: shouldFitContainer ? undefined : { maxWidth: 300 } }, this.renderGroups(items)));
        };
        /** Ensure droplist is positioned before focussing to avoid container scrolling to top */
        this.onDroplistPositioned = () => {
            this.dropdownListPositioned = true;
            // Trigger render so item focus manager can auto focus for keyboard trigger
            this.setState({
                autoFocusDropdownItems: this.sourceOfIsOpen === 'keydown',
            });
            if (this.props.onPositioned)
                this.props.onPositioned();
        };
        /** Render focusManager only after droplist has been positioned when trigger via keyboard */
        this.renderDropdownItems = () => {
            if (this.sourceOfIsOpen === 'keydown' && this.dropdownListPositioned) {
                return (React.createElement(DropdownItemFocusManager, { autoFocus: this.state.autoFocusDropdownItems, close: this.close }, this.props.children));
            }
            return React.createElement(Fragment, null, this.props.children);
        };
    }
    handleClickDeprecated(event) {
        const menuContainer = this.domMenuContainer;
        if (!menuContainer ||
            (menuContainer && !menuContainer.contains(event.target))) {
            this.toggle({ source: 'click', event });
        }
    }
    handleClick(event) {
        // For any clicks we don't want autofocus
        this.setState({ autoFocusDropdownItems: false });
        if (this.isUsingDeprecatedAPI()) {
            this.handleClickDeprecated(event);
            return;
        }
        if (this.triggerContainer &&
            this.triggerContainer.contains(event.target) &&
            event.target.disabled !== true) {
            const { isOpen } = this.props;
            this.sourceOfIsOpen = 'mouse';
            this.props.onOpenChange({ isOpen: !isOpen, event });
        }
    }
    render() {
        const { appearance, boundariesElement, isLoading, isOpen, onOpenChange, position, isMenuFixed, shouldAllowMultilineItems, shouldFitContainer, shouldFlip, testId, } = this.props;
        const { id } = this.state;
        const isDeprecated = this.isUsingDeprecatedAPI();
        const deprecatedProps = isDeprecated
            ? {
                onKeyDown: this.handleKeyboardInteractionsDeprecated,
                shouldAllowMultilineItems,
            }
            : {
                onKeyDown: this.handleKeyboardInteractionForClosed,
            };
        return (React.createElement(DropdownItemSelectionCache, null,
            React.createElement(Droplist, Object.assign({ appearance: appearance, boundariesElement: boundariesElement, isLoading: isLoading, isOpen: isOpen, onClick: (e) => this.handleClick(e), onOpenChange: this.handleOpenChange, position: position, isMenuFixed: isMenuFixed, shouldFitContainer: shouldFitContainer, shouldFlip: shouldFlip, trigger: this.renderTrigger(), onPositioned: this.onDroplistPositioned }, deprecatedProps, { analyticsContext: {
                    componentName: 'dropdownMenu',
                    packageName,
                    packageVersion,
                }, testId: testId }), isDeprecated ? (this.renderDeprecated()) : (React.createElement(WidthConstrainer, { id: id, role: "menu", shouldFitContainer: shouldFitContainer },
                React.createElement(DropdownItemClickManager, { onItemClicked: (event) => onOpenChange({ isOpen: false, event }) }, this.renderDropdownItems()))))));
    }
}
DropdownMenuStateless.defaultProps = {
    appearance: 'default',
    boundariesElement: 'viewport',
    isLoading: false,
    isOpen: false,
    items: [],
    onItemActivated: () => { },
    onOpenChange: () => { },
    position: 'bottom left',
    isMenuFixed: false,
    shouldAllowMultilineItems: false,
    shouldFitContainer: false,
    shouldFlip: true,
    triggerType: 'default',
    onPositioned: () => { },
};
export { DropdownMenuStateless as DropdownMenuStatelessWithoutAnalytics };
const createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
    componentName: 'dropdownMenu',
    packageName,
    packageVersion,
})(withAnalyticsEvents({
    onOpenChange: createAndFireEventOnAtlaskit({
        action: 'toggled',
        actionSubject: 'dropdownMenu',
        attributes: {
            componentName: 'dropdownMenu',
            packageName,
            packageVersion,
        },
    }),
})(DropdownMenuStateless));
//# sourceMappingURL=DropdownMenuStateless.js.map