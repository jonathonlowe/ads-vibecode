"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var utils_1 = require("./utils");
function useInView(options) {
    if (options === void 0) { options = {}; }
    var ref = react_1.default.useRef();
    var observerInstance = react_1.default.useRef();
    var _a = tslib_1.__read(react_1.default.useState({
        inView: false,
        entry: undefined,
        target: undefined,
    }), 2), state = _a[0], setState = _a[1];
    var threshold = options.threshold, root = options.root, rootMargin = options.rootMargin;
    var setRef = react_1.default.useCallback(function (node) {
        var supportsIntersectionObserver = utils_1.browser.supportsIntersectionObserver;
        if (!supportsIntersectionObserver) {
            setState({
                inView: true,
                entry: undefined,
                target: node,
            });
            return null;
        }
        observerInstance.current = new IntersectionObserver(function (entries) {
            if (entries && entries.length) {
                var intersection = entries[0];
                var isIntersecting = intersection.isIntersecting, intersectionRatio = intersection.intersectionRatio;
                if (intersectionRatio >= 0) {
                    var inView = intersectionRatio >= (threshold || 0);
                    if (isIntersecting !== undefined) {
                        inView = inView && isIntersecting;
                    }
                    setState({
                        inView: inView,
                        entry: intersection,
                        target: node,
                    });
                }
            }
        }, {
            threshold: threshold,
            root: root,
            rootMargin: rootMargin,
        });
        if (ref.current) {
            observerInstance.current.unobserve(ref.current);
        }
        if (node) {
            observerInstance.current.observe(node);
        }
        // Store a reference to the node
        ref.current = node;
    }, [threshold, root, rootMargin]);
    /**
     * Unsubscribe IntersectionObserver before unmounting a component.
     */
    react_1.default.useEffect(function () {
        return function () {
            if (observerInstance.current && ref.current) {
                observerInstance.current.unobserve(ref.current);
            }
        };
    }, []);
    return [setRef, state.inView, state.target, state.entry];
}
exports.useInView = useInView;
//# sourceMappingURL=hooks.js.map