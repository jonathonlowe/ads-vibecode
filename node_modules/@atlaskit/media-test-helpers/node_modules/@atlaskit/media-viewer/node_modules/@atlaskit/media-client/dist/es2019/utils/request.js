import { parse, stringify } from 'query-string';
import { isClientBasedAuth } from '@atlaskit/media-core';
import { mapAuthToQueryParameters } from '../models/auth-query-parameters';
class HttpError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.message = message;
        this.statusCode = statusCode;
    }
}
const processFetchResponse = async (response) => {
    if (response.ok || response.redirected) {
        return response;
    }
    else {
        const text = await response.text();
        throw new HttpError(`Got error code ${response.status}: ${text}`, response.status);
    }
};
export function request(url, options = {}, controller) {
    const { method = 'GET', auth, params, headers, body, retryOptions = {}, } = options;
    const doFetch = () => fetch(createUrl(url, { params }), {
        method,
        body,
        headers: withAuth(auth)(headers),
        signal: controller && controller.signal,
    }).then(processFetchResponse);
    return promiseRetry(doFetch, retryOptions);
}
export function mapResponseToJson(response) {
    return response.json();
}
export function mapResponseToBlob(response) {
    return response.blob();
}
export function mapResponseToVoid() {
    return Promise.resolve();
}
export function createUrl(url, { params, auth }) {
    const { baseUrl, queryParams } = extract(url);
    const authParams = auth && mapAuthToQueryParameters(auth);
    const queryString = stringify({
        ...queryParams,
        ...params,
        ...authParams,
    });
    const shouldAppendQueryString = queryString.length > 0;
    return `${baseUrl}${shouldAppendQueryString ? `?${queryString}` : ''}`;
}
function withAuth(auth) {
    return (headers) => {
        if (auth) {
            return {
                ...(headers || {}),
                ...mapAuthToRequestHeaders(auth),
            };
        }
        else {
            return headers;
        }
    };
}
function extract(url) {
    const index = url.indexOf('?');
    if (index > 0) {
        return {
            baseUrl: url.substring(0, index),
            queryParams: parse(url.substring(index + 1, url.length)),
        };
    }
    else {
        return {
            baseUrl: url,
        };
    }
}
function mapAuthToRequestHeaders(auth) {
    if (isClientBasedAuth(auth)) {
        return {
            'X-Client-Id': auth.clientId,
            Authorization: `Bearer ${auth.token}`,
        };
    }
    else {
        return {
            'X-Issuer': auth.asapIssuer,
            Authorization: `Bearer ${auth.token}`,
        };
    }
}
const DEFAULT_OPTIONS = {
    attempts: 5,
    startTimeoutInMs: 1000,
    factor: 2,
};
const wait = (timeoutInMs) => new Promise(resolve => {
    setTimeout(resolve, timeoutInMs);
});
// fetch throws TypeError for network errors
const isNotFetchNetworkError = (e) => !(e instanceof TypeError);
export const isAbortedRequestError = (e) => e.message === 'request_cancelled' || e.name === 'AbortError';
async function promiseRetry(functionToRetry, overwriteOptions = {}) {
    const options = {
        ...DEFAULT_OPTIONS,
        ...overwriteOptions,
    };
    let timeoutInMs = options.startTimeoutInMs;
    const waitAndBumpTimeout = async () => {
        await wait(timeoutInMs);
        timeoutInMs *= options.factor;
    };
    for (let i = 1; i <= options.attempts; i++) {
        try {
            return await functionToRetry();
        }
        catch (err) {
            // don't retry if request was aborted by user
            if (isAbortedRequestError(err)) {
                return Promise.reject(err);
            }
            const isLastAttempt = i === options.attempts;
            if ((isNotFetchNetworkError(err) && err.statusCode < 500) ||
                isLastAttempt) {
                return Promise.reject(new Error(`The call did not succeed after ${i} attempts. Last error is ${err.message}`));
            }
            else {
                await waitAndBumpTimeout();
            }
        }
    }
    return Promise.reject(new Error('Exhaused all attempts'));
}
//# sourceMappingURL=request.js.map