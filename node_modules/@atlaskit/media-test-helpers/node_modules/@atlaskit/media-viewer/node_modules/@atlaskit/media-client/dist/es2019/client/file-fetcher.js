import { ReplaySubject } from 'rxjs/ReplaySubject';
import uuid from 'uuid/v4';
import Dataloader from 'dataloader';
import { authToOwner } from '@atlaskit/media-core';
import { downloadUrl } from '@atlaskit/media-common/downloadUrl';
import { MediaStore, uploadFile, mapMediaItemToFileState, getFileStreamsCache, mapMediaFileToFileState, globalMediaEventEmitter, RECENTS_COLLECTION, } from '..';
import isValidId from 'uuid-validate';
import { getMediaTypeFromUploadableFile } from '../utils/getMediaTypeFromUploadableFile';
import { overrideMediaTypeIfUnknown } from '../utils/overrideMediaTypeIfUnknown';
import { convertBase64ToBlob } from '../utils/convertBase64ToBlob';
import { observableToPromise } from '../utils/observableToPromise';
import { getDimensionsFromBlob, } from '../utils/getDimensionsFromBlob';
import { getMediaTypeFromMimeType } from '../utils/getMediaTypeFromMimeType';
import { createFileStateSubject } from '../utils/createFileStateSubject';
import { isMimeTypeSupportedByBrowser } from '../utils/isMimeTypeSupportedByBrowser';
const POLLING_INTERVAL = 3000;
const maxNumberOfItemsPerCall = 100;
const makeCacheKey = (id, collection) => collection ? `${id}-${collection}` : id;
const isDataloaderErrorResult = (result) => {
    return result.error instanceof Error;
};
export const getItemsFromKeys = (dataloaderKeys, fileItems) => {
    const itemsByKey = fileItems.reduce((prev, nextFileItem) => {
        const { id, collection } = nextFileItem;
        const key = makeCacheKey(id, collection);
        prev[key] = isDataloaderErrorResult(nextFileItem)
            ? nextFileItem
            : nextFileItem.details;
        return prev;
    }, {});
    return dataloaderKeys.map(dataloaderKey => {
        const { id, collection } = dataloaderKey;
        const key = makeCacheKey(id, collection);
        return itemsByKey[key];
    });
};
export class FileFetcherImpl {
    constructor(mediaStore) {
        this.mediaStore = mediaStore;
        // Returns an array of the same length as the keys filled with file items
        this.batchLoadingFunc = async (keys) => {
            const nonCollectionName = '__media-single-file-collection__';
            const fileIdsByCollection = keys.reduce((prev, next) => {
                const collectionName = next.collection || nonCollectionName;
                const fileIds = prev[collectionName] || [];
                fileIds.push(next.id);
                prev[collectionName] = fileIds;
                return prev;
            }, {});
            const items = [];
            await Promise.all(Object.keys(fileIdsByCollection).map(async (collectionNameKey) => {
                const fileIds = fileIdsByCollection[collectionNameKey];
                const collectionName = collectionNameKey === nonCollectionName
                    ? undefined
                    : collectionNameKey;
                try {
                    const response = await this.mediaStore.getItems(fileIds, collectionName);
                    items.push(...response.data.items);
                }
                catch (error) {
                    fileIds.forEach(fileId => {
                        items.push({
                            id: fileId,
                            error: error || new Error('Failed to fetch'),
                            collection: collectionName,
                        });
                    });
                }
            }));
            return getItemsFromKeys(keys, items);
        };
        this.createDownloadFileStream = (id, collection) => {
            const subject = createFileStateSubject();
            let timeoutId;
            const fetchFile = async () => {
                try {
                    const response = await this.dataloader.load({ id, collection });
                    if (!response) {
                        return;
                    }
                    if (isDataloaderErrorResult(response)) {
                        subject.error(response);
                        return;
                    }
                    const fileState = mapMediaItemToFileState(id, response);
                    subject.next(fileState);
                    if (fileState.status === 'processing') {
                        timeoutId = window.setTimeout(fetchFile, POLLING_INTERVAL);
                    }
                    else {
                        subject.complete();
                    }
                }
                catch (e) {
                    window.clearTimeout(timeoutId);
                    subject.error(e);
                }
            };
            fetchFile();
            return subject;
        };
        this.dataloader = new Dataloader(this.batchLoadingFunc, {
            maxBatchSize: maxNumberOfItemsPerCall,
        });
    }
    getFileState(id, options) {
        if (!isValidId(id)) {
            const subject = createFileStateSubject();
            subject.error('invalid id was passed to getFileState');
            return subject;
        }
        return getFileStreamsCache().getOrInsert(id, () => {
            const collection = options && options.collectionName;
            return this.createDownloadFileStream(id, collection);
        });
    }
    getCurrentState(id, options) {
        return observableToPromise(this.getFileState(id, options));
    }
    getArtifactURL(artifacts, artifactName, collectionName) {
        return this.mediaStore.getArtifactURL(artifacts, artifactName, collectionName);
    }
    getFileBinaryURL(id, collectionName) {
        return this.mediaStore.getFileBinaryURL(id, collectionName);
    }
    touchFiles(descriptors, collection) {
        return this.mediaStore
            .touchFiles({ descriptors }, { collection })
            .then(({ data }) => data);
    }
    generateUploadableFileUpfrontIds(collection) {
        const id = uuid();
        const occurrenceKey = uuid();
        const touchFileDescriptor = {
            fileId: id,
            occurrenceKey,
            collection,
        };
        const deferredUploadId = this.touchFiles([touchFileDescriptor], collection).then(touchedFiles => touchedFiles.created[0].uploadId);
        return {
            id,
            occurrenceKey,
            deferredUploadId,
        };
    }
    async uploadExternal(url, collection) {
        const uploadableFileUpfrontIds = this.generateUploadableFileUpfrontIds(collection);
        const { id, occurrenceKey } = uploadableFileUpfrontIds;
        const subject = createFileStateSubject();
        const deferredBlob = fetch(url)
            .then(response => response.blob())
            .catch(() => undefined);
        const preview = new Promise(async (resolve, reject) => {
            const blob = await deferredBlob;
            if (!blob) {
                reject('Could not fetch the blob');
            }
            resolve({ value: blob, origin: 'remote' });
        });
        const name = url.split('/').pop() || '';
        // we create a initial fileState with the minimum info that we have at this point
        const fileState = {
            status: 'processing',
            name,
            size: 0,
            mediaType: 'unknown',
            mimeType: '',
            id,
            occurrenceKey,
            preview,
        };
        subject.next(fileState);
        // we save it into the cache as soon as possible, in case someone subscribes
        getFileStreamsCache().set(id, subject);
        return new Promise(async (resolve, reject) => {
            const blob = await deferredBlob;
            if (!blob) {
                return reject('Could not download remote file');
            }
            const { type, size } = blob;
            const file = {
                content: blob,
                mimeType: type,
                collection,
                name,
            };
            const mediaType = getMediaTypeFromMimeType(type);
            // we emit a richer state after the blob is fetched
            subject.next({
                status: 'processing',
                name,
                size,
                mediaType,
                mimeType: type,
                id,
                occurrenceKey,
                preview,
            });
            // we don't want to wait for the file to be upload
            this.upload(file, undefined, uploadableFileUpfrontIds);
            const dimensions = await getDimensionsFromBlob(blob);
            resolve({
                dimensions,
                uploadableFileUpfrontIds,
            });
        });
    }
    upload(file, controller, uploadableFileUpfrontIds) {
        if (typeof file.content === 'string') {
            file.content = convertBase64ToBlob(file.content);
        }
        const { content, name = '', // name property is not available in base64 image
        collection, } = file;
        if (!uploadableFileUpfrontIds) {
            uploadableFileUpfrontIds = this.generateUploadableFileUpfrontIds(collection);
        }
        const id = uploadableFileUpfrontIds.id;
        const occurrenceKey = uploadableFileUpfrontIds.occurrenceKey;
        let mimeType = '';
        let size = 0;
        let preview;
        // TODO [MSW-796]: get file size for base64
        const mediaType = getMediaTypeFromUploadableFile(file);
        const subject = createFileStateSubject();
        let processingSubscription;
        if (content instanceof Blob) {
            size = content.size;
            mimeType = content.type;
            if (isMimeTypeSupportedByBrowser(content.type)) {
                preview = {
                    value: content,
                    origin: 'local',
                };
            }
        }
        const stateBase = {
            id,
            occurrenceKey,
            name,
            size,
            mediaType,
            mimeType,
            preview,
        };
        const onProgress = (progress) => {
            subject.next({
                status: 'uploading',
                ...stateBase,
                progress,
            });
        };
        const onUploadFinish = (error) => {
            if (error) {
                if (error !== 'canceled') {
                    // Specific error coming from chunkinator via rejected fileId promise.
                    // We do not want to trigger error in this case.
                    const message = error instanceof Error ? error.message : error;
                    subject.next({
                        id,
                        status: 'error',
                        message,
                    });
                }
                return subject.error(error);
            }
            if (!isMimeTypeSupportedByBrowser(mimeType)) {
                processingSubscription = this.createDownloadFileStream(id, collection).subscribe({
                    next: remoteFileState => subject.next({
                        // merges base state with remote state
                        ...stateBase,
                        ...remoteFileState,
                        ...overrideMediaTypeIfUnknown(remoteFileState, mediaType),
                    }),
                    error: err => subject.error(err),
                    complete: () => subject.complete(),
                });
            }
            else {
                subject.next({
                    status: 'processing',
                    representations: {},
                    ...stateBase,
                });
                subject.complete();
            }
        };
        const { cancel } = uploadFile(file, this.mediaStore, uploadableFileUpfrontIds, {
            onUploadFinish,
            onProgress,
        });
        getFileStreamsCache().set(id, subject);
        // We should report progress asynchronously, since this is what consumer expects
        // (otherwise in newUploadService file-converting event will be emitted before files-added)
        setTimeout(() => {
            onProgress(0);
        }, 0);
        if (controller) {
            controller.setAbort(() => {
                cancel();
                if (processingSubscription) {
                    processingSubscription.unsubscribe();
                }
            });
        }
        return subject;
    }
    async downloadBinary(id, name = 'download', collectionName) {
        const url = await this.mediaStore.getFileBinaryURL(id, collectionName);
        downloadUrl(url, { name });
        globalMediaEventEmitter.emit('media-viewed', {
            fileId: id,
            isUserCollection: collectionName === RECENTS_COLLECTION,
            viewingLevel: 'download',
        });
    }
    async copyFile(source, destination) {
        const { authProvider, collection: sourceCollection, id } = source;
        const { authProvider: destinationAuthProvider, collection: destinationCollectionName, replaceFileId, occurrenceKey, } = destination;
        const mediaStore = new MediaStore({
            authProvider: destinationAuthProvider,
        });
        const owner = authToOwner(await authProvider({ collectionName: sourceCollection }));
        const body = {
            sourceFile: {
                id,
                collection: sourceCollection,
                owner,
            },
        };
        const params = {
            collection: destinationCollectionName,
            replaceFileId,
            occurrenceKey,
        };
        const copiedFile = (await mediaStore.copyFileWithToken(body, params)).data;
        const copiedFileObservable = new ReplaySubject(1);
        const copiedFileState = mapMediaFileToFileState({
            data: copiedFile,
        });
        copiedFileObservable.next(copiedFileState);
        getFileStreamsCache().set(copiedFile.id, copiedFileObservable);
        return copiedFile;
    }
}
//# sourceMappingURL=file-fetcher.js.map