"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var media_client_1 = require("@atlaskit/media-client");
var deep_equal_1 = tslib_1.__importDefault(require("deep-equal"));
var media_ui_1 = require("@atlaskit/media-ui");
var react_intl_1 = require("react-intl");
var domain_1 = require("./domain");
var styled_1 = require("./styled");
var media_type_icon_1 = require("@atlaskit/media-ui/media-type-icon");
var error_1 = require("./error");
var download_1 = require("./download");
var initialState = {
    item: domain_1.Outcome.pending(),
};
var Header = /** @class */ (function (_super) {
    tslib_1.__extends(Header, _super);
    function Header() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = initialState;
        _this.renderDownload = function () {
            var item = _this.state.item;
            var _a = _this.props, identifier = _a.identifier, mediaClient = _a.mediaClient;
            return item.match({
                pending: function () { return download_1.DisabledToolbarDownloadButton; },
                failed: function () { return download_1.DisabledToolbarDownloadButton; },
                successful: function (item) { return (react_1.default.createElement(download_1.ToolbarDownloadButton, { state: item, identifier: identifier, mediaClient: mediaClient })); },
            });
        };
        _this.renderSidebarButton = function () {
            var _a = _this.props, extensions = _a.extensions, isSidebarVisible = _a.isSidebarVisible, onSidebarButtonClick = _a.onSidebarButtonClick;
            if (extensions && extensions.sidebar) {
                return (react_1.default.createElement(media_ui_1.MediaButton, { isSelected: isSidebarVisible, testId: "media-viewer-sidebar-button", appearance: 'toolbar', onClick: onSidebarButtonClick, iconBefore: extensions.sidebar.icon }));
            }
        };
        _this.renderSize = function (item) {
            if (item.size) {
                return _this.renderSeparator() + media_ui_1.toHumanReadableMediaSize(item.size);
            }
            else {
                return '';
            }
        };
        _this.renderSeparator = function () {
            return ' Â· ';
        };
        _this.renderFileTypeText = function (mediaType) {
            var mediaTypeTranslationMap = {
                doc: media_ui_1.messages.document,
                audio: media_ui_1.messages.audio,
                video: media_ui_1.messages.video,
                image: media_ui_1.messages.image,
                unknown: media_ui_1.messages.unknown,
            };
            var message = mediaTypeTranslationMap[mediaType || 'unknown'];
            // Defaulting to unknown again since backend has more mediaTypes than the current supported ones
            return react_1.default.createElement(react_intl_1.FormattedMessage, tslib_1.__assign({}, (message || media_ui_1.messages.unknown)));
        };
        _this.getMediaIcon = function (mediaType) {
            return react_1.default.createElement(media_type_icon_1.MediaTypeIcon, { type: mediaType });
        };
        return _this;
    }
    Header.prototype.UNSAFE_componentWillUpdate = function (nextProps) {
        if (this.needsReset(this.props, nextProps)) {
            this.release();
            this.init(nextProps);
        }
    };
    Header.prototype.componentDidMount = function () {
        this.init(this.props);
    };
    Header.prototype.componentWillUnmount = function () {
        this.release();
    };
    Header.prototype.init = function (props) {
        var _this = this;
        this.setState(initialState, function () {
            var mediaClient = props.mediaClient, identifier = props.identifier;
            if (media_client_1.isExternalImageIdentifier(identifier)) {
                var _a = identifier.name, name_1 = _a === void 0 ? identifier.dataURI : _a;
                // Simulate a processing file state to render right metadata
                var fileState = {
                    status: 'processing',
                    id: name_1,
                    mediaType: 'image',
                    mimeType: 'image/',
                    name: name_1,
                    representations: {},
                    size: 0,
                };
                _this.setState({
                    item: domain_1.Outcome.successful(fileState),
                });
                return;
            }
            var id = identifier.id;
            _this.subscription = mediaClient.file
                .getFileState(id, {
                collectionName: identifier.collectionName,
            })
                .subscribe({
                next: function (file) {
                    _this.setState({
                        item: domain_1.Outcome.successful(file),
                    });
                },
                error: function (err) {
                    _this.setState({
                        item: domain_1.Outcome.failed(error_1.createError('metadataFailed', err)),
                    });
                },
            });
        });
    };
    Header.prototype.render = function () {
        return (react_1.default.createElement(styled_1.Header, { className: media_ui_1.hideControlsClassName },
            react_1.default.createElement(styled_1.LeftHeader, null, this.renderMetadata()),
            react_1.default.createElement(styled_1.RightHeader, null,
                this.renderSidebarButton(),
                this.renderDownload())));
    };
    Header.prototype.renderMetadata = function () {
        var _this = this;
        var item = this.state.item;
        return item.match({
            successful: function (item) { return _this.renderMetadataLayout(item); },
            pending: function () { return null; },
            failed: function () { return null; },
        });
    };
    Header.prototype.renderMetadataLayout = function (item) {
        if (item.status === 'processed' || item.status === 'processing') {
            return (react_1.default.createElement(styled_1.MetadataWrapper, null,
                react_1.default.createElement(styled_1.MetadataIconWrapper, null, this.getMediaIcon(item.mediaType)),
                react_1.default.createElement(styled_1.MedatadataTextWrapper, null,
                    react_1.default.createElement(styled_1.MetadataFileName, { "data-testid": "media-viewer-file-name" }, item.name || react_1.default.createElement(react_intl_1.FormattedMessage, tslib_1.__assign({}, media_ui_1.messages.unknown))),
                    react_1.default.createElement(styled_1.MetadataSubText, { "data-testid": "media-viewer-file-metadata-text" },
                        this.renderFileTypeText(item.mediaType),
                        this.renderSize(item)))));
        }
        else {
            return null;
        }
    };
    Header.prototype.needsReset = function (propsA, propsB) {
        return (!deep_equal_1.default(propsA.identifier, propsB.identifier) ||
            propsA.mediaClient !== propsB.mediaClient);
    };
    Header.prototype.release = function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    return Header;
}(react_1.default.Component));
exports.Header = Header;
exports.default = react_intl_1.injectIntl(Header);
//# sourceMappingURL=header.js.map