import React from 'react';
import { isAbortedRequestError, isImageRepresentationReady, isImageMimeTypeSupportedByBrowser, isErrorFileState, addFileAttrsToUrl, } from '@atlaskit/media-client';
import { getOrientation } from '@atlaskit/media-ui';
import { Outcome } from '../../domain';
import { createError } from '../../error';
import { InteractiveImg } from './interactive-img';
import { BaseViewer } from '../base-viewer';
function processedFileStateToMediaItem(file) {
    return {
        type: 'file',
        details: {
            id: file.id,
        },
    };
}
export class ImageViewer extends BaseViewer {
    constructor() {
        super(...arguments);
        this.onLoad = () => {
            this.props.onLoad({ status: 'success' });
            this.onMediaDisplayed();
        };
        this.onError = () => {
            this.props.onLoad({
                status: 'error',
                errorMessage: 'Interactive-img render failed',
            });
        };
    }
    get initialState() {
        return { content: Outcome.pending() };
    }
    async init() {
        const { item: file, mediaClient, collectionName } = this.props;
        if (file.status === 'error') {
            return;
        }
        try {
            let orientation = 1;
            let objectUrl;
            let originalBinaryImageUrl;
            let isLocalFileReference = false;
            const { preview } = file;
            if (preview) {
                const { value, origin } = await preview;
                if (value instanceof Blob) {
                    orientation = await getOrientation(value);
                    objectUrl = URL.createObjectURL(value);
                    isLocalFileReference = origin === 'local';
                }
                else {
                    objectUrl = value;
                }
            }
            else if (isImageRepresentationReady(file)) {
                const item = processedFileStateToMediaItem(file);
                const controller = typeof AbortController !== 'undefined'
                    ? new AbortController()
                    : undefined;
                const response = mediaClient.getImage(item.details.id, {
                    collection: collectionName,
                    mode: 'fit',
                }, controller, true);
                this.cancelImageFetch = () => controller && controller.abort();
                objectUrl = URL.createObjectURL(await response);
            }
            else {
                this.setState({
                    content: Outcome.pending(),
                });
                return;
            }
            if (!isLocalFileReference && // objectUrl at this point is binary file already
                !isErrorFileState(file) &&
                file.status !== 'uploading' &&
                file.mediaType === 'image' &&
                isImageMimeTypeSupportedByBrowser(file.mimeType)) {
                originalBinaryImageUrl = await mediaClient.file.getFileBinaryURL(file.id);
            }
            this.setState({
                content: Outcome.successful({
                    objectUrl,
                    orientation,
                    originalBinaryImageUrl,
                }),
            });
        }
        catch (err) {
            // TODO : properly handle aborted requests (MS-2843)
            if (!isAbortedRequestError(err)) {
                this.setState({
                    content: Outcome.failed(createError('previewFailed', err, file)),
                });
                const errorMessage = err.message || err.name;
                this.props.onLoad({ status: 'error', errorMessage });
            }
        }
    }
    release() {
        if (this.cancelImageFetch) {
            this.cancelImageFetch();
        }
        this.state.content.whenSuccessful(({ objectUrl }) => {
            this.revokeObjectUrl(objectUrl);
        });
    }
    // This method is spied on by some test cases, so don't rename or remove it.
    revokeObjectUrl(objectUrl) {
        URL.revokeObjectURL(objectUrl);
    }
    renderSuccessful(content) {
        const { item, onClose, contextId, collectionName } = this.props;
        const src = contextId
            ? addFileAttrsToUrl(content.objectUrl, {
                id: item.id,
                contextId,
                collection: collectionName,
            })
            : content.objectUrl;
        return (React.createElement(InteractiveImg, { onLoad: this.onLoad, onError: this.onError, src: src, originalBinaryImageSrc: content.originalBinaryImageUrl, orientation: content.orientation, onClose: onClose }));
    }
}
//# sourceMappingURL=index.js.map