import React from 'react';
import { isExternalImageIdentifier, isFileIdentifier, } from '@atlaskit/media-client';
import { FormattedMessage } from 'react-intl';
import { messages } from '@atlaskit/media-ui';
import { Outcome } from './domain';
import { ImageViewer } from './viewers/image';
import { VideoViewer } from './viewers/video';
import { DocViewer } from './viewers/doc';
import { Spinner } from './loading';
import deepEqual from 'deep-equal';
import ErrorMessage, { createError, } from './error';
import { ErrorViewDownloadButton } from './download';
import { withAnalyticsEvents, } from '@atlaskit/analytics-next';
import { mediaFileCommencedEvent, mediaFileLoadSucceededEvent, mediaFileLoadFailedEvent, } from './analytics/item-viewer';
import { channel } from './analytics/index';
import { AudioViewer } from './viewers/audio';
import { InteractiveImg } from './viewers/image/interactive-img';
const initialState = {
    item: Outcome.pending(),
};
export class ItemViewerBase extends React.Component {
    constructor() {
        super(...arguments);
        this.state = initialState;
        this.onImageViewerLoaded = (payload) => {
            const { item } = this.state;
            // the item.whenFailed case is handled in the "init" method
            item.whenSuccessful(fileState => {
                if (fileState.status === 'processed') {
                    const { identifier } = this.props;
                    if (payload.status === 'success') {
                        this.fireAnalytics(mediaFileLoadSucceededEvent(fileState));
                    }
                    else if (payload.status === 'error' && isFileIdentifier(identifier)) {
                        const { id } = identifier;
                        this.fireAnalytics(mediaFileLoadFailedEvent(id, payload.errorMessage || 'ImageViewer error', fileState));
                    }
                }
            });
        };
        this.onCanPlay = (fileState) => () => {
            if (fileState.status === 'processed') {
                this.fireAnalytics(mediaFileLoadSucceededEvent(fileState));
            }
        };
        this.onError = (fileState) => () => {
            if (fileState.status === 'processed') {
                this.fireAnalytics(mediaFileLoadFailedEvent(fileState.id, 'Playback failed', fileState));
            }
        };
        this.onDocError = (fileState) => (error) => {
            const processedFileState = fileState.status === 'processed' ? fileState : undefined;
            this.fireAnalytics(mediaFileLoadFailedEvent(fileState.id, `${error.name}: ${error.message}`, processedFileState));
        };
        this.fireAnalytics = (payload) => {
            const { createAnalyticsEvent } = this.props;
            if (createAnalyticsEvent) {
                const ev = createAnalyticsEvent(payload);
                ev.fire(channel);
            }
        };
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        if (this.needsReset(this.props, nextProps)) {
            this.release();
            this.setState(initialState);
        }
    }
    componentDidUpdate(oldProps) {
        if (this.needsReset(oldProps, this.props)) {
            this.init(this.props);
        }
    }
    componentWillUnmount() {
        this.release();
    }
    componentDidMount() {
        this.init(this.props);
    }
    renderFileState(item) {
        if (item.status === 'error') {
            return this.renderError('previewFailed', item);
        }
        const { mediaClient, identifier, showControls, onClose, previewCount, isSidebarVisible, contextId, } = this.props;
        const collectionName = isFileIdentifier(identifier)
            ? identifier.collectionName
            : undefined;
        const viewerProps = {
            mediaClient,
            item,
            collectionName,
            onClose,
            previewCount,
        };
        switch (item.mediaType) {
            case 'image':
                return (React.createElement(ImageViewer, Object.assign({ onLoad: this.onImageViewerLoaded, contextId: contextId }, viewerProps)));
            case 'audio':
                return (React.createElement(AudioViewer, Object.assign({ showControls: showControls, onCanPlay: this.onCanPlay(item), onError: this.onError(item) }, viewerProps)));
            case 'video':
                return (React.createElement(VideoViewer, Object.assign({ showControls: showControls, onCanPlay: this.onCanPlay(item), onError: this.onError(item) }, viewerProps)));
            case 'doc':
                return (React.createElement(DocViewer, Object.assign({ onSuccess: this.onCanPlay(item), onError: this.onDocError(item), isSidebarVisible: isSidebarVisible }, viewerProps)));
            default:
                return this.renderError('unsupported', item);
        }
    }
    renderError(errorName, file) {
        if (file) {
            const err = createError(errorName, undefined, file);
            return (React.createElement(ErrorMessage, { error: err },
                React.createElement("p", null,
                    React.createElement(FormattedMessage, Object.assign({}, messages.try_downloading_file))),
                this.renderDownloadButton(file, err)));
        }
        else {
            return React.createElement(ErrorMessage, { error: createError(errorName) });
        }
    }
    render() {
        const { identifier } = this.props;
        const { item } = this.state;
        if (isExternalImageIdentifier(identifier)) {
            const { dataURI } = identifier;
            return React.createElement(InteractiveImg, { src: dataURI });
        }
        return item.match({
            successful: item => {
                switch (item.status) {
                    case 'processed':
                    case 'uploading':
                    case 'processing':
                        return this.renderFileState(item);
                    case 'failed-processing':
                        return this.renderError('failedProcessing', item);
                    case 'error':
                        return this.renderError('previewFailed', item);
                    default:
                        return React.createElement(Spinner, null);
                }
            },
            pending: () => React.createElement(Spinner, null),
            failed: err => this.renderError(err.errorName, item.data),
        });
    }
    renderDownloadButton(state, err) {
        const { mediaClient, identifier } = this.props;
        const collectionName = isFileIdentifier(identifier)
            ? identifier.collectionName
            : undefined;
        return (React.createElement(ErrorViewDownloadButton, { state: state, mediaClient: mediaClient, err: err, collectionName: collectionName }));
    }
    init(props) {
        const { mediaClient, identifier } = props;
        if (isExternalImageIdentifier(identifier)) {
            return;
        }
        const { id } = identifier;
        this.fireAnalytics(mediaFileCommencedEvent(id));
        this.subscription = mediaClient.file
            .getFileState(id, {
            collectionName: identifier.collectionName,
        })
            .subscribe({
            next: file => {
                this.setState({
                    item: Outcome.successful(file),
                });
            },
            error: err => {
                this.setState({
                    item: Outcome.failed(createError('metadataFailed', err)),
                });
                this.fireAnalytics(mediaFileLoadFailedEvent(id, 'Metadata fetching failed'));
            },
        });
    }
    // It's possible that a different identifier or mediaClient was passed.
    // We therefore need to reset Media Viewer.
    needsReset(propsA, propsB) {
        return (!deepEqual(propsA.identifier, propsB.identifier) ||
            propsA.mediaClient !== propsB.mediaClient);
    }
    release() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
export const ItemViewer = withAnalyticsEvents()(ItemViewerBase);
//# sourceMappingURL=item-viewer.js.map