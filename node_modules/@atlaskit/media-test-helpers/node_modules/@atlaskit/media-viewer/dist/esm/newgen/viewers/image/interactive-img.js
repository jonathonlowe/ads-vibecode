import { __extends } from "tslib";
import React from 'react';
import { Camera, getCssFromImageOrientation, hideControlsClassName, Rectangle, Vector2, } from '@atlaskit/media-ui';
import { MAX_RESOLUTION } from '@atlaskit/media-client/constants';
import { withAnalyticsEvents, } from '@atlaskit/analytics-next';
import HDIcon from '@atlaskit/icon/glyph/vid-hd-circle';
import Spinner from '@atlaskit/spinner';
import { B75, B200, DN400, DN60, N0 } from '@atlaskit/theme/colors';
import { BaselineExtend, HDIconGroupWrapper, HDIconWrapper, ImageWrapper, Img, } from '../../styled';
import { ZoomLevel } from '../../domain/zoomLevel';
import { closeOnDirectClick } from '../../utils/closeOnDirectClick';
import { ZoomControls } from '../../zoomControls';
import { closedEvent } from '../../analytics/closed';
import { channel } from '../../analytics';
export function zoomLevelAfterResize(newCamera, oldCamera, oldZoomLevel) {
    var isImgScaledToFit = oldZoomLevel.value === oldCamera.scaleDownToFit;
    var zoomLevelToRefit = new ZoomLevel(newCamera.scaleDownToFit);
    return isImgScaledToFit ? zoomLevelToRefit : oldZoomLevel;
}
var clientRectangle = function (el) {
    var clientWidth = el.clientWidth, clientHeight = el.clientHeight;
    return new Rectangle(clientWidth, clientHeight);
};
var naturalSizeRectangle = function (el) {
    var naturalWidth = el.naturalWidth, naturalHeight = el.naturalHeight;
    return new Rectangle(naturalWidth, naturalHeight);
};
var initialState = {
    zoomLevel: new ZoomLevel(1),
    isHDActive: false,
    isHDActivating: false,
    isHDAvailable: false,
    isDragging: false,
    cursorPos: new Vector2(0, 0),
    hasBeenLoadedOnce: false,
};
var InteractiveImgComponent = /** @class */ (function (_super) {
    __extends(InteractiveImgComponent, _super);
    function InteractiveImgComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = initialState;
        _this.saveWrapperRef = function (ref) { return (_this.wrapper = ref); };
        _this.onImageClicked = function (e) {
            var _a = _this.props, onClose = _a.onClose, onBlanketClicked = _a.onBlanketClicked;
            if (e.target === e.currentTarget && onBlanketClicked) {
                onBlanketClicked();
            }
            closeOnDirectClick(onClose)(e);
        };
        _this.onImgLoad = function (ev) {
            var _a = _this.props, onLoad = _a.onLoad, originalBinaryImageSrc = _a.originalBinaryImageSrc;
            var _b = _this.state, hasBeenLoadedOnce = _b.hasBeenLoadedOnce, oldZoomLevel = _b.zoomLevel, currentCamera = _b.camera;
            var _c = _this.state, isHDActivating = _c.isHDActivating, isHDAvailable = _c.isHDAvailable, isHDActive = _c.isHDActive;
            if (!_this.wrapper) {
                return;
            }
            var viewport = clientRectangle(_this.wrapper);
            var originalImgRect = naturalSizeRectangle(ev.currentTarget);
            var camera = new Camera(viewport, originalImgRect);
            var newZoomLevel;
            if (hasBeenLoadedOnce && currentCamera) {
                /* This is not first time image is loading. Likely due to new (HD) image is loaded.
                 * In order to keep new image on the same perceived zoom level we need to scale.
                 * It depends on ration between old and new images and current zoom level.
                 * For example:
                 * - old image is 2000px with zoom at 50% (0.5). New image is 4000px. 2000/4000 * 0.5 = 0.25 (25%)
                 * - old image is 2000px with zoom at 200% (2). New image is 4000px. 2000/4000 * 2 = 1 (100%)
                 */
                var previousImageWidth = currentCamera.originalImg.width;
                var newImageWidth = originalImgRect.width;
                newZoomLevel = new ZoomLevel((previousImageWidth / newImageWidth) * oldZoomLevel.value);
                isHDActivating = false;
            }
            else {
                newZoomLevel = new ZoomLevel(camera.scaleDownToFit);
                // If initial (non-HD) image is equal to MAX resolution -
                // this means most likely original image had higher res (because non-HD is downsized and caped off with MAX res)
                isHDAvailable =
                    !!originalBinaryImageSrc &&
                        (originalImgRect.width === MAX_RESOLUTION ||
                            originalImgRect.height === MAX_RESOLUTION);
                // Automatically activate HD on first load if zoom level is already 100% or bigger
                isHDActive = newZoomLevel.value >= 1;
                if (onLoad) {
                    // Call onLoad only once on initial image render
                    onLoad();
                }
            }
            _this.setState({
                camera: camera,
                zoomLevel: newZoomLevel,
                hasBeenLoadedOnce: true,
                isHDActivating: isHDActivating,
                isHDAvailable: isHDAvailable,
                isHDActive: isHDActive,
            });
        };
        _this.onResize = function () {
            var camera = _this.state.camera;
            if (!_this.wrapper || !camera) {
                return;
            }
            var oldZoomLevel = _this.state.zoomLevel;
            var newViewport = clientRectangle(_this.wrapper);
            var newCamera = camera.resizedViewport(newViewport);
            var newZoomLevel = zoomLevelAfterResize(newCamera, camera, oldZoomLevel);
            _this.setState({
                camera: newCamera,
                zoomLevel: newZoomLevel,
            });
        };
        _this.onZoomChange = function (nextZoomLevel) {
            var camera = _this.state.camera;
            var wrapper = _this.wrapper;
            if (!wrapper || !camera) {
                return;
            }
            var scrollLeft = wrapper.scrollLeft, scrollTop = wrapper.scrollTop;
            var prevOffset = new Vector2(scrollLeft, scrollTop);
            var _a = _this.state, prevZoomLevel = _a.zoomLevel, prevIsHDActive = _a.isHDActive, prevIsHDActivating = _a.isHDActivating;
            var isHDActive = prevIsHDActive || nextZoomLevel.value >= 1;
            var isHDActivating = prevIsHDActivating || (!prevIsHDActive && isHDActive);
            _this.setState({
                zoomLevel: nextZoomLevel,
                isHDActive: isHDActive,
                isHDActivating: isHDActivating,
            }, function () {
                var _a = camera.scaledOffset(prevOffset, prevZoomLevel.value, nextZoomLevel.value), x = _a.x, y = _a.y;
                wrapper.scrollLeft = x;
                wrapper.scrollTop = y;
            });
        };
        _this.startDragging = function (ev) {
            ev.preventDefault();
            _this.setState({
                isDragging: true,
                cursorPos: new Vector2(ev.screenX, ev.screenY),
            });
        };
        _this.stopDragging = function (ev) {
            ev.preventDefault();
            _this.setState({ isDragging: false });
        };
        _this.panImage = function (ev) {
            if (_this.state.isDragging && _this.wrapper) {
                var cursorPos = new Vector2(ev.screenX, ev.screenY);
                var delta = _this.state.cursorPos.sub(cursorPos);
                _this.setState({ cursorPos: cursorPos });
                _this.wrapper.scrollLeft += delta.x;
                _this.wrapper.scrollTop += delta.y;
            }
        };
        return _this;
    }
    InteractiveImgComponent.prototype.componentDidMount = function () {
        this.state = initialState;
        window.addEventListener('resize', this.onResize);
        document.addEventListener('mousemove', this.panImage);
        document.addEventListener('mouseup', this.stopDragging);
    };
    InteractiveImgComponent.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.onResize);
        document.removeEventListener('mousemove', this.panImage);
        document.removeEventListener('mouseup', this.stopDragging);
    };
    InteractiveImgComponent.prototype.renderHDIndicator = function () {
        var _a = this.state, isHDActivating = _a.isHDActivating, isHDAvailable = _a.isHDAvailable, isHDActive = _a.isHDActive;
        if (!isHDAvailable) {
            return null;
        }
        var hdPrimaryColor = isHDActivating ? B75 : isHDActive ? B200 : DN400;
        var hdSecondaryColor = isHDActive && !isHDActivating ? N0 : DN60;
        var testId = isHDActivating
            ? 'hd-activating'
            : isHDActive
                ? 'hd-active'
                : 'hd-inactive';
        return (React.createElement(HDIconGroupWrapper, { className: hideControlsClassName },
            isHDActivating ? React.createElement(Spinner, { appearance: "invert" }) : undefined,
            React.createElement(HDIconWrapper, null,
                React.createElement(HDIcon, { primaryColor: hdPrimaryColor, secondaryColor: hdSecondaryColor, label: "hd", testId: testId }))));
    };
    InteractiveImgComponent.prototype.render = function () {
        var _a = this.props, src = _a.src, originalBinaryImageSrc = _a.originalBinaryImageSrc, orientation = _a.orientation, onError = _a.onError;
        var _b = this.state, zoomLevel = _b.zoomLevel, isHDAvailable = _b.isHDAvailable, isHDActive = _b.isHDActive, camera = _b.camera, isDragging = _b.isDragging;
        var canDrag = (camera && zoomLevel.value > camera.scaleToFit) || false;
        // We use style attr instead of SC prop for perf reasons
        var imgStyle = (camera && camera.scaledImg(zoomLevel.value)) || {};
        if (orientation) {
            imgStyle.transform = getCssFromImageOrientation(orientation);
        }
        var srcToDisplay = isHDAvailable && isHDActive && originalBinaryImageSrc
            ? originalBinaryImageSrc
            : src;
        return (React.createElement(ImageWrapper, { "data-testid": "media-viewer-image-content", onClick: this.onImageClicked, innerRef: this.saveWrapperRef },
            React.createElement(Img, { "data-testid": "media-viewer-image", canDrag: canDrag, isDragging: isDragging, src: srcToDisplay, style: imgStyle, onLoad: this.onImgLoad, onError: onError, onMouseDown: this.startDragging, shouldPixelate: zoomLevel.value > 1 }),
            React.createElement(BaselineExtend, null),
            React.createElement(ZoomControls, { zoomLevel: zoomLevel, onChange: this.onZoomChange }),
            this.renderHDIndicator()));
    };
    return InteractiveImgComponent;
}(React.Component));
export { InteractiveImgComponent };
export var InteractiveImg = withAnalyticsEvents({
    onBlanketClicked: function (createAnalyticsEvent) {
        var event = createAnalyticsEvent(closedEvent('blanket'));
        event.fire(channel);
    },
})(InteractiveImgComponent);
//# sourceMappingURL=interactive-img.js.map