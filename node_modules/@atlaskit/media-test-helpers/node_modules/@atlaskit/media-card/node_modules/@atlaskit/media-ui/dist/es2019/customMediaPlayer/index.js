import React from 'react';
import { Component } from 'react';
import PlayIcon from '@atlaskit/icon/glyph/vid-play';
import PauseIcon from '@atlaskit/icon/glyph/vid-pause';
import FullScreenIconOn from '@atlaskit/icon/glyph/vid-full-screen-on';
import FullScreenIconOff from '@atlaskit/icon/glyph/vid-full-screen-off';
import SoundIcon from '@atlaskit/icon/glyph/hipchat/outgoing-sound';
import HDIcon from '@atlaskit/icon/glyph/vid-hd-circle';
import DownloadIcon from '@atlaskit/icon/glyph/download';
import MediaButton from '../MediaButton';
import Spinner from '@atlaskit/spinner';
import { WidthObserver } from '@atlaskit/width-detector';
import MediaPlayer from 'react-video-renderer';
import { B200, DN400, N0, DN60 } from '@atlaskit/theme/colors';
import { TimeRange } from './timeRange';
import { CurrentTime, VideoWrapper, CustomVideoWrapper, TimebarWrapper, VolumeWrapper, TimeWrapper, LeftControls, RightControls, ControlsWrapper, VolumeToggleWrapper, MutedIndicator, SpinnerWrapper, VolumeTimeRangeWrapper, } from './styled';
import { formatDuration } from '../formatDuration';
import { hideControlsClassName } from '../classNames';
import { Shortcut, keyCodes } from '../shortcut';
import { toggleFullscreen, getFullscreenElement, vendorify, } from './fullscreen';
import { injectIntl } from 'react-intl';
import { messages } from '../messages';
import simultaneousPlayManager from './simultaneousPlayManager';
const toolbar = 'toolbar';
const SMALL_VIDEO_MAX_WIDTH = 400;
export class CustomMediaPlayer extends Component {
    constructor() {
        super(...arguments);
        this.wasPlayedOnce = false;
        this.state = {
            isFullScreenEnabled: false,
            isLargePlayer: true,
        };
        this.onFullScreenChange = (e) => {
            if (e.target !== this.videoWrapperRef) {
                return;
            }
            const { isFullScreenEnabled: currentFullScreenMode } = this.state;
            const isFullScreenEnabled = !!getFullscreenElement();
            if (currentFullScreenMode !== isFullScreenEnabled) {
                this.setState({
                    isFullScreenEnabled,
                });
            }
        };
        this.onTimeChange = (navigate) => (value) => {
            navigate(value);
        };
        this.onVolumeChange = (setVolume) => (value) => setVolume(value);
        this.shortcutHandler = (toggleButtonAction) => () => {
            const { showControls } = this.props;
            toggleButtonAction();
            if (showControls) {
                showControls();
            }
        };
        this.renderCurrentTime = ({ currentTime, duration }) => {
            return (React.createElement(CurrentTime, { draggable: false },
                formatDuration(currentTime),
                " / ",
                formatDuration(duration)));
        };
        this.renderHDButton = () => {
            const { type, isHDAvailable, isHDActive, onHDToggleClick } = this.props;
            if (type === 'audio' || !isHDAvailable) {
                return;
            }
            const primaryColor = isHDActive ? B200 : DN400;
            const secondaryColor = isHDActive ? N0 : DN60;
            return (React.createElement(MediaButton, { appearance: toolbar, onClick: onHDToggleClick, iconBefore: React.createElement(HDIcon, { primaryColor: primaryColor, secondaryColor: secondaryColor, label: "hd" }) }));
        };
        this.renderVolume = ({ isMuted, volume }, actions, showSlider) => {
            return (React.createElement(VolumeWrapper, { showSlider: showSlider },
                React.createElement(VolumeToggleWrapper, { isMuted: isMuted },
                    React.createElement(MutedIndicator, { isMuted: isMuted }),
                    React.createElement(MediaButton, { appearance: toolbar, onClick: actions.toggleMute, iconBefore: React.createElement(SoundIcon, { label: "volume" }) })),
                showSlider && (React.createElement(VolumeTimeRangeWrapper, null,
                    React.createElement(TimeRange, { onChange: this.onVolumeChange(actions.setVolume), duration: 1, currentTime: volume, bufferedTime: volume, disableThumbTooltip: true, isAlwaysActive: true })))));
        };
        this.onFullScreenClick = () => toggleFullscreen(this.videoWrapperRef);
        this.onResize = (width) => this.setState({ isLargePlayer: width > SMALL_VIDEO_MAX_WIDTH });
        this.saveVideoWrapperRef = (el) => (this.videoWrapperRef = el);
        this.renderFullScreenButton = () => {
            const { intl: { formatMessage }, type, } = this.props;
            if (type === 'audio') {
                return;
            }
            const { isFullScreenEnabled } = this.state;
            const icon = isFullScreenEnabled ? (React.createElement(FullScreenIconOff, { label: formatMessage(messages.disable_fullscreen) })) : (React.createElement(FullScreenIconOn, { label: formatMessage(messages.enable_fullscreen) }));
            return (React.createElement(MediaButton, { "data-testid": "custom-media-player-fullscreen-button", appearance: toolbar, onClick: this.onFullScreenClick, iconBefore: icon }));
        };
        this.renderDownloadButton = () => {
            const { onDownloadClick } = this.props;
            if (!onDownloadClick) {
                return;
            }
            return (React.createElement(MediaButton, { "data-testid": "custom-media-player-download-button", appearance: toolbar, onClick: onDownloadClick, iconBefore: React.createElement(DownloadIcon, { label: "download" }) }));
        };
        this.renderSpinner = () => (React.createElement(SpinnerWrapper, null,
            React.createElement(Spinner, { appearance: "invert", size: "large" })));
        this.pause = () => {
            if (this.actions) {
                this.actions.pause();
            }
        };
        this.play = () => {
            const { onFirstPlay } = this.props;
            if (this.actions) {
                this.actions.play();
            }
            simultaneousPlayManager.pauseOthers(this);
            if (!this.wasPlayedOnce && onFirstPlay) {
                this.wasPlayedOnce = true;
                onFirstPlay();
            }
        };
    }
    componentDidMount() {
        const { isAutoPlay, onFirstPlay } = this.props;
        document.addEventListener(vendorify('fullscreenchange', false), this.onFullScreenChange);
        simultaneousPlayManager.subscribe(this);
        if (isAutoPlay) {
            simultaneousPlayManager.pauseOthers(this);
            if (onFirstPlay) {
                this.wasPlayedOnce = true;
                onFirstPlay();
            }
        }
    }
    componentWillUnmount() {
        document.removeEventListener(vendorify('fullscreenchange', false), this.onFullScreenChange);
        simultaneousPlayManager.unsubscribe(this);
    }
    setActions(actions) {
        // Actions are being sent constantly while the video is playing,
        // though play and pause functions are always the same objects
        if (!this.actions) {
            const { play, pause } = actions;
            this.actions = { play, pause };
        }
    }
    render() {
        const { type, src, isAutoPlay, isShortcutEnabled, intl: { formatMessage }, onCanPlay, onError, } = this.props;
        const { isFullScreenEnabled } = this.state;
        return (React.createElement(CustomVideoWrapper, { innerRef: this.saveVideoWrapperRef, "data-testid": "custom-media-player" },
            React.createElement(MediaPlayer, { sourceType: type, src: src, autoPlay: isAutoPlay, onCanPlay: onCanPlay, onError: onError }, (video, videoState, actions) => {
                this.setActions(actions);
                const { status, currentTime, buffered, duration, isLoading, } = videoState;
                const isPlaying = status === 'playing';
                const toggleButtonIcon = isPlaying ? (React.createElement(PauseIcon, { label: formatMessage(messages.play) })) : (React.createElement(PlayIcon, { label: formatMessage(messages.pause) }));
                const toggleButtonAction = isPlaying ? this.pause : this.play;
                const button = (React.createElement(MediaButton, { testId: "custom-media-player-play-toggle-button", "data-test-is-playing": isPlaying, appearance: toolbar, iconBefore: toggleButtonIcon, onClick: toggleButtonAction }));
                const shortcuts = (isShortcutEnabled || isFullScreenEnabled) && [
                    React.createElement(Shortcut, { key: "space-shortcut", keyCode: keyCodes.space, handler: this.shortcutHandler(toggleButtonAction) }),
                    React.createElement(Shortcut, { key: "m-shortcut", keyCode: keyCodes.m, handler: this.shortcutHandler(actions.toggleMute) }),
                ];
                return (React.createElement(VideoWrapper, null,
                    video,
                    isLoading && this.renderSpinner(),
                    shortcuts,
                    React.createElement(WidthObserver, { setWidth: this.onResize }),
                    React.createElement(ControlsWrapper, { className: hideControlsClassName },
                        React.createElement(TimeWrapper, null,
                            React.createElement(TimeRange, { currentTime: currentTime, bufferedTime: buffered, duration: duration, onChange: this.onTimeChange(actions.navigate) })),
                        React.createElement(TimebarWrapper, null,
                            React.createElement(LeftControls, null,
                                button,
                                this.renderVolume(videoState, actions, this.state.isLargePlayer)),
                            React.createElement(RightControls, null,
                                this.state.isLargePlayer &&
                                    this.renderCurrentTime(videoState),
                                this.renderHDButton(),
                                this.renderFullScreenButton(),
                                this.renderDownloadButton())))));
            })));
    }
}
export default injectIntl(CustomMediaPlayer);
//# sourceMappingURL=index.js.map