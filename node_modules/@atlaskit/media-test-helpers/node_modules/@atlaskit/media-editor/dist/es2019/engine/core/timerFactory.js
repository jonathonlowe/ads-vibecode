// Active timer that starts when constructed. To stop it call unload()
class ActiveTimer {
    constructor(callback, msecInterval, starter, stopper) {
        this.stopper = stopper;
        this.handle = starter(callback, msecInterval);
    }
    unload() {
        if (this.handle !== 0) {
            this.stopper(this.handle);
            this.handle = 0;
        }
    }
}
// Responsible for providing timers for the core.
//
// The core creates a timer with createTimer() and receives the id.
// Then it may call startTimer() and stopTimer() on the same id many times.
export class TimerFactory {
    constructor(onTick, timerStarter, timerStopper) {
        this.onTick = onTick;
        this.timerStarter = timerStarter;
        this.timerStopper = timerStopper;
        this.lastId = 0;
        this.activeTimers = {};
    }
    unload() {
        for (let id in this.activeTimers) {
            this.activeTimers[id].unload();
        }
    }
    createTimer() {
        return this.lastId++;
    }
    startTimer(id, msecInterval) {
        // If the timer with this id already running, we must stop it
        this.unloadTimer(id);
        this.activeTimers[id] = new ActiveTimer(() => {
            this.onTick(id);
        }, msecInterval, this.timerStarter || TimerFactory.defaultStarter, this.timerStopper || TimerFactory.defaultStopper);
    }
    stopTimer(id) {
        this.unloadTimer(id);
        delete this.activeTimers[id];
    }
    unloadTimer(id) {
        const current = this.activeTimers[id];
        if (current) {
            current.unload();
        }
    }
    static defaultStarter(callback, msecInterval) {
        return window.setInterval(callback, msecInterval);
    }
    static defaultStopper(handle) {
        clearInterval(handle);
    }
}
//# sourceMappingURL=timerFactory.js.map