import { ReplaySubject } from 'rxjs/ReplaySubject';
import { mapMediaFileToFileState, getFileStreamsCache, } from '..';
export const collectionCache = {};
const createCacheEntry = () => ({
    items: [],
    subject: new ReplaySubject(1),
    isLoadingNextPage: false,
});
export class CollectionFetcher {
    constructor(mediaStore) {
        this.mediaStore = mediaStore;
    }
    createFileStateObserver(id, details) {
        const subject = new ReplaySubject(1);
        const mediaFile = {
            id,
            ...details,
        };
        const fileState = mapMediaFileToFileState({ data: mediaFile });
        subject.next(fileState);
        return subject;
    }
    populateCache(items) {
        items.forEach(item => {
            const fileStream = this.createFileStateObserver(item.id, item.details);
            getFileStreamsCache().set(item.id, fileStream);
        });
    }
    removeFromCache(id, collectionName) {
        const collectionCacheIndex = collectionCache[collectionName].items.findIndex(item => item.id === id);
        if (collectionCacheIndex === -1) {
            return;
        }
        getFileStreamsCache().remove(id);
        collectionCache[collectionName].items.splice(collectionCacheIndex, 1);
    }
    getItems(collectionName, params) {
        if (!collectionCache[collectionName]) {
            collectionCache[collectionName] = createCacheEntry();
        }
        const collection = collectionCache[collectionName];
        const subject = collection.subject;
        this.mediaStore
            .getCollectionItems(collectionName, {
            ...params,
            details: 'full',
        })
            .then(items => {
            const { contents, nextInclusiveStartKey } = items.data;
            this.populateCache(contents);
            // It's hard to merge two together, so we just take what's came from the server.
            // Since we load only one page > 2 pages will be ditched from the cache.
            collection.items = items.data.contents;
            collection.nextInclusiveStartKey = nextInclusiveStartKey;
            subject.next(collection.items);
        })
            .catch(error => subject.error(error));
        return subject;
    }
    async removeFile(id, collectionName, occurrenceKey) {
        await this.mediaStore.removeCollectionFile(id, collectionName, occurrenceKey);
        this.removeFromCache(id, collectionName);
        const collection = collectionCache[collectionName];
        collection.subject.next(collection.items);
    }
    async loadNextPage(collectionName, params) {
        const collection = collectionCache[collectionName];
        const isLoading = collection ? collection.isLoadingNextPage : false;
        if (!collection || !collection.nextInclusiveStartKey || isLoading) {
            return;
        }
        collection.isLoadingNextPage = true;
        const { nextInclusiveStartKey: inclusiveStartKey, items: currentItems, subject, } = collectionCache[collectionName];
        const response = await this.mediaStore.getCollectionItems(collectionName, {
            ...params,
            inclusiveStartKey,
            details: 'full',
        });
        const { contents, nextInclusiveStartKey } = response.data;
        this.populateCache(contents);
        const newItems = response.data.contents;
        const items = [...currentItems, ...newItems];
        subject.next(items);
        collectionCache[collectionName] = {
            items,
            nextInclusiveStartKey,
            subject,
            isLoadingNextPage: false,
        };
    }
}
//# sourceMappingURL=collection-fetcher.js.map