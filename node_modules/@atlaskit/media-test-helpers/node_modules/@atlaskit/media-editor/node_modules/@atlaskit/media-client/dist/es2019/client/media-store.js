import { request, createUrl, mapResponseToJson, mapResponseToVoid, mapResponseToBlob, getArtifactUrl, } from '..';
import { FILE_CACHE_MAX_AGE, MAX_RESOLUTION } from '../constants';
const defaultImageOptions = {
    'max-age': FILE_CACHE_MAX_AGE,
    allowAnimated: true,
    mode: 'crop',
};
const defaultGetCollectionItems = {
    limit: 30,
    sortDirection: 'desc',
};
const extendImageParams = (params, fetchMaxRes = false) => {
    return {
        ...defaultImageOptions,
        ...params,
        ...(fetchMaxRes ? { width: MAX_RESOLUTION, height: MAX_RESOLUTION } : {}),
    };
};
const jsonHeaders = {
    Accept: 'application/json',
    'Content-Type': 'application/json',
};
export class MediaStore {
    constructor(config) {
        this.config = config;
        this.getFile = (fileId, params = {}) => {
            return this.request(`/file/${fileId}`, {
                params,
                authContext: { collectionName: params.collection },
            }).then(mapResponseToJson);
        };
        this.getFileImageURL = async (id, params) => {
            const auth = await this.config.authProvider();
            return createUrl(`${auth.baseUrl}/file/${id}/image`, {
                params: extendImageParams(params),
                auth,
            });
        };
        this.getArtifactURL = async (artifacts, artifactName, collectionName) => {
            const artifactUrl = getArtifactUrl(artifacts, artifactName);
            if (!artifactUrl) {
                throw new Error(`artifact ${artifactName} not found`);
            }
            const auth = await this.config.authProvider({ collectionName });
            return createUrl(`${auth.baseUrl}${artifactUrl}`, {
                params: { collection: collectionName, 'max-age': FILE_CACHE_MAX_AGE },
                auth,
            });
        };
        this.getImage = async (id, params, controller, fetchMaxRes) => {
            // TODO add checkWebpSupport() back https://product-fabric.atlassian.net/browse/MPT-584
            const isWebpSupported = false;
            let headers;
            if (isWebpSupported) {
                headers = {
                    accept: 'image/webp,image/*,*/*;q=0.8',
                };
            }
            return this.request(`/file/${id}/image`, {
                headers,
                params: extendImageParams(params, fetchMaxRes),
                authContext: { collectionName: params && params.collection },
            }, controller).then(mapResponseToBlob);
        };
        this.getItems = (ids, collectionName) => {
            const descriptors = ids.map(id => ({
                type: 'file',
                id,
                collection: collectionName,
            }));
            return this.request('/items', {
                method: 'POST',
                body: JSON.stringify({ descriptors }),
                headers: jsonHeaders,
                authContext: { collectionName },
            }).then(mapResponseToJson);
        };
        this.getImageMetadata = (id, params) => {
            return this.request(`/file/${id}/image/metadata`, {
                params,
                authContext: { collectionName: params && params.collection },
            }).then(mapResponseToJson);
        };
    }
    async getCollectionItems(collectionName, params) {
        const response = await this.request(`/collection/${collectionName}/items`, {
            authContext: { collectionName },
            params: {
                ...defaultGetCollectionItems,
                ...params,
            },
            headers: {
                Accept: 'application/json',
            },
        });
        const { data: { contents, nextInclusiveStartKey }, } = await mapResponseToJson(response);
        // [TODO] MS-705: remove after backend adds filter
        // This prevents showing "ghost" files in recents
        const contentsWithoutEmptyFiles = contents.filter(item => item.details.size && item.details.size > 0);
        return {
            data: {
                contents: contentsWithoutEmptyFiles,
                nextInclusiveStartKey,
            },
        };
    }
    async removeCollectionFile(id, collectionName, occurrenceKey) {
        const body = {
            actions: [
                {
                    action: 'remove',
                    item: {
                        type: 'file',
                        id,
                        occurrenceKey,
                    },
                },
            ],
        };
        await this.request(`/collection/${collectionName}`, {
            method: 'PUT',
            authContext: { collectionName },
            body: JSON.stringify(body),
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
        });
    }
    createUpload(createUpTo = 1, collectionName) {
        return this.request(`/upload`, {
            method: 'POST',
            authContext: { collectionName },
            params: {
                createUpTo,
            },
            headers: {
                Accept: 'application/json',
            },
        }).then(mapResponseToJson);
    }
    uploadChunk(etag, blob, collectionName) {
        return this.request(`/chunk/${etag}`, {
            method: 'PUT',
            authContext: { collectionName },
            body: blob,
        }).then(mapResponseToVoid);
    }
    probeChunks(chunks, collectionName) {
        return this.request(`/chunk/probe`, {
            method: 'POST',
            authContext: { collectionName },
            body: JSON.stringify({
                chunks,
            }),
            headers: jsonHeaders,
        }).then(mapResponseToJson);
    }
    createFileFromUpload(body, params = {}) {
        return this.request('/file/upload', {
            method: 'POST',
            authContext: { collectionName: params.collection },
            params,
            body: JSON.stringify(body),
            headers: jsonHeaders,
        }).then(mapResponseToJson);
    }
    touchFiles(body, params = {}) {
        return this.request('/upload/createWithFiles', {
            method: 'POST',
            headers: jsonHeaders,
            body: JSON.stringify(body),
            authContext: { collectionName: params.collection },
        }).then(mapResponseToJson);
    }
    async getFileBinaryURL(id, collectionName) {
        const auth = await this.config.authProvider({ collectionName });
        return createUrl(`${auth.baseUrl}/file/${id}/binary`, {
            params: {
                dl: true,
                collection: collectionName,
                'max-age': FILE_CACHE_MAX_AGE,
            },
            auth,
        });
    }
    appendChunksToUpload(uploadId, body, collectionName) {
        return this.request(`/upload/${uploadId}/chunks`, {
            method: 'PUT',
            authContext: { collectionName },
            body: JSON.stringify(body),
            headers: jsonHeaders,
        }).then(mapResponseToVoid);
    }
    copyFileWithToken(body, params) {
        return this.request('/file/copy/withToken', {
            method: 'POST',
            authContext: { collectionName: params.collection },
            body: JSON.stringify(body),
            headers: jsonHeaders,
            params,
        }).then(mapResponseToJson);
    }
    async request(path, options = {
        method: 'GET',
        authContext: {},
    }, controller) {
        const { authProvider } = this.config;
        const { method, authContext, params, headers, body } = options;
        const auth = await authProvider(authContext);
        const response = await request(`${auth.baseUrl}${path}`, {
            method,
            auth,
            params,
            headers,
            body,
        }, controller);
        updateMediaRegion(response.headers.get('x-media-region'));
        return response;
    }
}
function updateMediaRegion(region) {
    if (!region || !(window && window.sessionStorage)) {
        return;
    }
    const currentRegion = window.sessionStorage.getItem('media-api-region');
    if (currentRegion !== region) {
        window.sessionStorage.setItem('media-api-region', region);
    }
}
//# sourceMappingURL=media-store.js.map