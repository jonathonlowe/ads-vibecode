import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import { withAnalyticsContext, withAnalyticsEvents, } from '@atlaskit/analytics-next';
import DownloadIcon from '@atlaskit/icon/glyph/download';
import { addFileAttrsToUrl, globalMediaEventEmitter, isDifferentIdentifier, isFileIdentifier, isImageRepresentationReady, isPreviewableType, RECENTS_COLLECTION, } from '@atlaskit/media-client';
import { MediaViewer } from '@atlaskit/media-viewer';
import { IntlProvider } from 'react-intl';
import { CardView } from '../cardView';
import { LazyContent } from '../../utils/lazyContent';
import { getDataURIDimension } from '../../utils/getDataURIDimension';
import { getFilePreviewFromFileState, } from '../../utils/getFilePreviewFromFileState';
import { extendMetadata } from '../../utils/metadata';
import { isBigger } from '../../utils/dimensionComparer';
import { getCardProgressFromFileState, getCardStatus, getCardStatusFromFileState, } from './getCardStatus';
import { InlinePlayer } from '../inlinePlayer';
import { createAndFireCustomMediaEvent, fileIsPreviewable, getAnalyticsErrorStateAttributes, getAnalyticsStatus, getBaseAnalyticsContext, getCopiedFileAnalyticsPayload, getFileAttributes, getLoadingStatusAnalyticsPayload, getMediaCardAnalyticsContext, getMediaCardCommencedAnalyticsPayload, hasFilenameAndFilesize, } from '../../utils/analytics';
import { MediaAnalyticsContext } from '@atlaskit/analytics-namespaced-context';
import { objectURLCache } from './objectURLCache';
export class CardBase extends Component {
    constructor() {
        super(...arguments);
        this.hasBeenMounted = false;
        this.lastAction = undefined;
        this.lastErrorState = {};
        this.cardRef = React.createRef();
        this.state = {
            status: 'loading',
            isCardVisible: !this.props.isLazy,
            previewOrientation: 1,
            isPlayingFile: false,
        };
        // we add a listener for each of the cards on the page
        // and then check if the triggered listener is from the card
        // that contains a div in current window.getSelection()
        // won't work in IE11
        this.onCopyListener = () => {
            if (typeof window.getSelection === 'function') {
                const selection = window.getSelection();
                if (this.cardRef.current &&
                    this.cardRef.current.divRef.current instanceof Node &&
                    selection &&
                    selection.containsNode &&
                    selection.containsNode(this.cardRef.current.divRef.current, true)) {
                    this.fireFileCopiedAnalytics();
                }
            }
        };
        this.shouldRefetchImage = (current, next) => {
            if (!current || !next) {
                return false;
            }
            return isBigger(current, next);
        };
        this.shouldFireLoadingStatusAnalyticsEvent = (action, errorState) => {
            const previousFailReason = this.lastErrorState && this.lastErrorState.failReason;
            const previousErrorMessage = this.lastErrorState && this.lastErrorState.error;
            const isDifferentErrorState = errorState.failReason !== previousFailReason ||
                errorState.error !== previousErrorMessage;
            const isDifferentAction = action !== this.lastAction;
            return isDifferentAction || isDifferentErrorState;
        };
        this.fireLoadingStatusAnalyticsEvent = ({ id, status, metadata, error, }) => {
            const { createAnalyticsEvent } = this.props;
            const previewable = fileIsPreviewable(metadata);
            const hasMinimalData = hasFilenameAndFilesize(metadata);
            const action = getAnalyticsStatus(previewable, hasMinimalData, status);
            const errorState = getAnalyticsErrorStateAttributes(previewable, hasMinimalData, this.lastFileState, error);
            if (action &&
                this.shouldFireLoadingStatusAnalyticsEvent(action, errorState)) {
                this.lastAction = action;
                this.lastErrorState = errorState;
                const fileAttributes = getFileAttributes(metadata, this.lastFileState && this.lastFileState.status);
                createAndFireCustomMediaEvent(getLoadingStatusAnalyticsPayload(action, id, fileAttributes, errorState), createAnalyticsEvent);
            }
        };
        this.fireFileCopiedAnalytics = () => {
            const { createAnalyticsEvent, identifier } = this.props;
            createAndFireCustomMediaEvent(getCopiedFileAnalyticsPayload(identifier), createAnalyticsEvent);
        };
        this.safeSetState = (state) => {
            if (this.hasBeenMounted) {
                this.setState(state);
            }
        };
        this.unsubscribe = () => {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            if (this.hasBeenMounted) {
                this.setState({ dataURI: undefined });
            }
            this.lastAction = undefined;
            this.lastErrorState = {};
        };
        // This method is called when card fails and user press 'Retry'
        this.onRetry = () => {
            this.lastAction = undefined;
            this.lastErrorState = {};
            this.fireCardCommencedAnalytics();
            this.updateStateForIdentifier();
        };
        this.onCardViewClick = (event, analyticsEvent) => {
            const { identifier, useInlinePlayer, shouldOpenMediaViewer } = this.props;
            const { metadata } = this.state;
            this.onClick(event, analyticsEvent);
            if (!metadata) {
                return;
            }
            const isVideo = metadata && metadata.mediaType === 'video';
            if (useInlinePlayer && isVideo) {
                this.setState({
                    isPlayingFile: true,
                });
            }
            else if (shouldOpenMediaViewer) {
                let mediaViewerSelectedItem;
                if (isFileIdentifier(identifier)) {
                    mediaViewerSelectedItem = {
                        id: identifier.id,
                        mediaItemType: 'file',
                        collectionName: identifier.collectionName,
                        occurrenceKey: identifier.occurrenceKey,
                    };
                }
                else {
                    mediaViewerSelectedItem = {
                        mediaItemType: 'external-image',
                        dataURI: identifier.dataURI,
                        name: identifier.name,
                    };
                }
                this.setState({
                    mediaViewerSelectedItem,
                });
            }
        };
        this.onInlinePlayerError = () => {
            this.setState({
                isPlayingFile: false,
            });
        };
        this.renderInlinePlayer = () => {
            const { identifier, mediaClient, dimensions, selected, testId, } = this.props;
            return (React.createElement(InlinePlayer, { mediaClient: mediaClient, dimensions: dimensions || {}, identifier: identifier, onError: this.onInlinePlayerError, onClick: this.onClick, selected: selected, ref: this.cardRef, testId: testId }));
        };
        this.onMediaViewerClose = () => {
            this.setState({
                mediaViewerSelectedItem: undefined,
            });
        };
        this.onDisplayImage = () => {
            const { identifier } = this.props;
            let payloadPart;
            if (isFileIdentifier(identifier)) {
                payloadPart = {
                    fileId: identifier.id,
                    isUserCollection: identifier.collectionName === RECENTS_COLLECTION,
                };
            }
            else {
                payloadPart = {
                    fileId: identifier.dataURI,
                    isUserCollection: false,
                };
            }
            globalMediaEventEmitter.emit('media-viewed', {
                viewingLevel: 'minimal',
                ...payloadPart,
            });
        };
        this.renderMediaViewer = () => {
            const { mediaViewerSelectedItem } = this.state;
            const { mediaClient, identifier, mediaViewerDataSource, contextId, } = this.props;
            if (!mediaViewerSelectedItem) {
                return;
            }
            const collectionName = isFileIdentifier(identifier)
                ? identifier.collectionName || ''
                : '';
            const dataSource = mediaViewerDataSource || {
                list: [],
            };
            return ReactDOM.createPortal(React.createElement(MediaViewer, { collectionName: collectionName, dataSource: dataSource, mediaClientConfig: mediaClient.config, selectedItem: mediaViewerSelectedItem, onClose: this.onMediaViewerClose, contextId: contextId }), document.body);
        };
        this.renderCard = () => {
            const { isLazy, appearance, resizeMode, dimensions, selectable, selected, disableOverlay, alt, testId, featureFlags, } = this.props;
            const { progress, metadata, dataURI, previewOrientation } = this.state;
            const { onRetry, onCardViewClick, onDisplayImage, actions, onMouseEnter, } = this;
            const status = getCardStatus(this.state, this.props);
            const card = (React.createElement(CardView, { status: status, metadata: metadata, dataURI: dataURI, alt: alt, appearance: appearance, resizeMode: resizeMode, dimensions: dimensions, actions: actions, selectable: selectable, selected: selected, onClick: onCardViewClick, onMouseEnter: onMouseEnter, disableOverlay: disableOverlay, progress: progress, onRetry: onRetry, onDisplayImage: onDisplayImage, previewOrientation: previewOrientation, ref: this.cardRef, testId: testId, featureFlags: featureFlags }));
            return isLazy ? (React.createElement(LazyContent, { placeholder: card, onRender: this.onCardInViewport }, card)) : (card);
        };
        this.onCardInViewport = () => {
            this.setState({ isCardVisible: true });
        };
        this.onClick = (event, analyticsEvent) => {
            const { onClick } = this.props;
            const { metadata } = this.state;
            if (onClick) {
                const cardEvent = {
                    event,
                    mediaItemDetails: metadata,
                };
                onClick(cardEvent, analyticsEvent);
            }
        };
        this.onMouseEnter = (event) => {
            const { onMouseEnter } = this.props;
            const { metadata } = this.state;
            if (onMouseEnter) {
                const cardEvent = {
                    event,
                    mediaItemDetails: metadata,
                };
                onMouseEnter(cardEvent);
            }
        };
    }
    componentDidMount() {
        this.hasBeenMounted = true;
        this.fireCardCommencedAnalytics();
        this.updateStateForIdentifier();
        document.addEventListener('copy', this.onCopyListener);
    }
    componentDidUpdate(prevProps, prevState) {
        const { mediaClient: prevMediaClient, identifier: prevIdentifier, dimensions: prevDimensions, } = prevProps;
        const { isCardVisible: prevIsCardVisible } = prevState;
        const { mediaClient, identifier, dimensions } = this.props;
        const { isCardVisible } = this.state;
        const isDifferent = isDifferentIdentifier(prevIdentifier, identifier);
        if ((prevIsCardVisible !== isCardVisible && isCardVisible) ||
            prevMediaClient !== mediaClient ||
            isDifferent ||
            this.shouldRefetchImage(prevDimensions, dimensions)) {
            this.fireCardCommencedAnalytics();
            this.updateStateForIdentifier();
        }
    }
    componentWillUnmount() {
        this.hasBeenMounted = false;
        this.unsubscribe();
        document.removeEventListener('copy', this.onCopyListener);
    }
    getId() {
        const { identifier } = this.props;
        if (identifier.mediaItemType === 'external-image') {
            return identifier.mediaItemType;
        }
        else {
            return identifier.id;
        }
    }
    updateStateForIdentifier() {
        const { mediaClient, identifier } = this.props;
        const { isCardVisible } = this.state;
        if (!isCardVisible) {
            return;
        }
        if (identifier.mediaItemType === 'file') {
            this.unsubscribe();
            this.subscribeInternalFile(identifier, mediaClient);
        }
    }
    getRequestedDimensions() {
        const { dimensions } = this.props;
        const options = {
            dimensions,
            element: this.cardRef.current && this.cardRef.current.divRef.current,
        };
        const width = getDataURIDimension('width', options);
        const height = getDataURIDimension('height', options);
        return {
            width,
            height,
        };
    }
    addContextToDataURI(dataURI, fileId, metadata, { width, height }, collectionName) {
        const { contextId, alt } = this.props;
        if (!contextId) {
            return dataURI;
        }
        return addFileAttrsToUrl(dataURI, {
            id: fileId,
            collection: collectionName,
            contextId,
            mimeType: metadata.mimeType,
            name: metadata.name,
            size: metadata.size,
            width,
            height,
            alt,
        });
    }
    async getObjectUrlFromBackendImageBlob(mediaClient, id, { width, height }, collectionName) {
        const { resizeMode } = this.props;
        const mode = resizeMode === 'stretchy-fit' ? 'full-fit' : resizeMode;
        try {
            const blob = await mediaClient.getImage(id, {
                collection: collectionName,
                mode,
                height,
                width,
                allowAnimated: true,
            });
            return URL.createObjectURL(blob);
        }
        catch (e) {
            // We don't want to set status=error if the preview fails, we still want to display the metadata
        }
    }
    subscribeInternalFile(identifier, mediaClient) {
        const { id, collectionName, occurrenceKey } = identifier;
        this.subscription = mediaClient.file
            .getFileState(id, { collectionName, occurrenceKey })
            .subscribe({
            next: async (fileState) => {
                let { dataURI } = this.state;
                const { dimensions = {} } = this.props;
                this.lastFileState = fileState;
                const thisCardStatusUpdateTimestamp = (performance || Date).now();
                const metadata = extendMetadata(fileState, this.state.metadata);
                this.safeSetState({ metadata });
                const shouldFetchRemotePreview = isImageRepresentationReady(fileState) &&
                    metadata.mediaType &&
                    isPreviewableType(metadata.mediaType);
                // Dimensions are used to create a key. We want to be able to
                // request new image from backend when different dimensions are provided.
                const cacheKey = [id, dimensions.height, dimensions.width].join('-');
                if (!dataURI && objectURLCache.has(cacheKey)) {
                    // No dataURI in state. Let's try and get one.
                    // First, we try to get one from the cache
                    dataURI = objectURLCache.get(cacheKey);
                }
                if (!dataURI) {
                    // Second, we try to get one from Preview possibly stored in FileState
                    let filePreview;
                    try {
                        filePreview = await getFilePreviewFromFileState(fileState);
                    }
                    catch (err) {
                        // no preview could be fetched from FileState
                        filePreview = { orientation: 1 };
                    }
                    let { originalDimensions } = this.props;
                    let requestedDimensions;
                    if (filePreview.src) {
                        dataURI = filePreview.src;
                        this.safeSetState({
                            previewOrientation: filePreview.orientation,
                        });
                        // Third, if there is no Preview in FileState we fetch one from /image backend
                    }
                    else if (shouldFetchRemotePreview) {
                        requestedDimensions = this.getRequestedDimensions();
                        dataURI = await this.getObjectUrlFromBackendImageBlob(mediaClient, id, requestedDimensions, collectionName);
                    }
                    if (dataURI) {
                        // In case we've retrieved dataURI using one of the two methods above,
                        // we want to embed some meta context into this URL for Copy/Paste to work.
                        const contextDimensions = originalDimensions ||
                            requestedDimensions ||
                            this.getRequestedDimensions();
                        dataURI = this.addContextToDataURI(dataURI, id, metadata, contextDimensions, collectionName);
                        // We store new dataURI into cache
                        objectURLCache.set(cacheKey, dataURI);
                    }
                }
                if (dataURI) {
                    // Finally we store retrieved dataURI into state
                    this.safeSetState({
                        dataURI,
                    });
                }
                const status = getCardStatusFromFileState(fileState, dataURI);
                this.fireLoadingStatusAnalyticsEvent({
                    id,
                    status,
                    metadata,
                });
                if (!this.lastCardStatusUpdateTimestamp ||
                    this.lastCardStatusUpdateTimestamp <= thisCardStatusUpdateTimestamp) {
                    const progress = getCardProgressFromFileState(fileState, dataURI);
                    // These status and progress must not override values representing more recent FileState
                    /* next() start        some await() delay in next()        status & progress update
                     * -------                    ------------------           ------------------------
                     *   |----[1]FileState:uploading------>|                                 |
                     *   |                                 |                                 |
                     *   |----[2]FileState:uploading------>|                                 |
                     *   |                                 |                                 |
                     *   |                                 |----[2]FileState:uploading------>| Update status to `uploading`
                     *   |----[3]FileState:processing----->|                                 |
                     *   |                                 |----[3]FileState:processing----->| Update status to `complete`
                     *   |                                 |                                 |
                     *   |                                 |----[1]FileState:uploading------>| We do not want to update status to `uploading` again!
                     *
                     */
                    this.safeSetState({
                        status,
                        progress,
                    });
                    this.lastCardStatusUpdateTimestamp = thisCardStatusUpdateTimestamp;
                }
            },
            error: error => {
                this.fireLoadingStatusAnalyticsEvent({
                    id,
                    status: 'error',
                    error,
                });
                this.safeSetState({ error, status: 'error' });
            },
        });
    }
    fireCardCommencedAnalytics() {
        const { createAnalyticsEvent } = this.props;
        const { isCardVisible } = this.state;
        if (!isCardVisible) {
            return;
        }
        const id = this.getId();
        createAndFireCustomMediaEvent(getMediaCardCommencedAnalyticsPayload(id), createAnalyticsEvent);
    }
    get actions() {
        const { actions = [], identifier } = this.props;
        const { status, metadata } = this.state;
        if (isFileIdentifier(identifier) && status === 'failed-processing') {
            const downloadAction = {
                label: 'Download',
                icon: React.createElement(DownloadIcon, { label: "Download" }),
                handler: () => this.props.mediaClient.file.downloadBinary(identifier.id, metadata.name, identifier.collectionName),
            };
            return [downloadAction, ...actions];
        }
        else {
            return actions;
        }
    }
    renderContent() {
        const { isPlayingFile, mediaViewerSelectedItem } = this.state;
        const innerContent = isPlayingFile
            ? this.renderInlinePlayer()
            : this.renderCard();
        return this.context.intl ? (innerContent) : (React.createElement(IntlProvider, { locale: "en" },
            React.createElement(React.Fragment, null,
                innerContent,
                mediaViewerSelectedItem ? this.renderMediaViewer() : null)));
    }
    render() {
        const { metadata } = this.state;
        return (React.createElement(MediaAnalyticsContext, { data: getMediaCardAnalyticsContext(metadata, this.lastFileState) }, this.renderContent()));
    }
}
CardBase.defaultProps = {
    appearance: 'auto',
    resizeMode: 'crop',
    isLazy: true,
    disableOverlay: false,
};
CardBase.getDerivedStateFromProps = (props) => {
    const { identifier } = props;
    if (identifier.mediaItemType === 'external-image') {
        const { dataURI, name, mediaItemType } = identifier;
        return {
            status: 'complete',
            dataURI,
            metadata: {
                id: mediaItemType,
                name: name || dataURI,
                mediaType: 'image',
            },
        };
    }
    return null;
};
export const Card = withAnalyticsContext(getBaseAnalyticsContext())(withAnalyticsEvents()(CardBase));
//# sourceMappingURL=index.js.map