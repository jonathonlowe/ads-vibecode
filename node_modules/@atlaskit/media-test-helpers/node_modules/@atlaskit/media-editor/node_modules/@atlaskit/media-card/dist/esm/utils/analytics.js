import { __assign } from "tslib";
import { isPreviewableType, } from '@atlaskit/media-client';
import { version as packageVersion, name as packageName, } from '../version.json';
import { createAndFireEvent, } from '@atlaskit/analytics-next';
import { ANALYTICS_MEDIA_CHANNEL } from '../root/media-card-analytics-error-boundary';
export function getBaseAnalyticsContext(componentName) {
    if (componentName === void 0) { componentName = 'mediaCard'; }
    /*
      This Context provides data needed to build packageHierarchy in Atlaskit Analytics Listener and Media Analytics Listener
    */
    return {
        packageVersion: packageVersion,
        packageName: packageName,
        componentName: componentName,
        component: componentName,
    };
}
export var getFileAttributes = function (metadata, fileStatus) { return ({
    fileSource: 'mediaCard',
    fileMediatype: metadata && metadata.mediaType,
    fileMimetype: metadata && metadata.mimeType,
    fileId: metadata && metadata.id,
    fileSize: metadata && metadata.size,
    fileStatus: fileStatus,
}); };
export function getMediaCardAnalyticsContext(metadata, fileStatus) {
    return {
        fileAttributes: getFileAttributes(metadata, fileStatus && fileStatus.status),
    };
}
export function createAndFireCustomMediaEvent(payload, createAnalyticsEvent) {
    if (createAnalyticsEvent) {
        var event_1 = createAnalyticsEvent(payload);
        event_1.fire(ANALYTICS_MEDIA_CHANNEL);
    }
}
export var createAndFireMediaEvent = function (payload) {
    return createAndFireEvent(ANALYTICS_MEDIA_CHANNEL)(payload);
};
export var getAnalyticsStatusFromCardStatus = function (cardStatus) {
    switch (cardStatus) {
        case 'error':
        case 'failed-processing':
            return 'failed';
        default:
            return;
    }
};
/*
 * Returns an empty object (success event) or an object containing an error with its corresponding failReason.
 */
export var getAnalyticsErrorStateAttributes = function (previewable, hasMinimalData, fileState, error) {
    var unknownError = 'unknown error';
    var errorMessage = error instanceof Error ? error.message : error;
    var errorMessageInFileState = fileState && 'message' in fileState && fileState.message;
    var fileStateIsErrorOrFailedProcessing = fileState && ['error', 'failed-processing'].includes(fileState.status);
    // if the fileState is undefined and theres no error message, don't fire an error event
    if (!fileState && !errorMessage) {
        return {};
    }
    // if the filestate IS undefined and has an error message, then fire an error event
    if (!fileState) {
        return {
            failReason: 'media-client-error',
            error: errorMessage,
        };
    }
    // if the file has no preview (i.e docs/pdfs/unknown files). Note, if the mediaType is undefined it is assumed to be unpreviewable
    if (!previewable) {
        // if an unpreviewable file has its filename and size (minimal metadata), then it can render successfully (card does not appear broken to the user)
        // files that are previewable i.e videos, need more than this minimal metadata as otherwise the card will appear broken
        if (hasMinimalData) {
            return {};
        }
        // If a file does not have minimal metadata, then fire an error with an error message stating this. Only do this if a pre-existing error message
        // such as a network error, does not exist. Additionally, only fire this error state if the fileState is an error or failed-processing.
        // For instance, we do not want to return an error state state if the fileState is uploading/uploaded/processing, as these states do not indicate an error.
        if (!errorMessageInFileState && fileStateIsErrorOrFailedProcessing) {
            return {
                failReason: 'file-status-error',
                error: 'Does not have minimal metadata (filename and filesize) OR metadata/media-type is undefined',
            };
        }
    }
    // if the state of a file is an error or has failed to process, fire an error message.
    if (fileStateIsErrorOrFailedProcessing) {
        return {
            failReason: 'file-status-error',
            error: errorMessageInFileState || unknownError,
        };
    }
    // if not, then the filestate is uploading/processed/processing, and hence we should not fire an error
    return {};
};
export var getCopiedFileAnalyticsPayload = function (identifier) {
    return {
        eventType: 'ui',
        action: 'copied',
        actionSubject: 'file',
        actionSubjectId: identifier.mediaItemType === 'file'
            ? identifier.id
            : identifier.mediaItemType,
    };
};
export var getMediaCardCommencedAnalyticsPayload = function (actionSubjectId) {
    return {
        eventType: 'operational',
        action: 'commenced',
        actionSubject: 'mediaCardRender',
        actionSubjectId: actionSubjectId,
    };
};
export var getAnalyticsStatus = function (previewable, hasMinimalData, status) {
    if (!previewable && hasMinimalData) {
        return;
    }
    return getAnalyticsStatusFromCardStatus(status);
};
export var hasFilenameAndFilesize = function (metadata) {
    return !!metadata && !!metadata.name && !!metadata.size;
};
export var fileIsPreviewable = function (metadata) {
    return !!metadata && !!metadata.mediaType && isPreviewableType(metadata.mediaType);
};
export var getLoadingStatusAnalyticsPayload = function (action, actionSubjectId, fileAttributes, errorState) {
    var payload = {
        eventType: 'operational',
        action: action,
        actionSubject: 'mediaCardRender',
        actionSubjectId: actionSubjectId,
    };
    if (!payload.attributes)
        payload.attributes = {};
    if (fileAttributes) {
        payload.attributes = __assign(__assign({}, payload.attributes), { fileAttributes: fileAttributes });
    }
    if (errorState) {
        payload.attributes.failReason = errorState.failReason;
        payload.attributes.error = errorState.error;
    }
    return payload;
};
//# sourceMappingURL=analytics.js.map