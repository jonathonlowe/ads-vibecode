import React from 'react';
import { Component } from 'react';
import { globalMediaEventEmitter, } from '@atlaskit/media-client';
import { CustomMediaPlayer, InactivityDetector } from '@atlaskit/media-ui';
import { InlinePlayerWrapper } from './styled';
import { defaultImageCardDimensions } from '..';
import { CardLoading } from '../utils/lightCards/cardLoading';
import { withAnalyticsEvents, } from '@atlaskit/analytics-next';
import { createAndFireMediaEvent } from '../utils/analytics';
export const getPreferredVideoArtifact = (fileState) => {
    if (fileState.status === 'processed' || fileState.status === 'processing') {
        const { artifacts } = fileState;
        if (!artifacts) {
            return undefined;
        }
        return artifacts['video_1280.mp4']
            ? 'video_1280.mp4'
            : artifacts['video_640.mp4']
                ? 'video_640.mp4'
                : undefined;
    }
    return undefined;
};
export class InlinePlayerBase extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.divRef = React.createRef();
        this.setFileSrc = (fileSrc) => {
            this.setState({ fileSrc });
        };
        // Tries to use the binary artifact to provide something to play while the video is still processing
        this.setBinaryURL = async () => {
            const { mediaClient, identifier, onError } = this.props;
            const { id, collectionName } = identifier;
            try {
                const fileSrc = await mediaClient.file.getFileBinaryURL(id, collectionName);
                this.setFileSrc(fileSrc);
            }
            catch (error) {
                if (onError) {
                    onError(error);
                }
            }
        };
        this.unsubscribe = () => {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        this.revoke = () => {
            const { fileSrc } = this.state;
            if (fileSrc) {
                URL.revokeObjectURL(fileSrc);
            }
        };
        this.getStyle = () => {
            const { dimensions } = this.props;
            // We are given dimensions. But we can’t just blindly apply them as width and height.
            // Because editor is giving us “maximum” dimensions (equal to what it can go to if resized to 100%
            // of available width). And the same time we don’t want to ignore these dimensions completely,
            // because if consumer do not constraint width/height of container we still want to stick to given dimensions.
            // Here we put width as a style. In combination with max-width: 100%; and max-height: 100%;
            // it would give us required effect.
            return {
                width: dimensions.width,
            };
        };
        this.onDownloadClick = () => {
            const { mediaClient, identifier } = this.props;
            const { id, collectionName } = identifier;
            mediaClient.file.downloadBinary(id, undefined, collectionName);
        };
        this.onFirstPlay = () => {
            const { identifier } = this.props;
            globalMediaEventEmitter.emit('media-viewed', {
                fileId: identifier.id,
                viewingLevel: 'full',
            });
        };
    }
    componentDidMount() {
        const { mediaClient, identifier } = this.props;
        const { id, collectionName } = identifier;
        this.revoke();
        this.unsubscribe();
        this.subscription = mediaClient.file
            .getFileState(id, { collectionName })
            .subscribe({
            next: async (fileState) => {
                const { fileSrc: existingFileSrc } = this.state;
                // we want to reuse the existing fileSrc to prevent re renders
                if (existingFileSrc) {
                    return;
                }
                if (fileState.status !== 'error' && fileState.preview) {
                    const { value } = await fileState.preview;
                    if (value instanceof Blob && value.type.indexOf('video/') === 0) {
                        const fileSrc = URL.createObjectURL(value);
                        this.setFileSrc(fileSrc);
                        return;
                    }
                }
                if (fileState.status === 'processed' ||
                    fileState.status === 'processing') {
                    const artifactName = getPreferredVideoArtifact(fileState);
                    const { artifacts } = fileState;
                    if (!artifactName || !artifacts) {
                        this.setBinaryURL();
                        return;
                    }
                    try {
                        const fileSrc = await mediaClient.file.getArtifactURL(artifacts, artifactName, collectionName);
                        this.setFileSrc(fileSrc);
                    }
                    catch (error) {
                        const { onError } = this.props;
                        if (onError) {
                            onError(error);
                        }
                    }
                }
            },
        });
    }
    componentWillUnmount() {
        this.unsubscribe();
        this.revoke();
    }
    render() {
        const { onClick, dimensions, selected, testId } = this.props;
        const { fileSrc } = this.state;
        if (!fileSrc) {
            return React.createElement(CardLoading, { testId: testId, dimensions: dimensions });
        }
        return (React.createElement(InlinePlayerWrapper, { "data-testid": testId || 'media-card-inline-player', style: this.getStyle(), selected: selected, onClick: onClick, innerRef: this.divRef },
            React.createElement(InactivityDetector, null, () => (React.createElement(CustomMediaPlayer, { type: "video", src: fileSrc, isAutoPlay: true, isHDAvailable: false, onDownloadClick: this.onDownloadClick, onFirstPlay: this.onFirstPlay })))));
    }
}
InlinePlayerBase.defaultProps = {
    dimensions: defaultImageCardDimensions,
};
export const InlinePlayer = withAnalyticsEvents({
    onClick: createAndFireMediaEvent({
        eventType: 'ui',
        action: 'clicked',
        actionSubject: 'mediaCard',
        actionSubjectId: 'mediaCardInlinePlayer',
    }),
})(InlinePlayerBase);
//# sourceMappingURL=inlinePlayer.js.map