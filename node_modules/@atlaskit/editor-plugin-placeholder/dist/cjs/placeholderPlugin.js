"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPlaceholderDecoration = createPlaceholderDecoration;
exports.createPlugin = createPlugin;
exports.pluginKey = exports.placeholderTestId = exports.placeholderPlugin = void 0;
var _messages = require("@atlaskit/editor-common/messages");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _utils = require("@atlaskit/editor-common/utils");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _view = require("@atlaskit/editor-prosemirror/view");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var pluginKey = exports.pluginKey = new _state.PluginKey('placeholderPlugin');
function getPlaceholderState(editorState) {
  return pluginKey.getState(editorState);
}
var placeholderTestId = exports.placeholderTestId = 'placeholder-test-id';
var nodeTypesWithLongPlaceholderText = ['expand', 'panel'];
var nodeTypesWithShortPlaceholderText = ['tableCell', 'tableHeader'];
function createPlaceholderDecoration(editorState, placeholderText) {
  var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var placeholderDecoration = document.createElement('span');
  var placeholderNodeWithText = placeholderDecoration;
  placeholderDecoration.setAttribute('data-testid', placeholderTestId);
  placeholderDecoration.className = 'placeholder-decoration';

  // PM sets contenteditable to false on Decorations so Firefox doesn't display the flashing cursor
  // So adding an extra span which will contain the placeholder text
  if (_utils.browser.gecko) {
    var placeholderNode = document.createElement('span');
    placeholderNode.setAttribute('contenteditable', 'true'); // explicitly overriding the default Decoration behaviour
    placeholderDecoration.appendChild(placeholderNode);
    placeholderNodeWithText = placeholderNode;
  }
  placeholderNodeWithText.textContent = placeholderText || ' ';

  // ME-2289 Tapping on backspace in empty editor hides and displays the keyboard
  // Add a editable buff node as the cursor moving forward is inevitable
  // when backspace in GBoard composition
  if (_utils.browser.android && _utils.browser.chrome) {
    var buffNode = document.createElement('span');
    buffNode.setAttribute('class', 'placeholder-android');
    buffNode.setAttribute('contenteditable', 'true');
    buffNode.textContent = ' ';
    placeholderDecoration.appendChild(buffNode);
  }
  var isTargetNested = editorState.doc.resolve(pos).depth > 1;

  // only truncate text for nested nodes, otherwise applying 'overflow: hidden;' to top level nodes
  // creates issues with quick insert button
  if (isTargetNested && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    placeholderDecoration.classList.add('placeholder-decoration-hide-overflow');
  }
  return _view.DecorationSet.create(editorState.doc, [_view.Decoration.widget(pos, placeholderDecoration, {
    side: 0,
    key: "placeholder ".concat(placeholderText)
  })]);
}
function setPlaceHolderState(placeholderText, pos) {
  return {
    hasPlaceholder: true,
    placeholderText: placeholderText,
    pos: pos ? pos : 1
  };
}
var emptyPlaceholder = function emptyPlaceholder(placeholderText) {
  return {
    hasPlaceholder: false,
    placeholderText: placeholderText
  };
};
function createPlaceHolderStateFrom(_ref) {
  var isEditorFocused = _ref.isEditorFocused,
    editorState = _ref.editorState,
    isTypeAheadOpen = _ref.isTypeAheadOpen,
    defaultPlaceholderText = _ref.defaultPlaceholderText,
    intl = _ref.intl,
    bracketPlaceholderText = _ref.bracketPlaceholderText,
    emptyLinePlaceholder = _ref.emptyLinePlaceholder;
  if (isTypeAheadOpen !== null && isTypeAheadOpen !== void 0 && isTypeAheadOpen(editorState)) {
    return emptyPlaceholder(defaultPlaceholderText);
  }
  if (defaultPlaceholderText && (0, _utils.isEmptyDocument)(editorState.doc)) {
    return setPlaceHolderState(defaultPlaceholderText);
  }
  if (isEditorFocused && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    var _parentNode$firstChil, _parentNode$firstChil2;
    var _editorState$selectio = editorState.selection,
      $from = _editorState$selectio.$from,
      $to = _editorState$selectio.$to;
    if ($from.pos !== $to.pos) {
      return emptyPlaceholder(defaultPlaceholderText);
    }
    var parentNode = $from.node($from.depth - 1);
    var parentType = parentNode === null || parentNode === void 0 ? void 0 : parentNode.type.name;
    if (emptyLinePlaceholder && parentType === 'doc') {
      var isEmptyLine = (0, _utils.isEmptyParagraph)($from.parent);
      if (isEmptyLine) {
        return setPlaceHolderState(emptyLinePlaceholder, $from.pos);
      }
    }
    var isEmptyNode = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childCount) === 1 && ((_parentNode$firstChil = parentNode.firstChild) === null || _parentNode$firstChil === void 0 ? void 0 : _parentNode$firstChil.content.size) === 0 && ((_parentNode$firstChil2 = parentNode.firstChild) === null || _parentNode$firstChil2 === void 0 ? void 0 : _parentNode$firstChil2.type.name) === 'paragraph';
    if (nodeTypesWithShortPlaceholderText.includes(parentType) && isEmptyNode) {
      var _table$node$firstChil;
      if (!(0, _platformFeatureFlags.fg)('platform_editor_controls_patch_3')) {
        return setPlaceHolderState(intl.formatMessage(_messages.placeholderTextMessages.shortEmptyNodePlaceholderText), $from.pos);
      }
      var table = (0, _utils2.findParentNode)(function (node) {
        return node.type === editorState.schema.nodes.table;
      })(editorState.selection);
      if (!table) {
        return emptyPlaceholder(defaultPlaceholderText);
      }
      var isFirstCell = (table === null || table === void 0 || (_table$node$firstChil = table.node.firstChild) === null || _table$node$firstChil === void 0 ? void 0 : _table$node$firstChil.content.firstChild) === parentNode;
      if (isFirstCell) {
        return setPlaceHolderState(intl.formatMessage(_messages.placeholderTextMessages.shortEmptyNodePlaceholderText), $from.pos);
      }
    }
    if (nodeTypesWithLongPlaceholderText.includes(parentType) && isEmptyNode) {
      return setPlaceHolderState(intl.formatMessage(_messages.placeholderTextMessages.longEmptyNodePlaceholderText), $from.pos);
    }
    return emptyPlaceholder(defaultPlaceholderText);
  }
  if (bracketPlaceholderText && (0, _utils.bracketTyped)(editorState) && isEditorFocused) {
    var _$from = editorState.selection.$from;
    // Space is to account for positioning of the bracket
    var bracketHint = '  ' + bracketPlaceholderText;
    return setPlaceHolderState(bracketHint, _$from.pos - 1);
  }
  return emptyPlaceholder(defaultPlaceholderText);
}
function createPlugin(intl, defaultPlaceholderText, bracketPlaceholderText, emptyLinePlaceholder, api) {
  if (!defaultPlaceholderText && !bracketPlaceholderText) {
    return;
  }
  return new _safePlugin.SafePlugin({
    key: pluginKey,
    state: {
      init: function init(_, state) {
        var _api$focus, _api$typeAhead;
        return createPlaceHolderStateFrom({
          isEditorFocused: Boolean(api === null || api === void 0 || (_api$focus = api.focus) === null || _api$focus === void 0 || (_api$focus = _api$focus.sharedState.currentState()) === null || _api$focus === void 0 ? void 0 : _api$focus.hasFocus),
          editorState: state,
          isTypeAheadOpen: api === null || api === void 0 || (_api$typeAhead = api.typeAhead) === null || _api$typeAhead === void 0 ? void 0 : _api$typeAhead.actions.isOpen,
          defaultPlaceholderText: defaultPlaceholderText,
          bracketPlaceholderText: bracketPlaceholderText,
          emptyLinePlaceholder: emptyLinePlaceholder,
          intl: intl
        });
      },
      apply: function apply(tr, placeholderState, _oldEditorState, newEditorState) {
        var _api$focus2, _api$typeAhead3, _placeholderState$pla;
        var meta = tr.getMeta(pluginKey);
        var isEditorFocused = Boolean(api === null || api === void 0 || (_api$focus2 = api.focus) === null || _api$focus2 === void 0 || (_api$focus2 = _api$focus2.sharedState.currentState()) === null || _api$focus2 === void 0 ? void 0 : _api$focus2.hasFocus);
        if ((meta === null || meta === void 0 ? void 0 : meta.placeholderText) !== undefined) {
          var _api$typeAhead2;
          return createPlaceHolderStateFrom({
            isEditorFocused: isEditorFocused,
            editorState: newEditorState,
            isTypeAheadOpen: api === null || api === void 0 || (_api$typeAhead2 = api.typeAhead) === null || _api$typeAhead2 === void 0 ? void 0 : _api$typeAhead2.actions.isOpen,
            defaultPlaceholderText: meta.placeholderText,
            bracketPlaceholderText: bracketPlaceholderText,
            emptyLinePlaceholder: emptyLinePlaceholder,
            intl: intl
          });
        }
        return createPlaceHolderStateFrom({
          isEditorFocused: isEditorFocused,
          editorState: newEditorState,
          isTypeAheadOpen: api === null || api === void 0 || (_api$typeAhead3 = api.typeAhead) === null || _api$typeAhead3 === void 0 ? void 0 : _api$typeAhead3.actions.isOpen,
          defaultPlaceholderText: (_placeholderState$pla = placeholderState === null || placeholderState === void 0 ? void 0 : placeholderState.placeholderText) !== null && _placeholderState$pla !== void 0 ? _placeholderState$pla : defaultPlaceholderText,
          bracketPlaceholderText: bracketPlaceholderText,
          emptyLinePlaceholder: emptyLinePlaceholder,
          intl: intl
        });
      }
    },
    props: {
      decorations: function decorations(editorState) {
        var _api$composition;
        var _getPlaceholderState = getPlaceholderState(editorState),
          hasPlaceholder = _getPlaceholderState.hasPlaceholder,
          placeholderText = _getPlaceholderState.placeholderText,
          pos = _getPlaceholderState.pos;
        var compositionPluginState = api === null || api === void 0 || (_api$composition = api.composition) === null || _api$composition === void 0 ? void 0 : _api$composition.sharedState.currentState();
        if (hasPlaceholder && placeholderText && pos !== undefined && !(compositionPluginState !== null && compositionPluginState !== void 0 && compositionPluginState.isComposing)) {
          return createPlaceholderDecoration(editorState, placeholderText, pos);
        }
        return;
      }
    }
  });
}
var placeholderPlugin = exports.placeholderPlugin = function placeholderPlugin(_ref2) {
  var options = _ref2.config,
    api = _ref2.api;
  var currentPlaceholder = options === null || options === void 0 ? void 0 : options.placeholder;
  return {
    name: 'placeholder',
    commands: {
      setPlaceholder: function setPlaceholder(placeholderText) {
        return function (_ref3) {
          var tr = _ref3.tr;
          if (currentPlaceholder !== placeholderText) {
            currentPlaceholder = placeholderText;
            return tr.setMeta(pluginKey, {
              placeholderText: placeholderText
            });
          }
          return null;
        };
      }
    },
    pmPlugins: function pmPlugins() {
      return [{
        name: 'placeholder',
        plugin: function plugin(_ref4) {
          var getIntl = _ref4.getIntl;
          return createPlugin(getIntl(), options && options.placeholder, options && options.placeholderBracketHint, options && options.emptyLinePlaceholder, api);
        }
      }];
    }
  };
};