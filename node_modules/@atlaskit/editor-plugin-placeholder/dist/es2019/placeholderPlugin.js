import { placeholderTextMessages as messages } from '@atlaskit/editor-common/messages';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { bracketTyped, browser, isEmptyDocument, isEmptyParagraph } from '@atlaskit/editor-common/utils';
import { PluginKey } from '@atlaskit/editor-prosemirror/state';
import { findParentNode } from '@atlaskit/editor-prosemirror/utils';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
export const pluginKey = new PluginKey('placeholderPlugin');
function getPlaceholderState(editorState) {
  return pluginKey.getState(editorState);
}
export const placeholderTestId = 'placeholder-test-id';
const nodeTypesWithLongPlaceholderText = ['expand', 'panel'];
const nodeTypesWithShortPlaceholderText = ['tableCell', 'tableHeader'];
export function createPlaceholderDecoration(editorState, placeholderText, pos = 1) {
  const placeholderDecoration = document.createElement('span');
  let placeholderNodeWithText = placeholderDecoration;
  placeholderDecoration.setAttribute('data-testid', placeholderTestId);
  placeholderDecoration.className = 'placeholder-decoration';

  // PM sets contenteditable to false on Decorations so Firefox doesn't display the flashing cursor
  // So adding an extra span which will contain the placeholder text
  if (browser.gecko) {
    const placeholderNode = document.createElement('span');
    placeholderNode.setAttribute('contenteditable', 'true'); // explicitly overriding the default Decoration behaviour
    placeholderDecoration.appendChild(placeholderNode);
    placeholderNodeWithText = placeholderNode;
  }
  placeholderNodeWithText.textContent = placeholderText || ' ';

  // ME-2289 Tapping on backspace in empty editor hides and displays the keyboard
  // Add a editable buff node as the cursor moving forward is inevitable
  // when backspace in GBoard composition
  if (browser.android && browser.chrome) {
    const buffNode = document.createElement('span');
    buffNode.setAttribute('class', 'placeholder-android');
    buffNode.setAttribute('contenteditable', 'true');
    buffNode.textContent = ' ';
    placeholderDecoration.appendChild(buffNode);
  }
  const isTargetNested = editorState.doc.resolve(pos).depth > 1;

  // only truncate text for nested nodes, otherwise applying 'overflow: hidden;' to top level nodes
  // creates issues with quick insert button
  if (isTargetNested && editorExperiment('platform_editor_controls', 'variant1')) {
    placeholderDecoration.classList.add('placeholder-decoration-hide-overflow');
  }
  return DecorationSet.create(editorState.doc, [Decoration.widget(pos, placeholderDecoration, {
    side: 0,
    key: `placeholder ${placeholderText}`
  })]);
}
function setPlaceHolderState(placeholderText, pos) {
  return {
    hasPlaceholder: true,
    placeholderText,
    pos: pos ? pos : 1
  };
}
const emptyPlaceholder = placeholderText => ({
  hasPlaceholder: false,
  placeholderText
});
function createPlaceHolderStateFrom({
  isEditorFocused,
  editorState,
  isTypeAheadOpen,
  defaultPlaceholderText,
  intl,
  bracketPlaceholderText,
  emptyLinePlaceholder
}) {
  if (isTypeAheadOpen !== null && isTypeAheadOpen !== void 0 && isTypeAheadOpen(editorState)) {
    return emptyPlaceholder(defaultPlaceholderText);
  }
  if (defaultPlaceholderText && isEmptyDocument(editorState.doc)) {
    return setPlaceHolderState(defaultPlaceholderText);
  }
  if (isEditorFocused && editorExperiment('platform_editor_controls', 'variant1')) {
    var _parentNode$firstChil, _parentNode$firstChil2;
    const {
      $from,
      $to
    } = editorState.selection;
    if ($from.pos !== $to.pos) {
      return emptyPlaceholder(defaultPlaceholderText);
    }
    const parentNode = $from.node($from.depth - 1);
    const parentType = parentNode === null || parentNode === void 0 ? void 0 : parentNode.type.name;
    if (emptyLinePlaceholder && parentType === 'doc') {
      const isEmptyLine = isEmptyParagraph($from.parent);
      if (isEmptyLine) {
        return setPlaceHolderState(emptyLinePlaceholder, $from.pos);
      }
    }
    const isEmptyNode = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childCount) === 1 && ((_parentNode$firstChil = parentNode.firstChild) === null || _parentNode$firstChil === void 0 ? void 0 : _parentNode$firstChil.content.size) === 0 && ((_parentNode$firstChil2 = parentNode.firstChild) === null || _parentNode$firstChil2 === void 0 ? void 0 : _parentNode$firstChil2.type.name) === 'paragraph';
    if (nodeTypesWithShortPlaceholderText.includes(parentType) && isEmptyNode) {
      var _table$node$firstChil;
      if (!fg('platform_editor_controls_patch_3')) {
        return setPlaceHolderState(intl.formatMessage(messages.shortEmptyNodePlaceholderText), $from.pos);
      }
      const table = findParentNode(node => node.type === editorState.schema.nodes.table)(editorState.selection);
      if (!table) {
        return emptyPlaceholder(defaultPlaceholderText);
      }
      const isFirstCell = (table === null || table === void 0 ? void 0 : (_table$node$firstChil = table.node.firstChild) === null || _table$node$firstChil === void 0 ? void 0 : _table$node$firstChil.content.firstChild) === parentNode;
      if (isFirstCell) {
        return setPlaceHolderState(intl.formatMessage(messages.shortEmptyNodePlaceholderText), $from.pos);
      }
    }
    if (nodeTypesWithLongPlaceholderText.includes(parentType) && isEmptyNode) {
      return setPlaceHolderState(intl.formatMessage(messages.longEmptyNodePlaceholderText), $from.pos);
    }
    return emptyPlaceholder(defaultPlaceholderText);
  }
  if (bracketPlaceholderText && bracketTyped(editorState) && isEditorFocused) {
    const {
      $from
    } = editorState.selection;
    // Space is to account for positioning of the bracket
    const bracketHint = '  ' + bracketPlaceholderText;
    return setPlaceHolderState(bracketHint, $from.pos - 1);
  }
  return emptyPlaceholder(defaultPlaceholderText);
}
export function createPlugin(intl, defaultPlaceholderText, bracketPlaceholderText, emptyLinePlaceholder, api) {
  if (!defaultPlaceholderText && !bracketPlaceholderText) {
    return;
  }
  return new SafePlugin({
    key: pluginKey,
    state: {
      init: (_, state) => {
        var _api$focus, _api$focus$sharedStat, _api$typeAhead;
        return createPlaceHolderStateFrom({
          isEditorFocused: Boolean(api === null || api === void 0 ? void 0 : (_api$focus = api.focus) === null || _api$focus === void 0 ? void 0 : (_api$focus$sharedStat = _api$focus.sharedState.currentState()) === null || _api$focus$sharedStat === void 0 ? void 0 : _api$focus$sharedStat.hasFocus),
          editorState: state,
          isTypeAheadOpen: api === null || api === void 0 ? void 0 : (_api$typeAhead = api.typeAhead) === null || _api$typeAhead === void 0 ? void 0 : _api$typeAhead.actions.isOpen,
          defaultPlaceholderText,
          bracketPlaceholderText,
          emptyLinePlaceholder,
          intl
        });
      },
      apply: (tr, placeholderState, _oldEditorState, newEditorState) => {
        var _api$focus2, _api$focus2$sharedSta, _api$typeAhead3, _placeholderState$pla;
        const meta = tr.getMeta(pluginKey);
        const isEditorFocused = Boolean(api === null || api === void 0 ? void 0 : (_api$focus2 = api.focus) === null || _api$focus2 === void 0 ? void 0 : (_api$focus2$sharedSta = _api$focus2.sharedState.currentState()) === null || _api$focus2$sharedSta === void 0 ? void 0 : _api$focus2$sharedSta.hasFocus);
        if ((meta === null || meta === void 0 ? void 0 : meta.placeholderText) !== undefined) {
          var _api$typeAhead2;
          return createPlaceHolderStateFrom({
            isEditorFocused,
            editorState: newEditorState,
            isTypeAheadOpen: api === null || api === void 0 ? void 0 : (_api$typeAhead2 = api.typeAhead) === null || _api$typeAhead2 === void 0 ? void 0 : _api$typeAhead2.actions.isOpen,
            defaultPlaceholderText: meta.placeholderText,
            bracketPlaceholderText,
            emptyLinePlaceholder,
            intl
          });
        }
        return createPlaceHolderStateFrom({
          isEditorFocused,
          editorState: newEditorState,
          isTypeAheadOpen: api === null || api === void 0 ? void 0 : (_api$typeAhead3 = api.typeAhead) === null || _api$typeAhead3 === void 0 ? void 0 : _api$typeAhead3.actions.isOpen,
          defaultPlaceholderText: (_placeholderState$pla = placeholderState === null || placeholderState === void 0 ? void 0 : placeholderState.placeholderText) !== null && _placeholderState$pla !== void 0 ? _placeholderState$pla : defaultPlaceholderText,
          bracketPlaceholderText,
          emptyLinePlaceholder,
          intl
        });
      }
    },
    props: {
      decorations(editorState) {
        var _api$composition;
        const {
          hasPlaceholder,
          placeholderText,
          pos
        } = getPlaceholderState(editorState);
        const compositionPluginState = api === null || api === void 0 ? void 0 : (_api$composition = api.composition) === null || _api$composition === void 0 ? void 0 : _api$composition.sharedState.currentState();
        if (hasPlaceholder && placeholderText && pos !== undefined && !(compositionPluginState !== null && compositionPluginState !== void 0 && compositionPluginState.isComposing)) {
          return createPlaceholderDecoration(editorState, placeholderText, pos);
        }
        return;
      }
    }
  });
}
export const placeholderPlugin = ({
  config: options,
  api
}) => {
  let currentPlaceholder = options === null || options === void 0 ? void 0 : options.placeholder;
  return {
    name: 'placeholder',
    commands: {
      setPlaceholder: placeholderText => ({
        tr
      }) => {
        if (currentPlaceholder !== placeholderText) {
          currentPlaceholder = placeholderText;
          return tr.setMeta(pluginKey, {
            placeholderText: placeholderText
          });
        }
        return null;
      }
    },
    pmPlugins() {
      return [{
        name: 'placeholder',
        plugin: ({
          getIntl
        }) => createPlugin(getIntl(), options && options.placeholder, options && options.placeholderBracketHint, options && options.emptyLinePlaceholder, api)
      }];
    }
  };
};