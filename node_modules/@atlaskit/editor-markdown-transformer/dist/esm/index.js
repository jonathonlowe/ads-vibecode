import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { defaultSchema } from '@atlaskit/adf-schema/schema-default';
import MarkdownIt from 'markdown-it';
import { markdownItTable } from 'markdown-it-table';
import { MarkdownParser } from '@atlaskit/editor-prosemirror/markdown';
import { markdownItMedia } from './media';

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function filterMdToPmSchemaMapping(schema, map) {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return Object.keys(map).reduce(function (newMap, key) {
    var value = map[key];
    var block = value.block || value.node;
    var mark = value.mark;
    if (block && schema.nodes[block] || mark && schema.marks[mark]) {
      newMap[key] = value;
    }
    return newMap;
  }, {});
}
var pmSchemaToMdMapping = {
  nodes: {
    blockquote: 'blockquote',
    paragraph: 'paragraph',
    rule: 'hr',
    // lheading (---, ===)
    heading: ['heading', 'lheading'],
    codeBlock: ['code', 'fence'],
    listItem: 'list',
    image: 'image'
  },
  marks: {
    em: 'emphasis',
    strong: 'text',
    link: ['link', 'autolink', 'reference', 'linkify'],
    strike: 'strikethrough',
    code: 'backticks'
  }
};
var mdToPmMapping = {
  blockquote: {
    block: 'blockquote'
  },
  paragraph: {
    block: 'paragraph'
  },
  em: {
    mark: 'em'
  },
  strong: {
    mark: 'strong'
  },
  link: {
    mark: 'link',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        href: tok.attrGet('href'),
        title: tok.attrGet('title') || null
      };
    }
  },
  hr: {
    node: 'rule'
  },
  heading: {
    block: 'heading',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        level: +tok.tag.slice(1)
      };
    }
  },
  softbreak: {
    node: 'hardBreak'
  },
  hardbreak: {
    node: 'hardBreak'
  },
  code_block: {
    block: 'codeBlock'
  },
  list_item: {
    block: 'listItem'
  },
  bullet_list: {
    block: 'bulletList'
  },
  ordered_list: {
    block: 'orderedList',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        order: typeof tok.attrGet('start') === 'number' ? tok.attrGet('start') : 1
      };
    }
  },
  code_inline: {
    mark: 'code'
  },
  fence: {
    block: 'codeBlock',
    // we trim any whitespaces around language definition
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        language: tok.info && tok.info.trim() || null
      };
    }
  },
  media_single: {
    block: 'mediaSingle',
    attrs: function attrs() {
      return {};
    }
  },
  media: {
    node: 'media',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        url: tok.attrGet('url'),
        alt: tok.attrGet('alt'),
        type: 'external'
      };
    }
  },
  emoji: {
    node: 'emoji',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        shortName: ":".concat(tok.markup, ":"),
        text: tok.content
      };
    }
  },
  table: {
    block: 'table'
  },
  tr: {
    block: 'tableRow'
  },
  th: {
    block: 'tableHeader'
  },
  td: {
    block: 'tableCell'
  },
  s: {
    mark: 'strike'
  },
  task_list: {
    block: 'taskList'
  },
  task_item: {
    block: 'taskItem',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: function attrs(tok) {
      return {
        state: tok.meta
      };
    }
  }
};
var md = MarkdownIt('zero', {
  html: false
});
md.enable([
// Process html entity - &#123;, &#xAF;, &quot;, ...
'entity',
// Process escaped chars and hardbreaks
'escape']);
export var MarkdownTransformer = /*#__PURE__*/function () {
  function MarkdownTransformer() {
    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSchema;
    var tokenizer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : md;
    _classCallCheck(this, MarkdownTransformer);
    // Enable markdown plugins based on schema
    ['nodes', 'marks'].forEach(function (key) {
      for (var idx in pmSchemaToMdMapping[key]) {
        if (schema[key][idx]) {
          tokenizer.enable(pmSchemaToMdMapping[key][idx]);
        }
      }
    });
    if (schema.nodes.table) {
      tokenizer.use(markdownItTable);
    }
    if (schema.nodes.media && schema.nodes.mediaSingle) {
      tokenizer.use(markdownItMedia);
    }
    this.markdownParser = new MarkdownParser(schema, tokenizer, filterMdToPmSchemaMapping(schema, mdToPmMapping));
  }
  return _createClass(MarkdownTransformer, [{
    key: "encode",
    value: function encode(_node) {
      throw new Error('This is not implemented yet');
    }
  }, {
    key: "parse",
    value: function parse(content) {
      return this.markdownParser.parse(content);
    }
  }]);
}();