import { defaultSchema } from '@atlaskit/adf-schema/schema-default';
import MarkdownIt from 'markdown-it';
import { markdownItTable } from 'markdown-it-table';
import { MarkdownParser } from '@atlaskit/editor-prosemirror/markdown';
import { markdownItMedia } from './media';

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function filterMdToPmSchemaMapping(schema, map) {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return Object.keys(map).reduce((newMap, key) => {
    const value = map[key];
    const block = value.block || value.node;
    const mark = value.mark;
    if (block && schema.nodes[block] || mark && schema.marks[mark]) {
      newMap[key] = value;
    }
    return newMap;
  }, {});
}
const pmSchemaToMdMapping = {
  nodes: {
    blockquote: 'blockquote',
    paragraph: 'paragraph',
    rule: 'hr',
    // lheading (---, ===)
    heading: ['heading', 'lheading'],
    codeBlock: ['code', 'fence'],
    listItem: 'list',
    image: 'image'
  },
  marks: {
    em: 'emphasis',
    strong: 'text',
    link: ['link', 'autolink', 'reference', 'linkify'],
    strike: 'strikethrough',
    code: 'backticks'
  }
};
const mdToPmMapping = {
  blockquote: {
    block: 'blockquote'
  },
  paragraph: {
    block: 'paragraph'
  },
  em: {
    mark: 'em'
  },
  strong: {
    mark: 'strong'
  },
  link: {
    mark: 'link',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      href: tok.attrGet('href'),
      title: tok.attrGet('title') || null
    })
  },
  hr: {
    node: 'rule'
  },
  heading: {
    block: 'heading',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      level: +tok.tag.slice(1)
    })
  },
  softbreak: {
    node: 'hardBreak'
  },
  hardbreak: {
    node: 'hardBreak'
  },
  code_block: {
    block: 'codeBlock'
  },
  list_item: {
    block: 'listItem'
  },
  bullet_list: {
    block: 'bulletList'
  },
  ordered_list: {
    block: 'orderedList',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      order: typeof tok.attrGet('start') === 'number' ? tok.attrGet('start') : 1
    })
  },
  code_inline: {
    mark: 'code'
  },
  fence: {
    block: 'codeBlock',
    // we trim any whitespaces around language definition
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      language: tok.info && tok.info.trim() || null
    })
  },
  media_single: {
    block: 'mediaSingle',
    attrs: () => ({})
  },
  media: {
    node: 'media',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => {
      return {
        url: tok.attrGet('url'),
        alt: tok.attrGet('alt'),
        type: 'external'
      };
    }
  },
  emoji: {
    node: 'emoji',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      shortName: `:${tok.markup}:`,
      text: tok.content
    })
  },
  table: {
    block: 'table'
  },
  tr: {
    block: 'tableRow'
  },
  th: {
    block: 'tableHeader'
  },
  td: {
    block: 'tableCell'
  },
  s: {
    mark: 'strike'
  },
  task_list: {
    block: 'taskList'
  },
  task_item: {
    block: 'taskItem',
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    attrs: tok => ({
      state: tok.meta
    })
  }
};
const md = MarkdownIt('zero', {
  html: false
});
md.enable([
// Process html entity - &#123;, &#xAF;, &quot;, ...
'entity',
// Process escaped chars and hardbreaks
'escape']);
export class MarkdownTransformer {
  constructor(schema = defaultSchema, tokenizer = md) {
    // Enable markdown plugins based on schema
    ['nodes', 'marks'].forEach(key => {
      for (const idx in pmSchemaToMdMapping[key]) {
        if (schema[key][idx]) {
          tokenizer.enable(pmSchemaToMdMapping[key][idx]);
        }
      }
    });
    if (schema.nodes.table) {
      tokenizer.use(markdownItTable);
    }
    if (schema.nodes.media && schema.nodes.mediaSingle) {
      tokenizer.use(markdownItMedia);
    }
    this.markdownParser = new MarkdownParser(schema, tokenizer, filterMdToPmSchemaMapping(schema, mdToPmMapping));
  }
  encode(_node) {
    throw new Error('This is not implemented yet');
  }
  parse(content) {
    return this.markdownParser.parse(content);
  }
}