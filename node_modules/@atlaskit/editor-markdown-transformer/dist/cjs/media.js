"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.markdownItMedia = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
function createRule() {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  var regx = /!\[([^\]]*)\]\(([^)]*?)\s*(?:"([^")]*)"\s*)?\)/g;
  var validParentTokens = ['th_open', 'td_open', 'list_item_open', 'blockquote_open'];

  /**
   * This function looks for strings that matches ![description](url) inside Inline-tokens.
   * It will then split the Inline-token with content before and after the image, example:
   *
   * Input (tokens):
   *   paragraph_open
   *   inline - content: Hello ![](image.jpg) World!
   *   paragraph_close
   * Output (tokens):
   *   paragraph_open
   *   inline - content: Hello
   *   paragraph_close
   *   media_single_open
   *   media
   *   media_single_close
   *   paragraph_open
   *   inline - content: World!
   *   paragraph_close
   *
   * This is applied before the inline content is parsed, to ensure that the formatting of
   * remaining inline content (bold, links, etc.) is kept intact!
   */
  return function media(State) {
    var getUrl = function getUrl(str) {
      var res = State.md.helpers.parseLinkDestination(str, str.indexOf('(') + 1, str.length);
      if (res.ok) {
        var href = State.md.normalizeLink(res.str);
        if (State.md.validateLink(href)) {
          return href;
        }
      }
      return '';
    };
    var createMediaTokens = function createMediaTokens(url) {
      var alt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var mediaSingleOpen = new State.Token('media_single_open', '', 1);
      var media = new State.Token('media', '', 0);
      media.attrs = [['url', getUrl(url)], ['type', 'external'], ['alt', alt]];
      var mediaSingleClose = new State.Token('media_single_close', '', -1);
      return [mediaSingleOpen, media, mediaSingleClose];
    };
    var createInlineTokens = function createInlineTokens(str, openingTokens, closingTokens) {
      if (!str || str.length === 0) {
        return [];
      }
      var inlineBefore = new State.Token('inline', '', 1);
      inlineBefore.content = str;
      inlineBefore.children = [];
      return [].concat((0, _toConsumableArray2.default)(openingTokens), [inlineBefore], (0, _toConsumableArray2.default)(closingTokens));
    };
    var processedTokens = [];
    var newTokens = State.tokens.reduce(function (tokens, token, i, arr) {
      var matchAll = Array.from(token.content.matchAll(regx));
      if (token.type === 'inline' && matchAll.length) {
        var openingTokens = [];
        var cursor = i - 1;
        var previousToken = arr[cursor];
        var subTree = [];
        while (previousToken && previousToken.level > 0 && validParentTokens.indexOf(previousToken.type) === -1) {
          openingTokens.unshift(previousToken);
          cursor--;
          previousToken = arr[cursor];
        }
        if (validParentTokens.indexOf(previousToken.type) === -1) {
          openingTokens.unshift(previousToken);
        } else {
          cursor++;
        }
        var closingTokens = openingTokens.map(function (token) {
          return new State.Token(token.type.replace('_open', '_close'), token.tag, -1);
        }).reverse();
        var inlineContentStack = token.content;
        matchAll.forEach(function (match, j) {
          var _match = (0, _slicedToArray2.default)(match, 3),
            matchString = _match[0],
            alt = _match[1],
            url = _match[2];
          var start = inlineContentStack.indexOf(matchString);
          var contentBefore = inlineContentStack.substr(0, start);
          inlineContentStack = inlineContentStack.substr(start + matchString.length);
          subTree = [].concat((0, _toConsumableArray2.default)(subTree), (0, _toConsumableArray2.default)(createInlineTokens(contentBefore, openingTokens, closingTokens)), (0, _toConsumableArray2.default)(createMediaTokens(url, alt)));
        });
        if (inlineContentStack.length) {
          subTree = [].concat((0, _toConsumableArray2.default)(subTree), (0, _toConsumableArray2.default)(createInlineTokens(inlineContentStack, openingTokens, closingTokens)));
        }
        processedTokens = [].concat((0, _toConsumableArray2.default)(processedTokens), (0, _toConsumableArray2.default)(closingTokens.map(function (c) {
          return c.type;
        })));
        tokens = [].concat((0, _toConsumableArray2.default)(tokens.slice(0, cursor)), (0, _toConsumableArray2.default)(subTree));
      } else if (processedTokens.indexOf(token.type) !== -1) {
        // Ignore token if it's already processed
        processedTokens.splice(processedTokens.indexOf(token.type), 1);
      } else {
        tokens.push(token);
      }
      return tokens;
    }, []);
    State.tokens = newTokens;
    return true;
  };
}

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var markdownItMedia = exports.markdownItMedia = function markdownItMedia(md) {
  md.core.ruler.before('inline', 'media', createRule());
};