import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { forwardRef, useCallback } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { useMergeRefs } from 'use-callback-ref';
import { N0 } from '@atlaskit/theme/colors';
import { CURRENT_SURFACE_CSS_VAR } from '@atlaskit/tokens';
import usePreventProgrammaticScroll from '../../hooks/use-prevent-programmatic-scroll';
export var wrapperWidth = {
  full: {
    width: '100vw'
  },
  extended: {
    width: '95vw'
  },
  narrow: {
    width: 360
  },
  medium: {
    width: 480
  },
  wide: {
    width: 600
  }
};
var wrapperStyles = css(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
  display: 'flex',
  height: '100vh',
  position: 'fixed',
  zIndex: 500,
  backgroundColor: "var(--ds-surface-overlay, ".concat(N0, ")")
}, CURRENT_SURFACE_CSS_VAR, "var(--ds-surface-overlay, ".concat(N0, ")")), "fontFamily", "var(--ds-font-family-body, ui-sans-serif, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Ubuntu, \"Helvetica Neue\", sans-serif)"), "insetBlockStart", 0), "insetInlineStart", 0), "overflow", 'hidden'));
/**
 * A wrapper that controls the styling of the drawer with a few hacks with refs to get our TouchÂ±Scroll locks working.
 */
var DrawerWrapper = /*#__PURE__*/forwardRef(function (_ref, scrollRef) {
  var children = _ref.children,
    className = _ref.className,
    _ref$width = _ref.width,
    width = _ref$width === void 0 ? 'narrow' : _ref$width,
    testId = _ref.testId,
    drawerRef = _ref.drawerRef,
    label = _ref.label,
    titleId = _ref.titleId;
  /**
   * We use a callback ref to assign the `<Content />` component to the forwarded `scrollRef`.
   * This ref comes from `react-scrolllock` to allow touch scrolling, eg.: `<ScrollLock><TouchScrollable>{children}</TouchScrollable><ScrollLock>`
   *
   * This is because we do not control the `<Content />` component in order to forward a ref to it (given it can be overriden via `DrawerPrimitiveProps['overrides']['Content']['component']`).
   * Additionally, we target the last child because with `props.overrides.Sidebar.component = () => null` you only have one child.
   * If both `Sidebar.component` and `Content.component` return null you will have no children and this will throw an error, but that doesn't seem valid.
   */
  var assignSecondChildRef = useCallback(function (node) {
    var _node$children;
    if (node !== null && node !== void 0 && (_node$children = node.children) !== null && _node$children !== void 0 && _node$children.length && typeof scrollRef === 'function') {
      scrollRef(node.children[node.children.length - 1]);
    }
  }, [scrollRef]);
  var ref = useMergeRefs([drawerRef, assignSecondChildRef]);
  usePreventProgrammaticScroll();
  return jsx("div", {
    css: wrapperStyles
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: wrapperWidth[width]
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: className,
    "data-testid": testId,
    ref: ref,
    "aria-modal": true,
    role: "dialog",
    "aria-label": label,
    "aria-labelledby": titleId
  }, children);
});
export default DrawerWrapper;