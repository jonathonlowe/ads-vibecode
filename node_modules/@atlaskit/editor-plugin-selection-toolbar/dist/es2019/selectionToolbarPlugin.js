import React from 'react';
import { bind } from 'bind-event-listener';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { calculateToolbarPositionAboveSelection, calculateToolbarPositionOnCellSelection, calculateToolbarPositionTrackHead } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { setToolbarDocking, toggleToolbar, updateToolbarDocking } from './pm-plugins/commands';
import { selectionToolbarPluginKey } from './pm-plugins/plugin-key';
import { getOverflowFloatingToolbarConfig } from './ui/overflow-toolbar-config';
import { PageVisibilityWatcher } from './ui/PageVisibilityWatcher';
import { PrimaryToolbarComponent } from './ui/PrimaryToolbarComponent';
const getToolbarDocking = (contextualFormattingEnabled, userPreferencesProvider) => {
  if (contextualFormattingEnabled && editorExperiment('platform_editor_controls', 'variant1')) {
    var _userPreferencesProvi;
    return (_userPreferencesProvi = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition')) !== null && _userPreferencesProvi !== void 0 ? _userPreferencesProvi : 'none';
  }
  return 'top';
};
export const selectionToolbarPlugin = ({
  api,
  config
}) => {
  const __selectionToolbarHandlers = [];
  let primaryToolbarComponent;
  const {
    userPreferencesProvider,
    contextualFormattingEnabled
  } = config;
  if (editorExperiment('platform_editor_controls', 'variant1', {
    exposure: true
  })) {
    var _api$primaryToolbar;
    primaryToolbarComponent = ({
      popupsBoundariesElement,
      popupsMountPoint,
      popupsScrollableElement
    }) => /*#__PURE__*/React.createElement(PrimaryToolbarComponent, {
      api: api,
      popupsBoundariesElement: popupsBoundariesElement,
      popupsMountPoint: popupsMountPoint,
      popupsScrollableElement: popupsScrollableElement
    });
    api === null || api === void 0 ? void 0 : (_api$primaryToolbar = api.primaryToolbar) === null || _api$primaryToolbar === void 0 ? void 0 : _api$primaryToolbar.actions.registerComponent({
      name: 'overflowMenu',
      component: primaryToolbarComponent
    });
  }
  let previousToolbarDocking = (userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition')) || null;
  let isPreferenceInitialized = false;
  return {
    name: 'selectionToolbar',
    actions: {
      suppressToolbar: () => {
        var _api$core$actions$exe;
        return (_api$core$actions$exe = api === null || api === void 0 ? void 0 : api.core.actions.execute(toggleToolbar({
          hide: true
        }))) !== null && _api$core$actions$exe !== void 0 ? _api$core$actions$exe : false;
      },
      unsuppressToolbar: () => {
        var _api$core$actions$exe2;
        return (_api$core$actions$exe2 = api === null || api === void 0 ? void 0 : api.core.actions.execute(toggleToolbar({
          hide: false
        }))) !== null && _api$core$actions$exe2 !== void 0 ? _api$core$actions$exe2 : false;
      },
      setToolbarDocking: toolbarDocking => {
        var _api$core$actions$exe3, _api$analytics;
        return (_api$core$actions$exe3 = api === null || api === void 0 ? void 0 : api.core.actions.execute(setToolbarDocking({
          toolbarDocking,
          userPreferencesProvider,
          editorAnalyticsApi: api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions
        }))) !== null && _api$core$actions$exe3 !== void 0 ? _api$core$actions$exe3 : false;
      },
      refreshToolbarDocking: () => {
        if (userPreferencesProvider) {
          var _api$core$actions$exe4;
          const userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
          return (_api$core$actions$exe4 = api === null || api === void 0 ? void 0 : api.core.actions.execute(updateToolbarDocking({
            toolbarDocking: userToolbarDockingPref
          }))) !== null && _api$core$actions$exe4 !== void 0 ? _api$core$actions$exe4 : false;
        }
        return false;
      }
    },
    getSharedState(editorState) {
      if (!editorState) {
        return;
      }
      return selectionToolbarPluginKey.getState(editorState);
    },
    pmPlugins(selectionToolbarHandlers) {
      if (selectionToolbarHandlers) {
        __selectionToolbarHandlers.push(...selectionToolbarHandlers);
      }
      return [{
        name: 'selection-tracker',
        plugin: () => {
          return new SafePlugin({
            key: selectionToolbarPluginKey,
            state: {
              init() {
                return {
                  selectionStable: false,
                  hide: false,
                  toolbarDocking: getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider)
                };
              },
              apply(tr, pluginState) {
                const meta = tr.getMeta(selectionToolbarPluginKey);
                if (meta) {
                  return {
                    ...pluginState,
                    ...meta
                  };
                }

                // if the toolbarDockingInitialPosition preference has changed
                // update the toolbarDocking state
                if (!previousToolbarDocking && fg('platform_editor_controls_patch_4')) {
                  // we currently only check for the initial value
                  const toolbarDockingPreference = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition');
                  if (toolbarDockingPreference && toolbarDockingPreference !== previousToolbarDocking) {
                    previousToolbarDocking = toolbarDockingPreference;
                    const userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
                    if (pluginState.toolbarDocking !== userToolbarDockingPref) {
                      return {
                        ...pluginState,
                        toolbarDocking: userToolbarDockingPref
                      };
                    }
                  }
                }
                return pluginState;
              }
            },
            view(view) {
              const unbind = bind(view.root, {
                type: 'mouseup',
                listener: () => {
                  var _api$editorViewMode;
                  // We only want to set selectionStable to true if the editor has focus
                  // to prevent the toolbar from showing when the editor is blurred
                  // due to a click outside the editor.

                  const editorViewModePlugin = api === null || api === void 0 ? void 0 : (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : _api$editorViewMode.sharedState.currentState();
                  const isViewModeEnabled = (editorViewModePlugin === null || editorViewModePlugin === void 0 ? void 0 : editorViewModePlugin.mode) === 'view';
                  view.dispatch(view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: !isViewModeEnabled ? view.hasFocus() : true
                  }));
                }
              });
              const unbindEditorViewFocus = bind(view.dom, {
                type: 'focus',
                listener: () => {
                  view.dispatch(view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: true
                  }));
                }
              });
              return {
                destroy() {
                  unbind();
                  unbindEditorViewFocus();
                }
              };
            },
            appendTransaction(_transactions, _oldState, newState) {
              if (!isPreferenceInitialized && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_2')) {
                const toolbarDockingPreference = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition');
                if (toolbarDockingPreference !== undefined) {
                  var _api$analytics2;
                  isPreferenceInitialized = true;
                  const userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
                  const tr = newState.tr;
                  if (!fg('platform_editor_controls_patch_4')) {
                    tr.setMeta(selectionToolbarPluginKey, {
                      toolbarDocking: userToolbarDockingPref
                    });
                  }
                  api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions.attachAnalyticsEvent({
                    action: ACTION.INITIALISED,
                    actionSubject: ACTION_SUBJECT.USER_PREFERENCES,
                    actionSubjectId: ACTION_SUBJECT_ID.SELECTION_TOOLBAR_PREFERENCES,
                    attributes: {
                      toolbarDocking: userToolbarDockingPref
                    },
                    eventType: EVENT_TYPE.OPERATIONAL
                  })(tr);
                  return tr;
                }
              }
              return null;
            },
            props: {
              handleDOMEvents: {
                mousedown: view => {
                  view.dispatch(view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: false
                  }));
                  return false;
                }
              }
            }
          });
        }
      }];
    },
    pluginsOptions: {
      floatingToolbar(state, intl, providerFactory) {
        const {
          selectionStable,
          hide,
          toolbarDocking
        } = selectionToolbarPluginKey.getState(state);
        const isCellSelection = ('$anchorCell' in state.selection);
        const isEditorControlsEnabled = editorExperiment('platform_editor_controls', 'variant1');
        if (state.selection.empty || !selectionStable || hide || state.selection instanceof NodeSelection ||
        // $anchorCell is only available in CellSelection, this check is to
        // avoid importing CellSelection from @atlaskit/editor-tables
        isCellSelection && !isEditorControlsEnabled // for Editor Controls we want to show the toolbar on CellSelection
        ) {
          // If there is no active selection, or the selection is not stable, or the selection is a node selection,
          // do not show the toolbar.
          return;
        }
        if (isCellSelection && isEditorControlsEnabled && fg('platform_editor_controls_patch_5')) {
          var _api$blockControls, _api$blockControls$sh;
          const isSelectedViaDragHandle = api === null || api === void 0 ? void 0 : (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 ? void 0 : (_api$blockControls$sh = _api$blockControls.sharedState.currentState()) === null || _api$blockControls$sh === void 0 ? void 0 : _api$blockControls$sh.isSelectedViaDragHandle;
          if (isSelectedViaDragHandle) {
            return;
          }
        }

        // Resolve the selectionToolbarHandlers to a list of SelectionToolbarGroups
        // and filter out any handlers which returned undefined
        const resolved = __selectionToolbarHandlers.map(selectionToolbarHandler => selectionToolbarHandler(state, intl, providerFactory)).filter(resolved => resolved !== undefined);
        // Sort the groups by rank
        // This is intended to allow different plugins to control the order of the groups
        // they add to the selection toolbar.
        // ie. if you want to have your plugin's group appear first, set rank to -10 if there is currently another
        // plugin you expect to be run at the same time as with an rank of -9
        resolved.sort(({
          rank: rankA = 0
        }, {
          rank: rankB = 0
        }) => {
          if (rankA < rankB) {
            return 1;
          }
          return -1;
        });
        const items = [];

        // This flattens the groups passed into the floating toolbar into a single list of items
        for (let i = 0; i < resolved.length; i++) {
          var _resolved$i;
          // add a seperator icon after each group except the last
          if (Array.isArray((_resolved$i = resolved[i]) === null || _resolved$i === void 0 ? void 0 : _resolved$i.items)) {
            items.push(...resolved[i].items);
          }
          if (editorExperiment('platform_editor_controls', 'variant1')) {
            if (resolved[i] && resolved[i + 1]) {
              var _resolved$i2, _resolved, _resolved$i3, _resolved2, _resolved3;
              const shouldNotAddSeparator = ((_resolved$i2 = resolved[i]) === null || _resolved$i2 === void 0 ? void 0 : _resolved$i2.pluginName) === 'textColor' && ((_resolved = resolved[i + 1]) === null || _resolved === void 0 ? void 0 : _resolved.pluginName) === 'highlight' || ((_resolved$i3 = resolved[i]) === null || _resolved$i3 === void 0 ? void 0 : _resolved$i3.pluginName) === 'alignment' && ((_resolved2 = resolved[i + 1]) === null || _resolved2 === void 0 ? void 0 : _resolved2.pluginName) === 'toolbarListsIndentation';
              if (((_resolved3 = resolved[i + 1]) === null || _resolved3 === void 0 ? void 0 : _resolved3.pluginName) === 'annotation') {
                items.push({
                  type: 'separator',
                  fullHeight: true
                });
              } else if (!fg('platform_editor_controls_patch_6')) {
                if (i !== resolved.length - 1 && !shouldNotAddSeparator) {
                  items.push({
                    type: 'separator',
                    fullHeight: false
                  });
                }
              }
            }
          } else {
            if (i !== resolved.length - 1) {
              items.push({
                type: 'separator'
              });
            }
          }
        }
        if (items.length > 0 && contextualFormattingEnabled && isEditorControlsEnabled) {
          items.push(...getOverflowFloatingToolbarConfig({
            api,
            toolbarDocking,
            intl
          }));
        }
        let onPositionCalculated;
        const toolbarTitle = 'Selection toolbar';
        if (isCellSelection && isEditorControlsEnabled) {
          onPositionCalculated = calculateToolbarPositionOnCellSelection(toolbarTitle);
        } else {
          const calcToolbarPosition = config.preferenceToolbarAboveSelection ? calculateToolbarPositionAboveSelection : calculateToolbarPositionTrackHead;
          onPositionCalculated = calcToolbarPosition(toolbarTitle);
        }
        const nodeType = getSelectionNodeTypes(state);
        return {
          title: 'Selection toolbar',
          nodeType: nodeType,
          items: items,
          ...(isEditorControlsEnabled && {
            scrollable: true
          }),
          onPositionCalculated
        };
      }
    },
    contentComponent: editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_user_preferences_provider_update') ? () => /*#__PURE__*/React.createElement(PageVisibilityWatcher, {
      api: api,
      userPreferencesProvider: userPreferencesProvider
    }) : undefined,
    primaryToolbarComponent: !(api !== null && api !== void 0 && api.primaryToolbar) && editorExperiment('platform_editor_controls', 'variant1', {
      exposure: true
    }) ? primaryToolbarComponent : undefined
  };
};
function getSelectionNodeTypes(state) {
  const selectionNodeTypes = [];
  state.doc.nodesBetween(state.selection.from, state.selection.to, (node, _pos, parent) => {
    if (selectionNodeTypes.indexOf(node.type) !== 0) {
      selectionNodeTypes.push(node.type);
    }
  });
  return selectionNodeTypes;
}