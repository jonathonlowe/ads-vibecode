import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import { bind } from 'bind-event-listener';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { calculateToolbarPositionAboveSelection, calculateToolbarPositionOnCellSelection, calculateToolbarPositionTrackHead } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { setToolbarDocking as _setToolbarDocking, toggleToolbar, updateToolbarDocking } from './pm-plugins/commands';
import { selectionToolbarPluginKey } from './pm-plugins/plugin-key';
import { getOverflowFloatingToolbarConfig } from './ui/overflow-toolbar-config';
import { PageVisibilityWatcher } from './ui/PageVisibilityWatcher';
import { PrimaryToolbarComponent } from './ui/PrimaryToolbarComponent';
var getToolbarDocking = function getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider) {
  if (contextualFormattingEnabled && editorExperiment('platform_editor_controls', 'variant1')) {
    var _userPreferencesProvi;
    return (_userPreferencesProvi = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition')) !== null && _userPreferencesProvi !== void 0 ? _userPreferencesProvi : 'none';
  }
  return 'top';
};
export var selectionToolbarPlugin = function selectionToolbarPlugin(_ref) {
  var api = _ref.api,
    config = _ref.config;
  var __selectionToolbarHandlers = [];
  var primaryToolbarComponent;
  var userPreferencesProvider = config.userPreferencesProvider,
    contextualFormattingEnabled = config.contextualFormattingEnabled;
  if (editorExperiment('platform_editor_controls', 'variant1', {
    exposure: true
  })) {
    var _api$primaryToolbar;
    primaryToolbarComponent = function primaryToolbarComponent(_ref2) {
      var popupsBoundariesElement = _ref2.popupsBoundariesElement,
        popupsMountPoint = _ref2.popupsMountPoint,
        popupsScrollableElement = _ref2.popupsScrollableElement;
      return /*#__PURE__*/React.createElement(PrimaryToolbarComponent, {
        api: api,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsMountPoint: popupsMountPoint,
        popupsScrollableElement: popupsScrollableElement
      });
    };
    api === null || api === void 0 || (_api$primaryToolbar = api.primaryToolbar) === null || _api$primaryToolbar === void 0 || _api$primaryToolbar.actions.registerComponent({
      name: 'overflowMenu',
      component: primaryToolbarComponent
    });
  }
  var previousToolbarDocking = (userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition')) || null;
  var isPreferenceInitialized = false;
  return {
    name: 'selectionToolbar',
    actions: {
      suppressToolbar: function suppressToolbar() {
        var _api$core$actions$exe;
        return (_api$core$actions$exe = api === null || api === void 0 ? void 0 : api.core.actions.execute(toggleToolbar({
          hide: true
        }))) !== null && _api$core$actions$exe !== void 0 ? _api$core$actions$exe : false;
      },
      unsuppressToolbar: function unsuppressToolbar() {
        var _api$core$actions$exe2;
        return (_api$core$actions$exe2 = api === null || api === void 0 ? void 0 : api.core.actions.execute(toggleToolbar({
          hide: false
        }))) !== null && _api$core$actions$exe2 !== void 0 ? _api$core$actions$exe2 : false;
      },
      setToolbarDocking: function setToolbarDocking(toolbarDocking) {
        var _api$core$actions$exe3, _api$analytics;
        return (_api$core$actions$exe3 = api === null || api === void 0 ? void 0 : api.core.actions.execute(_setToolbarDocking({
          toolbarDocking: toolbarDocking,
          userPreferencesProvider: userPreferencesProvider,
          editorAnalyticsApi: api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions
        }))) !== null && _api$core$actions$exe3 !== void 0 ? _api$core$actions$exe3 : false;
      },
      refreshToolbarDocking: function refreshToolbarDocking() {
        if (userPreferencesProvider) {
          var _api$core$actions$exe4;
          var userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
          return (_api$core$actions$exe4 = api === null || api === void 0 ? void 0 : api.core.actions.execute(updateToolbarDocking({
            toolbarDocking: userToolbarDockingPref
          }))) !== null && _api$core$actions$exe4 !== void 0 ? _api$core$actions$exe4 : false;
        }
        return false;
      }
    },
    getSharedState: function getSharedState(editorState) {
      if (!editorState) {
        return;
      }
      return selectionToolbarPluginKey.getState(editorState);
    },
    pmPlugins: function pmPlugins(selectionToolbarHandlers) {
      if (selectionToolbarHandlers) {
        __selectionToolbarHandlers.push.apply(__selectionToolbarHandlers, _toConsumableArray(selectionToolbarHandlers));
      }
      return [{
        name: 'selection-tracker',
        plugin: function plugin() {
          return new SafePlugin({
            key: selectionToolbarPluginKey,
            state: {
              init: function init() {
                return {
                  selectionStable: false,
                  hide: false,
                  toolbarDocking: getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider)
                };
              },
              apply: function apply(tr, pluginState) {
                var meta = tr.getMeta(selectionToolbarPluginKey);
                if (meta) {
                  return _objectSpread(_objectSpread({}, pluginState), meta);
                }

                // if the toolbarDockingInitialPosition preference has changed
                // update the toolbarDocking state
                if (!previousToolbarDocking && fg('platform_editor_controls_patch_4')) {
                  // we currently only check for the initial value
                  var toolbarDockingPreference = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition');
                  if (toolbarDockingPreference && toolbarDockingPreference !== previousToolbarDocking) {
                    previousToolbarDocking = toolbarDockingPreference;
                    var userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
                    if (pluginState.toolbarDocking !== userToolbarDockingPref) {
                      return _objectSpread(_objectSpread({}, pluginState), {}, {
                        toolbarDocking: userToolbarDockingPref
                      });
                    }
                  }
                }
                return pluginState;
              }
            },
            view: function view(_view) {
              var unbind = bind(_view.root, {
                type: 'mouseup',
                listener: function listener() {
                  var _api$editorViewMode;
                  // We only want to set selectionStable to true if the editor has focus
                  // to prevent the toolbar from showing when the editor is blurred
                  // due to a click outside the editor.

                  var editorViewModePlugin = api === null || api === void 0 || (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : _api$editorViewMode.sharedState.currentState();
                  var isViewModeEnabled = (editorViewModePlugin === null || editorViewModePlugin === void 0 ? void 0 : editorViewModePlugin.mode) === 'view';
                  _view.dispatch(_view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: !isViewModeEnabled ? _view.hasFocus() : true
                  }));
                }
              });
              var unbindEditorViewFocus = bind(_view.dom, {
                type: 'focus',
                listener: function listener() {
                  _view.dispatch(_view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: true
                  }));
                }
              });
              return {
                destroy: function destroy() {
                  unbind();
                  unbindEditorViewFocus();
                }
              };
            },
            appendTransaction: function appendTransaction(_transactions, _oldState, newState) {
              if (!isPreferenceInitialized && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_2')) {
                var toolbarDockingPreference = userPreferencesProvider === null || userPreferencesProvider === void 0 ? void 0 : userPreferencesProvider.getPreference('toolbarDockingInitialPosition');
                if (toolbarDockingPreference !== undefined) {
                  var _api$analytics2;
                  isPreferenceInitialized = true;
                  var userToolbarDockingPref = getToolbarDocking(contextualFormattingEnabled, userPreferencesProvider);
                  var tr = newState.tr;
                  if (!fg('platform_editor_controls_patch_4')) {
                    tr.setMeta(selectionToolbarPluginKey, {
                      toolbarDocking: userToolbarDockingPref
                    });
                  }
                  api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 || _api$analytics2.actions.attachAnalyticsEvent({
                    action: ACTION.INITIALISED,
                    actionSubject: ACTION_SUBJECT.USER_PREFERENCES,
                    actionSubjectId: ACTION_SUBJECT_ID.SELECTION_TOOLBAR_PREFERENCES,
                    attributes: {
                      toolbarDocking: userToolbarDockingPref
                    },
                    eventType: EVENT_TYPE.OPERATIONAL
                  })(tr);
                  return tr;
                }
              }
              return null;
            },
            props: {
              handleDOMEvents: {
                mousedown: function mousedown(view) {
                  view.dispatch(view.state.tr.setMeta(selectionToolbarPluginKey, {
                    selectionStable: false
                  }));
                  return false;
                }
              }
            }
          });
        }
      }];
    },
    pluginsOptions: {
      floatingToolbar: function floatingToolbar(state, intl, providerFactory) {
        var _ref3 = selectionToolbarPluginKey.getState(state),
          selectionStable = _ref3.selectionStable,
          hide = _ref3.hide,
          toolbarDocking = _ref3.toolbarDocking;
        var isCellSelection = ('$anchorCell' in state.selection);
        var isEditorControlsEnabled = editorExperiment('platform_editor_controls', 'variant1');
        if (state.selection.empty || !selectionStable || hide || state.selection instanceof NodeSelection ||
        // $anchorCell is only available in CellSelection, this check is to
        // avoid importing CellSelection from @atlaskit/editor-tables
        isCellSelection && !isEditorControlsEnabled // for Editor Controls we want to show the toolbar on CellSelection
        ) {
          // If there is no active selection, or the selection is not stable, or the selection is a node selection,
          // do not show the toolbar.
          return;
        }
        if (isCellSelection && isEditorControlsEnabled && fg('platform_editor_controls_patch_5')) {
          var _api$blockControls;
          var isSelectedViaDragHandle = api === null || api === void 0 || (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 || (_api$blockControls = _api$blockControls.sharedState.currentState()) === null || _api$blockControls === void 0 ? void 0 : _api$blockControls.isSelectedViaDragHandle;
          if (isSelectedViaDragHandle) {
            return;
          }
        }

        // Resolve the selectionToolbarHandlers to a list of SelectionToolbarGroups
        // and filter out any handlers which returned undefined
        var resolved = __selectionToolbarHandlers.map(function (selectionToolbarHandler) {
          return selectionToolbarHandler(state, intl, providerFactory);
        }).filter(function (resolved) {
          return resolved !== undefined;
        });
        // Sort the groups by rank
        // This is intended to allow different plugins to control the order of the groups
        // they add to the selection toolbar.
        // ie. if you want to have your plugin's group appear first, set rank to -10 if there is currently another
        // plugin you expect to be run at the same time as with an rank of -9
        resolved.sort(function (_ref4, _ref5) {
          var _ref4$rank = _ref4.rank,
            rankA = _ref4$rank === void 0 ? 0 : _ref4$rank;
          var _ref5$rank = _ref5.rank,
            rankB = _ref5$rank === void 0 ? 0 : _ref5$rank;
          if (rankA < rankB) {
            return 1;
          }
          return -1;
        });
        var items = [];

        // This flattens the groups passed into the floating toolbar into a single list of items
        for (var i = 0; i < resolved.length; i++) {
          var _resolved$i;
          // add a seperator icon after each group except the last
          if (Array.isArray((_resolved$i = resolved[i]) === null || _resolved$i === void 0 ? void 0 : _resolved$i.items)) {
            items.push.apply(items, _toConsumableArray(resolved[i].items));
          }
          if (editorExperiment('platform_editor_controls', 'variant1')) {
            if (resolved[i] && resolved[i + 1]) {
              var _resolved$i2, _resolved, _resolved$i3, _resolved2, _resolved3;
              var shouldNotAddSeparator = ((_resolved$i2 = resolved[i]) === null || _resolved$i2 === void 0 ? void 0 : _resolved$i2.pluginName) === 'textColor' && ((_resolved = resolved[i + 1]) === null || _resolved === void 0 ? void 0 : _resolved.pluginName) === 'highlight' || ((_resolved$i3 = resolved[i]) === null || _resolved$i3 === void 0 ? void 0 : _resolved$i3.pluginName) === 'alignment' && ((_resolved2 = resolved[i + 1]) === null || _resolved2 === void 0 ? void 0 : _resolved2.pluginName) === 'toolbarListsIndentation';
              if (((_resolved3 = resolved[i + 1]) === null || _resolved3 === void 0 ? void 0 : _resolved3.pluginName) === 'annotation') {
                items.push({
                  type: 'separator',
                  fullHeight: true
                });
              } else if (!fg('platform_editor_controls_patch_6')) {
                if (i !== resolved.length - 1 && !shouldNotAddSeparator) {
                  items.push({
                    type: 'separator',
                    fullHeight: false
                  });
                }
              }
            }
          } else {
            if (i !== resolved.length - 1) {
              items.push({
                type: 'separator'
              });
            }
          }
        }
        if (items.length > 0 && contextualFormattingEnabled && isEditorControlsEnabled) {
          items.push.apply(items, _toConsumableArray(getOverflowFloatingToolbarConfig({
            api: api,
            toolbarDocking: toolbarDocking,
            intl: intl
          })));
        }
        var onPositionCalculated;
        var toolbarTitle = 'Selection toolbar';
        if (isCellSelection && isEditorControlsEnabled) {
          onPositionCalculated = calculateToolbarPositionOnCellSelection(toolbarTitle);
        } else {
          var calcToolbarPosition = config.preferenceToolbarAboveSelection ? calculateToolbarPositionAboveSelection : calculateToolbarPositionTrackHead;
          onPositionCalculated = calcToolbarPosition(toolbarTitle);
        }
        var nodeType = getSelectionNodeTypes(state);
        return _objectSpread(_objectSpread({
          title: 'Selection toolbar',
          nodeType: nodeType,
          items: items
        }, isEditorControlsEnabled && {
          scrollable: true
        }), {}, {
          onPositionCalculated: onPositionCalculated
        });
      }
    },
    contentComponent: editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_user_preferences_provider_update') ? function () {
      return /*#__PURE__*/React.createElement(PageVisibilityWatcher, {
        api: api,
        userPreferencesProvider: userPreferencesProvider
      });
    } : undefined,
    primaryToolbarComponent: !(api !== null && api !== void 0 && api.primaryToolbar) && editorExperiment('platform_editor_controls', 'variant1', {
      exposure: true
    }) ? primaryToolbarComponent : undefined
  };
};
function getSelectionNodeTypes(state) {
  var selectionNodeTypes = [];
  state.doc.nodesBetween(state.selection.from, state.selection.to, function (node, _pos, parent) {
    if (selectionNodeTypes.indexOf(node.type) !== 0) {
      selectionNodeTypes.push(node.type);
    }
  });
  return selectionNodeTypes;
}