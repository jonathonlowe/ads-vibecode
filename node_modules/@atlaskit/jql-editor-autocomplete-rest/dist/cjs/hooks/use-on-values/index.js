"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = require("react");
var _reactMagneticDi = require("react-magnetic-di");
var _empty = require("rxjs/observable/empty");
var _of = require("rxjs/observable/of");
var _concatMap = require("rxjs/operators/concatMap");
var _delay = require("rxjs/operators/delay");
var _filter = require("rxjs/operators/filter");
var _findFieldObservable = _interopRequireDefault(require("../../utils/find-field-observable"));
var _strings = require("../../utils/strings");
var _constants = require("../constants");
var _useFetchFieldValues = require("../use-fetch-field-values");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var getValueType = function getValueType(field) {
  if (field.types.includes(_constants.USER_FIELD_TYPE)) {
    return 'user';
  }
  return undefined;
};
var fieldValuesReducer = function fieldValuesReducer(state, action) {
  var _action$payload = action.payload,
    cacheKey = _action$payload.cacheKey,
    values = _action$payload.values;
  return _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2.default)({}, cacheKey, values));
};
var initialState = {};

// Hard coded delay before making a fetch call for operands.
var OPERANDS_DELAY_MS = 650;

// Used to remove emails from user display names in autocomplete values, which come in format: "Name - email".
// Pattern below is specific enough for this purpose and we should avoid writing a more complex email matcher.
var BASIC_REMOVE_EMAIL_REGEX = /\s-\s\S+@\S+\.\S+$/;
var useOnValues = function useOnValues(jqlSearchableFields$, getSuggestions, createAndFireAnalyticsEvent) {
  var fetchFieldValues = (0, _useFetchFieldValues.useFetchFieldValues)(getSuggestions, createAndFireAnalyticsEvent);
  var _useReducer = (0, _react.useReducer)(fieldValuesReducer, initialState),
    _useReducer2 = (0, _slicedToArray2.default)(_useReducer, 2),
    fieldValuesCache = _useReducer2[0],
    dispatch = _useReducer2[1];
  return (0, _react.useCallback)(function (query, field) {
    if (typeof field !== 'string' || field === '') {
      return (0, _empty.empty)();
    }
    var field$ = (0, _findFieldObservable.default)(jqlSearchableFields$, field);

    // API expects unquoted and unescaped values
    var normalizedField = (0, _strings.normalize)(field);
    var normalizedQuery = query !== undefined ? (0, _strings.normalize)(query) : '';

    // Cache values by field + query
    var cacheKey = "".concat(normalizedField, ":").concat(normalizedQuery);
    var isCacheHit = Object.prototype.hasOwnProperty.call(fieldValuesCache, cacheKey);
    return field$.pipe((0, _filter.filter)(function (matchingField) {
      return matchingField.auto === 'true';
    }), (0, _concatMap.concatMap)(function (matchingField) {
      var _matchingField$cfid;
      if (isCacheHit) {
        return (0, _of.of)(fieldValuesCache[cacheKey]);
      }

      // If we have a cfid then use it to fetch autocomplete suggestions as results will always be unique.
      // Otherwise it's possible `normalizedField` will match against multiple fields in the API and thus
      // return no data.
      var fieldNameForFetch = (_matchingField$cfid = matchingField.cfid) !== null && _matchingField$cfid !== void 0 ? _matchingField$cfid : normalizedField;

      // We emit a single value using Observable.of(null) and delay that event before fetching field values so we
      // can mimic debounce behaviour.
      return (0, _of.of)(null).pipe((0, _delay.delay)(OPERANDS_DELAY_MS), (0, _concatMap.concatMap)(function () {
        return fetchFieldValues(fieldNameForFetch, normalizedQuery).then(function (values) {
          var valueType = getValueType(matchingField);
          if (valueType === 'user') {
            values.forEach(function (value) {
              value.valueType = valueType;
              // REST autocomplete API returns user display names with this format: "Name - email". To be
              // consistent with hydration API, we want to remove email from this name for rich inline nodes.
              value.nameOnRichInlineNode = value.name.replace(BASIC_REMOVE_EMAIL_REGEX, '');
            });
          }
          // Save response to in-memory cache
          dispatch({
            type: 'update-cache',
            payload: {
              cacheKey: cacheKey,
              values: values
            }
          });
          return values;
        }).catch(function () {
          return [];
        });
      }));
    }),
    // We can filter out empty arrays as there is nothing to consume
    (0, _filter.filter)(function (operands) {
      return operands.length > 0;
    }));
  }, [jqlSearchableFields$, fieldValuesCache, fetchFieldValues]);
};
var _default = exports.default = useOnValues;