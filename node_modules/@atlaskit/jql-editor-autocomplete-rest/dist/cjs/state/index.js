"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useJqlSearchableFieldsObservable = exports.useJqlOrderableFieldsObservable = exports.useJqlFunctionsObservable = exports.useJqlAutocompleteActions = exports.store = exports.actions = exports.JQLAutocompleteContainer = void 0;
var _reactSweetState = require("react-sweet-state");
var _from = require("rxjs/observable/from");
var _concatMap = require("rxjs/operators/concatMap");
var _jqlEditorCommon = require("@atlaskit/jql-editor-common");
var _analytics = require("../analytics");
var initialData = {
  jqlSearchableFields: [],
  jqlOrderableFields: [],
  jqlFunctions: []
};
var initialState = {
  initialDataFetched: false,
  jqlSearchableFields$: (0, _from.from)(initialData.jqlSearchableFields),
  jqlOrderableFields$: (0, _from.from)(initialData.jqlOrderableFields),
  jqlFunctions$: (0, _from.from)(initialData.jqlFunctions)
};
var actions = exports.actions = {
  load: function load(getInitialData, createAndFireAnalyticsEvent) {
    return function (_ref) {
      var getState = _ref.getState,
        setState = _ref.setState;
      var _getState = getState(),
        initialDataFetched = _getState.initialDataFetched;
      if (initialDataFetched) {
        return;
      }
      var promise = getInitialData("/rest/api/latest/jql/autocompletedata").then(function (res) {
        var initialValue = {
          jqlSearchableFields: [],
          jqlOrderableFields: [],
          jqlFunctions: res.jqlFunctions
        };
        var data = res.jqlFields.reduce(function (result, field) {
          if (field.searchable === 'true') {
            result.jqlSearchableFields.push(field);
          }
          if (field.orderable === 'true') {
            result.jqlOrderableFields.push(field);
          }
          return result;
        }, initialValue);

        // Minor optimisation so consumers don't have to wait for the promise `then` function to be called
        // whenever we subscribe to the observable. (`then` runs async in the current thread loop)
        setState({
          jqlSearchableFields$: (0, _from.from)(data.jqlSearchableFields),
          jqlOrderableFields$: (0, _from.from)(data.jqlOrderableFields),
          jqlFunctions$: (0, _from.from)(data.jqlFunctions)
        });
        createAndFireAnalyticsEvent({
          action: _analytics.Action.SUCCESS,
          actionSubject: _analytics.ActionSubject.AUTOCOMPLETE_INITIAL_DATA,
          eventType: _jqlEditorCommon.EventType.OPERATIONAL
        });
        return data;
      }).catch(function () {
        setState({
          jqlSearchableFields$: initialState.jqlSearchableFields$,
          jqlOrderableFields$: initialState.jqlOrderableFields$,
          jqlFunctions$: initialState.jqlFunctions$
        });
        createAndFireAnalyticsEvent({
          action: _analytics.Action.FAILED,
          actionSubject: _analytics.ActionSubject.AUTOCOMPLETE_INITIAL_DATA,
          eventType: _jqlEditorCommon.EventType.OPERATIONAL
        });
        return initialData;
      });

      // Set the in-flight promise in state as an observable. This allows consumers to subscribe to our initial data
      // without worrying about race conditions with the API call.
      setState({
        initialDataFetched: true,
        jqlSearchableFields$: (0, _from.from)(promise).pipe((0, _concatMap.concatMap)(function (_ref2) {
          var jqlSearchableFields = _ref2.jqlSearchableFields;
          return jqlSearchableFields;
        })),
        jqlOrderableFields$: (0, _from.from)(promise).pipe((0, _concatMap.concatMap)(function (_ref3) {
          var jqlOrderableFields = _ref3.jqlOrderableFields;
          return jqlOrderableFields;
        })),
        jqlFunctions$: (0, _from.from)(promise).pipe((0, _concatMap.concatMap)(function (_ref4) {
          var jqlFunctions = _ref4.jqlFunctions;
          return jqlFunctions;
        }))
      });
    };
  }
};
var store = exports.store = (0, _reactSweetState.createStore)({
  initialState: initialState,
  actions: actions
});

/**
 * Exported to allow consumers to have multiple store instances with initial JQL data. Typically this is unnecessary as
 * initial autocomplete data can be shared across all JQL editor instances but this can be useful for storybook testing
 * if you want to mock different responses for each story.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var JQLAutocompleteContainer = exports.JQLAutocompleteContainer = (0, _reactSweetState.createContainer)(store);
var useJqlAutocompleteActions = exports.useJqlAutocompleteActions = (0, _reactSweetState.createHook)(store, {
  selector: null
});
var useJqlSearchableFieldsObservable = exports.useJqlSearchableFieldsObservable = (0, _reactSweetState.createHook)(store, {
  selector: function selector(_ref5) {
    var jqlSearchableFields$ = _ref5.jqlSearchableFields$;
    return jqlSearchableFields$;
  }
});
var useJqlOrderableFieldsObservable = exports.useJqlOrderableFieldsObservable = (0, _reactSweetState.createHook)(store, {
  selector: function selector(_ref6) {
    var jqlOrderableFields$ = _ref6.jqlOrderableFields$;
    return jqlOrderableFields$;
  }
});
var useJqlFunctionsObservable = exports.useJqlFunctionsObservable = (0, _reactSweetState.createHook)(store, {
  selector: function selector(_ref7) {
    var jqlFunctions$ = _ref7.jqlFunctions$;
    return jqlFunctions$;
  }
});