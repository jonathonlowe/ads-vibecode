import { useCallback } from 'react';
import escapeRegExp from 'lodash/escapeRegExp';
import { empty } from 'rxjs/observable/empty';
import { concatMap } from 'rxjs/operators/concatMap';
import { filter } from 'rxjs/operators/filter';
import { map } from 'rxjs/operators/map';
import { toArray } from 'rxjs/operators/toArray';
import findField$ from '../../utils/find-field-observable';
var useOnFunctions = function useOnFunctions(jqlSearchableFields$, jqlFunctions$) {
  return useCallback(function (query, field, isListOperator) {
    if (typeof field !== 'string' || field === '') {
      return empty();
    }
    var filterRegex = typeof query === 'string' && query !== '' ? new RegExp("^".concat(escapeRegExp(query), "[^$]"), 'i') : undefined;
    var field$ = findField$(jqlSearchableFields$, field);

    // Find all functions that match our query with a type that intersects our field types
    return field$.pipe(concatMap(function (matchingField) {
      return jqlFunctions$.pipe(filter(function (func) {
        return !filterRegex || func.displayName.match(filterRegex) !== null;
      }), filter(function (func) {
        return (
          // Do not include functions that return a list unless we are using a list operator
          !!isListOperator || func.isList !== 'true'
        );
      }), filter(function (func) {
        return (
          // Include functions with a type that intersects our field types
          func.types.filter(function (type) {
            return matchingField.types.includes(type);
          }).length > 0
        );
      }), map(function (func) {
        return {
          name: func.displayName,
          value: func.value,
          isListFunction: func.isList === 'true' || func.supportsListAndSingleValueOperators === 'true'
        };
      }), toArray());
    }),
    // We can filter out empty arrays as there is nothing to consume
    filter(function (operands) {
      return operands.length > 0;
    }));
  }, [jqlSearchableFields$, jqlFunctions$]);
};
export default useOnFunctions;