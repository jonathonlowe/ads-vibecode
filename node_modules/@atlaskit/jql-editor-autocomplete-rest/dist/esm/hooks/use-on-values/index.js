import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useCallback, useReducer } from 'react';
import { di } from 'react-magnetic-di';
import { empty } from 'rxjs/observable/empty';
import { of } from 'rxjs/observable/of';
import { concatMap } from 'rxjs/operators/concatMap';
import { delay } from 'rxjs/operators/delay';
import { filter } from 'rxjs/operators/filter';
import findField$ from '../../utils/find-field-observable';
import { normalize } from '../../utils/strings';
import { USER_FIELD_TYPE } from '../constants';
import { useFetchFieldValues } from '../use-fetch-field-values';
var getValueType = function getValueType(field) {
  if (field.types.includes(USER_FIELD_TYPE)) {
    return 'user';
  }
  return undefined;
};
var fieldValuesReducer = function fieldValuesReducer(state, action) {
  var _action$payload = action.payload,
    cacheKey = _action$payload.cacheKey,
    values = _action$payload.values;
  return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, cacheKey, values));
};
var initialState = {};

// Hard coded delay before making a fetch call for operands.
var OPERANDS_DELAY_MS = 650;

// Used to remove emails from user display names in autocomplete values, which come in format: "Name - email".
// Pattern below is specific enough for this purpose and we should avoid writing a more complex email matcher.
var BASIC_REMOVE_EMAIL_REGEX = /\s-\s\S+@\S+\.\S+$/;
var useOnValues = function useOnValues(jqlSearchableFields$, getSuggestions, createAndFireAnalyticsEvent) {
  var fetchFieldValues = useFetchFieldValues(getSuggestions, createAndFireAnalyticsEvent);
  var _useReducer = useReducer(fieldValuesReducer, initialState),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    fieldValuesCache = _useReducer2[0],
    dispatch = _useReducer2[1];
  return useCallback(function (query, field) {
    if (typeof field !== 'string' || field === '') {
      return empty();
    }
    var field$ = findField$(jqlSearchableFields$, field);

    // API expects unquoted and unescaped values
    var normalizedField = normalize(field);
    var normalizedQuery = query !== undefined ? normalize(query) : '';

    // Cache values by field + query
    var cacheKey = "".concat(normalizedField, ":").concat(normalizedQuery);
    var isCacheHit = Object.prototype.hasOwnProperty.call(fieldValuesCache, cacheKey);
    return field$.pipe(filter(function (matchingField) {
      return matchingField.auto === 'true';
    }), concatMap(function (matchingField) {
      var _matchingField$cfid;
      if (isCacheHit) {
        return of(fieldValuesCache[cacheKey]);
      }

      // If we have a cfid then use it to fetch autocomplete suggestions as results will always be unique.
      // Otherwise it's possible `normalizedField` will match against multiple fields in the API and thus
      // return no data.
      var fieldNameForFetch = (_matchingField$cfid = matchingField.cfid) !== null && _matchingField$cfid !== void 0 ? _matchingField$cfid : normalizedField;

      // We emit a single value using Observable.of(null) and delay that event before fetching field values so we
      // can mimic debounce behaviour.
      return of(null).pipe(delay(OPERANDS_DELAY_MS), concatMap(function () {
        return fetchFieldValues(fieldNameForFetch, normalizedQuery).then(function (values) {
          var valueType = getValueType(matchingField);
          if (valueType === 'user') {
            values.forEach(function (value) {
              value.valueType = valueType;
              // REST autocomplete API returns user display names with this format: "Name - email". To be
              // consistent with hydration API, we want to remove email from this name for rich inline nodes.
              value.nameOnRichInlineNode = value.name.replace(BASIC_REMOVE_EMAIL_REGEX, '');
            });
          }
          // Save response to in-memory cache
          dispatch({
            type: 'update-cache',
            payload: {
              cacheKey: cacheKey,
              values: values
            }
          });
          return values;
        }).catch(function () {
          return [];
        });
      }));
    }),
    // We can filter out empty arrays as there is nothing to consume
    filter(function (operands) {
      return operands.length > 0;
    }));
  }, [jqlSearchableFields$, fieldValuesCache, fetchFieldValues]);
};
export default useOnValues;