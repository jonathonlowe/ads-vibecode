import { createContainer, createHook, createStore } from 'react-sweet-state';
import { from } from 'rxjs/observable/from';
import { concatMap } from 'rxjs/operators/concatMap';
import { EventType } from '@atlaskit/jql-editor-common';
import { Action, ActionSubject } from '../analytics';
var initialData = {
  jqlSearchableFields: [],
  jqlOrderableFields: [],
  jqlFunctions: []
};
var initialState = {
  initialDataFetched: false,
  jqlSearchableFields$: from(initialData.jqlSearchableFields),
  jqlOrderableFields$: from(initialData.jqlOrderableFields),
  jqlFunctions$: from(initialData.jqlFunctions)
};
export var actions = {
  load: function load(getInitialData, createAndFireAnalyticsEvent) {
    return function (_ref) {
      var getState = _ref.getState,
        setState = _ref.setState;
      var _getState = getState(),
        initialDataFetched = _getState.initialDataFetched;
      if (initialDataFetched) {
        return;
      }
      var promise = getInitialData("/rest/api/latest/jql/autocompletedata").then(function (res) {
        var initialValue = {
          jqlSearchableFields: [],
          jqlOrderableFields: [],
          jqlFunctions: res.jqlFunctions
        };
        var data = res.jqlFields.reduce(function (result, field) {
          if (field.searchable === 'true') {
            result.jqlSearchableFields.push(field);
          }
          if (field.orderable === 'true') {
            result.jqlOrderableFields.push(field);
          }
          return result;
        }, initialValue);

        // Minor optimisation so consumers don't have to wait for the promise `then` function to be called
        // whenever we subscribe to the observable. (`then` runs async in the current thread loop)
        setState({
          jqlSearchableFields$: from(data.jqlSearchableFields),
          jqlOrderableFields$: from(data.jqlOrderableFields),
          jqlFunctions$: from(data.jqlFunctions)
        });
        createAndFireAnalyticsEvent({
          action: Action.SUCCESS,
          actionSubject: ActionSubject.AUTOCOMPLETE_INITIAL_DATA,
          eventType: EventType.OPERATIONAL
        });
        return data;
      }).catch(function () {
        setState({
          jqlSearchableFields$: initialState.jqlSearchableFields$,
          jqlOrderableFields$: initialState.jqlOrderableFields$,
          jqlFunctions$: initialState.jqlFunctions$
        });
        createAndFireAnalyticsEvent({
          action: Action.FAILED,
          actionSubject: ActionSubject.AUTOCOMPLETE_INITIAL_DATA,
          eventType: EventType.OPERATIONAL
        });
        return initialData;
      });

      // Set the in-flight promise in state as an observable. This allows consumers to subscribe to our initial data
      // without worrying about race conditions with the API call.
      setState({
        initialDataFetched: true,
        jqlSearchableFields$: from(promise).pipe(concatMap(function (_ref2) {
          var jqlSearchableFields = _ref2.jqlSearchableFields;
          return jqlSearchableFields;
        })),
        jqlOrderableFields$: from(promise).pipe(concatMap(function (_ref3) {
          var jqlOrderableFields = _ref3.jqlOrderableFields;
          return jqlOrderableFields;
        })),
        jqlFunctions$: from(promise).pipe(concatMap(function (_ref4) {
          var jqlFunctions = _ref4.jqlFunctions;
          return jqlFunctions;
        }))
      });
    };
  }
};
export var store = createStore({
  initialState: initialState,
  actions: actions
});

/**
 * Exported to allow consumers to have multiple store instances with initial JQL data. Typically this is unnecessary as
 * initial autocomplete data can be shared across all JQL editor instances but this can be useful for storybook testing
 * if you want to mock different responses for each story.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export var JQLAutocompleteContainer = createContainer(store);
export var useJqlAutocompleteActions = createHook(store, {
  selector: null
});
export var useJqlSearchableFieldsObservable = createHook(store, {
  selector: function selector(_ref5) {
    var jqlSearchableFields$ = _ref5.jqlSearchableFields$;
    return jqlSearchableFields$;
  }
});
export var useJqlOrderableFieldsObservable = createHook(store, {
  selector: function selector(_ref6) {
    var jqlOrderableFields$ = _ref6.jqlOrderableFields$;
    return jqlOrderableFields$;
  }
});
export var useJqlFunctionsObservable = createHook(store, {
  selector: function selector(_ref7) {
    var jqlFunctions$ = _ref7.jqlFunctions$;
    return jqlFunctions$;
  }
});