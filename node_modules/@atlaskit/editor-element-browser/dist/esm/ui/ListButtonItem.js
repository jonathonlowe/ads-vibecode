import _extends from "@babel/runtime/helpers/extends";
import React, { memo, useCallback, useMemo, useEffect } from 'react';
import { ToolTipContent, formatShortcut } from '@atlaskit/editor-common/keymaps';
import ChevronRightIcon from '@atlaskit/icon/utility/chevron-right';
import Lozenge from '@atlaskit/lozenge';
import { ButtonItem } from '@atlaskit/menu';
import { Box, Inline, Text, xcss } from '@atlaskit/primitives';
import Tooltip from '@atlaskit/tooltip';
import { IconRenderer } from './IconRenderer';
var shortcutStyles = xcss({
  color: 'color.text.subtle',
  font: 'font.body.small',
  backgroundColor: 'color.background.accent.gray.subtlest',
  borderRadius: 'border.radius',
  borderStyle: 'none'
});
var selectedColorStyles = xcss({
  color: 'color.text.selected'
});
var disabledShortcutStyles = xcss({
  color: 'color.text.disabled',
  backgroundColor: 'color.background.disabled'
});
var viewAllStyles = xcss({
  background: "var(--ds-surface-overlay, #FFFFFF)",
  position: 'sticky',
  bottom: '-4px',
  width: '100%',
  height: '40px',
  borderTop: "1px solid ".concat("var(--ds-border, #091E4224)")
});
var ListButtonItemBase = /*#__PURE__*/memo(function (_ref) {
  var index = _ref.index,
    title = _ref.title,
    description = _ref.description,
    keyshortcut = _ref.keyshortcut,
    isSelected = _ref.isSelected,
    isDisabled = _ref.isDisabled,
    _ref$showDescription = _ref.showDescription,
    showDescription = _ref$showDescription === void 0 ? false : _ref$showDescription,
    renderContent = _ref.renderContent,
    renderIcon = _ref.renderIcon,
    renderElementAfter = _ref.renderElementAfter,
    onItemSelected = _ref.onItemSelected;
  var beforeElement = useMemo(function () {
    if (!renderIcon) {
      return null;
    }
    return /*#__PURE__*/React.createElement(IconRenderer, null, renderIcon());
  }, [renderIcon]);
  var afterElement = useMemo(function () {
    return renderElementAfter === null || renderElementAfter === void 0 ? void 0 : renderElementAfter();
  }, [renderElementAfter]);
  var content = useMemo(function () {
    return renderContent === null || renderContent === void 0 ? void 0 : renderContent();
  }, [renderContent]);
  return /*#__PURE__*/React.createElement(Tooltip, {
    content: /*#__PURE__*/React.createElement(ToolTipContent, {
      description: title,
      keymap: keyshortcut
    }),
    position: "top",
    ignoreTooltipPointerEvents: true
  }, function (tooltipProps) {
    return /*#__PURE__*/React.createElement(ButtonItem
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, tooltipProps, {
      iconBefore: beforeElement,
      iconAfter: afterElement,
      description: showDescription ? description : undefined,
      shouldDescriptionWrap: true,
      isSelected: isSelected,
      isDisabled: isDisabled,
      onClick: function onClick() {
        return onItemSelected === null || onItemSelected === void 0 ? void 0 : onItemSelected(index);
      }
    }), content);
  });
});
export var ListButtonItem = /*#__PURE__*/memo(function (props) {
  var keyshortcut = props.keyshortcut,
    isSelected = props.isSelected,
    isDisabled = props.isDisabled,
    attributes = props.attributes,
    title = props.title,
    setSelectedItem = props.setSelectedItem,
    index = props.index;
  var shortcutComponent = useCallback(function () {
    var shortcut = keyshortcut && formatShortcut(keyshortcut);
    if (!shortcut) {
      return null;
    }
    return /*#__PURE__*/React.createElement(Box, {
      paddingInline: "space.025",
      paddingBlock: "space.025",
      xcss: [shortcutStyles, isSelected && selectedColorStyles, isDisabled && disabledShortcutStyles]
    }, shortcut);
  }, [isDisabled, isSelected, keyshortcut]);
  var contentComponent = useCallback(function () {
    return /*#__PURE__*/React.createElement(Inline, {
      space: "space.100",
      alignBlock: 'center'
    }, /*#__PURE__*/React.createElement(Text, null, title), (attributes === null || attributes === void 0 ? void 0 : attributes.new) && /*#__PURE__*/React.createElement(Lozenge, {
      appearance: "new"
    }, "New"));
  }, [attributes === null || attributes === void 0 ? void 0 : attributes.new, title]);
  useEffect(function () {
    if (isSelected) {
      setSelectedItem === null || setSelectedItem === void 0 || setSelectedItem({
        index: index
      });
    }
  }, [isSelected, setSelectedItem, index]);
  return /*#__PURE__*/React.createElement(ListButtonItemBase
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    renderContent: contentComponent,
    renderElementAfter: shortcutComponent
  }));
});
export var ViewAllButtonItem = /*#__PURE__*/memo(function (_ref2) {
  var label = _ref2.label,
    onClick = _ref2.onClick,
    _ref2$isViewAllInsert = _ref2.isViewAllInserts,
    isViewAllInserts = _ref2$isViewAllInsert === void 0 ? false : _ref2$isViewAllInsert;
  var contentComponent = useCallback(function () {
    return /*#__PURE__*/React.createElement(Inline, {
      space: "space.100",
      alignBlock: 'center'
    }, /*#__PURE__*/React.createElement(Text, {
      color: 'color.text.selected'
    }, label), /*#__PURE__*/React.createElement(Box, {
      xcss: [selectedColorStyles]
    }, /*#__PURE__*/React.createElement(ChevronRightIcon, {
      label: label
    })));
  }, [label]);
  return isViewAllInserts ? /*#__PURE__*/React.createElement(Box, {
    xcss: viewAllStyles
  }, /*#__PURE__*/React.createElement(ListButtonItemBase, {
    index: -1,
    title: label,
    onItemSelected: onClick,
    renderContent: contentComponent,
    isViewAll: true
  })) : /*#__PURE__*/React.createElement(ListButtonItemBase, {
    index: -1,
    title: label,
    onItemSelected: onClick,
    renderContent: contentComponent
  });
});