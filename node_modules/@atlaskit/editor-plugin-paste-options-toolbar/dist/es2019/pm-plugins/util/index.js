export function isPastedFromFabricEditor(pastedFrom) {
  return pastedFrom === 'fabric-editor';
}

// @see https://product-fabric.atlassian.net/browse/ED-3159
// @see https://github.com/markdown-it/markdown-it/issues/38
export function escapeLinks(text) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return text.replace(/(\[([^\]]+)\]\()?((https?|ftp|jamfselfservice):\/\/[^\s"'>]+)/g, str => {
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    return str.match(/^(https?|ftp|jamfselfservice):\/\/[^\s"'>]+$/) ? `<${str}>` : str;
  });
}
export const hasMediaNode = slice => {
  if (!slice) {
    return false;
  }
  let hasMedia = false;
  slice.content.descendants(node => {
    if (['media', 'mediaInline', 'mediaGroup', 'mediaSingle'].includes(node.type.name)) {
      hasMedia = true;
      return false;
    }
    return true;
  });
  return hasMedia;
};
export const hasRuleNode = (slice, schema) => {
  let hasRuleNode = false;
  slice.content.nodesBetween(0, slice.content.size, (node, start) => {
    if (node.type === schema.nodes.rule) {
      hasRuleNode = true;
    }
  });
  return hasRuleNode;
};
export const hasLinkMark = slice => {
  let hasLinkMark = false;
  slice.content.descendants(node => {
    var _node$marks;
    const marks = (_node$marks = node.marks) === null || _node$marks === void 0 ? void 0 : _node$marks.map(mark => mark.type.name);
    hasLinkMark = marks === null || marks === void 0 ? void 0 : marks.includes('link');
    if (hasLinkMark) {
      //break out of loop
      return false;
    }
  });
  return hasLinkMark;
};