export function isPastedFromFabricEditor(pastedFrom) {
  return pastedFrom === 'fabric-editor';
}

// @see https://product-fabric.atlassian.net/browse/ED-3159
// @see https://github.com/markdown-it/markdown-it/issues/38
export function escapeLinks(text) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return text.replace(/(\[([^\]]+)\]\()?((https?|ftp|jamfselfservice):\/\/[^\s"'>]+)/g, function (str) {
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    return str.match(/^(https?|ftp|jamfselfservice):\/\/[^\s"'>]+$/) ? "<".concat(str, ">") : str;
  });
}
export var hasMediaNode = function hasMediaNode(slice) {
  if (!slice) {
    return false;
  }
  var hasMedia = false;
  slice.content.descendants(function (node) {
    if (['media', 'mediaInline', 'mediaGroup', 'mediaSingle'].includes(node.type.name)) {
      hasMedia = true;
      return false;
    }
    return true;
  });
  return hasMedia;
};
export var hasRuleNode = function hasRuleNode(slice, schema) {
  var hasRuleNode = false;
  slice.content.nodesBetween(0, slice.content.size, function (node, start) {
    if (node.type === schema.nodes.rule) {
      hasRuleNode = true;
    }
  });
  return hasRuleNode;
};
export var hasLinkMark = function hasLinkMark(slice) {
  var hasLinkMark = false;
  slice.content.descendants(function (node) {
    var _node$marks;
    var marks = (_node$marks = node.marks) === null || _node$marks === void 0 ? void 0 : _node$marks.map(function (mark) {
      return mark.type.name;
    });
    hasLinkMark = marks === null || marks === void 0 ? void 0 : marks.includes('link');
    if (hasLinkMark) {
      //break out of loop
      return false;
    }
  });
  return hasLinkMark;
};