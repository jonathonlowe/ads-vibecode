import memoizeOne from 'memoize-one';
import { CustomType, EmailType, TeamType, GroupType, UserType, ExternalUserType } from '../types';
import { PopupSelect } from '@atlaskit/select';
export const isExternalUser = option => option.type === ExternalUserType || Boolean(option.isExternal);
export const isUser = option => option.type === undefined || option.type === UserType;
export const isTeam = option => option.type === TeamType;
export const isGroup = option => option.type === GroupType;
export const isEmail = option => option.type === EmailType;
export const isCustom = option => option.type === CustomType;
export const isDefaultValuePopulated = value => value && !Array.isArray(value) || Array.isArray(value) && value.length > 0;
const isOptionData = option => option.name !== undefined;
export const optionToSelectableOption = option => {
  if (isOptionData(option)) {
    return {
      data: option,
      isDisabled: option.isDisabled,
      label: option.name,
      value: option.id
    };
  } else {
    return {
      data: {
        ...option,
        name: option.id
      },
      isDisabled: option.isDisabled,
      label: option.id,
      value: option.id
    };
  }
};
export const extractOptionValue = value => {
  if (!value) {
    return undefined;
  }
  if (Array.isArray(value)) {
    return value.map(({
      data: option
    }) => option);
  }
  return value.data;
};
export const isIterable = a => typeof a[Symbol.iterator] === 'function';
export const getOptions = memoizeOne(options => options.map(optionToSelectableOption));
export const optionToSelectableOptions = memoizeOne(defaultValue => {
  if (!defaultValue) {
    return null;
  }
  if (Array.isArray(defaultValue)) {
    return defaultValue.map(optionToSelectableOption);
  }
  return optionToSelectableOption(defaultValue);
});
export const getAvatarSize = appearance => appearance === 'big' ? 'medium' : appearance === 'multi' ? 'xsmall' : 'small';
export const isChildInput = child => child && typeof child === 'object' && child.props && child.props.type === 'text';
export const isSingleValue = value => !!value && !Array.isArray(value);
export const hasValue = value => !!value && value.trim().length > 0;
export const callCallback = (callback, ...args) => {
  if (typeof callback === 'function') {
    try {
      //  there is mystery error in IE 11, so we need this try-catch
      return callback(...args);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('@atlassian/user-select: an error happening in `callCallback`: ', error);
    }
  }
};
export const getAvatarUrl = optionData => {
  if (isUser(optionData) || isTeam(optionData) || isCustom(optionData)) {
    return optionData.avatarUrl;
  }
  return undefined;
};
export const isPopupUserPickerByComponent = SelectComponent => SelectComponent === PopupSelect;
export const isPopupUserPickerByProps = selectProps => selectProps.searchThreshold === -1;
export const isLozengeText = lozengeProp => {
  return (lozengeProp === null || lozengeProp === void 0 ? void 0 : lozengeProp.hasOwnProperty('text')) || false;
};