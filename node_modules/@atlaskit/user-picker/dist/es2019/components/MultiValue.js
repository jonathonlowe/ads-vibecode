import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React from 'react';
import { Box, Inline, xcss } from '@atlaskit/primitives';
import { components } from '@atlaskit/select';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { AddOptionAvatar } from './AddOptionAvatar';
import { SizeableAvatar } from './SizeableAvatar';
import { getAvatarUrl, isEmail, isGroup, isTeam } from './utils';
import PeopleIcon from '@atlaskit/icon/core/migration/people-group--people';
import { VerifiedTeamIcon } from '@atlaskit/people-teams-ui-public/verified-team-icon';
import { fg } from '@atlaskit/platform-feature-flags';
export const scrollToValue = (valueContainer, control) => {
  const {
    top,
    height
  } = valueContainer.getBoundingClientRect();
  const {
    height: controlHeight
  } = control.getBoundingClientRect();
  if (top - height < 0) {
    valueContainer.scrollIntoView();
  }
  if (top + height > controlHeight) {
    valueContainer.scrollIntoView(false);
  }
};
const groupTagContainer = xcss({
  paddingLeft: 'space.025',
  marginTop: 'space.025'
});
const nameWrapper = css({
  font: "var(--ds-font-body, normal 400 14px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Ubuntu, \"Helvetica Neue\", sans-serif)",
  paddingLeft: "var(--ds-space-050, 4px)"
});
export class MultiValue extends React.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "getElemBefore", () => {
      const {
        data: {
          data
        }
      } = this.props;
      if (isEmail(data)) {
        // This element is a decorative icon and does not require a label
        return jsx(AddOptionAvatar, {
          isLozenge: true
        });
      }
      if (isGroup(data)) {
        return jsx(Box, {
          xcss: groupTagContainer
        }, jsx(PeopleIcon, {
          LEGACY_margin: "-2px 0 0 0",
          color: "currentColor",
          label: "" // This element is a decorative icon and does not require a label
          ,
          LEGACY_size: "small"
        }));
      }
      return jsx(SizeableAvatar, {
        appearance: "multi",
        src: getAvatarUrl(data),
        type: isTeam(data) && fg('verified-team-in-user-picker') ? 'team' : 'person'
      });
    });
    _defineProperty(this, "getElemAfter", () => {
      const {
        data: {
          data
        }
      } = this.props;
      if (isTeam(data) && data.verified && fg('verified-team-in-user-picker')) {
        return jsx(VerifiedTeamIcon, null);
      }
      return null;
    });
    this.containerRef = /*#__PURE__*/React.createRef();
  }
  componentDidUpdate() {
    const {
      isFocused
    } = this.props;
    if (isFocused && this.containerRef.current && this.containerRef.current.parentElement && this.containerRef.current.parentElement.parentElement) {
      scrollToValue(this.containerRef.current, this.containerRef.current.parentElement.parentElement);
    }
  }
  shouldComponentUpdate(nextProps) {
    const {
      data: {
        label,
        data
      },
      innerProps,
      isFocused
    } = this.props;
    const {
      data: {
        label: nextLabel,
        data: nextData
      },
      innerProps: nextInnerProps,
      isFocused: nextIsFocused
    } = nextProps;

    // We can ignore onRemove here because it is an anonymous function
    // that will be recreated every time but with the same implementation.
    return data !== nextData || label !== nextLabel || innerProps !== nextInnerProps || isFocused !== nextIsFocused;
  }
  render() {
    const {
      children,
      innerProps,
      ...rest
    } = this.props;
    return jsx(components.MultiValue, _extends({}, rest, {
      innerProps: {
        ref: this.containerRef
      },
      cropWithEllipsis: false
    }), jsx(Inline, {
      alignBlock: "center"
    }, this.getElemBefore(), " ", jsx("div", {
      css: nameWrapper
    }, children), this.getElemAfter()));
  }
}