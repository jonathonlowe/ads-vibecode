import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
var ExusUserSourceContext = /*#__PURE__*/createContext({});
export var ExusUserSourceProvider = function ExusUserSourceProvider(_ref) {
  var fetchUserSource = _ref.fetchUserSource,
    children = _ref.children;
  return /*#__PURE__*/React.createElement(ExusUserSourceContext.Provider, {
    value: {
      fetchUserSource: fetchUserSource
    }
  }, children);
};
export var useUserSource = function useUserSource(accountId, shouldFetchSources, existingSources) {
  var _useContext = useContext(ExusUserSourceContext),
    fetchUserSource = _useContext.fetchUserSource;
  var _useState = useState([]),
    _useState2 = _slicedToArray(_useState, 2),
    externalSources = _useState2[0],
    setExternalSources = _useState2[1];
  var _useState3 = useState(true),
    _useState4 = _slicedToArray(_useState3, 2),
    loading = _useState4[0],
    setLoading = _useState4[1];
  var _useState5 = useState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    error = _useState6[0],
    setError = _useState6[1];
  var abortController = useMemo(function () {
    if (typeof AbortController === 'undefined') {
      return;
    }
    return new AbortController();
  }, []);
  useEffect(function () {
    var isMounted = true;
    var cleanup = function cleanup() {
      abortController === null || abortController === void 0 || abortController.abort();
      isMounted = false;
    };
    if (!fetchUserSource || !shouldFetchSources) {
      setLoading(false);
      return cleanup;
    }
    fetchUserSource(accountId, abortController === null || abortController === void 0 ? void 0 : abortController.signal).then(function (externalSources) {
      if (!isMounted) {
        return;
      }
      setLoading(false);
      var externalSourceTypes = externalSources.map(function (source) {
        return source.sourceType;
      });
      setExternalSources(externalSourceTypes);
    }).catch(function (error) {
      if (!isMounted) {
        return;
      }
      setLoading(false);
      setError(error);
    });
    return cleanup;
  }, [fetchUserSource, accountId, abortController, shouldFetchSources]);
  return useMemo(function () {
    return {
      sources: Array.from(new Set([].concat(_toConsumableArray(existingSources !== null && existingSources !== void 0 ? existingSources : []), _toConsumableArray(externalSources)))),
      loading: loading,
      error: error
    };
  }, [error, existingSources, externalSources, loading]);
};