import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["children", "innerProps"];
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React from 'react';
import { Box, Inline, xcss } from '@atlaskit/primitives';
import { components } from '@atlaskit/select';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { AddOptionAvatar } from './AddOptionAvatar';
import { SizeableAvatar } from './SizeableAvatar';
import { getAvatarUrl, isEmail, isGroup, isTeam } from './utils';
import PeopleIcon from '@atlaskit/icon/core/migration/people-group--people';
import { VerifiedTeamIcon } from '@atlaskit/people-teams-ui-public/verified-team-icon';
import { fg } from '@atlaskit/platform-feature-flags';
export var scrollToValue = function scrollToValue(valueContainer, control) {
  var _valueContainer$getBo = valueContainer.getBoundingClientRect(),
    top = _valueContainer$getBo.top,
    height = _valueContainer$getBo.height;
  var _control$getBoundingC = control.getBoundingClientRect(),
    controlHeight = _control$getBoundingC.height;
  if (top - height < 0) {
    valueContainer.scrollIntoView();
  }
  if (top + height > controlHeight) {
    valueContainer.scrollIntoView(false);
  }
};
var groupTagContainer = xcss({
  paddingLeft: 'space.025',
  marginTop: 'space.025'
});
var nameWrapper = css({
  font: "var(--ds-font-body, normal 400 14px/20px ui-sans-serif, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Ubuntu, \"Helvetica Neue\", sans-serif)",
  paddingLeft: "var(--ds-space-050, 4px)"
});
export var MultiValue = /*#__PURE__*/function (_React$Component) {
  function MultiValue(props) {
    var _this;
    _classCallCheck(this, MultiValue);
    _this = _callSuper(this, MultiValue, [props]);
    _defineProperty(_this, "getElemBefore", function () {
      var data = _this.props.data.data;
      if (isEmail(data)) {
        // This element is a decorative icon and does not require a label
        return jsx(AddOptionAvatar, {
          isLozenge: true
        });
      }
      if (isGroup(data)) {
        return jsx(Box, {
          xcss: groupTagContainer
        }, jsx(PeopleIcon, {
          LEGACY_margin: "-2px 0 0 0",
          color: "currentColor",
          label: "" // This element is a decorative icon and does not require a label
          ,
          LEGACY_size: "small"
        }));
      }
      return jsx(SizeableAvatar, {
        appearance: "multi",
        src: getAvatarUrl(data),
        type: isTeam(data) && fg('verified-team-in-user-picker') ? 'team' : 'person'
      });
    });
    _defineProperty(_this, "getElemAfter", function () {
      var data = _this.props.data.data;
      if (isTeam(data) && data.verified && fg('verified-team-in-user-picker')) {
        return jsx(VerifiedTeamIcon, null);
      }
      return null;
    });
    _this.containerRef = /*#__PURE__*/React.createRef();
    return _this;
  }
  _inherits(MultiValue, _React$Component);
  return _createClass(MultiValue, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var isFocused = this.props.isFocused;
      if (isFocused && this.containerRef.current && this.containerRef.current.parentElement && this.containerRef.current.parentElement.parentElement) {
        scrollToValue(this.containerRef.current, this.containerRef.current.parentElement.parentElement);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var _this$props = this.props,
        _this$props$data = _this$props.data,
        label = _this$props$data.label,
        data = _this$props$data.data,
        innerProps = _this$props.innerProps,
        isFocused = _this$props.isFocused;
      var _nextProps$data = nextProps.data,
        nextLabel = _nextProps$data.label,
        nextData = _nextProps$data.data,
        nextInnerProps = nextProps.innerProps,
        nextIsFocused = nextProps.isFocused;

      // We can ignore onRemove here because it is an anonymous function
      // that will be recreated every time but with the same implementation.
      return data !== nextData || label !== nextLabel || innerProps !== nextInnerProps || isFocused !== nextIsFocused;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        children = _this$props2.children,
        innerProps = _this$props2.innerProps,
        rest = _objectWithoutProperties(_this$props2, _excluded);
      return jsx(components.MultiValue, _extends({}, rest, {
        innerProps: {
          ref: this.containerRef
        },
        cropWithEllipsis: false
      }), jsx(Inline, {
        alignBlock: "center"
      }, this.getElemBefore(), " ", jsx("div", {
        css: nameWrapper
      }, children), this.getElemAfter()));
    }
  }]);
}(React.Component);