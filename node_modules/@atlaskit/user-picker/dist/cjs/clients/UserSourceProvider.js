"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useUserSource = exports.ExusUserSourceProvider = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var ExusUserSourceContext = /*#__PURE__*/(0, _react.createContext)({});
var ExusUserSourceProvider = exports.ExusUserSourceProvider = function ExusUserSourceProvider(_ref) {
  var fetchUserSource = _ref.fetchUserSource,
    children = _ref.children;
  return /*#__PURE__*/_react.default.createElement(ExusUserSourceContext.Provider, {
    value: {
      fetchUserSource: fetchUserSource
    }
  }, children);
};
var useUserSource = exports.useUserSource = function useUserSource(accountId, shouldFetchSources, existingSources) {
  var _useContext = (0, _react.useContext)(ExusUserSourceContext),
    fetchUserSource = _useContext.fetchUserSource;
  var _useState = (0, _react.useState)([]),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    externalSources = _useState2[0],
    setExternalSources = _useState2[1];
  var _useState3 = (0, _react.useState)(true),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    loading = _useState4[0],
    setLoading = _useState4[1];
  var _useState5 = (0, _react.useState)(null),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    error = _useState6[0],
    setError = _useState6[1];
  var abortController = (0, _react.useMemo)(function () {
    if (typeof AbortController === 'undefined') {
      return;
    }
    return new AbortController();
  }, []);
  (0, _react.useEffect)(function () {
    var isMounted = true;
    var cleanup = function cleanup() {
      abortController === null || abortController === void 0 || abortController.abort();
      isMounted = false;
    };
    if (!fetchUserSource || !shouldFetchSources) {
      setLoading(false);
      return cleanup;
    }
    fetchUserSource(accountId, abortController === null || abortController === void 0 ? void 0 : abortController.signal).then(function (externalSources) {
      if (!isMounted) {
        return;
      }
      setLoading(false);
      var externalSourceTypes = externalSources.map(function (source) {
        return source.sourceType;
      });
      setExternalSources(externalSourceTypes);
    }).catch(function (error) {
      if (!isMounted) {
        return;
      }
      setLoading(false);
      setError(error);
    });
    return cleanup;
  }, [fetchUserSource, accountId, abortController, shouldFetchSources]);
  return (0, _react.useMemo)(function () {
    return {
      sources: Array.from(new Set([].concat((0, _toConsumableArray2.default)(existingSources !== null && existingSources !== void 0 ? existingSources : []), (0, _toConsumableArray2.default)(externalSources)))),
      loading: loading,
      error: error
    };
  }, [error, existingSources, externalSources, loading]);
};