import type { ReactElement } from 'react';
import type { ActivityProvider } from '@atlaskit/activity-provider';
import type { CardOptions } from '@atlaskit/editor-common/card';
import type { CollabEditOptions } from '@atlaskit/editor-common/collab';
import type { ErrorReportingHandler } from '@atlaskit/editor-common/error-reporter';
import type { ExtensionHandlers, ExtensionProvider } from '@atlaskit/editor-common/extensions';
import type { AllEditorPresetPluginTypes, AllPluginNames, EditorPresetBuilder } from '@atlaskit/editor-common/preset';
import type { ContextIdentifierProvider, Providers, SearchProvider } from '@atlaskit/editor-common/provider-factory';
import type { EditorAppearance, EmptyStateHandler, FeedbackInfo, LinkingOptions, PerformanceTracking, QuickInsertOptions, TextFormattingOptions, Transformer } from '@atlaskit/editor-common/types';
import type { UseStickyToolbarType } from '@atlaskit/editor-common/ui';
import type { MenuItem } from '@atlaskit/editor-common/ui-menu';
import type { AnnotationProviders } from '@atlaskit/editor-plugins/annotation';
import type { BlockTypePluginOptions } from '@atlaskit/editor-plugins/block-type';
import type { CodeBlockOptions } from '@atlaskit/editor-plugins/code-block';
import type { DatePluginConfig } from '@atlaskit/editor-plugins/date';
import type { FindReplaceOptions } from '@atlaskit/editor-plugins/find-replace';
import type { LayoutPluginOptions } from '@atlaskit/editor-plugins/layout';
import type { MediaOptions, MediaState } from '@atlaskit/editor-plugins/media/types';
import type { MentionPluginConfig } from '@atlaskit/editor-plugins/mentions';
import type { PanelPluginConfig } from '@atlaskit/editor-plugins/panel';
import type { PlaceholderTextOptions } from '@atlaskit/editor-plugins/placeholder-text';
import type { PluginConfig as TablesPluginConfig } from '@atlaskit/editor-plugins/table/types';
import type { TextColorPluginConfig } from '@atlaskit/editor-plugins/text-color';
import type { Node, Schema } from '@atlaskit/editor-prosemirror/model';
import type { EditorView } from '@atlaskit/editor-prosemirror/view';
import type { MentionProvider } from '@atlaskit/mention/resource';
import type { TaskDecisionProvider } from '@atlaskit/task-decision';
import type EditorActions from '../actions';
import type { EditorOnChangeHandler } from './editor-onchange';
import type { ExtensionConfig } from './extension-config';
export type ReactComponents = ReactElement | ReactElement[];
type ExtensionProviders = (ExtensionProvider | Promise<ExtensionProvider>)[];
type ExtensionProvidersWithEditorAction = (editorActions?: EditorActions) => ExtensionProviders;
export type ExtensionProvidersProp = ExtensionProviders | ExtensionProvidersWithEditorAction;
export type BeforeAndAfterToolbarComponents = {
    before: ReactComponents;
    after: ReactComponents;
};
export type PrimaryToolbarComponents = BeforeAndAfterToolbarComponents | ReactComponents;
export type BeforeAndAfterContentComponents = {
    before: ReactComponents;
    after: ReactComponents;
};
export type ContentComponents = BeforeAndAfterContentComponents | ReactComponents;
interface EditorBaseProps {
    appearance?: EditorAppearance;
    contentComponents?: ContentComponents;
    primaryToolbarIconBefore?: ReactElement;
    secondaryToolbarComponents?: ReactComponents;
    persistScrollGutter?: boolean;
    quickInsert?: QuickInsertOptions;
    shouldFocus?: boolean;
    disabled?: boolean;
    contextPanel?: ReactComponents;
    errorReporterHandler?: ErrorReportingHandler;
    contentTransformerProvider?: (schema: Schema) => Transformer<string>;
    maxHeight?: number;
    minHeight?: number;
    defaultValue?: Node | string | Object;
    assistiveLabel?: string;
    popupsMountPoint?: HTMLElement;
    popupsBoundariesElement?: HTMLElement;
    popupsScrollableElement?: HTMLElement;
    editorActions?: EditorActions;
    onEditorReady?: (editorActions: EditorActions) => void;
    onDestroy?: () => void;
    onChange?: EditorOnChangeHandler;
    onCancel?: (editorView: EditorView) => void;
    /**
     * @deprecated do not use, value is hardcoded. Can be mocked for tests. Config exists here: platform/packages/editor/editor-plugin-base/src/pm-plugins/utils/inputTrackingConfig.ts
     * @description The nth keystroke after which an input time taken event is sent, 0 to disable it
     * @default 100
     */
    inputSamplingLimit?: number;
    extensionProviders?: ExtensionProvidersProp;
    UNSAFE_useAnalyticsContext?: boolean;
    /**
     * @default undefined
     * @description
     * Enables the sticky toolbar in the comment/standard editor.
     * If a boolean is specified and it's `true`, the sticky toolbar will be enabled, sticking to the top of the scroll parent.
     * Instead a reference can be specified to an existing sticky toolbar on the page that the editor toolbar should stay below (experimental).
     * if {offsetTop: number} is passed in, the toolbar is sticky and the toolbar's 'top' will be set to the offsetTop
     * so the toolbar will sticks to `{offsetTop}` below the scroll parent.
     */
    useStickyToolbar?: UseStickyToolbarType;
    /**
     * @default undefined
     * @description
     * Short lived feature flags for experiments and gradual rollouts
     * Flags are expected to follow these rules or they are filtered out
     *
     * 1. cased in kebab-case (match [a-z-])
     * 2. have boolean values
     *
     * @example
     * ```tsx
     * (<Editor featureFlags={{ 'my-feature': true }} />);
     * getFeatureFlags()?.myFeature === true;
     * ```
     *
     * @example
     * ```tsx
     * (<Editor featureFlags={{ 'my-feature': 'thing' }} />);
     * getFeatureFlags()?.myFeature === undefined;
     * ```
     *
     * @example
     * ```tsx
     * (<Editor featureFlags={{ 'product.my-feature': false }} />);
     * getFeatureFlags()?.myFeature === undefined;
     * getFeatureFlags()?.productMyFeature === undefined;
     * ```
     */
    featureFlags?: {
        [featureFlag: string]: string | boolean;
    };
    /**
     * This is required for accessing whether a page is a live page or not when rendering the appearance component.
     *
     * All other consumers should use the editorViewModePlugin to access live page and content mode status.
     *
     * @default false
     */
    __livePage?: boolean;
    skipValidation?: boolean;
}
export interface EditorSharedPropsWithPlugins {
    onSave?: (editorView: EditorView) => void;
    /**
     * @deprecated do not use, value is hardcoded. Can be mocked for tests. Config exists here: platform/packages/editor/editor-plugin-base/src/pm-plugins/utils/inputTrackingConfig.ts
     * @description Control performance metric measurements and tracking
     */
    performanceTracking?: PerformanceTracking;
    sanitizePrivateContent?: boolean;
    collabEdit?: CollabEditOptions;
    primaryToolbarComponents?: PrimaryToolbarComponents;
    allowUndoRedoButtons?: boolean;
}
export interface EditorProps extends EditorBaseProps, EditorPluginFeatureProps, EditorSharedPropsWithPlugins, EditorProviderProps {
    assistiveDescribedBy?: string;
}
export interface EditorNextProps extends EditorBaseProps, EditorSharedPropsWithPlugins, EditorProviderProps {
    preset: EditorPresetBuilder<AllPluginNames[], AllEditorPresetPluginTypes[]>;
    /**
     * @deprecated
     * This prop does nothing and will be removed soon.
     * Configuration of this parameter should be done via `editor-plugin-card` or the `universal` preset.
     *
     * Example:
     * // In preset creation you can pass the props passed to the editor like this:
     * preset.add([cardPlugin, { ...linking.smartLinks, linkPicker: linking.linkPicker }])
     */
    linking?: LinkingOptions;
    /**
     * @deprecated
     * This prop is no longer required and will be removed soon.
     * Configuration of this parameter should be done via `editor-plugin-media` or the `universal` preset.
     *
     * Example:
     * ```ts
     * // In preset creation you can pass the props passed to the editor like this:
     * preset.add([mediaPlugin, mediaOptions])
     * ```
     *
     * Note: Props you pass to the media plugin via the preset do not re-render like in React.
     * Therefore if you need to update the media provider later you will need to explicitly update it like so:
     *
     * ```ts
     * const { preset, editorApi } = usePreset(createPreset)
     * ...
     * // If we need to update the media provider later on
     * editorApi?.media.actions.setProvider(mediaProvider);
     * ```
     */
    media?: MediaOptions;
    assistiveDescribedBy?: string;
    emojiProvider?: Providers['emojiProvider'];
    taskDecisionProvider?: Promise<TaskDecisionProvider>;
    autoformattingProvider?: Providers['autoformattingProvider'];
}
export interface EditorProviderProps {
    activityProvider?: Promise<ActivityProvider>;
    searchProvider?: Promise<SearchProvider>;
    annotationProviders?: AnnotationProviders;
    collabEditProvider?: Providers['collabEditProvider'];
    presenceProvider?: Promise<any>;
    emojiProvider?: Providers['emojiProvider'];
    taskDecisionProvider?: Promise<TaskDecisionProvider>;
    legacyImageUploadProvider?: Providers['imageUploadProvider'];
    mentionProvider?: Promise<MentionProvider>;
    autoformattingProvider?: Providers['autoformattingProvider'];
    macroProvider?: Providers['macroProvider'];
    contextIdentifierProvider?: Promise<ContextIdentifierProvider>;
}
export interface EditorPluginFeatureProps {
    allowExpand?: boolean | {
        allowInsertion?: boolean;
        allowInteractiveExpand?: boolean;
    };
    allowNestedTasks?: boolean;
    allowBlockType?: BlockTypePluginOptions['allowBlockType'];
    allowTasksAndDecisions?: boolean;
    allowBreakout?: boolean;
    allowRule?: boolean;
    allowHelpDialog?: boolean;
    allowPanel?: boolean | PanelPluginConfig;
    allowExtension?: boolean | ExtensionConfig;
    allowConfluenceInlineComment?: boolean;
    allowTemplatePlaceholders?: boolean | PlaceholderTextOptions;
    allowDate?: boolean | DatePluginConfig;
    allowLayouts?: boolean | LayoutPluginOptions;
    allowStatus?: boolean | {
        menuDisabled: boolean;
    };
    allowTextAlignment?: boolean;
    allowIndentation?: boolean;
    showIndentationButtons?: boolean;
    allowFindReplace?: boolean | FindReplaceOptions;
    /**
     * Enable support for the "border" mark.
     * Refer to ADF Change proposal #65 for more details.
     */
    allowBorderMark?: boolean;
    /**
     * Enable support for the "fragment" mark.
     * Refer to ADF Change proposal #60 for more details.
     */
    allowFragmentMark?: boolean;
    /**
     * Set this to false to opt out of the default behaviour of auto scrolling into view
     * whenever the document is changed
     */
    autoScrollIntoView?: boolean;
    elementBrowser?: {
        showModal?: boolean;
        replacePlusMenu?: boolean;
        helpUrl?: string;
        emptyStateHandler?: EmptyStateHandler;
    };
    maxContentSize?: number;
    saveOnEnter?: boolean;
    feedbackInfo?: FeedbackInfo;
    mention?: MentionPluginConfig;
    /**
     * flag to indicate display name instead of nick name should be inserted for mentions
     * default: false, which inserts the nick name
     * @deprecated Use mention.mentionInsertDisplayName instead
     */
    mentionInsertDisplayName?: boolean;
    uploadErrorHandler?: (state: MediaState) => void;
    waitForMediaUpload?: boolean;
    extensionHandlers?: ExtensionHandlers;
    allowTextColor?: boolean | TextColorPluginConfig;
    allowTables?: boolean | TablesPluginConfig;
    insertMenuItems?: MenuItem[];
    /** @deprecated Use linking.smartLinks prop instead. */
    UNSAFE_cards?: CardOptions;
    /** @deprecated Use linking.smartLinks prop instead. */
    smartLinks?: CardOptions;
    allowAnalyticsGASV3?: boolean;
    codeBlock?: CodeBlockOptions;
    textFormatting?: TextFormattingOptions;
    placeholder?: string;
    placeholderBracketHint?: string;
    /**
     *  Configure and extend editor linking behaviour
     */
    linking?: LinkingOptions;
    media?: MediaOptions;
}
export {};
