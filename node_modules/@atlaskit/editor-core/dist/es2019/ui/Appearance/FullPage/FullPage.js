/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { useEffect, useMemo, useRef, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { browser } from '@atlaskit/editor-common/browser';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { ContextPanelWidthProvider } from '@atlaskit/editor-common/ui';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { FullPageContentArea } from './FullPageContentArea';
import { FullPageToolbar } from './FullPageToolbar';
import { getEditorViewMode } from './getEditorViewModeSync';
import { fullPageEditorWrapper } from './StyledComponents';
const useShowKeyline = contentAreaRef => {
  const [showKeyline, setShowKeyline] = useState(false);
  useEffect(() => {
    var _contentAreaRef$curre;
    if (!((_contentAreaRef$curre = contentAreaRef.current) !== null && _contentAreaRef$curre !== void 0 && _contentAreaRef$curre.contentArea)) {
      return;
    }
    const intersection = new IntersectionObserver(([entry]) => {
      setShowKeyline(!entry.isIntersecting && entry.boundingClientRect.top < entry.intersectionRect.top);
    }, {
      root: undefined,
      // Safari seems to miss events (on fast scroll) sometimes due
      // to differences in IntersectionObserver behaviour between browsers.
      // By lowering the threshold a little it gives Safari more
      // time to catch these events.
      threshold: browser.safari ? 0.98 : 1
    });
    intersection.observe(contentAreaRef.current.contentArea);
    return () => {
      intersection.disconnect();
    };
  }, [contentAreaRef]);
  return showKeyline;
};
const hasCustomComponents = components => {
  if (!components) {
    return false;
  }
  if ('before' in components) {
    return Array.isArray(components.before) && components.before.length > 0 || !!components.before || Array.isArray(components.after) && components.after.length > 0 || !!components.after;
  }
  return true;
};
export const FullPageEditor = props => {
  var _scrollContentContain, _scrollContentContain2, _scrollContentContain3, _scrollContentContain4, _scrollContentContain5, _wrapperElementRef$cu;
  const wrapperElementRef = useMemo(() => props.innerRef, [props.innerRef]);
  const scrollContentContainerRef = useRef(null);
  const showKeyline = useShowKeyline(scrollContentContainerRef);
  const editorAPI = props.editorAPI;
  const {
    editorViewModeState,
    primaryToolbarState,
    interactionState
  } = useSharedPluginState(editorAPI, ['editorViewMode', 'primaryToolbar', 'interaction']);
  const viewMode = getEditorViewMode(editorViewModeState, props.preset);
  let toolbarDocking = useSharedPluginStateSelector(editorAPI, 'selectionToolbar.toolbarDocking');
  if (!toolbarDocking && fg('platform_editor_controls_toolbar_ssr_fix')) {
    var _editorAPI$selectionT, _editorAPI$selectionT2, _editorAPI$selectionT3;
    // This is a workaround for the rendering issue with the selection toolbar
    // where using useSharedPluginStateSelector or useSharedPluginState the state are not
    // available when the editor is first loaded. and cause the toolbar to blink.
    const defaultDocking = props.__livePage ? 'none' : 'top';
    toolbarDocking = (_editorAPI$selectionT = editorAPI === null || editorAPI === void 0 ? void 0 : (_editorAPI$selectionT2 = editorAPI.selectionToolbar) === null || _editorAPI$selectionT2 === void 0 ? void 0 : (_editorAPI$selectionT3 = _editorAPI$selectionT2.sharedState.currentState()) === null || _editorAPI$selectionT3 === void 0 ? void 0 : _editorAPI$selectionT3.toolbarDocking) !== null && _editorAPI$selectionT !== void 0 ? _editorAPI$selectionT : defaultDocking;
  }
  let primaryToolbarComponents = props.primaryToolbarComponents;
  if (Array.isArray(primaryToolbarState === null || primaryToolbarState === void 0 ? void 0 : primaryToolbarState.components) && Array.isArray(primaryToolbarComponents)) {
    primaryToolbarComponents = primaryToolbarState.components.concat(primaryToolbarComponents);
  }
  let isEditorToolbarHidden = fg('platform_editor_sync_editor_view_mode_state') ? viewMode === 'view' : (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  if (props.__livePage && !editorExperiment('live_pages_graceful_edit', 'control')) {
    // the custom toolbar logic should only be applied when the experiment cohort is not control,
    // and the editor is in live page mode.
    if (!editorViewModeState) {
      // when first loading the editor, the toolbar should be hidden for all content modes
      // the editorViewMode plugin state is not able to be relied as it will not be setup when
      // the appearance component is being rendered.
      // In this case we set the toolbar to be hidden by default.
      isEditorToolbarHidden = true;
    } else {
      if (editorExperiment('live_pages_graceful_edit', 'initially-hide-toolbar')) {
        // for the initially-hide-toolbar variant, the toolbar should be hidden based on
        // a separate flag in the editorViewMode plugin state.
        isEditorToolbarHidden = !editorViewModeState._showTopToolbar || false;
      }
    }
  }
  const {
    customPrimaryToolbarComponents
  } = props;
  if (editorExperiment('platform_editor_controls', 'variant1', {
    exposure: true
  })) {
    if (fg('platform_editor_controls_toolbar_ssr_fix')) {
      if (toolbarDocking === 'none') {
        primaryToolbarComponents = [];
        if (!hasCustomComponents(customPrimaryToolbarComponents)) {
          isEditorToolbarHidden = true;
        }
      }
    } else {
      var _primaryToolbarCompon;
      if (toolbarDocking !== 'top') {
        primaryToolbarComponents = [];
      }
      if (!((_primaryToolbarCompon = primaryToolbarComponents) !== null && _primaryToolbarCompon !== void 0 && _primaryToolbarCompon.length) && !hasCustomComponents(customPrimaryToolbarComponents)) {
        isEditorToolbarHidden = true;
      }
    }
  }
  const popupsBoundariesElement = props.popupsBoundariesElement || (scrollContentContainerRef === null || scrollContentContainerRef === void 0 ? void 0 : (_scrollContentContain = scrollContentContainerRef.current) === null || _scrollContentContain === void 0 ? void 0 : _scrollContentContain.containerArea) || undefined;
  return jsx(ContextPanelWidthProvider, null, jsx("div", {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/design-system/consistent-css-prop-usage -- Ignored via go/DSP-18766
    css: fullPageEditorWrapper
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: "akEditor",
    ref: wrapperElementRef
  }, !editorExperiment('live_pages_graceful_edit', 'control') && jsx("div", {
    css: hiddenStyle,
    "data-hidden": isEditorToolbarHidden
  }, jsx(FullPageToolbar, {
    appearance: props.appearance,
    editorAPI: editorAPI,
    beforeIcon: props.primaryToolbarIconBefore,
    collabEdit: props.collabEdit,
    containerElement: (_scrollContentContain2 = (_scrollContentContain3 = scrollContentContainerRef.current) === null || _scrollContentContain3 === void 0 ? void 0 : _scrollContentContain3.scrollContainer) !== null && _scrollContentContain2 !== void 0 ? _scrollContentContain2 : null,
    customPrimaryToolbarComponents: props.customPrimaryToolbarComponents,
    disabled: !!props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    eventDispatcher: props.eventDispatcher,
    hasMinWidth: props.enableToolbarMinWidth,
    popupsBoundariesElement: props.popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    primaryToolbarComponents: primaryToolbarComponents,
    providerFactory: props.providerFactory,
    showKeyline: showKeyline,
    featureFlags: props.featureFlags
  })), editorExperiment('live_pages_graceful_edit', 'control') && !isEditorToolbarHidden && jsx(FullPageToolbar, {
    appearance: props.appearance,
    editorAPI: editorAPI,
    beforeIcon: props.primaryToolbarIconBefore,
    collabEdit: props.collabEdit,
    containerElement: (_scrollContentContain4 = (_scrollContentContain5 = scrollContentContainerRef.current) === null || _scrollContentContain5 === void 0 ? void 0 : _scrollContentContain5.scrollContainer) !== null && _scrollContentContain4 !== void 0 ? _scrollContentContain4 : null,
    customPrimaryToolbarComponents: props.customPrimaryToolbarComponents,
    disabled: !!props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    eventDispatcher: props.eventDispatcher,
    hasMinWidth: props.enableToolbarMinWidth,
    popupsBoundariesElement: props.popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    primaryToolbarComponents: primaryToolbarComponents,
    providerFactory: props.providerFactory,
    showKeyline: showKeyline,
    featureFlags: props.featureFlags
  }), jsx(FullPageContentArea, {
    editorAPI: editorAPI,
    ref: scrollContentContainerRef,
    appearance: props.appearance,
    contentComponents: props.contentComponents,
    contextPanel: props.contextPanel,
    customContentComponents: props.customContentComponents,
    disabled: props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView,
    eventDispatcher: props.eventDispatcher,
    popupsBoundariesElement: popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    providerFactory: props.providerFactory,
    wrapperElement: (_wrapperElementRef$cu = wrapperElementRef === null || wrapperElementRef === void 0 ? void 0 : wrapperElementRef.current) !== null && _wrapperElementRef$cu !== void 0 ? _wrapperElementRef$cu : null,
    pluginHooks: props.pluginHooks,
    featureFlags: props.featureFlags,
    isEditorToolbarHidden: isEditorToolbarHidden,
    viewMode: editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode,
    hasHadInteraction: interactionState === null || interactionState === void 0 ? void 0 : interactionState.hasHadInteraction
  })));
};
const hiddenStyle = css({
  visibility: 'visible',
  opacity: 1,
  transition: '200ms opacity, 200ms visibility, 200ms transform',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  '&[data-hidden="true"]': {
    height: 0,
    visibility: 'hidden',
    opacity: 0
    // transition: '0ms opacity, 0ms visibility, 0ms transform',
  }
});