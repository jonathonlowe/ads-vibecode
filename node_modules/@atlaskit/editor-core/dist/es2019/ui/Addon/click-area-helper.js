import { tintDirtyTransaction } from '@atlaskit/editor-common/collab';
import { addParagraphAtEnd } from '@atlaskit/editor-common/commands';
import { setSelectionTopLevelBlocks } from '@atlaskit/editor-common/selection';
import { closestElement } from '@atlaskit/editor-common/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { ignoreAttribute } from './ClickAreaBlock/contentComponentWrapper';

// we ignore all of the clicks made inside <div class="ak-editor-content-area" /> (but not clicks on the node itself)
const insideContentArea = ref => {
  while (ref) {
    if (ref.classList && ref.classList.contains('ak-editor-content-area')) {
      return true;
    }
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    ref = ref.parentNode;
  }
  return false;
};
const insideProseMirrorEditableArea = ref => {
  return Boolean(ref === null || ref === void 0 ? void 0 : ref.closest('.ProseMirror'));
};

/**
 * @see ED-14699 - check if editor is inside a modal to continue to bring cursor to input when
 * any part of the editor container is clicked
 *
 * Handles two cases when a click event is fired:
 *
 * 1. if editor (e.g. comment inside of Jira ticket view) is inside modal then ensure focus and cursor is brought to the input
 * 2. if another modal is open (e.g. delete confirmation modal for confluence table) then ignore clicks as they shouldn't influence editor state
 */
export const checkForModal = target => {
  const modalDialog = target === null || target === void 0 ? void 0 : target.closest('[role=dialog]');
  if (modalDialog) {
    // return false if not an editor inside modal, otherwise return true
    return !!(modalDialog !== null && modalDialog !== void 0 && modalDialog.querySelector('.akEditor'));
  }

  // no modal present so we can return true
  return true;
};
const clickAreaClickHandler = (view, event) => {
  var _view$hasFocus, _target$parentElement, _event$currentTarget;
  const isEditorFocused = !!(view !== null && view !== void 0 && (_view$hasFocus = view.hasFocus) !== null && _view$hasFocus !== void 0 && _view$hasFocus.call(view));
  if (!(event.target instanceof HTMLElement)) {
    return;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const target = event.target;
  const isTargetContentArea = target === null || target === void 0 ? void 0 : target.classList.contains('ak-editor-content-area');
  const isTargetChildOfContentArea = insideContentArea((target === null || target === void 0 ? void 0 : target.parentNode) instanceof HTMLElement ? target === null || target === void 0 ? void 0 : target.parentNode : null);
  const isTargetInsideEditableArea = insideProseMirrorEditableArea(target);

  // Any click inside ProseMirror should be managed by ProseMirror
  if (isTargetInsideEditableArea) {
    return false;
  }
  const isEventComingFromContentArea = Boolean(event.currentTarget.querySelector('.ak-editor-content-area'));

  // @see https://product-fabric.atlassian.net/browse/ED-4287
  // click event gets triggered twice on a checkbox (on <label> first and then on <input>)
  // by the time it gets triggered on input, PM already re-renders nodeView and detaches it from DOM
  // which doesn't pass the check !contentArea.contains(event.target)
  const isInputClicked = (target === null || target === void 0 ? void 0 : target.nodeName) === 'INPUT';
  // @see ED-5126
  const isPopupClicked = !!closestElement(target, '[data-editor-popup]');
  // Fixes issue when using a textarea for editor title in full page editor doesn't let user focus it.
  const isTextAreaClicked = (target === null || target === void 0 ? void 0 : target.nodeName) === 'TEXTAREA';
  const isBreadcrumbClicked = !!closestElement(target, 'nav[aria-label="Breadcrumbs"]');
  const selection = window.getSelection();
  const isEditorPopupTextSelected = (selection === null || selection === void 0 ? void 0 : selection.type) === 'Range' &&
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  closestElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode, '[data-editor-popup]');

  // For clicks directly on the content component -- they should not be ignored
  const isContentComponent = fg('platform_editor_keep_focus_on_content_comp_clicks') ? target === null || target === void 0 ? void 0 : (_target$parentElement = target.parentElement) === null || _target$parentElement === void 0 ? void 0 : _target$parentElement.closest(`[${ignoreAttribute}]`) : !!closestElement(target, `[${ignoreAttribute}]`) || (target === null || target === void 0 ? void 0 : target.getAttribute(ignoreAttribute)) === 'true';

  // This is a super workaround to find when events are coming from Confluence InlineComment modal
  // We don't own those components, so we can't change them
  const isEventComingFromInlineCommentPopup = Boolean(closestElement(event.currentTarget, 'div[offset]')) || Boolean(closestElement(target, 'div[offset]'));
  const isButtonClicked = Boolean(closestElement(event.currentTarget, 'button')) || Boolean(closestElement(target, 'button')) || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : _event$currentTarget.nodeName) === 'BUTTON' || (target === null || target === void 0 ? void 0 : target.nodeName) === 'BUTTON';
  const isTargetInsideContentArea = Boolean(isTargetChildOfContentArea);
  const isBetweenContentAreaAndEditableContent = isTargetInsideContentArea && !isTargetInsideEditableArea;

  // Column Picker dropdown in Datasources table
  const isDatasourcePopupClicked = !!(target !== null && target !== void 0 && target.closest('#column-picker-popup'));
  const edgeCaseScenario1 = (isBetweenContentAreaAndEditableContent || !isEventComingFromContentArea) && !isEditorFocused;
  const edgeCaseScenario2 = !isTargetInsideContentArea && isEditorFocused;
  const edgeCaseScenario3 = isTargetContentArea && !isTargetInsideContentArea && !isEditorFocused;
  const edgeCaseScenario4 = isEventComingFromContentArea && !isTargetContentArea && !isTargetInsideContentArea && !isEditorFocused;
  const edgeCases = edgeCaseScenario1 || edgeCaseScenario2 || edgeCaseScenario3 || edgeCaseScenario4;
  const isClickOutsideEditor = edgeCases && !isDatasourcePopupClicked && !isEventComingFromInlineCommentPopup && !isButtonClicked && !isInputClicked && !isTextAreaClicked && !isPopupClicked && !isBreadcrumbClicked && !isEditorPopupTextSelected && !isContentComponent && checkForModal(target);

  // click was within editor container and focus should be brought to input
  if (isClickOutsideEditor && view) {
    outsideProsemirrorEditorClickHandler(view, event);
  }
};
export const outsideProsemirrorEditorClickHandler = (view, event) => {
  var _view$hasFocus2;
  const {
    dispatch,
    dom,
    state
  } = view;
  const {
    tr
  } = state;
  const isEditorFocused = !!(view !== null && view !== void 0 && (_view$hasFocus2 = view.hasFocus) !== null && _view$hasFocus2 !== void 0 && _view$hasFocus2.call(view));
  const isBottomAreaClicked = event.clientY > dom.getBoundingClientRect().bottom;
  if (isBottomAreaClicked) {
    tr.setMeta('outsideProsemirrorEditorClicked', true);
    addParagraphAtEnd(tr);
  }
  setSelectionTopLevelBlocks(tr, event,
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  dom, view.posAtCoords.bind(view), isEditorFocused);
  tintDirtyTransaction(tr);
  if (!tr.docChanged && !tr.selectionSet) {
    return;
  }
  if (dispatch) {
    dispatch(tr);
  }
  view.focus();
  event.preventDefault();
};
export { clickAreaClickHandler };