// Disable no-re-export rule for entry point files
/* eslint-disable @atlaskit/editor/no-re-export */

import { sortByOrder } from '@atlaskit/editor-common/legacy-rank-plugins';
import { EditorPresetBuilder } from '@atlaskit/editor-common/preset';
import { basePlugin } from '@atlaskit/editor-plugins/base';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { createSchema } from './create-editor/create-schema';
function lightProcessPluginsList(editorPlugins) {
  /**
   * First pass to collect pluginsOptions
   */
  const pluginsOptions = editorPlugins.reduce((acc, plugin) => {
    if (plugin.pluginsOptions) {
      Object.keys(plugin.pluginsOptions).forEach(pluginName => {
        if (!acc[pluginName]) {
          acc[pluginName] = [];
        }
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        acc[pluginName].push(plugin.pluginsOptions[pluginName]);
      });
    }
    return acc;
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  {});

  /**
   * Process plugins
   */
  return editorPlugins.reduce((acc, editorPlugin) => {
    if (editorPlugin.pmPlugins) {
      acc.plugins.push(...editorPlugin.pmPlugins(editorPlugin.name ? pluginsOptions[editorPlugin.name] : undefined));
    }
    if (editorPlugin.marks) {
      acc.marks.push(...editorPlugin.marks());
    }
    if (editorPlugin.nodes) {
      acc.nodes.push(...editorPlugin.nodes());
    }
    if (editorPlugin.contentComponent) {
      acc.contentComponents.push(editorPlugin.contentComponent);
    }
    if (editorPlugin.usePluginHook) {
      acc.pluginHooks.push(editorPlugin.usePluginHook);
    }
    if (editorPlugin.onEditorViewStateUpdated) {
      acc.onEditorViewStateUpdatedCallbacks.push(editorPlugin.onEditorViewStateUpdated);
    }
    return acc;
  }, {
    nodes: [],
    marks: [],
    plugins: [],
    contentComponents: [],
    pluginHooks: [],
    onEditorViewStateUpdatedCallbacks: []
  });
}
export const createPMSchemaAndPlugins = (inputPreset = new EditorPresetBuilder()) => pluginFactoryParams => {
  let editorPlugins = [];

  // we are ignoring the below because while this logic knows if
  // basePlugin is in the inputPreset, the type system does not
  // so it marks it as a duplicate plugin :) - this is fine
  const preset = inputPreset.has(basePlugin) ? inputPreset : inputPreset.add(basePlugin);
  editorPlugins = preset.build({
    pluginInjectionAPI: pluginFactoryParams.pluginInjectionAPI
  });
  const editorConfig = lightProcessPluginsList(editorPlugins);
  const schema = createSchema(editorConfig);
  const plugins = editorConfig.plugins.sort(sortByOrder('plugins')).map(({
    plugin
  }) => plugin({
    ...pluginFactoryParams,
    schema
  })).filter(plugin => !!plugin);
  return {
    plugins,
    schema,
    onEditorViewStateUpdatedCallbacks: editorConfig.onEditorViewStateUpdatedCallbacks,
    editorConfig
  };
};
export function setTextSelection(view, anchor, head) {
  const {
    state
  } = view;
  const tr = state.tr.setSelection(TextSelection.create(state.doc, anchor, head));
  view.dispatch(tr);
}

/**
 * Given a selector, checks if an element matching the selector exists in the
 * document.
 * @param selector
 * @returns true if element matching selector exists in document, false otherwise
 */
export const isElementBySelectorInDocument = selector => {
  return Boolean(document.querySelector(selector));
};