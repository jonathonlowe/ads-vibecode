import { createFeatureFlagsFromProps } from '../utils/feature-flags-from-props';
import { isFullPage as fullPageCheck } from '../utils/is-full-page';
const isCodeBlockAllowed = options => {
  const exclude = options && options.allowBlockType && options.allowBlockType.exclude ? options.allowBlockType.exclude : [];
  return exclude.indexOf('codeBlock') === -1;
};
export function getScrollGutterOptions(props) {
  const {
    appearance
  } = props;
  if (fullPageCheck(appearance)) {
    // Full Page appearance uses a scrollable div wrapper.
    return {
      getScrollElement: () => document.querySelector('.fabric-editor-popup-scroll-parent')
    };
  }
  return undefined;
}
export function getDefaultPresetOptionsFromEditorProps(props, createAnalyticsEvent
// Omit placeholder since it's an existing prop in `DefaultPresetPluginOptions` and will get overridden there
) {
  var _props$linking, _props$textFormatting, _props$linking2;
  const appearance = props.appearance;
  const cardOptions = ((_props$linking = props.linking) === null || _props$linking === void 0 ? void 0 : _props$linking.smartLinks) || props.smartLinks || props.UNSAFE_cards;
  return {
    ...props,
    createAnalyticsEvent,
    typeAhead: {
      isMobile: false
    },
    featureFlags: createFeatureFlagsFromProps(props.featureFlags),
    paste: {
      cardOptions,
      sanitizePrivateContent: props.sanitizePrivateContent
    },
    base: {
      allowInlineCursorTarget: true,
      allowScrollGutter: getScrollGutterOptions(props)
    },
    blockType: {
      lastNodeMustBeParagraph: appearance === 'comment' || appearance === 'chromeless',
      allowBlockType: props.allowBlockType,
      isUndoRedoButtonsEnabled: props.allowUndoRedoButtons
    },
    placeholder: {
      placeholder: props.placeholder,
      placeholderBracketHint: props.placeholderBracketHint
    },
    textFormatting: {
      ...(props.textFormatting || {}),
      responsiveToolbarMenu: ((_props$textFormatting = props.textFormatting) === null || _props$textFormatting === void 0 ? void 0 : _props$textFormatting.responsiveToolbarMenu) != null ? props.textFormatting.responsiveToolbarMenu : props.allowUndoRedoButtons
    },
    submitEditor: props.onSave,
    quickInsert: {
      enableElementBrowser: props.elementBrowser && props.elementBrowser.showModal,
      elementBrowserHelpUrl: props.elementBrowser && props.elementBrowser.helpUrl,
      disableDefaultItems: false,
      headless: false,
      emptyStateHandler: props.elementBrowser && props.elementBrowser.emptyStateHandler,
      prioritySortingFn: props.quickInsert && typeof props.quickInsert !== 'boolean' && props.quickInsert.prioritySortingFn || undefined,
      onInsert: props.quickInsert && typeof props.quickInsert !== 'boolean' && props.quickInsert.onInsert || undefined
    },
    selection: {
      useLongPressSelection: false
    },
    hyperlinkOptions: {
      editorAppearance: props.appearance,
      linkPicker: (_props$linking2 = props.linking) === null || _props$linking2 === void 0 ? void 0 : _props$linking2.linkPicker,
      onClickCallback: cardOptions === null || cardOptions === void 0 ? void 0 : cardOptions.onClickCallback,
      platform: 'web'
    },
    codeBlock: {
      ...props.codeBlock,
      useLongPressSelection: false,
      allowCompositionInputOverride: false
    }
  };
}

/**
 * Maps EditorProps to EditorPlugins
 *
 * Note: The order that presets are added determines
 * their placement in the editor toolbar.
 */
export default function createPluginsList(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
preset, props, pluginInjectionAPI) {
  const excludes = new Set();
  if (!isCodeBlockAllowed({
    allowBlockType: props.allowBlockType
  })) {
    excludes.add('codeBlock');
  }
  return preset.build({
    pluginInjectionAPI,
    excludePlugins: excludes
  });
}