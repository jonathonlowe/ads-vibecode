"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useProviders = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = require("react");
/**
 * This hook is used to replace the old approach of using the `providerFactory`.
 *
 * Because plugins can't update their initial configuration, this hook listens to changes
 * and calls a command to push the update to the plugins shared state.
 *
 * In the future ideally consumers implement this behaviour themselves.
 */
var useProviders = exports.useProviders = function useProviders(_ref) {
  var editorApi = _ref.editorApi,
    contextIdentifierProvider = _ref.contextIdentifierProvider,
    mediaProvider = _ref.mediaProvider,
    mentionProvider = _ref.mentionProvider,
    cardProvider = _ref.cardProvider,
    emojiProvider = _ref.emojiProvider,
    autoformattingProvider = _ref.autoformattingProvider,
    taskDecisionProvider = _ref.taskDecisionProvider;
  (0, _react.useEffect)(function () {
    function setProvider() {
      return _setProvider.apply(this, arguments);
    }
    function _setProvider() {
      _setProvider = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _editorApi$core, _editorApi$contextIde;
        var provider;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (contextIdentifierProvider) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _context.next = 4;
              return contextIdentifierProvider;
            case 4:
              provider = _context.sent;
              editorApi === null || editorApi === void 0 || (_editorApi$core = editorApi.core) === null || _editorApi$core === void 0 || _editorApi$core.actions.execute(editorApi === null || editorApi === void 0 || (_editorApi$contextIde = editorApi.contextIdentifier) === null || _editorApi$contextIde === void 0 ? void 0 : _editorApi$contextIde.commands.setProvider({
                contextIdentifierProvider: provider
              }));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _setProvider.apply(this, arguments);
    }
    setProvider();
  }, [contextIdentifierProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (mediaProvider) {
      var _editorApi$media;
      editorApi === null || editorApi === void 0 || (_editorApi$media = editorApi.media) === null || _editorApi$media === void 0 || _editorApi$media.actions.setProvider(mediaProvider);
    }
  }, [mediaProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (mentionProvider) {
      var _editorApi$mention;
      editorApi === null || editorApi === void 0 || (_editorApi$mention = editorApi.mention) === null || _editorApi$mention === void 0 || _editorApi$mention.actions.setProvider(mentionProvider);
    }
  }, [mentionProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (cardProvider) {
      var _editorApi$card;
      editorApi === null || editorApi === void 0 || (_editorApi$card = editorApi.card) === null || _editorApi$card === void 0 || _editorApi$card.actions.setProvider(cardProvider);
    }
  }, [cardProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (emojiProvider) {
      var _editorApi$emoji;
      editorApi === null || editorApi === void 0 || (_editorApi$emoji = editorApi.emoji) === null || _editorApi$emoji === void 0 || _editorApi$emoji.actions.setProvider(emojiProvider);
    }
  }, [emojiProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (autoformattingProvider) {
      var _editorApi$customAuto;
      editorApi === null || editorApi === void 0 || (_editorApi$customAuto = editorApi.customAutoformat) === null || _editorApi$customAuto === void 0 || _editorApi$customAuto.actions.setProvider(autoformattingProvider);
    }
  }, [autoformattingProvider, editorApi]);
  (0, _react.useEffect)(function () {
    if (taskDecisionProvider) {
      var _editorApi$taskDecisi;
      editorApi === null || editorApi === void 0 || (_editorApi$taskDecisi = editorApi.taskDecision) === null || _editorApi$taskDecisi === void 0 || _editorApi$taskDecisi.actions.setProvider(taskDecisionProvider);
    }
  }, [taskDecisionProvider, editorApi]);
};