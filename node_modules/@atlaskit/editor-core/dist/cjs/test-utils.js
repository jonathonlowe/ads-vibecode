"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElementBySelectorInDocument = exports.createPMSchemaAndPlugins = void 0;
exports.setTextSelection = setTextSelection;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _legacyRankPlugins = require("@atlaskit/editor-common/legacy-rank-plugins");
var _preset = require("@atlaskit/editor-common/preset");
var _base = require("@atlaskit/editor-plugins/base");
var _state = require("@atlaskit/editor-prosemirror/state");
var _createSchema = require("./create-editor/create-schema");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // Disable no-re-export rule for entry point files
/* eslint-disable @atlaskit/editor/no-re-export */
function lightProcessPluginsList(editorPlugins) {
  /**
   * First pass to collect pluginsOptions
   */
  var pluginsOptions = editorPlugins.reduce(function (acc, plugin) {
    if (plugin.pluginsOptions) {
      Object.keys(plugin.pluginsOptions).forEach(function (pluginName) {
        if (!acc[pluginName]) {
          acc[pluginName] = [];
        }
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        acc[pluginName].push(plugin.pluginsOptions[pluginName]);
      });
    }
    return acc;
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  {});

  /**
   * Process plugins
   */
  return editorPlugins.reduce(function (acc, editorPlugin) {
    if (editorPlugin.pmPlugins) {
      var _acc$plugins;
      (_acc$plugins = acc.plugins).push.apply(_acc$plugins, (0, _toConsumableArray2.default)(editorPlugin.pmPlugins(editorPlugin.name ? pluginsOptions[editorPlugin.name] : undefined)));
    }
    if (editorPlugin.marks) {
      var _acc$marks;
      (_acc$marks = acc.marks).push.apply(_acc$marks, (0, _toConsumableArray2.default)(editorPlugin.marks()));
    }
    if (editorPlugin.nodes) {
      var _acc$nodes;
      (_acc$nodes = acc.nodes).push.apply(_acc$nodes, (0, _toConsumableArray2.default)(editorPlugin.nodes()));
    }
    if (editorPlugin.contentComponent) {
      acc.contentComponents.push(editorPlugin.contentComponent);
    }
    if (editorPlugin.usePluginHook) {
      acc.pluginHooks.push(editorPlugin.usePluginHook);
    }
    if (editorPlugin.onEditorViewStateUpdated) {
      acc.onEditorViewStateUpdatedCallbacks.push(editorPlugin.onEditorViewStateUpdated);
    }
    return acc;
  }, {
    nodes: [],
    marks: [],
    plugins: [],
    contentComponents: [],
    pluginHooks: [],
    onEditorViewStateUpdatedCallbacks: []
  });
}
var createPMSchemaAndPlugins = exports.createPMSchemaAndPlugins = function createPMSchemaAndPlugins() {
  var inputPreset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _preset.EditorPresetBuilder();
  return function (pluginFactoryParams) {
    var editorPlugins = [];

    // we are ignoring the below because while this logic knows if
    // basePlugin is in the inputPreset, the type system does not
    // so it marks it as a duplicate plugin :) - this is fine
    var preset = inputPreset.has(_base.basePlugin) ? inputPreset : inputPreset.add(_base.basePlugin);
    editorPlugins = preset.build({
      pluginInjectionAPI: pluginFactoryParams.pluginInjectionAPI
    });
    var editorConfig = lightProcessPluginsList(editorPlugins);
    var schema = (0, _createSchema.createSchema)(editorConfig);
    var plugins = editorConfig.plugins.sort((0, _legacyRankPlugins.sortByOrder)('plugins')).map(function (_ref) {
      var plugin = _ref.plugin;
      return plugin(_objectSpread(_objectSpread({}, pluginFactoryParams), {}, {
        schema: schema
      }));
    }).filter(function (plugin) {
      return !!plugin;
    });
    return {
      plugins: plugins,
      schema: schema,
      onEditorViewStateUpdatedCallbacks: editorConfig.onEditorViewStateUpdatedCallbacks,
      editorConfig: editorConfig
    };
  };
};
function setTextSelection(view, anchor, head) {
  var state = view.state;
  var tr = state.tr.setSelection(_state.TextSelection.create(state.doc, anchor, head));
  view.dispatch(tr);
}

/**
 * Given a selector, checks if an element matching the selector exists in the
 * document.
 * @param selector
 * @returns true if element matching selector exists in document, false otherwise
 */
var isElementBySelectorInDocument = exports.isElementBySelectorInDocument = function isElementBySelectorInDocument(selector) {
  return Boolean(document.querySelector(selector));
};