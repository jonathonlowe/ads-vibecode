"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FullPageEditor = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _react2 = require("@emotion/react");
var _browser = require("@atlaskit/editor-common/browser");
var _hooks = require("@atlaskit/editor-common/hooks");
var _ui = require("@atlaskit/editor-common/ui");
var _useSharedPluginStateSelector = require("@atlaskit/editor-common/use-shared-plugin-state-selector");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _FullPageContentArea = require("./FullPageContentArea");
var _FullPageToolbar = require("./FullPageToolbar");
var _getEditorViewModeSync = require("./getEditorViewModeSync");
var _StyledComponents = require("./StyledComponents");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766

var useShowKeyline = function useShowKeyline(contentAreaRef) {
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    showKeyline = _useState2[0],
    setShowKeyline = _useState2[1];
  (0, _react.useEffect)(function () {
    var _contentAreaRef$curre;
    if (!((_contentAreaRef$curre = contentAreaRef.current) !== null && _contentAreaRef$curre !== void 0 && _contentAreaRef$curre.contentArea)) {
      return;
    }
    var intersection = new IntersectionObserver(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 1),
        entry = _ref2[0];
      setShowKeyline(!entry.isIntersecting && entry.boundingClientRect.top < entry.intersectionRect.top);
    }, {
      root: undefined,
      // Safari seems to miss events (on fast scroll) sometimes due
      // to differences in IntersectionObserver behaviour between browsers.
      // By lowering the threshold a little it gives Safari more
      // time to catch these events.
      threshold: _browser.browser.safari ? 0.98 : 1
    });
    intersection.observe(contentAreaRef.current.contentArea);
    return function () {
      intersection.disconnect();
    };
  }, [contentAreaRef]);
  return showKeyline;
};
var hasCustomComponents = function hasCustomComponents(components) {
  if (!components) {
    return false;
  }
  if ('before' in components) {
    return Array.isArray(components.before) && components.before.length > 0 || !!components.before || Array.isArray(components.after) && components.after.length > 0 || !!components.after;
  }
  return true;
};
var FullPageEditor = exports.FullPageEditor = function FullPageEditor(props) {
  var _scrollContentContain, _scrollContentContain2, _scrollContentContain3, _scrollContentContain4, _scrollContentContain5, _wrapperElementRef$cu;
  var wrapperElementRef = (0, _react.useMemo)(function () {
    return props.innerRef;
  }, [props.innerRef]);
  var scrollContentContainerRef = (0, _react.useRef)(null);
  var showKeyline = useShowKeyline(scrollContentContainerRef);
  var editorAPI = props.editorAPI;
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(editorAPI, ['editorViewMode', 'primaryToolbar', 'interaction']),
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    primaryToolbarState = _useSharedPluginState.primaryToolbarState,
    interactionState = _useSharedPluginState.interactionState;
  var viewMode = (0, _getEditorViewModeSync.getEditorViewMode)(editorViewModeState, props.preset);
  var toolbarDocking = (0, _useSharedPluginStateSelector.useSharedPluginStateSelector)(editorAPI, 'selectionToolbar.toolbarDocking');
  if (!toolbarDocking && (0, _platformFeatureFlags.fg)('platform_editor_controls_toolbar_ssr_fix')) {
    var _editorAPI$selectionT, _editorAPI$selectionT2;
    // This is a workaround for the rendering issue with the selection toolbar
    // where using useSharedPluginStateSelector or useSharedPluginState the state are not
    // available when the editor is first loaded. and cause the toolbar to blink.
    var defaultDocking = props.__livePage ? 'none' : 'top';
    toolbarDocking = (_editorAPI$selectionT = editorAPI === null || editorAPI === void 0 || (_editorAPI$selectionT2 = editorAPI.selectionToolbar) === null || _editorAPI$selectionT2 === void 0 || (_editorAPI$selectionT2 = _editorAPI$selectionT2.sharedState.currentState()) === null || _editorAPI$selectionT2 === void 0 ? void 0 : _editorAPI$selectionT2.toolbarDocking) !== null && _editorAPI$selectionT !== void 0 ? _editorAPI$selectionT : defaultDocking;
  }
  var primaryToolbarComponents = props.primaryToolbarComponents;
  if (Array.isArray(primaryToolbarState === null || primaryToolbarState === void 0 ? void 0 : primaryToolbarState.components) && Array.isArray(primaryToolbarComponents)) {
    primaryToolbarComponents = primaryToolbarState.components.concat(primaryToolbarComponents);
  }
  var isEditorToolbarHidden = (0, _platformFeatureFlags.fg)('platform_editor_sync_editor_view_mode_state') ? viewMode === 'view' : (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  if (props.__livePage && !(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control')) {
    // the custom toolbar logic should only be applied when the experiment cohort is not control,
    // and the editor is in live page mode.
    if (!editorViewModeState) {
      // when first loading the editor, the toolbar should be hidden for all content modes
      // the editorViewMode plugin state is not able to be relied as it will not be setup when
      // the appearance component is being rendered.
      // In this case we set the toolbar to be hidden by default.
      isEditorToolbarHidden = true;
    } else {
      if ((0, _experiments.editorExperiment)('live_pages_graceful_edit', 'initially-hide-toolbar')) {
        // for the initially-hide-toolbar variant, the toolbar should be hidden based on
        // a separate flag in the editorViewMode plugin state.
        isEditorToolbarHidden = !editorViewModeState._showTopToolbar || false;
      }
    }
  }
  var customPrimaryToolbarComponents = props.customPrimaryToolbarComponents;
  if ((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1', {
    exposure: true
  })) {
    if ((0, _platformFeatureFlags.fg)('platform_editor_controls_toolbar_ssr_fix')) {
      if (toolbarDocking === 'none') {
        primaryToolbarComponents = [];
        if (!hasCustomComponents(customPrimaryToolbarComponents)) {
          isEditorToolbarHidden = true;
        }
      }
    } else {
      var _primaryToolbarCompon;
      if (toolbarDocking !== 'top') {
        primaryToolbarComponents = [];
      }
      if (!((_primaryToolbarCompon = primaryToolbarComponents) !== null && _primaryToolbarCompon !== void 0 && _primaryToolbarCompon.length) && !hasCustomComponents(customPrimaryToolbarComponents)) {
        isEditorToolbarHidden = true;
      }
    }
  }
  var popupsBoundariesElement = props.popupsBoundariesElement || (scrollContentContainerRef === null || scrollContentContainerRef === void 0 || (_scrollContentContain = scrollContentContainerRef.current) === null || _scrollContentContain === void 0 ? void 0 : _scrollContentContain.containerArea) || undefined;
  return (0, _react2.jsx)(_ui.ContextPanelWidthProvider, null, (0, _react2.jsx)("div", {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/design-system/consistent-css-prop-usage -- Ignored via go/DSP-18766
    css: _StyledComponents.fullPageEditorWrapper
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: "akEditor",
    ref: wrapperElementRef
  }, !(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') && (0, _react2.jsx)("div", {
    css: hiddenStyle,
    "data-hidden": isEditorToolbarHidden
  }, (0, _react2.jsx)(_FullPageToolbar.FullPageToolbar, {
    appearance: props.appearance,
    editorAPI: editorAPI,
    beforeIcon: props.primaryToolbarIconBefore,
    collabEdit: props.collabEdit,
    containerElement: (_scrollContentContain2 = (_scrollContentContain3 = scrollContentContainerRef.current) === null || _scrollContentContain3 === void 0 ? void 0 : _scrollContentContain3.scrollContainer) !== null && _scrollContentContain2 !== void 0 ? _scrollContentContain2 : null,
    customPrimaryToolbarComponents: props.customPrimaryToolbarComponents,
    disabled: !!props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    eventDispatcher: props.eventDispatcher,
    hasMinWidth: props.enableToolbarMinWidth,
    popupsBoundariesElement: props.popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    primaryToolbarComponents: primaryToolbarComponents,
    providerFactory: props.providerFactory,
    showKeyline: showKeyline,
    featureFlags: props.featureFlags
  })), (0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') && !isEditorToolbarHidden && (0, _react2.jsx)(_FullPageToolbar.FullPageToolbar, {
    appearance: props.appearance,
    editorAPI: editorAPI,
    beforeIcon: props.primaryToolbarIconBefore,
    collabEdit: props.collabEdit,
    containerElement: (_scrollContentContain4 = (_scrollContentContain5 = scrollContentContainerRef.current) === null || _scrollContentContain5 === void 0 ? void 0 : _scrollContentContain5.scrollContainer) !== null && _scrollContentContain4 !== void 0 ? _scrollContentContain4 : null,
    customPrimaryToolbarComponents: props.customPrimaryToolbarComponents,
    disabled: !!props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    eventDispatcher: props.eventDispatcher,
    hasMinWidth: props.enableToolbarMinWidth,
    popupsBoundariesElement: props.popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    primaryToolbarComponents: primaryToolbarComponents,
    providerFactory: props.providerFactory,
    showKeyline: showKeyline,
    featureFlags: props.featureFlags
  }), (0, _react2.jsx)(_FullPageContentArea.FullPageContentArea, {
    editorAPI: editorAPI,
    ref: scrollContentContainerRef,
    appearance: props.appearance,
    contentComponents: props.contentComponents,
    contextPanel: props.contextPanel,
    customContentComponents: props.customContentComponents,
    disabled: props.disabled,
    dispatchAnalyticsEvent: props.dispatchAnalyticsEvent,
    editorActions: props.editorActions,
    editorDOMElement: props.editorDOMElement
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ,
    editorView: props.editorView,
    eventDispatcher: props.eventDispatcher,
    popupsBoundariesElement: popupsBoundariesElement,
    popupsMountPoint: props.popupsMountPoint,
    popupsScrollableElement: props.popupsScrollableElement,
    providerFactory: props.providerFactory,
    wrapperElement: (_wrapperElementRef$cu = wrapperElementRef === null || wrapperElementRef === void 0 ? void 0 : wrapperElementRef.current) !== null && _wrapperElementRef$cu !== void 0 ? _wrapperElementRef$cu : null,
    pluginHooks: props.pluginHooks,
    featureFlags: props.featureFlags,
    isEditorToolbarHidden: isEditorToolbarHidden,
    viewMode: editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode,
    hasHadInteraction: interactionState === null || interactionState === void 0 ? void 0 : interactionState.hasHadInteraction
  })));
};
var hiddenStyle = (0, _react2.css)({
  visibility: 'visible',
  opacity: 1,
  transition: '200ms opacity, 200ms visibility, 200ms transform',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  '&[data-hidden="true"]': {
    height: 0,
    visibility: 'hidden',
    opacity: 0
    // transition: '0ms opacity, 0ms visibility, 0ms transform',
  }
});