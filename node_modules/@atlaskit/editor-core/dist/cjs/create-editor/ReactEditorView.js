"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactEditorView = ReactEditorView;
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactIntlNext = require("react-intl-next");
var _v = _interopRequireDefault(require("uuid/v4"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _eventDispatcher = require("@atlaskit/editor-common/event-dispatcher");
var _hooks = require("@atlaskit/editor-common/hooks");
var _normalizeFeatureFlags = require("@atlaskit/editor-common/normalize-feature-flags");
var _measureRender = require("@atlaskit/editor-common/performance/measure-render");
var _navigation = require("@atlaskit/editor-common/performance/navigation");
var _preset = require("@atlaskit/editor-common/preset");
var _processRawValue = require("@atlaskit/editor-common/process-raw-value");
var _uiReact = require("@atlaskit/editor-common/ui-react");
var _analytics2 = require("@atlaskit/editor-common/utils/analytics");
var _document = require("@atlaskit/editor-common/utils/document");
var _state2 = require("@atlaskit/editor-prosemirror/state");
var _view = require("@atlaskit/editor-prosemirror/view");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _useProviders = require("../composable-editor/hooks/useProviders");
var _featureFlagsFromProps = require("../utils/feature-flags-from-props");
var _getNodesCount = require("../utils/getNodesCount");
var _isFullPage = require("../utils/is-full-page");
var _RenderTracking = require("../utils/performance/components/RenderTracking");
var _measureEnum = _interopRequireDefault(require("../utils/performance/measure-enum"));
var _consts = require("./consts");
var _createEditor = require("./create-editor");
var _createPluginsList = _interopRequireDefault(require("./create-plugins-list"));
var _createSchema = require("./create-schema");
var _messages = require("./messages");
var _getUAPrefix = require("./ReactEditorView/getUAPrefix");
var _handleEditorFocus = require("./ReactEditorView/handleEditorFocus");
var _useDispatchTransaction = require("./ReactEditorView/useDispatchTransaction");
var _useFireFullWidthEvent = require("./ReactEditorView/useFireFullWidthEvent");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var EDIT_AREA_ID = 'ak-editor-textarea';
var focusElementOutsideEditor = function focusElementOutsideEditor() {
  // TODO: ED-26841 - This is an awful way of selecting this, would love a
  // better way be that a ref or even an id or data attibute.
  var aiButton = document.querySelector('[data-testid="platform-ai-button"]');
  if (aiButton && aiButton instanceof HTMLElement) {
    aiButton.focus();
  }
};
function ReactEditorView(props) {
  var _pluginInjectionAPI$c, _media, _linking, _document$querySelect, _props$render, _props$render2;
  var preset = props.preset,
    _props$editorProps = props.editorProps,
    nextAppearance = _props$editorProps.appearance,
    disabled = _props$editorProps.disabled,
    editorPropFeatureFlags = _props$editorProps.featureFlags,
    errorReporterHandler = _props$editorProps.errorReporterHandler,
    defaultValue = _props$editorProps.defaultValue,
    shouldFocus = _props$editorProps.shouldFocus,
    __livePage = _props$editorProps.__livePage,
    onEditorCreated = props.onEditorCreated,
    onEditorDestroyed = props.onEditorDestroyed;
  var _useState = (0, _react.useState)(undefined),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    editorAPI = _useState2[0],
    setEditorAPI = _useState2[1];
  var editorRef = (0, _react.useRef)(null);
  var viewRef = (0, _react.useRef)();
  var focusTimeoutId = (0, _react.useRef)();
  // ProseMirror is instantiated prior to the initial React render cycle,
  // so we allow transactions by default, to avoid discarding the initial one.
  var canDispatchTransactions = (0, _react.useRef)(true);
  var editorId = (0, _react.useRef)((0, _v.default)());
  var eventDispatcher = (0, _react.useMemo)(function () {
    return new _eventDispatcher.EventDispatcher();
  }, []);
  var config = (0, _react.useRef)({
    nodes: [],
    marks: [],
    pmPlugins: [],
    contentComponents: [],
    pluginHooks: [],
    primaryToolbarComponents: [],
    secondaryToolbarComponents: [],
    onEditorViewStateUpdatedCallbacks: []
  });
  var contentTransformer = (0, _react.useRef)(undefined);
  var featureFlags = (0, _react.useMemo)(function () {
    return (0, _featureFlagsFromProps.createFeatureFlagsFromProps)(editorPropFeatureFlags);
  }, [editorPropFeatureFlags]);
  var getEditorState = (0, _react.useCallback)(function () {
    var _viewRef$current;
    return (_viewRef$current = viewRef.current) === null || _viewRef$current === void 0 ? void 0 : _viewRef$current.state;
  }, []);
  var getEditorView = (0, _react.useCallback)(function () {
    return viewRef.current;
  }, []);
  var dispatch = (0, _react.useMemo)(function () {
    return (0, _eventDispatcher.createDispatch)(eventDispatcher);
  }, [eventDispatcher]);
  var errorReporter = (0, _react.useMemo)(function () {
    return (0, _createEditor.createErrorReporter)(errorReporterHandler);
  }, [errorReporterHandler]);
  var handleAnalyticsEvent = (0, _react.useCallback)(function (payload) {
    (0, _analytics.fireAnalyticsEvent)(props.createAnalyticsEvent)(payload);
  }, [props.createAnalyticsEvent]);
  var dispatchAnalyticsEvent = (0, _react.useCallback)(function (payload) {
    var dispatch = (0, _eventDispatcher.createDispatch)(eventDispatcher);
    dispatch(_analytics2.analyticsEventKey, {
      payload: payload
    });
  }, [eventDispatcher]);
  var pluginInjectionAPI = (0, _react.useRef)(new _preset.EditorPluginInjectionAPI({
    getEditorState: getEditorState,
    getEditorView: getEditorView,
    fireAnalyticsEvent: handleAnalyticsEvent
  }));
  (0, _react.useLayoutEffect)(function () {
    setEditorAPI(pluginInjectionAPI.current.api());
  }, []);
  var createEditorState = (0, _react.useCallback)(function (options) {
    var _api$editorViewMode;
    var schema;
    if (viewRef.current) {
      if (options.resetting) {
        /**
         * ReactEditorView currently does NOT handle dynamic schema,
         * We are reusing the existing schema, and rely on #reconfigureState
         * to update `this.config`
         */
        schema = viewRef.current.state.schema;
      } else {
        /**
         * There's presently a number of issues with changing the schema of a
         * editor inflight. A significant issue is that we lose the ability
         * to keep track of a user's history as the internal plugin state
         * keeps a list of Steps to undo/redo (which are tied to the schema).
         * Without a good way to do work around this, we prevent this for now.
         */
        // eslint-disable-next-line no-console
        console.warn('The editor does not support changing the schema dynamically.');
        return viewRef.current.state;
      }
    } else {
      config.current = (0, _createEditor.processPluginsList)((0, _createPluginsList.default)(options.props.preset, props.editorProps, pluginInjectionAPI.current));
      schema = (0, _createSchema.createSchema)(config.current);
    }
    var contentTransformerProvider = options.props.editorProps.contentTransformerProvider;
    var plugins = (0, _createEditor.createPMPlugins)({
      schema: schema,
      dispatch: dispatch,
      errorReporter: errorReporter,
      editorConfig: config.current,
      eventDispatcher: eventDispatcher,
      providerFactory: options.props.providerFactory,
      portalProviderAPI: props.portalProviderAPI,
      nodeViewPortalProviderAPI: props.nodeViewPortalProviderAPI,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      featureFlags: featureFlags,
      getIntl: function getIntl() {
        return props.intl;
      },
      onEditorStateUpdated: (0, _platformFeatureFlags.fg)('platform_editor_catch_missing_injection_states') ? pluginInjectionAPI.current.onEditorViewUpdated : undefined
    });
    contentTransformer.current = contentTransformerProvider ? contentTransformerProvider(schema) : undefined;
    var api = pluginInjectionAPI.current.api();

    // If we have a doc prop, we need to process it into a PMNode
    var doc;
    if (options.doc) {
      // if the collabEdit API is set, skip this validation due to potential pm validation errors
      // from docs that end up with invalid marks after processing (See #hot-111702 for more details)
      if ((api === null || api === void 0 ? void 0 : api.collabEdit) !== undefined && (0, _platformFeatureFlags.fg)('editor_load_conf_collab_docs_without_checks') || options.props.editorProps.skipValidation) {
        doc = (0, _processRawValue.processRawValueWithoutValidation)(schema, options.doc, dispatchAnalyticsEvent);
      } else {
        doc = (0, _processRawValue.processRawValue)(schema, options.doc, options.props.providerFactory, options.props.editorProps.sanitizePrivateContent, contentTransformer.current, dispatchAnalyticsEvent);
      }
    }
    var isViewMode = (api === null || api === void 0 || (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : _api$editorViewMode.sharedState.currentState().mode) === 'view';
    var selection;
    if (doc) {
      if (isViewMode) {
        var emptySelection = new _state2.TextSelection(doc.resolve(0));
        return _state2.EditorState.create({
          schema: schema,
          plugins: plugins,
          doc: doc,
          selection: emptySelection
        });
      } else {
        selection = options.selectionAtStart ? _state2.Selection.atStart(doc) : _state2.Selection.atEnd(doc);
      }
    }

    // Workaround for ED-3507: When media node is the last element, scrollIntoView throws an error
    var patchedSelection = selection ? _state2.Selection.findFrom(selection.$head, -1, true) || undefined : undefined;
    return _state2.EditorState.create({
      schema: schema,
      plugins: plugins,
      doc: doc,
      selection: patchedSelection
    });
  }, [errorReporter, featureFlags, props.intl, props.portalProviderAPI, props.nodeViewPortalProviderAPI, props.editorProps, dispatchAnalyticsEvent, eventDispatcher, dispatch]);
  var initialEditorState = (0, _react.useMemo)(function () {
    return createEditorState({
      props: props,
      doc: defaultValue,
      // ED-4759: Don't set selection at end for full-page editor - should be at start.
      selectionAtStart: (0, _isFullPage.isFullPage)(nextAppearance)
    });
  },
  // This is only used for the initial state - afterwards we will have `viewRef` available for use
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var getCurrentEditorState = (0, _react.useCallback)(function () {
    var _viewRef$current$stat, _viewRef$current2;
    return (_viewRef$current$stat = (_viewRef$current2 = viewRef.current) === null || _viewRef$current2 === void 0 ? void 0 : _viewRef$current2.state) !== null && _viewRef$current$stat !== void 0 ? _viewRef$current$stat : initialEditorState;
  }, [initialEditorState]);
  var blur = (0, _react.useCallback)(function () {
    if (!viewRef.current) {
      return;
    }
    if (viewRef.current.dom instanceof HTMLElement && viewRef.current.hasFocus()) {
      viewRef.current.dom.blur();
    }

    // The selectionToDOM method uses the document selection to determine currently selected node
    // We need to mimic blurring this as it seems doing the above is not enough.
    // @ts-expect-error
    var sel = viewRef.current.root.getSelection();
    if (sel) {
      sel.removeAllRanges();
    }
  }, []);
  var resetEditorState = (0, _react.useCallback)(function (_ref) {
    var _props$editorProps$on, _props$editorProps2;
    var doc = _ref.doc,
      shouldScrollToBottom = _ref.shouldScrollToBottom;
    if (!viewRef.current) {
      return;
    }

    // We cannot currently guarantee when all the portals will have re-rendered during a reconfigure
    // so we blur here to stop ProseMirror from trying to apply selection to detached nodes or
    // nodes that haven't been re-rendered to the document yet.
    blur();
    var newEditorState = createEditorState({
      props: props,
      doc: doc,
      resetting: true,
      selectionAtStart: !shouldScrollToBottom
    });
    viewRef.current.updateState(newEditorState);
    (_props$editorProps$on = (_props$editorProps2 = props.editorProps).onChange) === null || _props$editorProps$on === void 0 || _props$editorProps$on.call(_props$editorProps2, viewRef.current, {
      source: 'local'
    });
  }, [blur, createEditorState, props]);

  // Initialise phase
  // Using constructor hook so we setup and dispatch analytics before anything else
  (0, _hooks.useConstructor)(function () {
    var _props$intl;
    // This needs to be before initialising editorState because
    // we dispatch analytics events in plugin initialisation
    eventDispatcher.on(_analytics2.analyticsEventKey, handleAnalyticsEvent);
    eventDispatcher.on('resetEditorState', resetEditorState);
    dispatchAnalyticsEvent({
      action: _analytics.ACTION.STARTED,
      actionSubject: _analytics.ACTION_SUBJECT.EDITOR,
      attributes: {
        platform: _analytics.PLATFORMS.WEB,
        featureFlags: featureFlags ? (0, _normalizeFeatureFlags.getEnabledFeatureFlagKeys)(featureFlags) : [],
        accountLocale: (_props$intl = props.intl) === null || _props$intl === void 0 ? void 0 : _props$intl.locale,
        browserLocale: window.navigator.language
      },
      eventType: _analytics.EVENT_TYPE.UI
    });
  });
  (0, _react.useLayoutEffect)(function () {
    // Transaction dispatching is already enabled by default prior to
    // mounting, but we reset it here, just in case the editor view
    // instance is ever recycled (mounted again after unmounting) with
    // the same key.
    // AND since React 18 effects may run multiple times so we need to ensure
    // this is reset so that transactions are still allowed.
    // Although storing mounted state is an anti-pattern in React,
    // we do so here so that we can intercept and abort asynchronous
    // ProseMirror transactions when a dismount is imminent.
    canDispatchTransactions.current = true;
    return function () {
      // We can ignore any transactions from this point onwards.
      // This serves to avoid potential runtime exceptions which could arise
      // from an async dispatched transaction after it's unmounted.
      canDispatchTransactions.current = false;
    };
  }, []);

  // Cleanup
  (0, _react.useLayoutEffect)(function () {
    return function () {
      var focusTimeoutIdCurrent = focusTimeoutId.current;
      if (focusTimeoutIdCurrent) {
        clearTimeout(focusTimeoutIdCurrent);
      }
      if (viewRef.current) {
        // Destroy the state if the Editor is being unmounted
        var editorState = viewRef.current.state;
        editorState.plugins.forEach(function (plugin) {
          var state = plugin.getState(editorState);
          if (state && state.destroy) {
            state.destroy();
          }
        });
      }
      eventDispatcher.destroy();
      // this.view will be destroyed when React unmounts in handleEditorViewRef
    };
  }, [eventDispatcher]);
  var reconfigureState = (0, _react.useCallback)(function (props) {
    if (!viewRef.current) {
      return;
    }

    // We cannot currently guarantee when all the portals will have re-rendered during a reconfigure
    // so we blur here to stop ProseMirror from trying to apply selection to detached nodes or
    // nodes that haven't been re-rendered to the document yet.
    blur();
    var editorPlugins = (0, _createPluginsList.default)(props.preset, props.editorProps, pluginInjectionAPI.current);
    config.current = (0, _createEditor.processPluginsList)(editorPlugins);
    var state = viewRef.current.state;
    var plugins = (0, _createEditor.createPMPlugins)({
      schema: state.schema,
      dispatch: dispatch,
      errorReporter: errorReporter,
      editorConfig: config.current,
      eventDispatcher: eventDispatcher,
      providerFactory: props.providerFactory,
      portalProviderAPI: props.portalProviderAPI,
      nodeViewPortalProviderAPI: props.nodeViewPortalProviderAPI,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      featureFlags: featureFlags,
      getIntl: function getIntl() {
        return props.intl;
      },
      onEditorStateUpdated: (0, _platformFeatureFlags.fg)('platform_editor_catch_missing_injection_states') ? pluginInjectionAPI.current.onEditorViewUpdated : undefined
    });
    var newState = state.reconfigure({
      plugins: plugins
    });

    // need to update the state first so when the view builds the nodeviews it is
    // using the latest plugins
    viewRef.current.updateState(newState);
    return viewRef.current.update(_objectSpread(_objectSpread({}, viewRef.current.props), {}, {
      state: newState
    }));
  }, [blur, dispatchAnalyticsEvent, eventDispatcher, dispatch, errorReporter, featureFlags]);
  var onEditorViewUpdated = (0, _react.useCallback)(function (_ref2) {
    var originalTransaction = _ref2.originalTransaction,
      transactions = _ref2.transactions,
      oldEditorState = _ref2.oldEditorState,
      newEditorState = _ref2.newEditorState;
    if (!(0, _platformFeatureFlags.fg)('platform_editor_catch_missing_injection_states')) {
      pluginInjectionAPI.current.onEditorViewUpdated({
        newEditorState: newEditorState,
        oldEditorState: oldEditorState
      });
    }
    if (!(0, _platformFeatureFlags.fg)('platform_editor_migrate_state_updates')) {
      var _config$current;
      (_config$current = config.current) === null || _config$current === void 0 || _config$current.onEditorViewStateUpdatedCallbacks.forEach(function (entry) {
        entry.callback({
          originalTransaction: originalTransaction,
          transactions: transactions,
          oldEditorState: oldEditorState,
          newEditorState: newEditorState
        });
      });
    }
  }, []);
  var _dispatchTransaction = (0, _useDispatchTransaction.useDispatchTransaction)({
    onChange: props.editorProps.onChange,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    onEditorViewUpdated: onEditorViewUpdated,
    isRemoteReplaceDocumentTransaction: (_pluginInjectionAPI$c = pluginInjectionAPI.current.api()) === null || _pluginInjectionAPI$c === void 0 || (_pluginInjectionAPI$c = _pluginInjectionAPI$c.collabEdit) === null || _pluginInjectionAPI$c === void 0 || (_pluginInjectionAPI$c = _pluginInjectionAPI$c.actions) === null || _pluginInjectionAPI$c === void 0 ? void 0 : _pluginInjectionAPI$c.isRemoteReplaceDocumentTransaction
  });

  // Ignored via go/ees007
  // eslint-disable-next-line @atlaskit/editor/enforce-todo-comment-format
  // TODO: Remove these when we deprecate these props from editor-props - smartLinks is unfortunately still used in some places, we can sidestep this problem if we move everyone across to ComposableEditor and deprecate Editor
  var UNSAFE_cards = props.editorProps.UNSAFE_cards;
  var smartLinks = props.editorProps.smartLinks;

  // Temporary to replace provider factory while migration to `ComposableEditor` occurs
  (0, _useProviders.useProviders)({
    editorApi: editorAPI,
    contextIdentifierProvider: props.editorProps.contextIdentifierProvider,
    mediaProvider: (_media = props.editorProps.media) === null || _media === void 0 ? void 0 : _media.provider,
    mentionProvider: props.editorProps.mentionProvider,
    cardProvider: ((_linking = props.editorProps.linking) === null || _linking === void 0 || (_linking = _linking.smartLinks) === null || _linking === void 0 ? void 0 : _linking.provider) || smartLinks && smartLinks.provider || UNSAFE_cards && UNSAFE_cards.provider,
    emojiProvider: props.editorProps.emojiProvider,
    autoformattingProvider: props.editorProps.autoformattingProvider,
    taskDecisionProvider: props.editorProps.taskDecisionProvider
  });
  var getDirectEditorProps = (0, _react.useCallback)(function (state) {
    return {
      state: state !== null && state !== void 0 ? state : getCurrentEditorState(),
      dispatchTransaction: function dispatchTransaction(tr) {
        // Block stale transactions:
        // Prevent runtime exceptions from async transactions that would attempt to
        // update the DOM after React has unmounted the Editor.

        if (canDispatchTransactions.current) {
          _dispatchTransaction(viewRef.current, tr);
        }
      },
      // Disables the contentEditable attribute of the editor if the editor is disabled
      editable: function editable(_state) {
        return !disabled;
      },
      attributes: {
        'data-gramm': 'false'
      }
    };
  }, [_dispatchTransaction, disabled, getCurrentEditorState]);
  var createEditorView = (0, _react.useCallback)(function (node) {
    (0, _measureRender.measureRender)(_measureEnum.default.PROSEMIRROR_RENDERED, function (_ref3) {
      var duration = _ref3.duration,
        startTime = _ref3.startTime,
        distortedDuration = _ref3.distortedDuration;
      var proseMirrorRenderedSeverity = (0, _analytics2.getAnalyticsEventSeverity)(duration, _consts.PROSEMIRROR_RENDERED_NORMAL_SEVERITY_THRESHOLD, _consts.PROSEMIRROR_RENDERED_DEGRADED_SEVERITY_THRESHOLD);
      if (viewRef.current) {
        var _pluginInjectionAPI$c2;
        var nodes = (0, _getNodesCount.getNodesCount)(viewRef.current.state.doc);
        var ttfb = (0, _navigation.getResponseEndTime)();
        var contextIdentifier = (_pluginInjectionAPI$c2 = pluginInjectionAPI.current.api().base) === null || _pluginInjectionAPI$c2 === void 0 ? void 0 : _pluginInjectionAPI$c2.sharedState.currentState();
        dispatchAnalyticsEvent({
          action: _analytics.ACTION.PROSEMIRROR_RENDERED,
          actionSubject: _analytics.ACTION_SUBJECT.EDITOR,
          attributes: {
            duration: duration,
            startTime: startTime,
            nodes: nodes,
            ttfb: ttfb,
            severity: proseMirrorRenderedSeverity,
            objectId: contextIdentifier === null || contextIdentifier === void 0 ? void 0 : contextIdentifier.objectId,
            distortedDuration: distortedDuration
          },
          eventType: _analytics.EVENT_TYPE.OPERATIONAL
        });
      }
    });

    // Creates the editor-view from this.editorState. If an editor has been mounted
    // previously, this will contain the previous state of the editor.
    var view = new _view.EditorView({
      mount: node
    }, getDirectEditorProps());
    viewRef.current = view;
    pluginInjectionAPI.current.onEditorViewUpdated({
      newEditorState: viewRef.current.state,
      oldEditorState: undefined
    });
    return view;
  }, [getDirectEditorProps, dispatchAnalyticsEvent]);
  var _useState3 = (0, _react.useState)(undefined),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    editorView = _useState4[0],
    setEditorView = _useState4[1];
  var originalScrollToRestore = _react.default.useRef((0, _isFullPage.isFullPage)(props.editorProps.appearance) && (0, _platformFeatureFlags.fg)('platform_editor_reduce_scroll_jump_on_editor_start') ? (_document$querySelect = document.querySelector('[data-editor-scroll-container]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.scrollTop : undefined);
  var mitigateScrollJump =
  // The feature gate here is being used to avoid potential bugs with the scroll restoration code
  // moving it to the end of the expression negates the point of the feature gate
  // eslint-disable-next-line @atlaskit/platform/no-preconditioning
  (0, _isFullPage.isFullPage)(props.editorProps.appearance) && (0, _platformFeatureFlags.fg)('platform_editor_reduce_scroll_jump_on_editor_start') && originalScrollToRestore.current && originalScrollToRestore.current !== 0;
  (0, _react.useLayoutEffect)(function () {
    var _editorView$props$edi, _editorView$props;
    if (shouldFocus && editorView !== null && editorView !== void 0 && (_editorView$props$edi = (_editorView$props = editorView.props).editable) !== null && _editorView$props$edi !== void 0 && _editorView$props$edi.call(_editorView$props, editorView.state) && (0, _platformFeatureFlags.fg)('platform_editor_react_18_autofocus_fix')) {
      if ((0, _platformFeatureFlags.fg)('platform_editor_reduce_scroll_jump_on_editor_start')) {
        if (!mitigateScrollJump) {
          var liveDocWithContent = __livePage && !(0, _document.isEmptyDocument)(editorView.state.doc);
          if (liveDocWithContent && (0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init')) {
            focusElementOutsideEditor();
          } else {
            focusTimeoutId.current = (0, _handleEditorFocus.handleEditorFocus)(editorView);
          }
        }
      } else {
        var _liveDocWithContent = __livePage && !(0, _document.isEmptyDocument)(editorView.state.doc);
        if (_liveDocWithContent && (0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init')) {
          focusElementOutsideEditor();
        } else {
          focusTimeoutId.current = (0, _handleEditorFocus.handleEditorFocus)(editorView);
        }
      }
    }
  }, [editorView, shouldFocus, __livePage, mitigateScrollJump]);
  var handleEditorViewRef = (0, _react.useCallback)(function (node) {
    if (!viewRef.current && node) {
      var view = createEditorView(node);
      if ((0, _platformFeatureFlags.fg)('platform_editor_reduce_scroll_jump_on_editor_start')) {
        if (mitigateScrollJump) {
          var scrollElement = document.querySelector('[data-editor-scroll-container]');
          scrollElement === null || scrollElement === void 0 || scrollElement.scrollTo({
            top: originalScrollToRestore.current,
            behavior: 'instant'
          });
        }
      }
      onEditorCreated({
        view: view,
        config: config.current,
        eventDispatcher: eventDispatcher,
        transformer: contentTransformer.current
      });
      if ((0, _platformFeatureFlags.fg)('platform_editor_react_18_autofocus_fix')) {
        var _startTransition;
        /**
         * Defer using startTransition when it is available (in React 18) to fix
         * autofocus bug where React 18's concurrent rendering mode interferes with
         * setTimeout used in handleEditorFocus, causing autofocus to break.
         */
        var react18OnlyStartTransition = (_startTransition = _react.default === null || _react.default === void 0 ? void 0 : _react.default.startTransition) !== null && _startTransition !== void 0 ? _startTransition : function (fn) {
          return fn();
        };
        react18OnlyStartTransition(function () {
          // Force React to re-render so consumers get a reference to the editor view
          setEditorView(view);
        });
      } else {
        if (shouldFocus && view.props.editable && view.props.editable(view.state)) {
          if ((0, _platformFeatureFlags.fg)('platform_editor_reduce_scroll_jump_on_editor_start')) {
            if (!mitigateScrollJump) {
              var isLivePageWithContent = __livePage && !(0, _document.isEmptyDocument)(view.state.doc) && (0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init');
              if (!isLivePageWithContent && shouldFocus && view.props.editable && view.props.editable(view.state)) {
                focusTimeoutId.current = (0, _handleEditorFocus.handleEditorFocus)(view);
              }
            }
          } else {
            var _isLivePageWithContent = __livePage && !(0, _document.isEmptyDocument)(view.state.doc) && (0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init');
            if (!_isLivePageWithContent && shouldFocus && view.props.editable && view.props.editable(view.state)) {
              focusTimeoutId.current = (0, _handleEditorFocus.handleEditorFocus)(view);
            }
          }
        }

        // Force React to re-render so consumers get a reference to the editor view
        setEditorView(view);
      }
    } else if (viewRef.current && !node) {
      // When the appearance is changed, React will call handleEditorViewRef with node === null
      // to destroy the old EditorView, before calling this method again with node === div to
      // create the new EditorView
      onEditorDestroyed({
        view: viewRef.current,
        config: config.current,
        eventDispatcher: eventDispatcher,
        transformer: contentTransformer.current
      });
      var wasAnalyticsDisconnected = !eventDispatcher.has(_analytics2.analyticsEventKey, handleAnalyticsEvent);
      // If we disabled event listening for some reason we should re-enable it temporarily while we destroy
      // the view for any analytics that occur there.
      if (wasAnalyticsDisconnected) {
        eventDispatcher.on(_analytics2.analyticsEventKey, handleAnalyticsEvent);
        viewRef.current.destroy(); // Destroys the dom node & all node views
        eventDispatcher.off(_analytics2.analyticsEventKey, handleAnalyticsEvent);
      } else {
        viewRef.current.destroy(); // Destroys the dom node & all node views
      }
      viewRef.current = undefined;
    }
  }, [createEditorView, onEditorCreated, eventDispatcher, shouldFocus, __livePage, onEditorDestroyed, handleAnalyticsEvent, mitigateScrollJump]);
  var createEditor = (0, _react.useCallback)(function (assistiveLabel, assistiveDescribedBy) {
    return /*#__PURE__*/_react.default.createElement("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      className: (0, _getUAPrefix.getUAPrefix)(),
      key: "ProseMirror",
      ref: handleEditorViewRef,
      "aria-label": assistiveLabel || props.intl.formatMessage(_messages.editorMessages.editorAssistiveLabel)
      // setting aria-multiline to true when not mobile appearance.
      //  because somehow mobile tests are failing when it set.
      //  don't know why that is happening.
      // Created https://product-fabric.atlassian.net/jira/servicedesk/projects/DTR/queues/issue/DTR-1675
      //  to investigate further.
      ,
      "aria-multiline": true,
      role: "textbox",
      id: EDIT_AREA_ID,
      "aria-describedby": assistiveDescribedBy,
      "data-editor-id": editorId.current
    });
  }, [handleEditorViewRef, props.intl]);
  var previousPreset = (0, _hooks.usePreviousState)(preset);
  (0, _react.useLayoutEffect)(function () {
    if (previousPreset && previousPreset !== preset) {
      reconfigureState(props);
    }
  }, [reconfigureState, previousPreset, preset, props]);
  var previousDisabledState = (0, _hooks.usePreviousState)(disabled);
  (0, _react.useLayoutEffect)(function () {
    if (viewRef.current && previousDisabledState !== disabled) {
      // Disables the contentEditable attribute of the editor if the editor is disabled
      viewRef.current.setProps({
        editable: function editable(_state) {
          return !disabled;
        }
      });
      var isLivePageWithContent = __livePage && !(0, _document.isEmptyDocument)(viewRef.current.state.doc) && (0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init');
      if (!disabled && shouldFocus && !isLivePageWithContent) {
        focusTimeoutId.current = (0, _handleEditorFocus.handleEditorFocus)(viewRef.current);
      }
    }
  }, [disabled, shouldFocus, previousDisabledState, __livePage]);
  (0, _useFireFullWidthEvent.useFireFullWidthEvent)(nextAppearance, dispatchAnalyticsEvent);
  var editor = (0, _react.useMemo)(function () {
    return createEditor(props.editorProps.assistiveLabel, props.editorProps.assistiveDescribedBy);
  },
  // `createEditor` changes a little too frequently - we don't want to recreate the editor view in this case
  // We should follow-up
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [props.editorProps.assistiveLabel, props.editorProps.assistiveDescribedBy]);

  // Render tracking firing too many events for the legacy content macro. We're aware of the re-render issue, but disabling this for now. See - https://product-fabric.atlassian.net/browse/ED-26650
  var renderTrackingEnabled = !featureFlags.lcmPreventRenderTracking;
  return /*#__PURE__*/_react.default.createElement(_uiReact.ReactEditorViewContext.Provider, {
    value: {
      editorRef: editorRef,
      editorView: viewRef.current,
      popupsMountPoint: props.editorProps.popupsMountPoint
    }
  }, (0, _platformFeatureFlags.fg)('platform_editor_legacy_content_macro') ? renderTrackingEnabled && /*#__PURE__*/_react.default.createElement(_RenderTracking.RenderTracking, {
    componentProps: props,
    action: _analytics.ACTION.RE_RENDERED,
    actionSubject: _analytics.ACTION_SUBJECT.REACT_EDITOR_VIEW,
    handleAnalyticsEvent: handleAnalyticsEvent,
    useShallow: true
  }) : /*#__PURE__*/_react.default.createElement(_RenderTracking.RenderTracking, {
    componentProps: props,
    action: _analytics.ACTION.RE_RENDERED,
    actionSubject: _analytics.ACTION_SUBJECT.REACT_EDITOR_VIEW,
    handleAnalyticsEvent: handleAnalyticsEvent,
    useShallow: true
  }), props.render ? (_props$render = (_props$render2 = props.render) === null || _props$render2 === void 0 ? void 0 : _props$render2.call(props, {
    editor: editor,
    view: viewRef.current,
    config: config.current,
    eventDispatcher: eventDispatcher,
    transformer: contentTransformer.current,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    editorRef: editorRef,
    editorAPI: editorAPI
  })) !== null && _props$render !== void 0 ? _props$render : editor : editor);
}
var _default = exports.default = (0, _reactIntlNext.injectIntl)(ReactEditorView);