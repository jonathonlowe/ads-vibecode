"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDispatchTransaction = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = require("react");
var _analytics = require("@atlaskit/editor-common/analytics");
var _coreUtils = require("@atlaskit/editor-common/core-utils");
var _performanceMeasures = require("@atlaskit/editor-common/performance-measures");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _findChangedNodesFromTransaction = require("../../utils/findChangedNodesFromTransaction");
var _saferTransactions = require("../../utils/performance/safer-transactions");
var _trackTransactions = require("../../utils/performance/track-transactions");
var _validateNodes = require("../../utils/validateNodes");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var useDispatchTransaction = exports.useDispatchTransaction = function useDispatchTransaction(_ref) {
  var onChange = _ref.onChange,
    dispatchAnalyticsEvent = _ref.dispatchAnalyticsEvent,
    onEditorViewUpdated = _ref.onEditorViewUpdated,
    isRemoteReplaceDocumentTransaction = _ref.isRemoteReplaceDocumentTransaction;
  // We need to have a ref to the latest `onChange` since the `dispatchTransaction` gets captured
  var onChangeRef = (0, _react.useRef)(onChange);
  (0, _react.useEffect)(function () {
    onChangeRef.current = onChange;
  }, [onChange]);
  var dispatchTransaction = (0, _react.useCallback)(function (view, unsafeTransaction) {
    if (!view) {
      return;
    }
    var nodes = (0, _findChangedNodesFromTransaction.findChangedNodesFromTransaction)(unsafeTransaction);
    var changedNodesValid = (0, _validateNodes.validateNodes)(nodes);
    var transaction = new Proxy(unsafeTransaction, (0, _saferTransactions.freezeUnsafeTransactionProperties)({
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      pluginKey: 'unknown-reacteditorview'
    }));

    // If the transaction is a remote replaceDocument transaction, we should skip validation.
    // Remote replaceDocument transactions are fired when the document is replaced by initialization of editor-plugin-collab-edit
    // If there is a discrepancy in the ProseMirror schema at initialization, it results in the editor being loaded with no content,
    // giving the user the impression that content has been lost
    var isRemoteReplace = isRemoteReplaceDocumentTransaction ?
    // eslint-disable-next-line @atlaskit/platform/no-preconditioning
    (0, _platformFeatureFlags.fg)('platform_editor_transaction_skip_validation') && isRemoteReplaceDocumentTransaction(transaction) : false;
    if (changedNodesValid || isRemoteReplace) {
      var oldEditorState = view.state;

      // go ahead and update the state now we know the transaction is good
      var _view$state$applyTran = view.state.applyTransaction(transaction),
        newEditorState = _view$state$applyTran.state,
        transactions = _view$state$applyTran.transactions;
      if (newEditorState === oldEditorState) {
        return;
      }
      view.updateState(newEditorState);
      onEditorViewUpdated({
        originalTransaction: transaction,
        transactions: transactions,
        oldEditorState: oldEditorState,
        newEditorState: newEditorState
      });
      if (onChangeRef.current && transaction.docChanged) {
        var source = transaction.getMeta('isRemote') ? 'remote' : 'local';
        (0, _performanceMeasures.startMeasure)(_trackTransactions.EVENT_NAME_ON_CHANGE);
        onChangeRef.current(view, {
          source: source
        });
        (0, _performanceMeasures.stopMeasure)(_trackTransactions.EVENT_NAME_ON_CHANGE);
      }
    }
    if (!changedNodesValid) {
      var invalidNodes = nodes.filter(function (node) {
        return !(0, _validateNodes.validNode)(node);
      }).map(function (node) {
        return (0, _coreUtils.getDocStructure)(node, {
          compact: true
        });
      });
      dispatchAnalyticsEvent({
        action: _analytics.ACTION.DISPATCHED_INVALID_TRANSACTION,
        actionSubject: _analytics.ACTION_SUBJECT.EDITOR,
        eventType: _analytics.EVENT_TYPE.OPERATIONAL,
        attributes: _objectSpread({
          analyticsEventPayloads: (0, _analytics.getAnalyticsEventsFromTransaction)(transaction),
          invalidNodes: invalidNodes
        }, (0, _platformFeatureFlags.fg)('platform_editor_transaction_skip_validation') ? {
          isRemoteReplaceDocumentTransaction: isRemoteReplace
        } : {})
      });
    }
  }, [dispatchAnalyticsEvent, onEditorViewUpdated, isRemoteReplaceDocumentTransaction]);
  return dispatchTransaction;
};