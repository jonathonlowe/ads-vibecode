"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleEditorFocus = handleEditorFocus;
var _react = _interopRequireDefault(require("react"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
function handleEditorFocus(view) {
  if (view !== null && view !== void 0 && view.hasFocus()) {
    return;
  }

  /**
   * If startTransition is available (in React 18),
   * don't use setTimeout as startTransition will be used in ReactEditorViewNext.
   * setTimeout(fn, 0) will not defer the focus reliably in React 18 with
   * concurrent rendering.
   */
  var react16OnlySetTimeout = _react.default !== null && _react.default !== void 0 && _react.default.startTransition && (0, _platformFeatureFlags.fg)('platform_editor_react_18_autofocus_fix') ? function (fn) {
    return fn();
  } : function (fn) {
    return window.setTimeout(fn, 0);
  };
  return react16OnlySetTimeout(function () {
    // Due to race conditions during editor lifecycle transitions (e.g. SPA route changes during opening or closing)
    // where the view (and its internal docView) may have been destroyed, the timeout callback may fire on a stale view.
    // Bail out in that scenario to prevent operating on an unmounted view.
    if ((0, _platformFeatureFlags.fg)('platform_editor_posfromdom_null_fix')) {
      if (view !== null && view !== void 0 && view.isDestroyed) {
        return;
      }
    }
    if (view !== null && view !== void 0 && view.hasFocus()) {
      return;
    }
    if (!window.getSelection) {
      view === null || view === void 0 || view.focus();
      return;
    }
    var domSelection = window.getSelection();
    if (!domSelection || domSelection.rangeCount === 0) {
      view === null || view === void 0 || view.focus();
      return;
    }
    var range = domSelection.getRangeAt(0);
    // if selection is outside editor focus and exit
    if (view && range.startContainer.contains(view.dom)) {
      view.focus();
      return;
    }

    // set cursor/selection and focus
    var anchor = view === null || view === void 0 ? void 0 : view.posAtDOM(range.startContainer, range.startOffset);
    var head = view === null || view === void 0 ? void 0 : view.posAtDOM(range.endContainer, range.endOffset);
    // if anchor or head < 0 focus and exit
    if (anchor && anchor < 0 || head && head < 0) {
      view === null || view === void 0 || view.focus();
      return;
    }
    if (view && anchor) {
      var selection = _state.TextSelection.create(view.state.doc, anchor, head);
      var tr = view.state.tr.setSelection(selection);
      view.dispatch(tr);
      view.focus();
    }
  });
}