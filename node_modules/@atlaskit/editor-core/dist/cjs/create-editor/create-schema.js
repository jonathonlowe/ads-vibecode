"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMetadataAttributes = void 0;
exports.createSchema = createSchema;
exports.wrapToDOMProxy = exports.wrapNodeSpecProxy = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _schema = require("@atlaskit/adf-schema/schema");
var _legacyRankPlugins = require("@atlaskit/editor-common/legacy-rank-plugins");
var _prosemirrorDomMetadata = require("@atlaskit/editor-common/prosemirror-dom-metadata");
var _model = require("@atlaskit/editor-prosemirror/model");
var _createEditor = require("./create-editor");
/**
 * ðŸ§± Internal Helper Function: Editor FE Platform
 *
 * Adds generic metadata attributes to a DOMOutputSpec array based on the provided node or mark.
 * This function ensures that the DOMOutputSpec is annotated with ProseMirror-specific metadata.
 *
 * @param {Object} params - Parameters object.
 * @param {PMNode | PMMark} params.nodeOrMark - The ProseMirror node or mark to extract metadata from.
 * @param {DOMOutputSpec} params.domSpec - The DOMOutputSpec to which attributes will be added.
 * @returns {DOMOutputSpec} The modified DOMOutputSpec with additional metadata.
 */
var addMetadataAttributes = exports.addMetadataAttributes = function addMetadataAttributes(_ref) {
  var nodeOrMark = _ref.nodeOrMark,
    domSpec = _ref.domSpec;
  if (!Array.isArray(domSpec)) {
    return domSpec;
  }
  var maybeDefinedAttributes = domSpec[1];
  var metadata = (0, _prosemirrorDomMetadata.createProseMirrorMetadata)(nodeOrMark);
  var hasDefinedAttributes = (0, _typeof2.default)(maybeDefinedAttributes) === 'object' && !Array.isArray(maybeDefinedAttributes);
  if (hasDefinedAttributes) {
    domSpec[1] = Object.assign(maybeDefinedAttributes, metadata);
  } else {
    domSpec.splice(1, 0, metadata);
  }
  return domSpec;
};

/**
 * ðŸ§± Internal Helper Function: Editor FE Platform
 *
 * Wraps a `toDOM` function with a proxy that automatically adds metadata attributes
 * to the resulting DOMOutputSpec. This is useful for dynamically enhancing the output
 * of a `toDOM` function with additional context.
 *
 * @param {function(PMNode | PMMark): DOMOutputSpec} toDOM - The original `toDOM` function.
 * @returns {function(PMNode | PMMark): DOMOutputSpec} A proxied `toDOM` function that adds metadata attributes.
 */
var wrapToDOMProxy = exports.wrapToDOMProxy = function wrapToDOMProxy(toDOM) {
  return new Proxy(toDOM, {
    apply: function apply(target, thisArg, argumentsList) {
      var domSpec = Reflect.apply(target, thisArg, argumentsList);
      if (!Array.isArray(domSpec)) {
        return domSpec;
      }
      var nodeOrMark = argumentsList[0];
      return addMetadataAttributes({
        nodeOrMark: nodeOrMark,
        domSpec: domSpec
      });
    }
  });
};

/**
 * ðŸ§± Internal Helper Function: Editor FE Platform
 *
 * Wraps a NodeSpec or MarkSpec object with a proxy to enhance its `toDOM` method.
 * This proxy automatically adds metadata attributes to the DOM output of the `toDOM` method,
 * enriching the DOM representation with additional ProseMirror-specific metadata.
 *
 * For nodes thats use NodeViews, you can find the implementation of those attributes on this file:
 * @see `packages/editor/editor-common/src/safe-plugin/index.ts`
 *
 * @template T
 * @param {T} spec - The NodeSpec or MarkSpec object to be wrapped.
 * @returns {T} A proxied NodeSpec or MarkSpec object where the `toDOM` method is enhanced
 * with metadata attributes.
 */
var wrapNodeSpecProxy = exports.wrapNodeSpecProxy = function wrapNodeSpecProxy(spec) {
  return new Proxy(spec, {
    get: function get(target, prop, receiver) {
      var result = Reflect.get(target, prop, receiver);
      if (prop === 'toDOM' && typeof result === 'function') {
        return wrapToDOMProxy(result);
      }
      return result;
    }
  });
};
function createSchema(editorConfig) {
  var marks = (0, _createEditor.fixExcludes)(editorConfig.marks.sort((0, _legacyRankPlugins.sortByOrder)('marks')).reduce(function (acc, mark) {
    acc[mark.name] = wrapNodeSpecProxy(mark.mark);
    return acc;
  }, {}));
  var nodes = (0, _schema.sanitizeNodes)(editorConfig.nodes.sort((0, _legacyRankPlugins.sortByOrder)('nodes')).reduce(function (acc, node) {
    acc[node.name] = wrapNodeSpecProxy(node.node);
    return acc;
  }, {}), marks);
  return new _model.Schema({
    nodes: nodes,
    marks: marks
  });
}