import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React, { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { injectIntl } from 'react-intl-next';
import uuid from 'uuid/v4';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE, fireAnalyticsEvent, PLATFORMS } from '@atlaskit/editor-common/analytics';
import { createDispatch, EventDispatcher } from '@atlaskit/editor-common/event-dispatcher';
import { useConstructor, usePreviousState } from '@atlaskit/editor-common/hooks';
import { getEnabledFeatureFlagKeys } from '@atlaskit/editor-common/normalize-feature-flags';
import { measureRender } from '@atlaskit/editor-common/performance/measure-render';
import { getResponseEndTime } from '@atlaskit/editor-common/performance/navigation';
import { EditorPluginInjectionAPI } from '@atlaskit/editor-common/preset';
import { processRawValue, processRawValueWithoutValidation } from '@atlaskit/editor-common/process-raw-value';
import { ReactEditorViewContext } from '@atlaskit/editor-common/ui-react';
import { analyticsEventKey, getAnalyticsEventSeverity } from '@atlaskit/editor-common/utils/analytics';
import { isEmptyDocument } from '@atlaskit/editor-common/utils/document';
import { EditorState, Selection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { EditorView } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { useProviders } from '../composable-editor/hooks/useProviders';
import { createFeatureFlagsFromProps } from '../utils/feature-flags-from-props';
import { getNodesCount } from '../utils/getNodesCount';
import { isFullPage } from '../utils/is-full-page';
import { RenderTracking } from '../utils/performance/components/RenderTracking';
import measurements from '../utils/performance/measure-enum';
import { PROSEMIRROR_RENDERED_DEGRADED_SEVERITY_THRESHOLD, PROSEMIRROR_RENDERED_NORMAL_SEVERITY_THRESHOLD } from './consts';
import { createErrorReporter, createPMPlugins, processPluginsList } from './create-editor';
import createPluginsList from './create-plugins-list';
import { createSchema } from './create-schema';
import { editorMessages } from './messages';
import { getUAPrefix } from './ReactEditorView/getUAPrefix';
import { handleEditorFocus } from './ReactEditorView/handleEditorFocus';
import { useDispatchTransaction } from './ReactEditorView/useDispatchTransaction';
import { useFireFullWidthEvent } from './ReactEditorView/useFireFullWidthEvent';
var EDIT_AREA_ID = 'ak-editor-textarea';
var focusElementOutsideEditor = function focusElementOutsideEditor() {
  // TODO: ED-26841 - This is an awful way of selecting this, would love a
  // better way be that a ref or even an id or data attibute.
  var aiButton = document.querySelector('[data-testid="platform-ai-button"]');
  if (aiButton && aiButton instanceof HTMLElement) {
    aiButton.focus();
  }
};
export function ReactEditorView(props) {
  var _pluginInjectionAPI$c, _media, _linking, _document$querySelect, _props$render, _props$render2;
  var preset = props.preset,
    _props$editorProps = props.editorProps,
    nextAppearance = _props$editorProps.appearance,
    disabled = _props$editorProps.disabled,
    editorPropFeatureFlags = _props$editorProps.featureFlags,
    errorReporterHandler = _props$editorProps.errorReporterHandler,
    defaultValue = _props$editorProps.defaultValue,
    shouldFocus = _props$editorProps.shouldFocus,
    __livePage = _props$editorProps.__livePage,
    onEditorCreated = props.onEditorCreated,
    onEditorDestroyed = props.onEditorDestroyed;
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    editorAPI = _useState2[0],
    setEditorAPI = _useState2[1];
  var editorRef = useRef(null);
  var viewRef = useRef();
  var focusTimeoutId = useRef();
  // ProseMirror is instantiated prior to the initial React render cycle,
  // so we allow transactions by default, to avoid discarding the initial one.
  var canDispatchTransactions = useRef(true);
  var editorId = useRef(uuid());
  var eventDispatcher = useMemo(function () {
    return new EventDispatcher();
  }, []);
  var config = useRef({
    nodes: [],
    marks: [],
    pmPlugins: [],
    contentComponents: [],
    pluginHooks: [],
    primaryToolbarComponents: [],
    secondaryToolbarComponents: [],
    onEditorViewStateUpdatedCallbacks: []
  });
  var contentTransformer = useRef(undefined);
  var featureFlags = useMemo(function () {
    return createFeatureFlagsFromProps(editorPropFeatureFlags);
  }, [editorPropFeatureFlags]);
  var getEditorState = useCallback(function () {
    var _viewRef$current;
    return (_viewRef$current = viewRef.current) === null || _viewRef$current === void 0 ? void 0 : _viewRef$current.state;
  }, []);
  var getEditorView = useCallback(function () {
    return viewRef.current;
  }, []);
  var dispatch = useMemo(function () {
    return createDispatch(eventDispatcher);
  }, [eventDispatcher]);
  var errorReporter = useMemo(function () {
    return createErrorReporter(errorReporterHandler);
  }, [errorReporterHandler]);
  var handleAnalyticsEvent = useCallback(function (payload) {
    fireAnalyticsEvent(props.createAnalyticsEvent)(payload);
  }, [props.createAnalyticsEvent]);
  var dispatchAnalyticsEvent = useCallback(function (payload) {
    var dispatch = createDispatch(eventDispatcher);
    dispatch(analyticsEventKey, {
      payload: payload
    });
  }, [eventDispatcher]);
  var pluginInjectionAPI = useRef(new EditorPluginInjectionAPI({
    getEditorState: getEditorState,
    getEditorView: getEditorView,
    fireAnalyticsEvent: handleAnalyticsEvent
  }));
  useLayoutEffect(function () {
    setEditorAPI(pluginInjectionAPI.current.api());
  }, []);
  var createEditorState = useCallback(function (options) {
    var _api$editorViewMode;
    var schema;
    if (viewRef.current) {
      if (options.resetting) {
        /**
         * ReactEditorView currently does NOT handle dynamic schema,
         * We are reusing the existing schema, and rely on #reconfigureState
         * to update `this.config`
         */
        schema = viewRef.current.state.schema;
      } else {
        /**
         * There's presently a number of issues with changing the schema of a
         * editor inflight. A significant issue is that we lose the ability
         * to keep track of a user's history as the internal plugin state
         * keeps a list of Steps to undo/redo (which are tied to the schema).
         * Without a good way to do work around this, we prevent this for now.
         */
        // eslint-disable-next-line no-console
        console.warn('The editor does not support changing the schema dynamically.');
        return viewRef.current.state;
      }
    } else {
      config.current = processPluginsList(createPluginsList(options.props.preset, props.editorProps, pluginInjectionAPI.current));
      schema = createSchema(config.current);
    }
    var contentTransformerProvider = options.props.editorProps.contentTransformerProvider;
    var plugins = createPMPlugins({
      schema: schema,
      dispatch: dispatch,
      errorReporter: errorReporter,
      editorConfig: config.current,
      eventDispatcher: eventDispatcher,
      providerFactory: options.props.providerFactory,
      portalProviderAPI: props.portalProviderAPI,
      nodeViewPortalProviderAPI: props.nodeViewPortalProviderAPI,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      featureFlags: featureFlags,
      getIntl: function getIntl() {
        return props.intl;
      },
      onEditorStateUpdated: fg('platform_editor_catch_missing_injection_states') ? pluginInjectionAPI.current.onEditorViewUpdated : undefined
    });
    contentTransformer.current = contentTransformerProvider ? contentTransformerProvider(schema) : undefined;
    var api = pluginInjectionAPI.current.api();

    // If we have a doc prop, we need to process it into a PMNode
    var doc;
    if (options.doc) {
      // if the collabEdit API is set, skip this validation due to potential pm validation errors
      // from docs that end up with invalid marks after processing (See #hot-111702 for more details)
      if ((api === null || api === void 0 ? void 0 : api.collabEdit) !== undefined && fg('editor_load_conf_collab_docs_without_checks') || options.props.editorProps.skipValidation) {
        doc = processRawValueWithoutValidation(schema, options.doc, dispatchAnalyticsEvent);
      } else {
        doc = processRawValue(schema, options.doc, options.props.providerFactory, options.props.editorProps.sanitizePrivateContent, contentTransformer.current, dispatchAnalyticsEvent);
      }
    }
    var isViewMode = (api === null || api === void 0 || (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : _api$editorViewMode.sharedState.currentState().mode) === 'view';
    var selection;
    if (doc) {
      if (isViewMode) {
        var emptySelection = new TextSelection(doc.resolve(0));
        return EditorState.create({
          schema: schema,
          plugins: plugins,
          doc: doc,
          selection: emptySelection
        });
      } else {
        selection = options.selectionAtStart ? Selection.atStart(doc) : Selection.atEnd(doc);
      }
    }

    // Workaround for ED-3507: When media node is the last element, scrollIntoView throws an error
    var patchedSelection = selection ? Selection.findFrom(selection.$head, -1, true) || undefined : undefined;
    return EditorState.create({
      schema: schema,
      plugins: plugins,
      doc: doc,
      selection: patchedSelection
    });
  }, [errorReporter, featureFlags, props.intl, props.portalProviderAPI, props.nodeViewPortalProviderAPI, props.editorProps, dispatchAnalyticsEvent, eventDispatcher, dispatch]);
  var initialEditorState = useMemo(function () {
    return createEditorState({
      props: props,
      doc: defaultValue,
      // ED-4759: Don't set selection at end for full-page editor - should be at start.
      selectionAtStart: isFullPage(nextAppearance)
    });
  },
  // This is only used for the initial state - afterwards we will have `viewRef` available for use
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var getCurrentEditorState = useCallback(function () {
    var _viewRef$current$stat, _viewRef$current2;
    return (_viewRef$current$stat = (_viewRef$current2 = viewRef.current) === null || _viewRef$current2 === void 0 ? void 0 : _viewRef$current2.state) !== null && _viewRef$current$stat !== void 0 ? _viewRef$current$stat : initialEditorState;
  }, [initialEditorState]);
  var blur = useCallback(function () {
    if (!viewRef.current) {
      return;
    }
    if (viewRef.current.dom instanceof HTMLElement && viewRef.current.hasFocus()) {
      viewRef.current.dom.blur();
    }

    // The selectionToDOM method uses the document selection to determine currently selected node
    // We need to mimic blurring this as it seems doing the above is not enough.
    // @ts-expect-error
    var sel = viewRef.current.root.getSelection();
    if (sel) {
      sel.removeAllRanges();
    }
  }, []);
  var resetEditorState = useCallback(function (_ref) {
    var _props$editorProps$on, _props$editorProps2;
    var doc = _ref.doc,
      shouldScrollToBottom = _ref.shouldScrollToBottom;
    if (!viewRef.current) {
      return;
    }

    // We cannot currently guarantee when all the portals will have re-rendered during a reconfigure
    // so we blur here to stop ProseMirror from trying to apply selection to detached nodes or
    // nodes that haven't been re-rendered to the document yet.
    blur();
    var newEditorState = createEditorState({
      props: props,
      doc: doc,
      resetting: true,
      selectionAtStart: !shouldScrollToBottom
    });
    viewRef.current.updateState(newEditorState);
    (_props$editorProps$on = (_props$editorProps2 = props.editorProps).onChange) === null || _props$editorProps$on === void 0 || _props$editorProps$on.call(_props$editorProps2, viewRef.current, {
      source: 'local'
    });
  }, [blur, createEditorState, props]);

  // Initialise phase
  // Using constructor hook so we setup and dispatch analytics before anything else
  useConstructor(function () {
    var _props$intl;
    // This needs to be before initialising editorState because
    // we dispatch analytics events in plugin initialisation
    eventDispatcher.on(analyticsEventKey, handleAnalyticsEvent);
    eventDispatcher.on('resetEditorState', resetEditorState);
    dispatchAnalyticsEvent({
      action: ACTION.STARTED,
      actionSubject: ACTION_SUBJECT.EDITOR,
      attributes: {
        platform: PLATFORMS.WEB,
        featureFlags: featureFlags ? getEnabledFeatureFlagKeys(featureFlags) : [],
        accountLocale: (_props$intl = props.intl) === null || _props$intl === void 0 ? void 0 : _props$intl.locale,
        browserLocale: window.navigator.language
      },
      eventType: EVENT_TYPE.UI
    });
  });
  useLayoutEffect(function () {
    // Transaction dispatching is already enabled by default prior to
    // mounting, but we reset it here, just in case the editor view
    // instance is ever recycled (mounted again after unmounting) with
    // the same key.
    // AND since React 18 effects may run multiple times so we need to ensure
    // this is reset so that transactions are still allowed.
    // Although storing mounted state is an anti-pattern in React,
    // we do so here so that we can intercept and abort asynchronous
    // ProseMirror transactions when a dismount is imminent.
    canDispatchTransactions.current = true;
    return function () {
      // We can ignore any transactions from this point onwards.
      // This serves to avoid potential runtime exceptions which could arise
      // from an async dispatched transaction after it's unmounted.
      canDispatchTransactions.current = false;
    };
  }, []);

  // Cleanup
  useLayoutEffect(function () {
    return function () {
      var focusTimeoutIdCurrent = focusTimeoutId.current;
      if (focusTimeoutIdCurrent) {
        clearTimeout(focusTimeoutIdCurrent);
      }
      if (viewRef.current) {
        // Destroy the state if the Editor is being unmounted
        var editorState = viewRef.current.state;
        editorState.plugins.forEach(function (plugin) {
          var state = plugin.getState(editorState);
          if (state && state.destroy) {
            state.destroy();
          }
        });
      }
      eventDispatcher.destroy();
      // this.view will be destroyed when React unmounts in handleEditorViewRef
    };
  }, [eventDispatcher]);
  var reconfigureState = useCallback(function (props) {
    if (!viewRef.current) {
      return;
    }

    // We cannot currently guarantee when all the portals will have re-rendered during a reconfigure
    // so we blur here to stop ProseMirror from trying to apply selection to detached nodes or
    // nodes that haven't been re-rendered to the document yet.
    blur();
    var editorPlugins = createPluginsList(props.preset, props.editorProps, pluginInjectionAPI.current);
    config.current = processPluginsList(editorPlugins);
    var state = viewRef.current.state;
    var plugins = createPMPlugins({
      schema: state.schema,
      dispatch: dispatch,
      errorReporter: errorReporter,
      editorConfig: config.current,
      eventDispatcher: eventDispatcher,
      providerFactory: props.providerFactory,
      portalProviderAPI: props.portalProviderAPI,
      nodeViewPortalProviderAPI: props.nodeViewPortalProviderAPI,
      dispatchAnalyticsEvent: dispatchAnalyticsEvent,
      featureFlags: featureFlags,
      getIntl: function getIntl() {
        return props.intl;
      },
      onEditorStateUpdated: fg('platform_editor_catch_missing_injection_states') ? pluginInjectionAPI.current.onEditorViewUpdated : undefined
    });
    var newState = state.reconfigure({
      plugins: plugins
    });

    // need to update the state first so when the view builds the nodeviews it is
    // using the latest plugins
    viewRef.current.updateState(newState);
    return viewRef.current.update(_objectSpread(_objectSpread({}, viewRef.current.props), {}, {
      state: newState
    }));
  }, [blur, dispatchAnalyticsEvent, eventDispatcher, dispatch, errorReporter, featureFlags]);
  var onEditorViewUpdated = useCallback(function (_ref2) {
    var originalTransaction = _ref2.originalTransaction,
      transactions = _ref2.transactions,
      oldEditorState = _ref2.oldEditorState,
      newEditorState = _ref2.newEditorState;
    if (!fg('platform_editor_catch_missing_injection_states')) {
      pluginInjectionAPI.current.onEditorViewUpdated({
        newEditorState: newEditorState,
        oldEditorState: oldEditorState
      });
    }
    if (!fg('platform_editor_migrate_state_updates')) {
      var _config$current;
      (_config$current = config.current) === null || _config$current === void 0 || _config$current.onEditorViewStateUpdatedCallbacks.forEach(function (entry) {
        entry.callback({
          originalTransaction: originalTransaction,
          transactions: transactions,
          oldEditorState: oldEditorState,
          newEditorState: newEditorState
        });
      });
    }
  }, []);
  var _dispatchTransaction = useDispatchTransaction({
    onChange: props.editorProps.onChange,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    onEditorViewUpdated: onEditorViewUpdated,
    isRemoteReplaceDocumentTransaction: (_pluginInjectionAPI$c = pluginInjectionAPI.current.api()) === null || _pluginInjectionAPI$c === void 0 || (_pluginInjectionAPI$c = _pluginInjectionAPI$c.collabEdit) === null || _pluginInjectionAPI$c === void 0 || (_pluginInjectionAPI$c = _pluginInjectionAPI$c.actions) === null || _pluginInjectionAPI$c === void 0 ? void 0 : _pluginInjectionAPI$c.isRemoteReplaceDocumentTransaction
  });

  // Ignored via go/ees007
  // eslint-disable-next-line @atlaskit/editor/enforce-todo-comment-format
  // TODO: Remove these when we deprecate these props from editor-props - smartLinks is unfortunately still used in some places, we can sidestep this problem if we move everyone across to ComposableEditor and deprecate Editor
  var UNSAFE_cards = props.editorProps.UNSAFE_cards;
  var smartLinks = props.editorProps.smartLinks;

  // Temporary to replace provider factory while migration to `ComposableEditor` occurs
  useProviders({
    editorApi: editorAPI,
    contextIdentifierProvider: props.editorProps.contextIdentifierProvider,
    mediaProvider: (_media = props.editorProps.media) === null || _media === void 0 ? void 0 : _media.provider,
    mentionProvider: props.editorProps.mentionProvider,
    cardProvider: ((_linking = props.editorProps.linking) === null || _linking === void 0 || (_linking = _linking.smartLinks) === null || _linking === void 0 ? void 0 : _linking.provider) || smartLinks && smartLinks.provider || UNSAFE_cards && UNSAFE_cards.provider,
    emojiProvider: props.editorProps.emojiProvider,
    autoformattingProvider: props.editorProps.autoformattingProvider,
    taskDecisionProvider: props.editorProps.taskDecisionProvider
  });
  var getDirectEditorProps = useCallback(function (state) {
    return {
      state: state !== null && state !== void 0 ? state : getCurrentEditorState(),
      dispatchTransaction: function dispatchTransaction(tr) {
        // Block stale transactions:
        // Prevent runtime exceptions from async transactions that would attempt to
        // update the DOM after React has unmounted the Editor.

        if (canDispatchTransactions.current) {
          _dispatchTransaction(viewRef.current, tr);
        }
      },
      // Disables the contentEditable attribute of the editor if the editor is disabled
      editable: function editable(_state) {
        return !disabled;
      },
      attributes: {
        'data-gramm': 'false'
      }
    };
  }, [_dispatchTransaction, disabled, getCurrentEditorState]);
  var createEditorView = useCallback(function (node) {
    measureRender(measurements.PROSEMIRROR_RENDERED, function (_ref3) {
      var duration = _ref3.duration,
        startTime = _ref3.startTime,
        distortedDuration = _ref3.distortedDuration;
      var proseMirrorRenderedSeverity = getAnalyticsEventSeverity(duration, PROSEMIRROR_RENDERED_NORMAL_SEVERITY_THRESHOLD, PROSEMIRROR_RENDERED_DEGRADED_SEVERITY_THRESHOLD);
      if (viewRef.current) {
        var _pluginInjectionAPI$c2;
        var nodes = getNodesCount(viewRef.current.state.doc);
        var ttfb = getResponseEndTime();
        var contextIdentifier = (_pluginInjectionAPI$c2 = pluginInjectionAPI.current.api().base) === null || _pluginInjectionAPI$c2 === void 0 ? void 0 : _pluginInjectionAPI$c2.sharedState.currentState();
        dispatchAnalyticsEvent({
          action: ACTION.PROSEMIRROR_RENDERED,
          actionSubject: ACTION_SUBJECT.EDITOR,
          attributes: {
            duration: duration,
            startTime: startTime,
            nodes: nodes,
            ttfb: ttfb,
            severity: proseMirrorRenderedSeverity,
            objectId: contextIdentifier === null || contextIdentifier === void 0 ? void 0 : contextIdentifier.objectId,
            distortedDuration: distortedDuration
          },
          eventType: EVENT_TYPE.OPERATIONAL
        });
      }
    });

    // Creates the editor-view from this.editorState. If an editor has been mounted
    // previously, this will contain the previous state of the editor.
    var view = new EditorView({
      mount: node
    }, getDirectEditorProps());
    viewRef.current = view;
    pluginInjectionAPI.current.onEditorViewUpdated({
      newEditorState: viewRef.current.state,
      oldEditorState: undefined
    });
    return view;
  }, [getDirectEditorProps, dispatchAnalyticsEvent]);
  var _useState3 = useState(undefined),
    _useState4 = _slicedToArray(_useState3, 2),
    editorView = _useState4[0],
    setEditorView = _useState4[1];
  var originalScrollToRestore = React.useRef(isFullPage(props.editorProps.appearance) && fg('platform_editor_reduce_scroll_jump_on_editor_start') ? (_document$querySelect = document.querySelector('[data-editor-scroll-container]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.scrollTop : undefined);
  var mitigateScrollJump =
  // The feature gate here is being used to avoid potential bugs with the scroll restoration code
  // moving it to the end of the expression negates the point of the feature gate
  // eslint-disable-next-line @atlaskit/platform/no-preconditioning
  isFullPage(props.editorProps.appearance) && fg('platform_editor_reduce_scroll_jump_on_editor_start') && originalScrollToRestore.current && originalScrollToRestore.current !== 0;
  useLayoutEffect(function () {
    var _editorView$props$edi, _editorView$props;
    if (shouldFocus && editorView !== null && editorView !== void 0 && (_editorView$props$edi = (_editorView$props = editorView.props).editable) !== null && _editorView$props$edi !== void 0 && _editorView$props$edi.call(_editorView$props, editorView.state) && fg('platform_editor_react_18_autofocus_fix')) {
      if (fg('platform_editor_reduce_scroll_jump_on_editor_start')) {
        if (!mitigateScrollJump) {
          var liveDocWithContent = __livePage && !isEmptyDocument(editorView.state.doc);
          if (liveDocWithContent && fg('platform_editor_no_cursor_on_live_doc_init')) {
            focusElementOutsideEditor();
          } else {
            focusTimeoutId.current = handleEditorFocus(editorView);
          }
        }
      } else {
        var _liveDocWithContent = __livePage && !isEmptyDocument(editorView.state.doc);
        if (_liveDocWithContent && fg('platform_editor_no_cursor_on_live_doc_init')) {
          focusElementOutsideEditor();
        } else {
          focusTimeoutId.current = handleEditorFocus(editorView);
        }
      }
    }
  }, [editorView, shouldFocus, __livePage, mitigateScrollJump]);
  var handleEditorViewRef = useCallback(function (node) {
    if (!viewRef.current && node) {
      var view = createEditorView(node);
      if (fg('platform_editor_reduce_scroll_jump_on_editor_start')) {
        if (mitigateScrollJump) {
          var scrollElement = document.querySelector('[data-editor-scroll-container]');
          scrollElement === null || scrollElement === void 0 || scrollElement.scrollTo({
            top: originalScrollToRestore.current,
            behavior: 'instant'
          });
        }
      }
      onEditorCreated({
        view: view,
        config: config.current,
        eventDispatcher: eventDispatcher,
        transformer: contentTransformer.current
      });
      if (fg('platform_editor_react_18_autofocus_fix')) {
        var _startTransition;
        /**
         * Defer using startTransition when it is available (in React 18) to fix
         * autofocus bug where React 18's concurrent rendering mode interferes with
         * setTimeout used in handleEditorFocus, causing autofocus to break.
         */
        var react18OnlyStartTransition = (_startTransition = React === null || React === void 0 ? void 0 : React.startTransition) !== null && _startTransition !== void 0 ? _startTransition : function (fn) {
          return fn();
        };
        react18OnlyStartTransition(function () {
          // Force React to re-render so consumers get a reference to the editor view
          setEditorView(view);
        });
      } else {
        if (shouldFocus && view.props.editable && view.props.editable(view.state)) {
          if (fg('platform_editor_reduce_scroll_jump_on_editor_start')) {
            if (!mitigateScrollJump) {
              var isLivePageWithContent = __livePage && !isEmptyDocument(view.state.doc) && fg('platform_editor_no_cursor_on_live_doc_init');
              if (!isLivePageWithContent && shouldFocus && view.props.editable && view.props.editable(view.state)) {
                focusTimeoutId.current = handleEditorFocus(view);
              }
            }
          } else {
            var _isLivePageWithContent = __livePage && !isEmptyDocument(view.state.doc) && fg('platform_editor_no_cursor_on_live_doc_init');
            if (!_isLivePageWithContent && shouldFocus && view.props.editable && view.props.editable(view.state)) {
              focusTimeoutId.current = handleEditorFocus(view);
            }
          }
        }

        // Force React to re-render so consumers get a reference to the editor view
        setEditorView(view);
      }
    } else if (viewRef.current && !node) {
      // When the appearance is changed, React will call handleEditorViewRef with node === null
      // to destroy the old EditorView, before calling this method again with node === div to
      // create the new EditorView
      onEditorDestroyed({
        view: viewRef.current,
        config: config.current,
        eventDispatcher: eventDispatcher,
        transformer: contentTransformer.current
      });
      var wasAnalyticsDisconnected = !eventDispatcher.has(analyticsEventKey, handleAnalyticsEvent);
      // If we disabled event listening for some reason we should re-enable it temporarily while we destroy
      // the view for any analytics that occur there.
      if (wasAnalyticsDisconnected) {
        eventDispatcher.on(analyticsEventKey, handleAnalyticsEvent);
        viewRef.current.destroy(); // Destroys the dom node & all node views
        eventDispatcher.off(analyticsEventKey, handleAnalyticsEvent);
      } else {
        viewRef.current.destroy(); // Destroys the dom node & all node views
      }
      viewRef.current = undefined;
    }
  }, [createEditorView, onEditorCreated, eventDispatcher, shouldFocus, __livePage, onEditorDestroyed, handleAnalyticsEvent, mitigateScrollJump]);
  var createEditor = useCallback(function (assistiveLabel, assistiveDescribedBy) {
    return /*#__PURE__*/React.createElement("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      className: getUAPrefix(),
      key: "ProseMirror",
      ref: handleEditorViewRef,
      "aria-label": assistiveLabel || props.intl.formatMessage(editorMessages.editorAssistiveLabel)
      // setting aria-multiline to true when not mobile appearance.
      //  because somehow mobile tests are failing when it set.
      //  don't know why that is happening.
      // Created https://product-fabric.atlassian.net/jira/servicedesk/projects/DTR/queues/issue/DTR-1675
      //  to investigate further.
      ,
      "aria-multiline": true,
      role: "textbox",
      id: EDIT_AREA_ID,
      "aria-describedby": assistiveDescribedBy,
      "data-editor-id": editorId.current
    });
  }, [handleEditorViewRef, props.intl]);
  var previousPreset = usePreviousState(preset);
  useLayoutEffect(function () {
    if (previousPreset && previousPreset !== preset) {
      reconfigureState(props);
    }
  }, [reconfigureState, previousPreset, preset, props]);
  var previousDisabledState = usePreviousState(disabled);
  useLayoutEffect(function () {
    if (viewRef.current && previousDisabledState !== disabled) {
      // Disables the contentEditable attribute of the editor if the editor is disabled
      viewRef.current.setProps({
        editable: function editable(_state) {
          return !disabled;
        }
      });
      var isLivePageWithContent = __livePage && !isEmptyDocument(viewRef.current.state.doc) && fg('platform_editor_no_cursor_on_live_doc_init');
      if (!disabled && shouldFocus && !isLivePageWithContent) {
        focusTimeoutId.current = handleEditorFocus(viewRef.current);
      }
    }
  }, [disabled, shouldFocus, previousDisabledState, __livePage]);
  useFireFullWidthEvent(nextAppearance, dispatchAnalyticsEvent);
  var editor = useMemo(function () {
    return createEditor(props.editorProps.assistiveLabel, props.editorProps.assistiveDescribedBy);
  },
  // `createEditor` changes a little too frequently - we don't want to recreate the editor view in this case
  // We should follow-up
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [props.editorProps.assistiveLabel, props.editorProps.assistiveDescribedBy]);

  // Render tracking firing too many events for the legacy content macro. We're aware of the re-render issue, but disabling this for now. See - https://product-fabric.atlassian.net/browse/ED-26650
  var renderTrackingEnabled = !featureFlags.lcmPreventRenderTracking;
  return /*#__PURE__*/React.createElement(ReactEditorViewContext.Provider, {
    value: {
      editorRef: editorRef,
      editorView: viewRef.current,
      popupsMountPoint: props.editorProps.popupsMountPoint
    }
  }, fg('platform_editor_legacy_content_macro') ? renderTrackingEnabled && /*#__PURE__*/React.createElement(RenderTracking, {
    componentProps: props,
    action: ACTION.RE_RENDERED,
    actionSubject: ACTION_SUBJECT.REACT_EDITOR_VIEW,
    handleAnalyticsEvent: handleAnalyticsEvent,
    useShallow: true
  }) : /*#__PURE__*/React.createElement(RenderTracking, {
    componentProps: props,
    action: ACTION.RE_RENDERED,
    actionSubject: ACTION_SUBJECT.REACT_EDITOR_VIEW,
    handleAnalyticsEvent: handleAnalyticsEvent,
    useShallow: true
  }), props.render ? (_props$render = (_props$render2 = props.render) === null || _props$render2 === void 0 ? void 0 : _props$render2.call(props, {
    editor: editor,
    view: viewRef.current,
    config: config.current,
    eventDispatcher: eventDispatcher,
    transformer: contentTransformer.current,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    editorRef: editorRef,
    editorAPI: editorAPI
  })) !== null && _props$render !== void 0 ? _props$render : editor : editor);
}
export default injectIntl(ReactEditorView);