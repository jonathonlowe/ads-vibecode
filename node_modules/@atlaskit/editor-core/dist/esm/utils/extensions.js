import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import Loadable from 'react-loadable';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, fireAnalyticsEvent, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { getQuickInsertItemsFromModule, resolveImport } from '@atlaskit/editor-common/extensions';
import { combineProviders } from '@atlaskit/editor-common/provider-helpers';
import { findInsertLocation } from '@atlaskit/editor-common/utils/analytics';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
/**
 * Utils to send analytics event when a extension is inserted using quickInsert
 */
function sendExtensionQuickInsertAnalytics(item, selection, createAnalyticsEvent, source) {
  if (createAnalyticsEvent) {
    var insertLocation = fg('platform_nested_nbm_analytics_location') ? findInsertLocation(selection) : undefined;
    if (insertLocation && ['listItem', 'blockquote', 'nestedExpand', 'panel'].includes(insertLocation)) {
      // No-op editorExperiment evaluation to track usage of nested non-bodied macros
      // these can't be tracked at the point of diversion of the experience because that is a toggle of the
      // ProseMirror schema nodes for listItems, nestedExpand, blockquote, and panel. At that point the customer
      // has not yet been exposed to the experience.
      editorExperiment('platform_editor_nested_non_bodied_macros', 'test', {
        exposure: true
      });
    }
    fireAnalyticsEvent(createAnalyticsEvent)({
      payload: {
        action: ACTION.INSERTED,
        actionSubject: ACTION_SUBJECT.DOCUMENT,
        actionSubjectId: ACTION_SUBJECT_ID.EXTENSION,
        attributes: _objectSpread({
          extensionType: item.extensionType,
          extensionKey: item.extensionKey,
          key: item.key,
          inputMethod: source || INPUT_METHOD.QUICK_INSERT
        }, insertLocation ? {
          insertLocation: insertLocation
        } : {}),
        eventType: EVENT_TYPE.TRACK
      }
    });
  }
}
var showDummyAPIWarning = function showDummyAPIWarning(location) {
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line no-console
    console.warn("Extension plugin not attached to editor - cannot use extension API in ".concat(location));
  }
};
var dummyExtensionAPI = {
  editInContextPanel: function editInContextPanel() {
    return showDummyAPIWarning('editInContextPanel');
  },
  _editInLegacyMacroBrowser: function _editInLegacyMacroBrowser() {
    return showDummyAPIWarning('_editInLegacyMacroBrowser');
  },
  doc: {
    insertAfter: function insertAfter() {
      return showDummyAPIWarning('doc:insertAfter');
    },
    scrollTo: function scrollTo() {
      return showDummyAPIWarning('doc:scrollTo');
    },
    update: function update() {
      return showDummyAPIWarning('doc:update');
    }
  }
};
export function extensionProviderToQuickInsertProvider(_x, _x2, _x3, _x4) {
  return _extensionProviderToQuickInsertProvider.apply(this, arguments);
}

// Ignored via go/ees005
// eslint-disable-next-line require-await
function _extensionProviderToQuickInsertProvider() {
  _extensionProviderToQuickInsertProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(extensionProvider, editorActions, apiRef, createAnalyticsEvent) {
    var extensions;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return extensionProvider.getExtensions();
        case 2:
          extensions = _context.sent;
          return _context.abrupt("return", {
            getItems: function getItems() {
              var quickInsertItems = getQuickInsertItemsFromModule(extensions, function (item) {
                var Icon = Loadable({
                  loader: item.icon,
                  loading: function loading() {
                    return null;
                  }
                });
                return {
                  title: item.title,
                  description: item.description,
                  icon: function icon() {
                    return /*#__PURE__*/React.createElement(Icon, {
                      label: ""
                    });
                  },
                  keywords: item.keywords,
                  featured: item.featured,
                  categories: item.categories,
                  isDisabledOffline: true,
                  action: function action(insert, state, source) {
                    if (typeof item.node === 'function') {
                      if (fg('platform_editor_add_extension_api_to_quick_insert')) {
                        var _apiRef$current;
                        var extensionAPI = apiRef === null || apiRef === void 0 || (_apiRef$current = apiRef.current) === null || _apiRef$current === void 0 || (_apiRef$current = _apiRef$current.extension) === null || _apiRef$current === void 0 || (_apiRef$current = _apiRef$current.actions) === null || _apiRef$current === void 0 ? void 0 : _apiRef$current.api();
                        // While this should only run when the extension some setups of editor
                        // may not have the extension API
                        if (extensionAPI) {
                          resolveImport(item.node(extensionAPI)).then(function (node) {
                            sendExtensionQuickInsertAnalytics(item, state.selection, createAnalyticsEvent, source);
                            if (node) {
                              editorActions.replaceSelection(node);
                            }
                          });
                        } else {
                          // Originally it was understood we could only use this if we were using the extension plugin
                          // However there are some edge cases where this is not true (ie. in jira)
                          // Since making it optional now would be a breaking change - instead we can just pass a dummy
                          // extension API to consumers that warns them of using the methods.
                          resolveImport(item.node(dummyExtensionAPI)).then(function (node) {
                            sendExtensionQuickInsertAnalytics(item, state.selection, createAnalyticsEvent, source);
                            if (node) {
                              editorActions.replaceSelection(node);
                            }
                          });
                        }
                      } else {
                        // @ts-expect-error No longer supported without extension API - this will be removed once we cleanup the FG.
                        resolveImport(item.node()).then(function (node) {
                          sendExtensionQuickInsertAnalytics(item, state.selection, createAnalyticsEvent, source);
                          if (node) {
                            editorActions.replaceSelection(node);
                          }
                        });
                      }
                      return insert('');
                    } else {
                      sendExtensionQuickInsertAnalytics(item, state.selection, createAnalyticsEvent, source);
                      return insert(item.node);
                    }
                  }
                };
              });
              return Promise.all(quickInsertItems);
            }
          });
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _extensionProviderToQuickInsertProvider.apply(this, arguments);
}
export function combineQuickInsertProviders(_x5) {
  return _combineQuickInsertProviders.apply(this, arguments);
}
function _combineQuickInsertProviders() {
  _combineQuickInsertProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(quickInsertProviders) {
    var _combineProviders, invokeList;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _combineProviders = combineProviders(quickInsertProviders), invokeList = _combineProviders.invokeList;
          return _context2.abrupt("return", {
            getItems: function getItems() {
              return invokeList('getItems');
            }
          });
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _combineQuickInsertProviders.apply(this, arguments);
}