import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// Disable no-re-export rule for entry point files
/* eslint-disable @atlaskit/editor/no-re-export */

import { sortByOrder } from '@atlaskit/editor-common/legacy-rank-plugins';
import { EditorPresetBuilder } from '@atlaskit/editor-common/preset';
import { basePlugin } from '@atlaskit/editor-plugins/base';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { createSchema } from './create-editor/create-schema';
function lightProcessPluginsList(editorPlugins) {
  /**
   * First pass to collect pluginsOptions
   */
  var pluginsOptions = editorPlugins.reduce(function (acc, plugin) {
    if (plugin.pluginsOptions) {
      Object.keys(plugin.pluginsOptions).forEach(function (pluginName) {
        if (!acc[pluginName]) {
          acc[pluginName] = [];
        }
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        acc[pluginName].push(plugin.pluginsOptions[pluginName]);
      });
    }
    return acc;
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  {});

  /**
   * Process plugins
   */
  return editorPlugins.reduce(function (acc, editorPlugin) {
    if (editorPlugin.pmPlugins) {
      var _acc$plugins;
      (_acc$plugins = acc.plugins).push.apply(_acc$plugins, _toConsumableArray(editorPlugin.pmPlugins(editorPlugin.name ? pluginsOptions[editorPlugin.name] : undefined)));
    }
    if (editorPlugin.marks) {
      var _acc$marks;
      (_acc$marks = acc.marks).push.apply(_acc$marks, _toConsumableArray(editorPlugin.marks()));
    }
    if (editorPlugin.nodes) {
      var _acc$nodes;
      (_acc$nodes = acc.nodes).push.apply(_acc$nodes, _toConsumableArray(editorPlugin.nodes()));
    }
    if (editorPlugin.contentComponent) {
      acc.contentComponents.push(editorPlugin.contentComponent);
    }
    if (editorPlugin.usePluginHook) {
      acc.pluginHooks.push(editorPlugin.usePluginHook);
    }
    if (editorPlugin.onEditorViewStateUpdated) {
      acc.onEditorViewStateUpdatedCallbacks.push(editorPlugin.onEditorViewStateUpdated);
    }
    return acc;
  }, {
    nodes: [],
    marks: [],
    plugins: [],
    contentComponents: [],
    pluginHooks: [],
    onEditorViewStateUpdatedCallbacks: []
  });
}
export var createPMSchemaAndPlugins = function createPMSchemaAndPlugins() {
  var inputPreset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new EditorPresetBuilder();
  return function (pluginFactoryParams) {
    var editorPlugins = [];

    // we are ignoring the below because while this logic knows if
    // basePlugin is in the inputPreset, the type system does not
    // so it marks it as a duplicate plugin :) - this is fine
    var preset = inputPreset.has(basePlugin) ? inputPreset : inputPreset.add(basePlugin);
    editorPlugins = preset.build({
      pluginInjectionAPI: pluginFactoryParams.pluginInjectionAPI
    });
    var editorConfig = lightProcessPluginsList(editorPlugins);
    var schema = createSchema(editorConfig);
    var plugins = editorConfig.plugins.sort(sortByOrder('plugins')).map(function (_ref) {
      var plugin = _ref.plugin;
      return plugin(_objectSpread(_objectSpread({}, pluginFactoryParams), {}, {
        schema: schema
      }));
    }).filter(function (plugin) {
      return !!plugin;
    });
    return {
      plugins: plugins,
      schema: schema,
      onEditorViewStateUpdatedCallbacks: editorConfig.onEditorViewStateUpdatedCallbacks,
      editorConfig: editorConfig
    };
  };
};
export function setTextSelection(view, anchor, head) {
  var state = view.state;
  var tr = state.tr.setSelection(TextSelection.create(state.doc, anchor, head));
  view.dispatch(tr);
}

/**
 * Given a selector, checks if an element matching the selector exists in the
 * document.
 * @param selector
 * @returns true if element matching selector exists in document, false otherwise
 */
export var isElementBySelectorInDocument = function isElementBySelectorInDocument(selector) {
  return Boolean(document.querySelector(selector));
};