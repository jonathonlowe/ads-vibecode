"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _bindEventListener = require("bind-event-listener");
var _analyticsNext = require("@atlaskit/analytics-next");
var _noop = _interopRequireDefault(require("@atlaskit/ds-lib/noop"));
var _compiled = require("@atlaskit/primitives/compiled");
var _indicator = require("./indicator");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var packageName = "@atlaskit/progress-indicator";
var packageVersion = "12.0.3";
var progressIndicatorGapMap = {
  comfortable: {
    default: 'space.100',
    large: 'space.150'
  },
  cozy: {
    default: 'space.075',
    large: 'space.100'
  },
  compact: {
    default: 'space.050',
    large: 'space.075'
  }
};
var sizes = {
  default: 8,
  large: 12
};
var varDotsSize = '--ds-dots-size';
var varDotsMargin = '--ds-dots-margin';

/**
 * __ProgressDots__
 *
 * A progress indicator shows the user where they are along the steps of a journey.
 */
var ProgressDots = function ProgressDots(_ref) {
  var _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'default' : _ref$appearance,
    _ref$ariaControls = _ref.ariaControls,
    ariaControls = _ref$ariaControls === void 0 ? 'panel' : _ref$ariaControls,
    _ref$ariaLabel = _ref.ariaLabel,
    ariaLabel = _ref$ariaLabel === void 0 ? 'tab' : _ref$ariaLabel,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? 'default' : _ref$size,
    _ref$spacing = _ref.spacing,
    gutter = _ref$spacing === void 0 ? 'comfortable' : _ref$spacing,
    selectedIndex = _ref.selectedIndex,
    testId = _ref.testId,
    values = _ref.values,
    onSelect = _ref.onSelect;
  var tablistRef = (0, _react.useRef)(null);
  var onSelectWithAnalytics = (0, _analyticsNext.usePlatformLeafEventHandler)({
    fn: onSelect || _noop.default,
    action: 'selected',
    componentName: 'progressIndicator',
    packageName: packageName,
    packageVersion: packageVersion
  });
  var gap = progressIndicatorGapMap[gutter][size];
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    var indicators = Array.from(tablistRef.current.children);

    // bail if the target isn't an indicator
    if (!indicators.includes(event.target)) {
      return;
    }

    // bail if not valid arrow key
    var isLeft = event.key === 'ArrowLeft';
    var isRight = event.key === 'ArrowRight';
    if (!isLeft && !isRight) {
      return;
    }

    // bail if at either end of the values
    var isAlpha = isLeft && selectedIndex === 0;
    var isOmega = isRight && selectedIndex === values.length - 1;
    if (isAlpha || isOmega) {
      return;
    }
    var index = isLeft ? selectedIndex - 1 : selectedIndex + 1;

    // call the consumer's select method and focus the applicable indicator
    if (onSelect) {
      onSelectWithAnalytics({
        event: event,
        index: index
      });
    }
    if (typeof indicators[index].focus === 'function') {
      indicators[index].focus();
    }
  }, [onSelectWithAnalytics, selectedIndex, values, onSelect]);
  (0, _react.useEffect)(function () {
    if (!onSelect) {
      return _noop.default;
    }
    return (0, _bindEventListener.bind)(document, {
      type: 'keydown',
      listener: handleKeyDown,
      options: {
        capture: false
      }
    });
  }, [onSelect, handleKeyDown]);
  return /*#__PURE__*/_react.default.createElement(_compiled.Box, {
    style: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, varDotsSize, "".concat(sizes[size], "px")), varDotsMargin, gap),
    role: onSelect && 'tablist'
  }, /*#__PURE__*/_react.default.createElement(_compiled.Inline, {
    testId: testId,
    ref: function ref(r) {
      tablistRef.current = r;
    },
    alignInline: "center",
    space: gap
  }, values.map(function (_, index) {
    var isSelected = selectedIndex === index;
    var tabId = "".concat(ariaLabel).concat(index);
    var panelId = "".concat(ariaControls).concat(index);
    var indicatorTestId = testId && "".concat(testId, "-ind-").concat(index);
    return onSelect ? /*#__PURE__*/_react.default.createElement(_indicator.ButtonIndicator, {
      key: index,
      testId: indicatorTestId,
      appearance: appearance,
      isSelected: isSelected,
      tabId: tabId,
      panelId: panelId,
      onClick: function onClick(event) {
        return onSelectWithAnalytics({
          event: event,
          index: index
        });
      }
    }) : /*#__PURE__*/_react.default.createElement(_indicator.PresentationalIndicator, {
      key: index,
      testId: indicatorTestId,
      appearance: appearance,
      isSelected: isSelected
    });
  })));
};
var _default = exports.default = ProgressDots;