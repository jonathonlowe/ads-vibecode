"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.createHorizontalRule = void 0;
exports.inputRulePlugin = inputRulePlugin;
var _analytics = require("@atlaskit/editor-common/analytics");
var _insert = require("@atlaskit/editor-common/insert");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _utils = require("@atlaskit/editor-common/utils");
var _model = require("@atlaskit/editor-prosemirror/model");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _prosemirrorInputRules = require("@atlaskit/prosemirror-input-rules");
var createHorizontalRule = exports.createHorizontalRule = function createHorizontalRule(state, start, end, inputMethod, editorAnalyticsAPI) {
  if (!state.selection.empty) {
    return null;
  }
  var tr = null;
  var rule = state.schema.nodes.rule;
  /**
   * This is a workaround to get rid of the typeahead text when using quick insert
   * Once we insert *nothing*, we get a new transaction, so we can use the new selection
   * without considering the extra text after the `/` command.
   **/
  tr = state.tr.replaceWith(start, end, _model.Fragment.empty);
  tr = (0, _insert.safeInsert)(rule.createChecked(), tr.selection.from)(tr);
  if (!tr) {
    tr = state.tr.replaceRange(start, end, new _model.Slice(_model.Fragment.from(state.schema.nodes.rule.createChecked()), 0, 0));
  }
  editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
    action: _analytics.ACTION.INSERTED,
    actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: _analytics.ACTION_SUBJECT_ID.DIVIDER,
    attributes: {
      inputMethod: inputMethod
    },
    eventType: _analytics.EVENT_TYPE.TRACK
  })(tr);
  return tr;
};
var createHorizontalRuleAutoformat = function createHorizontalRuleAutoformat(state, start, end, editorAnalyticsAPI) {
  var listItem = state.schema.nodes.listItem;
  if ((0, _utils2.hasParentNodeOfType)(listItem)(state.selection)) {
    return null;
  }
  return createHorizontalRule(state, start, end, _analytics.INPUT_METHOD.FORMATTING, editorAnalyticsAPI);
};
function inputRulePlugin(schema, editorAnalyticsAPI) {
  var rules = [];
  if (schema.nodes.rule) {
    // '---' and '***' for hr
    rules.push(
    // eslint-disable-next-line require-unicode-regexp
    (0, _utils.createRule)(/^(\-\-\-|\*\*\*)$/, function (state, _match, start, end) {
      return createHorizontalRuleAutoformat(state, start, end, editorAnalyticsAPI);
    }));

    // '---' and '***' after shift+enter for hr
    rules.push((0, _utils.createRule)(
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    new RegExp("".concat(_prosemirrorInputRules.leafNodeReplacementCharacter, "(\\-\\-\\-|\\*\\*\\*)")), function (state, _match, start, end) {
      var hardBreak = state.schema.nodes.hardBreak;
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (state.doc.resolve(start).nodeAfter.type !== hardBreak) {
        return null;
      }
      return createHorizontalRuleAutoformat(state, start, end, editorAnalyticsAPI);
    }));
  }
  if (rules.length !== 0) {
    return new _safePlugin.SafePlugin((0, _prosemirrorInputRules.createPlugin)('rule', rules, {
      isBlockNodeRule: true
    }));
  }
  return;
}
var _default = exports.default = inputRulePlugin;