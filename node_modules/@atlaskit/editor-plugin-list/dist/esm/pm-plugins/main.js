import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { setGapCursorSelection, Side } from '@atlaskit/editor-common/selection';
import { CodeBlockSharedCssClassName, getOrderedListInlineStyles, listItemCounterPadding } from '@atlaskit/editor-common/styles';
import { getItemCounterDigitsSize, isListNode, pluginFactory } from '@atlaskit/editor-common/utils';
import { PluginKey } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { isWrappingPossible } from './utils/selection';
var listPluginKey = new PluginKey('listPlugin');
export var pluginKey = listPluginKey;
var initialState = {
  bulletListActive: false,
  bulletListDisabled: false,
  orderedListActive: false,
  orderedListDisabled: false,
  decorationSet: DecorationSet.empty
};
export var getDecorations = function getDecorations(doc, state, featureFlags) {
  var decorations = [];

  // this stack keeps track of each (nested) list to calculate the indentation level
  var processedListsStack = [];
  doc.nodesBetween(0, doc.content.size, function (node, currentNodeStartPos) {
    if (processedListsStack.length > 0) {
      var isOutsideLastList = true;
      while (isOutsideLastList && processedListsStack.length > 0) {
        var lastList = processedListsStack[processedListsStack.length - 1];
        var lastListEndPos = lastList.startPos + lastList.node.nodeSize;
        isOutsideLastList = currentNodeStartPos >= lastListEndPos;
        // once we finish iterating over each innermost list, pop the stack to
        // decrease the indent level attribute accordingly
        if (isOutsideLastList) {
          processedListsStack.pop();
        }
      }
    }
    if (isListNode(node)) {
      processedListsStack.push({
        node: node,
        startPos: currentNodeStartPos
      });
      var from = currentNodeStartPos;
      var to = currentNodeStartPos + node.nodeSize;
      var depth = processedListsStack.length;
      decorations.push(Decoration.node(from, to, {
        'data-indent-level': "".concat(depth)
      }));
      if (node.type.name === 'orderedList') {
        var _node$attrs;
        // If a numbered list has item counters numbering >= 100, we'll need to add special
        // spacing to account for the extra digit chars
        var digitsSize = getItemCounterDigitsSize({
          itemsCount: node === null || node === void 0 ? void 0 : node.childCount,
          order: node === null || node === void 0 || (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.order
        });
        if (digitsSize && digitsSize > 2) {
          decorations.push(Decoration.node(from, to, {
            style: getOrderedListInlineStyles(digitsSize, 'string')
          }));
        }
      }
    }
  });
  return DecorationSet.empty.add(doc, decorations);
};
var handleDocChanged = function handleDocChanged(featureFlags) {
  return function (tr, pluginState, editorState) {
    var nextPluginState = handleSelectionChanged(tr, pluginState);
    var decorationSet = getDecorations(tr.doc, editorState, featureFlags);
    return _objectSpread(_objectSpread({}, nextPluginState), {}, {
      decorationSet: decorationSet
    });
  };
};
var handleSelectionChanged = function handleSelectionChanged(tr, pluginState) {
  var _tr$doc$type$schema$n = tr.doc.type.schema.nodes,
    bulletList = _tr$doc$type$schema$n.bulletList,
    orderedList = _tr$doc$type$schema$n.orderedList,
    taskList = _tr$doc$type$schema$n.taskList;
  var listParent = findParentNodeOfType([bulletList, orderedList, taskList])(tr.selection);
  var bulletListActive = !!listParent && listParent.node.type === bulletList;
  var orderedListActive = !!listParent && listParent.node.type === orderedList;
  var bulletListDisabled = !(bulletListActive || orderedListActive || isWrappingPossible(bulletList, tr.selection));
  var orderedListDisabled = !(bulletListActive || orderedListActive || isWrappingPossible(orderedList, tr.selection));
  if (bulletListActive !== pluginState.bulletListActive || orderedListActive !== pluginState.orderedListActive || bulletListDisabled !== pluginState.bulletListDisabled || orderedListDisabled !== pluginState.orderedListDisabled) {
    var nextPluginState = _objectSpread(_objectSpread({}, pluginState), {}, {
      bulletListActive: bulletListActive,
      orderedListActive: orderedListActive,
      bulletListDisabled: bulletListDisabled,
      orderedListDisabled: orderedListDisabled
    });
    return nextPluginState;
  }
  return pluginState;
};
var reducer = function reducer() {
  return function (state) {
    return state;
  };
};
var createInitialState = function createInitialState(featureFlags) {
  return function (state) {
    return _objectSpread(_objectSpread({}, initialState), {}, {
      decorationSet: getDecorations(state.doc, state, featureFlags)
    });
  };
};
export var createPlugin = function createPlugin(eventDispatch, featureFlags) {
  var _pluginFactory = pluginFactory(listPluginKey, reducer(), {
      onDocChanged: handleDocChanged(featureFlags),
      onSelectionChanged: handleSelectionChanged
    }),
    getPluginState = _pluginFactory.getPluginState,
    createPluginState = _pluginFactory.createPluginState;
  return new SafePlugin({
    state: createPluginState(eventDispatch, createInitialState(featureFlags)),
    key: listPluginKey,
    props: {
      decorations: function decorations(state) {
        var _getPluginState = getPluginState(state),
          decorationSet = _getPluginState.decorationSet;
        return decorationSet;
      },
      handleClick: function handleClick(view, pos, event) {
        var state = view.state;
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        if (['LI', 'UL'].includes((event === null || event === void 0 ? void 0 : event.target).tagName)) {
          var _nodeAtPos$firstChild;
          var nodeAtPos = state.tr.doc.nodeAt(pos);
          var _view$state$schema$no = view.state.schema.nodes,
            listItem = _view$state$schema$no.listItem,
            codeBlock = _view$state$schema$no.codeBlock;
          if ((nodeAtPos === null || nodeAtPos === void 0 ? void 0 : nodeAtPos.type) === listItem && (nodeAtPos === null || nodeAtPos === void 0 || (_nodeAtPos$firstChild = nodeAtPos.firstChild) === null || _nodeAtPos$firstChild === void 0 ? void 0 : _nodeAtPos$firstChild.type) === codeBlock) {
            var _document;
            var bufferPx = 50;
            var isCodeBlockNextToListMarker = Boolean((_document = document) === null || _document === void 0 || (_document = _document.elementFromPoint(event.clientX + (listItemCounterPadding + bufferPx), event.clientY)) === null || _document === void 0 ? void 0 : _document.closest(".".concat(CodeBlockSharedCssClassName.CODEBLOCK_CONTAINER)));
            if (isCodeBlockNextToListMarker) {
              // +1 needed to put cursor inside li
              // otherwise gap cursor markup will be injected as immediate child of ul resulting in invalid html
              setGapCursorSelection(view, pos + 1, Side.LEFT);
              return true;
            }
          }
        }
        return false;
      }
    }
  });
};