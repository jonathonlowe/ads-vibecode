"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWrappingJoinRule = void 0;
var _analytics = require("@atlaskit/editor-common/analytics");
var _utils = require("@atlaskit/editor-common/utils");
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
// eslint-disable-next-line @typescript-eslint/no-explicit-any

var createWrappingJoinRule = exports.createWrappingJoinRule = function createWrappingJoinRule(_ref) {
  var match = _ref.match,
    nodeType = _ref.nodeType,
    getAttrs = _ref.getAttrs,
    joinPredicate = _ref.joinPredicate;
  var handler = function handler(state, match, start, end) {
    var attrs = (getAttrs instanceof Function ? getAttrs(match) : getAttrs) || {};
    var tr = state.tr;
    var fixedStart = Math.max(start, 1);
    tr.delete(fixedStart, end);
    var $start = tr.doc.resolve(fixedStart);
    var range = $start.blockRange();
    var wrapping = range && (0, _transform.findWrapping)(range, nodeType, attrs);
    if (!wrapping || !range) {
      return null;
    }
    var parentNodePosMapped = tr.mapping.map(range.start);
    var parentNode = tr.doc.nodeAt(parentNodePosMapped);
    var lastWrap = wrapping[wrapping.length - 1];
    if (parentNode && lastWrap) {
      var allowedMarks = lastWrap.type.allowedMarks(parentNode.marks) || [];
      tr.setNodeMarkup(parentNodePosMapped, parentNode.type, parentNode.attrs, allowedMarks);
    }
    tr.wrap(range, wrapping);

    // if an orderedList node would be inserted by the input rule match, and
    // that orderedList node is being added directly after another orderedList
    var $end = tr.doc.resolve(tr.mapping.map(end));
    var nodeWithPos = (0, _utils2.findParentNodeOfTypeClosestToPos)($end, nodeType);
    if (nodeType === state.schema.nodes.orderedList) {
      // otherwise join the lists
      if (nodeWithPos) {
        var nodeEnd = nodeWithPos.pos + nodeWithPos.node.nodeSize;
        var after = tr.doc.resolve(nodeEnd).nodeAfter;
        if (after && after.type === nodeType && (0, _transform.canJoin)(tr.doc, nodeEnd) && (!joinPredicate || joinPredicate(match, after, _analytics.JOIN_SCENARIOS_WHEN_TYPING_TO_INSERT_LIST.JOINED_TO_LIST_BELOW))) {
          tr.join(nodeEnd);
        }
      }
    }
    var before = tr.doc.resolve(fixedStart - 1).nodeBefore;
    if (before && before.type === nodeType && (0, _transform.canJoin)(tr.doc, fixedStart - 1) && (!joinPredicate || joinPredicate(match, before, _analytics.JOIN_SCENARIOS_WHEN_TYPING_TO_INSERT_LIST.JOINED_TO_LIST_ABOVE))) {
      tr.join(fixedStart - 1);
    }
    return tr;
  };
  return (0, _utils.createRule)(match, handler);
};