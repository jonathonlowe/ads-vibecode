"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.liftFollowingList = liftFollowingList;
exports.liftNodeSelectionList = liftNodeSelectionList;
exports.liftTextSelectionList = liftTextSelectionList;
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _indentation = require("./utils/indentation");
function liftListItem(selection, tr) {
  var $from = selection.$from,
    $to = selection.$to;
  var nodeType = tr.doc.type.schema.nodes.listItem;
  var range = $from.blockRange($to, function (node) {
    return !!node.childCount && !!node.firstChild && node.firstChild.type === nodeType;
  });
  if (!range || range.depth < 2 || $from.node(range.depth - 1).type !== nodeType) {
    return tr;
  }
  var end = range.end;
  var endOfList = $to.end(range.depth);
  if (end < endOfList) {
    tr.step(new _transform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new _model.Slice(_model.Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));
    range = new _model.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  return tr.lift(range, (0, _transform.liftTarget)(range)).scrollIntoView();
}

// Function will lift list item following selection to level-1.
function liftFollowingList(from, to, rootListDepth, tr) {
  var listItem = tr.doc.type.schema.nodes.listItem;
  var lifted = false;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (!lifted && node.type === listItem && pos > from) {
      lifted = true;
      var listDepth = rootListDepth + 3;
      while (listDepth > rootListDepth + 2) {
        var start = tr.doc.resolve(tr.mapping.map(pos));
        listDepth = start.depth;
        var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));
        var sel = new _state.TextSelection(start, end);
        tr = liftListItem(sel, tr);
      }
    }
  });
  return tr;
}
function liftNodeSelectionList(selection, tr) {
  var from = selection.from;
  var listItem = tr.doc.type.schema.nodes.listItem;
  var mappedPosition = tr.mapping.map(from);
  var nodeAtPos = tr.doc.nodeAt(mappedPosition);
  var start = tr.doc.resolve(mappedPosition);
  if ((start === null || start === void 0 ? void 0 : start.parent.type) !== listItem) {
    return tr;
  }
  var end = tr.doc.resolve(mappedPosition + ((nodeAtPos === null || nodeAtPos === void 0 ? void 0 : nodeAtPos.nodeSize) || 1));
  var range = start.blockRange(end);
  if (range) {
    var _liftTarget = (0, _indentation.getListLiftTarget)(start);
    tr.lift(range, _liftTarget);
  }
  return tr;
}
// The function will list paragraphs in selection out to level 1 below root list.
function liftTextSelectionList(selection, tr) {
  var from = selection.from,
    to = selection.to;
  var paragraph = tr.doc.type.schema.nodes.paragraph;
  var listCol = [];
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (node.type === paragraph) {
      listCol.push({
        node: node,
        pos: pos
      });
    }
  });
  for (var i = listCol.length - 1; i >= 0; i--) {
    var _paragraph = listCol[i];
    var start = tr.doc.resolve(tr.mapping.map(_paragraph.pos));
    if (start.depth > 0) {
      var end = void 0;
      if (_paragraph.node.textContent && _paragraph.node.textContent.length > 0) {
        end = tr.doc.resolve(tr.mapping.map(_paragraph.pos + _paragraph.node.textContent.length));
      } else {
        end = tr.doc.resolve(tr.mapping.map(_paragraph.pos + 1));
      }
      var range = start.blockRange(end);
      if (range) {
        tr.lift(range, (0, _indentation.getListLiftTarget)(start));
      }
    }
  }
  return tr;
}