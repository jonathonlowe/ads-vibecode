import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { Decoration } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { NESTED_DEPTH, getNodeAnchor, getNodeTypeWithLevel, TYPE_NODE_DEC } from './decorations-common';
var IGNORE_NODES = ['tableCell', 'tableHeader', 'tableRow', 'listItem', 'caption', 'layoutColumn'];
var IGNORE_NODES_NEXT = ['tableCell', 'tableHeader', 'tableRow', 'listItem', 'caption'];
var IGNORE_NODE_DESCENDANTS = ['listItem', 'taskList', 'decisionList', 'mediaSingle'];
var IGNORE_NODE_DESCENDANTS_ADVANCED_LAYOUT = ['listItem', 'taskList', 'decisionList'];
export var shouldDescendIntoNode = function shouldDescendIntoNode(node) {
  // Optimisation to avoid drawing node decorations for empty table cells
  if (['tableCell', 'tableHeader'].includes(node.type.name)) {
    var _node$firstChild;
    if (node.childCount === 1 && ((_node$firstChild = node.firstChild) === null || _node$firstChild === void 0 ? void 0 : _node$firstChild.type.name) === 'paragraph' && (fg('platform_editor_element_dnd_nested_fix_patch_6') ? node.firstChild.childCount === 0 : true)) {
      return false;
    }
  }
  if (editorExperiment('advanced_layouts', true)) {
    return !IGNORE_NODE_DESCENDANTS_ADVANCED_LAYOUT.includes(node.type.name);
  }
  return !IGNORE_NODE_DESCENDANTS.includes(node.type.name);
};
var shouldIgnoreNode = function shouldIgnoreNode(node, ignore_nodes, depth, parent) {
  var _nodeTypes$table, _node$attrs, _node$attrs2;
  var isEmbedCard = node.type.name === 'embedCard';
  var isMediaSingle = node.type.name === 'mediaSingle';
  var nodeTypes = node.type.schema.nodes;
  var isTable = node.type.name === (nodeTypes === null || nodeTypes === void 0 || (_nodeTypes$table = nodeTypes.table) === null || _nodeTypes$table === void 0 ? void 0 : _nodeTypes$table.name);
  var parentIsTable = parent && [nodeTypes.tableHeader, nodeTypes.tableCell].includes(parent.type);
  var isNestedTable = isTable && parentIsTable;
  if (isNestedTable && fg('platform_editor_disable_drag_handle_nested_tables')) {
    return true;
  }
  var isFirstTableRow = (parent === null || parent === void 0 ? void 0 : parent.type.name) === 'table' && depth === 1 && node === parent.firstChild && 'tableRow' === node.type.name && editorExperiment('advanced_layouts', true);
  if (isFirstTableRow) {
    return false;
  }
  var isLegacyContentMacroExtension = node.type.name === 'extension' && ((_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.extensionType) === 'com.atlassian.confluence.migration' && ((_node$attrs2 = node.attrs) === null || _node$attrs2 === void 0 ? void 0 : _node$attrs2.extensionKey) === 'legacy-content';
  if (isLegacyContentMacroExtension) {
    return true;
  }
  return (isEmbedCard || isMediaSingle) && ['wrap-right', 'wrap-left'].includes(node.attrs.layout) ? true : ignore_nodes.includes(node.type.name);
};

/**
 * Find node decorations in the pos range between from and to (non-inclusive)
 * @param decorations
 * @param from
 * @param to
 * @returns
 */
export var findNodeDecs = function findNodeDecs(decorations, from, to) {
  var newfrom = from;
  var newTo = to;

  // make it non-inclusive
  if (newfrom !== undefined) {
    newfrom++;
  }

  // make it non-inclusive
  if (newTo !== undefined) {
    newTo--;
  }

  // return empty array if range reversed
  if (newfrom !== undefined && newTo !== undefined && newfrom > newTo) {
    return [];
  }
  return decorations.find(newfrom, newTo, function (spec) {
    return spec.type === TYPE_NODE_DEC;
  });
};
export var nodeDecorations = function nodeDecorations(newState, from, to) {
  var decs = [];
  var docFrom = from === undefined || from < 0 ? 0 : from;
  var docTo = to === undefined || to > newState.doc.nodeSize - 2 ? newState.doc.nodeSize - 2 : to;
  var ignore_nodes = editorExperiment('advanced_layouts', true) ? IGNORE_NODES_NEXT : IGNORE_NODES;
  newState.doc.nodesBetween(docFrom, docTo, function (node, pos, parent, index) {
    var depth = 0;
    var shouldDescend = shouldDescendIntoNode(node);
    var anchorName = getNodeAnchor(node);
    var nodeTypeWithLevel = getNodeTypeWithLevel(node);

    // Doesn't descend into a node
    if (node.isInline) {
      return false;
    }
    depth = newState.doc.resolve(pos).depth;
    if (shouldIgnoreNode(node, ignore_nodes, depth, parent)) {
      return shouldDescend; //skip over, don't consider it a valid depth
    }
    var anchorStyles = "anchor-name: ".concat(anchorName, ";");
    decs.push(Decoration.node(pos, pos + node.nodeSize, _defineProperty(_defineProperty(_defineProperty({
      style: anchorStyles
    }, 'data-drag-handler-anchor-name', anchorName), 'data-drag-handler-node-type', nodeTypeWithLevel), 'data-drag-handler-anchor-depth', "".concat(depth)), {
      type: TYPE_NODE_DEC,
      anchorName: anchorName,
      nodeType: node.type.name,
      nodeTypeWithLevel: nodeTypeWithLevel
    }));
    return shouldDescend && depth < NESTED_DEPTH;
  });
  return decs;
};