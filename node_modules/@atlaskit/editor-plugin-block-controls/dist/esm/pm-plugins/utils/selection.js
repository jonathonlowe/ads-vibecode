import { TextSelection, NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { key } from '../main';
export var getMultiSelectionIfPosInside = function getMultiSelectionIfPosInside(api, pos, tr) {
  var _api$blockControls, _pluginState$multiSel, _tr$getMeta;
  var pluginState = api === null || api === void 0 || (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 ? void 0 : _api$blockControls.sharedState.currentState();
  // With move nodes shortcut, we expand selection and move node within one transaction,
  // Hence we also look for `multiSelectDnD` in transaction meta
  var multiSelectDnD = (_pluginState$multiSel = pluginState === null || pluginState === void 0 ? void 0 : pluginState.multiSelectDnD) !== null && _pluginState$multiSel !== void 0 ? _pluginState$multiSel : tr === null || tr === void 0 || (_tr$getMeta = tr.getMeta(key)) === null || _tr$getMeta === void 0 ? void 0 : _tr$getMeta.multiSelectDnD;
  if (multiSelectDnD && multiSelectDnD.anchor >= 0 && multiSelectDnD.head >= 0) {
    var multiFrom = Math.min(multiSelectDnD.anchor, multiSelectDnD.head);
    var multiTo = Math.max(multiSelectDnD.anchor, multiSelectDnD.head);

    // We subtract one as the handle position is before the node
    return pos >= multiFrom - 1 && pos < multiTo ? {
      anchor: multiSelectDnD.anchor,
      head: multiSelectDnD.head
    } : {};
  }
  return {};
};

/**
 *
 * @returns from and to positions of the selected content (after expansion)
 */
export var getSelectedSlicePosition = function getSelectedSlicePosition(handlePos, tr, api) {
  var _activeNode$nodeSize;
  var _getMultiSelectionIfP = getMultiSelectionIfPosInside(api, handlePos, tr),
    anchor = _getMultiSelectionIfP.anchor,
    head = _getMultiSelectionIfP.head;
  var inSelection = anchor !== undefined && head !== undefined;
  var from = inSelection ? Math.min(anchor || 0, head || 0) : handlePos;
  var activeNode = tr.doc.nodeAt(handlePos);
  var activeNodeEndPos = handlePos + ((_activeNode$nodeSize = activeNode === null || activeNode === void 0 ? void 0 : activeNode.nodeSize) !== null && _activeNode$nodeSize !== void 0 ? _activeNode$nodeSize : 1);
  var to = inSelection ? Math.max(anchor || 0, head || 0) : activeNodeEndPos;
  return {
    from: from,
    to: to
  };
};

/**
 * Takes a position and expands the selection to encompass the node at that position. Ignores empty or out of range selections.
 * Ignores positions that are in text blocks (i.e. not start of a node)
 * @returns TextSelection if expanded, otherwise returns Selection that was passed in.
 */
export var expandSelectionHeadToNodeAtPos = function expandSelectionHeadToNodeAtPos(selection, nodePos) {
  var doc = selection.$anchor.doc;
  if (nodePos < 0 || nodePos > doc.nodeSize - 2 || selection.empty) {
    return selection;
  }
  var $pos = doc.resolve(nodePos);
  var node = $pos.nodeAfter;
  if ($pos.node().isTextblock || !node) {
    return selection;
  }
  var $newHead = nodePos < selection.anchor ? $pos : doc.resolve(node.nodeSize + nodePos);
  var textSelection = new TextSelection(selection.$anchor, $newHead);
  return textSelection;
};

/**
 * This swaps the anchor/head for NodeSelections when its anchor > pos.
 * This is because NodeSelection always has an anchor at the start of the node,
 * which may not align with the existing selection.
 */
export var alignAnchorHeadInDirectionOfPos = function alignAnchorHeadInDirectionOfPos(selection, pos) {
  return selection instanceof NodeSelection && Math.max(pos, selection.anchor) === selection.anchor ? new TextSelection(selection.$head, selection.$anchor) : selection;
};