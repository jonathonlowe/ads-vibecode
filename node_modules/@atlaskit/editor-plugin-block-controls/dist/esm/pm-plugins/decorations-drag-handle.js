import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { createElement } from 'react';
import { bind } from 'bind-event-listener';
import ReactDOM from 'react-dom';
import uuid from 'uuid';
import { Decoration } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { DragHandle, DragHandleWithVisibility } from '../ui/drag-handle';
import { TYPE_HANDLE_DEC, TYPE_NODE_DEC, unmountDecorations } from './decorations-common';
export var emptyParagraphNodeDecorations = function emptyParagraphNodeDecorations() {
  var anchorName = "--node-anchor-paragraph-0";
  var style = "anchor-name: ".concat(anchorName, "; margin-top: 0px;");
  return Decoration.node(0, 2, _defineProperty({
    style: style
  }, 'data-drag-handler-anchor-name', anchorName), {
    type: TYPE_NODE_DEC
  });
};
export var findHandleDec = function findHandleDec(decorations, from, to) {
  return decorations.find(from, to, function (spec) {
    return spec.type === TYPE_HANDLE_DEC;
  });
};
export var dragHandleDecoration = function dragHandleDecoration(api, formatMessage, pos, anchorName, nodeType, nodeViewPortalProviderAPI, handleOptions, anchorRectCache) {
  if (!fg('platform_editor_fix_widget_destroy')) {
    unmountDecorations(nodeViewPortalProviderAPI, 'data-blocks-drag-handle-container', 'data-blocks-drag-handle-key');
  }
  var unbind;
  var key = uuid();
  return Decoration.widget(pos, function (view, getPosUnsafe) {
    var element = document.createElement('span');
    // inline decoration causes focus issues when refocusing Editor into first line
    element.style.display = 'block';
    element.setAttribute('data-testid', 'block-ctrl-decorator-widget');
    element.setAttribute('data-blocks-drag-handle-container', 'true');
    element.setAttribute('data-blocks-drag-handle-key', key);
    var isTopLevelNode = true;
    var getPos = function getPos() {
      try {
        return getPosUnsafe();
      } catch (e) {
        return undefined;
      }
    };
    var newPos = getPos();
    if (typeof newPos === 'number') {
      var $pos = view.state.doc.resolve(newPos);
      isTopLevelNode = ($pos === null || $pos === void 0 ? void 0 : $pos.parent.type.name) === 'doc';
    }
    /*
     * We disable mouseover event to fix flickering issue on hover
     * However, the tooltip for nested drag handle is no long working.
     */
    if (newPos === undefined || !isTopLevelNode) {
      // This will also hide the tooltip.
      unbind = bind(element, {
        type: 'mouseover',
        listener: function listener(e) {
          e.stopPropagation();
        }
      });
    }

    // There are times when global clear: "both" styles are applied to this decoration causing jumpiness
    // due to margins applied to other nodes eg. Headings
    element.style.clear = 'unset';

    // temporarily re-instating ReactDOM.render to fix drag handle focus issue, fix to
    // follow via ED-26546

    // previous under platform_editor_react18_plugin_portalprovider
    // 	nodeViewPortalProviderAPI.render(
    // 		() =>
    // 			createElement(DragHandle, {
    // 				view,
    // 				api,
    // 				formatMessage,
    // 				getPos,
    // 				anchorName,
    // 				nodeType,
    // 				handleOptions,
    // 				isTopLevelNode,
    // 			}),
    // 		element,
    // 		key,
    // 	);

    if (editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_widget_visibility')) {
      ReactDOM.render( /*#__PURE__*/createElement(DragHandleWithVisibility, {
        view: view,
        api: api,
        formatMessage: formatMessage,
        getPos: getPos,
        anchorName: anchorName,
        nodeType: nodeType,
        handleOptions: handleOptions,
        isTopLevelNode: isTopLevelNode,
        anchorRectCache: anchorRectCache
      }), element);
    } else {
      ReactDOM.render( /*#__PURE__*/createElement(DragHandle, {
        view: view,
        api: api,
        formatMessage: formatMessage,
        getPos: getPos,
        anchorName: anchorName,
        nodeType: nodeType,
        handleOptions: handleOptions,
        isTopLevelNode: isTopLevelNode,
        anchorRectCache: anchorRectCache
      }), element);
    }
    return element;
  }, {
    side: -1,
    type: TYPE_HANDLE_DEC,
    testid: "".concat(TYPE_HANDLE_DEC, "-").concat(uuid()),
    destroy: function destroy(node) {
      unbind && unbind();
      if (fg('platform_editor_fix_widget_destroy')) {
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        ReactDOM.unmountComponentAtNode(node);
      }
    }
  });
};