import { findParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { findNodeDecs } from '../pm-plugins/decorations-anchor';
import { getDecorations, key } from '../pm-plugins/main';
import { getNestedNodePosition } from '../pm-plugins/utils/getNestedNodePosition';
var findParentPosForHandle = function findParentPosForHandle(state) {
  var _activeNode$handleOpt;
  var $from = state.selection.$from;
  var _ref = key.getState(state) || {},
    activeNode = _ref.activeNode;

  // if a node handle is already focused, return the parent pos of that node (with focused handle)
  if (activeNode && (_activeNode$handleOpt = activeNode.handleOptions) !== null && _activeNode$handleOpt !== void 0 && _activeNode$handleOpt.isFocused) {
    var $activeNodePos = state.doc.resolve(activeNode.pos);

    // if the handle is at the top level already, do nothing
    if ($activeNodePos.depth === 0) {
      return undefined;
    }
    return $activeNodePos.before();
  }

  // if we are in second level of nested node, we should focus the node at level 1
  if ($from.depth <= 1) {
    return $from.before(1);
  }

  // if we are inside a table, we should focus the table's handle
  var parentTableNode = findParentNodeOfType([state.schema.nodes.table])(state.selection);
  if (parentTableNode) {
    return parentTableNode.pos;
  }

  // else find closest parent node
  return getNestedNodePosition(state);
};
var findNextAnchorDecoration = function findNextAnchorDecoration(state) {
  var decorations = getDecorations(state);
  if (!decorations) {
    return undefined;
  }
  var nextHandleNodePos = findParentPosForHandle(state);
  if (nextHandleNodePos === undefined) {
    return undefined;
  }
  var nextHandleNode = state.doc.nodeAt(nextHandleNodePos);
  var nodeDecorations = nextHandleNode && findNodeDecs(decorations, nextHandleNodePos, nextHandleNodePos + nextHandleNode.nodeSize);
  if (!nodeDecorations || nodeDecorations.length === 0) {
    return undefined;
  }

  // ensure the decoration covers the position of the look up node
  nodeDecorations = nodeDecorations.filter(function (decoration) {
    return decoration.from <= nextHandleNodePos;
  });
  if (nodeDecorations.length === 0) {
    return undefined;
  }

  // sort the decorations by the position of the node
  // so we can find the closest decoration to the node
  nodeDecorations.sort(function (a, b) {
    if (a.from === b.from) {
      return a.to - b.to;
    }
    return b.from - a.from;
  });

  // return the closest decoration to the node
  return nodeDecorations[0];
};
export var showDragHandleAtSelection = function showDragHandleAtSelection(api) {
  return function (state) {
    var decoration = findNextAnchorDecoration(state);
    if (api && decoration) {
      api.core.actions.execute(api.blockControls.commands.showDragHandleAt(decoration.from, decoration.spec.anchorName, decoration.spec.nodeTypeWithLevel, {
        isFocused: true
      }));
      return true;
    }
    return false;
  };
};