import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { logException } from '@atlaskit/editor-common/monitoring';
import { Fragment, Node as PMNode } from '@atlaskit/editor-prosemirror/model';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { attachMoveNodeAnalytics, fireInsertLayoutAnalytics, getMultiSelectAnalyticsAttributes } from '../pm-plugins/utils/analytics';
import { containsNodeOfType, isFragmentOfType } from '../pm-plugins/utils/check-fragment';
import { maxLayoutColumnSupported } from '../pm-plugins/utils/consts';
import { removeFromSource } from '../pm-plugins/utils/remove-from-source';
import { getMultiSelectionIfPosInside } from '../pm-plugins/utils/selection';
import { isInSameLayout } from '../pm-plugins/utils/validation';
import { DEFAULT_COLUMN_DISTRIBUTIONS } from '../ui/consts';
var createNewLayout = function createNewLayout(schema, layoutContents) {
  if (layoutContents.length === 0 || layoutContents.length > maxLayoutColumnSupported()) {
    return null;
  }
  var width = DEFAULT_COLUMN_DISTRIBUTIONS[layoutContents.length];
  if (!width) {
    return null;
  }
  var _ref = schema.nodes || {},
    layoutSection = _ref.layoutSection,
    layoutColumn = _ref.layoutColumn;
  try {
    var layoutContent = Fragment.fromArray(layoutContents.map(function (layoutContent) {
      return layoutColumn.createChecked({
        width: width
      }, layoutContent);
    }));
    var layoutSectionNode = layoutSection.createChecked(undefined, layoutContent);
    return layoutSectionNode;
  } catch (error) {
    logException(error, {
      location: 'editor-plugin-block-controls/move-to-layout'
    });
  }
  return null;
};
var moveToExistingLayout = function moveToExistingLayout(toLayout, toLayoutPos, sourceContent, from, to, tr, $originalFrom, $originalTo, api, selectMovedNode) {
  var isSameLayout = isInSameLayout($originalFrom, $originalTo);
  var sourceContentEndPos = -1;
  var isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);
  var sourceNodeTypes, hasSelectedMultipleNodes;
  if (isMultiSelect) {
    if (sourceContent instanceof Fragment) {
      sourceContentEndPos = from + sourceContent.size;
      var attributes = getMultiSelectAnalyticsAttributes(tr, from, sourceContentEndPos);
      hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
      sourceNodeTypes = attributes.nodeTypes;
    }
  } else {
    if (sourceContent instanceof PMNode) {
      sourceContentEndPos = from + sourceContent.nodeSize;
    }
  }
  if (sourceContentEndPos === -1) {
    return tr;
  }
  if (isSameLayout) {
    var _$originalFrom$nodeAf;
    // reorder columns
    tr.delete(from, sourceContentEndPos);
    var mappedTo = tr.mapping.map(to);
    tr.insert(mappedTo, sourceContent);
    if (selectMovedNode) {
      tr.setSelection(new NodeSelection(tr.doc.resolve(mappedTo))).scrollIntoView();
    }
    attachMoveNodeAnalytics(tr, INPUT_METHOD.DRAG_AND_DROP, $originalFrom.depth, ((_$originalFrom$nodeAf = $originalFrom.nodeAfter) === null || _$originalFrom$nodeAf === void 0 ? void 0 : _$originalFrom$nodeAf.type.name) || '', 1, 'layoutSection', true, api, sourceNodeTypes, hasSelectedMultipleNodes);
  } else if (toLayout.childCount < maxLayoutColumnSupported()) {
    var _$originalFrom$nodeAf2;
    removeFromSource(tr, tr.doc.resolve(from), sourceContentEndPos);
    insertToDestinationNoWidthUpdate(tr, tr.mapping.map(to), sourceContent);
    attachMoveNodeAnalytics(tr, INPUT_METHOD.DRAG_AND_DROP, $originalFrom.depth, ((_$originalFrom$nodeAf2 = $originalFrom.nodeAfter) === null || _$originalFrom$nodeAf2 === void 0 ? void 0 : _$originalFrom$nodeAf2.type.name) || '', 1, 'layoutSection', false, api, sourceNodeTypes, hasSelectedMultipleNodes);
  }
  return tr;
};

/**
 * This function is similar to insertToDestination
 * But without update width step, mainly rely on the append transaction from layout.
 * @param tr
 * @param to
 * @param sourceNode
 * @returns
 */
var insertToDestinationNoWidthUpdate = function insertToDestinationNoWidthUpdate(tr, to, sourceContent) {
  var _ref2 = tr.doc.type.schema.nodes || {},
    layoutColumn = _ref2.layoutColumn;
  var content = null;
  try {
    if (editorExperiment('platform_editor_element_drag_and_drop_multiselect', true)) {
      if (sourceContent instanceof Fragment) {
        var _sourceFragment$first;
        var sourceFragment = sourceContent;
        content = layoutColumn.createChecked({
          width: 0
        }, isFragmentOfType(sourceFragment, 'layoutColumn') ? (_sourceFragment$first = sourceFragment.firstChild) === null || _sourceFragment$first === void 0 ? void 0 : _sourceFragment$first.content : sourceFragment);
      }
    } else {
      if (sourceContent instanceof PMNode) {
        var sourceNode = sourceContent;
        content = layoutColumn.createChecked({
          width: 0
        }, sourceNode.type.name === 'layoutColumn' ? sourceNode.content : sourceNode);
      }
    }
  } catch (error) {
    logException(error, {
      location: 'editor-plugin-block-controls/move-to-layout'
    });
  }
  if (content) {
    tr.insert(to, content);
  }
  return tr;
};

/**
 * Check if the node at `from` can be moved to node at `to` to create/expand a layout.
 * Returns the source and destination nodes and positions if it's a valid move, otherwise, undefined
 */
var canMoveToLayout = function canMoveToLayout(api, from, to, tr, moveNodeAtCursorPos) {
  if (from === to) {
    return;
  }
  var _ref3 = tr.doc.type.schema.nodes || {},
    layoutSection = _ref3.layoutSection,
    layoutColumn = _ref3.layoutColumn,
    doc = _ref3.doc;

  // layout plugin does not exist
  if (!layoutSection || !layoutColumn) {
    return;
  }
  var $to = tr.doc.resolve(to);

  // drop at invalid position, not top level, or not a layout column
  if (!$to.nodeAfter || ![doc, layoutSection].includes($to.parent.type)) {
    return;
  }
  var $from = tr.doc.resolve(from);
  var isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);

  // invalid from position or dragging a layout
  if (!$from.nodeAfter || $from.nodeAfter.type === layoutSection) {
    return;
  }
  var sourceContent = $from.nodeAfter;
  var sourceFrom = from;
  var sourceTo = from + sourceContent.nodeSize;
  if (isMultiSelect && !moveNodeAtCursorPos) {
    var _getMultiSelectionIfP = getMultiSelectionIfPosInside(api, from),
      anchor = _getMultiSelectionIfP.anchor,
      head = _getMultiSelectionIfP.head;
    if (anchor !== undefined && head !== undefined) {
      sourceFrom = Math.min(anchor, head);
      sourceTo = Math.max(anchor, head);
      sourceContent = tr.doc.slice(sourceFrom, sourceTo).content;

      // TODO: ED-26959 - this might become expensive for large content, consider removing it if check has been done beforehand
      if (containsNodeOfType(sourceContent, 'layoutSection')) {
        return;
      }
    } else {
      sourceContent = Fragment.from($from.nodeAfter);
    }
  }
  var toNode = $to.nodeAfter;
  return {
    toNode: toNode,
    $to: $to,
    sourceContent: sourceContent,
    $sourceFrom: tr.doc.resolve(sourceFrom),
    sourceTo: sourceTo
  };
};
var removeBreakoutMarks = function removeBreakoutMarks(tr, $from, to) {
  var fromContentWithoutBreakout = $from.nodeAfter;
  var _ref4 = tr.doc.type.schema.marks || {},
    breakout = _ref4.breakout;
  if (editorExperiment('platform_editor_element_drag_and_drop_multiselect', true)) {
    tr.doc.nodesBetween($from.pos, to, function (node, pos, parent) {
      // breakout doesn't exist on nested nodes
      if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'doc' && node.marks.some(function (m) {
        return m.type === breakout;
      })) {
        tr.removeNodeMark(pos, breakout);
      }

      // descending is not needed as  breakout doesn't exist on nested nodes
      return false;
    });
    // resolve again the source content after node updated (remove breakout marks)
    fromContentWithoutBreakout = tr.doc.slice($from.pos, to).content;
  } else {
    if (breakout && $from.nodeAfter && $from.nodeAfter.marks.some(function (m) {
      return m.type === breakout;
    })) {
      tr.removeNodeMark($from.pos, breakout);
      // resolve again the source node after node updated (remove breakout marks)
      fromContentWithoutBreakout = tr.doc.resolve($from.pos).nodeAfter;
    }
  }
  return fromContentWithoutBreakout;
};
var getBreakoutMode = function getBreakoutMode(content, breakout) {
  if (editorExperiment('platform_editor_element_drag_and_drop_multiselect', true)) {
    if (content instanceof PMNode) {
      var _content$marks$find;
      return (_content$marks$find = content.marks.find(function (m) {
        return m.type === breakout;
      })) === null || _content$marks$find === void 0 ? void 0 : _content$marks$find.attrs.mode;
    } else if (content instanceof Fragment) {
      // Find the first breakout mode in the fragment
      var firstBreakoutMode;
      for (var i = 0; i < content.childCount; i++) {
        var child = content.child(i);
        var breakoutMark = child.marks.find(function (m) {
          return m.type === breakout;
        });
        if (breakoutMark) {
          firstBreakoutMode = breakoutMark.attrs.mode;
          break;
        }
      }
      return firstBreakoutMode;
    }
  } else {
    // Without multi-select support, we can assume source content is of type PMNode
    if (content instanceof PMNode) {
      var _content$marks$find2;
      return (_content$marks$find2 = content.marks.find(function (m) {
        return m.type === breakout;
      })) === null || _content$marks$find2 === void 0 ? void 0 : _content$marks$find2.attrs.mode;
    }
  }
};

// TODO: ED-26959 - As part of platform_editor_element_drag_and_drop_multiselect clean up,
// source content variable that has type of `PMNode | Fragment` should be updated to `Fragment` only
export var moveToLayout = function moveToLayout(api) {
  return function (from, to, options) {
    return function (_ref5) {
      var tr = _ref5.tr;
      if (!api) {
        return tr;
      }
      var canMove = canMoveToLayout(api, from, to, tr, options === null || options === void 0 ? void 0 : options.moveNodeAtCursorPos);
      if (!canMove) {
        return tr;
      }
      var toNode = canMove.toNode,
        $to = canMove.$to,
        sourceContent = canMove.sourceContent,
        $sourceFrom = canMove.$sourceFrom,
        sourceTo = canMove.sourceTo;
      var _ref6 = tr.doc.type.schema.nodes || {},
        layoutSection = _ref6.layoutSection,
        layoutColumn = _ref6.layoutColumn;
      var _ref7 = tr.doc.type.schema.marks || {},
        breakout = _ref7.breakout;

      // get breakout mode from destination node,
      // if not found, get from source node,
      var breakoutMode = getBreakoutMode(toNode, breakout) || getBreakoutMode(sourceContent, breakout);

      // we don't want to remove marks when moving/re-ordering layoutSection
      var shouldRemoveMarks = !($sourceFrom.node().type === layoutSection && editorExperiment('platform_editor_element_drag_and_drop_multiselect', true) && fg('platform_editor_elements_dnd_multi_select_patch_3'));
      var fromContentBeforeBreakoutMarksRemoved = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true) ? tr.doc.slice($sourceFrom.pos, sourceTo).content : $sourceFrom.nodeAfter;

      // remove breakout from source content
      var fromContentWithoutBreakout = shouldRemoveMarks ? removeBreakoutMarks(tr, $sourceFrom, sourceTo) : fromContentBeforeBreakoutMarksRemoved;
      if (!fromContentWithoutBreakout) {
        return tr;
      }
      if (fg('platform_editor_ease_of_use_metrics')) {
        var _api$metrics;
        api === null || api === void 0 || (_api$metrics = api.metrics) === null || _api$metrics === void 0 || _api$metrics.commands.setContentMoved()({
          tr: tr
        });
      }
      var isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);
      if (toNode.type === layoutSection) {
        var toPos = options !== null && options !== void 0 && options.moveToEnd ? to + toNode.nodeSize - 1 : to + 1;
        return moveToExistingLayout(toNode, to, fromContentWithoutBreakout, $sourceFrom.pos, toPos, tr, $sourceFrom, $to, api, options === null || options === void 0 ? void 0 : options.selectMovedNode);
      } else if (toNode.type === layoutColumn) {
        var toLayout = $to.parent;
        var toLayoutPos = to - $to.parentOffset - 1;
        var _toPos = options !== null && options !== void 0 && options.moveToEnd ? to + toNode.nodeSize : to;
        return moveToExistingLayout(toLayout, toLayoutPos, fromContentWithoutBreakout, $sourceFrom.pos, _toPos, tr, $sourceFrom, $to, api, options === null || options === void 0 ? void 0 : options.selectMovedNode);
      } else {
        var toNodeWithoutBreakout = toNode;

        // remove breakout from node;
        if (breakout && $to.nodeAfter && $to.nodeAfter.marks.some(function (m) {
          return m.type === breakout;
        })) {
          tr.removeNodeMark(to, breakout);
          // resolve again the source node after node updated (remove breakout marks)
          toNodeWithoutBreakout = tr.doc.resolve(to).nodeAfter || toNode;
        }
        if (isMultiSelect) {
          if (isFragmentOfType(fromContentWithoutBreakout, 'layoutColumn') && fromContentWithoutBreakout.firstChild) {
            fromContentWithoutBreakout = fromContentWithoutBreakout.firstChild.content;
          }
        } else {
          if (fromContentWithoutBreakout instanceof PMNode && fromContentWithoutBreakout.type.name === 'layoutColumn') {
            fromContentWithoutBreakout = fromContentWithoutBreakout.content;
          }
        }
        var layoutContents = options !== null && options !== void 0 && options.moveToEnd ? [toNodeWithoutBreakout, fromContentWithoutBreakout] : [fromContentWithoutBreakout, toNodeWithoutBreakout];
        var newLayout = createNewLayout(tr.doc.type.schema, layoutContents);
        if (newLayout) {
          var sourceNodeTypes, hasSelectedMultipleNodes;
          if (isMultiSelect) {
            var attributes = getMultiSelectAnalyticsAttributes(tr, $sourceFrom.pos, sourceTo);
            hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
            sourceNodeTypes = attributes.nodeTypes;
          }
          tr = removeFromSource(tr, $sourceFrom, sourceTo);
          var mappedTo = tr.mapping.map(to);
          tr.delete(mappedTo, mappedTo + toNodeWithoutBreakout.nodeSize).insert(mappedTo, newLayout);
          breakoutMode && tr.setNodeMarkup(mappedTo, newLayout.type, newLayout.attrs, [breakout.create({
            mode: breakoutMode
          })]);
          fireInsertLayoutAnalytics(tr, api, sourceNodeTypes, hasSelectedMultipleNodes);
        }
        return tr;
      }
    };
  };
};