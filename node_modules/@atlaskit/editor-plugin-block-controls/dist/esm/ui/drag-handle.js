import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

import { useCallback, useEffect, useRef, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { bind } from 'bind-event-listener';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { browser } from '@atlaskit/editor-common/browser';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { dragToMoveDown, dragToMoveLeft, dragToMoveRight, dragToMoveUp, getAriaKeyshortcuts, TooltipContentWithMultipleShortcuts } from '@atlaskit/editor-common/keymaps';
import { blockControlsMessages } from '@atlaskit/editor-common/messages';
import { tableControlsSpacing } from '@atlaskit/editor-common/styles';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { findDomRefAtPos } from '@atlaskit/editor-prosemirror/utils';
import DragHandlerIcon from '@atlaskit/icon/glyph/drag-handler';
import DragHandleVerticalIcon from '@atlaskit/icon/utility/drag-handle-vertical';
import { fg } from '@atlaskit/platform-feature-flags';
import { draggable } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { setCustomNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview';
import { Box, xcss } from '@atlaskit/primitives';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import Tooltip from '@atlaskit/tooltip';
import { key } from '../pm-plugins/main';
import { getMultiSelectAnalyticsAttributes } from '../pm-plugins/utils/analytics';
import { getControlBottomCSSValue, getControlHeightCSSValue, getLeftPosition, getNodeHeight, getTopPosition, shouldBeSticky, shouldMaskNodeControls } from '../pm-plugins/utils/drag-handle-positions';
import { isHandleCorrelatedToSelection, selectNode } from '../pm-plugins/utils/getSelection';
import { alignAnchorHeadInDirectionOfPos, expandSelectionHeadToNodeAtPos } from '../pm-plugins/utils/selection';
import { BLOCK_MENU_ENABLED, DRAG_HANDLE_BORDER_RADIUS, DRAG_HANDLE_HEIGHT, DRAG_HANDLE_MAX_SHIFT_CLICK_DEPTH, DRAG_HANDLE_WIDTH, DRAG_HANDLE_ZINDEX, dragHandleGap, nodeMargins, spacingBetweenNodesForPreview, STICKY_CONTROLS_TOP_MARGIN, topPositionAdjustment } from './consts';
import { dragPreview } from './drag-preview';
import { refreshAnchorName } from './utils/anchor-name';
import { VisibilityContainer } from './visibility-container';
var iconWrapperStyles = xcss({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
});
var buttonWrapperStyles = css({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    background: "linear-gradient(to bottom, ".concat("var(--ds-surface, #FFFFFF)", " 90%, transparent)"),
    marginBottom: "var(--ds-space-negative-200, -16px)",
    paddingBottom: "var(--ds-space-200, 16px)",
    marginTop: "var(--ds-space-negative-400, -32px)",
    paddingTop: "calc(".concat("var(--ds-space-400, 32px)", " - 1px)"),
    marginRight: "var(--ds-space-negative-150, -12px)",
    paddingRight: "var(--ds-space-150, 12px)",
    boxSizing: 'border-box'
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    background: "linear-gradient(to bottom, ".concat("var(--ds-surface, #FFFFFF)", " 90%, transparent)"),
    marginBottom: "var(--ds-space-negative-200, -16px)",
    paddingBottom: "var(--ds-space-200, 16px)",
    marginTop: "var(--ds-space-negative-400, -32px)",
    paddingTop: "calc(".concat("var(--ds-space-400, 32px)", " - 1px)"),
    marginRight: "var(--ds-space-negative-150, -12px)",
    paddingRight: "var(--ds-space-150, 12px)",
    boxSizing: 'border-box'
  }
});

// update color to match quick insert button for new editor controls
var dragHandleColor = css({
  color: "var(--ds-icon-subtle, #626F86)"
});
var dragHandleButtonStyles = css({
  display: 'flex',
  boxSizing: 'border-box',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  height: DRAG_HANDLE_HEIGHT,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  width: DRAG_HANDLE_WIDTH,
  border: 'none',
  background: 'transparent',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  borderRadius: DRAG_HANDLE_BORDER_RADIUS,
  // when platform_editor_controls is enabled, the drag handle color is overridden. Update color here when experiment is cleaned up.
  color: "var(--ds-icon, #44546F)",
  cursor: 'grab',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  zIndex: DRAG_HANDLE_ZINDEX,
  outline: 'none',
  '&:hover': {
    backgroundColor: "var(--ds-background-neutral-subtle-hovered, #091E420F)"
  },
  '&:active': {
    backgroundColor: "var(--ds-background-neutral-subtle-pressed, #091E4224)"
  },
  '&:focus': {
    outline: "2px solid ".concat("var(--ds-border-focused, #388BFF)")
  },
  '&:disabled': {
    color: "var(--ds-icon-disabled, #8993A4)",
    backgroundColor: 'transparent'
  },
  '&:hover:disabled': {
    backgroundColor: "var(--ds-background-disabled, transparent)"
  }
});
var dragHandleButtonStylesOld = css({
  position: 'absolute',
  paddingTop: "var(--ds-space-025, 2px)",
  paddingBottom: "var(--ds-space-025, 2px)",
  paddingLeft: '0',
  paddingRight: '0',
  boxSizing: 'border-box',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  height: DRAG_HANDLE_HEIGHT,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  width: DRAG_HANDLE_WIDTH,
  border: 'none',
  background: 'transparent',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  borderRadius: DRAG_HANDLE_BORDER_RADIUS,
  // when platform_editor_controls is enabled, the drag handle color is overridden. Update color here when experiment is cleaned up.
  color: "var(--ds-icon, #44546F)",
  cursor: 'grab',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  zIndex: DRAG_HANDLE_ZINDEX,
  outline: 'none',
  '&:hover': {
    backgroundColor: "var(--ds-background-neutral-subtle-hovered, #091E420F)"
  },
  '&:active': {
    backgroundColor: "var(--ds-background-neutral-subtle-pressed, #091E4224)"
  },
  '&:focus': {
    outline: "2px solid ".concat("var(--ds-border-focused, #388BFF)")
  },
  '&:disabled': {
    color: "var(--ds-icon-disabled, #8993A4)",
    backgroundColor: 'transparent'
  },
  '&:hover:disabled': {
    backgroundColor: "var(--ds-background-disabled, transparent)"
  }
});
var dragHandleContainerStyles = xcss({
  position: 'absolute',
  boxSizing: 'border-box'
});
var tooltipContainerStyles = css({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  bottom: "-".concat(STICKY_CONTROLS_TOP_MARGIN, "px"),
  position: 'sticky',
  display: 'block',
  zIndex: 100 // card = 100
});
var tooltipContainerStylesStickyHeaderWithMask = css({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  top: "".concat(STICKY_CONTROLS_TOP_MARGIN, "px"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    top: '0'
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    top: '0'
  }
});
var tooltipContainerStylesStickyHeaderWithoutMask = css({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  top: "".concat(STICKY_CONTROLS_TOP_MARGIN, "px"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
    top: tableControlsSpacing
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
    top: tableControlsSpacing
  }
});
var dragHandleMultiLineSelectionFixFirefox = css({
  '&::selection': {
    backgroundColor: 'transparent'
  }
});
var layoutColumnDragHandleStyles = css({
  transform: 'rotate(90deg)'
});
var selectedStyles = css({
  backgroundColor: "var(--ds-background-selected, #E9F2FF)",
  color: "var(--ds-icon-selected, #0C66E4)"
});

// [Chrome only] When selection contains multiple nodes and then drag a drag handle that is within the selection range,
// icon span receives dragStart event, instead of button, and since it is not registered as a draggable element
// with pragmatic DnD and pragmatic DnD is not triggered
var handleIconDragStart = function handleIconDragStart(e) {
  if (!browser.chrome || !fg('platform_editor_dnd_update_drag_start_target')) {
    return;
  }
  // prevent dragStart handler triggered by icon
  e.stopPropagation();
  var dragEvent = new DragEvent('dragstart', {
    bubbles: true,
    cancelable: true,
    dataTransfer: e.dataTransfer
  });
  if (e.target instanceof HTMLElement) {
    var _e$target$closest;
    // re-dispatch drag event on button so that pragmatic DnD can be triggered properly
    (_e$target$closest = e.target.closest('button')) === null || _e$target$closest === void 0 || _e$target$closest.dispatchEvent(dragEvent);
  }
};
var getNodeSpacingForPreview = function getNodeSpacingForPreview(node) {
  if (!node) {
    return spacingBetweenNodesForPreview['default'];
  }
  var nodeTypeName = node.type.name;
  if (nodeTypeName === 'heading') {
    return spacingBetweenNodesForPreview["heading".concat(node.attrs.level)] || spacingBetweenNodesForPreview['default'];
  }
  return spacingBetweenNodesForPreview[nodeTypeName] || spacingBetweenNodesForPreview['default'];
};
var getNodeMargins = function getNodeMargins(node) {
  if (!node) {
    return nodeMargins['default'];
  }
  var nodeTypeName = node.type.name;
  if (nodeTypeName === 'heading') {
    return nodeMargins["heading".concat(node.attrs.level)] || nodeMargins['default'];
  }
  return nodeMargins[nodeTypeName] || nodeMargins['default'];
};
export var DragHandle = function DragHandle(_ref) {
  var _api$core2, _api$blockControls3, _api$analytics2, _api$core4;
  var view = _ref.view,
    api = _ref.api,
    formatMessage = _ref.formatMessage,
    getPos = _ref.getPos,
    anchorName = _ref.anchorName,
    nodeType = _ref.nodeType,
    handleOptions = _ref.handleOptions,
    _ref$isTopLevelNode = _ref.isTopLevelNode,
    isTopLevelNode = _ref$isTopLevelNode === void 0 ? true : _ref$isTopLevelNode,
    anchorRectCache = _ref.anchorRectCache;
  var start = getPos();
  var buttonRef = useRef(null);
  var _useState = useState(768),
    _useState2 = _slicedToArray(_useState, 2),
    blockCardWidth = _useState2[0],
    setBlockCardWidth = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    dragHandleSelected = _useState4[0],
    setDragHandleSelected = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    dragHandleDisabled = _useState6[0],
    setDragHandleDisabled = _useState6[1];
  var _useSharedPluginState = useSharedPluginState(api, ['featureFlags']),
    featureFlagsState = _useSharedPluginState.featureFlagsState;
  var selection = useSharedPluginStateSelector(api, 'selection.selection');
  var isShiftDown = useSharedPluginStateSelector(api, 'blockControls.isShiftDown');
  var hasHadInteraction = useSharedPluginStateSelector(api, 'interaction.hasHadInteraction') !== false;
  var isLayoutColumn = nodeType === 'layoutColumn';
  var isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);
  useEffect(function () {
    // blockCard/datasource width is rendered correctly after this decoraton does. We need to observe for changes.
    if (nodeType === 'blockCard') {
      var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
      var container = dom === null || dom === void 0 ? void 0 : dom.querySelector('.datasourceView-content-inner-wrap');
      if (container) {
        var resizeObserver = new ResizeObserver(function (entries) {
          var width = entries[0].contentBoxSize[0].inlineSize;
          setBlockCardWidth(width);
        });
        resizeObserver.observe(container);
        return function () {
          return resizeObserver.unobserve(container);
        };
      }
    }
  }, [anchorName, nodeType, view.dom]);
  var handleOnClick = useCallback(function (e) {
    var _api$core;
    if (!isMultiSelect) {
      setDragHandleSelected(!dragHandleSelected);
    }
    api === null || api === void 0 || (_api$core = api.core) === null || _api$core === void 0 || _api$core.actions.execute(function (_ref2) {
      var _api$blockControls$sh, _api$analytics;
      var tr = _ref2.tr;
      var startPos = getPos();
      if (startPos === undefined) {
        return tr;
      }
      var mSelect = api === null || api === void 0 || (_api$blockControls$sh = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh === void 0 ? void 0 : _api$blockControls$sh.multiSelectDnD;
      var $anchor = (mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) !== undefined ? tr.doc.resolve(mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) : tr.selection.$anchor;
      if (!isMultiSelect || tr.selection.empty || !e.shiftKey) {
        tr = selectNode(tr, startPos, nodeType);
        if (BLOCK_MENU_ENABLED && editorExperiment('platform_editor_controls', 'variant1')) {
          var _api$blockControls;
          api === null || api === void 0 || (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 || _api$blockControls.commands.toggleBlockMenu({
            anchorName: anchorName
          })({
            tr: tr
          });
          e.stopPropagation();
        }
      } else if (isTopLevelNode && $anchor.depth <= DRAG_HANDLE_MAX_SHIFT_CLICK_DEPTH && e.shiftKey && fg('platform_editor_elements_dnd_shift_click_select')) {
        var _api$blockControls2;
        var alignAnchorHeadToSel = alignAnchorHeadInDirectionOfPos(tr.selection, startPos);
        var selectionWithExpandedHead = expandSelectionHeadToNodeAtPos(alignAnchorHeadToSel, startPos);
        tr.setSelection(selectionWithExpandedHead);
        api === null || api === void 0 || (_api$blockControls2 = api.blockControls) === null || _api$blockControls2 === void 0 || _api$blockControls2.commands.setMultiSelectPositions()({
          tr: tr
        });
      }
      var resolvedMovingNode = tr.doc.resolve(startPos);
      var maybeNode = resolvedMovingNode.nodeAfter;
      tr.setMeta('scrollIntoView', false);
      api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 || _api$analytics.actions.attachAnalyticsEvent({
        eventType: EVENT_TYPE.UI,
        action: ACTION.CLICKED,
        actionSubject: ACTION_SUBJECT.BUTTON,
        actionSubjectId: ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
        attributes: {
          nodeDepth: resolvedMovingNode.depth,
          nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || ''
        }
      })(tr);
      return tr;
    });
    view.focus();
  }, [isMultiSelect, api === null || api === void 0 || (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions, api === null || api === void 0 ? void 0 : api.blockControls.sharedState, api === null || api === void 0 || (_api$blockControls3 = api.blockControls) === null || _api$blockControls3 === void 0 ? void 0 : _api$blockControls3.commands, api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, view, dragHandleSelected, getPos, isTopLevelNode, nodeType, anchorName]);

  // TODO: ED-26959 - This needs to be investigated further. Drag preview generation is not always working
  // as expected with a node selection. This workaround sets the selection to the node on mouseDown,
  // but ensures the preview is generated correctly.
  var handleMouseDown = useCallback(function () {
    if (editorExperiment('advanced_layouts', true)) {
      var _buttonRef$current;
      // prevent native drag and drop.
      (_buttonRef$current = buttonRef.current) === null || _buttonRef$current === void 0 || _buttonRef$current.focus();
      if (!isLayoutColumn) {
        return undefined;
      }
    }
  }, [isLayoutColumn]);
  var handleKeyDown = useCallback(function (e) {
    if (fg('platform_editor_element_drag_and_drop_ed_23873')) {
      // allow user to use spacebar to select the node
      if (!e.repeat && e.key === ' ') {
        var _api$core3;
        var startPos = getPos();
        api === null || api === void 0 || (_api$core3 = api.core) === null || _api$core3 === void 0 || _api$core3.actions.execute(function (_ref3) {
          var tr = _ref3.tr;
          if (startPos === undefined) {
            return tr;
          }
          var node = tr.doc.nodeAt(startPos);
          if (!node) {
            return tr;
          }
          var $startPos = tr.doc.resolve(startPos + node.nodeSize);
          var selection = new TextSelection($startPos);
          tr.setSelection(selection);
          !isMultiSelect && tr.setMeta(key, {
            pos: startPos
          });
          return tr;
        });
      } else if (![e.altKey, e.ctrlKey, e.shiftKey].some(function (pressed) {
        return pressed;
      })) {
        // If not trying to press shortcut keys,
        // return focus to editor to resume editing from caret position
        view.focus();
      }
    }
  }, [getPos, api === null || api === void 0 || (_api$core4 = api.core) === null || _api$core4 === void 0 ? void 0 : _api$core4.actions, isMultiSelect, view]);
  useEffect(function () {
    var element = buttonRef.current;
    if (!element) {
      return;
    }
    return draggable({
      element: element,
      getInitialData: function getInitialData() {
        return {
          type: 'element',
          start: start
        };
      },
      onGenerateDragPreview: function onGenerateDragPreview(_ref4) {
        var _api$blockControls$sh2;
        var nativeSetDragImage = _ref4.nativeSetDragImage;
        if (isMultiSelect) {
          var _api$core5;
          api === null || api === void 0 || (_api$core5 = api.core) === null || _api$core5 === void 0 || _api$core5.actions.execute(function (_ref5) {
            var tr = _ref5.tr;
            var handlePos = getPos();
            if (typeof handlePos !== 'number') {
              return tr;
            }
            var oldHandlePosCheck = handlePos >= tr.selection.$from.start() - 1 && handlePos <= tr.selection.to;
            var newHandlePosCheck = isHandleCorrelatedToSelection(view.state, tr.selection, handlePos);
            if (!tr.selection.empty && (fg('platform_editor_elements_dnd_multi_select_patch_1') ? newHandlePosCheck : oldHandlePosCheck)) {
              var _api$blockControls4;
              api === null || api === void 0 || (_api$blockControls4 = api.blockControls) === null || _api$blockControls4 === void 0 || _api$blockControls4.commands.setMultiSelectPositions()({
                tr: tr
              });
            } else if (fg('platform_editor_elements_dnd_select_node_on_drag')) {
              tr = selectNode(tr, handlePos, nodeType);
            }
            return tr;
          });
        }
        var startPos = getPos();
        var state = view.state;
        var doc = state.doc,
          selection = state.selection;
        var sliceFrom = selection.from;
        var sliceTo = selection.to;
        var mSelect = api === null || api === void 0 || (_api$blockControls$sh2 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh2 === void 0 ? void 0 : _api$blockControls$sh2.multiSelectDnD;
        if (mSelect) {
          var anchor = mSelect.anchor,
            head = mSelect.head;
          sliceFrom = Math.min(anchor, head);
          sliceTo = Math.max(anchor, head);
        }
        var expandedSlice = doc.slice(sliceFrom, sliceTo);
        var isDraggingMultiLine = isMultiSelect && startPos !== undefined && startPos >= sliceFrom && startPos < sliceTo && expandedSlice.content.childCount > 1;
        setCustomNativeDragPreview({
          getOffset: function getOffset() {
            if (!isDraggingMultiLine) {
              return {
                x: 0,
                y: 0
              };
            } else {
              // Calculate the offset of the preview container,
              // So when drag multiple nodes, the preview align with the position of the selected nodes
              var domAtPos = view.domAtPos.bind(view);
              var domElementsHeightBeforeHandle = 0;
              var nodesStartPos = [];
              var nodesEndPos = [];
              var activeNodeMarginTop = 0;
              for (var i = 0; i < expandedSlice.content.childCount; i++) {
                if (i === 0) {
                  var _expandedSlice$conten;
                  nodesStartPos[i] = sliceFrom;
                  nodesEndPos[i] = sliceFrom + (((_expandedSlice$conten = expandedSlice.content.maybeChild(i)) === null || _expandedSlice$conten === void 0 ? void 0 : _expandedSlice$conten.nodeSize) || 0);
                } else {
                  var _expandedSlice$conten2;
                  nodesStartPos[i] = nodesEndPos[i - 1];
                  nodesEndPos[i] = nodesStartPos[i] + (((_expandedSlice$conten2 = expandedSlice.content.maybeChild(i)) === null || _expandedSlice$conten2 === void 0 ? void 0 : _expandedSlice$conten2.nodeSize) || 0);
                }

                // when the node is before the handle, calculate the height of the node
                if (nodesEndPos[i] <= startPos) {
                  // eslint-disable-next-line @atlaskit/editor/no-as-casting
                  var currentNodeElement = findDomRefAtPos(nodesStartPos[i], domAtPos);
                  var maybeCurrentNode = expandedSlice.content.maybeChild(i);
                  var currentNodeSpacing = maybeCurrentNode ? getNodeMargins(maybeCurrentNode).top + getNodeMargins(maybeCurrentNode).bottom : 0;
                  domElementsHeightBeforeHandle = domElementsHeightBeforeHandle + currentNodeElement.offsetHeight + currentNodeSpacing;
                } else {
                  // when the node is after the handle, calculate the top margin of the active node
                  var maybeNextNode = expandedSlice.content.maybeChild(i);
                  activeNodeMarginTop = maybeNextNode ? getNodeMargins(maybeNextNode).top : 0;
                  break;
                }
              }
              return {
                x: 0,
                y: domElementsHeightBeforeHandle + activeNodeMarginTop
              };
            }
          },
          render: function render(_ref6) {
            var container = _ref6.container;
            var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
            if (!dom) {
              return;
            }
            if (!isDraggingMultiLine) {
              return dragPreview(container, {
                dom: dom,
                nodeType: nodeType
              });
            } else {
              var domAtPos = view.domAtPos.bind(view);
              var previewContent = [];
              expandedSlice.content.descendants(function (node, pos, _parent, _index) {
                // Get the dom element of the node
                //eslint-disable-next-line @atlaskit/editor/no-as-casting
                var nodeDomElement = findDomRefAtPos(sliceFrom + pos, domAtPos);
                var currentNodeSpacing = getNodeSpacingForPreview(node);
                previewContent.push({
                  dom: nodeDomElement,
                  nodeType: node.type.name,
                  nodeSpacing: currentNodeSpacing
                });
                return false; // Only iterate through the first level of nodes
              });
              return dragPreview(container, previewContent);
            }
          },
          nativeSetDragImage: nativeSetDragImage
        });
      },
      onDragStart: function onDragStart() {
        var _api$core6;
        if (start === undefined) {
          return;
        }
        api === null || api === void 0 || (_api$core6 = api.core) === null || _api$core6 === void 0 || _api$core6.actions.execute(function (_ref7) {
          var _api$blockControls$sh3, _api$blockControls5, _api$analytics3;
          var tr = _ref7.tr;
          var nodeTypes, hasSelectedMultipleNodes;
          var resolvedMovingNode = tr.doc.resolve(start);
          var maybeNode = resolvedMovingNode.nodeAfter;
          var mSelect = api === null || api === void 0 || (_api$blockControls$sh3 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh3 === void 0 ? void 0 : _api$blockControls$sh3.multiSelectDnD;
          if (mSelect) {
            var attributes = getMultiSelectAnalyticsAttributes(tr, mSelect.anchor, mSelect.head);
            nodeTypes = attributes.nodeTypes;
            hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
          } else {
            nodeTypes = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name;
            hasSelectedMultipleNodes = false;
          }
          api === null || api === void 0 || (_api$blockControls5 = api.blockControls) === null || _api$blockControls5 === void 0 || _api$blockControls5.commands.setNodeDragged(getPos, anchorName, nodeType)({
            tr: tr
          });
          tr.setMeta('scrollIntoView', false);
          api === null || api === void 0 || (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 || _api$analytics3.actions.attachAnalyticsEvent({
            eventType: EVENT_TYPE.UI,
            action: ACTION.DRAGGED,
            actionSubject: ACTION_SUBJECT.ELEMENT,
            actionSubjectId: ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
            attributes: _objectSpread({
              nodeDepth: resolvedMovingNode.depth,
              nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || ''
            }, isMultiSelect && {
              nodeTypes: nodeTypes,
              hasSelectedMultipleNodes: hasSelectedMultipleNodes
            })
          })(tr);
          return tr;
        });
        view.focus();
      }
    });
  }, [anchorName, api, getPos, isMultiSelect, nodeType, start, view]);
  var macroInteractionUpdates = featureFlagsState === null || featureFlagsState === void 0 ? void 0 : featureFlagsState.macroInteractionUpdates;
  var calculatePosition = useCallback(function () {
    var pos = getPos();
    var $pos = pos && view.state.doc.resolve(pos);
    var parentPos = $pos && $pos.depth ? $pos.before() : undefined;
    var node = parentPos !== undefined ? view.state.doc.nodeAt(parentPos) : undefined;
    var parentNodeType = node === null || node === void 0 ? void 0 : node.type.name;
    var supportsAnchor = CSS.supports('top', "anchor(".concat(anchorName, " start)")) && CSS.supports('left', "anchor(".concat(anchorName, " start)"));
    var safeAnchorName = editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_2') ? refreshAnchorName({
      getPos: getPos,
      view: view,
      anchorName: anchorName
    }) : anchorName;
    var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(safeAnchorName, "\"]"));
    var hasResizer = nodeType === 'table' || nodeType === 'mediaSingle';
    var isExtension = nodeType === 'extension' || nodeType === 'bodiedExtension' || nodeType === 'multiBodiedExtension' && fg('platform_editor_multi_body_extension_extensibility');
    var isBlockCard = nodeType === 'blockCard' && !!blockCardWidth;
    var isEmbedCard = nodeType === 'embedCard';
    var isMacroInteractionUpdates = macroInteractionUpdates && isExtension;
    var innerContainer = null;
    if (dom) {
      if (isEmbedCard) {
        innerContainer = dom.querySelector('.rich-media-item');
      } else if (hasResizer) {
        innerContainer = dom.querySelector('.resizer-item');
      } else if (isExtension) {
        innerContainer = dom.querySelector('.extension-container[data-layout]');
      } else if (isBlockCard) {
        //specific to datasource blockCard
        innerContainer = dom.querySelector('.datasourceView-content-inner-wrap');
      }
    }
    var isEdgeCase = (hasResizer || isExtension || isEmbedCard || isBlockCard) && innerContainer;
    var isSticky = shouldBeSticky(nodeType);
    if (supportsAnchor) {
      var bottom = editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_sticky_controls') ? getControlBottomCSSValue(safeAnchorName, isSticky, isTopLevelNode, isLayoutColumn) : {};
      return _objectSpread({
        left: isEdgeCase ? "calc(anchor(".concat(safeAnchorName, " start) + ").concat(getLeftPosition(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType), ")") : editorExperiment('advanced_layouts', true) && isLayoutColumn ? "calc((anchor(".concat(safeAnchorName, " right) + anchor(").concat(safeAnchorName, " left))/2 - ").concat(DRAG_HANDLE_HEIGHT / 2, "px)") : "calc(anchor(".concat(safeAnchorName, " start) - ").concat(DRAG_HANDLE_WIDTH, "px - ").concat(dragHandleGap(nodeType, parentNodeType), "px)"),
        top: editorExperiment('advanced_layouts', true) && isLayoutColumn ? "calc(anchor(".concat(safeAnchorName, " top) - ").concat(DRAG_HANDLE_WIDTH, "px)") : "calc(anchor(".concat(safeAnchorName, " start) + ").concat(topPositionAdjustment(nodeType), "px)")
      }, bottom);
    }
    var height = editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_sticky_controls') ? getControlHeightCSSValue(getNodeHeight(dom, safeAnchorName, anchorRectCache) || 0, isSticky, isTopLevelNode, "".concat(DRAG_HANDLE_HEIGHT), isLayoutColumn) : {};
    return _objectSpread({
      left: isEdgeCase ? "calc(".concat((dom === null || dom === void 0 ? void 0 : dom.offsetLeft) || 0, "px + ").concat(getLeftPosition(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType), ")") : getLeftPosition(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType),
      top: getTopPosition(dom, nodeType)
    }, height);
  }, [anchorName, getPos, view, nodeType, blockCardWidth, macroInteractionUpdates, anchorRectCache, isTopLevelNode, isLayoutColumn]);
  var _useState7 = useState({
      display: 'none'
    }),
    _useState8 = _slicedToArray(_useState7, 2),
    positionStyles = _useState8[0],
    setPositionStyles = _useState8[1];
  useEffect(function () {
    var cleanUpTransitionListener;
    if (nodeType === 'extension' || nodeType === 'embedCard') {
      var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
      if (!dom) {
        return;
      }
      cleanUpTransitionListener = bind(dom, {
        type: 'transitionend',
        listener: function listener() {
          setPositionStyles(calculatePosition());
        }
      });
    }
    var calcPos = requestAnimationFrame(function () {
      setPositionStyles(calculatePosition());
    });
    return function () {
      var _cleanUpTransitionLis;
      cancelAnimationFrame(calcPos);
      (_cleanUpTransitionLis = cleanUpTransitionListener) === null || _cleanUpTransitionLis === void 0 || _cleanUpTransitionLis();
    };
  }, [calculatePosition, view.dom, anchorName, nodeType]);
  useEffect(function () {
    if (handleOptions !== null && handleOptions !== void 0 && handleOptions.isFocused && buttonRef.current && fg('platform_editor_element_drag_and_drop_ed_23873')) {
      var id = requestAnimationFrame(function () {
        var _buttonRef$current2;
        (_buttonRef$current2 = buttonRef.current) === null || _buttonRef$current2 === void 0 || _buttonRef$current2.focus();
      });
      return function () {
        cancelAnimationFrame(id);
        view.focus();
      };
    }
  }, [buttonRef, handleOptions === null || handleOptions === void 0 ? void 0 : handleOptions.isFocused, view]);
  useEffect(function () {
    if (!isMultiSelect || typeof start !== 'number' || !selection) {
      return;
    }
    setDragHandleSelected(isHandleCorrelatedToSelection(view.state, selection, start));
  }, [start, selection, view.state, isMultiSelect]);
  useEffect(function () {
    var _api$blockControls$sh4;
    if (!isMultiSelect || isShiftDown === undefined || view.state.selection.empty || !fg('platform_editor_elements_dnd_shift_click_select')) {
      return;
    }
    var mSelect = api === null || api === void 0 || (_api$blockControls$sh4 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh4 === void 0 ? void 0 : _api$blockControls$sh4.multiSelectDnD;
    var $anchor = (mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) !== undefined ? view.state.doc.resolve(mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) : view.state.selection.$anchor;
    if (isShiftDown && (!isTopLevelNode || isTopLevelNode && $anchor.depth > DRAG_HANDLE_MAX_SHIFT_CLICK_DEPTH)) {
      setDragHandleDisabled(true);
    } else {
      setDragHandleDisabled(false);
    }
  }, [api === null || api === void 0 ? void 0 : api.blockControls.sharedState, isMultiSelect, isShiftDown, isTopLevelNode, view.state.doc, view.state.selection]);
  var helpDescriptors = isTopLevelNode ? [{
    description: formatMessage(blockControlsMessages.dragToMove)
  }, {
    description: formatMessage(blockControlsMessages.moveUp),
    keymap: dragToMoveUp
  }, {
    description: formatMessage(blockControlsMessages.moveDown),
    keymap: dragToMoveDown
  }, {
    description: formatMessage(blockControlsMessages.moveLeft),
    keymap: dragToMoveLeft
  }, {
    description: formatMessage(blockControlsMessages.moveRight),
    keymap: dragToMoveRight
  }] : [{
    description: formatMessage(blockControlsMessages.dragToMove)
  }, {
    description: formatMessage(blockControlsMessages.moveUp),
    keymap: dragToMoveUp
  }, {
    description: formatMessage(blockControlsMessages.moveDown),
    keymap: dragToMoveDown
  }];
  var isParentNodeOfTypeLayout;
  if (!isTopLevelNode) {
    var pos = getPos();
    if (typeof pos === 'number') {
      var _$pos$parent;
      var $pos = view.state.doc.resolve(pos);
      isParentNodeOfTypeLayout = ($pos === null || $pos === void 0 || (_$pos$parent = $pos.parent) === null || _$pos$parent === void 0 ? void 0 : _$pos$parent.type.name) === 'layoutColumn';
    }
    if (isParentNodeOfTypeLayout) {
      helpDescriptors = [].concat(_toConsumableArray(helpDescriptors), [{
        description: formatMessage(blockControlsMessages.moveLeft),
        keymap: dragToMoveLeft
      }, {
        description: formatMessage(blockControlsMessages.moveRight),
        keymap: dragToMoveRight
      }]);
    }
  }

  // When advanced layout is on, layout column drag handle show only show 'Drag to move', no shortcuts
  if (editorExperiment('advanced_layouts', true) && nodeType === 'layoutColumn') {
    helpDescriptors = [{
      description: formatMessage(blockControlsMessages.dragToRearrange)
    }, {
      description: formatMessage(blockControlsMessages.moveUp),
      keymap: dragToMoveUp
    }, {
      description: formatMessage(blockControlsMessages.moveDown),
      keymap: dragToMoveDown
    }, {
      description: formatMessage(blockControlsMessages.moveLeft),
      keymap: dragToMoveLeft
    }, {
      description: formatMessage(blockControlsMessages.moveRight),
      keymap: dragToMoveRight
    }];
  }
  if (editorExperiment('platform_editor_controls', 'variant1')) {
    helpDescriptors = [{
      description: formatMessage(blockControlsMessages.dragToMove)
    }];
  }
  var message = helpDescriptors.map(function (descriptor) {
    return descriptor.keymap ? [descriptor.description, getAriaKeyshortcuts(descriptor.keymap)] : [descriptor.description];
  }).join('. ');
  var handleOnDrop = function handleOnDrop(event) {
    editorExperiment('platform_editor_element_drag_and_drop_multiselect', true) && event.stopPropagation();
  };
  var renderButton = function renderButton() {
    return (
      // eslint-disable-next-line @atlaskit/design-system/no-html-button
      jsx("button", {
        type: "button",
        css: [editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_sticky_controls') ? dragHandleButtonStyles : dragHandleButtonStylesOld, editorExperiment('platform_editor_controls', 'variant1') && dragHandleColor,
        // ED-26266: Fixed the drag handle highlight when selecting multiple line in Firefox
        // See https://product-fabric.atlassian.net/browse/ED-26266
        browser.gecko && fg('platform_editor_dnd_handle_highlight_fix_firefox') && dragHandleMultiLineSelectionFixFirefox, editorExperiment('advanced_layouts', true) && isLayoutColumn && layoutColumnDragHandleStyles, dragHandleSelected && (!fg('platform_editor_no_selection_until_interaction') || hasHadInteraction) && selectedStyles],
        ref: buttonRef
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
        ,
        style: !(editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_sticky_controls')) && positionStyles || {},
        onClick: handleOnClick,
        onMouseDown: handleMouseDown,
        onKeyDown: handleKeyDown
        // eslint-disable-next-line @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop
        ,
        onDrop: handleOnDrop,
        disabled: dragHandleDisabled,
        "data-editor-block-ctrl-drag-handle": true,
        "data-testid": "block-ctrl-drag-handle"
      }, jsx(Box, {
        xcss: iconWrapperStyles
        // eslint-disable-next-line @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop
        ,
        onDragStart: handleIconDragStart
      }, jsx(DragHandleVerticalIcon, {
        spacing: "spacious",
        label: "",
        LEGACY_fallbackIcon: DragHandlerIcon,
        LEGACY_size: "medium"
      })))
    );
  };
  var stickyWithTooltip = function stickyWithTooltip() {
    return jsx(Box
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    , {
      style: positionStyles,
      xcss: [dragHandleContainerStyles],
      as: "span",
      testId: "block-ctrl-drag-handle-container"
    }, jsx("span", {
      css: [tooltipContainerStyles, shouldMaskNodeControls(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithMask, !shouldMaskNodeControls(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithoutMask]
    }, jsx(Tooltip, {
      content: jsx(TooltipContentWithMultipleShortcuts, {
        helpDescriptors: helpDescriptors
      }),
      ignoreTooltipPointerEvents: true,
      position: 'top',
      onShow: function onShow() {
        var _api$accessibilityUti;
        api === null || api === void 0 || (_api$accessibilityUti = api.accessibilityUtils) === null || _api$accessibilityUti === void 0 || _api$accessibilityUti.actions.ariaNotify(message, {
          priority: 'important'
        });
      }
    }, jsx("span", {
      css: [shouldMaskNodeControls(nodeType, isTopLevelNode) && buttonWrapperStyles]
    }, renderButton()))));
  };
  var stickyWithoutTooltip = function stickyWithoutTooltip() {
    return jsx(Box
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    , {
      style: positionStyles,
      xcss: [dragHandleContainerStyles],
      as: "span",
      testId: "block-ctrl-drag-handle-container"
    }, jsx("span", {
      css: [tooltipContainerStyles, shouldMaskNodeControls(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithMask, !shouldMaskNodeControls(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithoutMask]
    }, jsx("span", {
      css: [shouldMaskNodeControls(nodeType, isTopLevelNode) && buttonWrapperStyles]
    }, renderButton())));
  };
  var buttonWithTooltip = function buttonWithTooltip() {
    return jsx(Tooltip, {
      content: jsx(TooltipContentWithMultipleShortcuts, {
        helpDescriptors: helpDescriptors
      }),
      ignoreTooltipPointerEvents: true,
      onShow: function onShow() {
        var _api$accessibilityUti2;
        api === null || api === void 0 || (_api$accessibilityUti2 = api.accessibilityUtils) === null || _api$accessibilityUti2 === void 0 || _api$accessibilityUti2.actions.ariaNotify(message, {
          priority: 'important'
        });
      }
    }, renderButton());
  };
  var isTooltip = !dragHandleDisabled && fg('platform_editor_element_drag_and_drop_ed_23873');
  var stickyRender = isTooltip ? stickyWithTooltip() : stickyWithoutTooltip();
  var render = isTooltip ? buttonWithTooltip() : renderButton();
  return editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_sticky_controls') ? stickyRender : render;
};
export var DragHandleWithVisibility = function DragHandleWithVisibility(_ref8) {
  var view = _ref8.view,
    api = _ref8.api,
    formatMessage = _ref8.formatMessage,
    getPos = _ref8.getPos,
    anchorName = _ref8.anchorName,
    nodeType = _ref8.nodeType,
    anchorRectCache = _ref8.anchorRectCache;
  return jsx(VisibilityContainer, {
    api: api
  }, jsx(DragHandle, {
    view: view,
    api: api,
    formatMessage: formatMessage,
    getPos: getPos,
    anchorName: anchorName,
    nodeType: nodeType,
    anchorRectCache: anchorRectCache
  }));
};