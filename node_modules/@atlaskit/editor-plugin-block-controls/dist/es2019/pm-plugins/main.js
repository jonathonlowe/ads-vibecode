import rafSchedule from 'raf-schd';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { browser } from '@atlaskit/editor-common/browser';
import { isMeasuring, startMeasure, stopMeasure } from '@atlaskit/editor-common/performance-measures';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { isEmptyDocument } from '@atlaskit/editor-common/utils';
import { NodeSelection, PluginKey, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { autoScrollForElements } from '@atlaskit/pragmatic-drag-and-drop-auto-scroll/element';
import { combine } from '@atlaskit/pragmatic-drag-and-drop/combine';
import { monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { BLOCK_MENU_ENABLED } from '../ui/consts';
import { findNodeDecs, nodeDecorations } from './decorations-anchor';
import { dragHandleDecoration, emptyParagraphNodeDecorations, findHandleDec } from './decorations-drag-handle';
import { dropTargetDecorations, findDropTargetDecs } from './decorations-drop-target';
import { findQuickInsertInsertButtonDecoration, quickInsertButtonDecoration } from './decorations-quick-insert-button';
import { handleMouseDown } from './handle-mouse-down';
import { handleMouseOver } from './handle-mouse-over';
import { boundKeydownHandler } from './keymap';
import { defaultActiveAnchorTracker } from './utils/active-anchor-tracker';
import { getMultiSelectAnalyticsAttributes } from './utils/analytics';
import { AnchorRectCache, isAnchorSupported } from './utils/anchor-utils';
import { selectNode } from './utils/getSelection';
import { getSelectedSlicePosition } from './utils/selection';
import { getTrMetadata } from './utils/transactions';
export const key = new PluginKey('blockControls');
const EDITOR_BLOCKS_DRAG_INIT = 'Editor Blocks Drag Initialization Time';
const isHTMLElement = element => {
  return element instanceof HTMLElement;
};
const destroyFn = (api, editorView) => {
  const scrollable = document.querySelector('.fabric-editor-popup-scroll-parent');
  const cleanupFn = [];
  if (scrollable) {
    cleanupFn.push(autoScrollForElements({
      element: scrollable
    }));
  }
  cleanupFn.push(monitorForElements({
    canMonitor: ({
      source
    }) => source.data.type === 'element',
    onDrag: () => {
      if (isMeasuring(EDITOR_BLOCKS_DRAG_INIT)) {
        stopMeasure(EDITOR_BLOCKS_DRAG_INIT, (duration, startTime) => {
          var _api$analytics;
          const {
            state
          } = editorView;
          api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions.fireAnalyticsEvent({
            action: ACTION.BLOCKS_DRAG_INIT,
            actionSubject: ACTION_SUBJECT.EDITOR,
            eventType: EVENT_TYPE.OPERATIONAL,
            attributes: {
              duration,
              startTime,
              nodesCount: state.doc.nodeSize
            }
          });
        });
      }
    },
    onDragStart: () => {
      if (isHTMLElement(scrollable)) {
        scrollable.style.setProperty('scroll-behavior', 'unset');
      }
    },
    onDrop: ({
      location,
      source
    }) => {
      var _api$core;
      if (isHTMLElement(scrollable)) {
        scrollable.style.setProperty('scroll-behavior', null);
      }
      if (!api) {
        return;
      }
      (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(({
        tr
      }) => {
        const isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);
        if (isMultiSelect) {
          var _api$blockControls, _api$selection;
          const {
            multiSelectDnD
          } = ((_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 ? void 0 : _api$blockControls.sharedState.currentState()) || {};
          // Restore the users initial Editor selection when the drop completes
          if (multiSelectDnD) {
            // If the TextSelection between the drag start and end has changed, the document has changed, and we should not reapply the last selection
            const expandedSelectionUnchanged = multiSelectDnD.textAnchor === tr.selection.anchor && multiSelectDnD.textHead === tr.selection.head;
            if (expandedSelectionUnchanged) {
              const $anchor = tr.doc.resolve(multiSelectDnD.userAnchor);
              const $head = tr.doc.resolve(multiSelectDnD.userHead);
              if ($head.node() === $anchor.node()) {
                const $from = $anchor.min($head);
                selectNode(tr, $from.pos, $from.node().type.name);
              } else {
                tr.setSelection(TextSelection.create(tr.doc, multiSelectDnD.userAnchor, multiSelectDnD.userHead));
              }
            }
          }
          (_api$selection = api.selection) === null || _api$selection === void 0 ? void 0 : _api$selection.commands.clearManualSelection()({
            tr
          });
        }
        const {
          start
        } = source.data;
        // if no drop targets are rendered, assume that drop is invalid
        const lastDragCancelled = location.current.dropTargets.length === 0;
        if (lastDragCancelled) {
          var _api$analytics2;
          let nodeTypes, hasSelectedMultipleNodes;
          if (isMultiSelect) {
            const position = getSelectedSlicePosition(start, tr, api);
            const attributes = getMultiSelectAnalyticsAttributes(tr, position.from, position.to);
            nodeTypes = attributes.nodeTypes;
            hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
          }
          const resolvedMovingNode = tr.doc.resolve(start);
          const maybeNode = resolvedMovingNode.nodeAfter;
          (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions.attachAnalyticsEvent({
            eventType: EVENT_TYPE.UI,
            action: ACTION.CANCELLED,
            actionSubject: ACTION_SUBJECT.DRAG,
            actionSubjectId: ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
            attributes: {
              nodeDepth: resolvedMovingNode.depth,
              nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || '',
              ...(isMultiSelect && {
                nodeTypes,
                hasSelectedMultipleNodes
              })
            }
          })(tr);
        }
        if (fg('platform_editor_ease_of_use_metrics')) {
          var _api$metrics;
          (_api$metrics = api.metrics) === null || _api$metrics === void 0 ? void 0 : _api$metrics.commands.startActiveSessionTimer()({
            tr
          });
        }
        if (fg('platform_editor_user_intent_plugin')) {
          var _api$userIntent;
          (_api$userIntent = api.userIntent) === null || _api$userIntent === void 0 ? void 0 : _api$userIntent.commands.setCurrentUserIntent('default')({
            tr
          });
        }
        return tr.setMeta(key, {
          ...tr.getMeta(key),
          isDragging: false,
          isPMDragging: false,
          lastDragCancelled
        });
      });
    }
  }));
  return combine(...cleanupFn);
};
const initialState = {
  decorations: DecorationSet.empty,
  activeNode: undefined,
  isDragging: false,
  isMenuOpen: false,
  editorHeight: 0,
  editorWidthLeft: 0,
  editorWidthRight: 0,
  isResizerResizing: false,
  isDocSizeLimitEnabled: null,
  isPMDragging: false,
  multiSelectDnD: undefined,
  lastDragCancelled: false,
  isSelectedViaDragHandle: false
};
export const getDecorations = state => {
  var _key$getState;
  return (_key$getState = key.getState(state)) === null || _key$getState === void 0 ? void 0 : _key$getState.decorations;
};
const getDecorationAtPos = (decorations, pos, to) => {
  // Find the newly minted node decs that touch the active node
  const findNewNodeDecs = findNodeDecs(decorations, pos - 1, to);

  // Find the specific dec that the active node corresponds to
  const nodeDecsAtActivePos = findNewNodeDecs.filter(dec => (dec === null || dec === void 0 ? void 0 : dec.from) === pos);

  // If multiple decorations at the active node pos, we want the last one
  const nodeDecAtActivePos = nodeDecsAtActivePos.pop();
  return nodeDecAtActivePos;
};
export const apply = (api, formatMessage, tr, currentState, newState, flags, nodeViewPortalProviderAPI, anchorRectCache) => {
  var _meta$multiSelectDnD, _activeNode, _activeNode2, _meta$activeNode$hand, _activeNode3, _activeNode4, _meta$isDragging, _meta$isDragging2, _meta$toggleMenu, _meta$editorHeight, _meta$editorWidthLeft, _meta$editorWidthRigh, _meta$isPMDragging, _meta$isShiftDown, _meta$lastDragCancell;
  let {
    activeNode,
    decorations,
    isResizerResizing,
    multiSelectDnD
  } = currentState;
  const {
    editorHeight,
    editorWidthLeft,
    editorWidthRight,
    isDragging,
    isMenuOpen,
    menuTriggerBy,
    isPMDragging,
    isShiftDown,
    lastDragCancelled,
    isSelectedViaDragHandle
  } = currentState;
  let isActiveNodeDeleted = false;
  const {
    from,
    to,
    numReplaceSteps,
    isAllText,
    isReplacedWithSameSize
  } = getTrMetadata(tr);
  const meta = tr.getMeta(key);

  // When steps exist, remap existing decorations, activeNode and multi select positions
  if (tr.docChanged) {
    decorations = decorations.map(tr.mapping, tr.doc);

    // don't remap activeNode if it's being dragged
    if (editorExperiment('platform_editor_controls', 'control')) {
      if (activeNode) {
        const mappedPos = tr.mapping.mapResult(activeNode.pos);
        isActiveNodeDeleted = mappedPos.deleted;
        activeNode = {
          pos: mappedPos.pos,
          anchorName: activeNode.anchorName,
          nodeType: activeNode.nodeType
        };
      }
    } else {
      if (activeNode && (meta === null || meta === void 0 ? void 0 : meta.isDragging) !== true) {
        var _mappedRootPos$pos, _mappedRootPos;
        const mappedPos = tr.mapping.mapResult(activeNode.pos, -1);
        isActiveNodeDeleted = mappedPos.deletedAfter;
        // for editor controls, remap the rootPos as well
        let mappedRootPos;
        if (activeNode.rootPos !== undefined) {
          mappedRootPos = tr.mapping.mapResult(activeNode.rootPos, -1);
        }
        activeNode = {
          pos: mappedPos.pos,
          anchorName: activeNode.anchorName,
          nodeType: activeNode.nodeType,
          rootPos: (_mappedRootPos$pos = (_mappedRootPos = mappedRootPos) === null || _mappedRootPos === void 0 ? void 0 : _mappedRootPos.pos) !== null && _mappedRootPos$pos !== void 0 ? _mappedRootPos$pos : activeNode.rootPos,
          rootAnchorName: activeNode.rootAnchorName,
          rootNodeType: activeNode.rootNodeType
        };
      }
    }
    if (multiSelectDnD && flags.isMultiSelectEnabled) {
      multiSelectDnD.anchor = tr.mapping.map(multiSelectDnD.anchor);
      multiSelectDnD.head = tr.mapping.map(multiSelectDnD.head);
    }
  }
  const resizerMeta = tr.getMeta('is-resizer-resizing');
  isResizerResizing = resizerMeta !== null && resizerMeta !== void 0 ? resizerMeta : isResizerResizing;
  multiSelectDnD = (_meta$multiSelectDnD = meta === null || meta === void 0 ? void 0 : meta.multiSelectDnD) !== null && _meta$multiSelectDnD !== void 0 ? _meta$multiSelectDnD : multiSelectDnD;
  if (multiSelectDnD && flags.isMultiSelectEnabled) {
    multiSelectDnD = (meta === null || meta === void 0 ? void 0 : meta.isDragging) === false || tr.selection.empty ? undefined : multiSelectDnD;
  }
  const maybeNodeCountChanged = !isAllText && numReplaceSteps > 0;
  let latestActiveNode;
  if (fg('platform_editor_remove_drag_handle_fix')) {
    latestActiveNode = meta === null || meta === void 0 ? void 0 : meta.activeNode;
    if (!latestActiveNode && (!isActiveNodeDeleted || isReplacedWithSameSize)) {
      latestActiveNode = activeNode;
    }
  } else {
    var _meta$activeNode;
    latestActiveNode = (_meta$activeNode = meta === null || meta === void 0 ? void 0 : meta.activeNode) !== null && _meta$activeNode !== void 0 ? _meta$activeNode : activeNode;
  }

  // Re-create node decorations
  const isDecSetEmpty = decorations === DecorationSet.empty;
  const isNodeDecsMissing = isDecSetEmpty || maybeNodeCountChanged;
  const shouldRedrawNodeDecs = !isResizerResizing && (fg('platform_editor_advanced_layouts_redraw_on_drag') ? isNodeDecsMissing || (meta === null || meta === void 0 ? void 0 : meta.isDragging) : isNodeDecsMissing);
  let isActiveNodeModified = false;
  if (api && shouldRedrawNodeDecs) {
    const oldNodeDecs = findNodeDecs(decorations, from, to);
    decorations = decorations.remove(oldNodeDecs);
    const newNodeDecs = nodeDecorations(newState, isDecSetEmpty ? undefined : from, isDecSetEmpty ? undefined : to);
    decorations = decorations.add(newState.doc, newNodeDecs);
    if (editorExperiment('platform_editor_controls', 'control')) {
      if (latestActiveNode && !isActiveNodeDeleted) {
        // Find the newly minted node decs that touch the active node
        const findNewNodeDecs = findNodeDecs(decorations, latestActiveNode.pos - 1, to);

        // Find the specific dec that the active node corresponds to
        const nodeDecsAtActivePos = findNewNodeDecs.filter(dec => (dec === null || dec === void 0 ? void 0 : dec.from) === latestActiveNode.pos);

        // If multiple decorations at the active node pos, we want the last one
        const nodeDecAtActivePos = nodeDecsAtActivePos.pop();

        // Update the active node anchor-name and type for accurate positioning
        if (nodeDecAtActivePos) {
          isActiveNodeModified = true;
          latestActiveNode.anchorName = nodeDecAtActivePos.spec.anchorName;
          latestActiveNode.nodeType = nodeDecAtActivePos.spec.nodeType;
        }
      }
    } else {
      if (latestActiveNode && (!isActiveNodeDeleted || isReplacedWithSameSize)) {
        const nodeDecAtActivePos = getDecorationAtPos(decorations, latestActiveNode.pos, to);
        const rootNodeDecAtActivePos = getDecorationAtPos(decorations, latestActiveNode.rootPos, to);
        if (nodeDecAtActivePos || rootNodeDecAtActivePos) {
          isActiveNodeModified = true;
        }

        // Update the active node anchor-name and type for accurate positioning
        if (nodeDecAtActivePos) {
          latestActiveNode.anchorName = nodeDecAtActivePos.spec.anchorName;
          latestActiveNode.nodeType = nodeDecAtActivePos.spec.nodeType;
        }
        if (rootNodeDecAtActivePos) {
          latestActiveNode.rootAnchorName = rootNodeDecAtActivePos.spec.anchorName;
          latestActiveNode.rootNodeType = rootNodeDecAtActivePos.spec.nodeType;
        }
      }
    }
  }

  // Check if editor dimensions have changed
  const editorSizeChanged = (meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== editorHeight || (meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== editorWidthLeft || (meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== editorWidthRight;

  // Check if there's a new active node, and it differs from the last
  const activeNodeChanged = (meta === null || meta === void 0 ? void 0 : meta.activeNode) && ((meta === null || meta === void 0 ? void 0 : meta.activeNode.pos) !== ((_activeNode = activeNode) === null || _activeNode === void 0 ? void 0 : _activeNode.pos) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.anchorName) !== ((_activeNode2 = activeNode) === null || _activeNode2 === void 0 ? void 0 : _activeNode2.anchorName) || (meta === null || meta === void 0 ? void 0 : (_meta$activeNode$hand = meta.activeNode.handleOptions) === null || _meta$activeNode$hand === void 0 ? void 0 : _meta$activeNode$hand.isFocused));
  const rootActiveNodeChanged = (meta === null || meta === void 0 ? void 0 : meta.activeNode) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.rootPos) !== ((_activeNode3 = activeNode) === null || _activeNode3 === void 0 ? void 0 : _activeNode3.rootPos) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.rootAnchorName) !== ((_activeNode4 = activeNode) === null || _activeNode4 === void 0 ? void 0 : _activeNode4.rootAnchorName);

  // Some browsers don't support anchor positioning, meaning we need to replace the handle when nodes change
  const handleNeedsRedraw = shouldRedrawNodeDecs && !isAnchorSupported();

  // Create/recreate handle dec when the active node is missing/changes, or the editor viewport has changed (non-anchor pos workaround)
  const shouldRecreateHandle = latestActiveNode && (activeNodeChanged || isActiveNodeModified || editorSizeChanged || handleNeedsRedraw);
  const shouldRecreateQuickInsertButton = latestActiveNode && (rootActiveNodeChanged || isActiveNodeModified || editorSizeChanged || handleNeedsRedraw);
  let shouldRemoveHandle = false;
  if (fg('platform_editor_remove_drag_handle_fix')) {
    // If the active node is missing, we need to remove the handle
    shouldRemoveHandle = latestActiveNode ? isResizerResizing || isActiveNodeDeleted && !isReplacedWithSameSize || (meta === null || meta === void 0 ? void 0 : meta.nodeMoved) : true;
  } else {
    // Remove handle dec when explicitly hidden, a node is resizing, activeNode pos was deleted, or DnD moved a node
    shouldRemoveHandle = latestActiveNode && (isResizerResizing || isActiveNodeDeleted || (meta === null || meta === void 0 ? void 0 : meta.nodeMoved));
  }
  if (shouldRemoveHandle) {
    var _activeNode5, _activeNode6;
    const oldHandle = findHandleDec(decorations, (_activeNode5 = activeNode) === null || _activeNode5 === void 0 ? void 0 : _activeNode5.pos, (_activeNode6 = activeNode) === null || _activeNode6 === void 0 ? void 0 : _activeNode6.pos);
    decorations = decorations.remove(oldHandle);
    if (editorExperiment('platform_editor_controls', 'variant1')) {
      var _activeNode7, _activeNode8;
      const oldQuickInsertButton = findQuickInsertInsertButtonDecoration(decorations, (_activeNode7 = activeNode) === null || _activeNode7 === void 0 ? void 0 : _activeNode7.rootPos, (_activeNode8 = activeNode) === null || _activeNode8 === void 0 ? void 0 : _activeNode8.rootPos);
      decorations = decorations.remove(oldQuickInsertButton);
    }
  } else if (api) {
    var _latestActiveNode5;
    if (shouldRecreateHandle) {
      var _activeNode9, _activeNode10, _latestActiveNode, _latestActiveNode2, _latestActiveNode3, _latestActiveNode4;
      const oldHandle = findHandleDec(decorations, (_activeNode9 = activeNode) === null || _activeNode9 === void 0 ? void 0 : _activeNode9.pos, (_activeNode10 = activeNode) === null || _activeNode10 === void 0 ? void 0 : _activeNode10.pos);
      decorations = decorations.remove(oldHandle);
      const handleDec = dragHandleDecoration(api, formatMessage, (_latestActiveNode = latestActiveNode) === null || _latestActiveNode === void 0 ? void 0 : _latestActiveNode.pos, (_latestActiveNode2 = latestActiveNode) === null || _latestActiveNode2 === void 0 ? void 0 : _latestActiveNode2.anchorName, (_latestActiveNode3 = latestActiveNode) === null || _latestActiveNode3 === void 0 ? void 0 : _latestActiveNode3.nodeType, nodeViewPortalProviderAPI, (_latestActiveNode4 = latestActiveNode) === null || _latestActiveNode4 === void 0 ? void 0 : _latestActiveNode4.handleOptions, anchorRectCache);
      decorations = decorations.add(newState.doc, [handleDec]);
    }
    if (shouldRecreateQuickInsertButton && ((_latestActiveNode5 = latestActiveNode) === null || _latestActiveNode5 === void 0 ? void 0 : _latestActiveNode5.rootPos) !== undefined && editorExperiment('platform_editor_controls', 'variant1')) {
      var _activeNode11, _activeNode12, _latestActiveNode6, _latestActiveNode7, _latestActiveNode8, _latestActiveNode9, _latestActiveNode10;
      const oldQuickInsertButton = findQuickInsertInsertButtonDecoration(decorations, (_activeNode11 = activeNode) === null || _activeNode11 === void 0 ? void 0 : _activeNode11.rootPos, (_activeNode12 = activeNode) === null || _activeNode12 === void 0 ? void 0 : _activeNode12.rootPos);
      decorations = decorations.remove(oldQuickInsertButton);
      const quickInsertButton = quickInsertButtonDecoration(api, formatMessage, (_latestActiveNode6 = latestActiveNode) === null || _latestActiveNode6 === void 0 ? void 0 : _latestActiveNode6.rootPos, (_latestActiveNode7 = latestActiveNode) === null || _latestActiveNode7 === void 0 ? void 0 : _latestActiveNode7.anchorName, (_latestActiveNode8 = latestActiveNode) === null || _latestActiveNode8 === void 0 ? void 0 : _latestActiveNode8.nodeType, nodeViewPortalProviderAPI, (_latestActiveNode9 = latestActiveNode) === null || _latestActiveNode9 === void 0 ? void 0 : _latestActiveNode9.rootAnchorName, (_latestActiveNode10 = latestActiveNode) === null || _latestActiveNode10 === void 0 ? void 0 : _latestActiveNode10.rootNodeType, anchorRectCache);
      decorations = decorations.add(newState.doc, [quickInsertButton]);
    }
  }

  // Drop targets may be missing when the node count is being changed during a drag
  const isDropTargetsMissing = ((_meta$isDragging = meta === null || meta === void 0 ? void 0 : meta.isDragging) !== null && _meta$isDragging !== void 0 ? _meta$isDragging : isDragging) && maybeNodeCountChanged && !(meta !== null && meta !== void 0 && meta.nodeMoved);

  // Remove drop target decorations when dragging stops or they need to be redrawn
  if ((meta === null || meta === void 0 ? void 0 : meta.isDragging) === false || isDropTargetsMissing) {
    const dropTargetDecs = findDropTargetDecs(decorations);
    decorations = decorations.remove(dropTargetDecs);
  }

  // Add drop targets when dragging starts or some are missing
  if (api) {
    if (meta !== null && meta !== void 0 && meta.isDragging || isDropTargetsMissing) {
      const decs = dropTargetDecorations(newState, api, formatMessage, nodeViewPortalProviderAPI, latestActiveNode, anchorRectCache);
      decorations = decorations.add(newState.doc, decs);
    }
  }
  const isEmptyDoc = isEmptyDocument(newState.doc);
  if (isEmptyDoc) {
    const hasNodeDecoration = !!findNodeDecs(decorations).length;
    if (!hasNodeDecoration) {
      decorations = decorations.add(newState.doc, [emptyParagraphNodeDecorations()]);
    }
  }
  let newActiveNode;
  if (editorExperiment('platform_editor_controls', 'variant1')) {
    var _latestActiveNode11, _latestActiveNode12;
    // remove isEmptyDoc check and let decorations render and determine their own visibility
    newActiveNode = !(meta !== null && meta !== void 0 && meta.activeNode) && findHandleDec(decorations, (_latestActiveNode11 = latestActiveNode) === null || _latestActiveNode11 === void 0 ? void 0 : _latestActiveNode11.pos, (_latestActiveNode12 = latestActiveNode) === null || _latestActiveNode12 === void 0 ? void 0 : _latestActiveNode12.pos).length === 0 ? null : latestActiveNode;
  } else {
    var _latestActiveNode13, _latestActiveNode14;
    newActiveNode = isEmptyDoc || !(meta !== null && meta !== void 0 && meta.activeNode) && findHandleDec(decorations, (_latestActiveNode13 = latestActiveNode) === null || _latestActiveNode13 === void 0 ? void 0 : _latestActiveNode13.pos, (_latestActiveNode14 = latestActiveNode) === null || _latestActiveNode14 === void 0 ? void 0 : _latestActiveNode14.pos).length === 0 ? null : latestActiveNode;
  }
  let isMenuOpenNew = isMenuOpen;
  if (BLOCK_MENU_ENABLED && editorExperiment('platform_editor_controls', 'variant1')) {
    if (meta !== null && meta !== void 0 && meta.closeMenu) {
      isMenuOpenNew = false;
    } else if (meta !== null && meta !== void 0 && meta.toggleMenu) {
      const isSameAnchor = (meta === null || meta === void 0 ? void 0 : meta.toggleMenu.anchorName) === menuTriggerBy;
      isMenuOpenNew = menuTriggerBy === undefined || isSameAnchor || !isMenuOpen && !isSameAnchor ? !isMenuOpen : isMenuOpen;
    }
  } else if (meta !== null && meta !== void 0 && meta.toggleMenu) {
    isMenuOpenNew = !isMenuOpen;
  }
  const isSelectedViaDragHandleNew = (meta === null || meta === void 0 ? void 0 : meta.isSelectedViaDragHandle) !== undefined && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_5') ? meta === null || meta === void 0 ? void 0 : meta.isSelectedViaDragHandle : isSelectedViaDragHandle;
  return {
    decorations,
    activeNode: newActiveNode,
    isDragging: (_meta$isDragging2 = meta === null || meta === void 0 ? void 0 : meta.isDragging) !== null && _meta$isDragging2 !== void 0 ? _meta$isDragging2 : isDragging,
    isMenuOpen: isMenuOpenNew,
    menuTriggerBy: editorExperiment('platform_editor_controls', 'variant1') ? (meta === null || meta === void 0 ? void 0 : (_meta$toggleMenu = meta.toggleMenu) === null || _meta$toggleMenu === void 0 ? void 0 : _meta$toggleMenu.anchorName) || menuTriggerBy : undefined,
    editorHeight: (_meta$editorHeight = meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== null && _meta$editorHeight !== void 0 ? _meta$editorHeight : editorHeight,
    editorWidthLeft: (_meta$editorWidthLeft = meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== null && _meta$editorWidthLeft !== void 0 ? _meta$editorWidthLeft : editorWidthLeft,
    editorWidthRight: (_meta$editorWidthRigh = meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== null && _meta$editorWidthRigh !== void 0 ? _meta$editorWidthRigh : editorWidthRight,
    isResizerResizing: isResizerResizing,
    isDocSizeLimitEnabled: initialState.isDocSizeLimitEnabled,
    isPMDragging: (_meta$isPMDragging = meta === null || meta === void 0 ? void 0 : meta.isPMDragging) !== null && _meta$isPMDragging !== void 0 ? _meta$isPMDragging : isPMDragging,
    multiSelectDnD,
    isShiftDown: (_meta$isShiftDown = meta === null || meta === void 0 ? void 0 : meta.isShiftDown) !== null && _meta$isShiftDown !== void 0 ? _meta$isShiftDown : isShiftDown,
    lastDragCancelled: (_meta$lastDragCancell = meta === null || meta === void 0 ? void 0 : meta.lastDragCancelled) !== null && _meta$lastDragCancell !== void 0 ? _meta$lastDragCancell : lastDragCancelled,
    isSelectedViaDragHandle: isSelectedViaDragHandleNew
  };
};
export const createPlugin = (api, getIntl, nodeViewPortalProviderAPI) => {
  const {
    formatMessage
  } = getIntl();
  const isAdvancedLayoutEnabled = editorExperiment('advanced_layouts', true, {
    exposure: true
  });
  const isMultiSelectEnabled = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true, {
    exposure: true
  });
  const flags = {
    isMultiSelectEnabled
  };
  let anchorRectCache;
  if (!isAnchorSupported()) {
    anchorRectCache = new AnchorRectCache();
  }
  return new SafePlugin({
    key,
    state: {
      init() {
        return initialState;
      },
      apply: (tr, currentState, _, newState) => apply(api, formatMessage, tr, currentState, newState, flags, nodeViewPortalProviderAPI, anchorRectCache)
    },
    props: {
      decorations: state => {
        var _api$editorDisabled, _api$editorDisabled$s, _key$getState2;
        const isDisabled = api === null || api === void 0 ? void 0 : (_api$editorDisabled = api.editorDisabled) === null || _api$editorDisabled === void 0 ? void 0 : (_api$editorDisabled$s = _api$editorDisabled.sharedState.currentState()) === null || _api$editorDisabled$s === void 0 ? void 0 : _api$editorDisabled$s.editorDisabled;
        if (isDisabled) {
          return;
        }
        return (_key$getState2 = key.getState(state)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.decorations;
      },
      handleDOMEvents: {
        drop(view, event) {
          var _pluginState, _pluginState2, _pluginState3, _event$target, _event$target$closest;
          // Prevent native DnD from triggering if we are in drag
          const {
            dispatch,
            dragging,
            state
          } = view;
          const tr = state.tr;
          let pluginState = key.getState(state);
          const dndDragCancelled = (_pluginState = pluginState) === null || _pluginState === void 0 ? void 0 : _pluginState.lastDragCancelled;
          if ((_pluginState2 = pluginState) !== null && _pluginState2 !== void 0 && _pluginState2.isPMDragging || dndDragCancelled && isMultiSelectEnabled) {
            if (fg('platform_editor_ease_of_use_metrics')) {
              var _api$metrics2;
              api === null || api === void 0 ? void 0 : (_api$metrics2 = api.metrics) === null || _api$metrics2 === void 0 ? void 0 : _api$metrics2.commands.startActiveSessionTimer()({
                tr
              });
            }
            dispatch(tr.setMeta(key, {
              ...tr.getMeta(key),
              isPMDragging: false,
              lastDragCancelled: false
            }));
          }
          pluginState = key.getState(view.state);
          if (!(event.target instanceof HTMLElement) || !((_pluginState3 = pluginState) !== null && _pluginState3 !== void 0 && _pluginState3.activeNode)) {
            return false;
          }
          // Currently we can only drag one node at a time
          // so we only need to check first child
          const draggable = dragging === null || dragging === void 0 ? void 0 : dragging.slice.content.firstChild;
          if (dndDragCancelled && isMultiSelectEnabled || (draggable === null || draggable === void 0 ? void 0 : draggable.type.name) === 'layoutColumn') {
            // we prevent native DnD for layoutColumn to prevent single column layout.
            event.preventDefault();
            return false;
          }
          const nodeElement = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : (_event$target$closest = _event$target.closest) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.call(_event$target, '[data-drag-handler-anchor-name]');
          if (!nodeElement) {
            return false;
          }

          // TODO: ED-26959 - Review usage of posAtDOM here
          const domPos = Math.max(view.posAtDOM(nodeElement, 0) - 1, 0);
          const nodeTarget = state.doc.nodeAt(domPos);
          const isSameNode = !!(nodeTarget && draggable !== null && draggable !== void 0 && draggable.eq(nodeTarget));
          if (isSameNode) {
            event.preventDefault();
            return true;
          }
          return false;
        },
        dragenter(_view, event) {
          if (isAdvancedLayoutEnabled) {
            if (isHTMLElement(event.target)) {
              const closestParentElement = event.target.closest('[data-drag-handler-anchor-depth="0"]');
              if (closestParentElement) {
                const currentAnchor = closestParentElement.getAttribute('data-drag-handler-anchor-name');
                if (currentAnchor) {
                  defaultActiveAnchorTracker.emit(currentAnchor);
                }
              }
            }
          }
        },
        dragstart(view) {
          var _anchorRectCache;
          startMeasure(EDITOR_BLOCKS_DRAG_INIT);
          if (isAdvancedLayoutEnabled) {
            defaultActiveAnchorTracker.reset();
          }
          (_anchorRectCache = anchorRectCache) === null || _anchorRectCache === void 0 ? void 0 : _anchorRectCache.setEditorView(view);
          view.dispatch(view.state.tr.setMeta(key, {
            ...view.state.tr.getMeta(key),
            isPMDragging: true
          }));
        },
        dragend(view) {
          var _key$getState3;
          const {
            state,
            dispatch
          } = view;
          if ((_key$getState3 = key.getState(state)) !== null && _key$getState3 !== void 0 && _key$getState3.isPMDragging) {
            const tr = state.tr;
            tr.setMeta(key, {
              ...state.tr.getMeta(key),
              isPMDragging: false
            });
            if (fg('platform_editor_ease_of_use_metrics')) {
              var _api$metrics3;
              api === null || api === void 0 ? void 0 : (_api$metrics3 = api.metrics) === null || _api$metrics3 === void 0 ? void 0 : _api$metrics3.commands.startActiveSessionTimer()({
                tr
              });
            }
            dispatch(tr);
          }
        },
        mouseover: (view, event) => {
          handleMouseOver(view, event, api);
          return false;
        },
        mousedown: editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_2') ? handleMouseDown(api) : undefined,
        keydown(view, event) {
          if (isMultiSelectEnabled) {
            if (event.shiftKey && event.ctrlKey) {
              //prevent holding down key combo from firing repeatedly
              if (!event.repeat && boundKeydownHandler(api, formatMessage)(view, event)) {
                event.preventDefault();
                return true;
              }
            }

            // Command + Shift + ArrowUp to select was broken with the plugin enabled so this manually sets the selection
            const {
              selection,
              doc,
              tr
            } = view.state;
            const metaKey = browser.mac ? event.metaKey : event.ctrlKey;
            if (event.key === 'ArrowUp' && event.shiftKey && metaKey) {
              if (selection instanceof TextSelection || selection instanceof NodeSelection) {
                const newSelection = TextSelection.create(doc, selection.head, 1);
                view.dispatch(tr.setSelection(newSelection));
                return true;
              }
            }
            if ((event.key === 'Enter' || event.key === ' ') && event.target instanceof HTMLElement && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_5')) {
              const isDragHandle = event.target.closest('[data-editor-block-ctrl-drag-handle="true"]') !== null;
              api === null || api === void 0 ? void 0 : api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(isDragHandle));
            }
            if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowDown' || event.key === 'ArrowUp') && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_5')) {
              var _api$blockControls$sh;
              if (api !== null && api !== void 0 && (_api$blockControls$sh = api.blockControls.sharedState.currentState()) !== null && _api$blockControls$sh !== void 0 && _api$blockControls$sh.isSelectedViaDragHandle) {
                api === null || api === void 0 ? void 0 : api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(false));
              }
            }
            if (!event.repeat && event.shiftKey && fg('platform_editor_elements_dnd_shift_click_select')) {
              view.dispatch(view.state.tr.setMeta(key, {
                ...view.state.tr.getMeta(key),
                isShiftDown: true
              }));
            }
            return false;
          } else {
            // Command + Shift + ArrowUp to select was broken with the plugin enabled so this manually sets the selection
            const {
              selection,
              doc,
              tr
            } = view.state;
            const metaKey = browser.mac ? event.metaKey : event.ctrlKey;
            if (event.key === 'ArrowUp' && event.shiftKey && metaKey) {
              if (selection instanceof TextSelection || selection instanceof NodeSelection) {
                const newSelection = TextSelection.create(doc, selection.head, 1);
                view.dispatch(tr.setSelection(newSelection));
                return true;
              }
            }
            if (event.shiftKey && event.ctrlKey) {
              //prevent holding down key combo from firing repeatedly
              if (!event.repeat && boundKeydownHandler(api, formatMessage)(view, event)) {
                event.preventDefault();
                return true;
              }
            }
            if ((event.key === 'Enter' || event.key === ' ') && event.target instanceof HTMLElement && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_5')) {
              const isDragHandle = event.target.closest('[data-editor-block-ctrl-drag-handle="true"]') !== null;
              api === null || api === void 0 ? void 0 : api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(isDragHandle));
            }
            if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowDown' || event.key === 'ArrowUp') && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_5')) {
              var _api$blockControls$sh2;
              if (api !== null && api !== void 0 && (_api$blockControls$sh2 = api.blockControls.sharedState.currentState()) !== null && _api$blockControls$sh2 !== void 0 && _api$blockControls$sh2.isSelectedViaDragHandle) {
                api === null || api === void 0 ? void 0 : api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(false));
              }
            }
          }
        },
        keyup(view, event) {
          if (!event.repeat && event.key === 'Shift') {
            view.dispatch(view.state.tr.setMeta(key, {
              ...view.state.tr.getMeta(key),
              isShiftDown: false
            }));
          }
        }
      }
    },
    view: editorView => {
      const dom = editorView.dom;
      const editorContentArea = editorView.dom.closest('.fabric-editor-popup-scroll-parent');

      // Use ResizeObserver to observe resizer (scroll-parent typically grows when resizing) and editor width changes
      const resizeObserverWidth = new ResizeObserver(rafSchedule(entries => {
        const pluginState = key.getState(editorView.state);
        if (!(pluginState !== null && pluginState !== void 0 && pluginState.isDragging)) {
          const isResizerResizing = !!dom.querySelector('.is-resizing');
          const transaction = editorView.state.tr;
          if ((pluginState === null || pluginState === void 0 ? void 0 : pluginState.isResizerResizing) !== isResizerResizing) {
            transaction.setMeta('is-resizer-resizing', isResizerResizing);
          }
          if (!isResizerResizing) {
            const editorContentArea = entries[0].target;
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const editorWidthRight = editorContentArea.getBoundingClientRect().right;
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const editorWidthLeft = editorContentArea.getBoundingClientRect().left;
            transaction.setMeta(key, {
              ...transaction.getMeta(key),
              editorWidthLeft,
              editorWidthRight
            });
          }
          editorView.dispatch(transaction);
        }
      }));
      if (editorContentArea) {
        resizeObserverWidth.observe(editorContentArea);
      }

      // Start pragmatic monitors
      const pragmaticCleanup = destroyFn(api, editorView);
      return {
        destroy() {
          if (editorContentArea) {
            resizeObserverWidth.unobserve(editorContentArea);
          }
          pragmaticCleanup();
        }
      };
    }
  });
};