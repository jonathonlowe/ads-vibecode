import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
const isEmptyNestedParagraphOrHeading = target => {
  if (target instanceof HTMLHeadingElement || target instanceof HTMLParagraphElement) {
    var _target$parentElement;
    return !((_target$parentElement = target.parentElement) !== null && _target$parentElement !== void 0 && _target$parentElement.classList.contains('ProseMirror')) && target.textContent === '';
  }
  return false;
};
export const handleMouseOver = (view, event, api) => {
  var _api$blockControls, _target$classList;
  const {
    isDragging,
    activeNode
  } = (api === null || api === void 0 ? void 0 : (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 ? void 0 : _api$blockControls.sharedState.currentState()) || {};

  // Most mouseover events don't fire during drag but some can slip through
  // when the drag begins. This prevents those.
  if (isDragging) {
    return false;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const target = event.target;
  if (target !== null && target !== void 0 && (_target$classList = target.classList) !== null && _target$classList !== void 0 && _target$classList.contains('ProseMirror')) {
    return false;
  }
  let rootElement = target === null || target === void 0 ? void 0 : target.closest('[data-drag-handler-anchor-name]');
  if (rootElement) {
    var _rootElement$parentEl;
    // We want to exlude handles from showing for empty paragraph and heading nodes
    if (isEmptyNestedParagraphOrHeading(rootElement)) {
      return false;
    }
    if (rootElement.getAttribute('data-drag-handler-node-type') === 'media' && editorExperiment('advanced_layouts', true)) {
      rootElement = rootElement.closest('[data-drag-handler-anchor-name][data-drag-handler-node-type="mediaSingle"]');
      if (!rootElement) {
        return false;
      }
    }
    const parentElement = (_rootElement$parentEl = rootElement.parentElement) === null || _rootElement$parentEl === void 0 ? void 0 : _rootElement$parentEl.closest('[data-drag-handler-anchor-name]');
    const parentElementType = parentElement === null || parentElement === void 0 ? void 0 : parentElement.getAttribute('data-drag-handler-node-type');
    if (editorExperiment('advanced_layouts', true)) {
      // We want to exclude handles from showing for direct descendant of table nodes (i.e. nodes in cells)
      if (parentElement && (parentElementType === 'table' || parentElementType === 'tableRow')) {
        rootElement = parentElement;
      }
    } else {
      // We want to exclude handles from showing for direct descendant of table nodes (i.e. nodes in cells)
      if (parentElement && parentElementType === 'table') {
        rootElement = parentElement;
      }
    }

    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const anchorName = rootElement.getAttribute('data-drag-handler-anchor-name');
    // No need to update handle position if its already there
    if ((activeNode === null || activeNode === void 0 ? void 0 : activeNode.anchorName) === anchorName) {
      return false;
    }

    // We want to exlude handles from showing for wrapped nodes
    // TODO: ED-26959 - We should be able remove these check if we decided to
    // go we not decoration for wrapped image solution.
    if (['wrap-right', 'wrap-left'].includes(rootElement.getAttribute('layout') || '')) {
      return false;
    }
    const parentRootElement = rootElement.parentElement;
    let pos;
    if (parentRootElement) {
      var _parentRootElement$ch;
      const childNodes = Array.from(parentRootElement.childNodes);
      const index = childNodes.indexOf(rootElement);
      pos = view.posAtDOM(parentRootElement, index);

      // We want to exlude handles showing for first element in a Panel, ignoring widgets like gapcursor
      const firstChildIsWidget = parentRootElement === null || parentRootElement === void 0 ? void 0 : (_parentRootElement$ch = parentRootElement.children[0]) === null || _parentRootElement$ch === void 0 ? void 0 : _parentRootElement$ch.classList.contains('ProseMirror-widget');
      if (parentElement && parentElementType === 'panel' && !parentElement.classList.contains('ak-editor-panel__no-icon') && (index === 0 || firstChildIsWidget && index === 1)) {
        return false;
      }
    } else {
      pos = view.posAtDOM(rootElement, 0);
    }
    if (parentRootElement && parentRootElement.getAttribute('data-layout-section') === 'true' && parentRootElement.querySelectorAll('[data-layout-column]').length === 1 && editorExperiment('advanced_layouts', true)) {
      // Don't show drag handle for layout column in a single column layout
      return false;
    }
    const targetPos = view.state.doc.resolve(pos).pos;
    let rootAnchorName;
    let rootNodeType;
    let rootPos;
    if (editorExperiment('platform_editor_controls', 'variant1')) {
      rootPos = view.state.doc.resolve(pos).before(1);
      if (targetPos !== rootPos) {
        const rootDOM = view.nodeDOM(rootPos);
        if (rootDOM instanceof HTMLElement) {
          var _rootDOM$getAttribute, _rootDOM$getAttribute2;
          rootAnchorName = (_rootDOM$getAttribute = rootDOM.getAttribute('data-drag-handler-anchor-name')) !== null && _rootDOM$getAttribute !== void 0 ? _rootDOM$getAttribute : undefined;
          rootNodeType = (_rootDOM$getAttribute2 = rootDOM.getAttribute('data-drag-handler-node-type')) !== null && _rootDOM$getAttribute2 !== void 0 ? _rootDOM$getAttribute2 : undefined;
        }
      }
    }
    const nodeType = rootElement.getAttribute('data-drag-handler-node-type');
    if (nodeType) {
      if (editorExperiment('platform_editor_controls', 'variant1')) {
        var _api$core, _api$blockControls2, _rootPos, _rootAnchorName, _rootNodeType;
        api === null || api === void 0 ? void 0 : (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(api === null || api === void 0 ? void 0 : (_api$blockControls2 = api.blockControls) === null || _api$blockControls2 === void 0 ? void 0 : _api$blockControls2.commands.showDragHandleAt(targetPos, anchorName, nodeType, undefined, (_rootPos = rootPos) !== null && _rootPos !== void 0 ? _rootPos : targetPos, (_rootAnchorName = rootAnchorName) !== null && _rootAnchorName !== void 0 ? _rootAnchorName : anchorName, (_rootNodeType = rootNodeType) !== null && _rootNodeType !== void 0 ? _rootNodeType : nodeType));
      } else {
        var _api$core2, _api$blockControls3;
        api === null || api === void 0 ? void 0 : (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions.execute(api === null || api === void 0 ? void 0 : (_api$blockControls3 = api.blockControls) === null || _api$blockControls3 === void 0 ? void 0 : _api$blockControls3.commands.showDragHandleAt(targetPos, anchorName, nodeType));
      }
    }
  }
};