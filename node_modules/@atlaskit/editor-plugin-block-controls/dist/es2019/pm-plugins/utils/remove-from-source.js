import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { findParentNodeClosestToPos } from '@atlaskit/editor-prosemirror/utils';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { isFragmentOfType } from './check-fragment';
import { MIN_LAYOUT_COLUMN } from './consts';
import { updateColumnWidths } from './update-column-widths';
export const removeFromSource = (tr, $from, to) => {
  var _sourceContent, _sourceContent2;
  let sourceContent = $from.nodeAfter;
  let isLayoutColumn = ((_sourceContent = sourceContent) === null || _sourceContent === void 0 ? void 0 : _sourceContent.type.name) === 'layoutColumn';
  let sourceNodeEndPos = $from.pos + (((_sourceContent2 = sourceContent) === null || _sourceContent2 === void 0 ? void 0 : _sourceContent2.nodeSize) || 1);
  if (editorExperiment('platform_editor_element_drag_and_drop_multiselect', true)) {
    sourceContent = tr.doc.slice($from.pos, to).content;
    isLayoutColumn = isFragmentOfType(sourceContent, 'layoutColumn');
    sourceNodeEndPos = to === undefined ? $from.pos + sourceContent.size : to;
  }
  if (!sourceContent) {
    return tr;
  }
  if (isLayoutColumn) {
    const sourceParent = $from.parent;
    if (sourceParent.childCount === MIN_LAYOUT_COLUMN) {
      tr.delete($from.pos + 1, sourceNodeEndPos - 1);

      // Currently, we assume that the MIN_LAYOUT_COLUMN is set to 2.
      // This value may require an update when we introduce support for a single-column layout.
      if (sourceParent.childCount === 2) {
        var _$from$parent$lastChi, _$from$parent$firstCh;
        const layoutContentFragment = $from.parentOffset === 0 ? Fragment.from((_$from$parent$lastChi = $from.parent.lastChild) === null || _$from$parent$lastChi === void 0 ? void 0 : _$from$parent$lastChi.content) : Fragment.from((_$from$parent$firstCh = $from.parent.firstChild) === null || _$from$parent$firstCh === void 0 ? void 0 : _$from$parent$firstCh.content);
        const parent = findParentNodeClosestToPos($from, node => {
          return node.type.name === 'layoutSection';
        });
        if (parent && layoutContentFragment) {
          var _tr$doc$resolve$nodeA;
          const layoutSectionPos = tr.mapping.map(parent.pos);
          // get the updated layout node size
          const layoutSectionNodeSize = ((_tr$doc$resolve$nodeA = tr.doc.resolve(layoutSectionPos).nodeAfter) === null || _tr$doc$resolve$nodeA === void 0 ? void 0 : _tr$doc$resolve$nodeA.nodeSize) || 0;
          tr.replaceWith(layoutSectionPos, layoutSectionPos + layoutSectionNodeSize, layoutContentFragment);
        }
      }
      return tr;
    } else {
      updateColumnWidths(tr, $from.parent, $from.before($from.depth), sourceParent.childCount - 1);
    }
  }
  tr.delete($from.pos, sourceNodeEndPos);
  return tr;
};