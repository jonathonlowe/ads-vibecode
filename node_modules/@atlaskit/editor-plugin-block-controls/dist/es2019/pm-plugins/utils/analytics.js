import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { fg } from '@atlaskit/platform-feature-flags';
export const attachMoveNodeAnalytics = (tr, inputMethod, fromDepth, fromNodeType, toDepth, toNodeType, isSameParent, api, fromNodeTypes, hasSelectedMultipleNodes) => {
  var _api$analytics, _api$analytics$action;
  return api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : (_api$analytics$action = _api$analytics.actions) === null || _api$analytics$action === void 0 ? void 0 : _api$analytics$action.attachAnalyticsEvent({
    eventType: EVENT_TYPE.TRACK,
    action: ACTION.MOVED,
    actionSubject: ACTION_SUBJECT.ELEMENT,
    actionSubjectId: ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
    attributes: {
      nodeDepth: fromDepth,
      nodeType: fromNodeType,
      nodeTypes: fromNodeTypes,
      hasSelectedMultipleNodes,
      destinationNodeDepth: toDepth,
      destinationNodeType: toNodeType,
      isSameParent: isSameParent,
      inputMethod
    }
  })(tr);
};
export const fireInsertLayoutAnalytics = (tr, api, nodeTypes, hasSelectedMultipleNodes) => {
  var _api$analytics2, _api$analytics2$actio;
  api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : (_api$analytics2$actio = _api$analytics2.actions) === null || _api$analytics2$actio === void 0 ? void 0 : _api$analytics2$actio.attachAnalyticsEvent({
    action: ACTION.INSERTED,
    actionSubject: ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: ACTION_SUBJECT_ID.LAYOUT,
    attributes: {
      inputMethod: INPUT_METHOD.DRAG_AND_DROP,
      nodeTypes,
      hasSelectedMultipleNodes
    },
    eventType: EVENT_TYPE.TRACK
  })(tr);
};

/**
 * Given a range, return distinctive types of node and whether there are multiple nodes in the range
 */
export const getMultiSelectAnalyticsAttributes = (tr, anchor, head) => {
  const nodeTypes = [];
  const from = Math.min(anchor, head);
  const to = Math.max(anchor, head);
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (pos < from) {
      // ignore parent node
      return true;
    }
    nodeTypes.push(node.type.name);

    // only care about the top level (relatively in the range) nodes
    return false;
  });
  return {
    nodeTypes: fg('platform_editor_track_node_types') ? [...new Set(nodeTypes)].sort().join(',') : undefined,
    hasSelectedMultipleNodes: nodeTypes.length > 1
  };
};