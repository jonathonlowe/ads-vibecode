import React from 'react';
import { expandSelectionBounds } from '@atlaskit/editor-common/selection';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { moveNode } from './editor-commands/move-node';
import { moveToLayout } from './editor-commands/move-to-layout';
import { firstNodeDecPlugin } from './pm-plugins/first-node-dec-plugin';
import { createInteractionTrackingPlugin, interactionTrackingPluginKey } from './pm-plugins/interaction-tracking/pm-plugin';
import { createPlugin, key } from './pm-plugins/main';
import { selectNode } from './pm-plugins/utils/getSelection';
import BlockMenu from './ui/block-menu';
import { DragHandleMenu } from './ui/drag-handle-menu';
import { GlobalStylesWrapper } from './ui/global-styles';
export const blockControlsPlugin = ({
  api
}) => ({
  name: 'blockControls',
  pmPlugins() {
    const pmPlugins = [{
      name: 'blockControlsPmPlugin',
      plugin: ({
        getIntl,
        nodeViewPortalProviderAPI
      }) => createPlugin(api, getIntl, nodeViewPortalProviderAPI)
    }];
    if (editorExperiment('platform_editor_controls', 'variant1')) {
      if (fg('platform_editor_controls_widget_visibility')) {
        pmPlugins.push({
          name: 'blockControlsInteractionTrackingPlugin',
          plugin: createInteractionTrackingPlugin
        });
      }
      pmPlugins.push({
        name: 'firstNodeDec',
        plugin: firstNodeDecPlugin
      });
    }
    return pmPlugins;
  },
  commands: {
    moveNode: moveNode(api),
    moveToLayout: moveToLayout(api),
    showDragHandleAt: (pos, anchorName, nodeType, handleOptions, rootPos, rootAnchorName, rootNodeType) => ({
      tr
    }) => {
      const currMeta = tr.getMeta(key);
      tr.setMeta(key, {
        ...currMeta,
        activeNode: {
          pos,
          anchorName,
          nodeType,
          handleOptions,
          rootPos,
          rootAnchorName,
          rootNodeType
        },
        closeMenu: editorExperiment('platform_editor_controls', 'variant1') ? true : undefined
      });
      return tr;
    },
    toggleBlockMenu: options => ({
      tr
    }) => {
      const currMeta = tr.getMeta(key);
      if (options !== null && options !== void 0 && options.closeMenu) {
        tr.setMeta(key, {
          ...currMeta,
          closeMenu: true
        });
        return tr;
      }
      tr.setMeta(key, {
        ...currMeta,
        toggleMenu: {
          anchorName: options === null || options === void 0 ? void 0 : options.anchorName
        }
      });
      return tr;
    },
    setNodeDragged: (getPos, anchorName, nodeType) => ({
      tr
    }) => {
      const pos = getPos();
      if (pos === undefined) {
        return tr;
      }
      const currMeta = tr.getMeta(key);
      tr.setMeta(key, {
        ...currMeta,
        isDragging: true,
        activeNode: {
          pos,
          anchorName,
          nodeType
        }
      });
      if (fg('platform_editor_ease_of_use_metrics')) {
        var _api$metrics;
        api === null || api === void 0 ? void 0 : (_api$metrics = api.metrics) === null || _api$metrics === void 0 ? void 0 : _api$metrics.commands.handleIntentToStartEdit({
          shouldStartTimer: false,
          shouldPersistActiveSession: true
        })({
          tr
        });
      }
      if (fg('platform_editor_user_intent_plugin')) {
        var _api$userIntent;
        api === null || api === void 0 ? void 0 : (_api$userIntent = api.userIntent) === null || _api$userIntent === void 0 ? void 0 : _api$userIntent.commands.setCurrentUserIntent('dragging')({
          tr
        });
      }
      return tr;
    },
    setMultiSelectPositions: (anchor, head) => ({
      tr
    }) => {
      var _api$selection, _$to$nodeBefore, _$from$nodeAfter;
      const {
        anchor: userAnchor,
        head: userHead
      } = tr.selection;
      let $expandedAnchor, $expandedHead;
      if (anchor !== undefined && head !== undefined) {
        $expandedAnchor = tr.doc.resolve(anchor);
        $expandedHead = tr.doc.resolve(head);
      } else {
        const expandedSelection = expandSelectionBounds(tr.selection.$anchor, tr.selection.$head);
        $expandedAnchor = expandedSelection.$anchor;
        $expandedHead = expandedSelection.$head;
      }
      api === null || api === void 0 ? void 0 : (_api$selection = api.selection) === null || _api$selection === void 0 ? void 0 : _api$selection.commands.setManualSelection($expandedAnchor.pos, $expandedHead.pos)({
        tr
      });
      const $from = $expandedAnchor.min($expandedHead);
      const $to = $expandedAnchor.max($expandedHead);
      let expandedNormalisedSel;
      if ($from.nodeAfter === $to.nodeBefore) {
        selectNode(tr, $from.pos, $expandedAnchor.node().type.name);
        expandedNormalisedSel = tr.selection;
      } else if (((_$to$nodeBefore = $to.nodeBefore) === null || _$to$nodeBefore === void 0 ? void 0 : _$to$nodeBefore.type.name) === 'mediaSingle' || ((_$from$nodeAfter = $from.nodeAfter) === null || _$from$nodeAfter === void 0 ? void 0 : _$from$nodeAfter.type.name) === 'mediaSingle') {
        expandedNormalisedSel = new TextSelection($expandedAnchor, $expandedHead);
        tr.setSelection(expandedNormalisedSel);
      } else {
        // this is to normalise the selection's boundaries to inline positions, preventing it from collapsing
        expandedNormalisedSel = TextSelection.between($expandedAnchor, $expandedHead);
        tr.setSelection(expandedNormalisedSel);
      }
      const multiSelectDnD = {
        anchor: $expandedAnchor.pos,
        head: $expandedHead.pos,
        textAnchor: expandedNormalisedSel.anchor,
        textHead: expandedNormalisedSel.head,
        userAnchor: userAnchor,
        userHead: userHead
      };
      const currMeta = tr.getMeta(key);
      tr.setMeta(key, {
        ...currMeta,
        multiSelectDnD
      });
      return tr;
    },
    setSelectedViaDragHandle: isSelectedViaDragHandle => ({
      tr
    }) => {
      const currMeta = tr.getMeta(key);
      return tr.setMeta(key, {
        ...currMeta,
        isSelectedViaDragHandle
      });
    }
  },
  getSharedState(editorState) {
    var _key$getState$isMenuO, _key$getState, _key$getState$menuTri, _key$getState2, _key$getState$activeN, _key$getState3, _key$getState$isDragg, _key$getState4, _key$getState$isPMDra, _key$getState5, _key$getState$multiSe, _key$getState6, _key$getState$isShift, _key$getState7, _key$getState$lastDra, _key$getState8, _interactionTrackingP, _key$getState$isSelec, _key$getState9;
    if (!editorState) {
      return undefined;
    }
    return {
      isMenuOpen: (_key$getState$isMenuO = (_key$getState = key.getState(editorState)) === null || _key$getState === void 0 ? void 0 : _key$getState.isMenuOpen) !== null && _key$getState$isMenuO !== void 0 ? _key$getState$isMenuO : false,
      menuTriggerBy: (_key$getState$menuTri = (_key$getState2 = key.getState(editorState)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.menuTriggerBy) !== null && _key$getState$menuTri !== void 0 ? _key$getState$menuTri : undefined,
      activeNode: (_key$getState$activeN = (_key$getState3 = key.getState(editorState)) === null || _key$getState3 === void 0 ? void 0 : _key$getState3.activeNode) !== null && _key$getState$activeN !== void 0 ? _key$getState$activeN : undefined,
      isDragging: (_key$getState$isDragg = (_key$getState4 = key.getState(editorState)) === null || _key$getState4 === void 0 ? void 0 : _key$getState4.isDragging) !== null && _key$getState$isDragg !== void 0 ? _key$getState$isDragg : false,
      isPMDragging: (_key$getState$isPMDra = (_key$getState5 = key.getState(editorState)) === null || _key$getState5 === void 0 ? void 0 : _key$getState5.isPMDragging) !== null && _key$getState$isPMDra !== void 0 ? _key$getState$isPMDra : false,
      multiSelectDnD: (_key$getState$multiSe = (_key$getState6 = key.getState(editorState)) === null || _key$getState6 === void 0 ? void 0 : _key$getState6.multiSelectDnD) !== null && _key$getState$multiSe !== void 0 ? _key$getState$multiSe : undefined,
      isShiftDown: (_key$getState$isShift = (_key$getState7 = key.getState(editorState)) === null || _key$getState7 === void 0 ? void 0 : _key$getState7.isShiftDown) !== null && _key$getState$isShift !== void 0 ? _key$getState$isShift : undefined,
      lastDragCancelled: (_key$getState$lastDra = (_key$getState8 = key.getState(editorState)) === null || _key$getState8 === void 0 ? void 0 : _key$getState8.lastDragCancelled) !== null && _key$getState$lastDra !== void 0 ? _key$getState$lastDra : false,
      isEditing: (_interactionTrackingP = interactionTrackingPluginKey.getState(editorState)) === null || _interactionTrackingP === void 0 ? void 0 : _interactionTrackingP.isEditing,
      isSelectedViaDragHandle: (_key$getState$isSelec = (_key$getState9 = key.getState(editorState)) === null || _key$getState9 === void 0 ? void 0 : _key$getState9.isSelectedViaDragHandle) !== null && _key$getState$isSelec !== void 0 ? _key$getState$isSelec : false
    };
  },
  contentComponent({
    editorView,
    popupsMountPoint,
    popupsBoundariesElement,
    popupsScrollableElement
  }) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, editorExperiment('platform_editor_controls', 'variant1') ? /*#__PURE__*/React.createElement(BlockMenu, {
      editorView: editorView,
      mountPoint: popupsMountPoint,
      boundariesElement: popupsBoundariesElement,
      scrollableElement: popupsScrollableElement,
      api: api
    }) : /*#__PURE__*/React.createElement(DragHandleMenu, {
      api: api
    }), /*#__PURE__*/React.createElement(GlobalStylesWrapper, null));
  }
});