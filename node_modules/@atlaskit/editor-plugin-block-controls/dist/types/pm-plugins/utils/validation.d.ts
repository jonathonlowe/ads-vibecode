import { Fragment, Slice } from '@atlaskit/editor-prosemirror/model';
import type { NodeType, Node as PMNode, ResolvedPos } from '@atlaskit/editor-prosemirror/model';
export declare const isInsideTable: (nodeType: NodeType) => Boolean;
export declare const isLayoutColumn: (nodeType: NodeType) => Boolean;
export declare const isDoc: (nodeType: NodeType) => Boolean;
export declare const isExpand: (nodeType: NodeType) => Boolean;
export declare const isNestedExpand: (nodeType: NodeType) => Boolean;
export declare const isInSameLayout: ($from: ResolvedPos, $to: ResolvedPos) => boolean;
/**
 * This function converts an expand into a nested expand,
 * although it may fail based on the expand's content.
 * @param expandNode the node to transform.
 * @returns an nested expand node
 * @throws RangeError: Invalid content for node nestedExpand
 */
export declare const transformExpandToNestedExpand: (expandNode: PMNode) => PMNode | null;
export declare const transformFragmentExpandToNestedExpand: (fragment: Fragment) => Fragment | null;
export declare const transformSliceExpandToNestedExpand: (slice: Slice) => Slice | null;
export declare const memoizedTransformExpandToNestedExpand: import("memoize-one").MemoizedFn<(node: PMNode) => PMNode | null>;
export declare const canCreateNodeWithContentInsideAnotherNode: (nodeTypesToCreate: NodeType[], nodeWithTargetFragment: Fragment) => boolean;
export declare function canMoveNodeToIndex(destParent: PMNode, indexIntoParent: number, srcNode: PMNode, $destNodePos: ResolvedPos, destNode?: PMNode): boolean;
export declare function canMoveSliceToIndex(slice: Slice, sliceFromPos: number, sliceToPos: number, destParent: PMNode, indexIntoParent: number, $destNodePos: ResolvedPos, destNode?: PMNode): boolean;
