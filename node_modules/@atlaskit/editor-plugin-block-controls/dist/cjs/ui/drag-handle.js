"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DragHandleWithVisibility = exports.DragHandle = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _react2 = require("@emotion/react");
var _bindEventListener = require("bind-event-listener");
var _analytics = require("@atlaskit/editor-common/analytics");
var _browser = require("@atlaskit/editor-common/browser");
var _hooks = require("@atlaskit/editor-common/hooks");
var _keymaps = require("@atlaskit/editor-common/keymaps");
var _messages = require("@atlaskit/editor-common/messages");
var _styles = require("@atlaskit/editor-common/styles");
var _useSharedPluginStateSelector = require("@atlaskit/editor-common/use-shared-plugin-state-selector");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _dragHandler = _interopRequireDefault(require("@atlaskit/icon/glyph/drag-handler"));
var _dragHandleVertical = _interopRequireDefault(require("@atlaskit/icon/utility/drag-handle-vertical"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _adapter = require("@atlaskit/pragmatic-drag-and-drop/element/adapter");
var _setCustomNativeDragPreview = require("@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview");
var _primitives = require("@atlaskit/primitives");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _tooltip = _interopRequireDefault(require("@atlaskit/tooltip"));
var _main = require("../pm-plugins/main");
var _analytics2 = require("../pm-plugins/utils/analytics");
var _dragHandlePositions = require("../pm-plugins/utils/drag-handle-positions");
var _getSelection = require("../pm-plugins/utils/getSelection");
var _selection = require("../pm-plugins/utils/selection");
var _consts = require("./consts");
var _dragPreview = require("./drag-preview");
var _anchorName = require("./utils/anchor-name");
var _visibilityContainer = require("./visibility-container");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } /**
 * @jsxRuntime classic
 * @jsx jsx
 */ // eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
var iconWrapperStyles = (0, _primitives.xcss)({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
});
var buttonWrapperStyles = (0, _react2.css)({
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    background: "linear-gradient(to bottom, ".concat("var(--ds-surface, #FFFFFF)", " 90%, transparent)"),
    marginBottom: "var(--ds-space-negative-200, -16px)",
    paddingBottom: "var(--ds-space-200, 16px)",
    marginTop: "var(--ds-space-negative-400, -32px)",
    paddingTop: "calc(".concat("var(--ds-space-400, 32px)", " - 1px)"),
    marginRight: "var(--ds-space-negative-150, -12px)",
    paddingRight: "var(--ds-space-150, 12px)",
    boxSizing: 'border-box'
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    background: "linear-gradient(to bottom, ".concat("var(--ds-surface, #FFFFFF)", " 90%, transparent)"),
    marginBottom: "var(--ds-space-negative-200, -16px)",
    paddingBottom: "var(--ds-space-200, 16px)",
    marginTop: "var(--ds-space-negative-400, -32px)",
    paddingTop: "calc(".concat("var(--ds-space-400, 32px)", " - 1px)"),
    marginRight: "var(--ds-space-negative-150, -12px)",
    paddingRight: "var(--ds-space-150, 12px)",
    boxSizing: 'border-box'
  }
});

// update color to match quick insert button for new editor controls
var dragHandleColor = (0, _react2.css)({
  color: "var(--ds-icon-subtle, #626F86)"
});
var dragHandleButtonStyles = (0, _react2.css)({
  display: 'flex',
  boxSizing: 'border-box',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  height: _consts.DRAG_HANDLE_HEIGHT,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  width: _consts.DRAG_HANDLE_WIDTH,
  border: 'none',
  background: 'transparent',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  borderRadius: _consts.DRAG_HANDLE_BORDER_RADIUS,
  // when platform_editor_controls is enabled, the drag handle color is overridden. Update color here when experiment is cleaned up.
  color: "var(--ds-icon, #44546F)",
  cursor: 'grab',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  zIndex: _consts.DRAG_HANDLE_ZINDEX,
  outline: 'none',
  '&:hover': {
    backgroundColor: "var(--ds-background-neutral-subtle-hovered, #091E420F)"
  },
  '&:active': {
    backgroundColor: "var(--ds-background-neutral-subtle-pressed, #091E4224)"
  },
  '&:focus': {
    outline: "2px solid ".concat("var(--ds-border-focused, #388BFF)")
  },
  '&:disabled': {
    color: "var(--ds-icon-disabled, #8993A4)",
    backgroundColor: 'transparent'
  },
  '&:hover:disabled': {
    backgroundColor: "var(--ds-background-disabled, transparent)"
  }
});
var dragHandleButtonStylesOld = (0, _react2.css)({
  position: 'absolute',
  paddingTop: "var(--ds-space-025, 2px)",
  paddingBottom: "var(--ds-space-025, 2px)",
  paddingLeft: '0',
  paddingRight: '0',
  boxSizing: 'border-box',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  height: _consts.DRAG_HANDLE_HEIGHT,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  width: _consts.DRAG_HANDLE_WIDTH,
  border: 'none',
  background: 'transparent',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  borderRadius: _consts.DRAG_HANDLE_BORDER_RADIUS,
  // when platform_editor_controls is enabled, the drag handle color is overridden. Update color here when experiment is cleaned up.
  color: "var(--ds-icon, #44546F)",
  cursor: 'grab',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  zIndex: _consts.DRAG_HANDLE_ZINDEX,
  outline: 'none',
  '&:hover': {
    backgroundColor: "var(--ds-background-neutral-subtle-hovered, #091E420F)"
  },
  '&:active': {
    backgroundColor: "var(--ds-background-neutral-subtle-pressed, #091E4224)"
  },
  '&:focus': {
    outline: "2px solid ".concat("var(--ds-border-focused, #388BFF)")
  },
  '&:disabled': {
    color: "var(--ds-icon-disabled, #8993A4)",
    backgroundColor: 'transparent'
  },
  '&:hover:disabled': {
    backgroundColor: "var(--ds-background-disabled, transparent)"
  }
});
var dragHandleContainerStyles = (0, _primitives.xcss)({
  position: 'absolute',
  boxSizing: 'border-box'
});
var tooltipContainerStyles = (0, _react2.css)({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  bottom: "-".concat(_consts.STICKY_CONTROLS_TOP_MARGIN, "px"),
  position: 'sticky',
  display: 'block',
  zIndex: 100 // card = 100
});
var tooltipContainerStylesStickyHeaderWithMask = (0, _react2.css)({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  top: "".concat(_consts.STICKY_CONTROLS_TOP_MARGIN, "px"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    top: '0'
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    top: '0'
  }
});
var tooltipContainerStylesStickyHeaderWithoutMask = (0, _react2.css)({
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
  top: "".concat(_consts.STICKY_CONTROLS_TOP_MARGIN, "px"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-blocks-drag-handle-container]:has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
    top: _styles.tableControlsSpacing
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors
  '[data-prosemirror-mark-name="breakout"]:has([data-blocks-drag-handle-container]):has(+ [data-prosemirror-node-name="table"] .pm-table-with-controls tr.sticky) &': {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values
    top: _styles.tableControlsSpacing
  }
});
var dragHandleMultiLineSelectionFixFirefox = (0, _react2.css)({
  '&::selection': {
    backgroundColor: 'transparent'
  }
});
var layoutColumnDragHandleStyles = (0, _react2.css)({
  transform: 'rotate(90deg)'
});
var selectedStyles = (0, _react2.css)({
  backgroundColor: "var(--ds-background-selected, #E9F2FF)",
  color: "var(--ds-icon-selected, #0C66E4)"
});

// [Chrome only] When selection contains multiple nodes and then drag a drag handle that is within the selection range,
// icon span receives dragStart event, instead of button, and since it is not registered as a draggable element
// with pragmatic DnD and pragmatic DnD is not triggered
var handleIconDragStart = function handleIconDragStart(e) {
  if (!_browser.browser.chrome || !(0, _platformFeatureFlags.fg)('platform_editor_dnd_update_drag_start_target')) {
    return;
  }
  // prevent dragStart handler triggered by icon
  e.stopPropagation();
  var dragEvent = new DragEvent('dragstart', {
    bubbles: true,
    cancelable: true,
    dataTransfer: e.dataTransfer
  });
  if (e.target instanceof HTMLElement) {
    var _e$target$closest;
    // re-dispatch drag event on button so that pragmatic DnD can be triggered properly
    (_e$target$closest = e.target.closest('button')) === null || _e$target$closest === void 0 || _e$target$closest.dispatchEvent(dragEvent);
  }
};
var getNodeSpacingForPreview = function getNodeSpacingForPreview(node) {
  if (!node) {
    return _consts.spacingBetweenNodesForPreview['default'];
  }
  var nodeTypeName = node.type.name;
  if (nodeTypeName === 'heading') {
    return _consts.spacingBetweenNodesForPreview["heading".concat(node.attrs.level)] || _consts.spacingBetweenNodesForPreview['default'];
  }
  return _consts.spacingBetweenNodesForPreview[nodeTypeName] || _consts.spacingBetweenNodesForPreview['default'];
};
var getNodeMargins = function getNodeMargins(node) {
  if (!node) {
    return _consts.nodeMargins['default'];
  }
  var nodeTypeName = node.type.name;
  if (nodeTypeName === 'heading') {
    return _consts.nodeMargins["heading".concat(node.attrs.level)] || _consts.nodeMargins['default'];
  }
  return _consts.nodeMargins[nodeTypeName] || _consts.nodeMargins['default'];
};
var DragHandle = exports.DragHandle = function DragHandle(_ref) {
  var _api$core2, _api$blockControls3, _api$analytics2, _api$core4;
  var view = _ref.view,
    api = _ref.api,
    formatMessage = _ref.formatMessage,
    getPos = _ref.getPos,
    anchorName = _ref.anchorName,
    nodeType = _ref.nodeType,
    handleOptions = _ref.handleOptions,
    _ref$isTopLevelNode = _ref.isTopLevelNode,
    isTopLevelNode = _ref$isTopLevelNode === void 0 ? true : _ref$isTopLevelNode,
    anchorRectCache = _ref.anchorRectCache;
  var start = getPos();
  var buttonRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(768),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    blockCardWidth = _useState2[0],
    setBlockCardWidth = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    dragHandleSelected = _useState4[0],
    setDragHandleSelected = _useState4[1];
  var _useState5 = (0, _react.useState)(false),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    dragHandleDisabled = _useState6[0],
    setDragHandleDisabled = _useState6[1];
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(api, ['featureFlags']),
    featureFlagsState = _useSharedPluginState.featureFlagsState;
  var selection = (0, _useSharedPluginStateSelector.useSharedPluginStateSelector)(api, 'selection.selection');
  var isShiftDown = (0, _useSharedPluginStateSelector.useSharedPluginStateSelector)(api, 'blockControls.isShiftDown');
  var hasHadInteraction = (0, _useSharedPluginStateSelector.useSharedPluginStateSelector)(api, 'interaction.hasHadInteraction') !== false;
  var isLayoutColumn = nodeType === 'layoutColumn';
  var isMultiSelect = (0, _experiments.editorExperiment)('platform_editor_element_drag_and_drop_multiselect', true);
  (0, _react.useEffect)(function () {
    // blockCard/datasource width is rendered correctly after this decoraton does. We need to observe for changes.
    if (nodeType === 'blockCard') {
      var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
      var container = dom === null || dom === void 0 ? void 0 : dom.querySelector('.datasourceView-content-inner-wrap');
      if (container) {
        var resizeObserver = new ResizeObserver(function (entries) {
          var width = entries[0].contentBoxSize[0].inlineSize;
          setBlockCardWidth(width);
        });
        resizeObserver.observe(container);
        return function () {
          return resizeObserver.unobserve(container);
        };
      }
    }
  }, [anchorName, nodeType, view.dom]);
  var handleOnClick = (0, _react.useCallback)(function (e) {
    var _api$core;
    if (!isMultiSelect) {
      setDragHandleSelected(!dragHandleSelected);
    }
    api === null || api === void 0 || (_api$core = api.core) === null || _api$core === void 0 || _api$core.actions.execute(function (_ref2) {
      var _api$blockControls$sh, _api$analytics;
      var tr = _ref2.tr;
      var startPos = getPos();
      if (startPos === undefined) {
        return tr;
      }
      var mSelect = api === null || api === void 0 || (_api$blockControls$sh = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh === void 0 ? void 0 : _api$blockControls$sh.multiSelectDnD;
      var $anchor = (mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) !== undefined ? tr.doc.resolve(mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) : tr.selection.$anchor;
      if (!isMultiSelect || tr.selection.empty || !e.shiftKey) {
        tr = (0, _getSelection.selectNode)(tr, startPos, nodeType);
        if (_consts.BLOCK_MENU_ENABLED && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
          var _api$blockControls;
          api === null || api === void 0 || (_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 || _api$blockControls.commands.toggleBlockMenu({
            anchorName: anchorName
          })({
            tr: tr
          });
          e.stopPropagation();
        }
      } else if (isTopLevelNode && $anchor.depth <= _consts.DRAG_HANDLE_MAX_SHIFT_CLICK_DEPTH && e.shiftKey && (0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_shift_click_select')) {
        var _api$blockControls2;
        var alignAnchorHeadToSel = (0, _selection.alignAnchorHeadInDirectionOfPos)(tr.selection, startPos);
        var selectionWithExpandedHead = (0, _selection.expandSelectionHeadToNodeAtPos)(alignAnchorHeadToSel, startPos);
        tr.setSelection(selectionWithExpandedHead);
        api === null || api === void 0 || (_api$blockControls2 = api.blockControls) === null || _api$blockControls2 === void 0 || _api$blockControls2.commands.setMultiSelectPositions()({
          tr: tr
        });
      }
      var resolvedMovingNode = tr.doc.resolve(startPos);
      var maybeNode = resolvedMovingNode.nodeAfter;
      tr.setMeta('scrollIntoView', false);
      api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 || _api$analytics.actions.attachAnalyticsEvent({
        eventType: _analytics.EVENT_TYPE.UI,
        action: _analytics.ACTION.CLICKED,
        actionSubject: _analytics.ACTION_SUBJECT.BUTTON,
        actionSubjectId: _analytics.ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
        attributes: {
          nodeDepth: resolvedMovingNode.depth,
          nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || ''
        }
      })(tr);
      return tr;
    });
    view.focus();
  }, [isMultiSelect, api === null || api === void 0 || (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions, api === null || api === void 0 ? void 0 : api.blockControls.sharedState, api === null || api === void 0 || (_api$blockControls3 = api.blockControls) === null || _api$blockControls3 === void 0 ? void 0 : _api$blockControls3.commands, api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, view, dragHandleSelected, getPos, isTopLevelNode, nodeType, anchorName]);

  // TODO: ED-26959 - This needs to be investigated further. Drag preview generation is not always working
  // as expected with a node selection. This workaround sets the selection to the node on mouseDown,
  // but ensures the preview is generated correctly.
  var handleMouseDown = (0, _react.useCallback)(function () {
    if ((0, _experiments.editorExperiment)('advanced_layouts', true)) {
      var _buttonRef$current;
      // prevent native drag and drop.
      (_buttonRef$current = buttonRef.current) === null || _buttonRef$current === void 0 || _buttonRef$current.focus();
      if (!isLayoutColumn) {
        return undefined;
      }
    }
  }, [isLayoutColumn]);
  var handleKeyDown = (0, _react.useCallback)(function (e) {
    if ((0, _platformFeatureFlags.fg)('platform_editor_element_drag_and_drop_ed_23873')) {
      // allow user to use spacebar to select the node
      if (!e.repeat && e.key === ' ') {
        var _api$core3;
        var startPos = getPos();
        api === null || api === void 0 || (_api$core3 = api.core) === null || _api$core3 === void 0 || _api$core3.actions.execute(function (_ref3) {
          var tr = _ref3.tr;
          if (startPos === undefined) {
            return tr;
          }
          var node = tr.doc.nodeAt(startPos);
          if (!node) {
            return tr;
          }
          var $startPos = tr.doc.resolve(startPos + node.nodeSize);
          var selection = new _state.TextSelection($startPos);
          tr.setSelection(selection);
          !isMultiSelect && tr.setMeta(_main.key, {
            pos: startPos
          });
          return tr;
        });
      } else if (![e.altKey, e.ctrlKey, e.shiftKey].some(function (pressed) {
        return pressed;
      })) {
        // If not trying to press shortcut keys,
        // return focus to editor to resume editing from caret position
        view.focus();
      }
    }
  }, [getPos, api === null || api === void 0 || (_api$core4 = api.core) === null || _api$core4 === void 0 ? void 0 : _api$core4.actions, isMultiSelect, view]);
  (0, _react.useEffect)(function () {
    var element = buttonRef.current;
    if (!element) {
      return;
    }
    return (0, _adapter.draggable)({
      element: element,
      getInitialData: function getInitialData() {
        return {
          type: 'element',
          start: start
        };
      },
      onGenerateDragPreview: function onGenerateDragPreview(_ref4) {
        var _api$blockControls$sh2;
        var nativeSetDragImage = _ref4.nativeSetDragImage;
        if (isMultiSelect) {
          var _api$core5;
          api === null || api === void 0 || (_api$core5 = api.core) === null || _api$core5 === void 0 || _api$core5.actions.execute(function (_ref5) {
            var tr = _ref5.tr;
            var handlePos = getPos();
            if (typeof handlePos !== 'number') {
              return tr;
            }
            var oldHandlePosCheck = handlePos >= tr.selection.$from.start() - 1 && handlePos <= tr.selection.to;
            var newHandlePosCheck = (0, _getSelection.isHandleCorrelatedToSelection)(view.state, tr.selection, handlePos);
            if (!tr.selection.empty && ((0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_multi_select_patch_1') ? newHandlePosCheck : oldHandlePosCheck)) {
              var _api$blockControls4;
              api === null || api === void 0 || (_api$blockControls4 = api.blockControls) === null || _api$blockControls4 === void 0 || _api$blockControls4.commands.setMultiSelectPositions()({
                tr: tr
              });
            } else if ((0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_select_node_on_drag')) {
              tr = (0, _getSelection.selectNode)(tr, handlePos, nodeType);
            }
            return tr;
          });
        }
        var startPos = getPos();
        var state = view.state;
        var doc = state.doc,
          selection = state.selection;
        var sliceFrom = selection.from;
        var sliceTo = selection.to;
        var mSelect = api === null || api === void 0 || (_api$blockControls$sh2 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh2 === void 0 ? void 0 : _api$blockControls$sh2.multiSelectDnD;
        if (mSelect) {
          var anchor = mSelect.anchor,
            head = mSelect.head;
          sliceFrom = Math.min(anchor, head);
          sliceTo = Math.max(anchor, head);
        }
        var expandedSlice = doc.slice(sliceFrom, sliceTo);
        var isDraggingMultiLine = isMultiSelect && startPos !== undefined && startPos >= sliceFrom && startPos < sliceTo && expandedSlice.content.childCount > 1;
        (0, _setCustomNativeDragPreview.setCustomNativeDragPreview)({
          getOffset: function getOffset() {
            if (!isDraggingMultiLine) {
              return {
                x: 0,
                y: 0
              };
            } else {
              // Calculate the offset of the preview container,
              // So when drag multiple nodes, the preview align with the position of the selected nodes
              var domAtPos = view.domAtPos.bind(view);
              var domElementsHeightBeforeHandle = 0;
              var nodesStartPos = [];
              var nodesEndPos = [];
              var activeNodeMarginTop = 0;
              for (var i = 0; i < expandedSlice.content.childCount; i++) {
                if (i === 0) {
                  var _expandedSlice$conten;
                  nodesStartPos[i] = sliceFrom;
                  nodesEndPos[i] = sliceFrom + (((_expandedSlice$conten = expandedSlice.content.maybeChild(i)) === null || _expandedSlice$conten === void 0 ? void 0 : _expandedSlice$conten.nodeSize) || 0);
                } else {
                  var _expandedSlice$conten2;
                  nodesStartPos[i] = nodesEndPos[i - 1];
                  nodesEndPos[i] = nodesStartPos[i] + (((_expandedSlice$conten2 = expandedSlice.content.maybeChild(i)) === null || _expandedSlice$conten2 === void 0 ? void 0 : _expandedSlice$conten2.nodeSize) || 0);
                }

                // when the node is before the handle, calculate the height of the node
                if (nodesEndPos[i] <= startPos) {
                  // eslint-disable-next-line @atlaskit/editor/no-as-casting
                  var currentNodeElement = (0, _utils.findDomRefAtPos)(nodesStartPos[i], domAtPos);
                  var maybeCurrentNode = expandedSlice.content.maybeChild(i);
                  var currentNodeSpacing = maybeCurrentNode ? getNodeMargins(maybeCurrentNode).top + getNodeMargins(maybeCurrentNode).bottom : 0;
                  domElementsHeightBeforeHandle = domElementsHeightBeforeHandle + currentNodeElement.offsetHeight + currentNodeSpacing;
                } else {
                  // when the node is after the handle, calculate the top margin of the active node
                  var maybeNextNode = expandedSlice.content.maybeChild(i);
                  activeNodeMarginTop = maybeNextNode ? getNodeMargins(maybeNextNode).top : 0;
                  break;
                }
              }
              return {
                x: 0,
                y: domElementsHeightBeforeHandle + activeNodeMarginTop
              };
            }
          },
          render: function render(_ref6) {
            var container = _ref6.container;
            var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
            if (!dom) {
              return;
            }
            if (!isDraggingMultiLine) {
              return (0, _dragPreview.dragPreview)(container, {
                dom: dom,
                nodeType: nodeType
              });
            } else {
              var domAtPos = view.domAtPos.bind(view);
              var previewContent = [];
              expandedSlice.content.descendants(function (node, pos, _parent, _index) {
                // Get the dom element of the node
                //eslint-disable-next-line @atlaskit/editor/no-as-casting
                var nodeDomElement = (0, _utils.findDomRefAtPos)(sliceFrom + pos, domAtPos);
                var currentNodeSpacing = getNodeSpacingForPreview(node);
                previewContent.push({
                  dom: nodeDomElement,
                  nodeType: node.type.name,
                  nodeSpacing: currentNodeSpacing
                });
                return false; // Only iterate through the first level of nodes
              });
              return (0, _dragPreview.dragPreview)(container, previewContent);
            }
          },
          nativeSetDragImage: nativeSetDragImage
        });
      },
      onDragStart: function onDragStart() {
        var _api$core6;
        if (start === undefined) {
          return;
        }
        api === null || api === void 0 || (_api$core6 = api.core) === null || _api$core6 === void 0 || _api$core6.actions.execute(function (_ref7) {
          var _api$blockControls$sh3, _api$blockControls5, _api$analytics3;
          var tr = _ref7.tr;
          var nodeTypes, hasSelectedMultipleNodes;
          var resolvedMovingNode = tr.doc.resolve(start);
          var maybeNode = resolvedMovingNode.nodeAfter;
          var mSelect = api === null || api === void 0 || (_api$blockControls$sh3 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh3 === void 0 ? void 0 : _api$blockControls$sh3.multiSelectDnD;
          if (mSelect) {
            var attributes = (0, _analytics2.getMultiSelectAnalyticsAttributes)(tr, mSelect.anchor, mSelect.head);
            nodeTypes = attributes.nodeTypes;
            hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
          } else {
            nodeTypes = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name;
            hasSelectedMultipleNodes = false;
          }
          api === null || api === void 0 || (_api$blockControls5 = api.blockControls) === null || _api$blockControls5 === void 0 || _api$blockControls5.commands.setNodeDragged(getPos, anchorName, nodeType)({
            tr: tr
          });
          tr.setMeta('scrollIntoView', false);
          api === null || api === void 0 || (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 || _api$analytics3.actions.attachAnalyticsEvent({
            eventType: _analytics.EVENT_TYPE.UI,
            action: _analytics.ACTION.DRAGGED,
            actionSubject: _analytics.ACTION_SUBJECT.ELEMENT,
            actionSubjectId: _analytics.ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
            attributes: _objectSpread({
              nodeDepth: resolvedMovingNode.depth,
              nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || ''
            }, isMultiSelect && {
              nodeTypes: nodeTypes,
              hasSelectedMultipleNodes: hasSelectedMultipleNodes
            })
          })(tr);
          return tr;
        });
        view.focus();
      }
    });
  }, [anchorName, api, getPos, isMultiSelect, nodeType, start, view]);
  var macroInteractionUpdates = featureFlagsState === null || featureFlagsState === void 0 ? void 0 : featureFlagsState.macroInteractionUpdates;
  var calculatePosition = (0, _react.useCallback)(function () {
    var pos = getPos();
    var $pos = pos && view.state.doc.resolve(pos);
    var parentPos = $pos && $pos.depth ? $pos.before() : undefined;
    var node = parentPos !== undefined ? view.state.doc.nodeAt(parentPos) : undefined;
    var parentNodeType = node === null || node === void 0 ? void 0 : node.type.name;
    var supportsAnchor = CSS.supports('top', "anchor(".concat(anchorName, " start)")) && CSS.supports('left', "anchor(".concat(anchorName, " start)"));
    var safeAnchorName = (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_2') ? (0, _anchorName.refreshAnchorName)({
      getPos: getPos,
      view: view,
      anchorName: anchorName
    }) : anchorName;
    var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(safeAnchorName, "\"]"));
    var hasResizer = nodeType === 'table' || nodeType === 'mediaSingle';
    var isExtension = nodeType === 'extension' || nodeType === 'bodiedExtension' || nodeType === 'multiBodiedExtension' && (0, _platformFeatureFlags.fg)('platform_editor_multi_body_extension_extensibility');
    var isBlockCard = nodeType === 'blockCard' && !!blockCardWidth;
    var isEmbedCard = nodeType === 'embedCard';
    var isMacroInteractionUpdates = macroInteractionUpdates && isExtension;
    var innerContainer = null;
    if (dom) {
      if (isEmbedCard) {
        innerContainer = dom.querySelector('.rich-media-item');
      } else if (hasResizer) {
        innerContainer = dom.querySelector('.resizer-item');
      } else if (isExtension) {
        innerContainer = dom.querySelector('.extension-container[data-layout]');
      } else if (isBlockCard) {
        //specific to datasource blockCard
        innerContainer = dom.querySelector('.datasourceView-content-inner-wrap');
      }
    }
    var isEdgeCase = (hasResizer || isExtension || isEmbedCard || isBlockCard) && innerContainer;
    var isSticky = (0, _dragHandlePositions.shouldBeSticky)(nodeType);
    if (supportsAnchor) {
      var bottom = (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_sticky_controls') ? (0, _dragHandlePositions.getControlBottomCSSValue)(safeAnchorName, isSticky, isTopLevelNode, isLayoutColumn) : {};
      return _objectSpread({
        left: isEdgeCase ? "calc(anchor(".concat(safeAnchorName, " start) + ").concat((0, _dragHandlePositions.getLeftPosition)(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType), ")") : (0, _experiments.editorExperiment)('advanced_layouts', true) && isLayoutColumn ? "calc((anchor(".concat(safeAnchorName, " right) + anchor(").concat(safeAnchorName, " left))/2 - ").concat(_consts.DRAG_HANDLE_HEIGHT / 2, "px)") : "calc(anchor(".concat(safeAnchorName, " start) - ").concat(_consts.DRAG_HANDLE_WIDTH, "px - ").concat((0, _consts.dragHandleGap)(nodeType, parentNodeType), "px)"),
        top: (0, _experiments.editorExperiment)('advanced_layouts', true) && isLayoutColumn ? "calc(anchor(".concat(safeAnchorName, " top) - ").concat(_consts.DRAG_HANDLE_WIDTH, "px)") : "calc(anchor(".concat(safeAnchorName, " start) + ").concat((0, _consts.topPositionAdjustment)(nodeType), "px)")
      }, bottom);
    }
    var height = (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_sticky_controls') ? (0, _dragHandlePositions.getControlHeightCSSValue)((0, _dragHandlePositions.getNodeHeight)(dom, safeAnchorName, anchorRectCache) || 0, isSticky, isTopLevelNode, "".concat(_consts.DRAG_HANDLE_HEIGHT), isLayoutColumn) : {};
    return _objectSpread({
      left: isEdgeCase ? "calc(".concat((dom === null || dom === void 0 ? void 0 : dom.offsetLeft) || 0, "px + ").concat((0, _dragHandlePositions.getLeftPosition)(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType), ")") : (0, _dragHandlePositions.getLeftPosition)(dom, nodeType, innerContainer, isMacroInteractionUpdates, parentNodeType),
      top: (0, _dragHandlePositions.getTopPosition)(dom, nodeType)
    }, height);
  }, [anchorName, getPos, view, nodeType, blockCardWidth, macroInteractionUpdates, anchorRectCache, isTopLevelNode, isLayoutColumn]);
  var _useState7 = (0, _react.useState)({
      display: 'none'
    }),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    positionStyles = _useState8[0],
    setPositionStyles = _useState8[1];
  (0, _react.useEffect)(function () {
    var cleanUpTransitionListener;
    if (nodeType === 'extension' || nodeType === 'embedCard') {
      var dom = view.dom.querySelector("[data-drag-handler-anchor-name=\"".concat(anchorName, "\"]"));
      if (!dom) {
        return;
      }
      cleanUpTransitionListener = (0, _bindEventListener.bind)(dom, {
        type: 'transitionend',
        listener: function listener() {
          setPositionStyles(calculatePosition());
        }
      });
    }
    var calcPos = requestAnimationFrame(function () {
      setPositionStyles(calculatePosition());
    });
    return function () {
      var _cleanUpTransitionLis;
      cancelAnimationFrame(calcPos);
      (_cleanUpTransitionLis = cleanUpTransitionListener) === null || _cleanUpTransitionLis === void 0 || _cleanUpTransitionLis();
    };
  }, [calculatePosition, view.dom, anchorName, nodeType]);
  (0, _react.useEffect)(function () {
    if (handleOptions !== null && handleOptions !== void 0 && handleOptions.isFocused && buttonRef.current && (0, _platformFeatureFlags.fg)('platform_editor_element_drag_and_drop_ed_23873')) {
      var id = requestAnimationFrame(function () {
        var _buttonRef$current2;
        (_buttonRef$current2 = buttonRef.current) === null || _buttonRef$current2 === void 0 || _buttonRef$current2.focus();
      });
      return function () {
        cancelAnimationFrame(id);
        view.focus();
      };
    }
  }, [buttonRef, handleOptions === null || handleOptions === void 0 ? void 0 : handleOptions.isFocused, view]);
  (0, _react.useEffect)(function () {
    if (!isMultiSelect || typeof start !== 'number' || !selection) {
      return;
    }
    setDragHandleSelected((0, _getSelection.isHandleCorrelatedToSelection)(view.state, selection, start));
  }, [start, selection, view.state, isMultiSelect]);
  (0, _react.useEffect)(function () {
    var _api$blockControls$sh4;
    if (!isMultiSelect || isShiftDown === undefined || view.state.selection.empty || !(0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_shift_click_select')) {
      return;
    }
    var mSelect = api === null || api === void 0 || (_api$blockControls$sh4 = api.blockControls.sharedState.currentState()) === null || _api$blockControls$sh4 === void 0 ? void 0 : _api$blockControls$sh4.multiSelectDnD;
    var $anchor = (mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) !== undefined ? view.state.doc.resolve(mSelect === null || mSelect === void 0 ? void 0 : mSelect.anchor) : view.state.selection.$anchor;
    if (isShiftDown && (!isTopLevelNode || isTopLevelNode && $anchor.depth > _consts.DRAG_HANDLE_MAX_SHIFT_CLICK_DEPTH)) {
      setDragHandleDisabled(true);
    } else {
      setDragHandleDisabled(false);
    }
  }, [api === null || api === void 0 ? void 0 : api.blockControls.sharedState, isMultiSelect, isShiftDown, isTopLevelNode, view.state.doc, view.state.selection]);
  var helpDescriptors = isTopLevelNode ? [{
    description: formatMessage(_messages.blockControlsMessages.dragToMove)
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveUp),
    keymap: _keymaps.dragToMoveUp
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveDown),
    keymap: _keymaps.dragToMoveDown
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveLeft),
    keymap: _keymaps.dragToMoveLeft
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveRight),
    keymap: _keymaps.dragToMoveRight
  }] : [{
    description: formatMessage(_messages.blockControlsMessages.dragToMove)
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveUp),
    keymap: _keymaps.dragToMoveUp
  }, {
    description: formatMessage(_messages.blockControlsMessages.moveDown),
    keymap: _keymaps.dragToMoveDown
  }];
  var isParentNodeOfTypeLayout;
  if (!isTopLevelNode) {
    var pos = getPos();
    if (typeof pos === 'number') {
      var _$pos$parent;
      var $pos = view.state.doc.resolve(pos);
      isParentNodeOfTypeLayout = ($pos === null || $pos === void 0 || (_$pos$parent = $pos.parent) === null || _$pos$parent === void 0 ? void 0 : _$pos$parent.type.name) === 'layoutColumn';
    }
    if (isParentNodeOfTypeLayout) {
      helpDescriptors = [].concat((0, _toConsumableArray2.default)(helpDescriptors), [{
        description: formatMessage(_messages.blockControlsMessages.moveLeft),
        keymap: _keymaps.dragToMoveLeft
      }, {
        description: formatMessage(_messages.blockControlsMessages.moveRight),
        keymap: _keymaps.dragToMoveRight
      }]);
    }
  }

  // When advanced layout is on, layout column drag handle show only show 'Drag to move', no shortcuts
  if ((0, _experiments.editorExperiment)('advanced_layouts', true) && nodeType === 'layoutColumn') {
    helpDescriptors = [{
      description: formatMessage(_messages.blockControlsMessages.dragToRearrange)
    }, {
      description: formatMessage(_messages.blockControlsMessages.moveUp),
      keymap: _keymaps.dragToMoveUp
    }, {
      description: formatMessage(_messages.blockControlsMessages.moveDown),
      keymap: _keymaps.dragToMoveDown
    }, {
      description: formatMessage(_messages.blockControlsMessages.moveLeft),
      keymap: _keymaps.dragToMoveLeft
    }, {
      description: formatMessage(_messages.blockControlsMessages.moveRight),
      keymap: _keymaps.dragToMoveRight
    }];
  }
  if ((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    helpDescriptors = [{
      description: formatMessage(_messages.blockControlsMessages.dragToMove)
    }];
  }
  var message = helpDescriptors.map(function (descriptor) {
    return descriptor.keymap ? [descriptor.description, (0, _keymaps.getAriaKeyshortcuts)(descriptor.keymap)] : [descriptor.description];
  }).join('. ');
  var handleOnDrop = function handleOnDrop(event) {
    (0, _experiments.editorExperiment)('platform_editor_element_drag_and_drop_multiselect', true) && event.stopPropagation();
  };
  var renderButton = function renderButton() {
    return (
      // eslint-disable-next-line @atlaskit/design-system/no-html-button
      (0, _react2.jsx)("button", {
        type: "button",
        css: [(0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_sticky_controls') ? dragHandleButtonStyles : dragHandleButtonStylesOld, (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && dragHandleColor,
        // ED-26266: Fixed the drag handle highlight when selecting multiple line in Firefox
        // See https://product-fabric.atlassian.net/browse/ED-26266
        _browser.browser.gecko && (0, _platformFeatureFlags.fg)('platform_editor_dnd_handle_highlight_fix_firefox') && dragHandleMultiLineSelectionFixFirefox, (0, _experiments.editorExperiment)('advanced_layouts', true) && isLayoutColumn && layoutColumnDragHandleStyles, dragHandleSelected && (!(0, _platformFeatureFlags.fg)('platform_editor_no_selection_until_interaction') || hasHadInteraction) && selectedStyles],
        ref: buttonRef
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
        ,
        style: !((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_sticky_controls')) && positionStyles || {},
        onClick: handleOnClick,
        onMouseDown: handleMouseDown,
        onKeyDown: handleKeyDown
        // eslint-disable-next-line @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop
        ,
        onDrop: handleOnDrop,
        disabled: dragHandleDisabled,
        "data-editor-block-ctrl-drag-handle": true,
        "data-testid": "block-ctrl-drag-handle"
      }, (0, _react2.jsx)(_primitives.Box, {
        xcss: iconWrapperStyles
        // eslint-disable-next-line @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop
        ,
        onDragStart: handleIconDragStart
      }, (0, _react2.jsx)(_dragHandleVertical.default, {
        spacing: "spacious",
        label: "",
        LEGACY_fallbackIcon: _dragHandler.default,
        LEGACY_size: "medium"
      })))
    );
  };
  var stickyWithTooltip = function stickyWithTooltip() {
    return (0, _react2.jsx)(_primitives.Box
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    , {
      style: positionStyles,
      xcss: [dragHandleContainerStyles],
      as: "span",
      testId: "block-ctrl-drag-handle-container"
    }, (0, _react2.jsx)("span", {
      css: [tooltipContainerStyles, (0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithMask, !(0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithoutMask]
    }, (0, _react2.jsx)(_tooltip.default, {
      content: (0, _react2.jsx)(_keymaps.TooltipContentWithMultipleShortcuts, {
        helpDescriptors: helpDescriptors
      }),
      ignoreTooltipPointerEvents: true,
      position: 'top',
      onShow: function onShow() {
        var _api$accessibilityUti;
        api === null || api === void 0 || (_api$accessibilityUti = api.accessibilityUtils) === null || _api$accessibilityUti === void 0 || _api$accessibilityUti.actions.ariaNotify(message, {
          priority: 'important'
        });
      }
    }, (0, _react2.jsx)("span", {
      css: [(0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && buttonWrapperStyles]
    }, renderButton()))));
  };
  var stickyWithoutTooltip = function stickyWithoutTooltip() {
    return (0, _react2.jsx)(_primitives.Box
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    , {
      style: positionStyles,
      xcss: [dragHandleContainerStyles],
      as: "span",
      testId: "block-ctrl-drag-handle-container"
    }, (0, _react2.jsx)("span", {
      css: [tooltipContainerStyles, (0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithMask, !(0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && tooltipContainerStylesStickyHeaderWithoutMask]
    }, (0, _react2.jsx)("span", {
      css: [(0, _dragHandlePositions.shouldMaskNodeControls)(nodeType, isTopLevelNode) && buttonWrapperStyles]
    }, renderButton())));
  };
  var buttonWithTooltip = function buttonWithTooltip() {
    return (0, _react2.jsx)(_tooltip.default, {
      content: (0, _react2.jsx)(_keymaps.TooltipContentWithMultipleShortcuts, {
        helpDescriptors: helpDescriptors
      }),
      ignoreTooltipPointerEvents: true,
      onShow: function onShow() {
        var _api$accessibilityUti2;
        api === null || api === void 0 || (_api$accessibilityUti2 = api.accessibilityUtils) === null || _api$accessibilityUti2 === void 0 || _api$accessibilityUti2.actions.ariaNotify(message, {
          priority: 'important'
        });
      }
    }, renderButton());
  };
  var isTooltip = !dragHandleDisabled && (0, _platformFeatureFlags.fg)('platform_editor_element_drag_and_drop_ed_23873');
  var stickyRender = isTooltip ? stickyWithTooltip() : stickyWithoutTooltip();
  var render = isTooltip ? buttonWithTooltip() : renderButton();
  return (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_sticky_controls') ? stickyRender : render;
};
var DragHandleWithVisibility = exports.DragHandleWithVisibility = function DragHandleWithVisibility(_ref8) {
  var view = _ref8.view,
    api = _ref8.api,
    formatMessage = _ref8.formatMessage,
    getPos = _ref8.getPos,
    anchorName = _ref8.anchorName,
    nodeType = _ref8.nodeType,
    anchorRectCache = _ref8.anchorRectCache;
  return (0, _react2.jsx)(_visibilityContainer.VisibilityContainer, {
    api: api
  }, (0, _react2.jsx)(DragHandle, {
    view: view,
    api: api,
    formatMessage: formatMessage,
    getPos: getPos,
    anchorName: anchorName,
    nodeType: nodeType,
    anchorRectCache: anchorRectCache
  }));
};