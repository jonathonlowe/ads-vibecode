"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.key = exports.getDecorations = exports.createPlugin = exports.apply = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _rafSchd = _interopRequireDefault(require("raf-schd"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _browser = require("@atlaskit/editor-common/browser");
var _performanceMeasures = require("@atlaskit/editor-common/performance-measures");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _utils = require("@atlaskit/editor-common/utils");
var _state = require("@atlaskit/editor-prosemirror/state");
var _view2 = require("@atlaskit/editor-prosemirror/view");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _element = require("@atlaskit/pragmatic-drag-and-drop-auto-scroll/element");
var _combine = require("@atlaskit/pragmatic-drag-and-drop/combine");
var _adapter = require("@atlaskit/pragmatic-drag-and-drop/element/adapter");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _consts = require("../ui/consts");
var _decorationsAnchor = require("./decorations-anchor");
var _decorationsDragHandle = require("./decorations-drag-handle");
var _decorationsDropTarget = require("./decorations-drop-target");
var _decorationsQuickInsertButton = require("./decorations-quick-insert-button");
var _handleMouseDown = require("./handle-mouse-down");
var _handleMouseOver = require("./handle-mouse-over");
var _keymap = require("./keymap");
var _activeAnchorTracker = require("./utils/active-anchor-tracker");
var _analytics2 = require("./utils/analytics");
var _anchorUtils = require("./utils/anchor-utils");
var _getSelection = require("./utils/getSelection");
var _selection2 = require("./utils/selection");
var _transactions = require("./utils/transactions");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var key = exports.key = new _state.PluginKey('blockControls');
var EDITOR_BLOCKS_DRAG_INIT = 'Editor Blocks Drag Initialization Time';
var isHTMLElement = function isHTMLElement(element) {
  return element instanceof HTMLElement;
};
var destroyFn = function destroyFn(api, editorView) {
  var scrollable = document.querySelector('.fabric-editor-popup-scroll-parent');
  var cleanupFn = [];
  if (scrollable) {
    cleanupFn.push((0, _element.autoScrollForElements)({
      element: scrollable
    }));
  }
  cleanupFn.push((0, _adapter.monitorForElements)({
    canMonitor: function canMonitor(_ref) {
      var source = _ref.source;
      return source.data.type === 'element';
    },
    onDrag: function onDrag() {
      if ((0, _performanceMeasures.isMeasuring)(EDITOR_BLOCKS_DRAG_INIT)) {
        (0, _performanceMeasures.stopMeasure)(EDITOR_BLOCKS_DRAG_INIT, function (duration, startTime) {
          var _api$analytics;
          var state = editorView.state;
          api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 || _api$analytics.actions.fireAnalyticsEvent({
            action: _analytics.ACTION.BLOCKS_DRAG_INIT,
            actionSubject: _analytics.ACTION_SUBJECT.EDITOR,
            eventType: _analytics.EVENT_TYPE.OPERATIONAL,
            attributes: {
              duration: duration,
              startTime: startTime,
              nodesCount: state.doc.nodeSize
            }
          });
        });
      }
    },
    onDragStart: function onDragStart() {
      if (isHTMLElement(scrollable)) {
        scrollable.style.setProperty('scroll-behavior', 'unset');
      }
    },
    onDrop: function onDrop(_ref2) {
      var _api$core;
      var location = _ref2.location,
        source = _ref2.source;
      if (isHTMLElement(scrollable)) {
        scrollable.style.setProperty('scroll-behavior', null);
      }
      if (!api) {
        return;
      }
      (_api$core = api.core) === null || _api$core === void 0 || _api$core.actions.execute(function (_ref3) {
        var tr = _ref3.tr;
        var isMultiSelect = (0, _experiments.editorExperiment)('platform_editor_element_drag_and_drop_multiselect', true);
        if (isMultiSelect) {
          var _api$blockControls, _api$selection;
          var _ref4 = ((_api$blockControls = api.blockControls) === null || _api$blockControls === void 0 ? void 0 : _api$blockControls.sharedState.currentState()) || {},
            multiSelectDnD = _ref4.multiSelectDnD;
          // Restore the users initial Editor selection when the drop completes
          if (multiSelectDnD) {
            // If the TextSelection between the drag start and end has changed, the document has changed, and we should not reapply the last selection
            var expandedSelectionUnchanged = multiSelectDnD.textAnchor === tr.selection.anchor && multiSelectDnD.textHead === tr.selection.head;
            if (expandedSelectionUnchanged) {
              var $anchor = tr.doc.resolve(multiSelectDnD.userAnchor);
              var $head = tr.doc.resolve(multiSelectDnD.userHead);
              if ($head.node() === $anchor.node()) {
                var $from = $anchor.min($head);
                (0, _getSelection.selectNode)(tr, $from.pos, $from.node().type.name);
              } else {
                tr.setSelection(_state.TextSelection.create(tr.doc, multiSelectDnD.userAnchor, multiSelectDnD.userHead));
              }
            }
          }
          (_api$selection = api.selection) === null || _api$selection === void 0 || _api$selection.commands.clearManualSelection()({
            tr: tr
          });
        }
        var _ref5 = source.data,
          start = _ref5.start;
        // if no drop targets are rendered, assume that drop is invalid
        var lastDragCancelled = location.current.dropTargets.length === 0;
        if (lastDragCancelled) {
          var _api$analytics2;
          var nodeTypes, hasSelectedMultipleNodes;
          if (isMultiSelect) {
            var position = (0, _selection2.getSelectedSlicePosition)(start, tr, api);
            var attributes = (0, _analytics2.getMultiSelectAnalyticsAttributes)(tr, position.from, position.to);
            nodeTypes = attributes.nodeTypes;
            hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
          }
          var resolvedMovingNode = tr.doc.resolve(start);
          var maybeNode = resolvedMovingNode.nodeAfter;
          (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 || _api$analytics2.actions.attachAnalyticsEvent({
            eventType: _analytics.EVENT_TYPE.UI,
            action: _analytics.ACTION.CANCELLED,
            actionSubject: _analytics.ACTION_SUBJECT.DRAG,
            actionSubjectId: _analytics.ACTION_SUBJECT_ID.ELEMENT_DRAG_HANDLE,
            attributes: _objectSpread({
              nodeDepth: resolvedMovingNode.depth,
              nodeType: (maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.type.name) || ''
            }, isMultiSelect && {
              nodeTypes: nodeTypes,
              hasSelectedMultipleNodes: hasSelectedMultipleNodes
            })
          })(tr);
        }
        if ((0, _platformFeatureFlags.fg)('platform_editor_ease_of_use_metrics')) {
          var _api$metrics;
          (_api$metrics = api.metrics) === null || _api$metrics === void 0 || _api$metrics.commands.startActiveSessionTimer()({
            tr: tr
          });
        }
        if ((0, _platformFeatureFlags.fg)('platform_editor_user_intent_plugin')) {
          var _api$userIntent;
          (_api$userIntent = api.userIntent) === null || _api$userIntent === void 0 || _api$userIntent.commands.setCurrentUserIntent('default')({
            tr: tr
          });
        }
        return tr.setMeta(key, _objectSpread(_objectSpread({}, tr.getMeta(key)), {}, {
          isDragging: false,
          isPMDragging: false,
          lastDragCancelled: lastDragCancelled
        }));
      });
    }
  }));
  return _combine.combine.apply(void 0, cleanupFn);
};
var initialState = {
  decorations: _view2.DecorationSet.empty,
  activeNode: undefined,
  isDragging: false,
  isMenuOpen: false,
  editorHeight: 0,
  editorWidthLeft: 0,
  editorWidthRight: 0,
  isResizerResizing: false,
  isDocSizeLimitEnabled: null,
  isPMDragging: false,
  multiSelectDnD: undefined,
  lastDragCancelled: false,
  isSelectedViaDragHandle: false
};
var getDecorations = exports.getDecorations = function getDecorations(state) {
  var _key$getState;
  return (_key$getState = key.getState(state)) === null || _key$getState === void 0 ? void 0 : _key$getState.decorations;
};
var getDecorationAtPos = function getDecorationAtPos(decorations, pos, to) {
  // Find the newly minted node decs that touch the active node
  var findNewNodeDecs = (0, _decorationsAnchor.findNodeDecs)(decorations, pos - 1, to);

  // Find the specific dec that the active node corresponds to
  var nodeDecsAtActivePos = findNewNodeDecs.filter(function (dec) {
    return (dec === null || dec === void 0 ? void 0 : dec.from) === pos;
  });

  // If multiple decorations at the active node pos, we want the last one
  var nodeDecAtActivePos = nodeDecsAtActivePos.pop();
  return nodeDecAtActivePos;
};
var _apply = exports.apply = function apply(api, formatMessage, tr, currentState, newState, flags, nodeViewPortalProviderAPI, anchorRectCache) {
  var _meta$multiSelectDnD, _activeNode, _activeNode2, _meta$activeNode$hand, _activeNode3, _activeNode4, _meta$isDragging, _meta$isDragging2, _meta$toggleMenu, _meta$editorHeight, _meta$editorWidthLeft, _meta$editorWidthRigh, _meta$isPMDragging, _meta$isShiftDown, _meta$lastDragCancell;
  var activeNode = currentState.activeNode,
    decorations = currentState.decorations,
    isResizerResizing = currentState.isResizerResizing,
    multiSelectDnD = currentState.multiSelectDnD;
  var editorHeight = currentState.editorHeight,
    editorWidthLeft = currentState.editorWidthLeft,
    editorWidthRight = currentState.editorWidthRight,
    isDragging = currentState.isDragging,
    isMenuOpen = currentState.isMenuOpen,
    menuTriggerBy = currentState.menuTriggerBy,
    isPMDragging = currentState.isPMDragging,
    isShiftDown = currentState.isShiftDown,
    lastDragCancelled = currentState.lastDragCancelled,
    isSelectedViaDragHandle = currentState.isSelectedViaDragHandle;
  var isActiveNodeDeleted = false;
  var _getTrMetadata = (0, _transactions.getTrMetadata)(tr),
    from = _getTrMetadata.from,
    to = _getTrMetadata.to,
    numReplaceSteps = _getTrMetadata.numReplaceSteps,
    isAllText = _getTrMetadata.isAllText,
    isReplacedWithSameSize = _getTrMetadata.isReplacedWithSameSize;
  var meta = tr.getMeta(key);

  // When steps exist, remap existing decorations, activeNode and multi select positions
  if (tr.docChanged) {
    decorations = decorations.map(tr.mapping, tr.doc);

    // don't remap activeNode if it's being dragged
    if ((0, _experiments.editorExperiment)('platform_editor_controls', 'control')) {
      if (activeNode) {
        var mappedPos = tr.mapping.mapResult(activeNode.pos);
        isActiveNodeDeleted = mappedPos.deleted;
        activeNode = {
          pos: mappedPos.pos,
          anchorName: activeNode.anchorName,
          nodeType: activeNode.nodeType
        };
      }
    } else {
      if (activeNode && (meta === null || meta === void 0 ? void 0 : meta.isDragging) !== true) {
        var _mappedRootPos$pos, _mappedRootPos;
        var _mappedPos = tr.mapping.mapResult(activeNode.pos, -1);
        isActiveNodeDeleted = _mappedPos.deletedAfter;
        // for editor controls, remap the rootPos as well
        var mappedRootPos;
        if (activeNode.rootPos !== undefined) {
          mappedRootPos = tr.mapping.mapResult(activeNode.rootPos, -1);
        }
        activeNode = {
          pos: _mappedPos.pos,
          anchorName: activeNode.anchorName,
          nodeType: activeNode.nodeType,
          rootPos: (_mappedRootPos$pos = (_mappedRootPos = mappedRootPos) === null || _mappedRootPos === void 0 ? void 0 : _mappedRootPos.pos) !== null && _mappedRootPos$pos !== void 0 ? _mappedRootPos$pos : activeNode.rootPos,
          rootAnchorName: activeNode.rootAnchorName,
          rootNodeType: activeNode.rootNodeType
        };
      }
    }
    if (multiSelectDnD && flags.isMultiSelectEnabled) {
      multiSelectDnD.anchor = tr.mapping.map(multiSelectDnD.anchor);
      multiSelectDnD.head = tr.mapping.map(multiSelectDnD.head);
    }
  }
  var resizerMeta = tr.getMeta('is-resizer-resizing');
  isResizerResizing = resizerMeta !== null && resizerMeta !== void 0 ? resizerMeta : isResizerResizing;
  multiSelectDnD = (_meta$multiSelectDnD = meta === null || meta === void 0 ? void 0 : meta.multiSelectDnD) !== null && _meta$multiSelectDnD !== void 0 ? _meta$multiSelectDnD : multiSelectDnD;
  if (multiSelectDnD && flags.isMultiSelectEnabled) {
    multiSelectDnD = (meta === null || meta === void 0 ? void 0 : meta.isDragging) === false || tr.selection.empty ? undefined : multiSelectDnD;
  }
  var maybeNodeCountChanged = !isAllText && numReplaceSteps > 0;
  var latestActiveNode;
  if ((0, _platformFeatureFlags.fg)('platform_editor_remove_drag_handle_fix')) {
    latestActiveNode = meta === null || meta === void 0 ? void 0 : meta.activeNode;
    if (!latestActiveNode && (!isActiveNodeDeleted || isReplacedWithSameSize)) {
      latestActiveNode = activeNode;
    }
  } else {
    var _meta$activeNode;
    latestActiveNode = (_meta$activeNode = meta === null || meta === void 0 ? void 0 : meta.activeNode) !== null && _meta$activeNode !== void 0 ? _meta$activeNode : activeNode;
  }

  // Re-create node decorations
  var isDecSetEmpty = decorations === _view2.DecorationSet.empty;
  var isNodeDecsMissing = isDecSetEmpty || maybeNodeCountChanged;
  var shouldRedrawNodeDecs = !isResizerResizing && ((0, _platformFeatureFlags.fg)('platform_editor_advanced_layouts_redraw_on_drag') ? isNodeDecsMissing || (meta === null || meta === void 0 ? void 0 : meta.isDragging) : isNodeDecsMissing);
  var isActiveNodeModified = false;
  if (api && shouldRedrawNodeDecs) {
    var oldNodeDecs = (0, _decorationsAnchor.findNodeDecs)(decorations, from, to);
    decorations = decorations.remove(oldNodeDecs);
    var newNodeDecs = (0, _decorationsAnchor.nodeDecorations)(newState, isDecSetEmpty ? undefined : from, isDecSetEmpty ? undefined : to);
    decorations = decorations.add(newState.doc, newNodeDecs);
    if ((0, _experiments.editorExperiment)('platform_editor_controls', 'control')) {
      if (latestActiveNode && !isActiveNodeDeleted) {
        // Find the newly minted node decs that touch the active node
        var findNewNodeDecs = (0, _decorationsAnchor.findNodeDecs)(decorations, latestActiveNode.pos - 1, to);

        // Find the specific dec that the active node corresponds to
        var nodeDecsAtActivePos = findNewNodeDecs.filter(function (dec) {
          return (dec === null || dec === void 0 ? void 0 : dec.from) === latestActiveNode.pos;
        });

        // If multiple decorations at the active node pos, we want the last one
        var nodeDecAtActivePos = nodeDecsAtActivePos.pop();

        // Update the active node anchor-name and type for accurate positioning
        if (nodeDecAtActivePos) {
          isActiveNodeModified = true;
          latestActiveNode.anchorName = nodeDecAtActivePos.spec.anchorName;
          latestActiveNode.nodeType = nodeDecAtActivePos.spec.nodeType;
        }
      }
    } else {
      if (latestActiveNode && (!isActiveNodeDeleted || isReplacedWithSameSize)) {
        var _nodeDecAtActivePos = getDecorationAtPos(decorations, latestActiveNode.pos, to);
        var rootNodeDecAtActivePos = getDecorationAtPos(decorations, latestActiveNode.rootPos, to);
        if (_nodeDecAtActivePos || rootNodeDecAtActivePos) {
          isActiveNodeModified = true;
        }

        // Update the active node anchor-name and type for accurate positioning
        if (_nodeDecAtActivePos) {
          latestActiveNode.anchorName = _nodeDecAtActivePos.spec.anchorName;
          latestActiveNode.nodeType = _nodeDecAtActivePos.spec.nodeType;
        }
        if (rootNodeDecAtActivePos) {
          latestActiveNode.rootAnchorName = rootNodeDecAtActivePos.spec.anchorName;
          latestActiveNode.rootNodeType = rootNodeDecAtActivePos.spec.nodeType;
        }
      }
    }
  }

  // Check if editor dimensions have changed
  var editorSizeChanged = (meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== editorHeight || (meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== editorWidthLeft || (meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== undefined && (meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== editorWidthRight;

  // Check if there's a new active node, and it differs from the last
  var activeNodeChanged = (meta === null || meta === void 0 ? void 0 : meta.activeNode) && ((meta === null || meta === void 0 ? void 0 : meta.activeNode.pos) !== ((_activeNode = activeNode) === null || _activeNode === void 0 ? void 0 : _activeNode.pos) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.anchorName) !== ((_activeNode2 = activeNode) === null || _activeNode2 === void 0 ? void 0 : _activeNode2.anchorName) || (meta === null || meta === void 0 || (_meta$activeNode$hand = meta.activeNode.handleOptions) === null || _meta$activeNode$hand === void 0 ? void 0 : _meta$activeNode$hand.isFocused));
  var rootActiveNodeChanged = (meta === null || meta === void 0 ? void 0 : meta.activeNode) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.rootPos) !== ((_activeNode3 = activeNode) === null || _activeNode3 === void 0 ? void 0 : _activeNode3.rootPos) && (meta === null || meta === void 0 ? void 0 : meta.activeNode.rootAnchorName) !== ((_activeNode4 = activeNode) === null || _activeNode4 === void 0 ? void 0 : _activeNode4.rootAnchorName);

  // Some browsers don't support anchor positioning, meaning we need to replace the handle when nodes change
  var handleNeedsRedraw = shouldRedrawNodeDecs && !(0, _anchorUtils.isAnchorSupported)();

  // Create/recreate handle dec when the active node is missing/changes, or the editor viewport has changed (non-anchor pos workaround)
  var shouldRecreateHandle = latestActiveNode && (activeNodeChanged || isActiveNodeModified || editorSizeChanged || handleNeedsRedraw);
  var shouldRecreateQuickInsertButton = latestActiveNode && (rootActiveNodeChanged || isActiveNodeModified || editorSizeChanged || handleNeedsRedraw);
  var shouldRemoveHandle = false;
  if ((0, _platformFeatureFlags.fg)('platform_editor_remove_drag_handle_fix')) {
    // If the active node is missing, we need to remove the handle
    shouldRemoveHandle = latestActiveNode ? isResizerResizing || isActiveNodeDeleted && !isReplacedWithSameSize || (meta === null || meta === void 0 ? void 0 : meta.nodeMoved) : true;
  } else {
    // Remove handle dec when explicitly hidden, a node is resizing, activeNode pos was deleted, or DnD moved a node
    shouldRemoveHandle = latestActiveNode && (isResizerResizing || isActiveNodeDeleted || (meta === null || meta === void 0 ? void 0 : meta.nodeMoved));
  }
  if (shouldRemoveHandle) {
    var _activeNode5, _activeNode6;
    var oldHandle = (0, _decorationsDragHandle.findHandleDec)(decorations, (_activeNode5 = activeNode) === null || _activeNode5 === void 0 ? void 0 : _activeNode5.pos, (_activeNode6 = activeNode) === null || _activeNode6 === void 0 ? void 0 : _activeNode6.pos);
    decorations = decorations.remove(oldHandle);
    if ((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
      var _activeNode7, _activeNode8;
      var oldQuickInsertButton = (0, _decorationsQuickInsertButton.findQuickInsertInsertButtonDecoration)(decorations, (_activeNode7 = activeNode) === null || _activeNode7 === void 0 ? void 0 : _activeNode7.rootPos, (_activeNode8 = activeNode) === null || _activeNode8 === void 0 ? void 0 : _activeNode8.rootPos);
      decorations = decorations.remove(oldQuickInsertButton);
    }
  } else if (api) {
    var _latestActiveNode5;
    if (shouldRecreateHandle) {
      var _activeNode9, _activeNode10, _latestActiveNode, _latestActiveNode2, _latestActiveNode3, _latestActiveNode4;
      var _oldHandle = (0, _decorationsDragHandle.findHandleDec)(decorations, (_activeNode9 = activeNode) === null || _activeNode9 === void 0 ? void 0 : _activeNode9.pos, (_activeNode10 = activeNode) === null || _activeNode10 === void 0 ? void 0 : _activeNode10.pos);
      decorations = decorations.remove(_oldHandle);
      var handleDec = (0, _decorationsDragHandle.dragHandleDecoration)(api, formatMessage, (_latestActiveNode = latestActiveNode) === null || _latestActiveNode === void 0 ? void 0 : _latestActiveNode.pos, (_latestActiveNode2 = latestActiveNode) === null || _latestActiveNode2 === void 0 ? void 0 : _latestActiveNode2.anchorName, (_latestActiveNode3 = latestActiveNode) === null || _latestActiveNode3 === void 0 ? void 0 : _latestActiveNode3.nodeType, nodeViewPortalProviderAPI, (_latestActiveNode4 = latestActiveNode) === null || _latestActiveNode4 === void 0 ? void 0 : _latestActiveNode4.handleOptions, anchorRectCache);
      decorations = decorations.add(newState.doc, [handleDec]);
    }
    if (shouldRecreateQuickInsertButton && ((_latestActiveNode5 = latestActiveNode) === null || _latestActiveNode5 === void 0 ? void 0 : _latestActiveNode5.rootPos) !== undefined && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
      var _activeNode11, _activeNode12, _latestActiveNode6, _latestActiveNode7, _latestActiveNode8, _latestActiveNode9, _latestActiveNode10;
      var _oldQuickInsertButton = (0, _decorationsQuickInsertButton.findQuickInsertInsertButtonDecoration)(decorations, (_activeNode11 = activeNode) === null || _activeNode11 === void 0 ? void 0 : _activeNode11.rootPos, (_activeNode12 = activeNode) === null || _activeNode12 === void 0 ? void 0 : _activeNode12.rootPos);
      decorations = decorations.remove(_oldQuickInsertButton);
      var quickInsertButton = (0, _decorationsQuickInsertButton.quickInsertButtonDecoration)(api, formatMessage, (_latestActiveNode6 = latestActiveNode) === null || _latestActiveNode6 === void 0 ? void 0 : _latestActiveNode6.rootPos, (_latestActiveNode7 = latestActiveNode) === null || _latestActiveNode7 === void 0 ? void 0 : _latestActiveNode7.anchorName, (_latestActiveNode8 = latestActiveNode) === null || _latestActiveNode8 === void 0 ? void 0 : _latestActiveNode8.nodeType, nodeViewPortalProviderAPI, (_latestActiveNode9 = latestActiveNode) === null || _latestActiveNode9 === void 0 ? void 0 : _latestActiveNode9.rootAnchorName, (_latestActiveNode10 = latestActiveNode) === null || _latestActiveNode10 === void 0 ? void 0 : _latestActiveNode10.rootNodeType, anchorRectCache);
      decorations = decorations.add(newState.doc, [quickInsertButton]);
    }
  }

  // Drop targets may be missing when the node count is being changed during a drag
  var isDropTargetsMissing = ((_meta$isDragging = meta === null || meta === void 0 ? void 0 : meta.isDragging) !== null && _meta$isDragging !== void 0 ? _meta$isDragging : isDragging) && maybeNodeCountChanged && !(meta !== null && meta !== void 0 && meta.nodeMoved);

  // Remove drop target decorations when dragging stops or they need to be redrawn
  if ((meta === null || meta === void 0 ? void 0 : meta.isDragging) === false || isDropTargetsMissing) {
    var dropTargetDecs = (0, _decorationsDropTarget.findDropTargetDecs)(decorations);
    decorations = decorations.remove(dropTargetDecs);
  }

  // Add drop targets when dragging starts or some are missing
  if (api) {
    if (meta !== null && meta !== void 0 && meta.isDragging || isDropTargetsMissing) {
      var decs = (0, _decorationsDropTarget.dropTargetDecorations)(newState, api, formatMessage, nodeViewPortalProviderAPI, latestActiveNode, anchorRectCache);
      decorations = decorations.add(newState.doc, decs);
    }
  }
  var isEmptyDoc = (0, _utils.isEmptyDocument)(newState.doc);
  if (isEmptyDoc) {
    var hasNodeDecoration = !!(0, _decorationsAnchor.findNodeDecs)(decorations).length;
    if (!hasNodeDecoration) {
      decorations = decorations.add(newState.doc, [(0, _decorationsDragHandle.emptyParagraphNodeDecorations)()]);
    }
  }
  var newActiveNode;
  if ((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    var _latestActiveNode11, _latestActiveNode12;
    // remove isEmptyDoc check and let decorations render and determine their own visibility
    newActiveNode = !(meta !== null && meta !== void 0 && meta.activeNode) && (0, _decorationsDragHandle.findHandleDec)(decorations, (_latestActiveNode11 = latestActiveNode) === null || _latestActiveNode11 === void 0 ? void 0 : _latestActiveNode11.pos, (_latestActiveNode12 = latestActiveNode) === null || _latestActiveNode12 === void 0 ? void 0 : _latestActiveNode12.pos).length === 0 ? null : latestActiveNode;
  } else {
    var _latestActiveNode13, _latestActiveNode14;
    newActiveNode = isEmptyDoc || !(meta !== null && meta !== void 0 && meta.activeNode) && (0, _decorationsDragHandle.findHandleDec)(decorations, (_latestActiveNode13 = latestActiveNode) === null || _latestActiveNode13 === void 0 ? void 0 : _latestActiveNode13.pos, (_latestActiveNode14 = latestActiveNode) === null || _latestActiveNode14 === void 0 ? void 0 : _latestActiveNode14.pos).length === 0 ? null : latestActiveNode;
  }
  var isMenuOpenNew = isMenuOpen;
  if (_consts.BLOCK_MENU_ENABLED && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    if (meta !== null && meta !== void 0 && meta.closeMenu) {
      isMenuOpenNew = false;
    } else if (meta !== null && meta !== void 0 && meta.toggleMenu) {
      var isSameAnchor = (meta === null || meta === void 0 ? void 0 : meta.toggleMenu.anchorName) === menuTriggerBy;
      isMenuOpenNew = menuTriggerBy === undefined || isSameAnchor || !isMenuOpen && !isSameAnchor ? !isMenuOpen : isMenuOpen;
    }
  } else if (meta !== null && meta !== void 0 && meta.toggleMenu) {
    isMenuOpenNew = !isMenuOpen;
  }
  var isSelectedViaDragHandleNew = (meta === null || meta === void 0 ? void 0 : meta.isSelectedViaDragHandle) !== undefined && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_5') ? meta === null || meta === void 0 ? void 0 : meta.isSelectedViaDragHandle : isSelectedViaDragHandle;
  return {
    decorations: decorations,
    activeNode: newActiveNode,
    isDragging: (_meta$isDragging2 = meta === null || meta === void 0 ? void 0 : meta.isDragging) !== null && _meta$isDragging2 !== void 0 ? _meta$isDragging2 : isDragging,
    isMenuOpen: isMenuOpenNew,
    menuTriggerBy: (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') ? (meta === null || meta === void 0 || (_meta$toggleMenu = meta.toggleMenu) === null || _meta$toggleMenu === void 0 ? void 0 : _meta$toggleMenu.anchorName) || menuTriggerBy : undefined,
    editorHeight: (_meta$editorHeight = meta === null || meta === void 0 ? void 0 : meta.editorHeight) !== null && _meta$editorHeight !== void 0 ? _meta$editorHeight : editorHeight,
    editorWidthLeft: (_meta$editorWidthLeft = meta === null || meta === void 0 ? void 0 : meta.editorWidthLeft) !== null && _meta$editorWidthLeft !== void 0 ? _meta$editorWidthLeft : editorWidthLeft,
    editorWidthRight: (_meta$editorWidthRigh = meta === null || meta === void 0 ? void 0 : meta.editorWidthRight) !== null && _meta$editorWidthRigh !== void 0 ? _meta$editorWidthRigh : editorWidthRight,
    isResizerResizing: isResizerResizing,
    isDocSizeLimitEnabled: initialState.isDocSizeLimitEnabled,
    isPMDragging: (_meta$isPMDragging = meta === null || meta === void 0 ? void 0 : meta.isPMDragging) !== null && _meta$isPMDragging !== void 0 ? _meta$isPMDragging : isPMDragging,
    multiSelectDnD: multiSelectDnD,
    isShiftDown: (_meta$isShiftDown = meta === null || meta === void 0 ? void 0 : meta.isShiftDown) !== null && _meta$isShiftDown !== void 0 ? _meta$isShiftDown : isShiftDown,
    lastDragCancelled: (_meta$lastDragCancell = meta === null || meta === void 0 ? void 0 : meta.lastDragCancelled) !== null && _meta$lastDragCancell !== void 0 ? _meta$lastDragCancell : lastDragCancelled,
    isSelectedViaDragHandle: isSelectedViaDragHandleNew
  };
};
var createPlugin = exports.createPlugin = function createPlugin(api, getIntl, nodeViewPortalProviderAPI) {
  var _getIntl = getIntl(),
    formatMessage = _getIntl.formatMessage;
  var isAdvancedLayoutEnabled = (0, _experiments.editorExperiment)('advanced_layouts', true, {
    exposure: true
  });
  var isMultiSelectEnabled = (0, _experiments.editorExperiment)('platform_editor_element_drag_and_drop_multiselect', true, {
    exposure: true
  });
  var flags = {
    isMultiSelectEnabled: isMultiSelectEnabled
  };
  var anchorRectCache;
  if (!(0, _anchorUtils.isAnchorSupported)()) {
    anchorRectCache = new _anchorUtils.AnchorRectCache();
  }
  return new _safePlugin.SafePlugin({
    key: key,
    state: {
      init: function init() {
        return initialState;
      },
      apply: function apply(tr, currentState, _, newState) {
        return _apply(api, formatMessage, tr, currentState, newState, flags, nodeViewPortalProviderAPI, anchorRectCache);
      }
    },
    props: {
      decorations: function decorations(state) {
        var _api$editorDisabled, _key$getState2;
        var isDisabled = api === null || api === void 0 || (_api$editorDisabled = api.editorDisabled) === null || _api$editorDisabled === void 0 || (_api$editorDisabled = _api$editorDisabled.sharedState.currentState()) === null || _api$editorDisabled === void 0 ? void 0 : _api$editorDisabled.editorDisabled;
        if (isDisabled) {
          return;
        }
        return (_key$getState2 = key.getState(state)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.decorations;
      },
      handleDOMEvents: {
        drop: function drop(view, event) {
          var _pluginState, _pluginState2, _pluginState3, _event$target, _event$target$closest;
          // Prevent native DnD from triggering if we are in drag
          var dispatch = view.dispatch,
            dragging = view.dragging,
            state = view.state;
          var tr = state.tr;
          var pluginState = key.getState(state);
          var dndDragCancelled = (_pluginState = pluginState) === null || _pluginState === void 0 ? void 0 : _pluginState.lastDragCancelled;
          if ((_pluginState2 = pluginState) !== null && _pluginState2 !== void 0 && _pluginState2.isPMDragging || dndDragCancelled && isMultiSelectEnabled) {
            if ((0, _platformFeatureFlags.fg)('platform_editor_ease_of_use_metrics')) {
              var _api$metrics2;
              api === null || api === void 0 || (_api$metrics2 = api.metrics) === null || _api$metrics2 === void 0 || _api$metrics2.commands.startActiveSessionTimer()({
                tr: tr
              });
            }
            dispatch(tr.setMeta(key, _objectSpread(_objectSpread({}, tr.getMeta(key)), {}, {
              isPMDragging: false,
              lastDragCancelled: false
            })));
          }
          pluginState = key.getState(view.state);
          if (!(event.target instanceof HTMLElement) || !((_pluginState3 = pluginState) !== null && _pluginState3 !== void 0 && _pluginState3.activeNode)) {
            return false;
          }
          // Currently we can only drag one node at a time
          // so we only need to check first child
          var draggable = dragging === null || dragging === void 0 ? void 0 : dragging.slice.content.firstChild;
          if (dndDragCancelled && isMultiSelectEnabled || (draggable === null || draggable === void 0 ? void 0 : draggable.type.name) === 'layoutColumn') {
            // we prevent native DnD for layoutColumn to prevent single column layout.
            event.preventDefault();
            return false;
          }
          var nodeElement = (_event$target = event.target) === null || _event$target === void 0 || (_event$target$closest = _event$target.closest) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.call(_event$target, '[data-drag-handler-anchor-name]');
          if (!nodeElement) {
            return false;
          }

          // TODO: ED-26959 - Review usage of posAtDOM here
          var domPos = Math.max(view.posAtDOM(nodeElement, 0) - 1, 0);
          var nodeTarget = state.doc.nodeAt(domPos);
          var isSameNode = !!(nodeTarget && draggable !== null && draggable !== void 0 && draggable.eq(nodeTarget));
          if (isSameNode) {
            event.preventDefault();
            return true;
          }
          return false;
        },
        dragenter: function dragenter(_view, event) {
          if (isAdvancedLayoutEnabled) {
            if (isHTMLElement(event.target)) {
              var closestParentElement = event.target.closest('[data-drag-handler-anchor-depth="0"]');
              if (closestParentElement) {
                var currentAnchor = closestParentElement.getAttribute('data-drag-handler-anchor-name');
                if (currentAnchor) {
                  _activeAnchorTracker.defaultActiveAnchorTracker.emit(currentAnchor);
                }
              }
            }
          }
        },
        dragstart: function dragstart(view) {
          var _anchorRectCache;
          (0, _performanceMeasures.startMeasure)(EDITOR_BLOCKS_DRAG_INIT);
          if (isAdvancedLayoutEnabled) {
            _activeAnchorTracker.defaultActiveAnchorTracker.reset();
          }
          (_anchorRectCache = anchorRectCache) === null || _anchorRectCache === void 0 || _anchorRectCache.setEditorView(view);
          view.dispatch(view.state.tr.setMeta(key, _objectSpread(_objectSpread({}, view.state.tr.getMeta(key)), {}, {
            isPMDragging: true
          })));
        },
        dragend: function dragend(view) {
          var _key$getState3;
          var state = view.state,
            dispatch = view.dispatch;
          if ((_key$getState3 = key.getState(state)) !== null && _key$getState3 !== void 0 && _key$getState3.isPMDragging) {
            var tr = state.tr;
            tr.setMeta(key, _objectSpread(_objectSpread({}, state.tr.getMeta(key)), {}, {
              isPMDragging: false
            }));
            if ((0, _platformFeatureFlags.fg)('platform_editor_ease_of_use_metrics')) {
              var _api$metrics3;
              api === null || api === void 0 || (_api$metrics3 = api.metrics) === null || _api$metrics3 === void 0 || _api$metrics3.commands.startActiveSessionTimer()({
                tr: tr
              });
            }
            dispatch(tr);
          }
        },
        mouseover: function mouseover(view, event) {
          (0, _handleMouseOver.handleMouseOver)(view, event, api);
          return false;
        },
        mousedown: (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_2') ? (0, _handleMouseDown.handleMouseDown)(api) : undefined,
        keydown: function keydown(view, event) {
          if (isMultiSelectEnabled) {
            if (event.shiftKey && event.ctrlKey) {
              //prevent holding down key combo from firing repeatedly
              if (!event.repeat && (0, _keymap.boundKeydownHandler)(api, formatMessage)(view, event)) {
                event.preventDefault();
                return true;
              }
            }

            // Command + Shift + ArrowUp to select was broken with the plugin enabled so this manually sets the selection
            var _view$state = view.state,
              selection = _view$state.selection,
              doc = _view$state.doc,
              tr = _view$state.tr;
            var metaKey = _browser.browser.mac ? event.metaKey : event.ctrlKey;
            if (event.key === 'ArrowUp' && event.shiftKey && metaKey) {
              if (selection instanceof _state.TextSelection || selection instanceof _state.NodeSelection) {
                var newSelection = _state.TextSelection.create(doc, selection.head, 1);
                view.dispatch(tr.setSelection(newSelection));
                return true;
              }
            }
            if ((event.key === 'Enter' || event.key === ' ') && event.target instanceof HTMLElement && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_5')) {
              var isDragHandle = event.target.closest('[data-editor-block-ctrl-drag-handle="true"]') !== null;
              api === null || api === void 0 || api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(isDragHandle));
            }
            if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowDown' || event.key === 'ArrowUp') && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_5')) {
              var _api$blockControls$sh;
              if (api !== null && api !== void 0 && (_api$blockControls$sh = api.blockControls.sharedState.currentState()) !== null && _api$blockControls$sh !== void 0 && _api$blockControls$sh.isSelectedViaDragHandle) {
                api === null || api === void 0 || api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(false));
              }
            }
            if (!event.repeat && event.shiftKey && (0, _platformFeatureFlags.fg)('platform_editor_elements_dnd_shift_click_select')) {
              view.dispatch(view.state.tr.setMeta(key, _objectSpread(_objectSpread({}, view.state.tr.getMeta(key)), {}, {
                isShiftDown: true
              })));
            }
            return false;
          } else {
            // Command + Shift + ArrowUp to select was broken with the plugin enabled so this manually sets the selection
            var _view$state2 = view.state,
              _selection = _view$state2.selection,
              _doc = _view$state2.doc,
              _tr = _view$state2.tr;
            var _metaKey = _browser.browser.mac ? event.metaKey : event.ctrlKey;
            if (event.key === 'ArrowUp' && event.shiftKey && _metaKey) {
              if (_selection instanceof _state.TextSelection || _selection instanceof _state.NodeSelection) {
                var _newSelection = _state.TextSelection.create(_doc, _selection.head, 1);
                view.dispatch(_tr.setSelection(_newSelection));
                return true;
              }
            }
            if (event.shiftKey && event.ctrlKey) {
              //prevent holding down key combo from firing repeatedly
              if (!event.repeat && (0, _keymap.boundKeydownHandler)(api, formatMessage)(view, event)) {
                event.preventDefault();
                return true;
              }
            }
            if ((event.key === 'Enter' || event.key === ' ') && event.target instanceof HTMLElement && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_5')) {
              var _isDragHandle = event.target.closest('[data-editor-block-ctrl-drag-handle="true"]') !== null;
              api === null || api === void 0 || api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(_isDragHandle));
            }
            if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowDown' || event.key === 'ArrowUp') && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_5')) {
              var _api$blockControls$sh2;
              if (api !== null && api !== void 0 && (_api$blockControls$sh2 = api.blockControls.sharedState.currentState()) !== null && _api$blockControls$sh2 !== void 0 && _api$blockControls$sh2.isSelectedViaDragHandle) {
                api === null || api === void 0 || api.core.actions.execute(api === null || api === void 0 ? void 0 : api.blockControls.commands.setSelectedViaDragHandle(false));
              }
            }
          }
        },
        keyup: function keyup(view, event) {
          if (!event.repeat && event.key === 'Shift') {
            view.dispatch(view.state.tr.setMeta(key, _objectSpread(_objectSpread({}, view.state.tr.getMeta(key)), {}, {
              isShiftDown: false
            })));
          }
        }
      }
    },
    view: function view(editorView) {
      var dom = editorView.dom;
      var editorContentArea = editorView.dom.closest('.fabric-editor-popup-scroll-parent');

      // Use ResizeObserver to observe resizer (scroll-parent typically grows when resizing) and editor width changes
      var resizeObserverWidth = new ResizeObserver((0, _rafSchd.default)(function (entries) {
        var pluginState = key.getState(editorView.state);
        if (!(pluginState !== null && pluginState !== void 0 && pluginState.isDragging)) {
          var isResizerResizing = !!dom.querySelector('.is-resizing');
          var transaction = editorView.state.tr;
          if ((pluginState === null || pluginState === void 0 ? void 0 : pluginState.isResizerResizing) !== isResizerResizing) {
            transaction.setMeta('is-resizer-resizing', isResizerResizing);
          }
          if (!isResizerResizing) {
            var _editorContentArea = entries[0].target;
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var editorWidthRight = _editorContentArea.getBoundingClientRect().right;
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var editorWidthLeft = _editorContentArea.getBoundingClientRect().left;
            transaction.setMeta(key, _objectSpread(_objectSpread({}, transaction.getMeta(key)), {}, {
              editorWidthLeft: editorWidthLeft,
              editorWidthRight: editorWidthRight
            }));
          }
          editorView.dispatch(transaction);
        }
      }));
      if (editorContentArea) {
        resizeObserverWidth.observe(editorContentArea);
      }

      // Start pragmatic monitors
      var pragmaticCleanup = destroyFn(api, editorView);
      return {
        destroy: function destroy() {
          if (editorContentArea) {
            resizeObserverWidth.unobserve(editorContentArea);
          }
          pragmaticCleanup();
        }
      };
    }
  });
};