"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useActiveAnchorTracker = exports.defaultActiveAnchorTracker = exports.ActiveAnchorTracker = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _events = require("events");
var _react = require("react");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var ActiveAnchorTracker = exports.ActiveAnchorTracker = /*#__PURE__*/function () {
  function ActiveAnchorTracker() {
    (0, _classCallCheck2.default)(this, ActiveAnchorTracker);
    (0, _defineProperty2.default)(this, "lastActiveAnchor", '');
    this.emitter = new _events.EventEmitter();
  }
  return (0, _createClass2.default)(ActiveAnchorTracker, [{
    key: "getActiveAnchor",
    value: function getActiveAnchor() {
      return this.lastActiveAnchor;
    }
  }, {
    key: "subscribe",
    value: function subscribe(anchorName, callback) {
      if (this.emitter) {
        this.emitter.on(anchorName, callback);
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(anchorName, callback) {
      if (this.emitter) {
        this.emitter.removeListener(anchorName, callback);
      }
    }
  }, {
    key: "emit",
    value: function emit(anchorName) {
      if (this.lastActiveAnchor !== anchorName && this.emitter) {
        this.emitter.emit(this.lastActiveAnchor, false);
        this.emitter.emit(anchorName, true);
        this.lastActiveAnchor = anchorName;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.emitter) {
        // To prevent any potential memory leaks,
        // we set the event emitter to null and then create a new event emitter.
        this.emitter.removeAllListeners();
        this.emitter = null;
        this.emitter = new _events.EventEmitter();
      }
    }
  }]);
}(); // TODO: ED-26959 - We should use a scoped ActiveAnchorTracker rather than the global static object.
// Move this into the plugin scope once the newApply functions becomes default apply.
var defaultActiveAnchorTracker = exports.defaultActiveAnchorTracker = new ActiveAnchorTracker();
var useActiveAnchorTracker = exports.useActiveAnchorTracker = function useActiveAnchorTracker(anchorName) {
  var activeAnchorTracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultActiveAnchorTracker;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    isActive = _useState2[0],
    setIsActive = _useState2[1];
  var onActive = function onActive(eventIsActive) {
    setIsActive(eventIsActive);
  };
  (0, _react.useEffect)(function () {
    if (activeAnchorTracker && anchorName && (0, _experiments.editorExperiment)('advanced_layouts', true)) {
      activeAnchorTracker.subscribe(anchorName, onActive);
      if (activeAnchorTracker.getActiveAnchor() === anchorName) {
        setIsActive(true);
      }
      var unsubscribe = function unsubscribe() {
        activeAnchorTracker.unsubscribe(anchorName, onActive);
      };
      return unsubscribe;
    }
  }, [activeAnchorTracker, anchorName]);
  var setActive = (0, _react.useCallback)(function () {
    activeAnchorTracker.emit(anchorName);
  }, [activeAnchorTracker, anchorName]);
  return [isActive, setActive];
};