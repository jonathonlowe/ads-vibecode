"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeFromSource = void 0;
var _model = require("@atlaskit/editor-prosemirror/model");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _checkFragment = require("./check-fragment");
var _consts = require("./consts");
var _updateColumnWidths = require("./update-column-widths");
var removeFromSource = exports.removeFromSource = function removeFromSource(tr, $from, to) {
  var _sourceContent, _sourceContent2;
  var sourceContent = $from.nodeAfter;
  var isLayoutColumn = ((_sourceContent = sourceContent) === null || _sourceContent === void 0 ? void 0 : _sourceContent.type.name) === 'layoutColumn';
  var sourceNodeEndPos = $from.pos + (((_sourceContent2 = sourceContent) === null || _sourceContent2 === void 0 ? void 0 : _sourceContent2.nodeSize) || 1);
  if ((0, _experiments.editorExperiment)('platform_editor_element_drag_and_drop_multiselect', true)) {
    sourceContent = tr.doc.slice($from.pos, to).content;
    isLayoutColumn = (0, _checkFragment.isFragmentOfType)(sourceContent, 'layoutColumn');
    sourceNodeEndPos = to === undefined ? $from.pos + sourceContent.size : to;
  }
  if (!sourceContent) {
    return tr;
  }
  if (isLayoutColumn) {
    var sourceParent = $from.parent;
    if (sourceParent.childCount === _consts.MIN_LAYOUT_COLUMN) {
      tr.delete($from.pos + 1, sourceNodeEndPos - 1);

      // Currently, we assume that the MIN_LAYOUT_COLUMN is set to 2.
      // This value may require an update when we introduce support for a single-column layout.
      if (sourceParent.childCount === 2) {
        var _$from$parent$lastChi, _$from$parent$firstCh;
        var layoutContentFragment = $from.parentOffset === 0 ? _model.Fragment.from((_$from$parent$lastChi = $from.parent.lastChild) === null || _$from$parent$lastChi === void 0 ? void 0 : _$from$parent$lastChi.content) : _model.Fragment.from((_$from$parent$firstCh = $from.parent.firstChild) === null || _$from$parent$firstCh === void 0 ? void 0 : _$from$parent$firstCh.content);
        var parent = (0, _utils.findParentNodeClosestToPos)($from, function (node) {
          return node.type.name === 'layoutSection';
        });
        if (parent && layoutContentFragment) {
          var _tr$doc$resolve$nodeA;
          var layoutSectionPos = tr.mapping.map(parent.pos);
          // get the updated layout node size
          var layoutSectionNodeSize = ((_tr$doc$resolve$nodeA = tr.doc.resolve(layoutSectionPos).nodeAfter) === null || _tr$doc$resolve$nodeA === void 0 ? void 0 : _tr$doc$resolve$nodeA.nodeSize) || 0;
          tr.replaceWith(layoutSectionPos, layoutSectionPos + layoutSectionNodeSize, layoutContentFragment);
        }
      }
      return tr;
    } else {
      (0, _updateColumnWidths.updateColumnWidths)(tr, $from.parent, $from.before($from.depth), sourceParent.childCount - 1);
    }
  }
  tr.delete($from.pos, sourceNodeEndPos);
  return tr;
};