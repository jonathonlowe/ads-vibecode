import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { traverse } from '../traverse/traverse';
// This is the set of marks that we wont allow in duplicate to
// exist on a given node, regardless of their attributes. We do
// not include annotations here, because we do allow duplicate
// annotations as long as they have unique id attributes (valid scenario)
var markDuplicatesDisallowed = new Set(['strong', 'underline', 'textColor', 'link', 'em', 'subsup', 'strike', 'backgroundColor']);
var maybeHasDisallowedDuplicateMarks = function maybeHasDisallowedDuplicateMarks(node) {
  var _node$marks;
  var markTypes = (_node$marks = node.marks) === null || _node$marks === void 0 || (_node$marks = _node$marks.map(function (mark) {
    return mark.type;
  })) === null || _node$marks === void 0 ? void 0 : _node$marks.filter(function (markType) {
    return (
      // For annotations, we are performing the same cheap check
      // for duplicates by type, without considering IDs, to quickly determine
      // whether there may be potential deduping targets.
      // In the actual deduping logic in maybeRemoveDisallowedDuplicateMarks,
      // we correctly/safely dedupe annotations by their unique IDs.
      markDuplicatesDisallowed.has(markType) || markType === 'annotation'
    );
  });
  if (!(markTypes !== null && markTypes !== void 0 && markTypes.length)) {
    return false;
  }
  return new Set(markTypes).size !== markTypes.length;
};
var maybeRemoveDisallowedDuplicateMarks = function maybeRemoveDisallowedDuplicateMarks(node) {
  var quota = new Map();
  var annotationsQuota = new Map();
  var discardedMarks = [];
  markDuplicatesDisallowed.forEach(function (mark) {
    quota.set(mark, false);
  });
  if (!node.marks) {
    return {
      discardedMarks: discardedMarks
    };
  }
  var dedupedMarks = node.marks.filter(function (mark) {
    var markType = mark.type;
    if (markType === 'annotation') {
      var _mark$attrs;
      var id = (_mark$attrs = mark.attrs) === null || _mark$attrs === void 0 ? void 0 : _mark$attrs.id;
      if (annotationsQuota.has(id)) {
        discardedMarks.push(mark);
        return false;
      } else {
        annotationsQuota.set(id, true);
        return true;
      }
    }
    if (quota.has(markType)) {
      if (!quota.get(markType)) {
        quota.set(markType, true);
        return true;
      } else {
        discardedMarks.push(mark);
        return false;
      }
    }
    return true;
  });
  return {
    node: _objectSpread(_objectSpread({}, node), {}, {
      marks: dedupedMarks
    }),
    discardedMarks: discardedMarks
  };
};
export var transformDedupeMarks = function transformDedupeMarks(adf) {
  var isTransformed = false;
  var discardedMarks = [];
  var transformedAdf = traverse(adf, {
    text: function text(node) {
      if (maybeHasDisallowedDuplicateMarks(node)) {
        var result = maybeRemoveDisallowedDuplicateMarks(node);
        var resultDiscardedMarks = result.discardedMarks;
        if (resultDiscardedMarks.length) {
          discardedMarks.push.apply(discardedMarks, _toConsumableArray(resultDiscardedMarks));
          isTransformed = true;
          return result.node;
        }
      }
    }
  });
  return {
    transformedAdf: transformedAdf,
    isTransformed: isTransformed,
    discardedMarks: discardedMarks
  };
};