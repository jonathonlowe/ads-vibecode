import { traverse } from '../traverse/traverse';
import { extension } from '../builders';
import { NodeNestingTransformError } from './errors';
const NESTED_TABLE_EXTENSION_TYPE = 'com.atlassian.confluence.migration',
  NESTED_TABLE_EXTENSION_KEY = 'nested-table';
export const isNestedTableExtension = extensionNode => {
  var _extensionNode$attrs, _extensionNode$attrs2;
  return ((_extensionNode$attrs = extensionNode.attrs) === null || _extensionNode$attrs === void 0 ? void 0 : _extensionNode$attrs.extensionType) === NESTED_TABLE_EXTENSION_TYPE && ((_extensionNode$attrs2 = extensionNode.attrs) === null || _extensionNode$attrs2 === void 0 ? void 0 : _extensionNode$attrs2.extensionKey) === NESTED_TABLE_EXTENSION_KEY;
};
const transformNestedTableExtension = nestedTableExtension => {
  var _nestedTableExtension, _nestedTableExtension2;
  // No content - drop the extension node
  if (!((_nestedTableExtension = nestedTableExtension.attrs) !== null && _nestedTableExtension !== void 0 && (_nestedTableExtension2 = _nestedTableExtension.parameters) !== null && _nestedTableExtension2 !== void 0 && _nestedTableExtension2.adf)) {
    return false;
  }
  try {
    var _nestedTableExtension3, _nestedTableExtension4;
    const adf = JSON.parse((_nestedTableExtension3 = nestedTableExtension.attrs) === null || _nestedTableExtension3 === void 0 ? void 0 : (_nestedTableExtension4 = _nestedTableExtension3.parameters) === null || _nestedTableExtension4 === void 0 ? void 0 : _nestedTableExtension4.adf);
    if (!adf.content || adf.content.length === 0) {
      return false;
    }
    return adf.content[0];
  } catch (e) {
    throw new NodeNestingTransformError('Failed to parse nested table content');
  }
};
function isInsideBodiedExtension(parent) {
  var _parent$parent;
  if (parent.node === undefined) {
    return false;
  }
  if (parent.node.type === 'bodiedExtension') {
    return true;
  }
  if (parent !== null && parent !== void 0 && (_parent$parent = parent.parent) !== null && _parent$parent !== void 0 && _parent$parent.node) {
    return isInsideBodiedExtension(parent.parent);
  }
  return false;
}
export const transformNestedTablesIncomingDocument = (adf, options = {}) => {
  let isTransformed = false;
  const transformedAdf = traverse(adf, {
    extension: (node, parent) => {
      if (isNestedTableExtension(node)) {
        // Bodied extensions in renderer use their own nested renderer to render the content.
        // This results in the document being validated/transformed twice, once with untransformed content and again with transformed content.
        // Since the untransformed content is valid ADF (table as extension in table) but the transformed content is not valid ADF, (table in table)
        // we need to skip transforming nested tables inside bodied extensions in renderer on the first pass or else it will fail validation and render an unsupported block.
        if (options.environment === 'renderer' && isInsideBodiedExtension(parent)) {
          return undefined;
        }
        isTransformed = true;
        return transformNestedTableExtension(node);
      }
    }
  });
  return {
    transformedAdf,
    isTransformed
  };
};
export const transformNestedTableNodeOutgoingDocument = tableCellNode => {
  try {
    var _tableCellNode$conten;
    return {
      ...tableCellNode,
      content: (_tableCellNode$conten = tableCellNode.content) === null || _tableCellNode$conten === void 0 ? void 0 : _tableCellNode$conten.map(childNode => {
        // wrap nested table in an extension node
        if ((childNode === null || childNode === void 0 ? void 0 : childNode.type) === 'table') {
          return extension({
            extensionType: NESTED_TABLE_EXTENSION_TYPE,
            extensionKey: NESTED_TABLE_EXTENSION_KEY,
            parameters: {
              adf: JSON.stringify({
                type: 'doc',
                version: 1,
                content: [childNode]
              })
            }
          });
        }
        return childNode;
      })
    };
  } catch (e) {
    throw new NodeNestingTransformError('Failed to encode nested table node');
  }
};