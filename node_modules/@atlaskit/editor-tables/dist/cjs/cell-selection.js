"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CellSelection = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _model = require("@atlaskit/editor-prosemirror/model");
var _state = require("@atlaskit/editor-prosemirror/state");
var _cellBookmark = require("./cell-bookmark");
var _tableMap = require("./table-map");
var _cells = require("./utils/cells");
var _colspan = require("./utils/colspan");
var _getCellSelectionRanges = require("./utils/get-cell-selection-ranges");
var _tables = require("./utils/tables");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /* eslint-disable @atlaskit/editor/no-re-export */ // Entry file in package.json
// Was copied from https://github.com/ProseMirror/prosemirror-tables/blob/master/src/cellselection.js
// This file defines a ProseMirror selection subclass that models
// table cell selections. The table plugin needs to be active to wire
// in the user interaction part of table selections (so that you
// actually get such selections when you select across cells).
// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)
// subclass that represents a cell selection spanning part of a table.
// With the plugin enabled, these will be created when the user
// selects across cells, and will be drawn by giving selected cells a
// `selectedCell` CSS class.
var CellSelection = exports.CellSelection = /*#__PURE__*/function (_Selection) {
  // :: (ResolvedPos, ?ResolvedPos)
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.

  function CellSelection($anchorCell) {
    var _this;
    var $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;
    (0, _classCallCheck2.default)(this, CellSelection);
    var ranges = (0, _getCellSelectionRanges.getCellSelectionRanges)($anchorCell, $headCell);
    _this = _callSuper(this, CellSelection, [ranges[0].$from, ranges[0].$to, ranges]);
    // :: ResolvedPos
    // A resolved position pointing _in front of_ the anchor cell (the one
    // that doesn't move when extending the selection).
    _this.$anchorCell = $anchorCell;
    // :: ResolvedPos
    // A resolved position pointing in front of the head cell (the one
    // moves when extending the selection).
    _this.$headCell = $headCell;
    _this.visible = false;
    return _this;
  }
  (0, _inherits2.default)(CellSelection, _Selection);
  return (0, _createClass2.default)(CellSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));
      var $headCell = doc.resolve(mapping.map(this.$headCell.pos));
      if ((0, _cells.pointsAtCell)($anchorCell) && (0, _cells.pointsAtCell)($headCell) && (0, _tables.inSameTable)($anchorCell, $headCell)) {
        var tableChanged = this.$anchorCell.node(-1) !== $anchorCell.node(-1);
        if (tableChanged && this.isRowSelection()) {
          return CellSelection.rowSelection($anchorCell, $headCell);
        }
        if (tableChanged && this.isColSelection()) {
          return CellSelection.colSelection($anchorCell, $headCell);
        }
        return new CellSelection($anchorCell, $headCell);
      }
      return _state.TextSelection.between($anchorCell, $headCell);
    }

    // :: () → Slice
    // Returns a rectangular slice of table rows containing the selected
    // cells.
  }, {
    key: "content",
    value: function content() {
      var table = this.$anchorCell.node(-1);
      var map = _tableMap.TableMap.get(table);
      var start = this.$anchorCell.start(-1);
      var rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);
      var seen = {};
      var rows = [];
      for (var row = rect.top; row < rect.bottom; row++) {
        var rowContent = [];
        for (var index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
          var pos = map.map[index];
          if (!seen[pos]) {
            seen[pos] = true;
            var cellRect = map.findCell(pos);
            var cell = table.nodeAt(pos);
            if (cell === null || cell === undefined) {
              throw new Error("No cell at position ".concat(pos));
            }
            var extraLeft = rect.left - cellRect.left;
            var extraRight = cellRect.right - rect.right;
            if (extraLeft > 0 || extraRight > 0) {
              var _cell = cell,
                attrs = _cell.attrs;
              if (!attrs) {
                throw new Error("No cell at position ".concat(pos));
              }
              if (extraLeft > 0) {
                attrs = (0, _colspan.removeColSpan)(attrs, 0, extraLeft);
              }
              if (extraRight > 0) {
                // Ignored via go/ees005
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                attrs = (0, _colspan.removeColSpan)(attrs, attrs.colspan - extraRight, extraRight);
              }
              if (cellRect.left < rect.left) {
                cell = cell.type.createAndFill(attrs);
              } else {
                cell = cell.type.create(attrs, cell.content);
              }
            }
            if (cell === null || cell === undefined) {
              throw new Error("No cell at position after create/createAndFill");
            }
            if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
              var _attrs = _objectSpread(_objectSpread({}, cell.attrs), {}, {
                rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
              });
              if (cellRect.top < rect.top) {
                cell = cell.type.createAndFill(_attrs);
              } else {
                cell = cell.type.create(_attrs, cell.content);
              }
            }
            if (cell === null || cell === undefined) {
              throw new Error("No cell at position before rowContent.push");
            }
            rowContent.push(cell);
          }
        }
        rows.push(table.child(row).copy(_model.Fragment.from(rowContent)));
      }
      var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
      return new _model.Slice(_model.Fragment.from(fragment), 1, 1);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _model.Slice.empty;
      var mapFrom = tr.steps.length;
      var ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var _ranges$i = ranges[i],
          $from = _ranges$i.$from,
          $to = _ranges$i.$to;
        var mapping = tr.mapping.slice(mapFrom);
        tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? _model.Slice.empty : content);
      }
      var sel = _state.Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
      if (sel) {
        tr.setSelection(sel);
      }
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(tr, node) {
      this.replace(tr, new _model.Slice(_model.Fragment.from(node), 0, 0));
    }
  }, {
    key: "forEachCell",
    value: function forEachCell(f) {
      var table = this.$anchorCell.node(-1);
      var map = _tableMap.TableMap.get(table);
      var start = this.$anchorCell.start(-1);
      var cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));
      for (var i = 0; i < cells.length; i++) {
        var cell = table.nodeAt(cells[i]);
        if (cell === null || cell === undefined) {
          throw new Error("undefined cell at pos ".concat(cells[i]));
        }
        f(cell, start + cells[i]);
      }
    }

    // :: () → bool
    // True if this selection goes all the way from the top to the
    // bottom of the table.
  }, {
    key: "isColSelection",
    value: function isColSelection() {
      if (!this.$anchorCell || !this.$headCell) {
        throw new Error('invalid $anchorCell or $headCell');
      }
      var anchorTop = this.$anchorCell.index(-1);
      var headTop = this.$headCell.index(-1);
      if (Math.min(anchorTop, headTop) > 0) {
        return false;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(anchorBot, headBot) === this.$headCell.node(-1).childCount;
    }

    // :: (ResolvedPos, ?ResolvedPos) → CellSelection
    // Returns the smallest column selection that covers the given anchor
    // and head cell.
  }, {
    key: "isRowSelection",
    value:
    // :: () → bool
    // True if this selection goes all the way from the left to the
    // right of the table.
    function isRowSelection() {
      if (!this.$anchorCell || !this.$headCell) {
        return false;
      }
      var start = this.$anchorCell.start(-1);
      var map = _tableMap.TableMap.get(this.$anchorCell.node(-1));
      var rowAtAnchorCell = map.rowCount(this.$anchorCell.pos - start);
      var rowAtHeadCell = map.rowCount(this.$headCell.pos - start);
      var isSelectionSameRow = rowAtAnchorCell === rowAtHeadCell;

      // if anchor and head in the same line, counting how many cells
      // should be in the row except merged cell
      var maxColumnInSelectedRow = map.getMaxColInRow(this.$anchorCell);

      // if selected cells less than table max column amount, and
      // the anchor/head not in a merged cell
      // it should be select maxColumnInSelectedRow to be TRUE
      if (isSelectionSameRow && this.ranges.length <= map.width && !map.isPosMerged(this.$anchorCell.pos - start) && !map.isPosMerged(this.$headCell.pos - start)) {
        return this.ranges.length === maxColumnInSelectedRow;
      }

      // If anchor and head in different row, it should be always in first and
      // last column to select the whole row.
      var anchorLeft = map.colCount(this.$anchorCell.pos - start);
      var headLeft = map.colCount(this.$headCell.pos - start);
      if (Math.min(anchorLeft, headLeft) > 0) {
        return false;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(anchorRight, headRight) === map.width;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof CellSelection && other.$anchorCell.pos === this.$anchorCell.pos && other.$headCell.pos === this.$headCell.pos;
    }

    // :: (ResolvedPos, ?ResolvedPos) → CellSelection
    // Returns the smallest row selection that covers the given anchor
    // and head cell.
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: 'cell',
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new _cellBookmark.CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
    }
  }], [{
    key: "colSelection",
    value: function colSelection($anchorCell) {
      var $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;
      var $calculatedAnchorCell = $anchorCell;
      var $calculatedHeadCell = $headCell;
      var map = _tableMap.TableMap.get($calculatedAnchorCell.node(-1));
      var start = $calculatedAnchorCell.start(-1);
      var anchorRect = map.findCell($calculatedAnchorCell.pos - start);
      var headRect = map.findCell($calculatedHeadCell.pos - start);
      var doc = $calculatedAnchorCell.node(0);
      if (anchorRect.top <= headRect.top) {
        if (anchorRect.top > 0) {
          $calculatedAnchorCell = doc.resolve(start + map.map[anchorRect.left]);
        }
        if (headRect.bottom < map.height) {
          $calculatedHeadCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]);
        }
      } else {
        if (headRect.top > 0) {
          $calculatedHeadCell = doc.resolve(start + map.map[headRect.left]);
        }
        if (anchorRect.bottom < map.height) {
          $calculatedAnchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);
        }
      }
      return new CellSelection($calculatedAnchorCell, $calculatedHeadCell);
    }
  }, {
    key: "rowSelection",
    value: function rowSelection($anchorCell) {
      var $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;
      var $calculatedAnchorCell = $anchorCell;
      var $calculatedHeadCell = $headCell;
      var map = _tableMap.TableMap.get($calculatedAnchorCell.node(-1));
      var start = $calculatedAnchorCell.start(-1);
      var anchorRect = map.findCell($calculatedAnchorCell.pos - start);
      var headRect = map.findCell($calculatedHeadCell.pos - start);
      var doc = $calculatedAnchorCell.node(0);
      if (anchorRect.left <= headRect.left) {
        if (anchorRect.left > 0) {
          $calculatedAnchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);
        }
        if (headRect.right < map.width) {
          $calculatedHeadCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]);
        }
      } else {
        if (headRect.left > 0) {
          $calculatedHeadCell = doc.resolve(start + map.map[headRect.top * map.width]);
        }
        if (anchorRect.right < map.width) {
          $calculatedAnchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]);
        }
      }
      return new CellSelection($calculatedAnchorCell, $calculatedHeadCell);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }

    // :: (Node, number, ?number) → CellSelection
  }, {
    key: "create",
    value: function create(doc, anchorCell) {
      var headCell = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchorCell;
      return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));
    }
  }]);
}(_state.Selection);
_state.Selection.jsonID('cell', CellSelection);