"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tableEditing = tableEditing;
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("../utils");
var _drawCellSelection = require("../utils/draw-cell-selection");
var _fixTables = require("../utils/fix-tables");
var _normalizeSelection = require("../utils/normalize-selection");
var _input = require("./input");
var _pluginKey = require("./plugin-key");
// :: () â†’ Plugin
//
// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)
// that, when added to an editor, enables cell-selection, handles
// cell-based copy/paste, and makes sure tables stay well-formed (each
// row has the same width, and cells don't overlap).
//
// You should probably put this plugin near the end of your array of
// plugins, since it handles mouse and arrow key events in tables
// rather broadly, and other plugins, like the gap cursor or the
// column-width dragging plugin, might want to get a turn first to
// perform more specific behavior.

function tableEditing() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$allowTableNodeSe = _ref.allowTableNodeSelection,
    allowTableNodeSelection = _ref$allowTableNodeSe === void 0 ? false : _ref$allowTableNodeSe,
    _ref$dragAndDropEnabl = _ref.dragAndDropEnabled,
    dragAndDropEnabled = _ref$dragAndDropEnabl === void 0 ? false : _ref$dragAndDropEnabl,
    reportFixedTable = _ref.reportFixedTable;
  return new _state.Plugin({
    key: _pluginKey.tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(unsafeTr, cur) {
        var tr = unsafeTr;
        var set = tr.getMeta(_pluginKey.tableEditingKey);
        if (set != null) {
          return set === -1 ? null : set;
        }
        if (cur == null || !tr.docChanged) {
          return cur;
        }
        var _tr$mapping$mapResult = tr.mapping.mapResult(cur),
          deleted = _tr$mapping$mapResult.deleted,
          pos = _tr$mapping$mapResult.pos;
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: _drawCellSelection.drawCellSelection,
      handleDOMEvents: {
        mousedown: function mousedown(view, event) {
          (0, _input.handleMouseDown)(view, event, dragAndDropEnabled);
        }
      },
      createSelectionBetween: function createSelectionBetween(view) {
        if (_pluginKey.tableEditingKey.getState(view.state) != null) {
          return view.state.selection;
        }
        return null;
      },
      handleTripleClick: _input.handleTripleClick,
      handleKeyDown: _input.handleKeyDown,
      handlePaste: _utils.handlePaste
    },
    appendTransaction: function appendTransaction(_, oldState, state) {
      return (0, _normalizeSelection.normalizeSelection)(state, (0, _fixTables.fixTables)(state, oldState, reportFixedTable), allowTableNodeSelection);
    }
  });
}