"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tableNewColumnMinWidth = exports.TableProblemTypes = exports.TableMap = exports.Rect = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
/* eslint-disable @atlaskit/editor/no-re-export */
// Entry file in package.json

// Because working with row and column-spanning cells is not quite
// trivial, this code builds up a descriptive structure for a given
// table node. The structures are cached with the (persistent) table
// nodes as key, so that they only have to be recomputed when the
// content of the table changes.
//
// This does mean that they have to store table-relative, not
// document-relative positions. So code that uses them will typically
// compute the start position of the table and offset positions passed
// to or gotten from this structure by that amount.

var readFromCache, addToCache;
// Prefer using a weak map to cache table maps. Fall back on a
// fixed-size cache if that's not supported.
if (typeof WeakMap !== 'undefined') {
  var cache = new WeakMap();
  readFromCache = function readFromCache(key) {
    return cache.get(key);
  };
  addToCache = function addToCache(key, value) {
    cache.set(key, value);
    return value;
  };
} else {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var _cache = [];
  var cacheSize = 10;
  var cachePos = 0;
  readFromCache = function readFromCache(key) {
    for (var i = 0; i < _cache.length; i += 2) {
      if (_cache[i] === key) {
        return _cache[i + 1];
      }
    }
  };
  addToCache = function addToCache(key, value) {
    if (cachePos === cacheSize) {
      cachePos = 0;
    }
    _cache[cachePos++] = key;
    return _cache[cachePos++] = value;
  };
}
var Rect = exports.Rect = /*#__PURE__*/(0, _createClass2.default)(function Rect(left, top, right, bottom) {
  (0, _classCallCheck2.default)(this, Rect);
  this.left = left;
  this.top = top;
  this.right = right;
  this.bottom = bottom;
});
var TableProblemTypes = exports.TableProblemTypes = /*#__PURE__*/function (TableProblemTypes) {
  TableProblemTypes["COLLISION"] = "collision";
  TableProblemTypes["OVERLONG_ROWSPAN"] = "overlong_rowspan";
  TableProblemTypes["MISSING"] = "missing";
  TableProblemTypes["COLWIDTH_MISMATCH"] = "colwidth mismatch";
  return TableProblemTypes;
}({});
// Ideally tableNewColumnMinWidth should be imported
// from '@atlaskit/editor-common/styles';
// We don't want to introduce a new dependency.
// Thus we define the constant here.
var tableNewColumnMinWidth = exports.tableNewColumnMinWidth = 140;

// ::- A table map describes the structore of a given table. To avoid
// recomputing them all the time, they are cached per table node. To
// be able to do that, positions saved in the map are relative to the
// start of the table, rather than the start of the document.
var TableMap = exports.TableMap = /*#__PURE__*/function () {
  function TableMap(width, height, map, problems, mapByColumn, mapByRow) {
    (0, _classCallCheck2.default)(this, TableMap);
    // The width of the table
    // The table's height
    (0, _defineProperty2.default)(this, "mapByColumn", []);
    (0, _defineProperty2.default)(this, "mapByRow", []);
    this.width = width;
    this.height = height;
    this.mapByColumn = mapByColumn || [];
    this.mapByRow = mapByRow || [];
    // :: [number] A width * height array with the start position of
    // the cell covering that part of the table in each slot
    this.map = map;
    // An optional array of problems (cell overlap or non-rectangular
    // shape) for the table, used by the table normalizer.
    this.problems = problems;
  }

  // :: (number) → Rect
  // Find the dimensions of the cell at the given position.
  return (0, _createClass2.default)(TableMap, [{
    key: "findCell",
    value: function findCell(pos) {
      for (var i = 0; i < this.map.length; i++) {
        var curPos = this.map[i];
        if (curPos !== pos) {
          continue;
        }
        var left = i % this.width;
        var top = i / this.width | 0;
        var right = left + 1;
        var bottom = top + 1;
        for (var j = 1; right < this.width && this.map[i + j] === curPos; j++) {
          right++;
        }
        for (var _j = 1; bottom < this.height && this.map[i + this.width * _j] === curPos; _j++) {
          bottom++;
        }
        return new Rect(left, top, right, bottom);
      }
      throw new RangeError('No cell with offset ' + pos + ' found');
    }

    // Find the left side of the cell at the given position.
  }, {
    key: "colCount",
    value: function colCount(pos) {
      for (var i = 0; i < this.map.length; i++) {
        if (this.map[i] === pos) {
          return i % this.width;
        }
      }
      throw new RangeError('No cell with offset ' + pos + ' found');
    }

    // Find the top side of the cell at the given position.
  }, {
    key: "rowCount",
    value: function rowCount(pos) {
      if (this.width <= 0) {
        throw new RangeError('Wrong table width found');
      }
      for (var i = 0; i < this.map.length; i++) {
        if (this.map[i] === pos) {
          return Math.floor(i / this.width);
        }
      }
      throw new RangeError('No cell with offset ' + pos + ' found');
    }
  }, {
    key: "isPosMerged",
    value: function isPosMerged(pos) {
      return this.map.includes(pos, this.map.indexOf(pos) + 1);
    }
  }, {
    key: "isCellMerged",
    value: function isCellMerged(row, col) {
      return this.isCellMergedTopLeft(row, col) || this.isCellMergedBottomRight(row, col);
    }
  }, {
    key: "isCellMergedTopLeft",
    value: function isCellMergedTopLeft(row, col) {
      var pos = this.map[row * this.width + col];
      return (
        // top
        row > 0 && pos === this.map[(row - 1) * this.width + col] ||
        // left
        col > 0 && pos === this.map[row * this.width + (col - 1)]
      );
    }
  }, {
    key: "isCellMergedBottomRight",
    value: function isCellMergedBottomRight(row, col) {
      var pos = this.map[row * this.width + col];
      return (
        // bottom
        row < this.height - 1 && pos === this.map[(row + 1) * this.width + col] ||
        // right
        col < this.width - 1 && pos === this.map[row * this.width + (col + 1)]
      );
    }

    // :: (number, string, number) → ?number
    // Find the next cell in the given direction, starting from the cell
    // at `pos`, if any.
  }, {
    key: "nextCell",
    value: function nextCell(pos, axis, dir) {
      var _this$findCell = this.findCell(pos),
        left = _this$findCell.left,
        right = _this$findCell.right,
        top = _this$findCell.top,
        bottom = _this$findCell.bottom;
      if (axis === 'horiz') {
        if (dir < 0 ? left === 0 : right === this.width) {
          return null;
        }
        return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
      } else {
        if (dir < 0 ? top === 0 : bottom === this.height) {
          return null;
        }
        return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
      }
    }

    // :: (number, number) → Rect
    // Get the rectangle spanning the two given cells.
  }, {
    key: "rectBetween",
    value: function rectBetween(a, b) {
      var _this$findCell2 = this.findCell(a),
        leftA = _this$findCell2.left,
        rightA = _this$findCell2.right,
        topA = _this$findCell2.top,
        bottomA = _this$findCell2.bottom;
      var _this$findCell3 = this.findCell(b),
        leftB = _this$findCell3.left,
        rightB = _this$findCell3.right,
        topB = _this$findCell3.top,
        bottomB = _this$findCell3.bottom;
      return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));
    }

    // :: (Rect) → [number]
    // Return the position of all cells that have the top left corner in
    // the given rectangle.
  }, {
    key: "cellsInRect",
    value: function cellsInRect(rect) {
      var result = [];
      var seen = {};
      for (var row = rect.top; row < rect.bottom; row++) {
        for (var col = rect.left; col < rect.right; col++) {
          var index = row * this.width + col;
          var pos = this.map[index];
          if (seen[pos]) {
            continue;
          }
          seen[pos] = true;
          if ((col !== rect.left || !col || this.map[index - 1] !== pos) && (row !== rect.top || !row || this.map[index - this.width] !== pos)) {
            result.push(pos);
          }
        }
      }
      return result;
    }

    // :: (number, number, Node) → number
    // Return the position at which the cell at the given row and column
    // starts, or would start, if a cell started there.
  }, {
    key: "positionAt",
    value: function positionAt(row, col, table) {
      for (var i = 0, rowStart = 0;; i++) {
        var rowEnd = rowStart + table.child(i).nodeSize;
        if (i === row) {
          var index = col + row * this.width;
          var rowEndIndex = (row + 1) * this.width;
          // Skip past cells from previous rows (via rowspan)
          while (index < rowEndIndex && this.map[index] < rowStart) {
            index++;
          }
          return index === rowEndIndex ? rowEnd - 1 : this.map[index];
        }
        rowStart = rowEnd;
      }
    }
  }, {
    key: "getMaxColInRow",
    value: function getMaxColInRow(pos) {
      var parentRowNode = pos.parent;
      if (parentRowNode.type.name === 'tableRow') {
        return parentRowNode.childCount;
      }
    }
  }, {
    key: "hasMergedCells",
    value: function hasMergedCells() {
      var uniquePositions = new Set(this.map);
      return uniquePositions.size !== this.map.length;
    }

    // :: (Node) → TableMap
    // Find the table map for the given table node.
  }], [{
    key: "get",
    value: function get(table) {
      return readFromCache(table) || addToCache(table, computeMap(table));
    }
  }]);
}(); // Compute a table map.
function computeMap(table) {
  if (table.type.spec.tableRole !== 'table') {
    throw new RangeError('Not a table node: ' + table.type.name);
  }
  var width = findWidth(table);
  var height = table.childCount;
  var map = [];
  var colWidths = [];
  var mapPos = 0,
    problems = null;
  for (var i = 0, e = width * height; i < e; i++) {
    map[i] = 0;
  }
  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table.child(row);
    pos++;
    for (var _i = 0;; _i++) {
      while (mapPos < map.length && map[mapPos] !== 0) {
        mapPos++;
      }
      if (_i === rowNode.childCount) {
        break;
      }
      var cellNode = rowNode.child(_i),
        _cellNode$attrs = cellNode.attrs,
        colspan = _cellNode$attrs.colspan,
        rowspan = _cellNode$attrs.rowspan,
        colwidth = _cellNode$attrs.colwidth;
      for (var h = 0; h < rowspan; h++) {
        if (h + row >= height) {
          (problems || (problems = [])).push({
            type: TableProblemTypes.OVERLONG_ROWSPAN,
            pos: pos,
            n: rowspan - h
          });
          break;
        }
        var start = mapPos + h * width;
        for (var w = 0; w < colspan; w++) {
          if (map[start + w] === 0) {
            map[start + w] = pos;
          } else {
            (problems || (problems = [])).push({
              type: TableProblemTypes.COLLISION,
              row: row,
              pos: pos,
              n: colspan - w
            });
          }
          var colW = colwidth && colwidth[w];
          if (colW) {
            var widthIndex = (start + w) % width * 2,
              prev = colWidths[widthIndex];
            if (prev == null || prev !== colW && colWidths[widthIndex + 1] === 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev === colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width;
    var missing = 0;
    while (mapPos < expectedPos) {
      if (map[mapPos++] === 0) {
        missing++;
      }
    }
    if (missing) {
      (problems || (problems = [])).push({
        type: TableProblemTypes.MISSING,
        row: row,
        n: missing
      });
    }
    pos++;
  }
  var mapByRow = Array(height);
  var mapByColumn = Array(width);
  for (var _i2 = 0; _i2 < map.length; _i2++) {
    var _mapByColumn$columnIn, _mapByRow$rowIndex;
    var columnIndex = _i2 % width;
    mapByColumn[columnIndex] = (_mapByColumn$columnIn = mapByColumn[columnIndex]) !== null && _mapByColumn$columnIn !== void 0 ? _mapByColumn$columnIn : [];
    mapByColumn[columnIndex].push(map[_i2]);
    var rowIndex = Math.trunc(_i2 / width);
    mapByRow[rowIndex] = (_mapByRow$rowIndex = mapByRow[rowIndex]) !== null && _mapByRow$rowIndex !== void 0 ? _mapByRow$rowIndex : [];
    mapByRow[rowIndex].push(map[_i2]);
  }
  var tableMap = new TableMap(width, height, map, problems, mapByColumn, mapByRow);
  var badWidths = false;

  // For columns that have defined widths, but whose widths disagree
  // between rows, fix up the cells whose width doesn't match the
  // computed one.
  for (var _i3 = 0; !badWidths && _i3 < colWidths.length; _i3 += 2) {
    if (colWidths[_i3] != null && colWidths[_i3 + 1] < height) {
      badWidths = true;
    }
  }

  // colWidths is an array of numbers, it can look like this
  // const colWidths = [255, 3, 125, 3, 150, 2, 130, 1];
  // 255 is a colWidth and 3 is a number of cells with this colwidth.
  // This check exists to make sure that the table has been resized,
  // which means there will be elements in the colWidths array.
  if (colWidths.length > 0 && colWidths.length !== width * 2) {
    for (var _i4 = 0; _i4 < width * 2 - colWidths.length; _i4++) {
      colWidths.push(tableNewColumnMinWidth, 0);
    }
    badWidths = true;
  }
  if (badWidths) {
    findBadColWidths(tableMap, colWidths, table);
  }
  return tableMap;
}
function findWidth(table) {
  var width = -1;
  var hasRowSpan = false;
  for (var row = 0; row < table.childCount; row++) {
    var rowNode = table.child(row);
    var rowWidth = 0;
    if (hasRowSpan) {
      for (var j = 0; j < row; j++) {
        var prevRow = table.child(j);
        for (var i = 0; i < prevRow.childCount; i++) {
          var cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) {
            rowWidth += cell.attrs.colspan;
          }
        }
      }
    }
    for (var _i5 = 0; _i5 < rowNode.childCount; _i5++) {
      var _cell = rowNode.child(_i5);
      rowWidth += _cell.attrs.colspan;
      if (_cell.attrs.rowspan > 1) {
        hasRowSpan = true;
      }
    }
    if (width === -1) {
      width = rowWidth;
    } else if (width !== rowWidth) {
      width = Math.max(width, rowWidth);
    }
  }
  return width;
}
function findBadColWidths(map, colWidths, table) {
  if (!map.problems) {
    map.problems = [];
  }
  var seen = {};
  for (var i = 0; i < map.map.length; i++) {
    var pos = map.map[i];
    if (seen[pos]) {
      continue;
    }
    seen[pos] = true;
    var node = table.nodeAt(pos);
    var updated = null;
    for (var j = 0; j < node.attrs.colspan; j++) {
      var col = (i + j) % map.width,
        colWidth = colWidths[col * 2];
      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] !== colWidth)) {
        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;
      }
    }
    if (updated) {
      map.problems.unshift({
        type: TableProblemTypes.COLWIDTH_MISMATCH,
        pos: pos,
        colwidth: updated
      });
    }
  }
}

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function freshColWidth(attrs) {
  if (attrs.colwidth) {
    return attrs.colwidth.slice();
  }
  var result = [];
  for (var i = 0; i < attrs.colspan; i++) {
    result.push(0);
  }
  return result;
}