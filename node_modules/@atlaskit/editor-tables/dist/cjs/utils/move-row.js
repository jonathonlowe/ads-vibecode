"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveRow = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _cellSelection = require("../cell-selection");
var _tableMap = require("../table-map");
var _analyseTable = require("./analyse-table");
var _cloneTr = require("./clone-tr");
var _find = require("./find");
var _getSelectionRangeInRow = require("./get-selection-range-in-row");
var _normalizeDirection = require("./normalize-direction");
var _reorderUtils = require("./reorder-utils");
var _tableNodeTypes = require("./table-node-types");
// :: (originRowIndex: number, targetRowIndex: targetColumnIndex, options?: MovementOptions) → (tr: Transaction) → Transaction
// Returns a new transaction that moves the origin row to the target index;
//
// by default "tryToFit" is false, that means if you try to move a row to a place
// where we will need to split a row with merged cells it'll throw an exception, for example:
//
// ```
//      ____________________________
//     |      |      |             |
//  0  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
//     |      |             |      |
//  1  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  2  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
// ```
//
// if you try to move the row 0 to the row index 1 with tryToFit false,
// it'll throw an exception since you can't split the row 1;
// but if "tryToFit" is true, it'll move the row using the current direction.
//
// We defined current direction using the target and origin values
// if the origin is greater than the target, that means the course is `bottom-to-top`,
// so the `tryToFit` logic will use this direction to determine
// if we should move the column to the right or the left.
//
// for example, if you call the function using `moveRow(0, 1, { tryToFit: true })`
// the result will be:
// ```
//      ____________________________
//     |      |             |      |
//  0  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  1  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
//     |      |      |             |
//  2  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
// ```
//
// since we could put the row zero on index one,
// we pushed to the best place to fit the row index 0,
// in this case, row index 2.
//
//
// -------- HOW TO OVERRIDE DIRECTION --------
//
// If you set "tryToFit" to "true", it will try to figure out the best direction
// place to fit using the origin and target index, for example:
//
//
// ```
//      ____________________________
//     |      |      |             |
//  0  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
//     |      |             |      |
//  1  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  2  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
//     |      |             |      |
//  3  |  A4  |     B4      |      |
//     |______|______ ______|      |
//     |      |      |      |  D2  |
//  4  |  A5  |  B5  |  C3  |      |
//     |______|______|______|______|
// ```
//
//
// If you try to move the row 0 to row index 4 with "tryToFit" enabled, by default,
// the code will put it on after the merged rows,
// but you can override it using the "direction" option.
//
// -1: Always put the origin before the target
// ```
//      ____________________________
//     |      |             |      |
//  0  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  1  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
//     |      |      |             |
//  2  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
//     |      |             |      |
//  3  |  A4  |     B4      |      |
//     |______|______ ______|      |
//     |      |      |      |  D2  |
//  4  |  A5  |  B5  |  C3  |      |
//     |______|______|______|______|
// ```
//
//  0: Automatically decide the best place to fit
// ```
//      ____________________________
//     |      |             |      |
//  0  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  1  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
//     |      |             |      |
//  2  |  A4  |     B4      |      |
//     |______|______ ______|      |
//     |      |      |      |  D2  |
//  3  |  A5  |  B5  |  C3  |      |
//     |______|______|______|______|
//     |      |      |             |
//  4  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
// ```
//
//  1: Always put the origin after the target
// ```
//      ____________________________
//     |      |             |      |
//  0  |  A2  |     B2      |      |
//     |______|______ ______|      |
//     |      |      |      |  D1  |
//  1  |  A3  |  B3  |  C2  |      |
//     |______|______|______|______|
//     |      |             |      |
//  2  |  A4  |     B4      |      |
//     |______|______ ______|      |
//     |      |      |      |  D2  |
//  3  |  A5  |  B5  |  C3  |      |
//     |______|______|______|______|
//     |      |      |             |
//  4  |  A1  |  B1  |     C1      |
//     |______|______|______ ______|
// ```
//
// ```javascript
// dispatch(
//   moveRow(x, y, options)(state.tr)
// );
// ```
var moveRow = exports.moveRow = function moveRow(state, originRowIndex, targetRowIndex) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    tryToFit: false,
    direction: 0,
    selectAfterMove: false
  };
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (!table) {
      return tr;
    }

    // normalize the origin index to an array since move row support moving both a single & multiple rows in a single action.
    if (!Array.isArray(originRowIndex)) {
      originRowIndex = [originRowIndex];
    }
    if (originRowIndex.includes(targetRowIndex)) {
      return tr;
    }
    var tableMap = _tableMap.TableMap.get(table.node);
    var _originRowIndex$reduc = originRowIndex.reduce(function (_ref, cur) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          min = _ref2[0],
          max = _ref2[1];
        return [Math.min(min, cur), Math.max(max, cur)];
      }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]),
      _originRowIndex$reduc2 = (0, _slicedToArray2.default)(_originRowIndex$reduc, 2),
      originMin = _originRowIndex$reduc2[0],
      originMax = _originRowIndex$reduc2[1];
    var originalRowRanges = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(originMin, originMax)(tr);
    var targetRowRanges = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(targetRowIndex)(tr);
    var indexesOriginRow = (originalRowRanges === null || originalRowRanges === void 0 ? void 0 : originalRowRanges.indexes) || [];
    var indexesTargetRow = (targetRowRanges === null || targetRowRanges === void 0 ? void 0 : targetRowRanges.indexes) || [];
    if (originMin < 0 || originMin === Number.MAX_SAFE_INTEGER || originMax >= tableMap.height || originMax === Number.MIN_SAFE_INTEGER ||
    // The target index cannot be within the origin bounds
    targetRowIndex >= originMin && targetRowIndex <= originMax) {
      return tr;
    }
    if (!options.tryToFit && indexesTargetRow.length > 1) {
      (0, _reorderUtils.isValidReorder)(originMin, targetRowIndex, indexesTargetRow, 'row');
    }
    var types = (0, _tableNodeTypes.tableNodeTypes)(state.schema);
    var direction = (0, _normalizeDirection.normalizeDirection)(originMin, targetRowIndex, options);
    var actualTargetIndex = Math[direction === 'start' ? 'min' : 'max'].apply(Math, (0, _toConsumableArray2.default)(indexesTargetRow));
    var originPositions = indexesOriginRow.map(function (index) {
      return tableMap.positionAt(index, 0, table.node) + table.pos;
    });
    var originNodes = originPositions.reduce(function (acc, pos) {
      var node = tr.doc.nodeAt(tr.mapping.map(pos));
      if (node) {
        return [].concat((0, _toConsumableArray2.default)(acc), [{
          pos: pos,
          node: node
        }]);
      }
      return acc;
    }, []);
    var targetPos = tableMap.positionAt(actualTargetIndex, 0, table.node) + table.pos;
    var targetNode = tr.doc.nodeAt(tr.mapping.map(targetPos));
    if (originNodes !== null && originNodes !== void 0 && originNodes.length && targetNode) {
      var newTr = (0, _cloneTr.cloneTr)(tr);
      var _determineTableHeader = (0, _analyseTable.determineTableHeaderStateFromTableNode)(table.node, tableMap, types),
        rowHeaderEnabled = _determineTableHeader.rowHeaderEnabled,
        columnHeaderEnabled = _determineTableHeader.columnHeaderEnabled;
      if (rowHeaderEnabled && (originMin === 0 || actualTargetIndex === 0)) {
        // This block is handling the situation where a row is moved in/out of the header position. If the header row option
        // is enabled then;
        // When a row is moved out, the row will be converted to a normal row and the row below it will become the header.
        // When a row is moved in, the old row header needs to be made normal, and the incoming row needs to be made a header.
        // This section only manages what happens to the other row, no the one being moved.
        var nearHeaderPos = tableMap.positionAt(originMin === 0 ? originMax + 1 : actualTargetIndex, 0, table.node) + table.pos;
        var nearHeaderNode = newTr.doc.nodeAt(newTr.mapping.map(nearHeaderPos));
        if (nearHeaderNode) {
          nearHeaderNode.forEach(function (node, offset, index) {
            var start = newTr.mapping.map(nearHeaderPos + 1 + offset);
            newTr.setNodeMarkup(start, actualTargetIndex !== 0 || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell, node.attrs);
          });
        }
      }
      var insertPos = direction === 'end' ? newTr.mapping.map(targetPos + targetNode.nodeSize, 1) : newTr.mapping.map(targetPos, -1);
      newTr.insert(insertPos, originNodes.map(function (_ref3, index) {
        var node = _ref3.node;
        return normalizeRowNode(node, rowHeaderEnabled && actualTargetIndex === 0 && index === 0, columnHeaderEnabled, types);
      }));

      // IMPORTANT: We need to perform the selection between the insert/delete. This is because the delete could cause
      // the current selection to be pushed out of the table resulting in an invalid selection range outside of the table
      if (options.selectAfterMove) {
        var offset = direction === 'end' ? 1 : 0;
        var selectionRange = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(actualTargetIndex + offset, actualTargetIndex + offset + originNodes.length - 1)(newTr);
        if (selectionRange) {
          newTr.setSelection(new _cellSelection.CellSelection(selectionRange.$anchor, selectionRange.$head));
        }
      }
      originNodes.forEach(function (_ref4) {
        var pos = _ref4.pos,
          node = _ref4.node;
        newTr.delete(newTr.mapping.map(pos, 1), newTr.mapping.map(pos + node.nodeSize, -1));
      });
      return newTr;
    }
    return tr;
  };
};

/**
 * This ensures the row node cell type correctly reflect what they should be.
 * @returns A copy of the rowNode
 */
function normalizeRowNode(rowNode, rowHeaderEnabled, columnHeaderEnabled, types) {
  var content = [];
  rowNode.forEach(function (node, offset, index) {
    var newTargetType = rowHeaderEnabled || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell;
    content.push(node.type !== newTargetType ? newTargetType.create(node.attrs, node.content, node.marks) : node);
  });
  return rowNode.type.create(rowNode.attrs, content, rowNode.marks);
}