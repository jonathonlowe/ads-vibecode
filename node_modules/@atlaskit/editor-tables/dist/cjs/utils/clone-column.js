"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneColumn = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _cellSelection = require("../cell-selection");
var _tableMap = require("../table-map");
var _analyseTable = require("./analyse-table");
var _cloneTr = require("./clone-tr");
var _find = require("./find");
var _getSelectionRangeInColumn = require("./get-selection-range-in-column");
var _reorderUtils = require("./reorder-utils");
var _tableNodeTypes = require("./table-node-types");
function normalizeDirection(targetDirection, options) {
  var _options$direction;
  var override = ((_options$direction = options === null || options === void 0 ? void 0 : options.direction) !== null && _options$direction !== void 0 ? _options$direction : 0) < 0 ? 'start' : 'end';
  return options !== null && options !== void 0 && options.tryToFit && !!(options !== null && options !== void 0 && options.direction) ? override : targetDirection;
}
var cloneColumn = exports.cloneColumn = function cloneColumn(state, originColumnIndex, targetColumnIndex, targetDirection) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
    tryToFit: false,
    direction: 0,
    selectAfterClone: false
  };
  return function (tr) {
    var _originalColumnRanges, _targetColumnRanges$i;
    var table = (0, _find.findTable)(tr.selection);
    if (!table) {
      return tr;
    }

    // normalize the origin index to an array since this supports moving both a single & multiple cols in a single action.
    if (!Array.isArray(originColumnIndex)) {
      originColumnIndex = [originColumnIndex];
    }
    var tableMap = _tableMap.TableMap.get(table.node);
    var originalColumnRanges = (0, _getSelectionRangeInColumn.getSelectionRangeInColumn)(Math.min.apply(Math, (0, _toConsumableArray2.default)(originColumnIndex)), Math.max.apply(Math, (0, _toConsumableArray2.default)(originColumnIndex)))(tr);
    var targetColumnRanges = (0, _getSelectionRangeInColumn.getSelectionRangeInColumn)(targetColumnIndex)(tr);
    var indexesOriginColumn = (_originalColumnRanges = originalColumnRanges === null || originalColumnRanges === void 0 ? void 0 : originalColumnRanges.indexes) !== null && _originalColumnRanges !== void 0 ? _originalColumnRanges : [];
    var indexesTargetColumn = (_targetColumnRanges$i = targetColumnRanges === null || targetColumnRanges === void 0 ? void 0 : targetColumnRanges.indexes) !== null && _targetColumnRanges$i !== void 0 ? _targetColumnRanges$i : [];
    var min = indexesOriginColumn[0];
    var max = indexesOriginColumn[indexesOriginColumn.length - 1];
    if (!options.tryToFit && indexesTargetColumn.length > 1) {
      (0, _reorderUtils.isValidReorder)(originColumnIndex[0], targetColumnIndex, indexesTargetColumn, 'column');
    }
    var types = (0, _tableNodeTypes.tableNodeTypes)(state.schema);
    var direction = normalizeDirection(targetDirection, options);
    var actualTargetIndex = Math[direction === 'start' ? 'min' : 'max'].apply(Math, (0, _toConsumableArray2.default)(indexesTargetColumn));
    var _determineTableHeader = (0, _analyseTable.determineTableHeaderStateFromTableNode)(table.node, tableMap, types),
      rowHeaderEnabled = _determineTableHeader.rowHeaderEnabled,
      columnHeaderEnabled = _determineTableHeader.columnHeaderEnabled;
    var createContentNode = createContentNodeFactory(table);
    var newTr = (0, _cloneTr.cloneTr)(tr);
    var origins = [];
    for (var y = 0; y < tableMap.height; y++) {
      origins.push([]);
      for (var x = min; x <= max; x++) {
        if (tableMap.isCellMergedTopLeft(y, x)) {
          continue;
        }
        var nodePos = tableMap.map[y * tableMap.width + x];
        origins[y].push(createContentNode(nodePos));
      }
      if (columnHeaderEnabled && actualTargetIndex === 0 && direction === 'start') {
        // This block is handling the situation where a col is moved in/out of the header position. If the header col option
        // is enabled then;
        // When a col is moved out, the col will be converted to a normal col and the col to the right will become the header.
        // When a col is moved in, the old col header needs to be made normal, and the incoming col needs to be made a header.
        // This section only manages what happens to the other col, not the one being moved.
        var nearHeaderCol = min === 0 ? max + 1 : actualTargetIndex;
        var _nodePos = tableMap.map[y * tableMap.width + nearHeaderCol];
        var _createContentNode = createContentNode(_nodePos),
          pos = _createContentNode.pos,
          node = _createContentNode.node;
        newTr.setNodeMarkup(pos, actualTargetIndex !== 0 || rowHeaderEnabled && y === 0 ? types.header_cell : types.cell, node.attrs);
      }
    }
    origins.forEach(function (row, y) {
      if (!row.length) {
        // If the origin has no cells to be moved then we can skip moving for this row. This can occur when a cell above rowspans
        // into the current row.
        return;
      }

      // The actual target index needs to be translated per row, this is because row/col spans can affect the amount of
      // cells each row contains.
      var rowTargetPosition = translateTargetPosition(y, actualTargetIndex, tableMap);
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var node = table.node.nodeAt(rowTargetPosition);
      var pos = table.start + rowTargetPosition;
      var insertPos = direction === 'end' ? newTr.mapping.map(pos + node.nodeSize, 1) : newTr.mapping.map(pos, -1);
      return newTr.insert(insertPos, row.map(function (_ref, x) {
        var node = _ref.node;
        return normalizeCellNode(node, rowHeaderEnabled && y === 0, columnHeaderEnabled && actualTargetIndex === 0 && x === 0 && direction === 'start', types);
      }));
    });
    if (options.selectAfterClone) {
      var offset = direction === 'end' ? 1 : 0;
      var selectionRange = (0, _getSelectionRangeInColumn.getSelectionRangeInColumn)(actualTargetIndex + offset, actualTargetIndex + offset + indexesOriginColumn.length - 1)(newTr);
      if (selectionRange) {
        newTr.setSelection(new _cellSelection.CellSelection(selectionRange.$anchor, selectionRange.$head));
      }
    }
    return newTr;
  };
};
function normalizeCellNode(cellNode, rowHeaderEnabled, columnHeaderEnabled, types) {
  var newTargetType = rowHeaderEnabled || columnHeaderEnabled ? types.header_cell : types.cell;
  return cellNode.type !== newTargetType ? newTargetType.create(cellNode.attrs, cellNode.content, cellNode.marks) : cellNode;
}
function createContentNodeFactory(table) {
  return function (nodePos) {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var node = table.node.nodeAt(nodePos);
    var pos = nodePos + table.start;
    return {
      pos: pos,
      start: pos + 1,
      node: node,
      depth: table.depth + 2
    };
  };
}
function translateTargetPosition(row, startIndex, tableMap) {
  if (tableMap.isCellMergedTopLeft(row, startIndex)) {
    // find the closet unmerged position to the left of the target. We scan left first because merged cells will actually
    // reduce the amount of cells in a row.
    for (var x = startIndex - 1; x >= 0; x--) {
      if (!tableMap.isCellMergedTopLeft(row, x)) {
        return tableMap.map[row * tableMap.width + x];
      }
    }

    // If no index found then we need to look to the right, this can occur when the first cell in the row is merged.
    for (var _x = startIndex + 1; _x < tableMap.width; _x++) {
      if (!tableMap.isCellMergedTopLeft(row, _x)) {
        return tableMap.map[row * tableMap.width + _x];
      }
    }
  }
  return tableMap.map[row * tableMap.width + startIndex];
}