"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transpose = exports.moveTableRow = exports.moveTableColumn = exports.isValidReorder = exports.convertTableNodeToArrayOfRows = exports.convertArrayOfRowsToTableNode = void 0;
var _tableMap = require("../table-map");
// array = [
//   [A1, B1, C1, null],
//   [A2, B2, null, D1],
//   [A3. B3, C2, null],
// ]

// This function transposes an array of array flipping the columns for rows,
// transposition is a familiar algebra concept;
// you can get more details here:
// https://en.wikipedia.org/wiki/Transpose
//
// ```javascript
//
//  const arr = [
//    ['a1', 'a2', 'a3'],
//    ['b1', 'b2', 'b3'],
//    ['c1', 'c2', 'c3'],
//    ['d1', 'd2', 'd3'],
//  ];
//
//  const result = transpose(arr);
//
//  result === [
//    ['a1', 'b1', 'c1', 'd1'],
//    ['a2', 'b2', 'c2', 'd2'],
//    ['a3', 'b3', 'c3', 'd3'],
//  ]
// ```
// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var transpose = exports.transpose = function transpose(array) {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return array[0].map(function (_, i) {
    return array.map(function (column) {
      return column[i];
    });
  });
};

// :: (tableNode: Node, tableArray: Array<Node>) -> Node
// This function will transform a matrix of nodes
// into table node respecting merged cells and rows configurations,
// for example this array will be convert to the table below:
//
// ```javascript
// array = [
//   [A1, B1, C1, null],
//   [A2, B2, null, D1],
//   [A3. B3, C2, null],
// ]
// ```
//
// ```
//  ____________________________
// |      |      |             |
// |  A1  |  B1  |     C1      |
// |______|______|______ ______|
// |      |             |      |
// |  A2  |     B2      |      |
// |______|______ ______|      |
// |      |      |      |  D1  |
// |  A3  |  B3  |  C2  |      |
// |______|______|______|______|
// ```
//
var convertArrayOfRowsToTableNode = exports.convertArrayOfRowsToTableNode = function convertArrayOfRowsToTableNode(tableNode, arrayOfNodes) {
  var rowsPM = [];
  var map = _tableMap.TableMap.get(tableNode);
  for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
    var row = tableNode.child(rowIndex);
    var rowCells = [];
    for (var colIndex = 0; colIndex < map.width; colIndex++) {
      if (!arrayOfNodes[rowIndex][colIndex]) {
        continue;
      }
      var cellPos = map.map[rowIndex * map.width + colIndex];
      var cell = arrayOfNodes[rowIndex][colIndex];
      var oldCell = tableNode.nodeAt(cellPos);
      if (!cell || !oldCell) {
        continue;
      }
      var newCell = oldCell.type.createChecked(Object.assign({}, cell.attrs), cell.content, cell.marks);
      rowCells.push(newCell);
    }
    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));
  }
  var newTable = tableNode.type.createChecked(tableNode.attrs, rowsPM, tableNode.marks);
  return newTable;
};
var moveRowInArrayOfRows = function moveRowInArrayOfRows(arrayOfNodes, indexesOrigin, indexesTarget, directionOverride) {
  var direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;
  var rowsExtracted = arrayOfNodes.splice(indexesOrigin[0], indexesOrigin.length);
  var positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;
  var target;
  if (directionOverride === -1 && direction === 1) {
    target = indexesTarget[0] - 1;
  } else if (directionOverride === 1 && direction === -1) {
    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;
  } else {
    target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;
  }

  // @ts-ignore no idea what this line does
  arrayOfNodes.splice.apply(arrayOfNodes, [target, 0].concat(rowsExtracted));
  return arrayOfNodes;
};

// :: (tableNode: Node) -> Array<Node>
// This function will transform the table node
// into a matrix of rows and columns respecting merged cells,
// for example this table will be convert to the below:
//
// ```
//  ____________________________
// |      |      |             |
// |  A1  |  B1  |     C1      |
// |______|______|______ ______|
// |      |             |      |
// |  A2  |     B2      |      |
// |______|______ ______|      |
// |      |      |      |  D1  |
// |  A3  |  B3  |  C2  |      |
// |______|______|______|______|
// ```
//
//
// ```javascript
// array = [
//   [A1, B1, C1, null],
//   [A2, B2, null, D1],
//   [A3. B3, C2, null],
// ]
// ```
var convertTableNodeToArrayOfRows = exports.convertTableNodeToArrayOfRows = function convertTableNodeToArrayOfRows(tableNode) {
  var map = _tableMap.TableMap.get(tableNode);
  var rows = [];
  for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
    var rowCells = [];
    var seen = {};
    for (var colIndex = 0; colIndex < map.width; colIndex++) {
      var cellPos = map.map[rowIndex * map.width + colIndex];
      var cell = tableNode.nodeAt(cellPos);
      var rect = map.findCell(cellPos);
      if (!cell || seen[cellPos] || rect.top !== rowIndex) {
        rowCells.push(null);
        continue;
      }
      seen[cellPos] = true;
      rowCells.push(cell);
    }
    rows.push(rowCells);
  }
  return rows;
};
var moveTableRow = exports.moveTableRow = function moveTableRow(table, indexesOrigin, indexesTarget, direction) {
  var rows = convertTableNodeToArrayOfRows(table.node);
  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
  return convertArrayOfRowsToTableNode(table.node, rows);
};
var moveTableColumn = exports.moveTableColumn = function moveTableColumn(table, indexesOrigin, indexesTarget, direction) {
  var rows = transpose(convertTableNodeToArrayOfRows(table.node));
  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
  rows = transpose(rows);
  return convertArrayOfRowsToTableNode(table.node, rows);
};
var isValidReorder = exports.isValidReorder = function isValidReorder(originIndex, targetIndex, targets, type) {
  var direction = originIndex > targetIndex ? -1 : 1;
  var errorMessage = "Target position is invalid, you can't move the ".concat(type, " ").concat(originIndex, " to ").concat(targetIndex, ", the target can't be split. You could use tryToFit option.");
  if (direction === 1) {
    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {
      throw new Error(errorMessage);
    }
  } else {
    if (targets.slice(1).indexOf(targetIndex) !== -1) {
      throw new Error(errorMessage);
    }
  }
  return true;
};