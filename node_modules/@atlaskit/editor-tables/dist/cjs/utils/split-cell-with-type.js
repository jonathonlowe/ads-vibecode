"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cellWrapping = cellWrapping;
exports.splitCellWithType = splitCellWithType;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _model = require("@atlaskit/editor-prosemirror/model");
var _cellSelection = require("../cell-selection");
var _cells = require("./cells");
var _selectionRect = require("./selection-rect");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) {
    // Sometimes the cell can be in the same depth.
    var role = $pos.node(d).type.spec.tableRole;
    if (role === 'cell' || role === 'header_cell') {
      return $pos.node(d);
    }
  }
  return null;
}
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
function splitCellWithType(getCellType) {
  return function (state, dispatch) {
    var sel = state.selection;
    var cellNode, cellPos;
    if (!(sel instanceof _cellSelection.CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) {
        return false;
      }
      var cellNodeAround = (0, _cells.cellAround)(sel.$from);
      cellPos = cellNodeAround && cellNodeAround.pos;
    } else {
      if (sel.$anchorCell.pos !== sel.$headCell.pos) {
        return false;
      }
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode && cellNode.attrs.colspan === 1 && cellNode.attrs.rowspan === 1) {
      return false;
    }
    if (cellNode && dispatch) {
      var cellAttrs = cellNode.attrs;
      var attrs = [];
      var colwidth = cellAttrs.colwidth;
      if (cellAttrs.rowspan && cellAttrs.rowspan > 1) {
        cellAttrs = _objectSpread(_objectSpread({}, cellAttrs), {}, {
          rowspan: 1
        });
      }
      if (cellAttrs.colspan && cellAttrs.colspan > 1) {
        cellAttrs = _objectSpread(_objectSpread({}, cellAttrs), {}, {
          colspan: 1
        });
      }
      var rect = (0, _selectionRect.selectedRect)(state);
      var tr = state.tr;
      for (var i = 0; i < rect.right - rect.left; i++) {
        attrs.push(colwidth ? _objectSpread(_objectSpread({}, cellAttrs), {}, {
          colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
        }) : cellAttrs);
      }
      var lastCell = null;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row === rect.top) {
          pos += cellNode.nodeSize;
        }
        for (var col = rect.left, _i = 0; col < rect.right; col++, _i++) {
          if (col === rect.left && row === rect.top) {
            continue;
          }
          var cellType = getCellType({
            node: cellNode,
            row: row,
            col: col
          }).createAndFill(attrs[_i]);
          if (cellType) {
            tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), cellType);
          }
        }
      }
      if (typeof cellPos === 'number') {
        tr.setNodeMarkup(cellPos, getCellType({
          node: cellNode,
          row: rect.top,
          col: rect.left
        }), attrs[0]);
      }
      var $lastCellPosition = lastCell && tr.doc.resolve(lastCell);
      if (sel instanceof _cellSelection.CellSelection && $lastCellPosition instanceof _model.ResolvedPos) {
        var cellSelection = new _cellSelection.CellSelection(tr.doc.resolve(sel.$anchorCell.pos), $lastCellPosition);
        tr.setSelection(cellSelection);
      }
      dispatch(tr);
    }
    return true;
  };
}