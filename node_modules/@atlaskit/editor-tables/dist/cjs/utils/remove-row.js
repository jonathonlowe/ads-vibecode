"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeSelectedRows = exports.removeRowClosestToPos = exports.removeRowAt = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _tableMap = require("../table-map");
var _cloneTr = require("./clone-tr");
var _find = require("./find");
var _isSelected = require("./is-selected");
var _isSelectionType = require("./is-selection-type");
var _removeTable = require("./remove-table");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function removeRow(tr, _ref, rowIndex) {
  var map = _ref.map,
    table = _ref.table,
    tableStart = _ref.tableStart;
  var rowPos = 0;
  for (var i = 0; i < rowIndex; i++) {
    rowPos += table.child(i).nodeSize;
  }
  var nextRow = rowPos + table.child(rowIndex).nodeSize;
  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  for (var col = 0, index = rowIndex * map.width; col < map.width; col++, index++) {
    var pos = map.map[index];
    if (rowIndex > 0 && pos === map.map[index - map.width]) {
      // If this cell starts in the row above, simply reduce its rowspan
      var cell = table.nodeAt(pos);
      if (!cell) {
        continue;
      }
      var attrs = cell.attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), undefined, _objectSpread(_objectSpread({}, attrs), {}, {
        rowspan: attrs.rowspan - 1
      }));
      col += attrs.colspan - 1;
    } else if (rowIndex < map.width && pos === map.map[index + map.width]) {
      // Else, if it continues in the row below, it has to be moved down
      var _cell = table.nodeAt(pos);
      if (!_cell) {
        continue;
      }
      var copy = _cell.type.create(_objectSpread(_objectSpread({}, _cell.attrs), {}, {
        rowspan: _cell.attrs.rowspan - 1
      }), _cell.content);
      var newPos = map.positionAt(rowIndex + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += _cell.attrs.colspan - 1;
    }
  }
  return tr;
}

// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.
var removeRowAt = exports.removeRowAt = function removeRowAt(rowIndex) {
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      if (rowIndex === 0 && map.height === 1) {
        return (0, _removeTable.removeTable)(tr);
      } else if (rowIndex >= 0 && rowIndex <= map.height) {
        removeRow(tr, {
          map: map,
          tableStart: table.start,
          table: table.node
        }, rowIndex);
        return (0, _cloneTr.cloneTr)(tr);
      }
    }
    return tr;
  };
};

// Returns a new transaction that removes selected rows.
var removeSelectedRows = exports.removeSelectedRows = function removeSelectedRows(tr) {
  var selection = tr.selection;
  if ((0, _isSelected.isTableSelected)(selection)) {
    return (0, _removeTable.removeTable)(tr);
  }
  if ((0, _isSelectionType.isSelectionType)(selection, 'cell')) {
    var table = (0, _find.findTable)(selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
      if (rect.top === 0 && rect.bottom === map.height) {
        return tr;
      }
      var pmTableRect = _objectSpread(_objectSpread({}, rect), {}, {
        map: map,
        table: table.node,
        tableStart: table.start
      });
      for (var i = pmTableRect.bottom - 1;; i--) {
        removeRow(tr, pmTableRect, i);
        if (i === pmTableRect.top) {
          break;
        }
        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
        pmTableRect.map = _tableMap.TableMap.get(pmTableRect.table);
      }
      return (0, _cloneTr.cloneTr)(tr);
    }
  }
  return tr;
};

// Returns a new transaction that removes a row closest to a given `$pos`.
var removeRowClosestToPos = exports.removeRowClosestToPos = function removeRowClosestToPos($pos) {
  return function (tr) {
    var rect = (0, _find.findCellRectClosestToPos)($pos);
    if (rect) {
      return removeRowAt(rect.top)((0, _utils.setTextSelection)($pos.pos)(tr));
    }
    return tr;
  };
};