"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneRow = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _cellSelection = require("../cell-selection");
var _tableMap = require("../table-map");
var _analyseTable = require("./analyse-table");
var _cloneTr = require("./clone-tr");
var _find = require("./find");
var _getSelectionRangeInRow = require("./get-selection-range-in-row");
var _reorderUtils = require("./reorder-utils");
var _tableNodeTypes = require("./table-node-types");
function normalizeDirection(targetDirection, options) {
  var _options$direction;
  var override = ((_options$direction = options === null || options === void 0 ? void 0 : options.direction) !== null && _options$direction !== void 0 ? _options$direction : 0) < 0 ? 'start' : 'end';
  return options !== null && options !== void 0 && options.tryToFit && !!(options !== null && options !== void 0 && options.direction) ? override : targetDirection;
}
var cloneRow = exports.cloneRow = function cloneRow(state, originRowIndex, targetRowIndex, targetDirection) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
    tryToFit: false,
    direction: 0,
    selectAfterClone: false
  };
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (!table) {
      return tr;
    }

    // normalize the origin index to an array since move row support moving both a single & multiple rows in a single action.
    if (!Array.isArray(originRowIndex)) {
      originRowIndex = [originRowIndex];
    }
    var tableMap = _tableMap.TableMap.get(table.node);
    var _originRowIndex$reduc = originRowIndex.reduce(function (_ref, cur) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          min = _ref2[0],
          max = _ref2[1];
        return [Math.min(min, cur), Math.max(max, cur)];
      }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]),
      _originRowIndex$reduc2 = (0, _slicedToArray2.default)(_originRowIndex$reduc, 2),
      originMin = _originRowIndex$reduc2[0],
      originMax = _originRowIndex$reduc2[1];
    var originalRowRanges = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(originMin, originMax)(tr);
    var targetRowRanges = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(targetRowIndex)(tr);
    var indexesOriginRow = (originalRowRanges === null || originalRowRanges === void 0 ? void 0 : originalRowRanges.indexes) || [];
    var indexesTargetRow = (targetRowRanges === null || targetRowRanges === void 0 ? void 0 : targetRowRanges.indexes) || [];
    if (originMin < 0 || originMin === Number.MAX_SAFE_INTEGER || originMax >= tableMap.height || originMax === Number.MIN_SAFE_INTEGER) {
      return tr;
    }
    if (!options.tryToFit && indexesTargetRow.length > 1) {
      (0, _reorderUtils.isValidReorder)(originMin, targetRowIndex, indexesTargetRow, 'row');
    }
    var types = (0, _tableNodeTypes.tableNodeTypes)(state.schema);
    var direction = normalizeDirection(targetDirection, options);
    var actualTargetIndex = Math[direction === 'start' ? 'min' : 'max'].apply(Math, (0, _toConsumableArray2.default)(indexesTargetRow));
    var originPositions = indexesOriginRow.map(function (index) {
      return tableMap.positionAt(index, 0, table.node) + table.pos;
    });
    var originNodes = originPositions.reduce(function (acc, pos) {
      var node = tr.doc.nodeAt(tr.mapping.map(pos));
      if (node) {
        return [].concat((0, _toConsumableArray2.default)(acc), [{
          pos: pos,
          node: node
        }]);
      }
      return acc;
    }, []);
    var targetPos = tableMap.positionAt(actualTargetIndex, 0, table.node) + table.pos;
    var targetNode = tr.doc.nodeAt(tr.mapping.map(targetPos));
    if (originNodes !== null && originNodes !== void 0 && originNodes.length && targetNode) {
      var newTr = (0, _cloneTr.cloneTr)(tr);
      var _determineTableHeader = (0, _analyseTable.determineTableHeaderStateFromTableNode)(table.node, tableMap, types),
        rowHeaderEnabled = _determineTableHeader.rowHeaderEnabled,
        columnHeaderEnabled = _determineTableHeader.columnHeaderEnabled;
      if (rowHeaderEnabled && actualTargetIndex === 0 && direction === 'start') {
        // This block is handling the situation where a row is moved in/out of the header position. If the header row option
        // is enabled then;
        // When a row is moved out, the row will be converted to a normal row and the row below it will become the header.
        // When a row is moved in, the old row header needs to be made normal, and the incoming row needs to be made a header.
        // This section only manages what happens to the other row, no the one being moved.
        var nearHeaderPos = tableMap.positionAt(originMin === 0 ? originMax + 1 : actualTargetIndex, 0, table.node) + table.pos;
        var nearHeaderNode = newTr.doc.nodeAt(newTr.mapping.map(nearHeaderPos));
        if (nearHeaderNode) {
          nearHeaderNode.forEach(function (node, offset, index) {
            var start = newTr.mapping.map(nearHeaderPos + 1 + offset);
            newTr.setNodeMarkup(start, actualTargetIndex !== 0 || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell, node.attrs);
          });
        }
      }
      var insertPos = direction === 'end' ? newTr.mapping.map(targetPos + targetNode.nodeSize, 1) : newTr.mapping.map(targetPos, -1);
      newTr.insert(insertPos, originNodes.map(function (_ref3, index) {
        var node = _ref3.node;
        return normalizeRowNode(node, rowHeaderEnabled && actualTargetIndex === 0 && index === 0 && direction === 'start', columnHeaderEnabled, types);
      }));
      if (options.selectAfterClone) {
        var offset = direction === 'end' ? 1 : 0;
        var selectionRange = (0, _getSelectionRangeInRow.getSelectionRangeInRow)(actualTargetIndex + offset, actualTargetIndex + offset + originNodes.length - 1)(newTr);
        if (selectionRange) {
          newTr.setSelection(new _cellSelection.CellSelection(selectionRange.$anchor, selectionRange.$head));
        }
      }
      return newTr;
    }
    return tr;
  };
};

/**
 * This ensures the row node cell type correctly reflect what they should be.
 * @returns A copy of the rowNode
 */
function normalizeRowNode(rowNode, rowHeaderEnabled, columnHeaderEnabled, types) {
  var content = [];
  rowNode.forEach(function (node, offset, index) {
    var newTargetType = rowHeaderEnabled || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell;
    content.push(node.type !== newTargetType ? newTargetType.create(node.attrs, node.content, node.marks) : node);
  });
  return rowNode.type.create(rowNode.attrs, content, rowNode.marks);
}