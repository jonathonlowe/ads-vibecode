"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeSelectedColumns = exports.removeColumnClosestToPos = exports.removeColumnAt = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _tableMap = require("../table-map");
var _cloneTr = require("./clone-tr");
var _colspan = require("./colspan");
var _find = require("./find");
var _isSelected = require("./is-selected");
var _isSelectionType = require("./is-selection-type");
var _removeTable = require("./remove-table");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function removeColumn(tr, _ref, columnIndex) {
  var map = _ref.map,
    table = _ref.table,
    tableStart = _ref.tableStart;
  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map.height;) {
    var index = row * map.width + columnIndex;
    var pos = map.map[index];
    var cell = table.nodeAt(pos);
    if (!cell) {
      continue;
    }

    // If this is part of a col-spanning cell
    if (columnIndex > 0 && map.map[index - 1] === pos || columnIndex < map.width - 1 && map.map[index + 1] === pos) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), undefined, (0, _colspan.removeColSpan)(cell.attrs, columnIndex - map.colCount(pos)));
    } else {
      var start = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start, start + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
  return tr;
}

// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.
var removeColumnAt = exports.removeColumnAt = function removeColumnAt(columnIndex) {
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      if (columnIndex === 0 && map.width === 1) {
        return (0, _removeTable.removeTable)(tr);
      } else if (columnIndex >= 0 && columnIndex <= map.width) {
        removeColumn(tr, {
          map: map,
          tableStart: table.start,
          table: table.node
        }, columnIndex);
        return (0, _cloneTr.cloneTr)(tr);
      }
    }
    return tr;
  };
};

// Returns a new transaction that removes selected columns.
var removeSelectedColumns = exports.removeSelectedColumns = function removeSelectedColumns(tr) {
  var selection = tr.selection;
  if ((0, _isSelected.isTableSelected)(selection)) {
    return (0, _removeTable.removeTable)(tr);
  }
  if ((0, _isSelectionType.isSelectionType)(selection, 'cell')) {
    var table = (0, _find.findTable)(selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
      if (rect.left === 0 && rect.right === map.width) {
        return tr;
      }
      var pmTableRect = _objectSpread(_objectSpread({}, rect), {}, {
        map: map,
        table: table.node,
        tableStart: table.start
      });
      for (var i = pmTableRect.right - 1;; i--) {
        removeColumn(tr, pmTableRect, i);
        if (i === pmTableRect.left) {
          break;
        }
        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
        pmTableRect.map = _tableMap.TableMap.get(pmTableRect.table);
      }
      return (0, _cloneTr.cloneTr)(tr);
    }
  }
  return tr;
};

// Returns a new transaction that removes a column closest to a given `$pos`.
var removeColumnClosestToPos = exports.removeColumnClosestToPos = function removeColumnClosestToPos($pos) {
  return function (tr) {
    var rect = (0, _find.findCellRectClosestToPos)($pos);
    if (rect) {
      return removeColumnAt(rect.left)((0, _utils.setTextSelection)($pos.pos)(tr));
    }
    return tr;
  };
};