"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isHeaderEnabledByType = isHeaderEnabledByType;
exports.toggleHeader = toggleHeader;
var _tableMap = require("../table-map");
var _selectionRect = require("./selection-rect");
var _tableNodeTypes = require("./table-node-types");
var _tables = require("./tables");
function isHeaderEnabledByType(type, rect, types) {
  // Get cell positions for first row or first column
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type === 'row' ? rect.map.width : 1,
    bottom: type === 'column' ? rect.map.height : 1
  });
  for (var i = 0; i < cellPositions.length; i++) {
    var cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}

// Toggles between row/column header and normal cells (Only applies to first row/column).
function toggleHeader(type) {
  return function (state, dispatch) {
    if (!(0, _tables.isInTable)(state)) {
      return false;
    }
    if (dispatch) {
      var types = (0, _tableNodeTypes.tableNodeTypes)(state.schema);
      var rect = (0, _selectionRect.selectedRect)(state),
        tr = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);
      var isHeaderEnabled = type === 'column' ? isHeaderRowEnabled : type === 'row' ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type === 'column' ? new _tableMap.Rect(0, selectionStartsAt, 1, rect.map.height) : type === 'row' ? new _tableMap.Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
      var newType;
      if (type === 'column') {
        newType = isHeaderColumnEnabled ? types.cell : types.header_cell;
      } else if (type === 'row') {
        newType = isHeaderRowEnabled ? types.cell : types.header_cell;
      } else {
        newType = types.cell;
      }
      rect.map.cellsInRect(cellsRect).forEach(function (relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}