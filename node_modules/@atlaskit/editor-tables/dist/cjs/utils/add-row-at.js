"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneRowAt = exports.addRowAt = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _tableMap = require("../table-map");
var _addRow = require("./add-row");
var _cloneTr = require("./clone-tr");
var _find = require("./find");
var _getCellsInRow = require("./get-cells-in-row");
var _setCellAttrs = require("./set-cell-attrs");
var _tableNodeTypes = require("./table-node-types");
var filterCellsInRow = function filterCellsInRow(rowIndex, predicate) {
  return function (tr) {
    var foundCells = [];
    var cells = (0, _getCellsInRow.getCellsInRow)(rowIndex)(tr.selection);
    if (cells) {
      for (var j = cells.length - 1; j >= 0; j--) {
        if (predicate(cells[j], tr)) {
          foundCells.push(cells[j]);
        }
      }
    }
    return foundCells;
  };
};

// Returns a new transaction that adds a new row after `cloneRowIndex`, cloning the row attributes at `cloneRowIndex`.
var cloneRowAt = exports.cloneRowAt = function cloneRowAt(rowIndex) {
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      if (rowIndex >= 0 && rowIndex <= map.height) {
        var tableNode = table.node;
        var tableNodes = (0, _tableNodeTypes.tableNodeTypes)(tableNode.type.schema);
        var rowPos = table.start;
        for (var i = 0; i < rowIndex + 1; i++) {
          rowPos += tableNode.child(i).nodeSize;
        }
        var cloneRow = tableNode.child(rowIndex);
        // Re-create the same nodes with same attrs, dropping the node content.
        var cells = [];
        var rowWidth = 0;
        cloneRow.forEach(function (cell) {
          // If we're copying a row with rowspan somewhere, we dont want to copy that cell
          // We'll increment its span below.
          if (cell.attrs.rowspan === 1) {
            rowWidth += cell.attrs.colspan;
            var node = tableNodes[cell.type.spec.tableRole].createAndFill(cell.attrs, [], cell.marks);
            if (node) {
              cells.push(node);
            }
          }
        });

        // If a higher row spans past our clone row, bump the higher row to cover this new row too.
        if (rowWidth < map.width) {
          var rowSpanCells = [];
          var _loop = function _loop(_i) {
            var foundCells = filterCellsInRow(_i, function (cell, tr) {
              var rowspan = cell.node.attrs.rowspan;
              var spanRange = _i + rowspan;
              return rowspan > 1 && spanRange > rowIndex;
            })(tr);
            rowSpanCells.push.apply(rowSpanCells, (0, _toConsumableArray2.default)(foundCells));
          };
          for (var _i = rowIndex; _i >= 0; _i--) {
            _loop(_i);
          }
          if (rowSpanCells.length) {
            rowSpanCells.forEach(function (cell) {
              tr = (0, _setCellAttrs.setCellAttrs)(cell, {
                rowspan: cell.node.attrs.rowspan + 1
              })(tr);
            });
          }
        }
        return (0, _utils.safeInsert)(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(tr);
      }
    }
    return tr;
  };
};

// Returns a new transaction that adds a new row at index `rowIndex`. Optionally clone the previous row.
var addRowAt = exports.addRowAt = function addRowAt(rowIndex, clonePreviousRow) {
  return function (tr) {
    var table = (0, _find.findTable)(tr.selection);
    if (table) {
      var map = _tableMap.TableMap.get(table.node);
      var cloneRowIndex = rowIndex - 1;
      if (clonePreviousRow && cloneRowIndex >= 0) {
        return (0, _cloneTr.cloneTr)(cloneRowAt(cloneRowIndex)(tr));
      }
      if (rowIndex >= 0 && rowIndex <= map.height) {
        return (0, _cloneTr.cloneTr)((0, _addRow.addRow)(tr, {
          map: map,
          tableStart: table.start,
          table: table.node
        }, rowIndex));
      }
    }
    return tr;
  };
};