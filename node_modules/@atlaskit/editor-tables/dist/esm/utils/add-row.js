import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { tableNodeTypes } from './table-node-types';
function rowIsHeader(map, table, row) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var col = 0; col < map.width; col++) {
    var cell = table.nodeAt(map.map[col + row * map.width]);
    if (cell && cell.type !== headerCell) {
      return false;
    }
  }
  return true;
}
export function addRow(tr, _ref, row) {
  var map = _ref.map,
    tableStart = _ref.tableStart,
    table = _ref.table;
  var rowPos = tableStart;
  for (var i = 0; i < row; i++) {
    rowPos += table.child(i).nodeSize;
  }
  var cells = [];
  var refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map, table, row + refRow)) {
    refRow = row === 0 || row === map.height ? null : 0;
  }
  for (var col = 0, index = map.width * row; col < map.width; col++, index++) {
    // Covered by a rowspan cell
    if (row > 0 && row < map.height && map.map[index] === map.map[index - map.width]) {
      var pos = map.map[index];
      var node = table.nodeAt(pos);
      if (!node) {
        throw new Error("addRow: node not found at pos ".concat(pos));
      }
      var attrs = node.attrs;
      tr.setNodeMarkup(tableStart + pos, undefined, _objectSpread(_objectSpread({}, attrs), {}, {
        rowspan: attrs.rowspan + 1
      }));
      col += attrs.colspan - 1;
    } else {
      var type = void 0;
      var _attrs = {};
      if (refRow == null) {
        type = tableNodeTypes(table.type.schema).cell;
      } else {
        var mappedPos = map.map[index + refRow * map.width];
        var cell = table.nodeAt(mappedPos);
        if (!cell) {
          throw new Error("addRow: invalid node at mapped pos ".concat(mappedPos));
        }
        type = cell.type;
        if (cell.attrs.background) {
          _attrs = {
            background: cell.attrs.background
          };
        }
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      cells.push(type.createAndFill(_attrs));
    }
  }
  var rowType = tableNodeTypes(table.type.schema).row;
  var rowCells = rowType.create(null, cells);
  tr.insert(rowPos, rowCells);
  return tr;
}