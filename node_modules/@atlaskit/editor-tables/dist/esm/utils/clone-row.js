import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { CellSelection } from '../cell-selection';
import { TableMap } from '../table-map';
import { determineTableHeaderStateFromTableNode } from './analyse-table';
import { cloneTr } from './clone-tr';
import { findTable } from './find';
import { getSelectionRangeInRow } from './get-selection-range-in-row';
import { isValidReorder } from './reorder-utils';
import { tableNodeTypes } from './table-node-types';
function normalizeDirection(targetDirection, options) {
  var _options$direction;
  var override = ((_options$direction = options === null || options === void 0 ? void 0 : options.direction) !== null && _options$direction !== void 0 ? _options$direction : 0) < 0 ? 'start' : 'end';
  return options !== null && options !== void 0 && options.tryToFit && !!(options !== null && options !== void 0 && options.direction) ? override : targetDirection;
}
export var cloneRow = function cloneRow(state, originRowIndex, targetRowIndex, targetDirection) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
    tryToFit: false,
    direction: 0,
    selectAfterClone: false
  };
  return function (tr) {
    var table = findTable(tr.selection);
    if (!table) {
      return tr;
    }

    // normalize the origin index to an array since move row support moving both a single & multiple rows in a single action.
    if (!Array.isArray(originRowIndex)) {
      originRowIndex = [originRowIndex];
    }
    var tableMap = TableMap.get(table.node);
    var _originRowIndex$reduc = originRowIndex.reduce(function (_ref, cur) {
        var _ref2 = _slicedToArray(_ref, 2),
          min = _ref2[0],
          max = _ref2[1];
        return [Math.min(min, cur), Math.max(max, cur)];
      }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]),
      _originRowIndex$reduc2 = _slicedToArray(_originRowIndex$reduc, 2),
      originMin = _originRowIndex$reduc2[0],
      originMax = _originRowIndex$reduc2[1];
    var originalRowRanges = getSelectionRangeInRow(originMin, originMax)(tr);
    var targetRowRanges = getSelectionRangeInRow(targetRowIndex)(tr);
    var indexesOriginRow = (originalRowRanges === null || originalRowRanges === void 0 ? void 0 : originalRowRanges.indexes) || [];
    var indexesTargetRow = (targetRowRanges === null || targetRowRanges === void 0 ? void 0 : targetRowRanges.indexes) || [];
    if (originMin < 0 || originMin === Number.MAX_SAFE_INTEGER || originMax >= tableMap.height || originMax === Number.MIN_SAFE_INTEGER) {
      return tr;
    }
    if (!options.tryToFit && indexesTargetRow.length > 1) {
      isValidReorder(originMin, targetRowIndex, indexesTargetRow, 'row');
    }
    var types = tableNodeTypes(state.schema);
    var direction = normalizeDirection(targetDirection, options);
    var actualTargetIndex = Math[direction === 'start' ? 'min' : 'max'].apply(Math, _toConsumableArray(indexesTargetRow));
    var originPositions = indexesOriginRow.map(function (index) {
      return tableMap.positionAt(index, 0, table.node) + table.pos;
    });
    var originNodes = originPositions.reduce(function (acc, pos) {
      var node = tr.doc.nodeAt(tr.mapping.map(pos));
      if (node) {
        return [].concat(_toConsumableArray(acc), [{
          pos: pos,
          node: node
        }]);
      }
      return acc;
    }, []);
    var targetPos = tableMap.positionAt(actualTargetIndex, 0, table.node) + table.pos;
    var targetNode = tr.doc.nodeAt(tr.mapping.map(targetPos));
    if (originNodes !== null && originNodes !== void 0 && originNodes.length && targetNode) {
      var newTr = cloneTr(tr);
      var _determineTableHeader = determineTableHeaderStateFromTableNode(table.node, tableMap, types),
        rowHeaderEnabled = _determineTableHeader.rowHeaderEnabled,
        columnHeaderEnabled = _determineTableHeader.columnHeaderEnabled;
      if (rowHeaderEnabled && actualTargetIndex === 0 && direction === 'start') {
        // This block is handling the situation where a row is moved in/out of the header position. If the header row option
        // is enabled then;
        // When a row is moved out, the row will be converted to a normal row and the row below it will become the header.
        // When a row is moved in, the old row header needs to be made normal, and the incoming row needs to be made a header.
        // This section only manages what happens to the other row, no the one being moved.
        var nearHeaderPos = tableMap.positionAt(originMin === 0 ? originMax + 1 : actualTargetIndex, 0, table.node) + table.pos;
        var nearHeaderNode = newTr.doc.nodeAt(newTr.mapping.map(nearHeaderPos));
        if (nearHeaderNode) {
          nearHeaderNode.forEach(function (node, offset, index) {
            var start = newTr.mapping.map(nearHeaderPos + 1 + offset);
            newTr.setNodeMarkup(start, actualTargetIndex !== 0 || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell, node.attrs);
          });
        }
      }
      var insertPos = direction === 'end' ? newTr.mapping.map(targetPos + targetNode.nodeSize, 1) : newTr.mapping.map(targetPos, -1);
      newTr.insert(insertPos, originNodes.map(function (_ref3, index) {
        var node = _ref3.node;
        return normalizeRowNode(node, rowHeaderEnabled && actualTargetIndex === 0 && index === 0 && direction === 'start', columnHeaderEnabled, types);
      }));
      if (options.selectAfterClone) {
        var offset = direction === 'end' ? 1 : 0;
        var selectionRange = getSelectionRangeInRow(actualTargetIndex + offset, actualTargetIndex + offset + originNodes.length - 1)(newTr);
        if (selectionRange) {
          newTr.setSelection(new CellSelection(selectionRange.$anchor, selectionRange.$head));
        }
      }
      return newTr;
    }
    return tr;
  };
};

/**
 * This ensures the row node cell type correctly reflect what they should be.
 * @returns A copy of the rowNode
 */
function normalizeRowNode(rowNode, rowHeaderEnabled, columnHeaderEnabled, types) {
  var content = [];
  rowNode.forEach(function (node, offset, index) {
    var newTargetType = rowHeaderEnabled || columnHeaderEnabled && index === 0 ? types.header_cell : types.cell;
    content.push(node.type !== newTargetType ? newTargetType.create(node.attrs, node.content, node.marks) : node);
  });
  return rowNode.type.create(rowNode.attrs, content, rowNode.marks);
}