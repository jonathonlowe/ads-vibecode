import { Rect } from '../table-map';
import { selectedRect } from './selection-rect';
import { tableNodeTypes } from './table-node-types';
import { isInTable } from './tables';
export function isHeaderEnabledByType(type, rect, types) {
  // Get cell positions for first row or first column
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type === 'row' ? rect.map.width : 1,
    bottom: type === 'column' ? rect.map.height : 1
  });
  for (var i = 0; i < cellPositions.length; i++) {
    var cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}

// Toggles between row/column header and normal cells (Only applies to first row/column).
export function toggleHeader(type) {
  return function (state, dispatch) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state),
        tr = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);
      var isHeaderEnabled = type === 'column' ? isHeaderRowEnabled : type === 'row' ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type === 'column' ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type === 'row' ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
      var newType;
      if (type === 'column') {
        newType = isHeaderColumnEnabled ? types.cell : types.header_cell;
      } else if (type === 'row') {
        newType = isHeaderRowEnabled ? types.cell : types.header_cell;
      } else {
        newType = types.cell;
      }
      rect.map.cellsInRect(cellsRect).forEach(function (relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}