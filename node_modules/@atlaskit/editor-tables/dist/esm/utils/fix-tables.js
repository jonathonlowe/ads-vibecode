import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { fixTablesKey } from '../pm-plugins/plugin-key';
import { TableMap, TableProblemTypes } from '../table-map';
import { removeColSpan } from './colspan';
import { tableNodeTypes } from './table-node-types';
// Helper for iterating through the nodes in a document that changed
// compared to the given previous document. Useful for avoiding
// duplicate work on each transaction.
function changedDescendants(old, cur, offsetStart, f) {
  var offset = offsetStart;
  var oldSize = old.childCount;
  var curSize = cur.childCount;
  // eslint-disable-next-line no-labels
  outer: for (var i = 0, j = 0; i < curSize; i++) {
    var child = cur.child(i);
    for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) === child) {
        j = scan + 1;
        offset += child.nodeSize;
        // eslint-disable-next-line no-continue, no-labels
        continue outer;
      }
    }
    f(child, offset);
    if (j < oldSize && old.child(j).sameMarkup(child)) {
      changedDescendants(old.child(j), child, offset + 1, f);
    } else {
      child.nodesBetween(0, child.content.size, f, offset + 1);
    }
    offset += child.nodeSize;
  }
}

// :: (EditorState, ?EditorState) → ?Transaction
// Inspect all tables in the given state's document and return a
// transaction that fixes them, if necessary. If `oldState` was
// provided, that is assumed to hold a previous, known-good state,
// which will be used to avoid re-scanning unchanged parts of the
// document.
export function fixTables(state, oldState, reportFixedTable) {
  var tr;
  var check = function check(node, pos) {
    if (node.type.spec.tableRole === 'table') {
      tr = fixTable(state, node, pos, tr, reportFixedTable);
    }
  };
  if (!oldState) {
    state.doc.descendants(check);
  } else if (oldState.doc !== state.doc) {
    changedDescendants(oldState.doc, state.doc, 0, check);
  }
  return tr;
}

// : (EditorState, Node, number, ?Transaction) → ?Transaction
// Fix the given table, if necessary. Will append to the transaction
// it was given, if non-null, or create a new one if necessary.
export function fixTable(state, table, tablePos, transaction, reportFixedTable) {
  var tr = transaction;
  var map = TableMap.get(table);
  if (!map.problems) {
    return tr;
  }
  if (!tr) {
    tr = state.tr;
  }

  // Track which rows we must add cells to, so that we can adjust that
  // when fixing collisions.
  var mustAdd = [];
  for (var i = 0; i < map.height; i++) {
    mustAdd.push(0);
  }
  for (var _i = 0; _i < map.problems.length; _i++) {
    var prob = map.problems[_i];
    if (reportFixedTable) {
      reportFixedTable({
        state: state,
        tr: tr,
        reason: prob.type || 'unknown'
      });
    }
    if (prob.type === TableProblemTypes.COLLISION) {
      var collision = prob;
      var cell = table.nodeAt(prob.pos);
      if (!cell) {
        throw new Error("fixTable: unable to find cell at pos ".concat(prob.pos));
      }
      for (var j = 0; j < cell.attrs.rowspan; j++) {
        mustAdd[collision.row + j] += collision.n;
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), undefined, removeColSpan(cell.attrs, cell.attrs.colspan - collision.n, collision.n));
    } else if (prob.type === TableProblemTypes.MISSING) {
      var missing = prob;
      mustAdd[missing.row] += missing.n;
    } else if (prob.type === TableProblemTypes.OVERLONG_ROWSPAN) {
      var overlong = prob;
      var _cell = table.nodeAt(overlong.pos);
      if (!_cell) {
        throw new Error("fixTable: unable to find cell at pos ".concat(prob.pos));
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + overlong.pos), undefined, _objectSpread(_objectSpread({}, _cell.attrs), {}, {
        rowspan: _cell.attrs.rowspan - overlong.n
      }));
    } else if (prob.type === TableProblemTypes.COLWIDTH_MISMATCH) {
      var _cell2 = table.nodeAt(prob.pos);
      if (!_cell2) {
        throw new Error("fixTable: unable to find cell at pos ".concat(prob.pos));
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), undefined, _objectSpread(_objectSpread({}, _cell2.attrs), {}, {
        colwidth: prob.colwidth
      }));
    }
  }
  var first;
  var last;
  for (var _i2 = 0; _i2 < mustAdd.length; _i2++) {
    if (mustAdd[_i2]) {
      if (first == null) {
        first = _i2;
      }
      last = _i2;
    }
  }
  // Add the necessary cells, using a heuristic for whether to add the
  // cells at the start or end of the rows (if it looks like a 'bite'
  // was taken out of the table, add cells at the start of the row
  // after the bite. Otherwise add them at the end).
  for (var _i3 = 0, pos = tablePos + 1; _i3 < map.height; _i3++) {
    var row = table.child(_i3);
    var end = pos + row.nodeSize;
    var add = mustAdd[_i3];
    if (add > 0) {
      var tableNodeType = 'cell';
      if (row.firstChild) {
        tableNodeType = row.firstChild.type.spec.tableRole;
      }
      var nodes = [];
      for (var _j = 0; _j < add; _j++) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
      }
      var side = (_i3 === 0 || first === _i3 - 1) && last === _i3 ? pos + 1 : end - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr.setMeta(fixTablesKey, {
    fixTables: true
  });
}