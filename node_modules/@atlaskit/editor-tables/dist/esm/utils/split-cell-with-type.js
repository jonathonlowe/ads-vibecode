import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { ResolvedPos } from '@atlaskit/editor-prosemirror/model';
import { CellSelection } from '../cell-selection';
import { cellAround } from './cells';
import { selectedRect } from './selection-rect';
export function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) {
    // Sometimes the cell can be in the same depth.
    var role = $pos.node(d).type.spec.tableRole;
    if (role === 'cell' || role === 'header_cell') {
      return $pos.node(d);
    }
  }
  return null;
}
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
export function splitCellWithType(getCellType) {
  return function (state, dispatch) {
    var sel = state.selection;
    var cellNode, cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) {
        return false;
      }
      var cellNodeAround = cellAround(sel.$from);
      cellPos = cellNodeAround && cellNodeAround.pos;
    } else {
      if (sel.$anchorCell.pos !== sel.$headCell.pos) {
        return false;
      }
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode && cellNode.attrs.colspan === 1 && cellNode.attrs.rowspan === 1) {
      return false;
    }
    if (cellNode && dispatch) {
      var cellAttrs = cellNode.attrs;
      var attrs = [];
      var colwidth = cellAttrs.colwidth;
      if (cellAttrs.rowspan && cellAttrs.rowspan > 1) {
        cellAttrs = _objectSpread(_objectSpread({}, cellAttrs), {}, {
          rowspan: 1
        });
      }
      if (cellAttrs.colspan && cellAttrs.colspan > 1) {
        cellAttrs = _objectSpread(_objectSpread({}, cellAttrs), {}, {
          colspan: 1
        });
      }
      var rect = selectedRect(state);
      var tr = state.tr;
      for (var i = 0; i < rect.right - rect.left; i++) {
        attrs.push(colwidth ? _objectSpread(_objectSpread({}, cellAttrs), {}, {
          colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
        }) : cellAttrs);
      }
      var lastCell = null;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row === rect.top) {
          pos += cellNode.nodeSize;
        }
        for (var col = rect.left, _i = 0; col < rect.right; col++, _i++) {
          if (col === rect.left && row === rect.top) {
            continue;
          }
          var cellType = getCellType({
            node: cellNode,
            row: row,
            col: col
          }).createAndFill(attrs[_i]);
          if (cellType) {
            tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), cellType);
          }
        }
      }
      if (typeof cellPos === 'number') {
        tr.setNodeMarkup(cellPos, getCellType({
          node: cellNode,
          row: rect.top,
          col: rect.left
        }), attrs[0]);
      }
      var $lastCellPosition = lastCell && tr.doc.resolve(lastCell);
      if (sel instanceof CellSelection && $lastCellPosition instanceof ResolvedPos) {
        var cellSelection = new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), $lastCellPosition);
        tr.setSelection(cellSelection);
      }
      dispatch(tr);
    }
    return true;
  };
}