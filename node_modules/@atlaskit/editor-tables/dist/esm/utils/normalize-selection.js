import { NodeSelection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { CellSelection } from '../cell-selection';
import { TableMap } from '../table-map';
export function normalizeSelection(state, transaction, allowTableNodeSelection) {
  var tr = transaction;
  var sel = (tr || state).selection;
  var _ref = tr || state,
    doc = _ref.doc;
  var normalize;
  var role;
  if (sel instanceof NodeSelection) {
    role = sel.node.type.spec.tableRole;
  }
  var isMultiSelect = editorExperiment('platform_editor_element_drag_and_drop_multiselect', true);
  if (sel instanceof NodeSelection && role) {
    if (role === 'cell' || role === 'header_cell') {
      normalize = CellSelection.create(doc, sel.from);
    } else if (role === 'row') {
      var $cell = doc.resolve(sel.from + 1);
      normalize = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map = TableMap.get(sel.node);
      var start = sel.from + 1;
      var lastCell = start + map.map[map.width * map.height - 1];
      normalize = CellSelection.create(doc, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize = TextSelection.create(doc, sel.from);
  } else if (sel instanceof TextSelection && (isMultiSelect ? isTextSelectionAcrossSameTableCells(sel) : isTextSelectionAcrossCells(sel))) {
    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());
  }
  if (normalize) {
    (tr || (tr = state.tr)).setSelection(normalize);
  }
  return tr;
}
function isCellBoundarySelection(_ref2) {
  var $from = _ref2.$from,
    $to = _ref2.$to;
  if ($from.pos === $to.pos || $from.pos < $from.pos - 6) {
    return false;
  } // Cheap elimination
  var afterFrom = $from.pos;
  var beforeTo = $to.pos;
  var depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++) {
    if ($from.after(depth + 1) < $from.end(depth)) {
      break;
    }
  }
  for (var d = $to.depth; d >= 0; d--, beforeTo--) {
    if ($to.before(d + 1) > $to.start(d)) {
      break;
    }
  }
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return afterFrom === beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells(_ref3) {
  var $from = _ref3.$from,
    $to = _ref3.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  for (var i = $from.depth; i > 0; i--) {
    var node = $from.node(i);
    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (var _i = $to.depth; _i > 0; _i--) {
    var _node = $to.node(_i);
    if (_node.type.spec.tableRole === 'cell' || _node.type.spec.tableRole === 'header_cell') {
      toCellBoundaryNode = _node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function isTextSelectionAcrossSameTableCells(_ref4) {
  var $from = _ref4.$from,
    $to = _ref4.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  var fromCellTableNode;
  var toCellTableNode;
  for (var i = $from.depth; i > 0; i--) {
    var node = $from.node(i);
    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {
      fromCellBoundaryNode = node;
    }
    if (node.type.name === 'table') {
      fromCellTableNode = node;
      break;
    }
  }
  for (var _i2 = $to.depth; _i2 > 0; _i2--) {
    var _node2 = $to.node(_i2);
    if (_node2.type.spec.tableRole === 'cell' || _node2.type.spec.tableRole === 'header_cell') {
      toCellBoundaryNode = _node2;
    }
    if (_node2.type.name === 'table') {
      toCellTableNode = _node2;
      break;
    }
  }
  return fromCellBoundaryNode !== undefined && toCellBoundaryNode !== undefined && fromCellBoundaryNode !== toCellBoundaryNode && toCellTableNode === fromCellTableNode && $to.parentOffset === 0;
}