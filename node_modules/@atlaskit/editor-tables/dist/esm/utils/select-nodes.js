import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { CellSelection } from '../cell-selection';
import { TableMap } from '../table-map';
import { cloneTr } from './clone-tr';
import { findCellClosestToPos, findTable, findTableClosestToPos } from './find';
var select = function select(type) {
  return function (index, expand) {
    return function (tr) {
      var table = findTable(tr.selection);
      var isRowSelection = type === 'row';
      var prevSelection = tr.selection;
      var isPrevRowSelection = !!prevSelection.$anchorCell && !!prevSelection.$headCell;
      if (table) {
        var map = TableMap.get(table.node);

        // Check if the index is valid
        if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {
          var left = isRowSelection ? 0 : index;
          var top = isRowSelection ? index : 0;
          var right = isRowSelection ? map.width : index + 1;
          var bottom = isRowSelection ? index + 1 : map.height;
          var cellsInFirstRow = [];
          if (expand) {
            var cell = findCellClosestToPos(tr.selection.$from);
            if (!cell) {
              return tr;
            }
            var selRect = map.findCell(cell.pos - table.start);
            if (isRowSelection) {
              top = Math.min(top, selRect.top);
              bottom = Math.max(bottom, selRect.bottom);
              cellsInFirstRow = map.cellsInRect({
                left: left,
                top: top,
                right: right,
                bottom: top + 1
              });
              var targetRowCells = map.cellsInRect({
                left: left,
                top: index,
                right: right,
                bottom: index + 1
              });
              var isBackwardSelection = targetRowCells[0] < prevSelection.$head.pos - table.start;
              if (isBackwardSelection && isPrevRowSelection) {
                var _head = table.start + cellsInFirstRow[0];
                var _anchor = prevSelection.$anchorCell.pos;
                var _$head = tr.doc.resolve(_head);
                var _$anchor = tr.doc.resolve(_anchor);
                return cloneTr(tr.setSelection(new CellSelection(_$anchor, _$head)));
              }
            } else {
              left = Math.min(left, selRect.left);
              right = Math.max(right, selRect.right);
              cellsInFirstRow = map.cellsInRect({
                left: left,
                top: top,
                right: left + 1,
                bottom: bottom
              });
              var _targetRowCells = map.cellsInRect({
                left: index,
                top: top,
                right: index + 1,
                bottom: bottom
              });
              var _isBackwardSelection = _targetRowCells[0] < prevSelection.$head.pos - table.start;
              if (_isBackwardSelection && isPrevRowSelection) {
                var _head2 = table.start + cellsInFirstRow[0];
                var _anchor2 = prevSelection.$anchorCell.pos;
                var _$head2 = tr.doc.resolve(_head2);
                var _$anchor2 = tr.doc.resolve(_anchor2);
                return cloneTr(tr.setSelection(new CellSelection(_$anchor2, _$head2)));
              }
            }
          }
          cellsInFirstRow = map.cellsInRect({
            left: left,
            top: top,
            right: isRowSelection ? right : left + 1,
            bottom: isRowSelection ? top + 1 : bottom
          });
          var cellsInLastRow = bottom - top === 1 ? cellsInFirstRow : map.cellsInRect({
            left: isRowSelection ? left : right - 1,
            top: isRowSelection ? bottom - 1 : top,
            right: right,
            bottom: bottom
          });
          var head = table.start + cellsInFirstRow[0];
          var anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];
          var $head = tr.doc.resolve(head);
          var $anchor = tr.doc.resolve(anchor);
          return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));
        }
      }
      return tr;
    };
  };
};

// Returns a new transaction that selects a column at index `columnIndex`.
// Use the optional `expand` param to extend from current selection.
export var selectColumn = select('column');

// Returns a new transaction that selects a row at index `rowIndex`.
// Use the optional `expand` param to extend from current selection.
export var selectRow = select('row');
var selectRowsOrColumns = function selectRowsOrColumns(type) {
  return function (indexes) {
    return function (tr) {
      var table = findTable(tr.selection);
      if (!table) {
        return tr;
      }
      var map = TableMap.get(table.node);
      if (!indexes || indexes.length <= 0 || type === 'rows' && Math.max.apply(Math, _toConsumableArray(indexes)) > map.height || type === 'columns' && Math.max.apply(Math, _toConsumableArray(indexes)) > map.width || Math.min.apply(Math, _toConsumableArray(indexes)) < 0) {
        return tr;
      }
      var startCellRect = map.cellsInRect({
        left: type === 'rows' ? 0 : Math.min.apply(Math, _toConsumableArray(indexes)),
        top: type === 'rows' ? Math.min.apply(Math, _toConsumableArray(indexes)) : 0,
        right: type === 'rows' ? map.width : Math.min.apply(Math, _toConsumableArray(indexes)) + 1,
        bottom: type === 'rows' ? Math.min.apply(Math, _toConsumableArray(indexes)) + 1 : 1
      });
      var endCellRect = map.cellsInRect({
        left: type === 'rows' ? map.width - 1 : Math.max.apply(Math, _toConsumableArray(indexes)),
        top: type === 'rows' ? Math.max.apply(Math, _toConsumableArray(indexes)) : map.height - 1,
        right: type === 'rows' ? map.width : Math.max.apply(Math, _toConsumableArray(indexes)) + 1,
        bottom: type === 'rows' ? Math.max.apply(Math, _toConsumableArray(indexes)) + 1 : map.height
      });
      var head = table.start + startCellRect[0];
      var anchor = table.start + endCellRect[endCellRect.length - 1];
      var $head = tr.doc.resolve(head);
      var $anchor = tr.doc.resolve(anchor);
      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));
    };
  };
};

// Returns a new transaction that selects all rows at `indexes`.
export var selectRows = selectRowsOrColumns('rows');

// Returns a new transaction that selects all columns at `indexes`.
export var selectColumns = selectRowsOrColumns('columns');

// Returns a new transaction that selects a table.
export var selectTable = function selectTable(tr) {
  var table = findTable(tr.selection);
  if (table) {
    var _TableMap$get = TableMap.get(table.node),
      map = _TableMap$get.map;
    if (map && map.length) {
      var head = table.start + map[0];
      var anchor = table.start + map[map.length - 1];
      var $head = tr.doc.resolve(head);
      var $anchor = tr.doc.resolve(anchor);
      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));
    }
  }
  return tr;
};
export var selectTableClosestToPos = function selectTableClosestToPos(tr, $pos) {
  var table = findTableClosestToPos($pos);
  if (table) {
    var _TableMap$get2 = TableMap.get(table.node),
      map = _TableMap$get2.map;
    if (map && map.length) {
      var head = table.start + map[0];
      var anchor = table.start + map[map.length - 1];
      var $head = tr.doc.resolve(head);
      var $anchor = tr.doc.resolve(anchor);
      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));
    }
  }
  return tr;
};