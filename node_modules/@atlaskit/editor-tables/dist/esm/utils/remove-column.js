import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { setTextSelection } from '@atlaskit/editor-prosemirror/utils';
import { TableMap } from '../table-map';
import { cloneTr } from './clone-tr';
import { removeColSpan } from './colspan';
import { findCellRectClosestToPos, findTable } from './find';
import { isTableSelected } from './is-selected';
import { isSelectionType } from './is-selection-type';
import { removeTable } from './remove-table';
function removeColumn(tr, _ref, columnIndex) {
  var map = _ref.map,
    table = _ref.table,
    tableStart = _ref.tableStart;
  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map.height;) {
    var index = row * map.width + columnIndex;
    var pos = map.map[index];
    var cell = table.nodeAt(pos);
    if (!cell) {
      continue;
    }

    // If this is part of a col-spanning cell
    if (columnIndex > 0 && map.map[index - 1] === pos || columnIndex < map.width - 1 && map.map[index + 1] === pos) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), undefined, removeColSpan(cell.attrs, columnIndex - map.colCount(pos)));
    } else {
      var start = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start, start + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
  return tr;
}

// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.
export var removeColumnAt = function removeColumnAt(columnIndex) {
  return function (tr) {
    var table = findTable(tr.selection);
    if (table) {
      var map = TableMap.get(table.node);
      if (columnIndex === 0 && map.width === 1) {
        return removeTable(tr);
      } else if (columnIndex >= 0 && columnIndex <= map.width) {
        removeColumn(tr, {
          map: map,
          tableStart: table.start,
          table: table.node
        }, columnIndex);
        return cloneTr(tr);
      }
    }
    return tr;
  };
};

// Returns a new transaction that removes selected columns.
export var removeSelectedColumns = function removeSelectedColumns(tr) {
  var selection = tr.selection;
  if (isTableSelected(selection)) {
    return removeTable(tr);
  }
  if (isSelectionType(selection, 'cell')) {
    var table = findTable(selection);
    if (table) {
      var map = TableMap.get(table.node);
      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
      if (rect.left === 0 && rect.right === map.width) {
        return tr;
      }
      var pmTableRect = _objectSpread(_objectSpread({}, rect), {}, {
        map: map,
        table: table.node,
        tableStart: table.start
      });
      for (var i = pmTableRect.right - 1;; i--) {
        removeColumn(tr, pmTableRect, i);
        if (i === pmTableRect.left) {
          break;
        }
        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
        pmTableRect.map = TableMap.get(pmTableRect.table);
      }
      return cloneTr(tr);
    }
  }
  return tr;
};

// Returns a new transaction that removes a column closest to a given `$pos`.
export var removeColumnClosestToPos = function removeColumnClosestToPos($pos) {
  return function (tr) {
    var rect = findCellRectClosestToPos($pos);
    if (rect) {
      return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));
    }
    return tr;
  };
};