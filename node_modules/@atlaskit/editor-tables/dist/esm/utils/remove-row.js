import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { setTextSelection } from '@atlaskit/editor-prosemirror/utils';
import { TableMap } from '../table-map';
import { cloneTr } from './clone-tr';
import { findCellRectClosestToPos, findTable } from './find';
import { isTableSelected } from './is-selected';
import { isSelectionType } from './is-selection-type';
import { removeTable } from './remove-table';
function removeRow(tr, _ref, rowIndex) {
  var map = _ref.map,
    table = _ref.table,
    tableStart = _ref.tableStart;
  var rowPos = 0;
  for (var i = 0; i < rowIndex; i++) {
    rowPos += table.child(i).nodeSize;
  }
  var nextRow = rowPos + table.child(rowIndex).nodeSize;
  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  for (var col = 0, index = rowIndex * map.width; col < map.width; col++, index++) {
    var pos = map.map[index];
    if (rowIndex > 0 && pos === map.map[index - map.width]) {
      // If this cell starts in the row above, simply reduce its rowspan
      var cell = table.nodeAt(pos);
      if (!cell) {
        continue;
      }
      var attrs = cell.attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), undefined, _objectSpread(_objectSpread({}, attrs), {}, {
        rowspan: attrs.rowspan - 1
      }));
      col += attrs.colspan - 1;
    } else if (rowIndex < map.width && pos === map.map[index + map.width]) {
      // Else, if it continues in the row below, it has to be moved down
      var _cell = table.nodeAt(pos);
      if (!_cell) {
        continue;
      }
      var copy = _cell.type.create(_objectSpread(_objectSpread({}, _cell.attrs), {}, {
        rowspan: _cell.attrs.rowspan - 1
      }), _cell.content);
      var newPos = map.positionAt(rowIndex + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += _cell.attrs.colspan - 1;
    }
  }
  return tr;
}

// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.
export var removeRowAt = function removeRowAt(rowIndex) {
  return function (tr) {
    var table = findTable(tr.selection);
    if (table) {
      var map = TableMap.get(table.node);
      if (rowIndex === 0 && map.height === 1) {
        return removeTable(tr);
      } else if (rowIndex >= 0 && rowIndex <= map.height) {
        removeRow(tr, {
          map: map,
          tableStart: table.start,
          table: table.node
        }, rowIndex);
        return cloneTr(tr);
      }
    }
    return tr;
  };
};

// Returns a new transaction that removes selected rows.
export var removeSelectedRows = function removeSelectedRows(tr) {
  var selection = tr.selection;
  if (isTableSelected(selection)) {
    return removeTable(tr);
  }
  if (isSelectionType(selection, 'cell')) {
    var table = findTable(selection);
    if (table) {
      var map = TableMap.get(table.node);
      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
      if (rect.top === 0 && rect.bottom === map.height) {
        return tr;
      }
      var pmTableRect = _objectSpread(_objectSpread({}, rect), {}, {
        map: map,
        table: table.node,
        tableStart: table.start
      });
      for (var i = pmTableRect.bottom - 1;; i--) {
        removeRow(tr, pmTableRect, i);
        if (i === pmTableRect.top) {
          break;
        }
        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
        pmTableRect.map = TableMap.get(pmTableRect.table);
      }
      return cloneTr(tr);
    }
  }
  return tr;
};

// Returns a new transaction that removes a row closest to a given `$pos`.
export var removeRowClosestToPos = function removeRowClosestToPos($pos) {
  return function (tr) {
    var rect = findCellRectClosestToPos($pos);
    if (rect) {
      return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));
    }
    return tr;
  };
};