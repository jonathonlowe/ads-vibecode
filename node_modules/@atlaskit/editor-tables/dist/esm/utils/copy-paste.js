import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// Utilities used for copy/paste handling.
//
// This module handles pasting cell content into tables, or pasting
// anything into a cell selection, as replacing a block of cells with
// the content of the selection. When pasting cells into a cell, that
// involves placing the block of pasted content so that its top left
// aligns with the selection cell, optionally extending the table to
// the right or bottom to make sure it is large enough. Pasting into a
// cell selection is different, here the cells in the selection are
// clipped to the selection's rectangle, optionally repeating the
// pasted cells when they are smaller than the selection.

import { Fragment, Slice } from '@atlaskit/editor-prosemirror/model';
import { Transform } from '@atlaskit/editor-prosemirror/transform';
import { CellSelection } from '../cell-selection';
import { TableMap } from '../table-map';
import { removeColSpan } from './colspan';
import { selectedRect } from './selection-rect';
import { tableNodeTypes } from './table-node-types';
import { isHeaderEnabledByType } from './toggle-header';

// Utilities to help with copying and pasting table cells

/**
 * Replace any header cells with table cells.
 *
 * @param schema
 * @param cells
 * @returns Fragment with header cells converted to table cells
 */
function stripHeaderType(schema, cells) {
  var newCells = [];
  cells.forEach(function (cell) {
    var _cellNodeType$createA;
    // Convert to cell type if not already
    var cellNodeType = tableNodeTypes(schema).cell;
    var tableCell = cell.type === cellNodeType ? cell : (_cellNodeType$createA = cellNodeType.createAndFill(cell.attrs, cell.content, cell.marks)) !== null && _cellNodeType$createA !== void 0 ? _cellNodeType$createA : cell;
    newCells.push(tableCell);
  });
  return Fragment.from(newCells);
}

// : (Slice) → ?{width: number, height: number, rows: [Fragment]}
// Get a rectangular area of cells from a slice, or null if the outer
// nodes of the slice aren't table cells or rows.
export function pastedCells(slice) {
  if (!slice.size) {
    return null;
  }
  var content = slice.content,
    openStart = slice.openStart,
    openEnd = slice.openEnd;
  if (!content.firstChild) {
    throw new Error('pastedCells: no firstChild defined for content');
  }
  while (content.childCount === 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole === 'table')) {
    openStart--;
    openEnd--;
    content = content.firstChild.content;
    if (!content.firstChild) {
      throw new Error('pastedCells: no firstChild defined for content');
    }
  }
  var first = content.firstChild;
  var role = first.type.spec.tableRole;
  var schema = first.type.schema;
  var rows = [];
  if (role === 'row') {
    for (var i = 0; i < content.childCount; i++) {
      var cells = content.child(i).content;
      var left = i ? 0 : Math.max(0, openStart - 1);
      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right) {
        cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;
      }
      rows.push(cells);
    }
  } else if (role === 'cell' || role === 'header_cell') {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);
  } else {
    return null;
  }
  var rowsWithoutHeaders = rows.map(function (row) {
    return stripHeaderType(schema, row);
  });
  return ensureRectangular(schema, rowsWithoutHeaders);
}

// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}
// Compute the width and height of a set of cells, and make sure each
// row has the same number of cells.
function ensureRectangular(schema, rowsFragment) {
  var rows = rowsFragment;
  var widths = [];
  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    for (var j = row.childCount - 1; j >= 0; j--) {
      var _row$child$attrs = row.child(j).attrs,
        rowspan = _row$child$attrs.rowspan,
        colspan = _row$child$attrs.colspan;
      for (var r = i; r < i + rowspan; r++) {
        widths[r] = (widths[r] || 0) + colspan;
      }
    }
  }
  var width = 0;
  for (var _r = 0; _r < widths.length; _r++) {
    width = Math.max(width, widths[_r]);
  }
  for (var _r2 = 0; _r2 < widths.length; _r2++) {
    if (_r2 >= rows.length) {
      rows.push(Fragment.empty);
    }
    if (widths[_r2] < width) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var empty = tableNodeTypes(schema).cell.createAndFill();
      var cells = [];
      for (var _i = widths[_r2]; _i < width; _i++) {
        cells.push(empty);
      }
      rows[_r2] = rows[_r2].append(Fragment.from(cells));
    }
  }
  return {
    height: rows.length,
    width: width,
    rows: rows
  };
}
export function fitSlice(nodeType, slice) {
  var node = nodeType.createAndFill();
  if (!node) {
    throw new Error("fitSlice: unable to create node");
  }
  var tr = new Transform(node).replace(0, node.content.size, slice);
  return tr.doc;
}

// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}
// Clip or extend (repeat) the given set of cells to cover the given
// width and height. Will clip rowspan/colspan cells at the edges when
// they stick out.
export function clipCells(_ref, newWidth, newHeight) {
  var currentWidth = _ref.width,
    currentHeight = _ref.height,
    currentRows = _ref.rows;
  var rows = currentRows;
  var width = currentWidth;
  var height = currentHeight;
  if (width !== newWidth) {
    var added = [];
    var newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var frag = rows[row];
      var cells = [];
      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {
        var cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth) {
          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        }
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j = 1; j < cell.attrs.rowspan; j++) {
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
        }
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height !== newHeight) {
    var _newRows = [];
    for (var _row = 0, _i2 = 0; _row < newHeight; _row++, _i2++) {
      var _cells = [];
      var source = rows[_i2 % height];
      for (var _j = 0; _j < source.childCount; _j++) {
        var _cell = source.child(_j);
        if (_row + _cell.attrs.rowspan > newHeight) {
          _cell = _cell.type.create(_objectSpread(_objectSpread({}, _cell.attrs), {}, {
            rowspan: Math.max(1, newHeight - _cell.attrs.rowspan)
          }), _cell.content);
        }
        _cells.push(_cell);
      }
      _newRows.push(Fragment.from(_cells));
    }
    rows = _newRows;
    height = newHeight;
  }
  return {
    width: width,
    height: height,
    rows: rows
  };
}

// Make sure a table has at least the given width and height. Return
// true if something was changed.
function growTable(tr, map, table, start, width, height, mapFrom) {
  var schema = tr.doc.type.schema;
  var types = tableNodeTypes(schema);
  var empty;
  var emptyHead;
  if (width > map.width) {
    for (var row = 0, rowEnd = 0; row < map.height; row++) {
      var rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [];
      var add = void 0;
      if (rowNode.lastChild == null || rowNode.lastChild.type === types.cell) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        add = empty || (empty = types.cell.createAndFill());
      } else {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        add = emptyHead || (emptyHead = types.header_cell.createAndFill());
      }
      for (var i = map.width; i < width; i++) {
        cells.push(add);
      }
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
    }
  }
  if (height > map.height) {
    var _cells2 = [];
    for (var _i3 = 0, k = (map.height - 1) * map.width; _i3 < Math.max(map.width, width); _i3++) {
      var header = void 0;
      if (_i3 >= map.width) {
        header = false;
      } else {
        var mappedPos = map.map[k + _i3];
        var node = table.nodeAt(mappedPos);
        if (!node) {
          throw new Error("growTable: no node found at pos ".concat(mappedPos));
        }
        header = node.type === types.header_cell;
      }
      _cells2.push(header ?
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      emptyHead || (emptyHead = types.header_cell.createAndFill()) :
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      empty || (empty = types.cell.createAndFill()));
    }
    var emptyRow = types.row.create(null, Fragment.from(_cells2));
    var rows = [];
    for (var _i4 = map.height; _i4 < height; _i4++) {
      rows.push(emptyRow);
    }
    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
  }
  return !!(empty || emptyHead);
}

// Make sure the given line (left, top) to (right, top) doesn't cross
// any rowspan cells by splitting cells that cross it. Return true if
// something changed.
function isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {
  if (top === 0 || top === map.height) {
    return false;
  }
  var found = false;
  for (var col = left; col < right; col++) {
    var index = top * map.width + col;
    var pos = map.map[index];
    if (map.map[index - map.width] === pos) {
      found = true;
      var cell = table.nodeAt(pos);
      if (!cell) {
        throw new Error("isolateHorizontal: no cell found at pos ".concat(pos));
      }
      var _map$findCell = map.findCell(pos),
        cellTop = _map$findCell.top,
        cellLeft = _map$findCell.left;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), undefined, _objectSpread(_objectSpread({}, cell.attrs), {}, {
        rowspan: top - cellTop
      }));
      var newCell = cell.type.createAndFill(_objectSpread(_objectSpread({}, cell.attrs), {}, {
        rowspan: cellTop + cell.attrs.rowspan - top
      }));
      if (!newCell) {
        throw new Error('isolateHorizontal: failed to create cell');
      }
      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), newCell);
      col += cell.attrs.colspan - 1;
    }
  }
  return found;
}

// Make sure the given line (left, top) to (left, bottom) doesn't
// cross any colspan cells by splitting cells that cross it. Return
// true if something changed.
function isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {
  if (left === 0 || left === map.width) {
    return false;
  }
  var found = false;
  for (var row = top; row < bottom; row++) {
    var index = row * map.width + left;
    var pos = map.map[index];
    if (map.map[index - 1] === pos) {
      found = true;
      var cell = table.nodeAt(pos);
      if (!cell) {
        throw new Error("isolateVertical: could not find cell at pos ".concat(pos));
      }
      var cellLeft = map.colCount(pos);
      var updatePos = tr.mapping.slice(mapFrom).map(pos + start);
      tr.setNodeMarkup(updatePos, undefined, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));
      var newCell = cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft));
      if (!newCell) {
        throw new Error('isolateVertical: failed to create cell');
      }
      tr.insert(updatePos + cell.nodeSize, newCell);
      row += cell.attrs.rowspan - 1;
    }
  }
  return found;
}
function applyHeaderCells(tr, tableMap, state, tableStart, table, headerRowEnabled, headerColumnEnabled) {
  var schema = state.schema;
  var setMarkup = function setMarkup(tr, row, col, headerEnabled) {
    var cellPos = tableStart + tableMap.positionAt(row, col, table);
    var cell = tr.doc.nodeAt(cellPos);
    var newType = headerEnabled ? schema.nodes.tableHeader : schema.nodes.tableCell;
    var isCellTypeChanged = newType !== (cell === null || cell === void 0 ? void 0 : cell.type);
    var isCellTypeValid = !!cell && [schema.nodes.tableCell, schema.nodes.tableHeader].includes(cell.type);
    if (isCellTypeChanged && isCellTypeValid) {
      tr.setNodeMarkup(cellPos, newType, cell === null || cell === void 0 ? void 0 : cell.attrs, cell === null || cell === void 0 ? void 0 : cell.marks);
    }
  };

  // For row === 0 && col === 0 it is enabled if either are enabled
  setMarkup(tr, 0, 0, headerColumnEnabled || headerRowEnabled);

  // Header Column
  for (var col = 1; col < tableMap.width; col++) {
    setMarkup(tr, 0, col, headerRowEnabled);
  }
  // Header Row
  for (var row = 1; row < tableMap.height; row++) {
    setMarkup(tr, row, 0, headerColumnEnabled);
  }
}

// Insert the given set of cells (as returned by `pastedCells`) into a
// table, at the position pointed at by rect.
export function insertCells(state, dispatch, tableStart, rect, cells) {
  var table = state.doc;
  var newRect = selectedRect(state);
  var types = tableNodeTypes(state.schema);

  // Get if the header row and column are enabled on the original table
  var headerRowEnabled = isHeaderEnabledByType('row', newRect, types);
  var headerColumnEnabled = isHeaderEnabledByType('column', newRect, types);
  if (tableStart) {
    table = state.doc.nodeAt(tableStart - 1);
    if (!table) {
      throw new Error("insertCells: could not find table at pos ".concat(tableStart - 1));
    }
  }
  var map = TableMap.get(table);
  var top = rect.top,
    left = rect.left;
  var right = left + cells.width;
  var bottom = top + cells.height;
  var tr = state.tr;
  var mapFrom = 0;
  function recomp() {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    map = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  // Prepare the table to be large enough and not have any cells
  // crossing the boundaries of the rectangle that we want to
  // insert into. If anything about it changes, recompute the table
  // map so that subsequent operations can see the current shape.
  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) {
    recomp();
  }
  for (var row = top; row < bottom; row++) {
    var from = map.positionAt(row, left, table);
    var to = map.positionAt(row, right, table);
    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top], 0, 0));
  }
  recomp();
  applyHeaderCells(tr, map, state, tableStart, table, headerRowEnabled, headerColumnEnabled);
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.map[top * map.width + left]), tr.doc.resolve(tableStart + map.map[(bottom - 1) * map.width + right - 1])));
  dispatch(tr);
}