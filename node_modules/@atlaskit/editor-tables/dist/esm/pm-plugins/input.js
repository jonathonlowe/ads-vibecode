// This file defines a number of helpers for wiring up user input to
// table-related functionality.

import { keydownHandler } from '@atlaskit/editor-prosemirror/keymap';
import { Slice } from '@atlaskit/editor-prosemirror/model';
import { Selection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { CellSelection } from '../cell-selection';
import { findTableClosestToPos, tableNodeTypes } from '../utils';
import { cellAround, nextCell } from '../utils/cells';
import { inSameTable } from '../utils/tables';
import { tableEditingKey } from './plugin-key';
export var handleKeyDown = keydownHandler({
  ArrowLeft: arrow('horiz', -1),
  ArrowRight: arrow('horiz', 1),
  ArrowUp: arrow('vert', -1),
  ArrowDown: arrow('vert', 1),
  'Shift-ArrowLeft': shiftArrow('horiz', -1),
  'Shift-ArrowRight': shiftArrow('horiz', 1),
  'Shift-ArrowUp': shiftArrow('vert', -1),
  'Shift-ArrowDown': shiftArrow('vert', 1),
  Backspace: deleteCellSelection,
  'Mod-Backspace': deleteCellSelection,
  Delete: deleteCellSelection,
  'Mod-Delete': deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) {
    return false;
  }
  if (dispatch) {
    dispatch(state.tr.setSelection(selection).scrollIntoView());
  }
  return true;
}
function arrow(axis, dir) {
  return function (state, dispatch, view) {
    if (dispatch) {
      var sel = state.selection;
      if (sel instanceof CellSelection) {
        return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));
      }
      if (axis !== 'horiz' && !sel.empty) {
        return false;
      }
      var end = view ? atEndOfCell(view, axis, dir) : null;
      if (end === null) {
        return false;
      }
      if (axis === 'horiz') {
        return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));
      }
      var $cell = state.doc.resolve(end);
      var $next = nextCell($cell, axis, dir);
      var newSel;
      if ($next) {
        newSel = Selection.near($next, 1);
      } else if (dir < 0) {
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      } else {
        newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      }
      return maybeSetSelection(state, dispatch, newSel);
    }
    return true;
  };
}
function shiftArrow(axis, dir) {
  return function (state, dispatch, view) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      var _maybeTableCell$paren;
      var end = view ? atEndOfCell(view, axis, dir) : null;
      if (end === null) {
        return false;
      }
      var _state$selection = state.selection,
        _$head = _state$selection.$head,
        $anchor = _state$selection.$anchor;
      var maybeTableCell = _$head.blockRange($anchor);

      // Make sure the selection is coming from the same cell
      var sameCell = ['tableCell', 'tableHeader'].includes((maybeTableCell === null || maybeTableCell === void 0 || (_maybeTableCell$paren = maybeTableCell.parent) === null || _maybeTableCell$paren === void 0 ? void 0 : _maybeTableCell$paren.type.name) || '');
      if (!sameCell) {
        return false;
      }
      sel = new CellSelection(state.doc.resolve(end));
    }
    var $head = nextCell(sel.$headCell, axis, dir);
    if (!$head) {
      return false;
    }
    if (dispatch) {
      return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head));
    }
    return true;
  };
}
function deleteCellSelection(state, dispatch) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection)) {
    return false;
  }
  if (dispatch) {
    var tr = state.tr;
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function (cell, pos) {
      if (!cell.content.eq(baseContent)) {
        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));
      }
    });
    if (tr.docChanged) {
      dispatch(tr);
    }
  }
  return true;
}
export function handleTripleClick(view, pos) {
  var doc = view.state.doc;
  var $cell = cellAround(doc.resolve(pos));
  if (!$cell) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
export function handleMouseDown(view, event, dragAndDropEnabled) {
  var startEvent = event;
  // Prevent right clicks from making a cell selection https://product-fabric.atlassian.net/browse/ED-12527
  if (startEvent.ctrlKey || startEvent.metaKey || startEvent.button === 2 // right mouse click
  ) {
    return false;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var startDOMCell = domInCell(view, startEvent.target);
  var $anchor = cellAround(view.state.selection.$anchor);
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    var targetElement = event.target instanceof HTMLElement || event.target instanceof SVGElement ? event.target : null;
    var isDragHandleElement = !!targetElement && !!targetElement.closest('button.pm-table-drag-handle-button-container, button.pm-table-drag-handle-button-clickable-zone');
    if (dragAndDropEnabled && isDragHandleElement) {
      return false;
    }
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && $anchor !== null &&
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  cellUnderMouse(view, startEvent).pos !== $anchor.pos) {
    // Adding to a selection that starts in another cell (causing a
    // cell selection to be created).
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    // Not in a cell, let the default behavior happen.
    return false;
  }

  // Create and dispatch a cell selection between the given anchor and
  // the position under the mouse.
  function setCellSelection($selectionAnchor, event) {
    var $head = cellUnderMouse(view, event);
    var starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($selectionAnchor, $head)) {
      if (starting) {
        $head = $selectionAnchor;
      } else {
        return false;
      }
    }
    var selection = new CellSelection($selectionAnchor, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var tr = view.state.tr.setSelection(selection);
      if (starting) {
        tr.setMeta(tableEditingKey, $selectionAnchor.pos);
      }
      view.dispatch(tr);
    }
  }

  // Stop listening to mouse motion events.
  function stop() {
    // Ignored via go/ees005
    // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
    view.root.removeEventListener('mouseup', stop);
    // Ignored via go/ees005
    // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
    view.root.removeEventListener('dragstart', stop);
    // Ignored via go/ees005
    // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
    view.root.removeEventListener('mousemove', move);
    if (tableEditingKey.getState(view.state) != null) {
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
    }
  }
  function move(event) {
    var anchor = tableEditingKey.getState(view.state);
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    var currDOMCell = domInCell(view, event.target);
    var isCurrCellInsideNestedTable = isInsideNestedTable(view, event);
    var isStartCellInsideNestedTable = isInsideNestedTable(view, startEvent);
    var isBothCellsInSameTable = isCurrCellInsideNestedTable === isStartCellInsideNestedTable;
    var $moveAnchor;
    var oldIfStatement = currDOMCell !== startDOMCell;
    var newIfStatement = currDOMCell !== startDOMCell && isBothCellsInSameTable;
    var checkCellsAreDifferent = fg('platform_editor_cell_selection_with_nested_tables') ? newIfStatement : oldIfStatement;
    if (anchor != null) {
      // Continuing an existing cross-cell selection
      $moveAnchor = view.state.doc.resolve(anchor);
      // Ignored via go/ees005
    } else if (checkCellsAreDifferent) {
      // Moving out of the initial cell -- start a new cell selection
      $moveAnchor = cellUnderMouse(view, startEvent);
      if (!$moveAnchor) {
        stop();
        return;
      }
    }
    if ($moveAnchor) {
      setCellSelection($moveAnchor, event);
    }
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
  view.root.addEventListener('mouseup', stop);
  // eslint-disable-next-line @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop, @repo/internal/dom-events/no-unsafe-event-listeners
  view.root.addEventListener('dragstart', stop);
  // Ignored via go/ees005
  // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
  view.root.addEventListener('mousemove', move);
  return false;
}

// Check whether the cursor is at the end of a cell (so that further
// motion would move out of the cell)
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return null;
  }
  var $head = view.state.selection.$head;
  for (var d = $head.depth - 1; d >= 0; d--) {
    var parent = $head.node(d);
    var index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index !== (dir < 0 ? 0 : parent.childCount)) {
      return null;
    }
    if (parent.type.spec.tableRole === 'cell' || parent.type.spec.tableRole === 'header_cell') {
      var cellPos = $head.before(d);
      var dirStr =
      // eslint-disable-next-line no-nested-ternary
      axis === 'vert' ? dir > 0 ? 'down' : 'up' : dir > 0 ? 'right' : 'left';
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, inputDom) {
  var dom = inputDom;
  for (; dom && dom !== view.dom; dom = dom.parentNode) {
    if (dom.nodeName === 'TD' || dom.nodeName === 'TH') {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) {
    return null;
  }
  return cellAround(view.state.doc.resolve(mousePos.pos));
}
function isInsideNestedTable(view, event) {
  var mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) {
    return false;
  }
  var pos = view.state.doc.resolve(mousePos.pos);
  var table = findTableClosestToPos(pos);
  if (!table) {
    return false;
  }
  var parent = view.state.doc.resolve(table.pos).parent;
  var nodeTypes = view.state.schema.nodes;
  return [nodeTypes.tableHeader, nodeTypes.tableCell].includes(parent.type);
}