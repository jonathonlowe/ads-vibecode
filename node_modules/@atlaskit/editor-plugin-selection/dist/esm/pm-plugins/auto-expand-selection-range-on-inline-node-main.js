import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
import { autoExpandSelectionRangeOnInlineNodePluginKey } from './auto-expand-selection-range-on-inline-node-key';
export var createAutoExpandSelectionRangeOnInlineNodePlugin = function createAutoExpandSelectionRangeOnInlineNodePlugin() {
  var mouseDownElement = null;
  return new SafePlugin({
    key: autoExpandSelectionRangeOnInlineNodePluginKey,
    props: {
      handleDOMEvents: {
        mousedown: function mousedown(_view, event) {
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          mouseDownElement = event.target;
        },
        mouseup: function mouseup(view, event) {
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          var mouseUpElement = event.target;
          if (fg('platform_editor_lcm_inline_node_selection_fix')) {
            // terminate early if mouse down and mouse up elements are the same -> e.g a click event
            // or mouse down doesn't trigger
            if (!mouseDownElement || mouseDownElement === mouseUpElement) {
              mouseDownElement = null;
              return;
            }
            // reset mouse down element after mouse up event
            // so that we can detect the next mouse down event is triggered right after mouse up event or not
            mouseDownElement = null;
          } else {
            // terminate early if mouse down and mouse up elements are the same -> e.g a click event
            if (mouseDownElement === mouseUpElement) {
              return;
            }
          }

          // terminate early if mouse up event is not fired on inline node
          if (!isMouseUpOnSupportedNode(mouseUpElement)) {
            return;
          }
          var dispatch = view.dispatch,
            state = view.state;
          var selection = state.selection;

          // terminate early if current selection is not a text selection -> e.g. table cell selection
          if (!(selection instanceof TextSelection)) {
            return;
          }

          // find the document position of the mouse up element
          var elementStartPosition = view.posAtDOM(mouseUpElement, 0);

          // find out the direction of selection
          var isAnchorBeforeElement = selection.$anchor.pos <= elementStartPosition;
          var expandedSelectionHeadPosition = isAnchorBeforeElement ? elementStartPosition + 1 : elementStartPosition;

          // expand the selection to include the mouse up element
          var tr = state.tr.setSelection(TextSelection.create(state.doc, selection.$anchor.pos, expandedSelectionHeadPosition));
          dispatch(tr);
        }
      }
    }
  });
};
var isMouseUpOnSupportedNode = function isMouseUpOnSupportedNode(mouseUpElement) {
  var supportedNodes = ['emoji', 'status', 'date', 'mention', 'inlineCard'];
  var supportedNodeViewContentClassNamesList = supportedNodes.map(function (nodeType) {
    return ".".concat(nodeType, "View-content-wrap");
  }).join(', ');
  return !!mouseUpElement.closest(supportedNodeViewContentClassNamesList);
};