"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAutoExpandSelectionRangeOnInlineNodePlugin = void 0;
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _state = require("@atlaskit/editor-prosemirror/state");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _autoExpandSelectionRangeOnInlineNodeKey = require("./auto-expand-selection-range-on-inline-node-key");
var createAutoExpandSelectionRangeOnInlineNodePlugin = exports.createAutoExpandSelectionRangeOnInlineNodePlugin = function createAutoExpandSelectionRangeOnInlineNodePlugin() {
  var mouseDownElement = null;
  return new _safePlugin.SafePlugin({
    key: _autoExpandSelectionRangeOnInlineNodeKey.autoExpandSelectionRangeOnInlineNodePluginKey,
    props: {
      handleDOMEvents: {
        mousedown: function mousedown(_view, event) {
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          mouseDownElement = event.target;
        },
        mouseup: function mouseup(view, event) {
          // Ignored via go/ees005
          // eslint-disable-next-line @atlaskit/editor/no-as-casting
          var mouseUpElement = event.target;
          if ((0, _platformFeatureFlags.fg)('platform_editor_lcm_inline_node_selection_fix')) {
            // terminate early if mouse down and mouse up elements are the same -> e.g a click event
            // or mouse down doesn't trigger
            if (!mouseDownElement || mouseDownElement === mouseUpElement) {
              mouseDownElement = null;
              return;
            }
            // reset mouse down element after mouse up event
            // so that we can detect the next mouse down event is triggered right after mouse up event or not
            mouseDownElement = null;
          } else {
            // terminate early if mouse down and mouse up elements are the same -> e.g a click event
            if (mouseDownElement === mouseUpElement) {
              return;
            }
          }

          // terminate early if mouse up event is not fired on inline node
          if (!isMouseUpOnSupportedNode(mouseUpElement)) {
            return;
          }
          var dispatch = view.dispatch,
            state = view.state;
          var selection = state.selection;

          // terminate early if current selection is not a text selection -> e.g. table cell selection
          if (!(selection instanceof _state.TextSelection)) {
            return;
          }

          // find the document position of the mouse up element
          var elementStartPosition = view.posAtDOM(mouseUpElement, 0);

          // find out the direction of selection
          var isAnchorBeforeElement = selection.$anchor.pos <= elementStartPosition;
          var expandedSelectionHeadPosition = isAnchorBeforeElement ? elementStartPosition + 1 : elementStartPosition;

          // expand the selection to include the mouse up element
          var tr = state.tr.setSelection(_state.TextSelection.create(state.doc, selection.$anchor.pos, expandedSelectionHeadPosition));
          dispatch(tr);
        }
      }
    }
  });
};
var isMouseUpOnSupportedNode = function isMouseUpOnSupportedNode(mouseUpElement) {
  var supportedNodes = ['emoji', 'status', 'date', 'mention', 'inlineCard'];
  var supportedNodeViewContentClassNamesList = supportedNodes.map(function (nodeType) {
    return ".".concat(nodeType, "View-content-wrap");
  }).join(', ');
  return !!mouseUpElement.closest(supportedNodeViewContentClassNamesList);
};