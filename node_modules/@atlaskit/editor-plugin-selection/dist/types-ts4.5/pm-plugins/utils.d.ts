import type { Node as PmNode, ResolvedPos } from '@atlaskit/editor-prosemirror/model';
import type { EditorState, ReadonlyTransaction, Transaction } from '@atlaskit/editor-prosemirror/state';
import { Selection } from '@atlaskit/editor-prosemirror/state';
import type { ContentNodeWithPos, NodeWithPos } from '@atlaskit/editor-prosemirror/utils';
import { DecorationSet } from '@atlaskit/editor-prosemirror/view';
export declare const getDecorations: (tr: Transaction | ReadonlyTransaction, manualSelection?: {
    anchor: number;
    head: number;
}) => DecorationSet;
/**
 * Use `getNodesToDecorateFromSelection` to collect and return
 * a list of nodes within the Selection that should have Selection
 * decorations applied. This allows selection styles to be added to
 * nested nodes. It will ignore text nodes as decorations are
 * applied natively and also ignore nodes that don't completely
 * sit within the given `Selection`.
 */
export declare const getNodesToDecorateFromSelection: (selection: Selection, doc: PmNode) => {
    node: PmNode;
    pos: number;
}[];
export declare function shouldRecalcDecorations({ oldEditorState, newEditorState, }: {
    oldEditorState: EditorState;
    newEditorState: EditorState;
}): boolean;
export declare const isSelectableContainerNode: (node?: PmNode | null) => boolean;
export declare const isSelectableChildNode: (node?: PmNode | null) => boolean;
/**
 * Finds closest parent node that is a selectable block container node
 * If it finds a parent that is not selectable but supports gap cursor, will
 * return undefined
 */
export declare const findSelectableContainerParent: (selection: Selection) => ContentNodeWithPos | undefined;
/**
 * Finds node before that is a selectable block container node, starting
 * from $pos.depth + 1 and working in
 * If it finds a node that is not selectable but supports gap cursor, will
 * return undefined
 */
export declare const findSelectableContainerBefore: ($pos: ResolvedPos, doc: PmNode) => NodeWithPos | undefined;
/**
 * Finds node after that is a selectable block container node, starting
 * from $pos.depth + 1 and working in
 * If it finds a node that is not selectable but supports gap cursor, will
 * return undefined
 */
export declare const findSelectableContainerAfter: ($pos: ResolvedPos, doc: PmNode) => NodeWithPos | undefined;
/**
 * Finds first child node that is a selectable block container node OR that
 * supports gap cursor
 */
export declare const findFirstChildNodeToSelect: (parent: PmNode) => NodeWithPos | undefined;
/**
 * Finds last child node that is a selectable block container node OR that
 * supports gap cursor
 */
export declare const findLastChildNodeToSelect: (parent: PmNode) => NodeWithPos | undefined;
export declare const isSelectionAtStartOfParentNode: ($pos: ResolvedPos, selection: Selection) => boolean;
export declare const isSelectionAtEndOfParentNode: ($pos: ResolvedPos, selection: Selection) => boolean;
