"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.keymapPlugin = keymapPlugin;
var _utils = require("@atlaskit/editor-common/utils");
var _keymap = require("@atlaskit/editor-prosemirror/keymap");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _utils3 = require("./utils");
var deleteCurrentItem = function deleteCurrentItem($from) {
  return function (tr) {
    return tr.delete($from.before($from.depth), $from.after($from.depth));
  };
};
var setTextSelection = function setTextSelection(pos) {
  return function (tr) {
    var newSelection = _state.Selection.findFrom(tr.doc.resolve(pos), -1, true);
    if (newSelection) {
      tr.setSelection(newSelection);
    }
    return tr;
  };
};
function keymapPlugin(schema) {
  return (0, _keymap.keymap)({
    Backspace: function Backspace(state, dispatch) {
      var $cursor = (0, _utils3.getCursor)(state.selection);
      var _state$schema$nodes = state.schema.nodes,
        codeBlock = _state$schema$nodes.codeBlock,
        listItem = _state$schema$nodes.listItem,
        table = _state$schema$nodes.table,
        layoutColumn = _state$schema$nodes.layoutColumn,
        paragraph = _state$schema$nodes.paragraph;
      if (!$cursor || $cursor.parent.type !== codeBlock || !dispatch) {
        return false;
      }
      if ($cursor.pos === 1 || (0, _utils2.hasParentNodeOfType)(listItem)(state.selection) && $cursor.parentOffset === 0) {
        var node = (0, _utils2.findParentNodeOfTypeClosestToPos)($cursor, codeBlock);
        if (!node) {
          return false;
        }
        dispatch(state.tr.setNodeMarkup(node.pos, node.node.type, node.node.attrs, []).setBlockType($cursor.pos, $cursor.pos, paragraph));
        return true;
      }
      if ($cursor.node && (0, _utils.isEmptyNode)(schema)($cursor.node()) && ((0, _utils2.hasParentNodeOfType)(layoutColumn)(state.selection) || (0, _utils2.hasParentNodeOfType)(table)(state.selection))) {
        var tr = state.tr;
        var insertPos = $cursor.pos;
        deleteCurrentItem($cursor)(tr);
        setTextSelection(insertPos)(tr);
        dispatch(tr.scrollIntoView());
        return true;
      }

      // Handle not nested empty code block
      if ((0, _utils.isEmptyNode)(schema)($cursor.node())) {
        dispatch(deleteCurrentItem($cursor)(state === null || state === void 0 ? void 0 : state.tr));
        return true;
      }
      return false;
    }
  });
}
var _default = exports.default = keymapPlugin;