import { isCodeBlockWordWrapEnabled } from '@atlaskit/editor-common/code-block';
import commonMessages, { codeBlockButtonMessages } from '@atlaskit/editor-common/messages';
import { findDomRefAtPos } from '@atlaskit/editor-prosemirror/utils';
import DeleteIcon from '@atlaskit/icon/core/delete';
import CopyIcon from '@atlaskit/icon/core/migration/copy';
import RemoveIcon from '@atlaskit/icon/core/migration/delete--editor-remove';
import TextWrapIcon from '@atlaskit/icon/core/text-wrap';
import { fg } from '@atlaskit/platform-feature-flags';
import { changeLanguage, copyContentToClipboard, removeCodeBlock, resetCopiedState, toggleWordWrapStateForCodeBlockNode } from '../editor-commands';
import { WrapIcon } from '../ui/icons/WrapIcon';
import { provideVisualFeedbackForCopyButton, removeVisualFeedbackForCopyButton } from './codeBlockCopySelectionPlugin';
import { createLanguageList, DEFAULT_LANGUAGES, getLanguageIdentifier } from './language-list';
import { pluginKey } from './plugin-key';
export const getToolbarConfig = (allowCopyToClipboard = false, api, overrideLanguageName = undefined) => (state, {
  formatMessage
}) => {
  var _api$decorations$acti, _api$decorations, _api$analytics, _codeBlockState$pos, _node$attrs;
  const {
    hoverDecoration
  } = (_api$decorations$acti = api === null || api === void 0 ? void 0 : (_api$decorations = api.decorations) === null || _api$decorations === void 0 ? void 0 : _api$decorations.actions) !== null && _api$decorations$acti !== void 0 ? _api$decorations$acti : {};
  const editorAnalyticsAPI = api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions;
  const codeBlockState = pluginKey.getState(state);
  const pos = (_codeBlockState$pos = codeBlockState === null || codeBlockState === void 0 ? void 0 : codeBlockState.pos) !== null && _codeBlockState$pos !== void 0 ? _codeBlockState$pos : null;
  if (!codeBlockState || pos === null) {
    return;
  }
  const node = state.doc.nodeAt(pos);
  const nodeType = state.schema.nodes.codeBlock;
  if ((node === null || node === void 0 ? void 0 : node.type) !== nodeType) {
    return;
  }
  const isWrapped = isCodeBlockWordWrapEnabled(node);
  const language = node === null || node === void 0 ? void 0 : (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.language;
  const languageList = createLanguageList(overrideLanguageName ? DEFAULT_LANGUAGES.map(language => ({
    ...language,
    name: overrideLanguageName(language.name)
  })) : DEFAULT_LANGUAGES);
  const options = languageList.map(lang => ({
    label: lang.name,
    value: getLanguageIdentifier(lang),
    alias: lang.alias
  }));

  // If language is not undefined search for it in the value and then search in the aliases
  const defaultValue = language ? options.find(option => option.value === language) || options.find(option => option.alias.includes(language)) : null;
  const languageSelect = {
    id: 'editor.codeBlock.languageOptions',
    type: 'select',
    selectType: 'list',
    onChange: option => changeLanguage(editorAnalyticsAPI)(option.value),
    defaultValue,
    placeholder: formatMessage(codeBlockButtonMessages.selectLanguage),
    options,
    filterOption: languageListFilter
  };
  const separator = {
    type: 'separator'
  };
  const copyToClipboardItems = !allowCopyToClipboard ? [] : [{
    id: 'editor.codeBlock.copy',
    type: 'button',
    supportsViewMode: true,
    appearance: 'subtle',
    icon: CopyIcon,
    // note: copyContentToClipboard contains logic that also removes the
    // visual feedback for the copy button
    onClick: copyContentToClipboard,
    title: formatMessage(codeBlockState.contentCopied ? codeBlockButtonMessages.copiedCodeToClipboard : codeBlockButtonMessages.copyCodeToClipboard),
    onMouseEnter: provideVisualFeedbackForCopyButton,
    // note: resetCopiedState contains logic that also removes the
    // visual feedback for the copy button
    onMouseLeave: resetCopiedState,
    onFocus: provideVisualFeedbackForCopyButton,
    onBlur: removeVisualFeedbackForCopyButton,
    hideTooltipOnClick: false,
    disabled: codeBlockState.isNodeSelected,
    tabIndex: null
  }, separator];
  const deleteButton = {
    id: 'editor.codeBlock.delete',
    type: 'button',
    appearance: 'danger',
    icon: DeleteIcon,
    iconFallback: RemoveIcon,
    onMouseEnter: hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(nodeType, true),
    onMouseLeave: hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(nodeType, false),
    onFocus: hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(nodeType, true),
    onBlur: hoverDecoration === null || hoverDecoration === void 0 ? void 0 : hoverDecoration(nodeType, false),
    onClick: removeCodeBlock,
    title: formatMessage(commonMessages.remove),
    tabIndex: null
  };
  const codeBlockWrapButton = {
    id: 'editor.codeBlock.wrap',
    type: 'button',
    supportsViewMode: true,
    icon: TextWrapIcon,
    iconFallback: WrapIcon,
    onClick: toggleWordWrapStateForCodeBlockNode(editorAnalyticsAPI),
    title: fg('editor_a11y_remove_unwrap_button') ? formatMessage(codeBlockButtonMessages.wrapCode) : isWrapped ? formatMessage(codeBlockButtonMessages.unwrapCode) : formatMessage(codeBlockButtonMessages.wrapCode),
    tabIndex: null,
    selected: isWrapped
  };
  return {
    title: 'CodeBlock floating controls',
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    getDomRef: view => findDomRefAtPos(pos, view.domAtPos.bind(view)),
    nodeType,
    items: [languageSelect, separator, codeBlockWrapButton, separator, ...copyToClipboardItems, deleteButton],
    scrollable: true
  };
};

/**
 * Filters language list based on both name and alias properties.
 */
export const languageListFilter = (option, rawInput) => {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const {
    data
  } = option;
  const searchString = rawInput.toLowerCase();
  return data.label.toLowerCase().includes(searchString) || data.alias.some(alias => alias.toLowerCase() === searchString);
};