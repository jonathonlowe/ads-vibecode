"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPlugin = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _commands = require("./commands");
var _pluginFactory = require("./plugin-factory");
var _pluginKey = require("./plugin-key");
var _types = require("./types");
var _utils = require("./utils");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// This plugin exists only in FullPage/FullWidth Editor and is used to register an event that tells us
// that a user cut and than pasted a node. This order of actions could be considered an alternative
// to new Drag and Drop functionality. The event (document moved) is not accurate, but should be enough to be
// used during DnD roll out. After DnD release this plugin must be removed.
var createPlugin = exports.createPlugin = function createPlugin(dispatch, editorAnalyticsAPI) {
  // This variable is used to distinguish between copy and cut events in transformCopied.
  var isCutEvent = false;
  return new _safePlugin.SafePlugin({
    key: _pluginKey.pluginKey,
    state: (0, _pluginFactory.createPluginState)(dispatch, _types.defaultState),
    props: {
      handleDOMEvents: {
        cut: function cut() {
          isCutEvent = true;
        }
      },
      handlePaste: function handlePaste(_ref, event, slice) {
        var _content$firstChild;
        var state = _ref.state,
          dispatch = _ref.dispatch;
        // The state was cleaned after previous paste. We don't need to update plugin state
        // with 'contentPasted' if currentActions array doesn't have 'copiedOrCut'.
        var _getPluginState = (0, _pluginFactory.getPluginState)(state),
          contentMoved = _getPluginState.contentMoved;
        var hasCutAction = contentMoved.currentActions.includes('contentCut');
        if (!hasCutAction) {
          return;
        }
        var content = slice.content;
        var nodeName = (_content$firstChild = content.firstChild) === null || _content$firstChild === void 0 ? void 0 : _content$firstChild.type.name;
        if (!nodeName || !(contentMoved !== null && contentMoved !== void 0 && contentMoved.nodeName) || !(0, _utils.isCursorSelectionAtTopLevel)(state.selection)) {
          return;
        }
        var tr = state.tr;
        editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent({
          action: _analytics.ACTION.MOVED,
          actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
          actionSubjectId: _analytics.ACTION_SUBJECT_ID.NODE,
          eventType: _analytics.EVENT_TYPE.TRACK,
          attributes: {
            // keep nodeName from copied slice
            nodeType: contentMoved === null || contentMoved === void 0 ? void 0 : contentMoved.nodeName,
            nodeDepth: contentMoved === null || contentMoved === void 0 ? void 0 : contentMoved.nodeDepth,
            destinationNodeDepth: (0, _utils.getParentNodeDepth)(state.selection),
            nodeTypes: contentMoved === null || contentMoved === void 0 ? void 0 : contentMoved.nodeTypes,
            hasSelectedMultipleNodes: contentMoved === null || contentMoved === void 0 ? void 0 : contentMoved.hasSelectedMultipleNodes
          }
        })(tr);

        // reset to default state
        var updatedTr = (0, _commands.resetContentMovedTransform)()(tr);
        dispatch(updatedTr);
      },
      transformCopied: function transformCopied(slice, _ref2) {
        var _content$firstChild2;
        var state = _ref2.state,
          dispatch = _ref2.dispatch;
        // We want to listen only to 'cut' events
        if (!isCutEvent) {
          return slice;
        }
        var resetState = false;
        var content = slice.content,
          size = slice.size;
        var selection = state.selection;
        // Note: the following is not the case once `platform_editor_element_drag_and_drop_multiselect` is enabled
        // we now want to track cut events for multiple nodes
        // Content should be just one node, so we added a check for slice.content.childCount === 1;
        // 1. It is possible to select a table by dragging the mouse over the table's rows.
        // As a result, slice will contain rows without tableNode itself and the childCount will be the number of rows.
        // From a user's perspective the whole table is selected and copied and on paste a table will indeed be created.
        // 2. Some block nodes can get selected when a user drags the mouse from the paragraph above the node to
        // the paragraph below the node. Visually only the node in between is selected, in reality, three nodes are
        // in the slice.
        // These cases are ignored and moveContent event won't be counted.
        var isMultiSelectTrackingEnabled = (0, _platformFeatureFlags.fg)('platform_editor_track_node_types');
        var nodeName = ((_content$firstChild2 = content.firstChild) === null || _content$firstChild2 === void 0 ? void 0 : _content$firstChild2.type.name) || '';
        var nodeTypes,
          hasSelectedMultipleNodes = false;
        if (content.childCount > 1) {
          if (isMultiSelectTrackingEnabled) {
            if ((0, _utils.containsExcludedNode)(content)) {
              resetState = true;
            } else {
              var attributes = (0, _utils.getMultipleSelectionAttributes)(content);
              nodeTypes = attributes.nodeTypes;
              hasSelectedMultipleNodes = attributes.hasSelectedMultipleNodes;
            }
          } else {
            resetState = true;
          }
        } else if (content.childCount === 1) {
          // Some nodes are not relevant as they are parts of nodes, not whole nodes (like tableCell, tableHeader instead of table node)
          // Some nodes like lists, taskList(item), decisionList(item) requires tricky checks that we want to avoid doing.
          // These nodes were added to excludedNodes array.
          if (!resetState && (0, _utils.isExcludedNode)(nodeName)) {
            resetState = true;
          }
          if (!resetState && !(0, _utils.isEntireNestedParagraphOrHeadingSelected)(selection)) {
            resetState = true;
          }
          if (!resetState && (0, _utils.isInlineNode)(nodeName) && (0, _utils.isNestedInlineNode)(selection)) {
            resetState = true;
          }
          if (!resetState && (0, _utils.isNestedInTable)(state)) {
            resetState = true;
          }
        } else {
          resetState = true;
        }
        if (resetState) {
          (0, _commands.resetContentMoved)()(state, dispatch);
        } else {
          var newState = {
            size: size,
            nodeName: nodeName,
            nodeDepth: (0, _utils.getParentNodeDepth)(selection)
          };
          if (isMultiSelectTrackingEnabled) {
            newState = _objectSpread(_objectSpread({}, newState), {}, {
              nodeTypes: nodeTypes !== null && nodeTypes !== void 0 ? nodeTypes : nodeName,
              hasSelectedMultipleNodes: hasSelectedMultipleNodes
            });
          }
          (0, _commands.updateContentMoved)(newState, 'contentCut')(state, dispatch);
        }
        isCutEvent = false;
        return slice;
      }
    }
  });
};