// TODO: ED-26962 - Ideally this should use the custom toggleMark function from @atlaskit/editor-common so we also disable the options when selecting inline nodes but it disables the marks when the selection is empty at this point in time which is undesirable
// import { toggleMark } from '@atlaskit/editor-common/mark';

import { moveLeft as keymapMoveLeft, moveRight as keymapMoveRight } from '@atlaskit/editor-common/keymaps';
import { anyMarkActive } from '@atlaskit/editor-common/mark';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { shallowEqual } from '@atlaskit/editor-common/utils';
import { toggleMark } from '@atlaskit/editor-prosemirror/commands';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { createInlineCodeFromTextInputWithAnalytics } from '../editor-commands/text-formatting';
// Ignored via go/ees005
// eslint-disable-next-line import/no-namespace
import * as commands from '../editor-commands/text-formatting';
import { pluginKey } from './plugin-key';
var isSelectionInlineCursor = function isSelectionInlineCursor(selection) {
  if (selection instanceof NodeSelection) {
    return true;
  }
  return false;
};
var checkNodeSelection = function checkNodeSelection(mark, editorState, type) {
  var selection = editorState.selection;
  if (isSelectionInlineCursor(selection)) {
    return false;
  }
  if (type !== null || type !== undefined) {
    return toggleMark(mark, {
      type: type
    })(editorState);
  }
  return toggleMark(mark)(editorState);
};
var getTextFormattingState = function getTextFormattingState(editorState, editorAnalyticsAPI) {
  var _editorState$schema$m = editorState.schema.marks,
    em = _editorState$schema$m.em,
    code = _editorState$schema$m.code,
    strike = _editorState$schema$m.strike,
    strong = _editorState$schema$m.strong,
    subsup = _editorState$schema$m.subsup,
    underline = _editorState$schema$m.underline;
  var state = {};
  if (code) {
    state.codeActive = anyMarkActive(editorState, code.create());
    state.codeDisabled = !checkNodeSelection(code, editorState);
  }
  if (em) {
    state.emActive = anyMarkActive(editorState, em);
    state.emDisabled = state.codeActive ? true : !checkNodeSelection(em, editorState);
  }
  if (strike) {
    state.strikeActive = anyMarkActive(editorState, strike);
    state.strikeDisabled = state.codeActive ? true : !checkNodeSelection(strike, editorState);
  }
  if (strong) {
    state.strongActive = anyMarkActive(editorState, strong);
    state.strongDisabled = state.codeActive ? true : !checkNodeSelection(strong, editorState);
  }
  if (subsup) {
    var subMark = subsup.create({
      type: 'sub'
    });
    var supMark = subsup.create({
      type: 'sup'
    });
    state.subscriptActive = anyMarkActive(editorState, subMark);
    state.subscriptDisabled = state.codeActive ? true : !checkNodeSelection(subsup, editorState, 'sub');
    state.superscriptActive = anyMarkActive(editorState, supMark);
    state.superscriptDisabled = state.codeActive ? true : !checkNodeSelection(subsup, editorState, 'sup');
  }
  if (underline) {
    state.underlineActive = anyMarkActive(editorState, underline);
    state.underlineDisabled = state.codeActive ? true : !checkNodeSelection(underline, editorState);
  }
  return state;
};
export var plugin = function plugin(dispatch, editorAnalyticsAPI) {
  return new SafePlugin({
    state: {
      init: function init(_config, state) {
        return getTextFormattingState(state, editorAnalyticsAPI);
      },
      apply: function apply(_tr, pluginState, _oldState, newState) {
        var state = getTextFormattingState(newState, editorAnalyticsAPI);
        if (!shallowEqual(pluginState, state)) {
          dispatch(pluginKey, state);
          return state;
        }
        return pluginState;
      }
    },
    key: pluginKey,
    props: {
      handleKeyDown: function handleKeyDown(view, event) {
        var state = view.state,
          dispatch = view.dispatch;
        if (event.key === keymapMoveRight.common && !event.metaKey) {
          return commands.moveRight()(state, dispatch);
        } else if (event.key === keymapMoveLeft.common && !event.metaKey) {
          return commands.moveLeft()(state, dispatch);
        }
        return false;
      },
      handleTextInput: function handleTextInput(view, from, to, text) {
        var state = view.state,
          dispatch = view.dispatch;
        var schema = state.schema,
          parentNodeType = state.selection.$from.parent.type;
        if (parentNodeType.allowsMarkType(schema.marks.code)) {
          return createInlineCodeFromTextInputWithAnalytics(editorAnalyticsAPI)(from, to, text)(state, dispatch);
        }
        return false;
      }
    }
  });
};