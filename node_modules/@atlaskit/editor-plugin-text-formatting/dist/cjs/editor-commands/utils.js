"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.markActive = exports.isArrayContainsContent = exports.hasCode = exports.compareItemsArrays = exports.checkFormattingIsPresent = void 0;
var _mark = require("@atlaskit/editor-common/mark");
var _clearFormatting = require("./clear-formatting");
var hasCode = exports.hasCode = function hasCode(state, pos) {
  var code = state.schema.marks.code;
  var node = pos >= 0 && state.doc.nodeAt(pos);
  if (node) {
    return !!node.marks.filter(function (mark) {
      return mark.type === code;
    }).length;
  }
  return false;
};

/**
 * Determine if a mark (with specific attribute values) exists anywhere in the selection.
 */
var markActive = exports.markActive = function markActive(state, mark) {
  var _state$selection = state.selection,
    from = _state$selection.from,
    to = _state$selection.to,
    empty = _state$selection.empty;
  // When the selection is empty, only the active marks apply.
  if (empty) {
    return !!mark.isInSet(state.tr.storedMarks || state.selection.$from.marks());
  }
  // For a non-collapsed selection, the marks on the nodes matter.
  var found = false;
  state.doc.nodesBetween(from, to, function (node) {
    found = found || mark.isInSet(node.marks);
  });
  return found;
};
var blockStylingIsPresent = function blockStylingIsPresent(state) {
  var _state$selection2 = state.selection,
    from = _state$selection2.from,
    to = _state$selection2.to;
  var isBlockStyling = false;
  state.doc.nodesBetween(from, to, function (node) {
    if (_clearFormatting.FORMATTING_NODE_TYPES.indexOf(node.type.name) !== -1) {
      isBlockStyling = true;
      return false;
    }
    return true;
  });
  return isBlockStyling;
};
var marksArePresent = function marksArePresent(state) {
  var activeMarkTypes = _clearFormatting.FORMATTING_MARK_TYPES.filter(function (mark) {
    if (!!state.schema.marks[mark]) {
      var _state$selection3 = state.selection,
        $from = _state$selection3.$from,
        empty = _state$selection3.empty;
      var marks = state.schema.marks;
      if (empty) {
        return !!marks[mark].isInSet(state.storedMarks || $from.marks());
      }
      return (0, _mark.anyMarkActive)(state, marks[mark]);
    }
    return false;
  });
  return activeMarkTypes.length > 0;
};
var checkFormattingIsPresent = exports.checkFormattingIsPresent = function checkFormattingIsPresent(state) {
  return marksArePresent(state) || blockStylingIsPresent(state);
};
var compareItemsArrays = exports.compareItemsArrays = function compareItemsArrays(items, prevItems) {
  return items && items.filter(function (item) {
    return !prevItems.includes(item);
  });
};
var isArrayContainsContent = exports.isArrayContainsContent = function isArrayContainsContent(items, content) {
  return items.filter(function (item) {
    return item.content === content;
  }).length > 0;
};