"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = void 0;
var _keymaps = require("@atlaskit/editor-common/keymaps");
var _mark = require("@atlaskit/editor-common/mark");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _utils = require("@atlaskit/editor-common/utils");
var _commands = require("@atlaskit/editor-prosemirror/commands");
var _state = require("@atlaskit/editor-prosemirror/state");
var _textFormatting = _interopRequireWildcard(require("../editor-commands/text-formatting"));
var commands = _textFormatting;
var _pluginKey = require("./plugin-key");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// TODO: ED-26962 - Ideally this should use the custom toggleMark function from @atlaskit/editor-common so we also disable the options when selecting inline nodes but it disables the marks when the selection is empty at this point in time which is undesirable
// import { toggleMark } from '@atlaskit/editor-common/mark';

// Ignored via go/ees005
// eslint-disable-next-line import/no-namespace

var isSelectionInlineCursor = function isSelectionInlineCursor(selection) {
  if (selection instanceof _state.NodeSelection) {
    return true;
  }
  return false;
};
var checkNodeSelection = function checkNodeSelection(mark, editorState, type) {
  var selection = editorState.selection;
  if (isSelectionInlineCursor(selection)) {
    return false;
  }
  if (type !== null || type !== undefined) {
    return (0, _commands.toggleMark)(mark, {
      type: type
    })(editorState);
  }
  return (0, _commands.toggleMark)(mark)(editorState);
};
var getTextFormattingState = function getTextFormattingState(editorState, editorAnalyticsAPI) {
  var _editorState$schema$m = editorState.schema.marks,
    em = _editorState$schema$m.em,
    code = _editorState$schema$m.code,
    strike = _editorState$schema$m.strike,
    strong = _editorState$schema$m.strong,
    subsup = _editorState$schema$m.subsup,
    underline = _editorState$schema$m.underline;
  var state = {};
  if (code) {
    state.codeActive = (0, _mark.anyMarkActive)(editorState, code.create());
    state.codeDisabled = !checkNodeSelection(code, editorState);
  }
  if (em) {
    state.emActive = (0, _mark.anyMarkActive)(editorState, em);
    state.emDisabled = state.codeActive ? true : !checkNodeSelection(em, editorState);
  }
  if (strike) {
    state.strikeActive = (0, _mark.anyMarkActive)(editorState, strike);
    state.strikeDisabled = state.codeActive ? true : !checkNodeSelection(strike, editorState);
  }
  if (strong) {
    state.strongActive = (0, _mark.anyMarkActive)(editorState, strong);
    state.strongDisabled = state.codeActive ? true : !checkNodeSelection(strong, editorState);
  }
  if (subsup) {
    var subMark = subsup.create({
      type: 'sub'
    });
    var supMark = subsup.create({
      type: 'sup'
    });
    state.subscriptActive = (0, _mark.anyMarkActive)(editorState, subMark);
    state.subscriptDisabled = state.codeActive ? true : !checkNodeSelection(subsup, editorState, 'sub');
    state.superscriptActive = (0, _mark.anyMarkActive)(editorState, supMark);
    state.superscriptDisabled = state.codeActive ? true : !checkNodeSelection(subsup, editorState, 'sup');
  }
  if (underline) {
    state.underlineActive = (0, _mark.anyMarkActive)(editorState, underline);
    state.underlineDisabled = state.codeActive ? true : !checkNodeSelection(underline, editorState);
  }
  return state;
};
var plugin = exports.plugin = function plugin(dispatch, editorAnalyticsAPI) {
  return new _safePlugin.SafePlugin({
    state: {
      init: function init(_config, state) {
        return getTextFormattingState(state, editorAnalyticsAPI);
      },
      apply: function apply(_tr, pluginState, _oldState, newState) {
        var state = getTextFormattingState(newState, editorAnalyticsAPI);
        if (!(0, _utils.shallowEqual)(pluginState, state)) {
          dispatch(_pluginKey.pluginKey, state);
          return state;
        }
        return pluginState;
      }
    },
    key: _pluginKey.pluginKey,
    props: {
      handleKeyDown: function handleKeyDown(view, event) {
        var state = view.state,
          dispatch = view.dispatch;
        if (event.key === _keymaps.moveRight.common && !event.metaKey) {
          return commands.moveRight()(state, dispatch);
        } else if (event.key === _keymaps.moveLeft.common && !event.metaKey) {
          return commands.moveLeft()(state, dispatch);
        }
        return false;
      },
      handleTextInput: function handleTextInput(view, from, to, text) {
        var state = view.state,
          dispatch = view.dispatch;
        var schema = state.schema,
          parentNodeType = state.selection.$from.parent.type;
        if (parentNodeType.allowsMarkType(schema.marks.code)) {
          return (0, _textFormatting.createInlineCodeFromTextInputWithAnalytics)(editorAnalyticsAPI)(from, to, text)(state, dispatch);
        }
        return false;
      }
    }
  });
};