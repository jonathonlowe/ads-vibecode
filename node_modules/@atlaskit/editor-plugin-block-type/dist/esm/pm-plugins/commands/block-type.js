function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { filterChildrenBetween, wrapSelectionIn } from '@atlaskit/editor-common/utils';
import { Slice, Fragment } from '@atlaskit/editor-prosemirror/model';
import { CellSelection } from '@atlaskit/editor-tables';
import { HEADINGS_BY_NAME, NORMAL_TEXT } from '../block-types';
import { FORMATTING_NODE_TYPES, FORMATTING_MARK_TYPES, cellSelectionNodesBetween, formatTypes, clearNodeFormattingOnSelection } from './clear-formatting';
import { wrapSelectionInBlockType } from './wrapSelectionIn';
export function setBlockType(name) {
  return function (_ref) {
    var tr = _ref.tr;
    var nodes = tr.doc.type.schema.nodes;
    if (name === NORMAL_TEXT.name && nodes.paragraph) {
      return setNormalText()({
        tr: tr
      });
    }
    var headingBlockType = HEADINGS_BY_NAME[name];
    if (headingBlockType && nodes.heading && headingBlockType.level) {
      return setHeading(headingBlockType.level)({
        tr: tr
      });
    }
    return null;
  };
}
export function setHeading(level, fromBlockQuote) {
  return function (_ref2) {
    var tr = _ref2.tr;
    var selection = tr.selection,
      schema = tr.doc.type.schema;
    var ranges = selection instanceof CellSelection ? selection.ranges : [selection];
    ranges.forEach(function (_ref3) {
      var $from = _ref3.$from,
        $to = _ref3.$to;
      if (fromBlockQuote) {
        var range = $from.blockRange($to);
        if (!range) {
          return;
        }
        var content = $from.node().content;
        var headingNode = schema.nodes.heading.createChecked({
          level: level
        }, content);
        var slice = new Slice(Fragment.from(headingNode), 0, 0);
        tr.replaceRange(range.start, range.end, slice);
      } else {
        tr.setBlockType($from.pos, $to.pos, schema.nodes.heading, {
          level: level
        });
      }
    });
    return tr;
  };
}
export function setBlockTypeWithAnalytics(name, inputMethod, editorAnalyticsApi, fromBlockQuote) {
  return function (_ref4) {
    var tr = _ref4.tr;
    var nodes = tr.doc.type.schema.nodes;
    if (name === 'normal' && nodes.paragraph) {
      return setNormalTextWithAnalytics(inputMethod, editorAnalyticsApi, fromBlockQuote)({
        tr: tr
      });
    }
    var headingBlockType = HEADINGS_BY_NAME[name];
    if (headingBlockType && nodes.heading && headingBlockType.level) {
      return setHeadingWithAnalytics(headingBlockType.level, inputMethod, editorAnalyticsApi, fromBlockQuote)({
        tr: tr
      });
    }
    return null;
  };
}
export function setNormalText(fromBlockQuote) {
  return function (_ref5) {
    var tr = _ref5.tr;
    var selection = tr.selection,
      schema = tr.doc.type.schema;
    var ranges = selection instanceof CellSelection ? selection.ranges : [selection];
    ranges.forEach(function (_ref6) {
      var $from = _ref6.$from,
        $to = _ref6.$to;
      if (fromBlockQuote) {
        var range = $from.blockRange($to);
        if (!range) {
          return;
        }
        tr.lift(range, 0);
      } else {
        tr.setBlockType($from.pos, $to.pos, schema.nodes.paragraph);
      }
    });
    return tr;
  };
}
export function clearFormatting(inputMethod, editorAnalyticsApi) {
  return function (_ref7) {
    var tr = _ref7.tr;
    var formattingCleared = [];
    var schema = tr.doc.type.schema;
    FORMATTING_MARK_TYPES.forEach(function (mark) {
      var _tr$selection = tr.selection,
        from = _tr$selection.from,
        to = _tr$selection.to;
      var markType = schema.marks[mark];
      if (!markType) {
        return;
      }
      if (tr.selection instanceof CellSelection) {
        cellSelectionNodesBetween(tr.selection, tr.doc, function (node, pos) {
          var isTableCell = node.type === schema.nodes.tableCell || node.type === schema.nodes.tableHeader;
          if (!isTableCell) {
            return true;
          }
          if (tr.doc.rangeHasMark(pos, pos + node.nodeSize, markType)) {
            formattingCleared.push(formatTypes[mark]);
            tr.removeMark(pos, pos + node.nodeSize, markType);
          }
          return false;
        });
      } else if (tr.doc.rangeHasMark(from, to, markType)) {
        formattingCleared.push(formatTypes[mark]);
        tr.removeMark(from, to, markType);
      }
    });
    FORMATTING_NODE_TYPES.forEach(function (nodeName) {
      var formattedNodeType = schema.nodes[nodeName];
      var _tr$selection2 = tr.selection,
        $from = _tr$selection2.$from,
        $to = _tr$selection2.$to;
      if (tr.selection instanceof CellSelection) {
        cellSelectionNodesBetween(tr.selection, tr.doc, clearNodeFormattingOnSelection(schema, tr, formattedNodeType, nodeName, formattingCleared));
      } else {
        tr.doc.nodesBetween($from.pos, $to.pos, clearNodeFormattingOnSelection(schema, tr, formattedNodeType, nodeName, formattingCleared));
      }
    });
    tr.setStoredMarks([]);
    if (formattingCleared.length) {
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent({
        action: ACTION.FORMATTED,
        eventType: EVENT_TYPE.TRACK,
        actionSubject: ACTION_SUBJECT.TEXT,
        actionSubjectId: ACTION_SUBJECT_ID.FORMAT_CLEAR,
        attributes: {
          inputMethod: inputMethod,
          formattingCleared: formattingCleared,
          dropdownMenu: 'textStyle'
        }
      })(tr);
    }
    return tr;
  };
}
function withCurrentHeadingLevel(fn) {
  return function (_ref8) {
    var tr = _ref8.tr;
    // Find all headings and paragraphs of text
    var _tr$doc$type$schema$n = tr.doc.type.schema.nodes,
      heading = _tr$doc$type$schema$n.heading,
      paragraph = _tr$doc$type$schema$n.paragraph;
    var nodes = filterChildrenBetween(tr.doc, tr.selection.from, tr.selection.to, function (node) {
      return node.type === heading || node.type === paragraph;
    });

    // Check each paragraph and/or heading and check for consistent level
    var level;
    var _iterator = _createForOfIteratorHelper(nodes),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        var nodeLevel = node.node.type === heading ? node.node.attrs.level : 0;
        if (!level) {
          level = nodeLevel;
        } else if (nodeLevel !== level) {
          // Conflict in level, therefore inconsistent and undefined
          level = undefined;
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return fn(level)({
      tr: tr
    });
  };
}
export function setNormalTextWithAnalytics(inputMethod, editorAnalyticsApi, fromBlockQuote) {
  return withCurrentHeadingLevel(function (previousHeadingLevel) {
    return function (_ref9) {
      var tr = _ref9.tr;
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent({
        action: ACTION.FORMATTED,
        actionSubject: ACTION_SUBJECT.TEXT,
        eventType: EVENT_TYPE.TRACK,
        actionSubjectId: ACTION_SUBJECT_ID.FORMAT_HEADING,
        attributes: {
          inputMethod: inputMethod,
          newHeadingLevel: 0,
          previousHeadingLevel: previousHeadingLevel
        }
      })(tr);
      return setNormalText(fromBlockQuote)({
        tr: tr
      });
    };
  });
}
export var setHeadingWithAnalytics = function setHeadingWithAnalytics(newHeadingLevel, inputMethod, editorAnalyticsApi, fromBlockQuote) {
  return withCurrentHeadingLevel(function (previousHeadingLevel) {
    return function (_ref10) {
      var tr = _ref10.tr;
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent({
        action: ACTION.FORMATTED,
        actionSubject: ACTION_SUBJECT.TEXT,
        eventType: EVENT_TYPE.TRACK,
        actionSubjectId: ACTION_SUBJECT_ID.FORMAT_HEADING,
        attributes: {
          inputMethod: inputMethod,
          newHeadingLevel: newHeadingLevel,
          previousHeadingLevel: previousHeadingLevel
        }
      })(tr);
      return setHeading(newHeadingLevel, fromBlockQuote)({
        tr: tr
      });
    };
  });
};
function insertBlockQuote() {
  return function (state, dispatch) {
    var nodes = state.schema.nodes;
    if (nodes.paragraph && nodes.blockquote) {
      return wrapSelectionIn(nodes.blockquote)(state, dispatch);
    }
    return false;
  };
}

/**
 *
 * @param name - block type name
 * @param inputMethod - input method
 * @param editorAnalyticsApi - analytics api, undefined if not available either because it failed to load or wasn't added
 * otherwise Editor becomes very sad and crashes
 * @returns - command that inserts block type
 */
export var insertBlockQuoteWithAnalytics = function insertBlockQuoteWithAnalytics(inputMethod, editorAnalyticsApi) {
  return withAnalytics(editorAnalyticsApi, {
    action: ACTION.FORMATTED,
    actionSubject: ACTION_SUBJECT.TEXT,
    eventType: EVENT_TYPE.TRACK,
    actionSubjectId: ACTION_SUBJECT_ID.FORMAT_BLOCK_QUOTE,
    attributes: {
      inputMethod: inputMethod
    }
  })(insertBlockQuote());
};
export function insertBlockQuoteWithAnalyticsCommand(inputMethod, editorAnalyticsApi) {
  return withCurrentHeadingLevel(function (previousHeadingLevel) {
    return function (_ref11) {
      var tr = _ref11.tr;
      var nodes = tr.doc.type.schema.nodes;
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 || editorAnalyticsApi.attachAnalyticsEvent({
        action: ACTION.FORMATTED,
        actionSubject: ACTION_SUBJECT.TEXT,
        eventType: EVENT_TYPE.TRACK,
        actionSubjectId: ACTION_SUBJECT_ID.FORMAT_BLOCK_QUOTE,
        attributes: {
          inputMethod: inputMethod
        }
      })(tr);
      return wrapSelectionInBlockType(nodes.blockquote)({
        tr: tr
      });
    };
  });
}
export var cleanUpAtTheStartOfDocument = function cleanUpAtTheStartOfDocument(state, dispatch) {
  var _ref12 = state.selection,
    $cursor = _ref12.$cursor;
  if ($cursor && !$cursor.nodeBefore && !$cursor.nodeAfter && $cursor.pos === 1) {
    var tr = state.tr,
      schema = state.schema;
    var paragraph = schema.nodes.paragraph;
    var parent = $cursor.parent;

    /**
     * Use cases:
     * 1. Change `heading` to `paragraph`
     * 2. Remove block marks
     *
     * NOTE: We already know it's an empty doc so it's safe to use 0
     */
    tr.setNodeMarkup(0, paragraph, parent.attrs, []);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  }
  return false;
};