import React from 'react';
import { extendedBlockquote, blockquoteWithoutNonBodiedMacros, hardBreak, heading } from '@atlaskit/adf-schema';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { keymap, tooltip } from '@atlaskit/editor-common/keymaps';
import { blockTypeMessages as messages } from '@atlaskit/editor-common/messages';
import { IconHeading, IconQuote } from '@atlaskit/editor-common/quick-insert';
import { ToolbarSize } from '@atlaskit/editor-common/types';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { clearFormatting, insertBlockQuoteWithAnalytics, insertBlockQuoteWithAnalyticsCommand, setBlockTypeWithAnalytics } from './pm-plugins/commands/block-type';
import inputRulePlugin from './pm-plugins/input-rule';
import keymapPlugin from './pm-plugins/keymap';
import { createPlugin, pluginKey } from './pm-plugins/main';
import { FloatingToolbarComponent } from './pm-plugins/ui/FloatingToolbarComponent';
import { PrimaryToolbarComponent } from './pm-plugins/ui/PrimaryToolbarComponent';
const headingPluginOptions = ({
  formatMessage
}, isAllowed, editorAnalyticsApi) => {
  if (!isAllowed) {
    return [];
  }
  return Array.from({
    length: 6
  }, (_v, idx) => {
    const level = idx + 1;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const descriptionDescriptor = messages[`heading${level}Description`];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const keyshortcut = tooltip(keymap[`toggleHeading${level}`]);
    const id = `heading${level}`;
    return {
      id,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      title: formatMessage(messages[id]),
      description: formatMessage(descriptionDescriptor),
      priority: 1300,
      keywords: [`h${level}`],
      keyshortcut,
      icon: () => /*#__PURE__*/React.createElement(IconHeading, {
        level: level
      }),
      action(insert, state) {
        const tr = insert(state.schema.nodes.heading.createChecked({
          level
        }));
        editorAnalyticsApi === null || editorAnalyticsApi === void 0 ? void 0 : editorAnalyticsApi.attachAnalyticsEvent({
          action: ACTION.FORMATTED,
          actionSubject: ACTION_SUBJECT.TEXT,
          eventType: EVENT_TYPE.TRACK,
          actionSubjectId: ACTION_SUBJECT_ID.FORMAT_HEADING,
          attributes: {
            inputMethod: INPUT_METHOD.QUICK_INSERT,
            newHeadingLevel: level
          }
        })(tr);
        return tr;
      }
    };
  });
};
const blockquotePluginOptions = ({
  formatMessage
}, isAllowed, editorAnalyticsApi) => {
  if (!isAllowed) {
    return [];
  }
  return [{
    id: 'blockquote',
    title: formatMessage(messages.blockquote),
    description: formatMessage(messages.blockquoteDescription),
    priority: 1300,
    keyshortcut: '>',
    icon: () => /*#__PURE__*/React.createElement(IconQuote, null),
    action(insert, state) {
      const tr = insert(state.schema.nodes.blockquote.createChecked({}, state.schema.nodes.paragraph.createChecked()));
      editorAnalyticsApi === null || editorAnalyticsApi === void 0 ? void 0 : editorAnalyticsApi.attachAnalyticsEvent({
        action: ACTION.FORMATTED,
        actionSubject: ACTION_SUBJECT.TEXT,
        eventType: EVENT_TYPE.TRACK,
        actionSubjectId: ACTION_SUBJECT_ID.FORMAT_BLOCK_QUOTE,
        attributes: {
          inputMethod: INPUT_METHOD.QUICK_INSERT
        }
      })(tr);
      return tr;
    }
  }];
};
const blockTypePlugin = ({
  config: options,
  api
}) => {
  var _api$primaryToolbar;
  const primaryToolbarComponent = ({
    popupsMountPoint,
    popupsBoundariesElement,
    popupsScrollableElement,
    toolbarSize,
    disabled,
    isToolbarReducedSpacing
  }) => {
    let isSmall = options && options.isUndoRedoButtonsEnabled ? toolbarSize < ToolbarSize.XXL : toolbarSize < ToolbarSize.XL;
    if (fg('platform_editor_toolbar_responsive_fixes')) {
      isSmall = toolbarSize < ToolbarSize.XXL;
    }
    return /*#__PURE__*/React.createElement(PrimaryToolbarComponent, {
      isSmall: isSmall,
      disabled: disabled,
      isToolbarReducedSpacing: isToolbarReducedSpacing,
      api: api,
      popupsMountPoint: popupsMountPoint,
      popupsBoundariesElement: popupsBoundariesElement,
      popupsScrollableElement: popupsScrollableElement,
      shouldUseDefaultRole: false
    });
  };
  api === null || api === void 0 ? void 0 : (_api$primaryToolbar = api.primaryToolbar) === null || _api$primaryToolbar === void 0 ? void 0 : _api$primaryToolbar.actions.registerComponent({
    name: 'blockType',
    component: primaryToolbarComponent
  });
  return {
    name: 'blockType',
    nodes() {
      const blockquote = editorExperiment('platform_editor_nested_non_bodied_macros', 'test', {
        exposure: false
      }) ? extendedBlockquote : blockquoteWithoutNonBodiedMacros;
      const nodes = [{
        name: 'heading',
        node: heading
      }, {
        name: 'blockquote',
        node: blockquote
      }, {
        name: 'hardBreak',
        node: hardBreak
      }];
      if (options && options.allowBlockType) {
        const exclude = options.allowBlockType.exclude ? options.allowBlockType.exclude : [];
        return nodes.filter(node => exclude.indexOf(node.name) === -1);
      }
      return nodes;
    },
    pmPlugins() {
      return [{
        name: 'blockType',
        plugin: ({
          dispatch
        }) => createPlugin(api, dispatch, options && options.lastNodeMustBeParagraph, options === null || options === void 0 ? void 0 : options.includeBlockQuoteAsTextstyleOption)
      }, {
        name: 'blockTypeInputRule',
        plugin: ({
          schema,
          featureFlags
        }) => {
          var _api$analytics;
          return inputRulePlugin(api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions, schema, featureFlags);
        }
      },
      // Needs to be lower priority than editor-tables.tableEditing
      // plugin as it is currently swallowing right/down arrow events inside tables
      {
        name: 'blockTypeKeyMap',
        plugin: ({
          schema,
          featureFlags
        }) => {
          var _api$analytics2;
          return keymapPlugin(api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, schema, featureFlags);
        }
      }];
    },
    actions: {
      insertBlockQuote(inputMethod) {
        var _api$analytics3;
        return insertBlockQuoteWithAnalytics(inputMethod, api === null || api === void 0 ? void 0 : (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions);
      }
    },
    commands: {
      setTextLevel(level, inputMethod, fromBlockQuote = false) {
        var _api$analytics4;
        return setBlockTypeWithAnalytics(level, inputMethod, api === null || api === void 0 ? void 0 : (_api$analytics4 = api.analytics) === null || _api$analytics4 === void 0 ? void 0 : _api$analytics4.actions, fromBlockQuote);
      },
      insertBlockQuote(inputMethod) {
        var _api$analytics5;
        return insertBlockQuoteWithAnalyticsCommand(inputMethod, api === null || api === void 0 ? void 0 : (_api$analytics5 = api.analytics) === null || _api$analytics5 === void 0 ? void 0 : _api$analytics5.actions);
      },
      clearFormatting(inputMethod) {
        var _api$analytics6;
        return clearFormatting(inputMethod, api === null || api === void 0 ? void 0 : (_api$analytics6 = api.analytics) === null || _api$analytics6 === void 0 ? void 0 : _api$analytics6.actions);
      }
    },
    getSharedState(editorState) {
      if (!editorState) {
        return;
      }
      return pluginKey.getState(editorState);
    },
    primaryToolbarComponent: !(api !== null && api !== void 0 && api.primaryToolbar) ? primaryToolbarComponent : undefined,
    pluginsOptions: {
      selectionToolbar: () => {
        var _api$selectionToolbar, _api$selectionToolbar2, _api$selectionToolbar3;
        if ((api === null || api === void 0 ? void 0 : (_api$selectionToolbar = api.selectionToolbar) === null || _api$selectionToolbar === void 0 ? void 0 : (_api$selectionToolbar2 = _api$selectionToolbar.sharedState) === null || _api$selectionToolbar2 === void 0 ? void 0 : (_api$selectionToolbar3 = _api$selectionToolbar2.currentState()) === null || _api$selectionToolbar3 === void 0 ? void 0 : _api$selectionToolbar3.toolbarDocking) === 'none' && editorExperiment('platform_editor_controls', 'variant1', {
          exposure: true
        })) {
          const toolbarCustom = {
            type: 'custom',
            render: (view, _idx, _dispatchAnalyticsEvent) => {
              if (!view) {
                return;
              }
              return /*#__PURE__*/React.createElement(FloatingToolbarComponent, {
                api: api
              });
            },
            fallback: []
          };
          return {
            isToolbarAbove: true,
            items: [toolbarCustom],
            rank: 8
          };
        } else {
          return undefined;
        }
      },
      ...(editorExperiment('platform_editor_insertion', 'control') && {
        quickInsert: intl => {
          var _api$analytics7, _api$analytics8;
          const exclude = options && options.allowBlockType && options.allowBlockType.exclude ? options.allowBlockType.exclude : [];
          return [...blockquotePluginOptions(intl, exclude.indexOf('blockquote') === -1, api === null || api === void 0 ? void 0 : (_api$analytics7 = api.analytics) === null || _api$analytics7 === void 0 ? void 0 : _api$analytics7.actions), ...headingPluginOptions(intl, exclude.indexOf('heading') === -1, api === null || api === void 0 ? void 0 : (_api$analytics8 = api.analytics) === null || _api$analytics8 === void 0 ? void 0 : _api$analytics8.actions)];
        }
      })
    }
  };
};
export { blockTypePlugin };