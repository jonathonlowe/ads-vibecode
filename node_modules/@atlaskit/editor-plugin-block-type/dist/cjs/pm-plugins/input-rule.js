"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _commands = require("@atlaskit/editor-common/commands");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _utils = require("@atlaskit/editor-common/utils");
var _prosemirrorInputRules = require("@atlaskit/prosemirror-input-rules");
var _utils2 = require("./utils");
var MAX_HEADING_LEVEL = 6;
function getHeadingLevel(match) {
  return {
    level: match[1].length
  };
}
function headingRule(nodeType, maxLevel) {
  return (0, _utils2.createWrappingTextBlockRule)({
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    match: new RegExp('^(#{1,' + maxLevel + '})\\s$'),
    nodeType: nodeType,
    getAttrs: getHeadingLevel
  });
}
function blockQuoteRule(nodeType) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return (0, _utils2.createJoinNodesRule)(/^\s*>\s$/, nodeType);
}

/**
 * Get heading rules
 *
 * @param {Schema} schema
 * @returns {InputRuleWithHandler[]}
 */
function getHeadingRules(editorAnalyticsAPI, schema) {
  // '# ' for h1, '## ' for h2 and etc
  var hashRule = headingRule(schema.nodes.heading, MAX_HEADING_LEVEL);
  var leftNodeReplacementHashRule = (0, _utils.createRule)(
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  new RegExp("".concat(_prosemirrorInputRules.leafNodeReplacementCharacter, "(#{1,6})\\s$")), function (state, match, start, end) {
    var level = match[1].length;
    return (0, _commands.insertBlock)(state, schema.nodes.heading, start, end, {
      level: level
    });
  });

  // New analytics handler
  var ruleWithHeadingAnalytics = (0, _utils.inputRuleWithAnalytics)(function (_state, matchResult) {
    return {
      action: _analytics.ACTION.FORMATTED,
      actionSubject: _analytics.ACTION_SUBJECT.TEXT,
      eventType: _analytics.EVENT_TYPE.TRACK,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.FORMAT_HEADING,
      attributes: {
        inputMethod: _analytics.INPUT_METHOD.FORMATTING,
        newHeadingLevel: getHeadingLevel(matchResult).level
      }
    };
  }, editorAnalyticsAPI);
  return [ruleWithHeadingAnalytics(hashRule), ruleWithHeadingAnalytics(leftNodeReplacementHashRule)];
}

/**
 * Get all block quote input rules
 *
 * @param {Schema} schema
 * @returns {InputRuleWithHandler[]}
 */
function getBlockQuoteRules(editorAnalyticsAPI, schema) {
  // '> ' for blockquote
  var greatherThanRule = blockQuoteRule(schema.nodes.blockquote);
  var leftNodeReplacementGreatherRule = (0, _utils.createRule)(
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  new RegExp("".concat(_prosemirrorInputRules.leafNodeReplacementCharacter, "\\s*>\\s$")), function (state, _match, start, end) {
    return (0, _commands.insertBlock)(state, schema.nodes.blockquote, start, end);
  });

  // Analytics V3 handler
  var ruleWithBlockQuoteAnalytics = (0, _utils.inputRuleWithAnalytics)({
    action: _analytics.ACTION.FORMATTED,
    actionSubject: _analytics.ACTION_SUBJECT.TEXT,
    eventType: _analytics.EVENT_TYPE.TRACK,
    actionSubjectId: _analytics.ACTION_SUBJECT_ID.FORMAT_BLOCK_QUOTE,
    attributes: {
      inputMethod: _analytics.INPUT_METHOD.FORMATTING
    }
  }, editorAnalyticsAPI);
  return [ruleWithBlockQuoteAnalytics(greatherThanRule), ruleWithBlockQuoteAnalytics(leftNodeReplacementGreatherRule)];
}
function inputRulePlugin(editorAnalyticsAPI, schema, featureFlags) {
  var rules = [];
  if (schema.nodes.heading) {
    rules.push.apply(rules, (0, _toConsumableArray2.default)(getHeadingRules(editorAnalyticsAPI, schema)));
  }
  if (schema.nodes.blockquote) {
    rules.push.apply(rules, (0, _toConsumableArray2.default)(getBlockQuoteRules(editorAnalyticsAPI, schema)));
  }
  if (rules.length !== 0) {
    return new _safePlugin.SafePlugin((0, _prosemirrorInputRules.createPlugin)('block-type', rules, {
      isBlockNodeRule: true
    }));
  }
  return;
}
var _default = exports.default = inputRulePlugin;