"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cellSelectionNodesBetween = exports.FORMATTING_NODE_TYPES = exports.FORMATTING_MARK_TYPES = void 0;
exports.clearNodeFormattingOnSelection = clearNodeFormattingOnSelection;
exports.formatTypes = void 0;
var _analytics = require("@atlaskit/editor-common/analytics");
var _transform = require("@atlaskit/editor-prosemirror/transform");
// Functions duplicated from platform/packages/editor/editor-plugin-text-formatting/src/editor-commands/clear-formatting.ts
// TODO: ED-26959 - Refactor to avoid duplication if platform_editor_blockquote_in_text_formatting_menu experiment is productionalised
var FORMATTING_NODE_TYPES = exports.FORMATTING_NODE_TYPES = ['heading', 'blockquote'];
var FORMATTING_MARK_TYPES = exports.FORMATTING_MARK_TYPES = ['em', 'code', 'strike', 'strong', 'underline', 'textColor', 'subsup', 'backgroundColor'];
var formatTypes = exports.formatTypes = {
  em: _analytics.ACTION_SUBJECT_ID.FORMAT_ITALIC,
  code: _analytics.ACTION_SUBJECT_ID.FORMAT_CODE,
  strike: _analytics.ACTION_SUBJECT_ID.FORMAT_STRIKE,
  strong: _analytics.ACTION_SUBJECT_ID.FORMAT_STRONG,
  underline: _analytics.ACTION_SUBJECT_ID.FORMAT_UNDERLINE,
  textColor: _analytics.ACTION_SUBJECT_ID.FORMAT_COLOR,
  subsup: 'subsup',
  backgroundColor: _analytics.ACTION_SUBJECT_ID.FORMAT_BACKGROUND_COLOR
};
var cellSelectionNodesBetween = exports.cellSelectionNodesBetween = function cellSelectionNodesBetween(selection, doc, f, startPos) {
  selection.forEachCell(function (cell, cellPos) {
    doc.nodesBetween(cellPos, cellPos + cell.nodeSize, f, startPos);
  });
};
function clearNodeFormattingOnSelection(schema, tr, formattedNodeType, nodeName, formattingCleared) {
  return function (node, pos) {
    if (node.type === formattedNodeType) {
      if (formattedNodeType.isTextblock) {
        tr.setNodeMarkup(pos, schema.nodes.paragraph);
        formattingCleared.push(nodeName);
        return false;
      } else {
        // In case of panel or blockquote
        var fromPos = tr.doc.resolve(pos + 1);
        var toPos = tr.doc.resolve(pos + node.nodeSize - 1);
        var nodeRange = fromPos.blockRange(toPos);
        if (nodeRange) {
          var targetLiftDepth = (0, _transform.liftTarget)(nodeRange);
          if (targetLiftDepth || targetLiftDepth === 0) {
            formattingCleared.push(nodeName);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            tr.lift(nodeRange, targetLiftDepth);
          }
        }
      }
    }
    return true;
  };
}