"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cellsAtColumn = cellsAtColumn;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _utils = require("@atlaskit/editor-tables/utils");
var _tableMap = require("./table-map");
var _marked = /*#__PURE__*/_regenerator.default.mark(cellsAtColumn);
/**
 * Helper to have a consistent way to iterate for all the cells in a column.
 * You can skip rows by passing the rows to skipped in the next arguments.
 * For example: `iter.next(1)` to skip the next row
 * @param rect
 * @param col
 */
function cellsAtColumn(rect, col) {
  var map, tableStart, table, refColumn, row, index, pos, hasMergedCells, type, cell, cellInfo, skippedRows;
  return _regenerator.default.wrap(function cellsAtColumn$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        map = rect.map, tableStart = rect.tableStart, table = rect.table;
        refColumn = col > 0 ? -1 : 0;
        if ((0, _utils.columnIsHeader)(map, table, col + refColumn)) {
          refColumn = col === 0 || col === map.width ? null : 0;
        }
        row = 0;
      case 4:
        if (!(row < map.height)) {
          _context.next = 20;
          break;
        }
        index = (0, _tableMap.getCellIndex)(rect.map, row, col);
        pos = map.map[index]; // We only consider to has merged cell to the first cell in a rowspan.
        hasMergedCells = (0, _tableMap.hasMergedColumns)(rect.map, row, col) && (0, _tableMap.isRootRow)(rect.map, row, col); // If this position falls inside a col-spanning cell
        type = refColumn == null ? (0, _utils.tableNodeTypes)(table.type.schema).cell :
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        table.nodeAt(map.map[index + refColumn]).type;
        if (!hasMergedCells) {
          pos = map.positionAt(row, col, table);
        }
        cell = table.nodeAt(pos);
        cellInfo = {
          from: tableStart + pos,
          to: tableStart + pos,
          row: row,
          col: hasMergedCells ? map.colCount(pos) : col,
          type: type,
          hasMergedCells: hasMergedCells
        };
        if (cell) {
          cellInfo.attrs = cell.attrs;
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          cellInfo.to = tableStart + pos + cell.nodeSize;
        }

        // We let the consumer to pass the rows that we want to skip
        _context.next = 15;
        return cellInfo;
      case 15:
        skippedRows = _context.sent;
        if (skippedRows && skippedRows > 0) {
          row += skippedRows;
        }
      case 17:
        row++;
        _context.next = 4;
        break;
      case 20:
      case "end":
        return _context.stop();
    }
  }, _marked);
}