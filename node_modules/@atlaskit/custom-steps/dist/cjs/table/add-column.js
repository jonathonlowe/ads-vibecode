"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddColumnStep = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _cellStep = require("./utils/cell-step");
var _cellsAtColumn = require("./utils/cells-at-column");
var _findColumn = require("./utils/find-column");
var _getTableRectFromDoc = require("./utils/get-table-rect-from-doc");
var _sideEffects = require("./utils/side-effects/side-effects");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var ADD_COLUMN_STEP = 'ak-add-column';
function printColumnInfo(columnInfo) {
  var cellsFrom = [];
  var _iterator = _createForOfIteratorHelper(columnInfo.values()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var cellInfo = _step.value;
      cellsFrom.push(cellInfo.from);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return "[".concat(cellsFrom.join(','), "]");
}
function createColumnInfo(cellsInfo) {
  return new Map(cellsInfo.map(function (cellInfo) {
    return [cellInfo.from, cellInfo];
  }));
}
var getTableRectAndColumnFactory = function getTableRectAndColumnFactory(doc, pos, columnInfo) {
  return (0, _memoizeOne.default)(function () {
    var rect = (0, _getTableRectFromDoc.getTableRectFromDoc)(doc, pos);
    var column = (0, _findColumn.findColumn)(columnInfo, rect);
    if (column === null) {
      throw new Error('no column');
    }
    return {
      rect: rect,
      column: column
    };
  });
};

/**
 * Index and positions looks like
 * 0    1    2    3   -> Add Column Index
 * | 5  | 10 | 15 |   -> Table with Positions
 * | 20 | 25 | 30 |
 * 0    1    2    x   -> Remove Column Index
 *
 */
// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var AddColumnStep = exports.AddColumnStep = /*#__PURE__*/function (_Step) {
  function AddColumnStep(tablePos, addColumnStepInfo) {
    var _this;
    var isDelete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    (0, _classCallCheck2.default)(this, AddColumnStep);
    _this = _callSuper(this, AddColumnStep);
    _this.tablePos = tablePos;
    _this.isDelete = isDelete;
    _this.sideEffectsHandler = new _sideEffects.SideEffectsHandler(addColumnStepInfo.sideEffects);
    _this.columnInfo = createColumnInfo(addColumnStepInfo.cells);
    return _this;
  }

  /**
   * Detect the column based on all the cells step in column info.
   * Recreate columnInfo based on the current document. We might need to add new cells added by insert row or unmerge cells.
   * If isDelete
   *    Decrease colspan if one row has merged cell
   *    Remove all the cells using columnInfo.cellStep[].from
   * else
   *    Increase colspan if one row had merged cell
   *    Add all new cells at columnInfo.cellStep[].from,
   *      if there is columnInfo.cellStep[].newCell use it
   *      else create an empty cell
   *
   * @param doc Current document
   */
  (0, _inherits2.default)(AddColumnStep, _Step);
  return (0, _createClass2.default)(AddColumnStep, [{
    key: "apply",
    value: function apply(doc) {
      var tablePos = this.tablePos;
      // Create transform base on the doc
      var tr = new _transform.Transform(doc);
      if (this.sideEffectsHandler.table.handleAddTable(tr, this.isDelete)) {
        return _transform.StepResult.ok(tr.doc);
      }
      var tableRect;
      try {
        tableRect = (0, _getTableRectFromDoc.getTableRectFromDoc)(doc, tablePos);
      } catch (e) {
        return _transform.StepResult.fail(e.message);
      }
      var column = (0, _findColumn.findColumn)(this.columnInfo, tableRect);
      if (column === null) {
        return _transform.StepResult.fail("No column for this cells \"".concat(printColumnInfo(this.columnInfo), "\" in table at position \"").concat(tablePos, "\"."));
      }
      if (this.sideEffectsHandler.table.handleRemoveTable(tr, this.tablePos, tableRect, column, this.isDelete)) {
        return _transform.StepResult.ok(tr.doc);
      }
      this.columnInfo = this.applyCellSteps(tr, tableRect, column, this.isDelete);

      // Return the document modified.
      return _transform.StepResult.ok(tr.doc);
    }

    /**
     * Update tablePos with the new position. If tablePos doesnt exist any more remove the step
     * Update all the cellStep inside columnInfo. If cellStep.from position gets deleted removed it from column info
     * if cellStep.length === 0 remove the step
     * Create a new step with all the position updated
     * @param mapping
     */
  }, {
    key: "map",
    value: function map(mapping) {
      var tablePosResult = mapping.mapResult(this.tablePos);
      if (tablePosResult.deleted) {
        // If table was deleted remove the step
        return null;
      }
      var cellSteps = [];
      var _iterator2 = _createForOfIteratorHelper(this.columnInfo.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var oldCellStep = _step2.value;
          var fromResult = mapping.mapResult(oldCellStep.from);
          var toResult = mapping.mapResult(oldCellStep.to);
          if (fromResult.deleted && toResult.deleted) {
            continue;
          }
          var cellStep = _objectSpread(_objectSpread({}, oldCellStep), {}, {
            from: fromResult.pos,
            to: toResult.pos
          });
          if (oldCellStep.mergeWith !== undefined) {
            cellStep.mergeWith = mapping.map(oldCellStep.mergeWith);
          }
          cellSteps.push(cellStep);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (cellSteps.length === 0) {
        return null;
      }
      var sideEffects = this.sideEffectsHandler.map(mapping);
      return new AddColumnStep(tablePosResult.pos, {
        cells: cellSteps,
        sideEffects: sideEffects
      }, this.isDelete);
    }

    /**
     * if isDelete
     *    Get the original cell node at columnInfo.cellStep[].from to columnInfo.cellStep[].to
     *    Create a copy of the node
     *    Create a new cellStep with the same positions but with the clone node as a content
     *    return new step inverted
     * else
     *    Remove the content from each columnInfo.cellStep[].content
     *    return new step inverted
     * @param originalDoc
     */
  }, {
    key: "invert",
    value: function invert(originalDoc) {
      var _this2 = this;
      var stepMap = this.getMap();

      // Memoize function to be called only on delete scenarios
      var getTableRectAndColumn = getTableRectAndColumnFactory(originalDoc, this.tablePos, this.columnInfo);
      // This is needed because the real pos of the cell in the generated document is affected by the previous operations.
      var newCellSteps = Array.from(this.columnInfo.values(), function (oldCellStep) {
        var newCellStep = (0, _cellStep.invertCellStep)(originalDoc, getTableRectAndColumn, oldCellStep, _this2.isDelete, stepMap);
        return newCellStep;
      });
      var sideEffects = this.sideEffectsHandler.invert(originalDoc, this.isDelete, stepMap);
      return new AddColumnStep(this.tablePos, {
        cells: newCellSteps,
        sideEffects: sideEffects
      }, !this.isDelete);
    }

    /**
     * StepMap is created based on columnInfo.
     * ColumnInfo is created on constructor and once is applied (the document could have new cells that weren't part of the original set)
     * if isDelete
     *    Create range array based on cell info where each range is [cellStep.from, cellStep.from - cellStep.to, 0]
     * else
     *    Create range array base on cell info where each range is [cellStep.from, 0, cellStep.content ? cellStep.content.nodeSize : defaultEmptyCellNodeSize]
     *
     * Ranges in ProseMirror are represented by each 3 elements in an array.
     * As [pos, currentSize, newSize, pos2, currentSize2, newSize2] where:
     * pos: Position in the document
     * currentSize: Represent the affected range, this will be pos + currentSize
     * newSize: Represent the new values, pos + newSize
     */
  }, {
    key: "getMap",
    value: function getMap() {
      var tableMap = this.sideEffectsHandler.getTableMap(this.isDelete);
      if (tableMap) {
        return tableMap;
      }
      var ranges = [];
      var _iterator3 = _createForOfIteratorHelper(this.columnInfo.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _ranges;
          var cellStep = _step3.value;
          (_ranges = ranges).push.apply(_ranges, (0, _toConsumableArray2.default)((0, _cellStep.getMapFromCellStep)(cellStep, this.isDelete)));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      ranges = this.sideEffectsHandler.rows.addRowRanges(ranges, this.isDelete);

      // If no steps, I create am empty stepMap
      return new _transform.StepMap(ranges);
    }

    /**
     * Try to merge this step with another one, to be applied directly
     * after it. Returns the merged step when possible, null if the
     * steps can't be merged.
     */
  }, {
    key: "merge",
    value: function merge(other) {
      // We cannot merge add column step at the moment
      return null;
    }

    /**
     * Create a JSON-serializeable representation of this step. When
     * defining this for a custom subclass, make sure the result object
     * includes the step type's [JSON id](#transform.Step^jsonID) under
     * the `stepType` property.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var addColumnStepJson = {
        stepType: ADD_COLUMN_STEP,
        tablePos: this.tablePos,
        cells: Array.from(this.columnInfo.values(), function (cellStep) {
          var cellStepJson = {
            from: cellStep.from,
            to: cellStep.to
          };
          if (cellStep.mergeWith !== undefined) {
            cellStepJson.mergeWith = cellStep.mergeWith;
          }
          if (cellStep.newCell !== undefined) {
            cellStepJson.newCell = cellStep.newCell.toJSON();
          }
          return cellStepJson;
        }),
        isDelete: this.isDelete
      };
      var sideEffectsJSON = this.sideEffectsHandler.toJSON();
      if (sideEffectsJSON) {
        addColumnStepJson.sideEffects = sideEffectsJSON;
      }
      return addColumnStepJson;
    }

    /**
     * Deserialize a step from its JSON representation. Will call
     * through to the step class' own implementation of this method.
     */
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "applyCellSteps",
    value: function applyCellSteps(tr, tableRect, column, isDelete) {
      var newColumnInfo = new Map();
      var rowsHandler = this.sideEffectsHandler.rows.start(this.isDelete);
      var iter = (0, _cellsAtColumn.cellsAtColumn)(tableRect, column);
      var next = iter.next();
      // Iterate for all the cells in the current document
      while (!next.done) {
        var cell = next.value;
        var previousCellStep = this.columnInfo.get(cell.from);
        var newCellStep = (0, _cellStep.createCellStep)(cell, column, isDelete, previousCellStep);

        // If is the last cell in the row and doesnt have colspan I need to remove the whole row.
        var removeRowResult = rowsHandler.handle(tr, tableRect, cell.row, column, cell);
        if (removeRowResult.handled) {
          next = iter.next(removeRowResult.skipRows);
          continue;
        }

        // Apply the step, to the pseudo document, get rows to skip, and the cellstep (might be modified, for example, a merge cell that remove the cell instead)
        var _applyCellStep = (0, _cellStep.applyCellStep)(tr, tableRect, cell, newCellStep, isDelete, column),
          skipRows = _applyCellStep.skipRows,
          cellStep = _applyCellStep.cellStep;

        // Store the new cell step. This could be an existing one or a new cell.
        newColumnInfo.set(newCellStep.from, cellStep);
        next = iter.next(skipRows);
      }
      rowsHandler.end(tr, tableRect, column);
      return newColumnInfo;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      // TODO: Add validation. Return null if it is invalid. Check in review if this is necessary
      var cells = json.cells.map(function (cellsJson) {
        var cell = _objectSpread(_objectSpread({}, cellsJson), {}, {
          newCell: cellsJson.newCell ? schema.nodeFromJSON(cellsJson.newCell) : undefined
        });
        return cell;
      });
      var sideEffects;
      if (json.sideEffects) {
        sideEffects = _sideEffects.SideEffectsHandler.fromJSON(schema, json.sideEffects);
      }
      return new AddColumnStep(json.tablePos, {
        cells: cells,
        sideEffects: sideEffects
      }, json.isDelete);
    }
  }, {
    key: "create",
    value: function create(doc, tablePos, column) {
      var isDelete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var tableRect = (0, _getTableRectFromDoc.getTableRectFromDoc)(doc, tablePos);

      // By default add column will rely on default behaviour (add empty cell).
      // There is no need to add content
      var cells = [];
      var iter = (0, _cellsAtColumn.cellsAtColumn)(tableRect, column);
      var next = iter.next();
      while (!next.done) {
        var cell = next.value;
        cells.push((0, _cellStep.createCellStep)(cell, column, isDelete));
        var skipRows = 0;
        if (cell.attrs && cell.attrs.rowspan) {
          skipRows = cell.attrs.rowspan - 1;
        }
        next = iter.next(skipRows);
      }
      return new AddColumnStep(tablePos, {
        cells: cells
      }, isDelete);
    }
  }]);
}(_transform.Step);
_transform.Step.jsonID(ADD_COLUMN_STEP, AddColumnStep);