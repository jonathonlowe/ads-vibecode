import _regeneratorRuntime from "@babel/runtime/regenerator";
var _marked = /*#__PURE__*/_regeneratorRuntime.mark(cellsAtColumn);
import { columnIsHeader, tableNodeTypes } from '@atlaskit/editor-tables/utils';
import { getCellIndex, hasMergedColumns, isRootRow } from './table-map';
/**
 * Helper to have a consistent way to iterate for all the cells in a column.
 * You can skip rows by passing the rows to skipped in the next arguments.
 * For example: `iter.next(1)` to skip the next row
 * @param rect
 * @param col
 */
export function cellsAtColumn(rect, col) {
  var map, tableStart, table, refColumn, row, index, pos, hasMergedCells, type, cell, cellInfo, skippedRows;
  return _regeneratorRuntime.wrap(function cellsAtColumn$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        map = rect.map, tableStart = rect.tableStart, table = rect.table;
        refColumn = col > 0 ? -1 : 0;
        if (columnIsHeader(map, table, col + refColumn)) {
          refColumn = col === 0 || col === map.width ? null : 0;
        }
        row = 0;
      case 4:
        if (!(row < map.height)) {
          _context.next = 20;
          break;
        }
        index = getCellIndex(rect.map, row, col);
        pos = map.map[index]; // We only consider to has merged cell to the first cell in a rowspan.
        hasMergedCells = hasMergedColumns(rect.map, row, col) && isRootRow(rect.map, row, col); // If this position falls inside a col-spanning cell
        type = refColumn == null ? tableNodeTypes(table.type.schema).cell :
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        table.nodeAt(map.map[index + refColumn]).type;
        if (!hasMergedCells) {
          pos = map.positionAt(row, col, table);
        }
        cell = table.nodeAt(pos);
        cellInfo = {
          from: tableStart + pos,
          to: tableStart + pos,
          row: row,
          col: hasMergedCells ? map.colCount(pos) : col,
          type: type,
          hasMergedCells: hasMergedCells
        };
        if (cell) {
          cellInfo.attrs = cell.attrs;
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          cellInfo.to = tableStart + pos + cell.nodeSize;
        }

        // We let the consumer to pass the rows that we want to skip
        _context.next = 15;
        return cellInfo;
      case 15:
        skippedRows = _context.sent;
        if (skippedRows && skippedRows > 0) {
          row += skippedRows;
        }
      case 17:
        row++;
        _context.next = 4;
        break;
      case 20:
      case "end":
        return _context.stop();
    }
  }, _marked);
}