"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMobileUploadService = createMobileUploadService;
exports.createMobileUploadStateMachine = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _map = require("rxjs/operators/map");
var _xstate = require("xstate");
var _fileState = require("../../../models/file-state");
var _shouldFetchRemoteFileStates3 = require("../../shouldFetchRemoteFileStates");
var _helpers = require("../helpers");
var _uploading = require("./states/uploading");
var _processing = require("./states/processing");
var _processed = require("./states/processed");
var _processingFailed = require("./states/processingFailed");
var _error = require("./states/error");
var createMobileUploadStateMachine = exports.createMobileUploadStateMachine = function createMobileUploadStateMachine(dataloader, initialState, collectionName) {
  return (0, _xstate.createMachine)({
    // Initial state
    initial: initialState.status,
    // Context
    context: {
      currentFileState: initialState
    },
    // State definitions
    states: {
      uploading: _uploading.machineUploadingState,
      processing: _processing.machineProcessingState,
      processed: _processed.machineProcessedState,
      processingFailed: _processingFailed.machineProcessingFailedState,
      error: _error.machineErrorState
    }
  }, {
    services: {
      shouldFetchRemoteFileStates: function () {
        var _shouldFetchRemoteFileStates2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(ctx) {
          var currentFileState, mediaType, mimeType, preview;
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                currentFileState = ctx.currentFileState;
                if (!(0, _fileState.isProcessingFileState)(currentFileState)) {
                  _context.next = 4;
                  break;
                }
                mediaType = currentFileState.mediaType, mimeType = currentFileState.mimeType, preview = currentFileState.preview;
                return _context.abrupt("return", (0, _shouldFetchRemoteFileStates3.shouldFetchRemoteFileStates)(mediaType, mimeType, preview));
              case 4:
                return _context.abrupt("return", false);
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function shouldFetchRemoteFileStates(_x) {
          return _shouldFetchRemoteFileStates2.apply(this, arguments);
        }
        return shouldFetchRemoteFileStates;
      }(),
      fetchRemoteFileStates: function fetchRemoteFileStates(ctx) {
        return (0, _helpers.createMobileDownloadFileStream)(dataloader, ctx.currentFileState.id, collectionName, ctx.currentFileState.occurrenceKey).pipe((0, _map.map)(function (fileState) {
          return {
            type: 'REMOTE_FILESTATE_RESULT',
            fileState: fileState
          };
        }));
      }
    }
  });
};
function createMobileUploadService(machine) {
  return (0, _xstate.interpret)(machine);
}