import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { isClientBasedAuth } from '@atlaskit/media-core';
import { FILE_CACHE_MAX_AGE, MAX_RESOLUTION } from '../../constants';
import { getArtifactUrl } from '../../models/artifacts';
import { isRequestError, request } from '../../utils/request';
import { createUrl, createMapResponseToJson, createMapResponseToBlob, defaultShouldRetryError, extendTraceContext } from '../../utils/request/helpers';
import { mapToMediaCdnUrl } from '../../utils/mediaCdn';
import { resolveAuth, resolveInitialAuth } from './resolveAuth';
import { ChunkHashAlgorithm } from '@atlaskit/media-core';
import { fg } from '@atlaskit/platform-feature-flags';
import { isCommercial } from '../../utils/isCommercial';
const MEDIA_API_REGION = 'media-api-region';
const MEDIA_API_ENVIRONMENT = 'media-api-environment';
const extendImageParams = (params, fetchMaxRes = false) => {
  var _params$maxAge, _params$allowAnimated, _params$mode;
  return {
    ...params,
    'max-age': (_params$maxAge = params === null || params === void 0 ? void 0 : params['max-age']) !== null && _params$maxAge !== void 0 ? _params$maxAge : FILE_CACHE_MAX_AGE,
    allowAnimated: (_params$allowAnimated = params === null || params === void 0 ? void 0 : params.allowAnimated) !== null && _params$allowAnimated !== void 0 ? _params$allowAnimated : true,
    mode: (_params$mode = params === null || params === void 0 ? void 0 : params.mode) !== null && _params$mode !== void 0 ? _params$mode : 'crop',
    ...(fetchMaxRes ? {
      width: MAX_RESOLUTION,
      height: MAX_RESOLUTION
    } : {})
  };
};
const jsonHeaders = {
  Accept: 'application/json',
  'Content-Type': 'application/json'
};
const cdnFeatureFlag = endpoint => {
  let result = endpoint;
  if (fg('platform_media_cdn_delivery')) {
    if (isCommercial()) {
      result += '/cdn';
    }
  }
  return result;
};
export class MediaStore {
  constructor(config) {
    _defineProperty(this, "resolveAuth", authContext => resolveAuth(this.config.authProvider, authContext, this.config.authProviderTimeout));
    _defineProperty(this, "resolveInitialAuth", () => resolveInitialAuth(this.config.initialAuth));
    this.config = config;
    this._chunkHashAlgorithm = config.chunkHashAlgorithm || ChunkHashAlgorithm.Sha1;
  }
  async removeCollectionFile(id, collectionName, occurrenceKey, traceContext) {
    const metadata = {
      method: 'PUT',
      endpoint: '/collection/{collectionName}'
    };
    const body = {
      actions: [{
        action: 'remove',
        item: {
          type: 'file',
          id,
          occurrenceKey
        }
      }]
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName
      },
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body),
      traceContext
    };
    await this.request(`/collection/${collectionName}`, options);
  }
  createUpload(createUpTo = 1, collectionName, traceContext) {
    const metadata = {
      method: 'POST',
      endpoint: '/upload'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName
      },
      params: {
        createUpTo,
        hashAlgorithm: this._chunkHashAlgorithm
      },
      headers: {
        Accept: 'application/json'
      },
      traceContext
    };
    return this.request(`/upload`, options).then(createMapResponseToJson(metadata));
  }
  async uploadChunk(etag, blob, uploadId, partNumber, collectionName, traceContext) {
    const metadata = {
      method: 'PUT',
      endpoint: '/chunk/{etag}'
    };
    const options = {
      ...metadata,
      params: {
        uploadId,
        partNumber
      },
      authContext: {
        collectionName
      },
      body: blob,
      traceContext
    };
    await this.request(`/chunk/${etag}`, options);
  }
  createFileFromUpload(body, params = {}, traceContext) {
    const metadata = {
      method: 'POST',
      endpoint: '/file/upload'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params.collection
      },
      params,
      headers: jsonHeaders,
      body: JSON.stringify(body),
      traceContext
    };
    return this.request('/file/upload', options).then(createMapResponseToJson(metadata));
  }
  getRejectedResponseFromDescriptor(descriptor, limit) {
    return {
      fileId: descriptor.fileId,
      error: {
        code: 'ExceedMaxFileSizeLimit',
        title: 'The expected file size exceeded the maximum size limit.',
        href: 'https://dt-api-filestore--app.ap-southeast-2.dev.atl-paas.net/api.html#BadRequest',
        limit,
        size: descriptor.size
      }
    };
  }
  async touchFiles(body, params = {}, traceContext) {
    const metadata = {
      method: 'POST',
      endpoint: '/upload/createWithFiles'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params.collection
      },
      headers: jsonHeaders,
      body: JSON.stringify(body),
      traceContext,
      params: {
        hashAlgorithm: this._chunkHashAlgorithm
      }
    };
    return this.request('/upload/createWithFiles', options).then(createMapResponseToJson(metadata));
  }
  getFile(fileId, params = {}, traceContext) {
    const metadata = {
      method: 'GET',
      endpoint: '/file/{fileId}'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params.collection
      },
      params,
      traceContext
    };
    return this.request(`/file/${fileId}`, options).then(createMapResponseToJson(metadata));
  }
  async getFileImageURL(id, params) {
    const {
      collection: collectionName
    } = params || {};
    const auth = await this.resolveAuth({
      collectionName
    });
    return this.createFileImageURL(id, auth, params);
  }

  // TODO Create ticket in case Trace Id can be supported through query params
  getFileImageURLSync(id, params) {
    const auth = this.resolveInitialAuth();
    return this.createFileImageURL(id, auth, params);
  }
  createFileImageURL(id, auth, params) {
    const options = {
      params: extendImageParams(params),
      auth
    };
    const imageEndpoint = cdnFeatureFlag('image');
    return mapToMediaCdnUrl(createUrl(`${auth.baseUrl}/file/${id}/${imageEndpoint}`, options), auth.token);
  }
  async getFileBinary(id, collectionName, abortController, maxAge = FILE_CACHE_MAX_AGE) {
    const headers = {};
    const binaryEndpoint = cdnFeatureFlag('binary');
    const metadata = {
      method: 'GET',
      endpoint: `/file/{fileId}/${binaryEndpoint}`
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName
      },
      headers,
      params: {
        collection: collectionName,
        'max-age': `${maxAge}`
      }
    };
    return this.request(`/file/${id}/${binaryEndpoint}`, options, abortController, true).then(createMapResponseToBlob(metadata));
  }
  async getFileBinaryURL(id, collectionName, maxAge = FILE_CACHE_MAX_AGE) {
    const auth = await this.resolveAuth({
      collectionName
    });
    const options = {
      params: {
        dl: true,
        collection: collectionName,
        'max-age': maxAge
      },
      auth
    };
    const binaryEndpoint = cdnFeatureFlag('binary');
    return mapToMediaCdnUrl(createUrl(`${auth.baseUrl}/file/${id}/${binaryEndpoint}`, options), auth.token);
  }
  async getArtifactURL(artifacts, artifactName, collectionName) {
    const artifactUrl = getArtifactUrl(artifacts, artifactName);
    if (!artifactUrl) {
      throw new Error(`artifact ${artifactName} not found`);
    }
    const auth = await this.resolveAuth({
      collectionName
    });
    const options = {
      params: {
        collection: collectionName,
        'max-age': FILE_CACHE_MAX_AGE
      },
      auth
    };
    return createUrl(mapToMediaCdnUrl(artifactUrl, auth.token), options);
  }
  async getImage(id, params, controller, fetchMaxRes, traceContext) {
    // TODO add checkWebpSupport() back https://product-fabric.atlassian.net/browse/MPT-584
    const isWebpSupported = false;
    const headers = {};
    if (isWebpSupported) {
      headers.accept = 'image/webp,image/*,*/*;q=0.8';
    }
    const imageEndpoint = cdnFeatureFlag('image');
    const metadata = {
      method: 'GET',
      endpoint: `/file/{fileId}/${imageEndpoint}`
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params && params.collection
      },
      params: extendImageParams(params, fetchMaxRes),
      headers,
      traceContext,
      addMediaClientParam: true
    };
    return this.request(`/file/${id}/${imageEndpoint}`, options, controller, true).then(createMapResponseToBlob(metadata));
  }
  async getItems(ids, collectionName, traceContext, includeHashForDuplicateFiles) {
    const descriptors = ids.map(id => ({
      type: 'file',
      id,
      collection: collectionName
    }));
    const metadata = {
      method: 'POST',
      endpoint: '/items'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName
      },
      headers: jsonHeaders,
      body: JSON.stringify({
        descriptors,
        includeHashForDuplicateFiles
      }),
      traceContext
    };
    return this.request('/items', options).then(createMapResponseToJson(metadata));
  }
  async getImageMetadata(id, params, traceContext) {
    const metadata = {
      method: 'GET',
      endpoint: '/file/{fileId}/image/metadata'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params && params.collection
      },
      params,
      traceContext
    };
    return this.request(`/file/${id}/image/metadata`, options).then(createMapResponseToJson(metadata));
  }
  async appendChunksToUpload(uploadId, body, collectionName, traceContext) {
    const metadata = {
      method: 'PUT',
      endpoint: '/upload/{uploadId}/chunks'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName
      },
      headers: jsonHeaders,
      body: JSON.stringify(body),
      traceContext
    };
    await this.request(`/upload/${uploadId}/chunks`, options);
  }
  copyFileWithToken(body, params, traceContext) {
    const metadata = {
      method: 'POST',
      endpoint: '/file/copy/withToken'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params.collection
      },
      // Contains collection name to write to
      params,
      // Contains collection name to write to
      headers: jsonHeaders,
      body: JSON.stringify(body),
      // Contains collection name to read from
      traceContext
    };
    return this.request('/file/copy/withToken', options).then(createMapResponseToJson(metadata));
  }
  copyFile(id, params, traceContext) {
    const metadata = {
      method: 'POST',
      endpoint: '/v2/file/copy'
    };
    const options = {
      ...metadata,
      authContext: {
        collectionName: params.collection
      },
      params,
      headers: jsonHeaders,
      body: JSON.stringify({
        id
      }),
      traceContext,
      clientOptions: {
        retryOptions: {
          shouldRetryError: err => {
            var _err$metadata;
            return defaultShouldRetryError(err) || isRequestError(err) && (err === null || err === void 0 ? void 0 : (_err$metadata = err.metadata) === null || _err$metadata === void 0 ? void 0 : _err$metadata.statusCode) === 401;
          }
        }
      }
    };
    return this.request('/v2/file/copy', options).then(createMapResponseToJson(metadata));
  }
  async registerCopyIntents(files, traceContext, resolvedAuth) {
    const metadata = {
      method: 'POST',
      endpoint: '/file/copy/intents'
    };
    const options = {
      ...metadata,
      headers: jsonHeaders,
      body: JSON.stringify({
        files
      }),
      traceContext,
      resolvedAuth
    };
    await this.request('/file/copy/intents', options);
  }
  async request(path, options = {
    method: 'GET',
    endpoint: undefined,
    authContext: {}
  }, controller, useMediaCdn) {
    const {
      method,
      endpoint,
      authContext,
      params,
      headers,
      body,
      clientOptions,
      traceContext,
      addMediaClientParam,
      resolvedAuth
    } = options;
    const auth = resolvedAuth !== null && resolvedAuth !== void 0 ? resolvedAuth : await this.resolveAuth(authContext);
    const clientId = isClientBasedAuth(auth) ? auth.clientId : undefined;
    const extendedTraceContext = extendTraceContext(traceContext);
    const extendedParams = addMediaClientParam ? {
      ...params,
      clientId
    } : params;
    let url = `${auth.baseUrl}${path}`;
    if (useMediaCdn) {
      url = mapToMediaCdnUrl(url, auth.token);
    }
    const response = await request(url, {
      method,
      endpoint,
      auth,
      params: extendedParams,
      headers,
      body,
      clientOptions,
      traceContext: extendedTraceContext
    }, controller);
    setKeyValueInSessionStorage(MEDIA_API_REGION, response.headers.get('x-media-region'));
    setKeyValueInSessionStorage(MEDIA_API_ENVIRONMENT, response.headers.get('x-media-env'));
    return response;
  }
  async testUrl(url, options = {}) {
    const {
      traceContext
    } = options;
    await request(url, {
      method: 'HEAD',
      traceContext: extendTraceContext(traceContext),
      clientOptions: {
        retryOptions: {
          maxAttempts: 1
        }
      }
    });
  }
  get chunkHashAlgorithm() {
    return this._chunkHashAlgorithm;
  }
}
const getValueFromSessionStorage = key => {
  return window && window.sessionStorage && window.sessionStorage.getItem(key) || undefined;
};
const setKeyValueInSessionStorage = (key, value) => {
  if (!value || !(window && window.sessionStorage)) {
    return;
  }
  const currentValue = window.sessionStorage.getItem(key);
  if (currentValue !== value) {
    window.sessionStorage.setItem(key, value);
  }
};
export const getMediaEnvironment = () => {
  return getValueFromSessionStorage(MEDIA_API_ENVIRONMENT);
};
export const getMediaRegion = () => {
  return getValueFromSessionStorage(MEDIA_API_REGION);
};