import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { Subscription } from 'rxjs/Subscription';
import { map } from 'rxjs/operators/map';
import uuid from 'uuid/v4';
import { authToOwner } from '@atlaskit/media-core';
import { downloadUrl } from '@atlaskit/media-common/downloadUrl';
import { MediaStore as MediaApi } from '../media-store';
import { isErrorFileState, isFinalFileState, isProcessingFileState, mapMediaFileToFileState, mapMediaItemToFileState } from '../../models/file-state';
import { isNotFoundMediaItemDetails } from '../../models/media';
import { FileFetcherError } from './error';
import { uploadFile } from '../../uploader';
import { getFileStreamsCache } from '../../file-streams-cache';
import { globalMediaEventEmitter } from '../../globalMediaEventEmitter';
import { RECENTS_COLLECTION } from '../../constants';
import isValidId from 'uuid-validate';
import { createFileDataloader } from '../../utils/createFileDataLoader';
import { getMediaTypeFromUploadableFile } from '../../utils/getMediaTypeFromUploadableFile';
import { overrideMediaTypeIfUnknown } from '../../utils/overrideMediaTypeIfUnknown';
import { convertBase64ToBlob } from '../../utils/convertBase64ToBlob';
import { toPromise, fromObservable } from '../../utils/mediaSubscribable';
import { getDimensionsFromBlob } from '../../utils/getDimensionsFromBlob';
import { createMediaSubject } from '../../utils/createMediaSubject';
import { getMediaTypeFromMimeType } from '@atlaskit/media-common/mediaTypeUtils';
import { shouldFetchRemoteFileStates } from '../../utils/shouldFetchRemoteFileStates';
import { PollingFunction } from '../../utils/polling';
import { isEmptyFile } from '../../utils/detectEmptyFile';
import { mediaStore } from '@atlaskit/media-state';
import { createCopyIntentRegisterationBatcher } from '../../utils/createCopyIntentRegisterationBatcher';
import { defaultShouldRetryError } from '../../utils/request/helpers';
import { isCommonMediaClientError, CommonMediaClientError, fromCommonMediaClientError } from '../../models/errors';
export { isFileFetcherError, FileFetcherError } from './error';
const isCopySourceFileWithToken = token => !!token.authProvider;
const isCopyDestinationWithToken = token => !!token.authProvider;
export class FileFetcherImpl {
  constructor(mediaApi, store = mediaStore) {
    _defineProperty(this, "getErrorFileState", (error, id, occurrenceKey) => {
      if (isCommonMediaClientError(error)) {
        return fromCommonMediaClientError(id, occurrenceKey, error);
      }
      // ________________________________________________
      // Legacy serializers
      // We need to revisit all the incoming error types and ensure all the "reason" values are known
      // We need to change the input error: any for a known type.
      if (typeof error === 'string') {
        const err = new CommonMediaClientError(error);
        return fromCommonMediaClientError(id, occurrenceKey, err);
      } else {
        const err = new CommonMediaClientError((error === null || error === void 0 ? void 0 : error.reason) || 'unknown', error === null || error === void 0 ? void 0 : error.metadata, error === null || error === void 0 ? void 0 : error.innerError);
        return fromCommonMediaClientError(id, occurrenceKey, err);
      }
    });
    _defineProperty(this, "setFileState", (id, fileState) => {
      this.store.setState(state => {
        state.files[id] = fileState;
      });
    });
    // TODO: ----- ADD TICKET TO PASS TRACE ID to this.dataloader.load
    _defineProperty(this, "createDownloadFileStream", (id, collectionName, occurrenceKey, includeHashForDuplicateFiles, forceRefresh) => {
      const subject = createMediaSubject();
      const poll = new PollingFunction();

      // ensure subject errors if polling exceeds max iterations or uncaught exception in executor
      poll.onError = error => subject.error(error);
      poll.execute(async () => {
        if (forceRefresh) {
          this.dataloader.clear({
            id,
            collectionName,
            includeHashForDuplicateFiles
          });
        }
        const response = await this.dataloader.load({
          id,
          collectionName,
          includeHashForDuplicateFiles
        });
        if (isNotFoundMediaItemDetails(response)) {
          throw new FileFetcherError('emptyItems', {
            id,
            collectionName,
            occurrenceKey,
            traceContext: response.metadataTraceContext
          });
        }
        if (isEmptyFile(response)) {
          throw new FileFetcherError('zeroVersionFile', {
            id,
            collectionName,
            occurrenceKey,
            traceContext: response.metadataTraceContext
          });
        }
        const fileState = mapMediaItemToFileState(id, response);
        subject.next(fileState);
        switch (fileState.status) {
          case 'processing':
            // the only case for continuing polling, otherwise this function is run once only
            poll.next();
            break;
          case 'processed':
            subject.complete();
            break;
        }
      });
      return subject;
    });
    _defineProperty(this, "getUploadingFileStateBase", (file, upfrontId) => {
      // TODO: DO not modify the input parameter 'content' attribute
      if (typeof file.content === 'string') {
        file.content = convertBase64ToBlob(file.content);
      }
      const {
        content,
        name = '' // name property is not available in base64 image
      } = file;
      const {
        id,
        occurrenceKey
      } = upfrontId;
      let preview;
      // TODO [MSW-796]: get file size for base64
      let size = 0;
      let mimeType = '';
      if (content instanceof Blob) {
        size = content.size;
        mimeType = content.type;
        preview = {
          value: content,
          origin: 'local'
        };
      }
      const mediaType = getMediaTypeFromUploadableFile(file);
      return {
        id,
        occurrenceKey,
        name,
        size,
        mediaType,
        mimeType,
        preview
      };
    });
    this.mediaApi = mediaApi;
    this.store = store;
    this.dataloader = createFileDataloader(mediaApi);
    this.copyIntentRegisterationBatcher = createCopyIntentRegisterationBatcher(mediaApi);
  }
  getFileState(id, options = {}) {
    const {
      collectionName,
      occurrenceKey,
      includeHashForDuplicateFiles,
      forceRefresh
    } = options;
    if (!isValidId(id)) {
      const subject = createMediaSubject();
      const err = new FileFetcherError('invalidFileId', {
        id,
        collectionName,
        occurrenceKey
      });
      const errorFileState = this.getErrorFileState(err, id, occurrenceKey);
      subject.error(err);
      this.setFileState(id, errorFileState);
      return fromObservable(subject);
    }
    if (forceRefresh) {
      getFileStreamsCache().remove(id);
    }
    return fromObservable(getFileStreamsCache().getOrInsert(id, () => {
      const subject = this.createDownloadFileStream(id, collectionName, undefined, includeHashForDuplicateFiles, forceRefresh);
      subject.subscribe({
        next: fileState => {
          this.setFileState(id, fileState);
        },
        error: err => {
          const errorFileState = this.getErrorFileState(err, id, occurrenceKey);
          this.setFileState(id, errorFileState);
        }
      });
      return subject;
    }));
  }
  getCurrentState(id, options) {
    return toPromise(this.getFileState(id, options));
  }
  getArtifactURL(artifacts, artifactName, collectionName) {
    return this.mediaApi.getArtifactURL(artifacts, artifactName, collectionName);
  }
  getFileBinaryURL(id, collectionName, maxAge) {
    return this.mediaApi.getFileBinaryURL(id, collectionName, maxAge);
  }
  touchFiles(descriptors, collection, traceContext) {
    return this.mediaApi.touchFiles({
      descriptors
    }, {
      collection
    }, traceContext).then(({
      data
    }) => data);
  }
  generateUploadableFileUpfrontIds(collection, traceContext) {
    const id = uuid();
    const occurrenceKey = uuid();
    const touchFileDescriptor = {
      fileId: id,
      occurrenceKey,
      collection
    };
    const deferredUploadId = this.touchFiles([touchFileDescriptor], collection, traceContext).then(touchedFiles => touchedFiles.created[0].uploadId);
    return {
      id,
      occurrenceKey,
      deferredUploadId
    };
  }
  async uploadExternal(url, collection, traceContext) {
    const uploadableFileUpfrontIds = this.generateUploadableFileUpfrontIds(collection, traceContext);
    const {
      id,
      occurrenceKey
    } = uploadableFileUpfrontIds;
    const subject = createMediaSubject();
    const deferredBlob = fetch(url).then(response => response.blob()).catch(() => undefined);
    const preview = new Promise(async (resolve, reject) => {
      const blob = await deferredBlob;
      if (!blob) {
        reject('Could not fetch the blob');
      }
      resolve({
        value: blob,
        origin: 'remote'
      });
    });
    const name = url.split('/').pop() || '';
    // we create a initial fileState with the minimum info that we have at this point
    const fileState = {
      status: 'processing',
      name,
      size: 0,
      mediaType: 'unknown',
      mimeType: '',
      id,
      occurrenceKey,
      preview
    };
    subject.next(fileState);
    // we save it into the cache as soon as possible, in case someone subscribes
    getFileStreamsCache().set(id, subject);
    this.setFileState(id, fileState);
    return new Promise(async (resolve, reject) => {
      const blob = await deferredBlob;
      if (!blob) {
        return reject('Could not download remote file');
      }
      const {
        type,
        size
      } = blob;
      const file = {
        content: blob,
        mimeType: type,
        collection,
        name,
        size
      };
      const mediaType = getMediaTypeFromMimeType(type);

      // we emit a richer state after the blob is fetched
      subject.next({
        status: 'processing',
        name,
        size,
        mediaType,
        mimeType: type,
        id,
        occurrenceKey,
        preview
      });
      // we don't want to wait for the file to be upload
      this.upload(file, undefined, uploadableFileUpfrontIds, traceContext);
      let dimensions;
      try {
        dimensions = await getDimensionsFromBlob(mediaType, blob);
      } catch (error) {
        reject(error);
        return;
      }
      resolve({
        dimensions,
        mimeType: type,
        uploadableFileUpfrontIds
      });
    });
  }
  upload(file, controller, uploadableFileUpfrontIds, traceContext) {
    const {
      collection
    } = file;
    const upfrontId = uploadableFileUpfrontIds || this.generateUploadableFileUpfrontIds(collection, traceContext);
    const {
      id,
      occurrenceKey
    } = upfrontId;
    const stateBase = this.getUploadingFileStateBase(file, upfrontId);
    const subject = createMediaSubject();
    getFileStreamsCache().set(id, subject);
    const onProgress = progress => {
      const fileState = {
        status: 'uploading',
        ...stateBase,
        progress
      };
      subject.next(fileState);
      this.setFileState(id, fileState);
    };
    let processingSubscription = new Subscription();
    const onUploadFinish = error => {
      if (error) {
        const errorFileState = this.getErrorFileState(error, id, occurrenceKey);
        this.setFileState(id, errorFileState);
        return subject.error(error);
      }
      processingSubscription = this.createDownloadFileStream(id, collection, occurrenceKey).pipe(map(remoteFileState => ({
        // merges base state with remote state
        ...stateBase,
        ...remoteFileState,
        ...overrideMediaTypeIfUnknown(remoteFileState, stateBase.mediaType)
      }))).subscribe({
        next: fileState => {
          subject.next(fileState);
          this.setFileState(id, fileState);
        },
        error: err => {
          const errorFileState = this.getErrorFileState(err, id, occurrenceKey);
          subject.error(err);
          this.setFileState(id, errorFileState);
        },
        complete: subject.complete
      });
    };
    const {
      cancel
    } = uploadFile(file, this.mediaApi, upfrontId, {
      onUploadFinish,
      onProgress
    }, traceContext);
    controller === null || controller === void 0 ? void 0 : controller.setAbort(() => {
      cancel();
      // TODO: filestate should turn to "Aborted" or something.
      // Consider canceling an upload that is already finished
      processingSubscription.unsubscribe();
    });

    // We should report progress asynchronously, since this is what consumer expects
    // (otherwise in newUploadService file-converting event will be emitted before files-added)
    setTimeout(onProgress, 0, 0);
    return fromObservable(subject);
  }
  async downloadBinary(id, name = 'download', collectionName, traceContext) {
    const url = await this.mediaApi.getFileBinaryURL(id, collectionName);
    downloadUrl(url, {
      name
    });
    globalMediaEventEmitter.emit('media-viewed', {
      fileId: id,
      isUserCollection: collectionName === RECENTS_COLLECTION,
      viewingLevel: 'download'
    });
    // Test the download after initiated the Browser process to catch any potential errors.
    await this.mediaApi.testUrl(url, {
      traceContext
    });
  }
  async registerCopyIntent(id, collectionName) {
    // pre-resolving auth to add it to the key
    const auth = await this.mediaApi.resolveAuth({
      collectionName
    });
    const key = {
      id,
      collectionName,
      resolvedAuth: auth
    };
    const error = await this.copyIntentRegisterationBatcher.load(key);
    if (error) {
      // if the error is retryable then it should not be cached
      if (defaultShouldRetryError(error)) {
        this.copyIntentRegisterationBatcher.clear(key);
      }
      throw error;
    }
  }
  async copyFileWithToken(source, destination, traceContext) {
    const {
      authProvider,
      collection: sourceCollection,
      id
    } = source;
    const {
      authProvider: destinationAuthProvider,
      collection: destinationCollectionName,
      replaceFileId,
      occurrenceKey
    } = destination;
    const mediaStore = destination.mediaStore || new MediaApi({
      authProvider: destinationAuthProvider
    });
    const owner = authToOwner(await authProvider({
      collectionName: sourceCollection
    }));
    const body = {
      sourceFile: {
        id,
        collection: sourceCollection,
        owner
      }
    };
    const params = {
      collection: destinationCollectionName,
      replaceFileId,
      occurrenceKey
    };
    const {
      data
    } = await mediaStore.copyFileWithToken(body, params, traceContext);
    return data;
  }
  async copyFileWithIntent(source, destination, traceContext) {
    const res = await this.mediaApi.copyFile(source.id, {
      sourceCollection: source.collection,
      collection: destination.collection,
      replaceFileId: destination.replaceFileId
    }, traceContext);
    const {
      data
    } = res;
    return data;
  }
  async copyFile(source, destination, options = {}, traceContext) {
    const {
      id
    } = source;
    const {
      collection: destinationCollectionName,
      replaceFileId,
      occurrenceKey
    } = destination;
    const {
      preview,
      mimeType
    } = options;
    const cache = getFileStreamsCache();
    let processingSubscription;
    try {
      let copiedFile;
      if (isCopySourceFileWithToken(source) && isCopyDestinationWithToken(destination)) {
        copiedFile = await this.copyFileWithToken(source, destination, traceContext);
      } else {
        copiedFile = await this.copyFileWithIntent(source, destination, traceContext);
      }

      // if we were passed a "mimeType", we propagate it into copiedFileWithMimeType
      const copiedFileWithMimeType = {
        ...copiedFile,
        ...(mimeType ? {
          mimeType
        } : undefined)
      };
      const {
        id: copiedId,
        mimeType: copiedMimeType
      } = copiedFileWithMimeType;

      // backend may return an "unknown" mediaType just after the copy
      // it's better to deduce it from "copiedMimeType" using getMediaTypeFromMimeType()
      const mediaType = copiedMimeType ? getMediaTypeFromMimeType(copiedMimeType) : 'unknown';
      const copiedFileState = mapMediaFileToFileState({
        data: copiedFileWithMimeType
      });
      const fileCache = cache.get(copiedId);
      const subject = fileCache || createMediaSubject();

      // if we were passed a "preview", we propagate it into the copiedFileState
      const previewOverride = !isErrorFileState(copiedFileState) && !!preview ? {
        preview
      } : {};
      if (!isFinalFileState(copiedFileState) &&
      // mimeType should always be returned by "copyFileWithToken"
      // but in case it's not, we don't want to penalize "copyFile"
      copiedMimeType && (await shouldFetchRemoteFileStates(mediaType, copiedMimeType, preview))) {
        const fileState = {
          ...copiedFileState,
          ...overrideMediaTypeIfUnknown(copiedFileState, mediaType),
          ...previewOverride
        };
        subject.next(fileState);
        this.setFileState(copiedId, fileState);
        processingSubscription = this.createDownloadFileStream(copiedId, destinationCollectionName, occurrenceKey).subscribe({
          next: remoteFileState => {
            const fileState = {
              ...remoteFileState,
              ...overrideMediaTypeIfUnknown(remoteFileState, mediaType),
              ...(!isErrorFileState(remoteFileState) && previewOverride)
            };
            this.setFileState(copiedId, fileState);
            return subject.next(fileState);
          },
          error: err => {
            const errorFileState = this.getErrorFileState(err, id, occurrenceKey);
            this.setFileState(copiedId, errorFileState);
            return subject.error(err);
          },
          complete: () => subject.complete()
        });
      } else if (!isProcessingFileState(copiedFileState)) {
        const fileState = {
          ...copiedFileState,
          ...(!isErrorFileState(copiedFileState) && previewOverride)
        };
        subject.next(fileState);
        this.setFileState(copiedId, fileState);
      }
      if (!cache.has(copiedId)) {
        getFileStreamsCache().set(copiedId, subject);
      }
      return copiedFile;
    } catch (error) {
      if (processingSubscription) {
        processingSubscription.unsubscribe();
      }
      if (replaceFileId) {
        const fileCache = cache.get(replaceFileId);
        const replaceFileState = this.store.getState().files[replaceFileId];
        if (fileCache) {
          fileCache.error(error);
        } else {
          // Create a new subject with the error state for new subscriptions
          cache.set(id, createMediaSubject(error));
        }
        const key = replaceFileState ? replaceFileId : id;
        const errorFileState = this.getErrorFileState(error, id, occurrenceKey);
        this.setFileState(key, errorFileState);
      }
      throw error;
    }
  }
}