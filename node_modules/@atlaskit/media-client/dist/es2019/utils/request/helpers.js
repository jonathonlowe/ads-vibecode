import { isClientBasedAuth } from '@atlaskit/media-core';
import { getRandomHex } from '@atlaskit/media-common';
import { mapAuthToQueryParameters } from '../../models/auth-query-parameters';
import { RequestError, isRequestError } from './errors';
const getStatusCode = error => {
  var _error$metadata;
  return isRequestError(error) && ((_error$metadata = error.metadata) === null || _error$metadata === void 0 ? void 0 : _error$metadata.statusCode) && error.metadata.statusCode;
};
export function waitPromise(timeout) {
  return new Promise(resolve => setTimeout(resolve, timeout));
}
export function isAbortedRequestError(err) {
  return err instanceof Error && err.message === 'request_cancelled' || !!err && err.name === 'AbortError';
}

// fetch throws TypeError for network errors
export function isFetchNetworkError(err) {
  return err instanceof TypeError;
}
export function isRateLimitedError(error) {
  const statusCode = error && getStatusCode(error);
  return statusCode === 429 || !!error && !!error.message && error.message.includes('429');
}
export const extendTraceContext = traceContext => traceContext ? {
  ...traceContext,
  spanId: (traceContext === null || traceContext === void 0 ? void 0 : traceContext.spanId) || getRandomHex(8)
} : undefined;
export const ZipkinHeaderKeys = {
  traceId: 'x-b3-traceid',
  spanId: 'x-b3-spanid',
  parentSpanId: 'x-b3-parentspanid',
  sampled: 'x-b3-sampled',
  flags: 'x-b3-flags'
};
const mapTraceIdToRequestHeaders = traceContext => {
  return traceContext ? {
    [ZipkinHeaderKeys.traceId]: traceContext.traceId,
    [ZipkinHeaderKeys.spanId]: traceContext.spanId
  } : {};
};
export function mapAuthToRequestHeaders(auth) {
  if (!auth) {
    return {};
  }
  if (isClientBasedAuth(auth)) {
    return {
      'X-Client-Id': auth.clientId,
      Authorization: `Bearer ${auth.token}`
    };
  }
  return {
    'X-Issuer': auth.asapIssuer,
    Authorization: `Bearer ${auth.token}`
  };
}
export function createUrl(url, {
  params,
  auth
}) {
  const parsedUrl = new URL(url, auth === null || auth === void 0 ? void 0 : auth.baseUrl);
  const authParams = auth && mapAuthToQueryParameters(auth) || {};
  const paramsToAppend = {
    ...params,
    ...authParams
  };
  Object.entries(paramsToAppend).filter(([_, value]) => value != null).forEach(pair => {
    parsedUrl.searchParams.append(...pair);
  });
  parsedUrl.searchParams.sort();
  return parsedUrl.toString();
}
export function extendHeaders(headers, auth, traceContext) {
  if (!auth && !traceContext && !headers) {
    return undefined;
  }
  return {
    ...(headers !== null && headers !== void 0 ? headers : {}),
    ...mapAuthToRequestHeaders(auth),
    ...mapTraceIdToRequestHeaders(traceContext)
  };
}
export function createMapResponseToJson(metadata) {
  return async response => {
    try {
      return await response.json();
    } catch (err) {
      throw new RequestError('serverInvalidBody', {
        ...metadata,
        ...extractMediaHeaders(response),
        statusCode: response.status
      }, err instanceof Error ? err : undefined);
    }
  };
}
export function createMapResponseToBlob(metadata) {
  return async response => {
    try {
      return await response.blob();
    } catch (err) {
      throw new RequestError('serverInvalidBody', {
        ...metadata,
        ...extractMediaHeaders(response),
        statusCode: response.status
      }, err instanceof Error ? err : undefined);
    }
  };
}
export const defaultShouldRetryError = err => {
  const statusCode = getStatusCode(err);
  return isFetchNetworkError(err) || (statusCode ? statusCode >= 500 : false);
};
export const DEFAULT_RETRY_OPTIONS = {
  startTimeoutInMs: 1000,
  // 1 second is generally a good timeout to start
  maxAttempts: 5,
  // Current test delay is 60s, so retries should finish before if a promise takes < 1s
  factor: 2 // Good for polling, which is out main use case
};
export function cloneRequestError(error, extraMetadata) {
  const {
    reason,
    metadata,
    innerError
  } = error;
  return new RequestError(reason, {
    ...metadata,
    ...extraMetadata
  }, innerError);
}
export async function fetchRetry(functionToRetry, metadata, overwriteOptions = {}) {
  const options = {
    ...DEFAULT_RETRY_OPTIONS,
    ...overwriteOptions
  };
  const {
    startTimeoutInMs,
    maxAttempts,
    factor,
    shouldRetryError = defaultShouldRetryError
  } = options;
  let attempts = 0;
  let timeoutInMs = startTimeoutInMs;
  let lastError;
  const waitAndBumpTimeout = async () => {
    await waitPromise(timeoutInMs);
    timeoutInMs *= factor;
    attempts += 1;
  };
  while (attempts < maxAttempts) {
    try {
      return await functionToRetry();
    } catch (err) {
      lastError = err;

      // don't retry if request was aborted by user
      if (isAbortedRequestError(err)) {
        throw new RequestError('clientAbortedRequest', metadata, err);
      }
      if (!shouldRetryError(err)) {
        throw err;
      }
      await waitAndBumpTimeout();
    }
  }
  if (isRequestError(lastError)) {
    throw cloneRequestError(lastError, {
      attempts,
      clientExhaustedRetries: true
    });
  }
  throw new RequestError('serverUnexpectedError', {
    ...metadata,
    attempts,
    clientExhaustedRetries: true
  }, lastError);
}
export function createRequestErrorReason(statusCode) {
  switch (statusCode) {
    case 400:
      return 'serverBadRequest';
    case 401:
      return 'serverUnauthorized';
    case 403:
      return 'serverForbidden';
    case 404:
      return 'serverNotFound';
    case 429:
      return 'serverRateLimited';
    case 500:
      return 'serverInternalError';
    case 502:
      return 'serverBadGateway';
    default:
      return 'serverUnexpectedError';
  }
}
export function createRequestErrorFromResponse(metadata, response) {
  const {
    status: statusCode
  } = response;
  const reason = createRequestErrorReason(statusCode);
  return new RequestError(reason, {
    ...metadata,
    ...extractMediaHeaders(response),
    statusCode
  });
}
export function createProcessFetchResponse(metadata) {
  return response => {
    if (response.ok || response.status < 400) {
      return response;
    }
    const requestError = createRequestErrorFromResponse(metadata, response);
    throw requestError;
  };
}
export function extractMediaHeaders(response) {
  const {
    headers
  } = response;
  const mediaRegion = headers.get('x-media-region') || 'unknown';
  const mediaEnv = headers.get('x-media-env') || 'unknown';
  return {
    mediaRegion,
    mediaEnv
  };
}