import Dataloader from 'dataloader';
import { getRandomHex } from '@atlaskit/media-common';
export const MAX_BATCH_SIZE = 100;
/**
 * Returns a function that, given Array<DataloaderKey>, resolves to an array of same length containing either DataloaderResult or Error.
 * Such contract is formalised by Dataloader 1.0, @see https://github.com/graphql/dataloader
 *
 * If an Error is resolved in the results, it must be at same position then their corresponding key:
 * - Dataloader will re-throw that Error when accessing/loading that particular key
 *
 * @param mediaStore instance of MediaStore
 */
function createBatchCopyIntentRegisterationFunc(mediaStore) {
  return async keys => {
    const keysByToken = keys.reduce((acc, key) => {
      const token = key.resolvedAuth.token;
      acc[token] = acc[token] || [];

      // de-duplicate ids in collection
      const hasDuplicates = acc[token].some(({
        id,
        collectionName
      }) => key.id === id && collectionName === key.collectionName);
      if (!hasDuplicates) {
        acc[token].push(key);
      }
      return acc;
    }, {});
    const items = [];
    await Promise.all(Object.keys(keysByToken).map(async batchKey => {
      const metadataTraceContext = {
        traceId: getRandomHex(8),
        spanId: getRandomHex(8)
      };
      const files = keysByToken[batchKey].map(key => ({
        id: key.id,
        collection: key.collectionName
      }));

      // given these are batched by the token the assumption is that they have the same details.
      const resolvedAuth = keysByToken[batchKey][0].resolvedAuth;
      try {
        await mediaStore.registerCopyIntents(files, metadataTraceContext, resolvedAuth);
      } catch (error) {
        files.forEach(({
          id,
          collection
        }) => {
          items.push({
            id,
            collection,
            error: error
          });
        });
      }
    }));
    return keys.map(({
      id,
      collectionName
    }) => {
      var _items$find;
      return (_items$find = items.find(item => item.id === id && item.collection === collectionName)) === null || _items$find === void 0 ? void 0 : _items$find.error;
    });
  };
}
export function createCopyIntentRegisterationBatcher(mediaStore) {
  return new Dataloader(createBatchCopyIntentRegisterationFunc(mediaStore), {
    maxBatchSize: MAX_BATCH_SIZE,
    cacheKeyFn: ({
      id,
      collectionName = 'default',
      resolvedAuth
    }) => `${id}-${collectionName}-${resolvedAuth.token}`
  });
}