import Dataloader from 'dataloader';
import { type MediaStore, type ResponseFileItem, type EmptyResponseFileItem } from '../client/media-store';
import { type NotFoundMediaItemDetails, type MediaItemDetails } from '../models/media';
export declare const MAX_BATCH_SIZE = 100;
export type DataloaderKey = {
    readonly id: string;
    readonly collectionName?: string;
    readonly includeHashForDuplicateFiles?: boolean;
};
export type DataloaderResult = MediaItemDetails | NotFoundMediaItemDetails;
export type BatchLoadingErrorResult = {
    readonly id: string;
    readonly collection?: string;
    readonly error: Error;
};
export declare const getItemsFromKeys: (dataloaderKeys: ReadonlyArray<DataloaderKey>, fileItems: Array<ResponseFileItem | BatchLoadingErrorResult | EmptyResponseFileItem>) => Array<DataloaderResult | Error>;
export type FileIdsByCollection = {
    [collectionName: string]: string[];
};
/**
 * Returns a function that, given Array<DataloaderKey>, resolves to an array of same length containing either DataloaderResult or Error.
 * Such contract is formalised by Dataloader 1.0, @see https://github.com/graphql/dataloader
 *
 * If an Error is resolved in the results, it must be at same position then their corresponding key:
 * - Dataloader will re-throw that Error when accessing/loading that particular key
 *
 * @param mediaStore instance of MediaStore
 */
export declare function createBatchLoadingFunc(mediaStore: MediaStore): (keys: ReadonlyArray<DataloaderKey>) => Promise<Array<DataloaderResult | Error>>;
export declare function createFileDataloader(mediaStore: MediaStore): Dataloader<DataloaderKey, DataloaderResult, DataloaderKey>;
