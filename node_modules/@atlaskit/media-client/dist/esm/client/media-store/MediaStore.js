import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { isClientBasedAuth } from '@atlaskit/media-core';
import { FILE_CACHE_MAX_AGE, MAX_RESOLUTION } from '../../constants';
import { getArtifactUrl } from '../../models/artifacts';
import { isRequestError, request as _request } from '../../utils/request';
import { createUrl, createMapResponseToJson, createMapResponseToBlob, defaultShouldRetryError, extendTraceContext } from '../../utils/request/helpers';
import { mapToMediaCdnUrl } from '../../utils/mediaCdn';
import { resolveAuth, resolveInitialAuth } from './resolveAuth';
import { ChunkHashAlgorithm } from '@atlaskit/media-core';
import { fg } from '@atlaskit/platform-feature-flags';
import { isCommercial } from '../../utils/isCommercial';
var MEDIA_API_REGION = 'media-api-region';
var MEDIA_API_ENVIRONMENT = 'media-api-environment';
var extendImageParams = function extendImageParams(params) {
  var _params$maxAge, _params$allowAnimated, _params$mode;
  var fetchMaxRes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return _objectSpread(_objectSpread({}, params), {}, {
    'max-age': (_params$maxAge = params === null || params === void 0 ? void 0 : params['max-age']) !== null && _params$maxAge !== void 0 ? _params$maxAge : FILE_CACHE_MAX_AGE,
    allowAnimated: (_params$allowAnimated = params === null || params === void 0 ? void 0 : params.allowAnimated) !== null && _params$allowAnimated !== void 0 ? _params$allowAnimated : true,
    mode: (_params$mode = params === null || params === void 0 ? void 0 : params.mode) !== null && _params$mode !== void 0 ? _params$mode : 'crop'
  }, fetchMaxRes ? {
    width: MAX_RESOLUTION,
    height: MAX_RESOLUTION
  } : {});
};
var jsonHeaders = {
  Accept: 'application/json',
  'Content-Type': 'application/json'
};
var cdnFeatureFlag = function cdnFeatureFlag(endpoint) {
  var result = endpoint;
  if (fg('platform_media_cdn_delivery')) {
    if (isCommercial()) {
      result += '/cdn';
    }
  }
  return result;
};
export var MediaStore = /*#__PURE__*/function () {
  function MediaStore(config) {
    var _this = this;
    _classCallCheck(this, MediaStore);
    _defineProperty(this, "resolveAuth", function (authContext) {
      return resolveAuth(_this.config.authProvider, authContext, _this.config.authProviderTimeout);
    });
    _defineProperty(this, "resolveInitialAuth", function () {
      return resolveInitialAuth(_this.config.initialAuth);
    });
    this.config = config;
    this._chunkHashAlgorithm = config.chunkHashAlgorithm || ChunkHashAlgorithm.Sha1;
  }
  return _createClass(MediaStore, [{
    key: "removeCollectionFile",
    value: function () {
      var _removeCollectionFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id, collectionName, occurrenceKey, traceContext) {
        var metadata, body, options;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              metadata = {
                method: 'PUT',
                endpoint: '/collection/{collectionName}'
              };
              body = {
                actions: [{
                  action: 'remove',
                  item: {
                    type: 'file',
                    id: id,
                    occurrenceKey: occurrenceKey
                  }
                }]
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: collectionName
                },
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body),
                traceContext: traceContext
              });
              _context.next = 5;
              return this.request("/collection/".concat(collectionName), options);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function removeCollectionFile(_x, _x2, _x3, _x4) {
        return _removeCollectionFile.apply(this, arguments);
      }
      return removeCollectionFile;
    }()
  }, {
    key: "createUpload",
    value: function createUpload() {
      var createUpTo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var collectionName = arguments.length > 1 ? arguments[1] : undefined;
      var traceContext = arguments.length > 2 ? arguments[2] : undefined;
      var metadata = {
        method: 'POST',
        endpoint: '/upload'
      };
      var options = _objectSpread(_objectSpread({}, metadata), {}, {
        authContext: {
          collectionName: collectionName
        },
        params: {
          createUpTo: createUpTo,
          hashAlgorithm: this._chunkHashAlgorithm
        },
        headers: {
          Accept: 'application/json'
        },
        traceContext: traceContext
      });
      return this.request("/upload", options).then(createMapResponseToJson(metadata));
    }
  }, {
    key: "uploadChunk",
    value: function () {
      var _uploadChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(etag, blob, uploadId, partNumber, collectionName, traceContext) {
        var metadata, options;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              metadata = {
                method: 'PUT',
                endpoint: '/chunk/{etag}'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                params: {
                  uploadId: uploadId,
                  partNumber: partNumber
                },
                authContext: {
                  collectionName: collectionName
                },
                body: blob,
                traceContext: traceContext
              });
              _context2.next = 4;
              return this.request("/chunk/".concat(etag), options);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function uploadChunk(_x5, _x6, _x7, _x8, _x9, _x10) {
        return _uploadChunk.apply(this, arguments);
      }
      return uploadChunk;
    }()
  }, {
    key: "createFileFromUpload",
    value: function createFileFromUpload(body) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var traceContext = arguments.length > 2 ? arguments[2] : undefined;
      var metadata = {
        method: 'POST',
        endpoint: '/file/upload'
      };
      var options = _objectSpread(_objectSpread({}, metadata), {}, {
        authContext: {
          collectionName: params.collection
        },
        params: params,
        headers: jsonHeaders,
        body: JSON.stringify(body),
        traceContext: traceContext
      });
      return this.request('/file/upload', options).then(createMapResponseToJson(metadata));
    }
  }, {
    key: "getRejectedResponseFromDescriptor",
    value: function getRejectedResponseFromDescriptor(descriptor, limit) {
      return {
        fileId: descriptor.fileId,
        error: {
          code: 'ExceedMaxFileSizeLimit',
          title: 'The expected file size exceeded the maximum size limit.',
          href: 'https://dt-api-filestore--app.ap-southeast-2.dev.atl-paas.net/api.html#BadRequest',
          limit: limit,
          size: descriptor.size
        }
      };
    }
  }, {
    key: "touchFiles",
    value: function () {
      var _touchFiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(body) {
        var params,
          traceContext,
          metadata,
          options,
          _args3 = arguments;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              params = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              traceContext = _args3.length > 2 ? _args3[2] : undefined;
              metadata = {
                method: 'POST',
                endpoint: '/upload/createWithFiles'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: params.collection
                },
                headers: jsonHeaders,
                body: JSON.stringify(body),
                traceContext: traceContext,
                params: {
                  hashAlgorithm: this._chunkHashAlgorithm
                }
              });
              return _context3.abrupt("return", this.request('/upload/createWithFiles', options).then(createMapResponseToJson(metadata)));
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function touchFiles(_x11) {
        return _touchFiles.apply(this, arguments);
      }
      return touchFiles;
    }()
  }, {
    key: "getFile",
    value: function getFile(fileId) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var traceContext = arguments.length > 2 ? arguments[2] : undefined;
      var metadata = {
        method: 'GET',
        endpoint: '/file/{fileId}'
      };
      var options = _objectSpread(_objectSpread({}, metadata), {}, {
        authContext: {
          collectionName: params.collection
        },
        params: params,
        traceContext: traceContext
      });
      return this.request("/file/".concat(fileId), options).then(createMapResponseToJson(metadata));
    }
  }, {
    key: "getFileImageURL",
    value: function () {
      var _getFileImageURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id, params) {
        var _ref, collectionName, auth;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _ref = params || {}, collectionName = _ref.collection;
              _context4.next = 3;
              return this.resolveAuth({
                collectionName: collectionName
              });
            case 3:
              auth = _context4.sent;
              return _context4.abrupt("return", this.createFileImageURL(id, auth, params));
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getFileImageURL(_x12, _x13) {
        return _getFileImageURL.apply(this, arguments);
      }
      return getFileImageURL;
    }() // TODO Create ticket in case Trace Id can be supported through query params
  }, {
    key: "getFileImageURLSync",
    value: function getFileImageURLSync(id, params) {
      var auth = this.resolveInitialAuth();
      return this.createFileImageURL(id, auth, params);
    }
  }, {
    key: "createFileImageURL",
    value: function createFileImageURL(id, auth, params) {
      var options = {
        params: extendImageParams(params),
        auth: auth
      };
      var imageEndpoint = cdnFeatureFlag('image');
      return mapToMediaCdnUrl(createUrl("".concat(auth.baseUrl, "/file/").concat(id, "/").concat(imageEndpoint), options), auth.token);
    }
  }, {
    key: "getFileBinary",
    value: function () {
      var _getFileBinary = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id, collectionName, abortController) {
        var maxAge,
          headers,
          binaryEndpoint,
          metadata,
          options,
          _args5 = arguments;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              maxAge = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : FILE_CACHE_MAX_AGE;
              headers = {};
              binaryEndpoint = cdnFeatureFlag('binary');
              metadata = {
                method: 'GET',
                endpoint: "/file/{fileId}/".concat(binaryEndpoint)
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: collectionName
                },
                headers: headers,
                params: {
                  collection: collectionName,
                  'max-age': "".concat(maxAge)
                }
              });
              return _context5.abrupt("return", this.request("/file/".concat(id, "/").concat(binaryEndpoint), options, abortController, true).then(createMapResponseToBlob(metadata)));
            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getFileBinary(_x14, _x15, _x16) {
        return _getFileBinary.apply(this, arguments);
      }
      return getFileBinary;
    }()
  }, {
    key: "getFileBinaryURL",
    value: function () {
      var _getFileBinaryURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(id, collectionName) {
        var maxAge,
          auth,
          options,
          binaryEndpoint,
          _args6 = arguments;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              maxAge = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : FILE_CACHE_MAX_AGE;
              _context6.next = 3;
              return this.resolveAuth({
                collectionName: collectionName
              });
            case 3:
              auth = _context6.sent;
              options = {
                params: {
                  dl: true,
                  collection: collectionName,
                  'max-age': maxAge
                },
                auth: auth
              };
              binaryEndpoint = cdnFeatureFlag('binary');
              return _context6.abrupt("return", mapToMediaCdnUrl(createUrl("".concat(auth.baseUrl, "/file/").concat(id, "/").concat(binaryEndpoint), options), auth.token));
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getFileBinaryURL(_x17, _x18) {
        return _getFileBinaryURL.apply(this, arguments);
      }
      return getFileBinaryURL;
    }()
  }, {
    key: "getArtifactURL",
    value: function () {
      var _getArtifactURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(artifacts, artifactName, collectionName) {
        var artifactUrl, auth, options;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              artifactUrl = getArtifactUrl(artifacts, artifactName);
              if (artifactUrl) {
                _context7.next = 3;
                break;
              }
              throw new Error("artifact ".concat(artifactName, " not found"));
            case 3:
              _context7.next = 5;
              return this.resolveAuth({
                collectionName: collectionName
              });
            case 5:
              auth = _context7.sent;
              options = {
                params: {
                  collection: collectionName,
                  'max-age': FILE_CACHE_MAX_AGE
                },
                auth: auth
              };
              return _context7.abrupt("return", createUrl(mapToMediaCdnUrl(artifactUrl, auth.token), options));
            case 8:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getArtifactURL(_x19, _x20, _x21) {
        return _getArtifactURL.apply(this, arguments);
      }
      return getArtifactURL;
    }()
  }, {
    key: "getImage",
    value: function () {
      var _getImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(id, params, controller, fetchMaxRes, traceContext) {
        var isWebpSupported, headers, imageEndpoint, metadata, options;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              // TODO add checkWebpSupport() back https://product-fabric.atlassian.net/browse/MPT-584
              isWebpSupported = false;
              headers = {};
              if (isWebpSupported) {
                headers.accept = 'image/webp,image/*,*/*;q=0.8';
              }
              imageEndpoint = cdnFeatureFlag('image');
              metadata = {
                method: 'GET',
                endpoint: "/file/{fileId}/".concat(imageEndpoint)
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: params && params.collection
                },
                params: extendImageParams(params, fetchMaxRes),
                headers: headers,
                traceContext: traceContext,
                addMediaClientParam: true
              });
              return _context8.abrupt("return", this.request("/file/".concat(id, "/").concat(imageEndpoint), options, controller, true).then(createMapResponseToBlob(metadata)));
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getImage(_x22, _x23, _x24, _x25, _x26) {
        return _getImage.apply(this, arguments);
      }
      return getImage;
    }()
  }, {
    key: "getItems",
    value: function () {
      var _getItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(ids, collectionName, traceContext, includeHashForDuplicateFiles) {
        var descriptors, metadata, options;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              descriptors = ids.map(function (id) {
                return {
                  type: 'file',
                  id: id,
                  collection: collectionName
                };
              });
              metadata = {
                method: 'POST',
                endpoint: '/items'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: collectionName
                },
                headers: jsonHeaders,
                body: JSON.stringify({
                  descriptors: descriptors,
                  includeHashForDuplicateFiles: includeHashForDuplicateFiles
                }),
                traceContext: traceContext
              });
              return _context9.abrupt("return", this.request('/items', options).then(createMapResponseToJson(metadata)));
            case 4:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getItems(_x27, _x28, _x29, _x30) {
        return _getItems.apply(this, arguments);
      }
      return getItems;
    }()
  }, {
    key: "getImageMetadata",
    value: function () {
      var _getImageMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(id, params, traceContext) {
        var metadata, options;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              metadata = {
                method: 'GET',
                endpoint: '/file/{fileId}/image/metadata'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: params && params.collection
                },
                params: params,
                traceContext: traceContext
              });
              return _context10.abrupt("return", this.request("/file/".concat(id, "/image/metadata"), options).then(createMapResponseToJson(metadata)));
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getImageMetadata(_x31, _x32, _x33) {
        return _getImageMetadata.apply(this, arguments);
      }
      return getImageMetadata;
    }()
  }, {
    key: "appendChunksToUpload",
    value: function () {
      var _appendChunksToUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(uploadId, body, collectionName, traceContext) {
        var metadata, options;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              metadata = {
                method: 'PUT',
                endpoint: '/upload/{uploadId}/chunks'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                authContext: {
                  collectionName: collectionName
                },
                headers: jsonHeaders,
                body: JSON.stringify(body),
                traceContext: traceContext
              });
              _context11.next = 4;
              return this.request("/upload/".concat(uploadId, "/chunks"), options);
            case 4:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function appendChunksToUpload(_x34, _x35, _x36, _x37) {
        return _appendChunksToUpload.apply(this, arguments);
      }
      return appendChunksToUpload;
    }()
  }, {
    key: "copyFileWithToken",
    value: function copyFileWithToken(body, params, traceContext) {
      var metadata = {
        method: 'POST',
        endpoint: '/file/copy/withToken'
      };
      var options = _objectSpread(_objectSpread({}, metadata), {}, {
        authContext: {
          collectionName: params.collection
        },
        // Contains collection name to write to
        params: params,
        // Contains collection name to write to
        headers: jsonHeaders,
        body: JSON.stringify(body),
        // Contains collection name to read from
        traceContext: traceContext
      });
      return this.request('/file/copy/withToken', options).then(createMapResponseToJson(metadata));
    }
  }, {
    key: "copyFile",
    value: function copyFile(id, params, traceContext) {
      var metadata = {
        method: 'POST',
        endpoint: '/v2/file/copy'
      };
      var options = _objectSpread(_objectSpread({}, metadata), {}, {
        authContext: {
          collectionName: params.collection
        },
        params: params,
        headers: jsonHeaders,
        body: JSON.stringify({
          id: id
        }),
        traceContext: traceContext,
        clientOptions: {
          retryOptions: {
            shouldRetryError: function shouldRetryError(err) {
              var _err$metadata;
              return defaultShouldRetryError(err) || isRequestError(err) && (err === null || err === void 0 || (_err$metadata = err.metadata) === null || _err$metadata === void 0 ? void 0 : _err$metadata.statusCode) === 401;
            }
          }
        }
      });
      return this.request('/v2/file/copy', options).then(createMapResponseToJson(metadata));
    }
  }, {
    key: "registerCopyIntents",
    value: function () {
      var _registerCopyIntents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(files, traceContext, resolvedAuth) {
        var metadata, options;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              metadata = {
                method: 'POST',
                endpoint: '/file/copy/intents'
              };
              options = _objectSpread(_objectSpread({}, metadata), {}, {
                headers: jsonHeaders,
                body: JSON.stringify({
                  files: files
                }),
                traceContext: traceContext,
                resolvedAuth: resolvedAuth
              });
              _context12.next = 4;
              return this.request('/file/copy/intents', options);
            case 4:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function registerCopyIntents(_x38, _x39, _x40) {
        return _registerCopyIntents.apply(this, arguments);
      }
      return registerCopyIntents;
    }()
  }, {
    key: "request",
    value: function () {
      var _request2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(path) {
        var options,
          controller,
          useMediaCdn,
          method,
          endpoint,
          authContext,
          params,
          headers,
          body,
          clientOptions,
          traceContext,
          addMediaClientParam,
          resolvedAuth,
          auth,
          clientId,
          extendedTraceContext,
          extendedParams,
          url,
          response,
          _args13 = arguments;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {
                method: 'GET',
                endpoint: undefined,
                authContext: {}
              };
              controller = _args13.length > 2 ? _args13[2] : undefined;
              useMediaCdn = _args13.length > 3 ? _args13[3] : undefined;
              method = options.method, endpoint = options.endpoint, authContext = options.authContext, params = options.params, headers = options.headers, body = options.body, clientOptions = options.clientOptions, traceContext = options.traceContext, addMediaClientParam = options.addMediaClientParam, resolvedAuth = options.resolvedAuth;
              if (!(resolvedAuth !== null && resolvedAuth !== void 0)) {
                _context13.next = 8;
                break;
              }
              _context13.t0 = resolvedAuth;
              _context13.next = 11;
              break;
            case 8:
              _context13.next = 10;
              return this.resolveAuth(authContext);
            case 10:
              _context13.t0 = _context13.sent;
            case 11:
              auth = _context13.t0;
              clientId = isClientBasedAuth(auth) ? auth.clientId : undefined;
              extendedTraceContext = extendTraceContext(traceContext);
              extendedParams = addMediaClientParam ? _objectSpread(_objectSpread({}, params), {}, {
                clientId: clientId
              }) : params;
              url = "".concat(auth.baseUrl).concat(path);
              if (useMediaCdn) {
                url = mapToMediaCdnUrl(url, auth.token);
              }
              _context13.next = 19;
              return _request(url, {
                method: method,
                endpoint: endpoint,
                auth: auth,
                params: extendedParams,
                headers: headers,
                body: body,
                clientOptions: clientOptions,
                traceContext: extendedTraceContext
              }, controller);
            case 19:
              response = _context13.sent;
              setKeyValueInSessionStorage(MEDIA_API_REGION, response.headers.get('x-media-region'));
              setKeyValueInSessionStorage(MEDIA_API_ENVIRONMENT, response.headers.get('x-media-env'));
              return _context13.abrupt("return", response);
            case 23:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function request(_x41) {
        return _request2.apply(this, arguments);
      }
      return request;
    }()
  }, {
    key: "testUrl",
    value: function () {
      var _testUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(url) {
        var options,
          traceContext,
          _args14 = arguments;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
              traceContext = options.traceContext;
              _context14.next = 4;
              return _request(url, {
                method: 'HEAD',
                traceContext: extendTraceContext(traceContext),
                clientOptions: {
                  retryOptions: {
                    maxAttempts: 1
                  }
                }
              });
            case 4:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      function testUrl(_x42) {
        return _testUrl.apply(this, arguments);
      }
      return testUrl;
    }()
  }, {
    key: "chunkHashAlgorithm",
    get: function get() {
      return this._chunkHashAlgorithm;
    }
  }]);
}();
var getValueFromSessionStorage = function getValueFromSessionStorage(key) {
  return window && window.sessionStorage && window.sessionStorage.getItem(key) || undefined;
};
var setKeyValueInSessionStorage = function setKeyValueInSessionStorage(key, value) {
  if (!value || !(window && window.sessionStorage)) {
    return;
  }
  var currentValue = window.sessionStorage.getItem(key);
  if (currentValue !== value) {
    window.sessionStorage.setItem(key, value);
  }
};
export var getMediaEnvironment = function getMediaEnvironment() {
  return getValueFromSessionStorage(MEDIA_API_ENVIRONMENT);
};
export var getMediaRegion = function getMediaRegion() {
  return getValueFromSessionStorage(MEDIA_API_REGION);
};