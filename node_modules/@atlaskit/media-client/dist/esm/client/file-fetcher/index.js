import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { Subscription } from 'rxjs/Subscription';
import { map } from 'rxjs/operators/map';
import uuid from 'uuid/v4';
import { authToOwner } from '@atlaskit/media-core';
import { downloadUrl } from '@atlaskit/media-common/downloadUrl';
import { MediaStore as MediaApi } from '../media-store';
import { isErrorFileState, isFinalFileState, isProcessingFileState, mapMediaFileToFileState, mapMediaItemToFileState } from '../../models/file-state';
import { isNotFoundMediaItemDetails } from '../../models/media';
import { FileFetcherError } from './error';
import { uploadFile } from '../../uploader';
import { getFileStreamsCache } from '../../file-streams-cache';
import { globalMediaEventEmitter } from '../../globalMediaEventEmitter';
import { RECENTS_COLLECTION } from '../../constants';
import isValidId from 'uuid-validate';
import { createFileDataloader } from '../../utils/createFileDataLoader';
import { getMediaTypeFromUploadableFile } from '../../utils/getMediaTypeFromUploadableFile';
import { overrideMediaTypeIfUnknown } from '../../utils/overrideMediaTypeIfUnknown';
import { convertBase64ToBlob } from '../../utils/convertBase64ToBlob';
import { toPromise, fromObservable } from '../../utils/mediaSubscribable';
import { getDimensionsFromBlob } from '../../utils/getDimensionsFromBlob';
import { createMediaSubject } from '../../utils/createMediaSubject';
import { getMediaTypeFromMimeType } from '@atlaskit/media-common/mediaTypeUtils';
import { shouldFetchRemoteFileStates } from '../../utils/shouldFetchRemoteFileStates';
import { PollingFunction } from '../../utils/polling';
import { isEmptyFile } from '../../utils/detectEmptyFile';
import { mediaStore } from '@atlaskit/media-state';
import { createCopyIntentRegisterationBatcher } from '../../utils/createCopyIntentRegisterationBatcher';
import { defaultShouldRetryError } from '../../utils/request/helpers';
import { isCommonMediaClientError, CommonMediaClientError, fromCommonMediaClientError } from '../../models/errors';
export { isFileFetcherError, FileFetcherError } from './error';
var isCopySourceFileWithToken = function isCopySourceFileWithToken(token) {
  return !!token.authProvider;
};
var isCopyDestinationWithToken = function isCopyDestinationWithToken(token) {
  return !!token.authProvider;
};
export var FileFetcherImpl = /*#__PURE__*/function () {
  function FileFetcherImpl(mediaApi) {
    var _this = this;
    var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mediaStore;
    _classCallCheck(this, FileFetcherImpl);
    _defineProperty(this, "getErrorFileState", function (error, id, occurrenceKey) {
      if (isCommonMediaClientError(error)) {
        return fromCommonMediaClientError(id, occurrenceKey, error);
      }
      // ________________________________________________
      // Legacy serializers
      // We need to revisit all the incoming error types and ensure all the "reason" values are known
      // We need to change the input error: any for a known type.
      if (typeof error === 'string') {
        var err = new CommonMediaClientError(error);
        return fromCommonMediaClientError(id, occurrenceKey, err);
      } else {
        var _err = new CommonMediaClientError((error === null || error === void 0 ? void 0 : error.reason) || 'unknown', error === null || error === void 0 ? void 0 : error.metadata, error === null || error === void 0 ? void 0 : error.innerError);
        return fromCommonMediaClientError(id, occurrenceKey, _err);
      }
    });
    _defineProperty(this, "setFileState", function (id, fileState) {
      _this.store.setState(function (state) {
        state.files[id] = fileState;
      });
    });
    // TODO: ----- ADD TICKET TO PASS TRACE ID to this.dataloader.load
    _defineProperty(this, "createDownloadFileStream", function (id, collectionName, occurrenceKey, includeHashForDuplicateFiles, forceRefresh) {
      var subject = createMediaSubject();
      var poll = new PollingFunction();

      // ensure subject errors if polling exceeds max iterations or uncaught exception in executor
      poll.onError = function (error) {
        return subject.error(error);
      };
      poll.execute( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var response, fileState;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (forceRefresh) {
                _this.dataloader.clear({
                  id: id,
                  collectionName: collectionName,
                  includeHashForDuplicateFiles: includeHashForDuplicateFiles
                });
              }
              _context.next = 3;
              return _this.dataloader.load({
                id: id,
                collectionName: collectionName,
                includeHashForDuplicateFiles: includeHashForDuplicateFiles
              });
            case 3:
              response = _context.sent;
              if (!isNotFoundMediaItemDetails(response)) {
                _context.next = 6;
                break;
              }
              throw new FileFetcherError('emptyItems', {
                id: id,
                collectionName: collectionName,
                occurrenceKey: occurrenceKey,
                traceContext: response.metadataTraceContext
              });
            case 6:
              if (!isEmptyFile(response)) {
                _context.next = 8;
                break;
              }
              throw new FileFetcherError('zeroVersionFile', {
                id: id,
                collectionName: collectionName,
                occurrenceKey: occurrenceKey,
                traceContext: response.metadataTraceContext
              });
            case 8:
              fileState = mapMediaItemToFileState(id, response);
              subject.next(fileState);
              _context.t0 = fileState.status;
              _context.next = _context.t0 === 'processing' ? 13 : _context.t0 === 'processed' ? 15 : 17;
              break;
            case 13:
              // the only case for continuing polling, otherwise this function is run once only
              poll.next();
              return _context.abrupt("break", 17);
            case 15:
              subject.complete();
              return _context.abrupt("break", 17);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      return subject;
    });
    _defineProperty(this, "getUploadingFileStateBase", function (file, upfrontId) {
      // TODO: DO not modify the input parameter 'content' attribute
      if (typeof file.content === 'string') {
        file.content = convertBase64ToBlob(file.content);
      }
      var content = file.content,
        _file$name = file.name,
        name = _file$name === void 0 ? '' : _file$name;
      var id = upfrontId.id,
        occurrenceKey = upfrontId.occurrenceKey;
      var preview;
      // TODO [MSW-796]: get file size for base64
      var size = 0;
      var mimeType = '';
      if (content instanceof Blob) {
        size = content.size;
        mimeType = content.type;
        preview = {
          value: content,
          origin: 'local'
        };
      }
      var mediaType = getMediaTypeFromUploadableFile(file);
      return {
        id: id,
        occurrenceKey: occurrenceKey,
        name: name,
        size: size,
        mediaType: mediaType,
        mimeType: mimeType,
        preview: preview
      };
    });
    this.mediaApi = mediaApi;
    this.store = store;
    this.dataloader = createFileDataloader(mediaApi);
    this.copyIntentRegisterationBatcher = createCopyIntentRegisterationBatcher(mediaApi);
  }
  return _createClass(FileFetcherImpl, [{
    key: "getFileState",
    value: function getFileState(id) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var collectionName = options.collectionName,
        occurrenceKey = options.occurrenceKey,
        includeHashForDuplicateFiles = options.includeHashForDuplicateFiles,
        forceRefresh = options.forceRefresh;
      if (!isValidId(id)) {
        var subject = createMediaSubject();
        var err = new FileFetcherError('invalidFileId', {
          id: id,
          collectionName: collectionName,
          occurrenceKey: occurrenceKey
        });
        var errorFileState = this.getErrorFileState(err, id, occurrenceKey);
        subject.error(err);
        this.setFileState(id, errorFileState);
        return fromObservable(subject);
      }
      if (forceRefresh) {
        getFileStreamsCache().remove(id);
      }
      return fromObservable(getFileStreamsCache().getOrInsert(id, function () {
        var subject = _this2.createDownloadFileStream(id, collectionName, undefined, includeHashForDuplicateFiles, forceRefresh);
        subject.subscribe({
          next: function next(fileState) {
            _this2.setFileState(id, fileState);
          },
          error: function error(err) {
            var errorFileState = _this2.getErrorFileState(err, id, occurrenceKey);
            _this2.setFileState(id, errorFileState);
          }
        });
        return subject;
      }));
    }
  }, {
    key: "getCurrentState",
    value: function getCurrentState(id, options) {
      return toPromise(this.getFileState(id, options));
    }
  }, {
    key: "getArtifactURL",
    value: function getArtifactURL(artifacts, artifactName, collectionName) {
      return this.mediaApi.getArtifactURL(artifacts, artifactName, collectionName);
    }
  }, {
    key: "getFileBinaryURL",
    value: function getFileBinaryURL(id, collectionName, maxAge) {
      return this.mediaApi.getFileBinaryURL(id, collectionName, maxAge);
    }
  }, {
    key: "touchFiles",
    value: function touchFiles(descriptors, collection, traceContext) {
      return this.mediaApi.touchFiles({
        descriptors: descriptors
      }, {
        collection: collection
      }, traceContext).then(function (_ref2) {
        var data = _ref2.data;
        return data;
      });
    }
  }, {
    key: "generateUploadableFileUpfrontIds",
    value: function generateUploadableFileUpfrontIds(collection, traceContext) {
      var id = uuid();
      var occurrenceKey = uuid();
      var touchFileDescriptor = {
        fileId: id,
        occurrenceKey: occurrenceKey,
        collection: collection
      };
      var deferredUploadId = this.touchFiles([touchFileDescriptor], collection, traceContext).then(function (touchedFiles) {
        return touchedFiles.created[0].uploadId;
      });
      return {
        id: id,
        occurrenceKey: occurrenceKey,
        deferredUploadId: deferredUploadId
      };
    }
  }, {
    key: "uploadExternal",
    value: function () {
      var _uploadExternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url, collection, traceContext) {
        var _this3 = this;
        var uploadableFileUpfrontIds, id, occurrenceKey, subject, deferredBlob, preview, name, fileState;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              uploadableFileUpfrontIds = this.generateUploadableFileUpfrontIds(collection, traceContext);
              id = uploadableFileUpfrontIds.id, occurrenceKey = uploadableFileUpfrontIds.occurrenceKey;
              subject = createMediaSubject();
              deferredBlob = fetch(url).then(function (response) {
                return response.blob();
              }).catch(function () {
                return undefined;
              });
              preview = new Promise( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, reject) {
                  var blob;
                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return deferredBlob;
                      case 2:
                        blob = _context2.sent;
                        if (!blob) {
                          reject('Could not fetch the blob');
                        }
                        resolve({
                          value: blob,
                          origin: 'remote'
                        });
                      case 5:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }));
                return function (_x4, _x5) {
                  return _ref3.apply(this, arguments);
                };
              }());
              name = url.split('/').pop() || ''; // we create a initial fileState with the minimum info that we have at this point
              fileState = {
                status: 'processing',
                name: name,
                size: 0,
                mediaType: 'unknown',
                mimeType: '',
                id: id,
                occurrenceKey: occurrenceKey,
                preview: preview
              };
              subject.next(fileState);
              // we save it into the cache as soon as possible, in case someone subscribes
              getFileStreamsCache().set(id, subject);
              this.setFileState(id, fileState);
              return _context4.abrupt("return", new Promise( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(resolve, reject) {
                  var blob, type, size, file, mediaType, dimensions;
                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return deferredBlob;
                      case 2:
                        blob = _context3.sent;
                        if (blob) {
                          _context3.next = 5;
                          break;
                        }
                        return _context3.abrupt("return", reject('Could not download remote file'));
                      case 5:
                        type = blob.type, size = blob.size;
                        file = {
                          content: blob,
                          mimeType: type,
                          collection: collection,
                          name: name,
                          size: size
                        };
                        mediaType = getMediaTypeFromMimeType(type); // we emit a richer state after the blob is fetched
                        subject.next({
                          status: 'processing',
                          name: name,
                          size: size,
                          mediaType: mediaType,
                          mimeType: type,
                          id: id,
                          occurrenceKey: occurrenceKey,
                          preview: preview
                        });
                        // we don't want to wait for the file to be upload
                        _this3.upload(file, undefined, uploadableFileUpfrontIds, traceContext);
                        _context3.prev = 10;
                        _context3.next = 13;
                        return getDimensionsFromBlob(mediaType, blob);
                      case 13:
                        dimensions = _context3.sent;
                        _context3.next = 20;
                        break;
                      case 16:
                        _context3.prev = 16;
                        _context3.t0 = _context3["catch"](10);
                        reject(_context3.t0);
                        return _context3.abrupt("return");
                      case 20:
                        resolve({
                          dimensions: dimensions,
                          mimeType: type,
                          uploadableFileUpfrontIds: uploadableFileUpfrontIds
                        });
                      case 21:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[10, 16]]);
                }));
                return function (_x6, _x7) {
                  return _ref4.apply(this, arguments);
                };
              }()));
            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function uploadExternal(_x, _x2, _x3) {
        return _uploadExternal.apply(this, arguments);
      }
      return uploadExternal;
    }()
  }, {
    key: "upload",
    value: function upload(file, controller, uploadableFileUpfrontIds, traceContext) {
      var _this4 = this;
      var collection = file.collection;
      var upfrontId = uploadableFileUpfrontIds || this.generateUploadableFileUpfrontIds(collection, traceContext);
      var id = upfrontId.id,
        occurrenceKey = upfrontId.occurrenceKey;
      var stateBase = this.getUploadingFileStateBase(file, upfrontId);
      var subject = createMediaSubject();
      getFileStreamsCache().set(id, subject);
      var onProgress = function onProgress(progress) {
        var fileState = _objectSpread(_objectSpread({
          status: 'uploading'
        }, stateBase), {}, {
          progress: progress
        });
        subject.next(fileState);
        _this4.setFileState(id, fileState);
      };
      var processingSubscription = new Subscription();
      var onUploadFinish = function onUploadFinish(error) {
        if (error) {
          var errorFileState = _this4.getErrorFileState(error, id, occurrenceKey);
          _this4.setFileState(id, errorFileState);
          return subject.error(error);
        }
        processingSubscription = _this4.createDownloadFileStream(id, collection, occurrenceKey).pipe(map(function (remoteFileState) {
          return _objectSpread(_objectSpread(_objectSpread({}, stateBase), remoteFileState), overrideMediaTypeIfUnknown(remoteFileState, stateBase.mediaType));
        })).subscribe({
          next: function next(fileState) {
            subject.next(fileState);
            _this4.setFileState(id, fileState);
          },
          error: function error(err) {
            var errorFileState = _this4.getErrorFileState(err, id, occurrenceKey);
            subject.error(err);
            _this4.setFileState(id, errorFileState);
          },
          complete: subject.complete
        });
      };
      var _uploadFile = uploadFile(file, this.mediaApi, upfrontId, {
          onUploadFinish: onUploadFinish,
          onProgress: onProgress
        }, traceContext),
        cancel = _uploadFile.cancel;
      controller === null || controller === void 0 || controller.setAbort(function () {
        cancel();
        // TODO: filestate should turn to "Aborted" or something.
        // Consider canceling an upload that is already finished
        processingSubscription.unsubscribe();
      });

      // We should report progress asynchronously, since this is what consumer expects
      // (otherwise in newUploadService file-converting event will be emitted before files-added)
      setTimeout(onProgress, 0, 0);
      return fromObservable(subject);
    }
  }, {
    key: "downloadBinary",
    value: function () {
      var _downloadBinary = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id) {
        var name,
          collectionName,
          traceContext,
          url,
          _args5 = arguments;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              name = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 'download';
              collectionName = _args5.length > 2 ? _args5[2] : undefined;
              traceContext = _args5.length > 3 ? _args5[3] : undefined;
              _context5.next = 5;
              return this.mediaApi.getFileBinaryURL(id, collectionName);
            case 5:
              url = _context5.sent;
              downloadUrl(url, {
                name: name
              });
              globalMediaEventEmitter.emit('media-viewed', {
                fileId: id,
                isUserCollection: collectionName === RECENTS_COLLECTION,
                viewingLevel: 'download'
              });
              // Test the download after initiated the Browser process to catch any potential errors.
              _context5.next = 10;
              return this.mediaApi.testUrl(url, {
                traceContext: traceContext
              });
            case 10:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function downloadBinary(_x8) {
        return _downloadBinary.apply(this, arguments);
      }
      return downloadBinary;
    }()
  }, {
    key: "registerCopyIntent",
    value: function () {
      var _registerCopyIntent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(id, collectionName) {
        var auth, key, error;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.mediaApi.resolveAuth({
                collectionName: collectionName
              });
            case 2:
              auth = _context6.sent;
              key = {
                id: id,
                collectionName: collectionName,
                resolvedAuth: auth
              };
              _context6.next = 6;
              return this.copyIntentRegisterationBatcher.load(key);
            case 6:
              error = _context6.sent;
              if (!error) {
                _context6.next = 10;
                break;
              }
              // if the error is retryable then it should not be cached
              if (defaultShouldRetryError(error)) {
                this.copyIntentRegisterationBatcher.clear(key);
              }
              throw error;
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function registerCopyIntent(_x9, _x10) {
        return _registerCopyIntent.apply(this, arguments);
      }
      return registerCopyIntent;
    }()
  }, {
    key: "copyFileWithToken",
    value: function () {
      var _copyFileWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(source, destination, traceContext) {
        var authProvider, sourceCollection, id, destinationAuthProvider, destinationCollectionName, replaceFileId, occurrenceKey, mediaStore, owner, body, params, _yield$mediaStore$cop, data;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              authProvider = source.authProvider, sourceCollection = source.collection, id = source.id;
              destinationAuthProvider = destination.authProvider, destinationCollectionName = destination.collection, replaceFileId = destination.replaceFileId, occurrenceKey = destination.occurrenceKey;
              mediaStore = destination.mediaStore || new MediaApi({
                authProvider: destinationAuthProvider
              });
              _context7.t0 = authToOwner;
              _context7.next = 6;
              return authProvider({
                collectionName: sourceCollection
              });
            case 6:
              _context7.t1 = _context7.sent;
              owner = (0, _context7.t0)(_context7.t1);
              body = {
                sourceFile: {
                  id: id,
                  collection: sourceCollection,
                  owner: owner
                }
              };
              params = {
                collection: destinationCollectionName,
                replaceFileId: replaceFileId,
                occurrenceKey: occurrenceKey
              };
              _context7.next = 12;
              return mediaStore.copyFileWithToken(body, params, traceContext);
            case 12:
              _yield$mediaStore$cop = _context7.sent;
              data = _yield$mediaStore$cop.data;
              return _context7.abrupt("return", data);
            case 15:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      function copyFileWithToken(_x11, _x12, _x13) {
        return _copyFileWithToken.apply(this, arguments);
      }
      return copyFileWithToken;
    }()
  }, {
    key: "copyFileWithIntent",
    value: function () {
      var _copyFileWithIntent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(source, destination, traceContext) {
        var res, data;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.mediaApi.copyFile(source.id, {
                sourceCollection: source.collection,
                collection: destination.collection,
                replaceFileId: destination.replaceFileId
              }, traceContext);
            case 2:
              res = _context8.sent;
              data = res.data;
              return _context8.abrupt("return", data);
            case 5:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function copyFileWithIntent(_x14, _x15, _x16) {
        return _copyFileWithIntent.apply(this, arguments);
      }
      return copyFileWithIntent;
    }()
  }, {
    key: "copyFile",
    value: function () {
      var _copyFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(source, destination) {
        var _this5 = this;
        var options,
          traceContext,
          id,
          destinationCollectionName,
          replaceFileId,
          occurrenceKey,
          preview,
          mimeType,
          cache,
          processingSubscription,
          copiedFile,
          copiedFileWithMimeType,
          copiedId,
          copiedMimeType,
          mediaType,
          copiedFileState,
          fileCache,
          subject,
          previewOverride,
          fileState,
          _fileState,
          _fileCache,
          replaceFileState,
          key,
          errorFileState,
          _args9 = arguments;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};
              traceContext = _args9.length > 3 ? _args9[3] : undefined;
              id = source.id;
              destinationCollectionName = destination.collection, replaceFileId = destination.replaceFileId, occurrenceKey = destination.occurrenceKey;
              preview = options.preview, mimeType = options.mimeType;
              cache = getFileStreamsCache();
              _context9.prev = 6;
              if (!(isCopySourceFileWithToken(source) && isCopyDestinationWithToken(destination))) {
                _context9.next = 13;
                break;
              }
              _context9.next = 10;
              return this.copyFileWithToken(source, destination, traceContext);
            case 10:
              copiedFile = _context9.sent;
              _context9.next = 16;
              break;
            case 13:
              _context9.next = 15;
              return this.copyFileWithIntent(source, destination, traceContext);
            case 15:
              copiedFile = _context9.sent;
            case 16:
              // if we were passed a "mimeType", we propagate it into copiedFileWithMimeType
              copiedFileWithMimeType = _objectSpread(_objectSpread({}, copiedFile), mimeType ? {
                mimeType: mimeType
              } : undefined);
              copiedId = copiedFileWithMimeType.id, copiedMimeType = copiedFileWithMimeType.mimeType; // backend may return an "unknown" mediaType just after the copy
              // it's better to deduce it from "copiedMimeType" using getMediaTypeFromMimeType()
              mediaType = copiedMimeType ? getMediaTypeFromMimeType(copiedMimeType) : 'unknown';
              copiedFileState = mapMediaFileToFileState({
                data: copiedFileWithMimeType
              });
              fileCache = cache.get(copiedId);
              subject = fileCache || createMediaSubject(); // if we were passed a "preview", we propagate it into the copiedFileState
              previewOverride = !isErrorFileState(copiedFileState) && !!preview ? {
                preview: preview
              } : {};
              _context9.t0 = !isFinalFileState(copiedFileState) &&
              // mimeType should always be returned by "copyFileWithToken"
              // but in case it's not, we don't want to penalize "copyFile"
              copiedMimeType;
              if (!_context9.t0) {
                _context9.next = 28;
                break;
              }
              _context9.next = 27;
              return shouldFetchRemoteFileStates(mediaType, copiedMimeType, preview);
            case 27:
              _context9.t0 = _context9.sent;
            case 28:
              if (!_context9.t0) {
                _context9.next = 35;
                break;
              }
              fileState = _objectSpread(_objectSpread(_objectSpread({}, copiedFileState), overrideMediaTypeIfUnknown(copiedFileState, mediaType)), previewOverride);
              subject.next(fileState);
              this.setFileState(copiedId, fileState);
              processingSubscription = this.createDownloadFileStream(copiedId, destinationCollectionName, occurrenceKey).subscribe({
                next: function next(remoteFileState) {
                  var fileState = _objectSpread(_objectSpread(_objectSpread({}, remoteFileState), overrideMediaTypeIfUnknown(remoteFileState, mediaType)), !isErrorFileState(remoteFileState) && previewOverride);
                  _this5.setFileState(copiedId, fileState);
                  return subject.next(fileState);
                },
                error: function error(err) {
                  var errorFileState = _this5.getErrorFileState(err, id, occurrenceKey);
                  _this5.setFileState(copiedId, errorFileState);
                  return subject.error(err);
                },
                complete: function complete() {
                  return subject.complete();
                }
              });
              _context9.next = 36;
              break;
            case 35:
              if (!isProcessingFileState(copiedFileState)) {
                _fileState = _objectSpread(_objectSpread({}, copiedFileState), !isErrorFileState(copiedFileState) && previewOverride);
                subject.next(_fileState);
                this.setFileState(copiedId, _fileState);
              }
            case 36:
              if (!cache.has(copiedId)) {
                getFileStreamsCache().set(copiedId, subject);
              }
              return _context9.abrupt("return", copiedFile);
            case 40:
              _context9.prev = 40;
              _context9.t1 = _context9["catch"](6);
              if (processingSubscription) {
                processingSubscription.unsubscribe();
              }
              if (replaceFileId) {
                _fileCache = cache.get(replaceFileId);
                replaceFileState = this.store.getState().files[replaceFileId];
                if (_fileCache) {
                  _fileCache.error(_context9.t1);
                } else {
                  // Create a new subject with the error state for new subscriptions
                  cache.set(id, createMediaSubject(_context9.t1));
                }
                key = replaceFileState ? replaceFileId : id;
                errorFileState = this.getErrorFileState(_context9.t1, id, occurrenceKey);
                this.setFileState(key, errorFileState);
              }
              throw _context9.t1;
            case 45:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[6, 40]]);
      }));
      function copyFile(_x17, _x18) {
        return _copyFile.apply(this, arguments);
      }
      return copyFile;
    }()
  }]);
}();