import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import Dataloader from 'dataloader';
import { getRandomHex } from '@atlaskit/media-common';
export var MAX_BATCH_SIZE = 100;
/**
 * Returns a function that, given Array<DataloaderKey>, resolves to an array of same length containing either DataloaderResult or Error.
 * Such contract is formalised by Dataloader 1.0, @see https://github.com/graphql/dataloader
 *
 * If an Error is resolved in the results, it must be at same position then their corresponding key:
 * - Dataloader will re-throw that Error when accessing/loading that particular key
 *
 * @param mediaStore instance of MediaStore
 */
function createBatchCopyIntentRegisterationFunc(mediaStore) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(keys) {
      var keysByToken, items;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            keysByToken = keys.reduce(function (acc, key) {
              var token = key.resolvedAuth.token;
              acc[token] = acc[token] || [];

              // de-duplicate ids in collection
              var hasDuplicates = acc[token].some(function (_ref2) {
                var id = _ref2.id,
                  collectionName = _ref2.collectionName;
                return key.id === id && collectionName === key.collectionName;
              });
              if (!hasDuplicates) {
                acc[token].push(key);
              }
              return acc;
            }, {});
            items = [];
            _context2.next = 4;
            return Promise.all(Object.keys(keysByToken).map( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(batchKey) {
                var metadataTraceContext, files, resolvedAuth;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      metadataTraceContext = {
                        traceId: getRandomHex(8),
                        spanId: getRandomHex(8)
                      };
                      files = keysByToken[batchKey].map(function (key) {
                        return {
                          id: key.id,
                          collection: key.collectionName
                        };
                      }); // given these are batched by the token the assumption is that they have the same details.
                      resolvedAuth = keysByToken[batchKey][0].resolvedAuth;
                      _context.prev = 3;
                      _context.next = 6;
                      return mediaStore.registerCopyIntents(files, metadataTraceContext, resolvedAuth);
                    case 6:
                      _context.next = 11;
                      break;
                    case 8:
                      _context.prev = 8;
                      _context.t0 = _context["catch"](3);
                      files.forEach(function (_ref4) {
                        var id = _ref4.id,
                          collection = _ref4.collection;
                        items.push({
                          id: id,
                          collection: collection,
                          error: _context.t0
                        });
                      });
                    case 11:
                    case "end":
                      return _context.stop();
                  }
                }, _callee, null, [[3, 8]]);
              }));
              return function (_x2) {
                return _ref3.apply(this, arguments);
              };
            }()));
          case 4:
            return _context2.abrupt("return", keys.map(function (_ref5) {
              var _items$find;
              var id = _ref5.id,
                collectionName = _ref5.collectionName;
              return (_items$find = items.find(function (item) {
                return item.id === id && item.collection === collectionName;
              })) === null || _items$find === void 0 ? void 0 : _items$find.error;
            }));
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
export function createCopyIntentRegisterationBatcher(mediaStore) {
  return new Dataloader(createBatchCopyIntentRegisterationFunc(mediaStore), {
    maxBatchSize: MAX_BATCH_SIZE,
    cacheKeyFn: function cacheKeyFn(_ref6) {
      var id = _ref6.id,
        _ref6$collectionName = _ref6.collectionName,
        collectionName = _ref6$collectionName === void 0 ? 'default' : _ref6$collectionName,
        resolvedAuth = _ref6.resolvedAuth;
      return "".concat(id, "-").concat(collectionName, "-").concat(resolvedAuth.token);
    }
  });
}