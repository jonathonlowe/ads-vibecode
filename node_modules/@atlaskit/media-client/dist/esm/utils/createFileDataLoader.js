import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import Dataloader from 'dataloader';
import { getRandomHex } from '@atlaskit/media-common';
export var MAX_BATCH_SIZE = 100;
var isBatchLoadingErrorResult = function isBatchLoadingErrorResult(result) {
  return result.error instanceof Error;
};
var isResponseFileItem = function isResponseFileItem(fileItem) {
  return 'details' in fileItem;
};
var makeCacheKey = function makeCacheKey(id, collection) {
  return collection ? "".concat(id, "-").concat(collection) : id;
};
export var getItemsFromKeys = function getItemsFromKeys(dataloaderKeys, fileItems) {
  var itemsByKey = fileItems.reduce(function (prev, fileItem) {
    var id = fileItem.id,
      collection = fileItem.collection;
    var key = makeCacheKey(id, collection);
    if (isBatchLoadingErrorResult(fileItem)) {
      prev[key] = fileItem.error;
    } else if (isResponseFileItem(fileItem)) {
      prev[key] = _objectSpread(_objectSpread({}, fileItem.details), {}, {
        metadataTraceContext: fileItem.metadataTraceContext
      });
    } else {
      prev[key] = {
        id: id,
        collection: collection,
        type: 'not-found',
        metadataTraceContext: fileItem.metadataTraceContext
      };
    }
    return prev;
  }, {});
  return dataloaderKeys.map(function (dataloaderKey) {
    var id = dataloaderKey.id,
      collectionName = dataloaderKey.collectionName;
    var key = makeCacheKey(id, collectionName);
    return itemsByKey[key] || {
      id: id,
      type: 'not-found'
    };
  });
};
/**
 * Returns a function that, given Array<DataloaderKey>, resolves to an array of same length containing either DataloaderResult or Error.
 * Such contract is formalised by Dataloader 1.0, @see https://github.com/graphql/dataloader
 *
 * If an Error is resolved in the results, it must be at same position then their corresponding key:
 * - Dataloader will re-throw that Error when accessing/loading that particular key
 *
 * @param mediaStore instance of MediaStore
 */
export function createBatchLoadingFunc(mediaStore) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(keys) {
      var nonCollectionName, includeHashByCollection, fileIdsByCollection, items;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            nonCollectionName = '__media-single-file-collection__';
            includeHashByCollection = keys.reduce(function (acc, key) {
              var collectionName = key.collectionName || nonCollectionName;
              if (key.includeHashForDuplicateFiles) {
                acc[collectionName] = key.includeHashForDuplicateFiles;
              }
              return acc;
            }, {});
            fileIdsByCollection = keys.reduce(function (acc, key) {
              var collectionName = key.collectionName || nonCollectionName;
              var fileIds = acc[collectionName] || [];

              // de-duplicate ids in collection
              if (fileIds.indexOf(key.id) === -1) {
                fileIds.push(key.id);
              }
              acc[collectionName] = fileIds;
              return acc;
            }, {});
            items = [];
            _context2.next = 6;
            return Promise.all(Object.keys(fileIdsByCollection).map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(collectionNameKey) {
                var metadataTraceContext, fileIds, includeHashForDuplicateFiles, collectionName, response, itemsWithMetadataTraceContext, itemsIds, fileIdsNotFound;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      metadataTraceContext = {
                        traceId: getRandomHex(8),
                        spanId: getRandomHex(8)
                      };
                      fileIds = fileIdsByCollection[collectionNameKey];
                      includeHashForDuplicateFiles = includeHashByCollection[collectionNameKey];
                      collectionName = collectionNameKey === nonCollectionName ? undefined : collectionNameKey;
                      _context.prev = 4;
                      _context.next = 7;
                      return mediaStore.getItems(fileIds, collectionName, metadataTraceContext, includeHashForDuplicateFiles);
                    case 7:
                      response = _context.sent;
                      itemsWithMetadataTraceContext = response.data.items.map(function (item) {
                        return _objectSpread(_objectSpread({}, item), {}, {
                          metadataTraceContext: metadataTraceContext
                        });
                      });
                      items.push.apply(items, _toConsumableArray(itemsWithMetadataTraceContext));

                      // add EmptyResponseFileItem for each file ID not included in /items response
                      itemsIds = itemsWithMetadataTraceContext.map(function (item) {
                        return item.id;
                      });
                      fileIdsNotFound = fileIds.filter(function (id) {
                        return !itemsIds.includes(id);
                      });
                      fileIdsNotFound.forEach(function (fileId) {
                        items.push({
                          id: fileId,
                          collection: collectionName,
                          type: 'not-found',
                          metadataTraceContext: metadataTraceContext
                        });
                      });
                      _context.next = 18;
                      break;
                    case 15:
                      _context.prev = 15;
                      _context.t0 = _context["catch"](4);
                      fileIds.forEach(function (fileId) {
                        items.push({
                          id: fileId,
                          collection: collectionName,
                          error: _context.t0
                        });
                      });
                    case 18:
                    case "end":
                      return _context.stop();
                  }
                }, _callee, null, [[4, 15]]);
              }));
              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }()));
          case 6:
            return _context2.abrupt("return", getItemsFromKeys(keys, items));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
export function createFileDataloader(mediaStore) {
  return new Dataloader(createBatchLoadingFunc(mediaStore), {
    maxBatchSize: MAX_BATCH_SIZE
  });
}