import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import uuidV4 from 'uuid/v4';
import Rusha from 'rusha';
export var WorkerHasher = /*#__PURE__*/function () {
  function WorkerHasher(numOfWorkers) {
    _classCallCheck(this, WorkerHasher);
    _defineProperty(this, "workers", []);
    _defineProperty(this, "jobs", {});
    for (var i = 0; i < numOfWorkers; ++i) {
      this.workers.push(this.createWorker());
    }
  }
  return _createClass(WorkerHasher, [{
    key: "hash",
    value: function hash(chunk) {
      return this.calculateHashInWorker(chunk);
    }
  }, {
    key: "createWorker",
    value: function createWorker() {
      var _this = this;
      var worker = Rusha.createWorker();
      var hasherWorker = {
        worker: worker,
        activeJobs: 0
      };
      worker.addEventListener('message', function (event) {
        _this.handleWorkerMessage(event, hasherWorker);
      });
      return hasherWorker;
    }
  }, {
    key: "handleWorkerMessage",
    value: function handleWorkerMessage(event, hasherWorker) {
      var id = event.data.id;
      if (this.jobs[id]) {
        var _this$jobs$id = this.jobs[id],
          resolve = _this$jobs$id.resolve,
          reject = _this$jobs$id.reject;
        delete this.jobs[id];
        hasherWorker.activeJobs--;
        if (event.data.error) {
          // TODO previously we were just calling it again.
          // this.calculateHashInWorker(chunk);
          reject(event.data.error);
        } else {
          resolve(event.data.hash);
        }
      }
    }
  }, {
    key: "calculateHashInWorker",
    value: function calculateHashInWorker(blob) {
      var _this2 = this;
      var jobId = uuidV4();
      return new Promise(function (resolve, reject) {
        _this2.jobs[jobId] = {
          resolve: resolve,
          reject: reject
        };
        var worker = _this2.getMostRelaxedWorker();
        _this2.dispatch(jobId, worker, blob);
      });
    }
  }, {
    key: "dispatch",
    value: function dispatch(jobId, hasherWorker, chunkBlob) {
      hasherWorker.activeJobs++;
      var worker = hasherWorker.worker;

      /*
       * postMessage() with chunk blob in Safari results in the error
       * "Failed to load resource: The operation could not be completed. (WebKitBlobResource error 1.)"
       *
       * To prevent it, we read the data from the blob using FileReader and pass it via postMessage to the worker.
       */
      if (navigator.userAgent.indexOf('Safari') > -1 && navigator.userAgent.indexOf('Chrome') === -1) {
        var rd = new FileReader();
        rd.onload = function () {
          worker.postMessage({
            id: jobId,
            data: rd.result
          });
        };
        rd.readAsBinaryString(chunkBlob);
        return;
      }
      worker.postMessage({
        id: jobId,
        data: chunkBlob
      });
    }
  }, {
    key: "getMostRelaxedWorker",
    value: function getMostRelaxedWorker() {
      return this.workers.reduce(function (current, next) {
        if (next.activeJobs < current.activeJobs) {
          return next;
        }
        return current;
      }, this.workers[0]);
    }
  }]);
}();