import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { map } from 'rxjs/operators/map';
import { createMachine, interpret } from 'xstate';
import { isProcessingFileState } from '../../../models/file-state';
import { shouldFetchRemoteFileStates as _shouldFetchRemoteFileStates } from '../../shouldFetchRemoteFileStates';
import { createMobileDownloadFileStream } from '../helpers';
import { machineUploadingState } from './states/uploading';
import { machineProcessingState } from './states/processing';
import { machineProcessedState } from './states/processed';
import { machineProcessingFailedState } from './states/processingFailed';
import { machineErrorState } from './states/error';
export var createMobileUploadStateMachine = function createMobileUploadStateMachine(dataloader, initialState, collectionName) {
  return createMachine({
    // Initial state
    initial: initialState.status,
    // Context
    context: {
      currentFileState: initialState
    },
    // State definitions
    states: {
      uploading: machineUploadingState,
      processing: machineProcessingState,
      processed: machineProcessedState,
      processingFailed: machineProcessingFailedState,
      error: machineErrorState
    }
  }, {
    services: {
      shouldFetchRemoteFileStates: function () {
        var _shouldFetchRemoteFileStates2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {
          var currentFileState, mediaType, mimeType, preview;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                currentFileState = ctx.currentFileState;
                if (!isProcessingFileState(currentFileState)) {
                  _context.next = 4;
                  break;
                }
                mediaType = currentFileState.mediaType, mimeType = currentFileState.mimeType, preview = currentFileState.preview;
                return _context.abrupt("return", _shouldFetchRemoteFileStates(mediaType, mimeType, preview));
              case 4:
                return _context.abrupt("return", false);
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function shouldFetchRemoteFileStates(_x) {
          return _shouldFetchRemoteFileStates2.apply(this, arguments);
        }
        return shouldFetchRemoteFileStates;
      }(),
      fetchRemoteFileStates: function fetchRemoteFileStates(ctx) {
        return createMobileDownloadFileStream(dataloader, ctx.currentFileState.id, collectionName, ctx.currentFileState.occurrenceKey).pipe(map(function (fileState) {
          return {
            type: 'REMOTE_FILESTATE_RESULT',
            fileState: fileState
          };
        }));
      }
    }
  });
};
export function createMobileUploadService(machine) {
  return interpret(machine);
}