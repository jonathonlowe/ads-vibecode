import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { isClientBasedAuth } from '@atlaskit/media-core';
import { getRandomHex } from '@atlaskit/media-common';
import { mapAuthToQueryParameters } from '../../models/auth-query-parameters';
import { RequestError, isRequestError } from './errors';
var getStatusCode = function getStatusCode(error) {
  var _error$metadata;
  return isRequestError(error) && ((_error$metadata = error.metadata) === null || _error$metadata === void 0 ? void 0 : _error$metadata.statusCode) && error.metadata.statusCode;
};
export function waitPromise(timeout) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, timeout);
  });
}
export function isAbortedRequestError(err) {
  return err instanceof Error && err.message === 'request_cancelled' || !!err && err.name === 'AbortError';
}

// fetch throws TypeError for network errors
export function isFetchNetworkError(err) {
  return err instanceof TypeError;
}
export function isRateLimitedError(error) {
  var statusCode = error && getStatusCode(error);
  return statusCode === 429 || !!error && !!error.message && error.message.includes('429');
}
export var extendTraceContext = function extendTraceContext(traceContext) {
  return traceContext ? _objectSpread(_objectSpread({}, traceContext), {}, {
    spanId: (traceContext === null || traceContext === void 0 ? void 0 : traceContext.spanId) || getRandomHex(8)
  }) : undefined;
};
export var ZipkinHeaderKeys = {
  traceId: 'x-b3-traceid',
  spanId: 'x-b3-spanid',
  parentSpanId: 'x-b3-parentspanid',
  sampled: 'x-b3-sampled',
  flags: 'x-b3-flags'
};
var mapTraceIdToRequestHeaders = function mapTraceIdToRequestHeaders(traceContext) {
  return traceContext ? _defineProperty(_defineProperty({}, ZipkinHeaderKeys.traceId, traceContext.traceId), ZipkinHeaderKeys.spanId, traceContext.spanId) : {};
};
export function mapAuthToRequestHeaders(auth) {
  if (!auth) {
    return {};
  }
  if (isClientBasedAuth(auth)) {
    return {
      'X-Client-Id': auth.clientId,
      Authorization: "Bearer ".concat(auth.token)
    };
  }
  return {
    'X-Issuer': auth.asapIssuer,
    Authorization: "Bearer ".concat(auth.token)
  };
}
export function createUrl(url, _ref2) {
  var params = _ref2.params,
    auth = _ref2.auth;
  var parsedUrl = new URL(url, auth === null || auth === void 0 ? void 0 : auth.baseUrl);
  var authParams = auth && mapAuthToQueryParameters(auth) || {};
  var paramsToAppend = _objectSpread(_objectSpread({}, params), authParams);
  Object.entries(paramsToAppend).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      _ = _ref4[0],
      value = _ref4[1];
    return value != null;
  }).forEach(function (pair) {
    var _parsedUrl$searchPara;
    (_parsedUrl$searchPara = parsedUrl.searchParams).append.apply(_parsedUrl$searchPara, _toConsumableArray(pair));
  });
  parsedUrl.searchParams.sort();
  return parsedUrl.toString();
}
export function extendHeaders(headers, auth, traceContext) {
  if (!auth && !traceContext && !headers) {
    return undefined;
  }
  return _objectSpread(_objectSpread(_objectSpread({}, headers !== null && headers !== void 0 ? headers : {}), mapAuthToRequestHeaders(auth)), mapTraceIdToRequestHeaders(traceContext));
}
export function createMapResponseToJson(metadata) {
  return /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(response) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return response.json();
          case 3:
            return _context.abrupt("return", _context.sent);
          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            throw new RequestError('serverInvalidBody', _objectSpread(_objectSpread(_objectSpread({}, metadata), extractMediaHeaders(response)), {}, {
              statusCode: response.status
            }), _context.t0 instanceof Error ? _context.t0 : undefined);
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 6]]);
    }));
    return function (_x) {
      return _ref5.apply(this, arguments);
    };
  }();
}
export function createMapResponseToBlob(metadata) {
  return /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(response) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return response.blob();
          case 3:
            return _context2.abrupt("return", _context2.sent);
          case 6:
            _context2.prev = 6;
            _context2.t0 = _context2["catch"](0);
            throw new RequestError('serverInvalidBody', _objectSpread(_objectSpread(_objectSpread({}, metadata), extractMediaHeaders(response)), {}, {
              statusCode: response.status
            }), _context2.t0 instanceof Error ? _context2.t0 : undefined);
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 6]]);
    }));
    return function (_x2) {
      return _ref6.apply(this, arguments);
    };
  }();
}
export var defaultShouldRetryError = function defaultShouldRetryError(err) {
  var statusCode = getStatusCode(err);
  return isFetchNetworkError(err) || (statusCode ? statusCode >= 500 : false);
};
export var DEFAULT_RETRY_OPTIONS = {
  startTimeoutInMs: 1000,
  // 1 second is generally a good timeout to start
  maxAttempts: 5,
  // Current test delay is 60s, so retries should finish before if a promise takes < 1s
  factor: 2 // Good for polling, which is out main use case
};
export function cloneRequestError(error, extraMetadata) {
  var reason = error.reason,
    metadata = error.metadata,
    innerError = error.innerError;
  return new RequestError(reason, _objectSpread(_objectSpread({}, metadata), extraMetadata), innerError);
}
export function fetchRetry(_x3, _x4) {
  return _fetchRetry.apply(this, arguments);
}
function _fetchRetry() {
  _fetchRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(functionToRetry, metadata) {
    var overwriteOptions,
      options,
      startTimeoutInMs,
      maxAttempts,
      factor,
      _options$shouldRetryE,
      shouldRetryError,
      attempts,
      timeoutInMs,
      lastError,
      waitAndBumpTimeout,
      _args4 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          overwriteOptions = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
          options = _objectSpread(_objectSpread({}, DEFAULT_RETRY_OPTIONS), overwriteOptions);
          startTimeoutInMs = options.startTimeoutInMs, maxAttempts = options.maxAttempts, factor = options.factor, _options$shouldRetryE = options.shouldRetryError, shouldRetryError = _options$shouldRetryE === void 0 ? defaultShouldRetryError : _options$shouldRetryE;
          attempts = 0;
          timeoutInMs = startTimeoutInMs;
          waitAndBumpTimeout = /*#__PURE__*/function () {
            var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
              return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return waitPromise(timeoutInMs);
                  case 2:
                    timeoutInMs *= factor;
                    attempts += 1;
                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }));
            return function waitAndBumpTimeout() {
              return _ref7.apply(this, arguments);
            };
          }();
        case 6:
          if (!(attempts < maxAttempts)) {
            _context4.next = 24;
            break;
          }
          _context4.prev = 7;
          _context4.next = 10;
          return functionToRetry();
        case 10:
          return _context4.abrupt("return", _context4.sent);
        case 13:
          _context4.prev = 13;
          _context4.t0 = _context4["catch"](7);
          lastError = _context4.t0;

          // don't retry if request was aborted by user
          if (!isAbortedRequestError(_context4.t0)) {
            _context4.next = 18;
            break;
          }
          throw new RequestError('clientAbortedRequest', metadata, _context4.t0);
        case 18:
          if (shouldRetryError(_context4.t0)) {
            _context4.next = 20;
            break;
          }
          throw _context4.t0;
        case 20:
          _context4.next = 22;
          return waitAndBumpTimeout();
        case 22:
          _context4.next = 6;
          break;
        case 24:
          if (!isRequestError(lastError)) {
            _context4.next = 26;
            break;
          }
          throw cloneRequestError(lastError, {
            attempts: attempts,
            clientExhaustedRetries: true
          });
        case 26:
          throw new RequestError('serverUnexpectedError', _objectSpread(_objectSpread({}, metadata), {}, {
            attempts: attempts,
            clientExhaustedRetries: true
          }), lastError);
        case 27:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[7, 13]]);
  }));
  return _fetchRetry.apply(this, arguments);
}
export function createRequestErrorReason(statusCode) {
  switch (statusCode) {
    case 400:
      return 'serverBadRequest';
    case 401:
      return 'serverUnauthorized';
    case 403:
      return 'serverForbidden';
    case 404:
      return 'serverNotFound';
    case 429:
      return 'serverRateLimited';
    case 500:
      return 'serverInternalError';
    case 502:
      return 'serverBadGateway';
    default:
      return 'serverUnexpectedError';
  }
}
export function createRequestErrorFromResponse(metadata, response) {
  var statusCode = response.status;
  var reason = createRequestErrorReason(statusCode);
  return new RequestError(reason, _objectSpread(_objectSpread(_objectSpread({}, metadata), extractMediaHeaders(response)), {}, {
    statusCode: statusCode
  }));
}
export function createProcessFetchResponse(metadata) {
  return function (response) {
    if (response.ok || response.status < 400) {
      return response;
    }
    var requestError = createRequestErrorFromResponse(metadata, response);
    throw requestError;
  };
}
export function extractMediaHeaders(response) {
  var headers = response.headers;
  var mediaRegion = headers.get('x-media-region') || 'unknown';
  var mediaEnv = headers.get('x-media-env') || 'unknown';
  return {
    mediaRegion: mediaRegion,
    mediaEnv: mediaEnv
  };
}