import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { roundEpsilon } from '../../../round-number';
import { withProfiling } from '../../../self-measurements';
var getPerformanceObject = function getPerformanceObject() {
  var _window;
  return ((_window = window) !== null && _window !== void 0 ? _window : {}).performance;
};
var getPerformanceObserverObject = function getPerformanceObserverObject() {
  var _window2;
  return ((_window2 = window) !== null && _window2 !== void 0 ? _window2 : {}).PerformanceObserver;
};
export var resourceTimingBuffer = {
  timings: [],
  maxSize: 1000,
  observer: null,
  transformResource: withProfiling(function transformResource(entry) {
    var _entry$serverTiming, _entry$serverTiming2;
    var duration = roundEpsilon(entry.duration);

    // prioritising atl-edge
    var totalBackendTimeEntry = ((_entry$serverTiming = entry.serverTiming) === null || _entry$serverTiming === void 0 ? void 0 : _entry$serverTiming.find(function (timing) {
      return timing.name === 'atl-edge';
    })) || ((_entry$serverTiming2 = entry.serverTiming) === null || _entry$serverTiming2 === void 0 ? void 0 : _entry$serverTiming2.find(
    // timing name should come from per-product config in the future
    function (timing) {
      return timing.name === 'total' || timing.name === 'filter-request-papi';
    }));
    var serverTime = totalBackendTimeEntry ? roundEpsilon(totalBackendTimeEntry.duration) : undefined;
    var networkTime = serverTime ? duration - serverTime : undefined;
    return {
      name: entry.name,
      initiatorType: entry.initiatorType,
      transferSize: entry.transferSize,
      startTime: roundEpsilon(entry.startTime),
      duration: roundEpsilon(entry.duration),
      fetchStart: roundEpsilon(entry.fetchStart || 0),
      workerStart: roundEpsilon(entry.workerStart || 0),
      responseStart: roundEpsilon(entry.responseStart || 0),
      requestStart: roundEpsilon(entry.requestStart || 0),
      serverTime: serverTime,
      networkTime: networkTime,
      encodedSize: roundEpsilon(entry.encodedBodySize),
      decodedSize: roundEpsilon(entry.decodedBodySize)
    };
  }),
  start: withProfiling(function start() {
    var _performance$getEntri;
    var performance = getPerformanceObject();
    var PerformanceObserver = getPerformanceObserverObject();
    if (!PerformanceObserver || !performance || typeof PerformanceObserver === 'undefined') {
      return;
    }
    if (resourceTimingBuffer.observer) {
      return;
    }
    var resources = (_performance$getEntri = performance.getEntriesByType) === null || _performance$getEntri === void 0 ? void 0 : _performance$getEntri.call(performance, 'resource');
    if (resources) {
      resourceTimingBuffer.timings = resources.map(function (resource) {
        return resourceTimingBuffer.transformResource(resource);
      });
    }
    resourceTimingBuffer.observer = new PerformanceObserver(resourceTimingBuffer.addTimings);
    resourceTimingBuffer.observer.observe({
      entryTypes: ['resource']
    });
  }),
  stop: withProfiling(function stop() {
    if (resourceTimingBuffer.observer) {
      resourceTimingBuffer.observer.disconnect();
      resourceTimingBuffer.observer = null;
    }
    resourceTimingBuffer.timings = [];
  }),
  addTimings: withProfiling(function addTimings(list) {
    var _resourceTimingBuffer;
    var entries = list.getEntries().map(function (entry) {
      return resourceTimingBuffer.transformResource(entry);
    });
    var overflow = resourceTimingBuffer.timings.length + entries.length;
    if (overflow > resourceTimingBuffer.maxSize) {
      var fieldsToRemove = overflow - resourceTimingBuffer.maxSize;
      resourceTimingBuffer.timings.splice(0, fieldsToRemove);
    }
    (_resourceTimingBuffer = resourceTimingBuffer.timings).push.apply(_resourceTimingBuffer, _toConsumableArray(entries));
  })
};
var isValidTiming = withProfiling(function isValidTiming(timing, startTime, endTime) {
  return timing.startTime >= startTime && timing.startTime + timing.duration <= endTime;
});
export var filterResourceTimings = withProfiling(function filterResourceTimings(startTime, endTime) {
  var performance = getPerformanceObject();
  var PerformanceObserver = getPerformanceObserverObject();
  if (!PerformanceObserver || !resourceTimingBuffer.observer) {
    var resources = performance === null || performance === void 0 ? void 0 : performance.getEntriesByType('resource');
    if (resources) {
      return resources.filter(function (timing) {
        return isValidTiming(timing, startTime, endTime);
      });
    }
    return null;
  }
  return resourceTimingBuffer.timings.filter(function (timing) {
    return isValidTiming(timing, startTime, endTime);
  });
});