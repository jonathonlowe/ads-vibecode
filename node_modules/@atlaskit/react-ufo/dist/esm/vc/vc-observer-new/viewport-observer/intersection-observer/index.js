import { withProfiling } from '../../../../self-measurements';
var isValidEntry = withProfiling(function isValidEntry(entry) {
  return entry.isIntersecting && entry.intersectionRect.width > 0 && entry.intersectionRect.height > 0;
}, ['vc']);
export function createIntersectionObserver(args) {
  if (!window || typeof window.IntersectionObserver !== 'function') {
    return null;
  }
  var onEntry = withProfiling(args.onEntry, ['vc']);
  var onObserved = typeof args.onObserved === 'function' ? withProfiling(args.onObserved, ['vc']) : undefined;
  var callbacksPerElement = new WeakMap();
  var intersectionObserverCallback = withProfiling(function intersectionObserverCallback(entries) {
    var validEntries = [];
    var startTime = performance.now();
    entries.forEach(function (entry) {
      if (!(entry.target instanceof HTMLElement) || !isValidEntry(entry)) {
        return;
      }
      var mutationTag = null;
      var mutationData = null;
      var tagOrCallback = callbacksPerElement.get(entry.target);
      if (typeof tagOrCallback === 'function') {
        var tagOrCallbackResult = tagOrCallback({
          target: entry.target,
          rect: entry.intersectionRect
        });
        if (!tagOrCallbackResult) {
          mutationTag = 'unknown';
        } else if (typeof tagOrCallbackResult === 'string') {
          mutationTag = tagOrCallbackResult;
        } else {
          mutationTag = tagOrCallbackResult.type;
          mutationData = tagOrCallbackResult.mutationData;
        }
      } else if (typeof tagOrCallback === 'string') {
        mutationTag = tagOrCallback;
      }
      onEntry({
        target: entry.target,
        rect: entry.intersectionRect,
        time: entry.time,
        type: mutationTag !== null && mutationTag !== void 0 ? mutationTag : 'unknown',
        mutationData: mutationData
      });
      validEntries.push(new WeakRef(entry.target));
      callbacksPerElement.delete(entry.target);
      observer.unobserve(entry.target);
    });
    onObserved === null || onObserved === void 0 || onObserved({
      time: startTime,
      elements: validEntries
    });
  });
  var observer = new IntersectionObserver(intersectionObserverCallback);
  return {
    disconnect: function disconnect() {
      observer.disconnect();
    },
    unobserve: function unobserve(target) {
      observer.unobserve(target);
    },
    watchAndTag: function watchAndTag(target, tagOrCallback) {
      callbacksPerElement.set(target, tagOrCallback);
      observer.observe(target);
    }
  };
}