import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { fg } from '@atlaskit/platform-feature-flags';
import { shouldHandleEditorLnv } from '../../../config';
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../../self-measurements';
import { isContainedWithinMediaWrapper } from '../media-wrapper/vc-utils';
import { EditorLnvHandler } from './editor-lnv';
import isNonVisualStyleMutation from './non-visual-styles/is-non-visual-style-mutation';
import { SSRPlaceholderHandlers } from './ssr-placeholders';
var state = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
var isElementVisible = withProfiling(function isElementVisible(target) {
  if (!target || typeof target.checkVisibility !== 'function') {
    return true;
  }
  var isVisible = target.checkVisibility({
    contentVisibilityAuto: true,
    opacityProperty: true,
    visibilityProperty: true
  });
  return isVisible;
}, ['vc']);
export var Observers = /*#__PURE__*/function () {
  function Observers(opts) {
    var _this = this;
    _classCallCheck(this, Observers);
    _defineProperty(this, "observedMutations", new WeakMap());
    _defineProperty(this, "elementsInView", new Set());
    _defineProperty(this, "callbacks", new Set());
    _defineProperty(this, "totalTime", 0);
    _defineProperty(this, "_startMeasureTimestamp", -1);
    _defineProperty(this, "ssr", {
      state: state.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    _defineProperty(this, "selectorConfig", {
      id: false,
      testId: false,
      role: false,
      className: true,
      dataVC: true
    });
    _defineProperty(this, "subscribeResults", function (cb) {
      _this.callbacks.add(cb);
    });
    _defineProperty(this, "observeElement", function (node, mutation, type, ignoreReason, attributeName) {
      var _this$intersectionObs;
      var oldValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var newValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      (_this$intersectionObs = _this.intersectionObserver) === null || _this$intersectionObs === void 0 || _this$intersectionObs.observe(node);
      if (fg('platform_ufo_log_attr_mutation_values')) {
        _this.observedMutations.set(node, {
          mutation: mutation,
          ignoreReason: ignoreReason,
          type: type,
          attributeName: attributeName,
          oldValue: oldValue,
          newValue: newValue
        });
      } else {
        _this.observedMutations.set(node, {
          mutation: mutation,
          ignoreReason: ignoreReason,
          type: type
        });
      }
    });
    var operationTimer = markProfilingStart('Observers constructor');
    this.selectorConfig = _objectSpread(_objectSpread({}, this.selectorConfig), opts.selectorConfig);
    this.intersectionObserver = this.getIntersectionObserver();
    this.mutationObserver = this.getMutationObserver();
    this.ssrPlaceholderHandler = new SSRPlaceholderHandlers();
    this.editorLnvHandler = new EditorLnvHandler();
    this.isBrowserSupported = withProfiling(this.isBrowserSupported.bind(this), ['vc']);
    this.observe = withProfiling(this.observe.bind(this), ['vc']);
    this.disconnect = withProfiling(this.disconnect.bind(this), ['vc']);
    this.subscribeResults = withProfiling(this.subscribeResults.bind(this), ['vc']);
    this.getTotalTime = withProfiling(this.getTotalTime.bind(this), ['vc']);
    this.setReactRootElement = withProfiling(this.setReactRootElement.bind(this), ['vc']);
    this.setReactRootRenderStart = withProfiling(this.setReactRootRenderStart.bind(this), ['vc']);
    this.setReactRootRenderStop = withProfiling(this.setReactRootRenderStop.bind(this), ['vc']);
    this.observeElement = withProfiling(this.observeElement.bind(this), ['vc']);
    this.getMutationObserver = withProfiling(this.getMutationObserver.bind(this), ['vc']);
    this.getElementName = withProfiling(this.getElementName.bind(this), ['vc']);
    this.getIntersectionObserver = withProfiling(this.getIntersectionObserver.bind(this), ['vc']);
    this.measureStart = withProfiling(this.measureStart.bind(this), ['vc']);
    this.measureStop = withProfiling(this.measureStop.bind(this), ['vc']);
    markProfilingEnd(operationTimer, {
      tags: ['vc']
    });
  }
  return _createClass(Observers, [{
    key: "isBrowserSupported",
    value: function isBrowserSupported() {
      return typeof window.IntersectionObserver === 'function' && typeof window.MutationObserver === 'function';
    }
  }, {
    key: "observe",
    value: function observe() {
      var _this$mutationObserve;
      this.totalTime = 0;
      this.ssr = {
        state: state.normal,
        reactRootElement: null,
        renderStart: -1,
        renderStop: -1
      };
      (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(document.body, {
        attributeFilter: ['hidden', 'style', 'src', 'class'],
        attributeOldValue: true,
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this$mutationObserve2, _this$intersectionObs2;
      (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 || _this$mutationObserve2.disconnect();
      (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 || _this$intersectionObs2.disconnect();
      this.observedMutations = new WeakMap();
      this.elementsInView = new Set();
      this.callbacks = new Set();
      this.ssr.reactRootElement = null;
      this.ssrPlaceholderHandler.clear();
      this.editorLnvHandler.clear();
    }
  }, {
    key: "getTotalTime",
    value: function getTotalTime() {
      return this.totalTime;
    }
  }, {
    key: "setReactRootElement",
    value: function setReactRootElement(element) {
      this.ssr.reactRootElement = element;
    }
  }, {
    key: "setReactRootRenderStart",
    value: function setReactRootRenderStart() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStart = startTime;
      this.ssr.state = state.waitingForFirstRender;
    }
  }, {
    key: "setReactRootRenderStop",
    value: function setReactRootRenderStop() {
      var stopTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStop = stopTime;
    }
  }, {
    key: "getMutationObserver",
    value: function getMutationObserver() {
      var _this2 = this;
      if (!this.isBrowserSupported()) {
        return null;
      }
      var shouldHandleEditorLnvLocal = shouldHandleEditorLnv();
      return new MutationObserver(function (mutations) {
        var operationTimer = markProfilingStart('mutationObserverCallback');
        _this2.measureStart();
        mutations.forEach(function (mutation) {
          // patching element if timestamp not automatically added
          // eslint-disable-next-line no-param-reassign
          mutation.timestamp = mutation.timestamp === undefined ? performance.now() : mutation.timestamp;
          var ignoreReason = '';
          if (_this2.ssr.state === state.waitingForFirstRender && mutation.timestamp > _this2.ssr.renderStart && mutation.target === _this2.ssr.reactRootElement) {
            _this2.ssr.state = state.ignoring;
            if (_this2.ssr.renderStop === -1) {
              // arbitrary 500ms DOM update window
              _this2.ssr.renderStop = mutation.timestamp + 500;
            }
            ignoreReason = 'ssr-hydration';
          }
          if (_this2.ssr.state === state.ignoring && mutation.timestamp > _this2.ssr.renderStart && mutation.target === _this2.ssr.reactRootElement) {
            if (mutation.timestamp <= _this2.ssr.renderStop) {
              ignoreReason = 'ssr-hydration';
            } else {
              _this2.ssr.state = state.normal;
            }
          }
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function (node) {
              if (isContainedWithinMediaWrapper(node)) {
                ignoreReason = 'image';
              }
              if (node instanceof HTMLElement
              /* && !node instanceof HTMLStyleElement && !node instanceof HTMLScriptElement && !node instanceof HTMLLinkElement */) {
                if (_this2.ssrPlaceholderHandler.isPlaceholder(node) || _this2.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                  _this2.ssrPlaceholderHandler.checkIfExistedAndSizeMatching(node).then(function (result) {
                    if (result === false) {
                      _this2.observeElement(node, mutation, 'html', ignoreReason);
                    }
                  });
                  return;
                }
                if (_this2.ssrPlaceholderHandler.isPlaceholderReplacement(node) || _this2.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                  _this2.ssrPlaceholderHandler.validateReactComponentMatchToPlaceholder(node).then(function (result) {
                    if (result === false) {
                      _this2.observeElement(node, mutation, 'html', ignoreReason);
                    }
                  });
                  return;
                }
                if (shouldHandleEditorLnvLocal) {
                  if (_this2.editorLnvHandler.shouldHandleAddedNode(node)) {
                    _this2.editorLnvHandler.handleAddedNode(node).then(function (_ref) {
                      var shouldIgnore = _ref.shouldIgnore;
                      _this2.observeElement(node, mutation, 'html', shouldIgnore ? 'editor-lazy-node-view' : ignoreReason);
                    });
                    return;
                  }
                }
                _this2.observeElement(node, mutation, 'html', ignoreReason);
              }
              if (node instanceof Text && node.parentElement != null) {
                _this2.observeElement(node.parentElement, mutation, 'text', ignoreReason);
              }
            });
            mutation.removedNodes.forEach(function (node) {
              if (node instanceof Element) {
                var _this2$intersectionOb;
                _this2.elementsInView.delete(node);
                (_this2$intersectionOb = _this2.intersectionObserver) === null || _this2$intersectionOb === void 0 || _this2$intersectionOb.unobserve(node);
              }
            });
          } else if (mutation.type === 'attributes') {
            if (mutation.target instanceof HTMLElement) {
              var _mutation$oldValue;
              var attributeName = mutation.attributeName;
              /*
              	"MutationObserver was explicitly designed to work that way, but I can't now recall the reasoning.
              	I think it might have been something along the lines that for consistency every setAttribute call should create a record.
              	Conceptually there is after all a mutation: there is an old value replaced with a new one,
              	and whether or not they are the same doesn't really matter.
              	And Custom elements should work the same way as MutationObserver."
              	https://github.com/whatwg/dom/issues/520#issuecomment-336574796
              */
              var oldValue = (_mutation$oldValue = mutation.oldValue) !== null && _mutation$oldValue !== void 0 ? _mutation$oldValue : undefined;
              var newValue = attributeName ? mutation.target.getAttribute(attributeName) : undefined;
              if (oldValue !== newValue) {
                if (isNonVisualStyleMutation(mutation)) {
                  ignoreReason = 'non-visual-style';
                }
                if (isContainedWithinMediaWrapper(mutation.target)) {
                  ignoreReason = 'image';
                }
                _this2.observeElement(mutation.target, mutation, 'attr', ignoreReason, attributeName, oldValue, newValue);
              }
            }
          }
        });
        markProfilingEnd(operationTimer, {
          tags: ['vc']
        });
      });
    }
  }, {
    key: "getElementName",
    value: function getElementName(element) {
      try {
        var tagName = element.localName;
        var dataVCAttr = element.getAttribute('data-vc');
        var dataVC = this.selectorConfig.dataVC && dataVCAttr ? "[data-vc=\"".concat(dataVCAttr, "\"]") : '';
        var id = this.selectorConfig.id && element.id ? "#".concat(element.id) : '';
        var testId = this.selectorConfig.testId ? element.getAttribute('data-testid') || element.getAttribute('data-test-id') : '';
        testId = testId ? "[testid=".concat(testId, "]") : '';
        var role = this.selectorConfig.role ? element.getAttribute('role') : '';
        role = role ? "[role=".concat(role, "]") : '';
        var classList = this.selectorConfig.className ? Array.from(element.classList).join('.') : '';
        classList = classList === '' ? '' : ".".concat(classList);
        var attrs = dataVC ? dataVC : [id, testId, role].join('');
        var idString = '';
        if (attrs === '' && classList === '') {
          var parent = element.parentElement ? this.getElementName(element.parentElement) : 'unknown';
          idString = "".concat(parent, " > ").concat(tagName);
        } else {
          idString = [tagName, attrs || classList].join('');
        }
        return idString;
      } catch (e) {
        return 'error';
      }
    }
  }, {
    key: "getIntersectionObserver",
    value: function getIntersectionObserver() {
      var _this3 = this;
      if (!this.isBrowserSupported()) {
        return null;
      }
      return new IntersectionObserver(function (entries) {
        var operationTimer = markProfilingStart('intersectionObserverCallback');
        _this3.measureStart();
        entries.forEach(function (_ref2) {
          var isIntersecting = _ref2.isIntersecting,
            ir = _ref2.intersectionRect,
            target = _ref2.target;
          var data = _this3.observedMutations.get(target);
          _this3.observedMutations.delete(target);
          if (isIntersecting && ir.width > 0 && ir.height > 0) {
            if (!(target instanceof HTMLElement)) {
              return;
            }
            if (!(data !== null && data !== void 0 && data.mutation)) {
              // ignore intersection report without recent mutation
              return;
            }
            if (!isElementVisible(target)) {
              data.ignoreReason = 'not-visible';
            }
            _this3.callbacks.forEach(function (callback) {
              var elementName;
              try {
                elementName = _this3.getElementName(target);
              } catch (e) {
                elementName = 'error';
              }
              callback(data.mutation.timestamp || performance.now(), ir, elementName, target, data.type, data.ignoreReason, data.attributeName, data.oldValue, data.newValue);
            });
            _this3.elementsInView.add(target);
          } else {
            _this3.elementsInView.delete(target);
          }
        });
        _this3.measureStop();
        markProfilingEnd(operationTimer, {
          tags: ['vc']
        });
      });
    }
  }, {
    key: "measureStart",
    value: function measureStart() {
      this._startMeasureTimestamp = performance.now();
    }
  }, {
    key: "measureStop",
    value: function measureStop() {
      if (this._startMeasureTimestamp === -1) {
        return;
      }
      this.totalTime += performance.now() - this._startMeasureTimestamp;
      this._startMeasureTimestamp = -1;
    }
  }]);
}();