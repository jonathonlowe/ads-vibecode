import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _VCObserver;
var _excluded = ["__debug__element"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { fg } from '@atlaskit/platform-feature-flags';
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../self-measurements';
import { attachAbortListeners } from './attachAbortListeners';
import { getVCRevisionsData } from './getVCRevisionsData';
import { getViewportHeight, getViewportWidth } from './getViewport';
import { MultiRevisionHeatmap } from './heatmap/heatmap';
import { Observers } from './observers';
import { getRevisions } from './revisions/revisions';
var abortReason = {
  scroll: 'scroll',
  keypress: 'keypress',
  resize: 'resize',
  error: 'error'
};
var UNUSED_SECTOR = 0;
var filterComponentsLog = withProfiling(function filterComponentsLog(log) {
  return Object.fromEntries(Object.entries(log).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      timestamp = _ref2[0],
      entries = _ref2[1];
    return [Number(timestamp), entries.map(function (entry) {
      var __debug__element = entry.__debug__element,
        rest = _objectWithoutProperties(entry, _excluded);
      return rest;
    })];
  }));
}, ['vc']);
export var VCObserver = /*#__PURE__*/function () {
  function VCObserver(options) {
    var _this = this;
    _classCallCheck(this, VCObserver);
    /* abort logic */
    _defineProperty(this, "abortReason", {
      reason: null,
      info: '',
      timestamp: -1,
      blocking: false
    });
    _defineProperty(this, "outOfBoundaryInfo", '');
    _defineProperty(this, "viewport", {
      w: 0,
      h: 0
    });
    /* heatmap */
    _defineProperty(this, "arraySize", 0);
    _defineProperty(this, "multiHeatmap", null);
    _defineProperty(this, "componentsLog", {});
    _defineProperty(this, "vcRatios", {});
    _defineProperty(this, "active", false);
    _defineProperty(this, "totalTime", 0);
    _defineProperty(this, "startTime", 0);
    _defineProperty(this, "_startMeasureTimestamp", -1);
    _defineProperty(this, "ssr", {
      reactRendered: -1
    });
    _defineProperty(this, "unbind", []);
    _defineProperty(this, "getAbortReasonInfo", function () {
      if (_this.abortReason.reason === null) {
        return null;
      }
      var info = _this.abortReason.info !== '' ? " ".concat(_this.abortReason.info) : '';
      return "".concat(_this.abortReason.reason).concat(info);
    });
    _defineProperty(this, "getVCRawData", function () {
      _this.measureStart();
      if (!_this.active) {
        _this.measureStop();
        return null;
      }
      _this.stop();
      var abortReasonInfo = _this.getAbortReasonInfo();
      _this.measureStop();
      return {
        abortReasonInfo: abortReasonInfo,
        abortReason: _objectSpread({}, _this.abortReason),
        heatmap: _this.heatmap,
        heatmapNext: _this.heatmapNext,
        multiHeatmap: _this.multiHeatmap,
        outOfBoundaryInfo: _this.outOfBoundaryInfo,
        totalTime: Math.round(_this.totalTime + _this.observers.getTotalTime()),
        componentsLog: _objectSpread({}, _this.componentsLog),
        viewport: _objectSpread({}, _this.viewport),
        oldDomUpdatesEnabled: _this.oldDomUpdatesEnabled,
        devToolsEnabled: _this.devToolsEnabled,
        ratios: _this.vcRatios
      };
    });
    _defineProperty(this, "getVCResult", /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref3) {
        var start, stop, tti, prefix, ssr, vc, isEventAborted, startTime, fullPrefix, rawData, abortReason, abortReasonInfo, heatmap, heatmapNext, outOfBoundaryInfo, totalTime, componentsLog, viewport, devToolsEnabled, ratios, multiHeatmap, isTTVCv1Disabled, ttvcV1Result, VC, VCBox, VCEntries, totalPainted, _componentsLog, vcNext, outOfBoundary, stopTime, ttvcV1DevToolInfo, ttvcV2DevToolInfo, isVCClean, revisionsData, isCalcSpeedIndexEnabled, speedIndex;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              start = _ref3.start, stop = _ref3.stop, tti = _ref3.tti, prefix = _ref3.prefix, ssr = _ref3.ssr, vc = _ref3.vc, isEventAborted = _ref3.isEventAborted;
              startTime = performance.now(); // add local measurement
              fullPrefix = prefix !== undefined && prefix !== '' ? "".concat(prefix, ":") : '';
              rawData = vc !== undefined ? vc : _this.getVCRawData();
              if (!(rawData === null)) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {});
            case 6:
              abortReason = rawData.abortReason, abortReasonInfo = rawData.abortReasonInfo, heatmap = rawData.heatmap, heatmapNext = rawData.heatmapNext, outOfBoundaryInfo = rawData.outOfBoundaryInfo, totalTime = rawData.totalTime, componentsLog = rawData.componentsLog, viewport = rawData.viewport, devToolsEnabled = rawData.devToolsEnabled, ratios = rawData.ratios, multiHeatmap = rawData.multiHeatmap;
              if (!(abortReasonInfo !== null && abortReason.blocking)) {
                _context.next = 10;
                break;
              }
              // exposing data to devtools
              try {
                if (devToolsEnabled && !_this.isPostInteraction) {
                  window.__vcNotAvailableReason = abortReasonInfo;
                }
              } catch (e) {}
              return _context.abrupt("return", _defineProperty(_defineProperty(_defineProperty({}, "".concat(fullPrefix, "vc:state"), false), "".concat(fullPrefix, "vc:abort:reason"), abortReasonInfo), "".concat(fullPrefix, "vc:abort:timestamp"), abortReason.timestamp));
            case 10:
              isTTVCv1Disabled = fg('platform_ufo_disable_ttvc_v1');
              ttvcV1Result = isTTVCv1Disabled ? {
                VC: {},
                VCBox: {},
                VCEntries: {
                  abs: [],
                  rel: [],
                  speedIndex: -1
                },
                totalPainted: -1
              } : VCObserver.calculateVC({
                heatmap: heatmap,
                ssr: ssr,
                componentsLog: _objectSpread({}, componentsLog),
                viewport: viewport
              });
              VC = ttvcV1Result.VC, VCBox = ttvcV1Result.VCBox, VCEntries = ttvcV1Result.VCEntries, totalPainted = ttvcV1Result.totalPainted;
              _componentsLog = {};
              Object.entries(_this.componentsLog).forEach(function (_ref6) {
                var _ref7 = _slicedToArray(_ref6, 2),
                  _timestamp = _ref7[0],
                  value = _ref7[1];
                var timestamp = Number(_timestamp);
                if (stop > timestamp) {
                  _componentsLog[timestamp] = value;
                }
              });
              vcNext = VCObserver.calculateVC({
                heatmap: heatmapNext,
                ssr: ssr,
                componentsLog: _componentsLog,
                viewport: viewport
              });
              try {
                if (!_this.isPostInteraction) {
                  VCObserver.VCParts.forEach(function (key) {
                    if (isTTVCv1Disabled) {
                      var duration = vcNext.VC[key];
                      if (duration !== null && duration !== undefined) {
                        performance.measure("VC".concat(key), {
                          start: start,
                          duration: duration
                        });
                        performance.measure("VC_Next".concat(key), {
                          start: start,
                          duration: duration
                        });
                      }
                    } else {
                      var ttvcV1duration = VC[key];
                      if (ttvcV1duration !== null && ttvcV1duration !== undefined) {
                        performance.measure("VC".concat(key), {
                          start: start,
                          duration: ttvcV1duration
                        });
                      }
                      var ttvcV2duration = vcNext.VC[key];
                      if (ttvcV2duration !== null && ttvcV2duration !== undefined) {
                        performance.measure("VC_Next".concat(key), {
                          start: start,
                          duration: ttvcV2duration
                        });
                      }
                    }
                  });
                }
              } catch (e) {
                /* empty */
              }
              outOfBoundary = outOfBoundaryInfo ? _defineProperty({}, "".concat(fullPrefix, "vc:oob"), outOfBoundaryInfo) : {}; //const oldDomUpdates = oldDomUpdatesEnabled ? { [`${fullPrefix}vc:old:dom`]: vcNext.VCBox } : {};
              stopTime = performance.now(); // exposing data to devtools
              try {
                if (!_this.isPostInteraction && devToolsEnabled) {
                  ttvcV1DevToolInfo = isTTVCv1Disabled ? undefined : {
                    entries: VCEntries.rel,
                    log: componentsLog,
                    metrics: {
                      '75': VC['75'],
                      '80': VC['80'],
                      '85': VC['85'],
                      '90': VC['90'],
                      '95': VC['95'],
                      '98': VC['98'],
                      '99': VC['99'],
                      tti: tti,
                      ttai: stop - start
                    },
                    start: start,
                    stop: stop,
                    heatmap: heatmap,
                    ratios: ratios
                  };
                  ttvcV2DevToolInfo = {
                    entries: vcNext.VCEntries.rel,
                    log: componentsLog,
                    metrics: {
                      '75': vcNext.VC['75'],
                      '80': vcNext.VC['80'],
                      '85': vcNext.VC['85'],
                      '90': vcNext.VC['90'],
                      '95': vcNext.VC['95'],
                      '98': vcNext.VC['98'],
                      '99': vcNext.VC['99'],
                      tti: tti,
                      ttai: stop - start
                    },
                    start: start,
                    stop: stop,
                    heatmap: heatmapNext,
                    ratios: ratios
                  };
                  if (isTTVCv1Disabled) {
                    window.__vc = ttvcV2DevToolInfo;
                    window.__vcNext = ttvcV2DevToolInfo;
                  } else {
                    window.__vc = ttvcV1DevToolInfo;
                    window.__vcNext = ttvcV2DevToolInfo;
                  }

                  // Emitting a custom event to make it available in the Chrome extension
                  window.dispatchEvent(new CustomEvent('vcReady', {
                    detail: {
                      log: filterComponentsLog(componentsLog),
                      entries: isTTVCv1Disabled ? vcNext.VCEntries.rel : VCEntries.rel
                    }
                  }));
                }
              } catch (e) {
                /*  do nothing */
              }
              isVCClean = !abortReasonInfo;
              revisionsData = getVCRevisionsData({
                fullPrefix: fullPrefix,
                interaction: {
                  start: start,
                  end: stop
                },
                isVCClean: isVCClean,
                multiHeatmap: multiHeatmap,
                ssr: ssr,
                calculatedVC: {
                  VC: VC,
                  VCBox: VCBox
                },
                calculatedVCNext: {
                  VC: vcNext.VC,
                  VCBox: vcNext.VCBox
                },
                isEventAborted: isEventAborted
              }); // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
              isCalcSpeedIndexEnabled = fg('ufo-calc-speed-index');
              speedIndex = _defineProperty(_defineProperty({}, "ufo:speedIndex", isTTVCv1Disabled ? vcNext.VCEntries.speedIndex : VCEntries.speedIndex), "ufo:next:speedIndex", vcNext.VCEntries.speedIndex);
              if (!isTTVCv1Disabled) {
                _context.next = 26;
                break;
              }
              return _context.abrupt("return", _objectSpread(_objectSpread(_objectSpread(_defineProperty(_defineProperty(_defineProperty({}, "".concat(fullPrefix, "vc:size"), viewport), "".concat(fullPrefix, "vc:time"), Math.round(totalTime + (stopTime - startTime))), "".concat(fullPrefix, "vc:ratios"), ratios), outOfBoundary), {}, _defineProperty({}, "".concat(fullPrefix, "vc:ignored"), _this.getIgnoredElements(componentsLog)), revisionsData), isCalcSpeedIndexEnabled ? speedIndex : {}));
            case 26:
              return _context.abrupt("return", _objectSpread(_objectSpread(_objectSpread(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
                'metrics:vc': VC
              }, "".concat(fullPrefix, "vc:state"), true), "".concat(fullPrefix, "vc:clean"), isVCClean), "".concat(fullPrefix, "vc:dom"), VCBox), "".concat(fullPrefix, "vc:updates"), fg('platform_ufo_vc_observer_new') ? undefined : VCEntries.rel.slice(0, 50)), "".concat(fullPrefix, "vc:size"), viewport), "".concat(fullPrefix, "vc:time"), Math.round(totalTime + (stopTime - startTime))), "".concat(fullPrefix, "vc:total"), totalPainted), "".concat(fullPrefix, "vc:ratios"), ratios), outOfBoundary), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(fullPrefix, "vc:next"), vcNext.VC), "".concat(fullPrefix, "vc:next:updates"), fg('platform_ufo_vc_observer_new') ? undefined : vcNext.VCEntries.rel.slice(0, 50)), "".concat(fullPrefix, "vc:next:dom"), vcNext.VCBox), "".concat(fullPrefix, "vc:ignored"), _this.getIgnoredElements(componentsLog)), revisionsData), isCalcSpeedIndexEnabled ? speedIndex : {}));
            case 27:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref4.apply(this, arguments);
      };
    }());
    _defineProperty(this, "handleUpdate", function (rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue) {
      _this.measureStart();
      _this.legacyHandleUpdate(rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue);
      if (!fg('platform_ufo_vc_observer_new')) {
        _this.onViewportChangeDetected({
          timestamp: rawTime,
          intersectionRect: intersectionRect,
          targetName: targetName,
          element: element,
          type: type,
          ignoreReason: ignoreReason,
          attributeName: attributeName,
          oldValue: oldValue,
          newValue: newValue
        });
      }
      _this.measureStop();
    });
    _defineProperty(this, "legacyHandleUpdate", function (rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue) {
      if (_this.abortReason.reason === null || _this.abortReason.blocking === false) {
        var time = Math.round(rawTime - _this.startTime);
        var mappedValues = _this.mapPixelsToHeatmap(intersectionRect.left, intersectionRect.top, intersectionRect.width, intersectionRect.height);
        _this.vcRatios[targetName] = _this.getElementRatio(mappedValues);
        if (!ignoreReason) {
          _this.applyChangesToHeatMap(mappedValues, time, _this.heatmapNext);
        }
        var isTTVCv1Disabled = fg('platform_ufo_disable_ttvc_v1');
        if (!isTTVCv1Disabled && (!ignoreReason || ignoreReason === 'not-visible') && type !== 'attr') {
          _this.applyChangesToHeatMap(mappedValues, time, _this.heatmap);
        }
        if (!_this.componentsLog[time]) {
          _this.componentsLog[time] = [];
        }
        _this.componentsLog[time].push({
          __debug__element: _this.devToolsEnabled ? new WeakRef(element) : null,
          type: type,
          intersectionRect: intersectionRect,
          targetName: targetName,
          ignoreReason: ignoreReason,
          attributeName: attributeName,
          oldValue: oldValue,
          newValue: newValue
        });
      }
    });
    _defineProperty(this, "onViewportChangeDetected", function (_ref9) {
      var element = _ref9.element,
        type = _ref9.type,
        ignoreReason = _ref9.ignoreReason,
        timestamp = _ref9.timestamp,
        targetName = _ref9.targetName,
        intersectionRect = _ref9.intersectionRect,
        attributeName = _ref9.attributeName,
        oldValue = _ref9.oldValue,
        newValue = _ref9.newValue;
      if (_this.multiHeatmap === null) {
        return;
      }
      // @todo add abort reason handling
      var time = Math.round(timestamp - _this.startTime);
      var revisions = getRevisions();
      var revisionsClassification = revisions.map(function (revision) {
        return revision.classifier.classifyUpdate({
          element: element,
          type: type,
          ignoreReason: ignoreReason
        });
      }, []);
      _this.multiHeatmap.handleUpdate({
        time: time,
        targetName: targetName,
        intersectionRect: intersectionRect,
        type: type,
        element: element,
        classification: revisionsClassification,
        onError: function onError(error) {
          _this.setAbortReason(abortReason.error, error.time, error.error);
        },
        attributeName: attributeName,
        oldValue: oldValue,
        newValue: newValue
      });
    });
    _defineProperty(this, "mapPixelsToHeatmap", function (left, top, width, height) {
      var _this$viewport = _this.viewport,
        w = _this$viewport.w,
        h = _this$viewport.h;
      var l = Math.floor(left / w * _this.arraySize);
      var t = Math.floor(top / h * _this.arraySize);
      var r = Math.ceil((left + width) / w * _this.arraySize);
      var b = Math.ceil((top + height) / h * _this.arraySize);

      // that info is temporary to get info why it goes over boundary
      if (_this.outOfBoundaryInfo === '') {
        var outOfBoundaryInfo = '';
        if (r > _this.arraySize) {
          outOfBoundaryInfo += " r ".concat(r, " ! ").concat(left, " ").concat(width);
        }
        if (b > _this.arraySize) {
          outOfBoundaryInfo += " r ".concat(r, " ! ").concat(top, " ").concat(height);
        }
        _this.outOfBoundaryInfo = outOfBoundaryInfo;
      }

      // correct values to min - 0, max - arraySize
      var result = {
        l: Math.max(0, l),
        t: Math.max(0, t),
        r: Math.min(_this.arraySize, r),
        b: Math.min(_this.arraySize, b)
      };
      return result;
    });
    _defineProperty(this, "getElementRatio", function (mappedValues) {
      var r = mappedValues.r,
        l = mappedValues.l,
        b = mappedValues.b,
        t = mappedValues.t;
      return (r - l) * (b - t) / (_this.arraySize * _this.arraySize);
    });
    _defineProperty(this, "abortReasonCallback", function (key, time) {
      switch (key) {
        case 'wheel':
          _this.setAbortReason(abortReason.scroll, time);
          break;
        case 'keydown':
          _this.setAbortReason(abortReason.keypress, time);
          break;
        case 'resize':
          _this.setAbortReason(abortReason.resize, time);
          break;
      }
    });
    _defineProperty(this, "attachAbortListeners", function () {
      var _window;
      _this.detachAbortListeners();
      var unbinds = attachAbortListeners(window, _this.viewport, _this.abortReasonCallback);
      if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
        var _window2;
        Object.entries(window.__SSR_ABORT_LISTENERS__.aborts).forEach(function (_ref10) {
          var _ref11 = _slicedToArray(_ref10, 2),
            key = _ref11[0],
            time = _ref11[1];
          if (time) {
            _this.abortReasonCallback(key, time);
          }
        });
        unbinds = unbinds.concat(window.__SSR_ABORT_LISTENERS__.unbinds);
        (_window2 = window) === null || _window2 === void 0 || delete _window2.__SSR_ABORT_LISTENERS__;
      }
      _this.unbind = unbinds;
    });
    var operationTimer = markProfilingStart('VCObserver constructor');
    this.arraySize = options.heatmapSize || 200;
    this.devToolsEnabled = options.devToolsEnabled || false;
    this.oldDomUpdatesEnabled = options.oldDomUpdates || false;
    this.observers = new Observers({
      selectorConfig: options.selectorConfig || {
        id: false,
        testId: false,
        role: false,
        className: true,
        dataVC: true
      }
    });
    this.heatmap = fg('platform_ufo_disable_ttvc_v1') ? [] : this.getCleanHeatmap();
    this.heatmapNext = this.getCleanHeatmap();
    this.multiHeatmap = new MultiRevisionHeatmap({
      viewport: this.viewport,
      revisions: getRevisions(),
      devToolsEnabled: this.devToolsEnabled
    });
    this.isPostInteraction = options.isPostInteraction || false;
    this.start = withProfiling(this.start.bind(this), ['vc']);
    this.stop = withProfiling(this.stop.bind(this), ['vc']);
    this.getAbortReasonInfo = withProfiling(this.getAbortReasonInfo.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getVCRawData = withProfiling(this.getVCRawData.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getIgnoredElements = withProfiling(this.getIgnoredElements.bind(this), ['vc']);
    this.getVCResult = withProfiling(this.getVCResult.bind(this), ['vc']);
    this.setSSRElement = withProfiling(this.setSSRElement.bind(this), ['vc']);
    this.setReactRootRenderStart = withProfiling(this.setReactRootRenderStart.bind(this), ['vc']);
    this.setReactRootRenderStop = withProfiling(this.setReactRootRenderStop.bind(this), ['vc']);
    this.handleUpdate = withProfiling(this.handleUpdate.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.legacyHandleUpdate = withProfiling(this.legacyHandleUpdate.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.onViewportChangeDetected = withProfiling(this.onViewportChangeDetected.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.setAbortReason = withProfiling(this.setAbortReason.bind(this), ['vc']);
    this.resetState = withProfiling(this.resetState.bind(this), ['vc']);
    this.setViewportSize = withProfiling(this.setViewportSize.bind(this), ['vc']);
    this.mapPixelsToHeatmap = withProfiling(this.mapPixelsToHeatmap.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getElementRatio = withProfiling(this.getElementRatio.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.applyChangesToHeatMap = withProfiling(this.applyChangesToHeatMap.bind(this), ['vc']);
    this.abortReasonCallback = withProfiling(this.abortReasonCallback.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.attachAbortListeners = withProfiling(this.attachAbortListeners.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.detachAbortListeners = withProfiling(this.detachAbortListeners.bind(this), ['vc']);
    this.measureStart = withProfiling(this.measureStart.bind(this), ['vc']);
    this.measureStop = withProfiling(this.measureStop.bind(this), ['vc']);
    markProfilingEnd(operationTimer, {
      tags: ['vc']
    });
  }
  return _createClass(VCObserver, [{
    key: "start",
    value: function start(_ref12) {
      var startTime = _ref12.startTime;
      this.active = true;
      if (this.observers.isBrowserSupported()) {
        this.setViewportSize();
        this.resetState();
        this.startTime = startTime;
        this.attachAbortListeners();
        this.observers.subscribeResults(this.handleUpdate);
        this.observers.observe();
      } else {
        this.setAbortReason('not-supported', startTime);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      this.observers.disconnect();
      this.detachAbortListeners();
    }
  }, {
    key: "getIgnoredElements",
    value: function getIgnoredElements(componentsLog) {
      return Object.values(componentsLog).flat().filter(function (_ref13) {
        var ignoreReason = _ref13.ignoreReason;
        return Boolean(ignoreReason);
      }).map(function (_ref14) {
        var targetName = _ref14.targetName,
          ignoreReason = _ref14.ignoreReason;
        return {
          targetName: targetName,
          ignoreReason: ignoreReason
        };
      });
    }
  }, {
    key: "setSSRElement",
    value: function setSSRElement(element) {
      this.observers.setReactRootElement(element);
    }
  }, {
    key: "setReactRootRenderStart",
    value: function setReactRootRenderStart() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.observers.setReactRootRenderStart(startTime);
    }
  }, {
    key: "setReactRootRenderStop",
    value: function setReactRootRenderStop() {
      var stopTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.observers.setReactRootRenderStop(stopTime);
    }
  }, {
    key: "setAbortReason",
    value: function setAbortReason(abort, timestamp) {
      var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      if (this.abortReason.reason === null || this.abortReason.blocking === false) {
        this.abortReason.reason = abort;
        this.abortReason.info = info;
        this.abortReason.timestamp = timestamp;
        this.abortReason.blocking = abort !== abortReason.scroll;
        if (this.abortReason.blocking) {
          this.detachAbortListeners();
        }
      }
    }
  }, {
    key: "resetState",
    value: function resetState() {
      this.abortReason = {
        reason: null,
        info: '',
        timestamp: -1,
        blocking: false
      };
      this.detachAbortListeners();
      this.heatmap = fg('platform_ufo_disable_ttvc_v1') ? [] : this.getCleanHeatmap();
      this.heatmapNext = this.getCleanHeatmap();
      this.multiHeatmap = new MultiRevisionHeatmap({
        viewport: this.viewport,
        revisions: getRevisions(),
        devToolsEnabled: this.devToolsEnabled
      });
      this.totalTime = 0;
      this.componentsLog = {};
      this.vcRatios = {};
    }
  }, {
    key: "getCleanHeatmap",
    value: function getCleanHeatmap() {
      var _this2 = this;
      return Array(this.arraySize).fill('').map(function () {
        return Array(_this2.arraySize).fill(UNUSED_SECTOR);
      });
    }
  }, {
    key: "setViewportSize",
    value: function setViewportSize() {
      this.viewport.w = getViewportWidth();
      this.viewport.h = getViewportHeight();
    }
  }, {
    key: "applyChangesToHeatMap",
    value: function applyChangesToHeatMap(a, time, heatmap) {
      var l = a.l,
        t = a.t,
        r = a.r,
        b = a.b;
      var localHeatmap = heatmap;
      for (var row = t; row < b; row++) {
        for (var col = l; col < r; col++) {
          if (localHeatmap[row] === undefined) {
            try {
              this.setAbortReason(abortReason.error, time, "index - ".concat(row));
            } catch (e) {
              this.setAbortReason(abortReason.error, time, 'row error');
            }
            return;
          } else {
            localHeatmap[row][col] = time;
          }
        }
      }
    }
  }, {
    key: "detachAbortListeners",
    value: function detachAbortListeners() {
      this.unbind.forEach(function (fn) {
        return fn();
      });
      this.unbind = [];
    }
  }, {
    key: "measureStart",
    value: function measureStart() {
      this._startMeasureTimestamp = performance.now();
    }
  }, {
    key: "measureStop",
    value: function measureStop() {
      if (this._startMeasureTimestamp === -1) {
        return;
      }
      this.totalTime += performance.now() - this._startMeasureTimestamp;
      this._startMeasureTimestamp = -1;
    }
  }]);
}();
_VCObserver = VCObserver;
/** config * */
_defineProperty(VCObserver, "VCParts", ['25', '50', '75', '80', '85', '90', '95', '98', '99']);
_defineProperty(VCObserver, "calculateVC", withProfiling(function calculateVC(_ref15) {
  var heatmap = _ref15.heatmap,
    _ref15$ssr = _ref15.ssr,
    ssr = _ref15$ssr === void 0 ? UNUSED_SECTOR : _ref15$ssr,
    componentsLog = _ref15.componentsLog,
    viewport = _ref15.viewport;
  var lastUpdate = {};
  var totalPainted = 0;
  if (ssr !== UNUSED_SECTOR) {
    var _window$document;
    var element = {
      __debug__element: new WeakRef((_window$document = window.document) === null || _window$document === void 0 ? void 0 : _window$document.body),
      intersectionRect: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        x: 0,
        y: 0,
        width: viewport.w,
        height: viewport.h,
        toJSON: function toJSON() {
          return {};
        }
      },
      targetName: 'SSR'
    };
    if (!componentsLog[ssr]) {
      componentsLog[ssr] = [];
    }
    componentsLog[ssr].push(element);
  }
  heatmap.forEach(function (line) {
    line.forEach(function (entry) {
      var rounded = Math.floor(entry === UNUSED_SECTOR && ssr !== UNUSED_SECTOR ? ssr : entry);
      totalPainted += rounded !== UNUSED_SECTOR ? 1 : 0;
      if (rounded !== UNUSED_SECTOR) {
        lastUpdate[rounded] = lastUpdate[rounded] ? lastUpdate[rounded] + 1 : 1;
      }
    });
  });
  var entries = Object.entries(lastUpdate).map(function (a) {
    return [parseInt(a[0], 10), a[1]];
  }).sort(function (a, b) {
    return a[0] > b[0] ? 1 : -1;
  });
  var VC = _VCObserver.makeVCReturnObj();
  var VCBox = _VCObserver.makeVCReturnObj();

  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
  var isCalcSpeedIndexEnabled = fg('ufo-calc-speed-index');
  entries.reduce(function () {
    var acc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var v = arguments.length > 1 ? arguments[1] : undefined;
    var currRatio = v[1] / totalPainted;
    var VCRatio = currRatio + acc;
    var preciseCurrRatio = Math.round(100 * (v[1] / totalPainted));
    var preciseAccRatio = Math.round(acc * 100);
    VCRatio = (preciseCurrRatio + preciseAccRatio) / 100;
    var time = v[0];
    _VCObserver.VCParts.forEach(function (key) {
      var value = parseInt(key, 10);
      if ((VC[key] === null || VC[key] === undefined) && VCRatio >= value / 100) {
        var _componentsLog$time;
        VC[key] = time;
        VCBox[key] = _toConsumableArray(new Set((_componentsLog$time = componentsLog[time]) === null || _componentsLog$time === void 0 ? void 0 : _componentsLog$time.filter(function (v) {
          return !v.ignoreReason;
        }).map(function (v) {
          return v.targetName;
        })));
      }
    });
    return VCRatio;
  }, 0);
  var VCEntries = entries.reduce(function (acc, _ref16, i) {
    var _acc$abs, _componentsLog$timest, _acc$rel$vc, _acc$rel;
    var _ref17 = _slicedToArray(_ref16, 2),
      timestamp = _ref17[0],
      entryPainted = _ref17[1];
    var currentlyPainted = entryPainted + (((_acc$abs = acc.abs[i - 1]) === null || _acc$abs === void 0 ? void 0 : _acc$abs[1]) || 0);
    var currentlyPaintedRatio = Math.round(currentlyPainted / totalPainted * 1000) / 10;
    var logEntry = _toConsumableArray(new Set((_componentsLog$timest = componentsLog[timestamp]) === null || _componentsLog$timest === void 0 ? void 0 : _componentsLog$timest.filter(function (v) {
      return !v.ignoreReason;
    }).map(function (v) {
      return v.targetName;
    })));
    var ratioDelta = (currentlyPaintedRatio - ((_acc$rel$vc = (_acc$rel = acc.rel[i - 1]) === null || _acc$rel === void 0 ? void 0 : _acc$rel.vc) !== null && _acc$rel$vc !== void 0 ? _acc$rel$vc : 0)) / 100;
    if (isCalcSpeedIndexEnabled) {
      var speedIndex = timestamp * ratioDelta;
      acc.speedIndex += speedIndex;
    }
    acc.abs.push([timestamp, currentlyPainted]);
    acc.rel.push({
      time: timestamp,
      vc: currentlyPaintedRatio,
      elements: logEntry
    });
    return acc;
  }, {
    abs: [],
    rel: [],
    speedIndex: 0
  });
  VCEntries.speedIndex = Math.round(VCEntries.speedIndex);
  return {
    VC: VC,
    VCBox: VCBox,
    VCEntries: VCEntries,
    totalPainted: totalPainted
  };
}, ['vc']));
_defineProperty(VCObserver, "makeVCReturnObj", withProfiling(function makeVCReturnObj() {
  var vc = {};
  _VCObserver.VCParts.forEach(function (v) {
    vc[v] = null;
  });
  return vc;
}, ['vc']));