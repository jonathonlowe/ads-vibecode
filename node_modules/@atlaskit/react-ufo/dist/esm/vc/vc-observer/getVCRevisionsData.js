import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { fg } from '@atlaskit/platform-feature-flags';
import { getPageVisibilityState } from '../../hidden-timing';
import { withProfiling } from '../../self-measurements';
import { getRevisions } from './revisions/revisions';
var VCParts = ['25', '50', '75', '80', '85', '90', '95', '98', '99'];
var READONLY_EMPTY_ARRAY = Array.from({
  length: 0
});

// Helper function to create vcDetails object to avoid code duplication
var createVCDetails = withProfiling(function createVCDetails(calculatedVC, shouldHaveVCmetric) {
  if (!shouldHaveVCmetric || !calculatedVC || !calculatedVC.VC || !calculatedVC.VCBox) {
    return {};
  }
  var details = {};
  var VC = calculatedVC.VC,
    VCBox = calculatedVC.VCBox; // Destructure once to avoid repeated property access

  for (var _i = 0, _VCParts = VCParts; _i < _VCParts.length; _i++) {
    var key = _VCParts[_i];
    details[key] = {
      t: VC[key],
      e: VCBox[key] || READONLY_EMPTY_ARRAY
    };
  }
  return details;
}, ['vc']);

// Optimized implementation (current one)
export var getVCRevisionsData = withProfiling(function getVCRevisionsData(_ref) {
  var fullPrefix = _ref.fullPrefix,
    interaction = _ref.interaction,
    isVCClean = _ref.isVCClean,
    isEventAborted = _ref.isEventAborted,
    multiHeatmap = _ref.multiHeatmap,
    ssr = _ref.ssr,
    calculatedVC = _ref.calculatedVC,
    calculatedVCNext = _ref.calculatedVCNext;
  if (!fg('platform_ufo_vc_observer_new')) {
    if (!multiHeatmap) {
      return null;
    }
    return _defineProperty({}, "".concat(fullPrefix, "vc:rev"), multiHeatmap === null || multiHeatmap === void 0 ? void 0 : multiHeatmap.getPayloadShapedData({
      VCParts: VCParts.map(function (v) {
        return parseInt(v);
      }),
      VCCalculationMethods: getRevisions().map(function (_ref2) {
        var classifier = _ref2.classifier;
        return classifier.VCCalculationMethod;
      }),
      filterComponentsLog: getRevisions().map(function (_ref3) {
        var classifier = _ref3.classifier;
        return classifier.filterComponentsLog;
      }),
      isEventAborted: isEventAborted,
      interactionStart: interaction.start,
      ttai: interaction.end,
      ssr: ssr,
      clean: isVCClean
    }));
  }

  // Calculate these conditions once
  var pageVisibilityUpToTTAI = getPageVisibilityState(interaction.start, interaction.end);
  var isVisiblePageVisibleUpToTTAI = pageVisibilityUpToTTAI === 'visible';
  var shouldHaveVCmetric = isVCClean && !isEventAborted && isVisiblePageVisibleUpToTTAI;

  // Create the V2 revision object which is always needed
  var ttvcV2Revision = {
    revision: 'fy25.02',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVCNext.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVCNext, shouldHaveVCmetric)
  };
  if (fg('platform_ufo_disable_ttvc_v1')) {
    return _defineProperty({}, "".concat(fullPrefix, "vc:rev"), [ttvcV2Revision]);
  }

  // Only create ttvcV1Revision when we're actually going to use it
  var ttvcV1Revision = {
    revision: 'fy25.01',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVC.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVC, shouldHaveVCmetric)
  };
  return _defineProperty({}, "".concat(fullPrefix, "vc:rev"), [ttvcV1Revision, ttvcV2Revision]);
}, ['vc']);