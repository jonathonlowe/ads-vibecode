import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectDestructuringEmpty from "@babel/runtime/helpers/objectDestructuringEmpty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { getPageVisibilityState } from '../../../hidden-timing';
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../../self-measurements';
var UNUSED_SECTOR = 0;
export var MultiRevisionHeatmap = /*#__PURE__*/function () {
  function MultiRevisionHeatmap(_ref) {
    var _this = this;
    var viewport = _ref.viewport,
      revisions = _ref.revisions,
      arraySize = _ref.arraySize,
      devToolsEnabled = _ref.devToolsEnabled;
    _classCallCheck(this, MultiRevisionHeatmap);
    _defineProperty(this, "arraySize", {
      w: 200,
      h: 200
    });
    _defineProperty(this, "mapPixelsToHeatmap", function (left, top, width, height) {
      var _this$viewport = _this.viewport,
        w = _this$viewport.w,
        h = _this$viewport.h;
      var l = Math.floor(left / w * _this.arraySize.w);
      var t = Math.floor(top / h * _this.arraySize.h);
      var r = Math.ceil((left + width) / w * _this.arraySize.w);
      var b = Math.ceil((top + height) / h * _this.arraySize.h);

      // correct values to min - 0, max - arraySize
      var result = {
        l: Math.max(0, l),
        t: Math.max(0, t),
        r: Math.min(_this.arraySize.w, r),
        b: Math.min(_this.arraySize.h, b)
      };
      return result;
    });
    _defineProperty(this, "getElementRatio", function (mappedValues) {
      var r = mappedValues.r,
        l = mappedValues.l,
        b = mappedValues.b,
        t = mappedValues.t;
      return (r - l) * (b - t) / (_this.arraySize.w * _this.arraySize.h);
    });
    var operationTimer = markProfilingStart('MultiRevisionHeatmap constructor');
    this.viewport = viewport;
    this.revisions = revisions;
    if (arraySize) {
      this.arraySize = arraySize;
    }
    this.heatmaps = new Array(revisions.length);
    this.componentsLogs = new Array(revisions.length);
    this.vcRatios = new Array(revisions.length);
    this.devToolsEnabled = devToolsEnabled || false;
    revisions.forEach(function (_ref2, i) {
      _objectDestructuringEmpty(_ref2);
      _this.heatmaps[i] = _this.getCleanHeatmap();
      _this.componentsLogs[i] = {};
      _this.vcRatios[i] = {};
    });
    this.handleUpdate = withProfiling(this.handleUpdate.bind(this), ['vc']);
    this.getData = withProfiling(this.getData.bind(this), ['vc']);
    this.getPayloadShapedData = withProfiling(this.getPayloadShapedData.bind(this), ['vc']);
    this.processData = withProfiling(this.processData.bind(this), ['vc']);
    this.mapPixelsToHeatmap = withProfiling(this.mapPixelsToHeatmap.bind(this), ['vc']);
    this.getElementRatio = withProfiling(this.getElementRatio.bind(this), ['vc']);
    this.applyChangesToHeatMap = withProfiling(this.applyChangesToHeatMap.bind(this), ['vc']);
    this.getIndex = withProfiling(this.getIndex.bind(this), ['vc']);
    this.getCleanHeatmap = withProfiling(this.getCleanHeatmap.bind(this), ['vc']);
    markProfilingEnd(operationTimer);
  }
  return _createClass(MultiRevisionHeatmap, [{
    key: "handleUpdate",
    value: function handleUpdate(_ref3) {
      var _this2 = this;
      var time = _ref3.time,
        type = _ref3.type,
        classification = _ref3.classification,
        intersectionRect = _ref3.intersectionRect,
        element = _ref3.element,
        targetName = _ref3.targetName,
        ignoreReason = _ref3.ignoreReason,
        onError = _ref3.onError,
        attributeName = _ref3.attributeName,
        oldValue = _ref3.oldValue,
        newValue = _ref3.newValue;
      var mappedValues = this.mapPixelsToHeatmap(intersectionRect.left, intersectionRect.top, intersectionRect.width, intersectionRect.height);
      var result = this.applyChangesToHeatMap(mappedValues, time, classification);
      if (result !== true) {
        onError(result);
      }
      var componentRatio = this.getElementRatio(mappedValues);
      this.revisions.forEach(function (_, i) {
        if (classification[i]) {
          _this2.vcRatios[i][targetName] = componentRatio;
        }
        if (!_this2.componentsLogs[i][time]) {
          _this2.componentsLogs[i][time] = [];
        }
        _this2.componentsLogs[i][time].push({
          __debug__element: _this2.devToolsEnabled ? new WeakRef(element) : null,
          intersectionRect: intersectionRect,
          targetName: targetName,
          ignoreReason: ignoreReason,
          attributeName: attributeName,
          oldValue: oldValue,
          newValue: newValue
        });
      });
    }
  }, {
    key: "getData",
    value: function getData() {
      return {
        heatmaps: this.heatmaps
      };
    }
  }, {
    key: "getPayloadShapedData",
    value: function getPayloadShapedData(args) {
      var pageVisibilityUpToTTAI = getPageVisibilityState(args.interactionStart, args.ttai);
      var result = this.processData(args);
      var payload = this.revisions.map(function (rev, i) {
        var _vcDetails$;
        var vcDetails = {};
        args.VCParts.forEach(function (VCPart) {
          vcDetails[VCPart] = {
            t: result[i].VC[VCPart] || 0,
            e: Array.from(result[i].VCBox[VCPart] || [])
          };
        });
        return {
          revision: rev.name,
          vcDetails: vcDetails,
          clean: args.clean,
          'metric:vc90': args.clean && !args.isEventAborted && pageVisibilityUpToTTAI === 'visible' ? vcDetails === null || vcDetails === void 0 || (_vcDetails$ = vcDetails['90']) === null || _vcDetails$ === void 0 ? void 0 : _vcDetails$.t : null
        };
      });
      return payload;
    }
  }, {
    key: "processData",
    value: function processData(_ref4) {
      var _this3 = this;
      var VCParts = _ref4.VCParts,
        VCCalculationMethods = _ref4.VCCalculationMethods,
        filterComponentsLog = _ref4.filterComponentsLog,
        ttai = _ref4.ttai,
        _ref4$ssr = _ref4.ssr,
        ssr = _ref4$ssr === void 0 ? UNUSED_SECTOR : _ref4$ssr;
      return this.heatmaps.map(function (heatmap, i) {
        var lastUpdate = {};
        var totalPainted = 0;
        var componentsLog = _this3.componentsLogs[i];
        if (ssr !== UNUSED_SECTOR) {
          var _window$document;
          var element = {
            __debug__element: new WeakRef((_window$document = window.document) === null || _window$document === void 0 ? void 0 : _window$document.body),
            intersectionRect: {
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              x: 0,
              y: 0,
              width: _this3.viewport.w,
              height: _this3.viewport.h,
              toJSON: function toJSON() {
                return {};
              }
            },
            targetName: 'SSR'
          };
          if (!componentsLog[ssr]) {
            componentsLog[ssr] = [];
          }
          componentsLog[ssr].push(element);
        }
        for (var _i = 0; _i < heatmap.length; _i++) {
          var rounded = Math.floor(heatmap[_i] === UNUSED_SECTOR && ssr !== UNUSED_SECTOR ? ssr : heatmap[_i]);
          totalPainted += rounded !== UNUSED_SECTOR ? 1 : 0;
          if (rounded !== UNUSED_SECTOR) {
            lastUpdate[rounded] = lastUpdate[rounded] ? lastUpdate[rounded] + 1 : 1;
          }
        }
        var entries = Object.entries(lastUpdate).map(function (a) {
          return [parseInt(a[0], 10), a[1]];
        }).sort(function (a, b) {
          return a[0] > b[0] ? 1 : -1;
        });

        // @todo remove it once fixed as described: https://product-fabric.atlassian.net/browse/AFO-3443
        componentsLog = filterComponentsLog[i]({
          componentsLog: componentsLog,
          ttai: ttai
        });
        var _VCCalculationMethods = VCCalculationMethods[i]({
            VCParts: VCParts,
            componentsLog: componentsLog,
            entries: entries,
            totalPainted: totalPainted
          }),
          VC = _VCCalculationMethods.VC,
          VCBox = _VCCalculationMethods.VCBox;
        var VCEntries = entries.reduce(function (acc, _ref5, i) {
          var _acc$abs, _componentsLog$timest;
          var _ref6 = _slicedToArray(_ref5, 2),
            timestamp = _ref6[0],
            entryPainted = _ref6[1];
          var currentlyPainted = entryPainted + (((_acc$abs = acc.abs[i - 1]) === null || _acc$abs === void 0 ? void 0 : _acc$abs[1]) || 0);
          var currentlyPaintedRatio = Math.round(currentlyPainted / totalPainted * 1000) / 10;
          var logEntry = (_componentsLog$timest = componentsLog[timestamp]) === null || _componentsLog$timest === void 0 ? void 0 : _componentsLog$timest.map(function (v) {
            return v.targetName;
          });
          acc.abs.push([timestamp, currentlyPainted]);
          acc.rel.push({
            time: timestamp,
            vc: currentlyPaintedRatio,
            elements: logEntry
          });
          return acc;
        }, {
          abs: [],
          rel: []
        });
        return {
          VC: VC,
          VCBox: VCBox,
          VCEntries: VCEntries,
          totalPainted: totalPainted
        };
      });
    }
  }, {
    key: "applyChangesToHeatMap",
    value: function applyChangesToHeatMap(a, time, classification) {
      var l = a.l,
        t = a.t,
        r = a.r,
        b = a.b;
      var size = classification.length;
      for (var row = t; row < b; row++) {
        if (this.heatmaps[0][row] === undefined) {
          try {
            return {
              error: "index - ".concat(row),
              time: time
            };
          } catch (e) {
            return {
              error: 'row error',
              time: time
            };
          }
        } else {
          for (var heatmapIndex = 0; heatmapIndex < size; heatmapIndex++) {
            if (classification[heatmapIndex]) {
              this.heatmaps[heatmapIndex].fill(time, this.getIndex(l, row), this.getIndex(r, row));
            }
          }
        }
      }
      return true;
    }
  }, {
    key: "getIndex",
    value: function getIndex(x, y) {
      return x + this.arraySize.w * y;
    }
  }, {
    key: "getCleanHeatmap",
    value: function getCleanHeatmap() {
      return new Int32Array(this.arraySize.w * this.arraySize.h);
    }
  }]);
}();
_defineProperty(MultiRevisionHeatmap, "makeVCReturnObj", withProfiling(function makeVCReturnObj(VCParts) {
  var vc = {};
  VCParts.forEach(function (v) {
    vc[v] = null;
  });
  return vc;
}, ['vc']));