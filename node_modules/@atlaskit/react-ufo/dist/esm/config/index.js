import { withProfiling } from '../self-measurements';
var config;

// Defensively typed, since this is directly user-editable
// and they could delete empty members

export var setUFOConfig = withProfiling(function setUFOConfig(newConfig) {
  config = newConfig;
});
export var getConfig = withProfiling(function getConfig() {
  return config;
});
export var getInteractionRate = withProfiling(function getInteractionRate(name, interactionKind) {
  try {
    if (!config) {
      return 0;
    }
    var _config = config,
      killswitch = _config.killswitch,
      rates = _config.rates,
      rules = _config.rules,
      kind = _config.kind,
      autoGeneratedRate = _config.autoGeneratedRate;
    if (killswitch != null) {
      // Specifically kill certain events
      if (killswitch.includes(name)) {
        return 0;
      }
    }
    if (rates != null) {
      // Decide the rate explicitly
      if (rates[name] != null) {
        return rates[name];
      }
    }
    if (rules != null) {
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var test = rule.test,
          rate = rule.rate;
        if (test != null && rate != null) {
          var regexp = new RegExp(test, 'ig');
          if (regexp.test(name)) {
            return rate;
          }
        }
      }
    }
    var isAutogenerated = name === null || name === void 0 ? void 0 : name.startsWith('auto-generated');
    if (isAutogenerated) {
      var _rate = autoGeneratedRate;
      if (_rate != null) {
        return _rate;
      }
    }
    if (kind != null) {
      var _rate2 = kind[interactionKind];
      if (_rate2 != null) {
        return _rate2;
      }
    }
    return 0;
  } catch (e) {
    // Fallback
    return 0;
  }
});
export var getExperimentalInteractionRate = withProfiling(function getExperimentalInteractionRate(name, interactionType) {
  try {
    if (!config) {
      return 0;
    }
    var _config2 = config,
      experimentalInteractionMetrics = _config2.experimentalInteractionMetrics;
    if (!(experimentalInteractionMetrics !== null && experimentalInteractionMetrics !== void 0 && experimentalInteractionMetrics.enabled)) {
      return 0;
    }
    if (experimentalInteractionMetrics.rates && typeof experimentalInteractionMetrics.rates[name] === 'number') {
      return experimentalInteractionMetrics.rates[name];
    }
    if (experimentalInteractionMetrics.kind && typeof experimentalInteractionMetrics.kind[interactionType] === 'number') {
      return experimentalInteractionMetrics.kind[interactionType];
    }
    return 0;
  } catch (e) {
    return 0;
  }
});
export var getPostInteractionRate = withProfiling(function getPostInteractionRate(name, interactionType) {
  try {
    if (!config) {
      return 0;
    }
    var _config3 = config,
      postInteractionLog = _config3.postInteractionLog;
    if (!(postInteractionLog !== null && postInteractionLog !== void 0 && postInteractionLog.enabled)) {
      return 0;
    }
    if (postInteractionLog.rates && typeof postInteractionLog.rates[name] === 'number') {
      return postInteractionLog.rates[name];
    }
    if (postInteractionLog.kind && typeof postInteractionLog.kind[interactionType] === 'number') {
      return postInteractionLog.kind[interactionType];
    }
    return 0;
  } catch (e) {
    return 0;
  }
});
export var getCapabilityRate = withProfiling(function getCapabilityRate(capability) {
  try {
    if (!config) {
      return 0;
    }
    var _config4 = config,
      capabilityRate = _config4.capability;
    if (capabilityRate != null) {
      var rate = capabilityRate[capability];
      if (rate != null) {
        return rate;
      }
    }
    return 0;
  } catch (_unused) {
    return 0;
  }
});
var validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'];
export var getTypingPerformanceTracingMethod = withProfiling(function getTypingPerformanceTracingMethod() {
  var defaultMethod = 'timeout';
  try {
    if (!config) {
      return defaultMethod;
    }
    var _config5 = config,
      typingMethod = _config5.typingMethod;
    if (typingMethod != null && validTypingMethods.find(function (m) {
      return m === typingMethod;
    })) {
      return typingMethod;
    } else {
      return defaultMethod;
    }
  } catch (e) {
    return defaultMethod;
  }
});

// Will ask UFO to wait for BM3 TTI for all events on this list
export var getAwaitBM3TTIList = withProfiling(function getAwaitBM3TTIList() {
  try {
    if (!config) {
      return [];
    }
    var _config6 = config,
      awaitBM3TTI = _config6.awaitBM3TTI;
    if (awaitBM3TTI != null) {
      return awaitBM3TTI;
    } else {
      return [];
    }
  } catch (e) {
    return [];
  }
});

// Flag to remove ufo segments prefixes
export var getRemovePageSegmentsUFOPrefixes = withProfiling(function getRemovePageSegmentsUFOPrefixes() {
  try {
    if (!config) {
      return false;
    }
    var _config7 = config,
      removePageSegmentsUFOPrefixes = _config7.removePageSegmentsUFOPrefixes;
    if (removePageSegmentsUFOPrefixes != null) {
      return removePageSegmentsUFOPrefixes;
    } else {
      return false;
    }
  } catch (e) {
    return false;
  }
});

// Flag to remove ufo segments prefixes
export var getRemoveInteractionsUFOPrefixes = withProfiling(function getRemoveInteractionsUFOPrefixes() {
  try {
    if (!config) {
      return false;
    }
    var _config8 = config,
      removeInteractionsUFOPrefixes = _config8.removeInteractionsUFOPrefixes;
    if (removeInteractionsUFOPrefixes != null) {
      return removeInteractionsUFOPrefixes;
    } else {
      return false;
    }
  } catch (e) {
    return false;
  }
});

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export var getUfoNameOverrides = withProfiling(function getUfoNameOverrides() {
  try {
    if (!config) {
      return undefined;
    }
    var _config9 = config,
      ufoNameOverrides = _config9.ufoNameOverrides;
    if (ufoNameOverrides != null) {
      return ufoNameOverrides;
    }
    return undefined;
  } catch (e) {
    return undefined;
  }
});

// Contains the list of interactions that do not abort existing known interactions
export var getDoNotAbortActivePressInteraction = withProfiling(function getDoNotAbortActivePressInteraction() {
  try {
    if (!config) {
      return undefined;
    }
    var _config10 = config,
      doNotAbortActivePressInteraction = _config10.doNotAbortActivePressInteraction;
    return doNotAbortActivePressInteraction;
  } catch (e) {
    return undefined;
  }
});

// Contains the list of interactions that do not abort on transitions
export var getDoNotAbortActivePressInteractionOnTransition = withProfiling(function getDoNotAbortActivePressInteractionOnTransition() {
  try {
    if (!config) {
      return undefined;
    }
    var _config11 = config,
      doNotAbortActivePressInteractionOnTransition = _config11.doNotAbortActivePressInteractionOnTransition;
    return doNotAbortActivePressInteractionOnTransition;
  } catch (e) {
    return undefined;
  }
});
export var shouldHandleEditorLnv = withProfiling(function shouldHandleEditorLnv() {
  try {
    var _config$enableEditorL, _config12;
    return (_config$enableEditorL = (_config12 = config) === null || _config12 === void 0 ? void 0 : _config12.enableEditorLnvHandler) !== null && _config$enableEditorL !== void 0 ? _config$enableEditorL : false;
  } catch (e) {
    return false;
  }
});