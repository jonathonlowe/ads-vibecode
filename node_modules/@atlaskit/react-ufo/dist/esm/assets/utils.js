import { withProfiling } from '../self-measurements';

/* Borrowed from https://bitbucket.org/atlassian/atlassian-frontend/src/master/packages/performance/browser-metrics/src/plugins/timings/resource.ts */
export var cacheableTypes = ['script', 'link', 'other'];
export var MEMORY_KEY = 'mem';
export var DISK_KEY = 'disk';
export var NETWORK_KEY = 'net';
export var calculateTransferType = withProfiling(function calculateTransferType(name, type, duration, size) {
  if (!cacheableTypes.includes(type) && !(type === 'other' && name.includes('.js'))) {
    return null;
  }
  if ((size === undefined || size === 0) && duration === 0) {
    return MEMORY_KEY;
  }
  if (size === 0 && duration > 0) {
    return DISK_KEY;
  }
  if (size === undefined) {
    return null;
  }
  return NETWORK_KEY;
});
export var getTypeOfRequest = withProfiling(function getTypeOfRequest(_ref) {
  var name = _ref.name,
    type = _ref.initiatorType;
  var category = 'other';
  var urlWithoutQuery = name.split('?')[0];
  switch (type) {
    case 'script':
      category = 'js';
      break;
    case 'link':
      if (urlWithoutQuery.endsWith('.css')) {
        category = 'css';
      }
      if (urlWithoutQuery.endsWith('.js')) {
        category = 'js';
      }
      break;
    case 'img':
      category = 'image';
      break;
    case 'font':
      category = 'font';
      break;
    default:
      if (urlWithoutQuery.endsWith('.js')) {
        category = 'js';
      } else if (urlWithoutQuery.endsWith('.css')) {
        category = 'css';
      } else if (urlWithoutQuery.match(/\.(woff|woff2|ttf|otf)$/)) {
        category = 'font';
      } else if (urlWithoutQuery.match(/\.(png|jpg|jpeg|gif|svg)$/)) {
        category = 'image';
      }
      break;
  }
  return category;
});
export var checkIfTimingsAvailable = withProfiling(function checkIfTimingsAvailable(entry) {
  if (entry.decodedSize === 0 && entry.encodedSize === 0 && entry.requestStart === 0 && entry.responseStart === 0) {
    return false;
  }
  return true;
});
export var round = withProfiling(function round(n) {
  if (isNaN(n)) {
    return 0;
  }
  return Math.round(n * 10000) / 10000;
});