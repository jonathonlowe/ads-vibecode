import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { getConfig } from '../config';
import { withProfiling } from '../self-measurements';
import { VCObserver } from '../vc/vc-observer';
var POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT = 3000;
var PostInteractionLog = /*#__PURE__*/function () {
  function PostInteractionLog() {
    _classCallCheck(this, PostInteractionLog);
    /**
     * Basic info about interaction that has just finished
     */
    _defineProperty(this, "lastInteractionFinish", null);
    /**
     * Array of observed react render timings
     */
    _defineProperty(this, "reactProfilerTimings", []);
    /**
     * Store the scheduled sink timeout Id so that it can be cancelled when needed
     */
    _defineProperty(this, "sinkTimeoutId", null);
    /**
     * independent VC observer, that observes until `custom.post-interaction-logs` event is sent
     */
    _defineProperty(this, "vcObserver", null);
    _defineProperty(this, "vcObserverSSRConfig", null);
    /**
     * Handler function to process / send the observation data
     */
    _defineProperty(this, "sinkHandlerFn", function () {});
    this.initializeVCObserver = withProfiling(this.initializeVCObserver.bind(this));
    this.startVCObserver = withProfiling(this.startVCObserver.bind(this));
    this.setVCObserverSSRConfig = withProfiling(this.setVCObserverSSRConfig.bind(this));
    this.setLastInteractionFinishVCResult = withProfiling(this.setLastInteractionFinishVCResult.bind(this));
    this.reset = withProfiling(this.reset.bind(this));
    this.hasData = withProfiling(this.hasData.bind(this));
    this.sendPostInteractionLog = withProfiling(this.sendPostInteractionLog.bind(this));
    this.onInteractionComplete = withProfiling(this.onInteractionComplete.bind(this));
    this.addProfilerTimings = withProfiling(this.addProfilerTimings.bind(this));
  }
  return _createClass(PostInteractionLog, [{
    key: "initializeVCObserver",
    value: function initializeVCObserver(options) {
      if (this.vcObserver === null) {
        this.vcObserver = new VCObserver(_objectSpread(_objectSpread({}, options), {}, {
          isPostInteraction: true
        }));
      }
    }
  }, {
    key: "startVCObserver",
    value: function startVCObserver(_ref) {
      var _this$vcObserver;
      var startTime = _ref.startTime;
      (_this$vcObserver = this.vcObserver) === null || _this$vcObserver === void 0 || _this$vcObserver.start({
        startTime: startTime
      });
    }
  }, {
    key: "setVCObserverSSRConfig",
    value: function setVCObserverSSRConfig(vcObserverSSRConfig) {
      this.vcObserverSSRConfig = vcObserverSSRConfig;
    }

    /**
     * Set the VC result as per the last interaction
     * Used to compare diffs of VC updates vs post interaction VC observer
     * @param result - VC result as calculated by UFO create payload
     */
  }, {
    key: "setLastInteractionFinishVCResult",
    value: function setLastInteractionFinishVCResult(result) {
      this.lastInteractionFinishVCResult = result;
    }
  }, {
    key: "sinkHandler",
    value:
    /**
     * Set the fn that would be invoked to process / send the observation data
     */
    function sinkHandler(sinkHandlerFn) {
      this.sinkHandlerFn = sinkHandlerFn;
    }

    /**
     * Reset state of the log
     */
  }, {
    key: "reset",
    value: function reset() {
      this.lastInteractionFinish = null;
      this.reactProfilerTimings = [];
      if (this.sinkTimeoutId != null) {
        clearTimeout(this.sinkTimeoutId);
        this.sinkTimeoutId = null;
      }
      this.setVCObserverSSRConfig(null);
    }

    /**
     * Check if there is data in the log
     */
  }, {
    key: "hasData",
    value: function hasData() {
      var _this$reactProfilerTi;
      return ((_this$reactProfilerTi = this.reactProfilerTimings) === null || _this$reactProfilerTi === void 0 ? void 0 : _this$reactProfilerTi.length) > 0;
    }

    /**
     * Send the log if there is data
     */
  }, {
    key: "sendPostInteractionLog",
    value: (function () {
      var _sendPostInteractionLog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$vcObserver3, _getConfig2;
        var _getConfig, _this$vcObserver2, postInteractionFinishVCResult, _this$vcObserver4;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(!this.hasData() || !this.lastInteractionFinish || !this.sinkHandlerFn)) {
                _context.next = 4;
                break;
              }
              this.reset();
              if ((_getConfig = getConfig()) !== null && _getConfig !== void 0 && (_getConfig = _getConfig.experimentalInteractionMetrics) !== null && _getConfig !== void 0 && _getConfig.enabled) {
                (_this$vcObserver2 = this.vcObserver) === null || _this$vcObserver2 === void 0 || _this$vcObserver2.stop();
              }
              return _context.abrupt("return");
            case 4:
              _context.next = 6;
              return (_this$vcObserver3 = this.vcObserver) === null || _this$vcObserver3 === void 0 ? void 0 : _this$vcObserver3.getVCResult(_objectSpread({
                start: this.lastInteractionFinish.start,
                stop: performance.now(),
                tti: -1,
                // no need for TTI value here
                isEventAborted: !!this.lastInteractionFinish.abortReason,
                prefix: 'ufo'
              }, this.vcObserverSSRConfig));
            case 6:
              postInteractionFinishVCResult = _context.sent;
              if ((_getConfig2 = getConfig()) !== null && _getConfig2 !== void 0 && (_getConfig2 = _getConfig2.experimentalInteractionMetrics) !== null && _getConfig2 !== void 0 && _getConfig2.enabled) {
                (_this$vcObserver4 = this.vcObserver) === null || _this$vcObserver4 === void 0 || _this$vcObserver4.stop();
              }
              this.sinkHandlerFn({
                lastInteractionFinish: this.lastInteractionFinish,
                reactProfilerTimings: this.reactProfilerTimings,
                // NOTE: invoking `getVCResult` at latest possible point in time here (not earlier) to get the most accurate result (from performance.now())
                postInteractionFinishVCResult: postInteractionFinishVCResult,
                lastInteractionFinishVCResult: this.lastInteractionFinishVCResult
              });
              this.reset();
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function sendPostInteractionLog() {
        return _sendPostInteractionLog.apply(this, arguments);
      }
      return sendPostInteractionLog;
    }()
    /**
     * This fn should be invoked when an interaction has finished
     * Basic details about the finished interaction will be recorded
     * A timeout will be setup to send the post interaction observation after some time.
     */
    )
  }, {
    key: "onInteractionComplete",
    value: function onInteractionComplete(_ref2) {
      var _getConfig3,
        _this = this;
      var ufoName = _ref2.ufoName,
        start = _ref2.start,
        end = _ref2.end,
        id = _ref2.id,
        abortReason = _ref2.abortReason,
        abortedByInteractionName = _ref2.abortedByInteractionName,
        routeName = _ref2.routeName,
        type = _ref2.type,
        experimentalTTAI = _ref2.experimentalTTAI,
        experimentalVC90 = _ref2.experimentalVC90;
      this.lastInteractionFinish = {
        ufoName: ufoName,
        start: start,
        end: end,
        id: id,
        abortReason: abortReason,
        abortedByInteractionName: abortedByInteractionName,
        routeName: routeName,
        type: type,
        experimentalTTAI: experimentalTTAI,
        experimentalVC90: experimentalVC90
      };
      var timeout = ((_getConfig3 = getConfig()) === null || _getConfig3 === void 0 ? void 0 : _getConfig3.timeWindowForLateMutationsInMilliseconds) || POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT;
      this.sinkTimeoutId = window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this.sendPostInteractionLog();
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      })), timeout);
    }

    /**
     * This fn should be invoked when a React render happens after interaction has finished
     */
  }, {
    key: "addProfilerTimings",
    value: function addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
      if (this.lastInteractionFinish != null) {
        this.reactProfilerTimings.push({
          type: type,
          actualDuration: actualDuration,
          baseDuration: baseDuration,
          startTime: startTime,
          commitTime: commitTime,
          labelStack: labelStack
        });
      }
    }
  }]);
}();
export { PostInteractionLog as default };