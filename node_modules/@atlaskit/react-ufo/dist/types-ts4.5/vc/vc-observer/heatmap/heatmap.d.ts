import type { ComponentsLogType, RevisionPayload, VCEntryType, VCIgnoreReason, VCRatioType } from '../../../common/vc/types';
import type { ObservedMutationType } from '../observers/types';
import type { FilterComponentsLogType, RevisionEntry, VCCalculationMethodType } from '../revisions/types';
type Viewport = {
    w: number;
    h: number;
};
type ArraySize = {
    w: number;
    h: number;
};
type HeatmapAttrs = {
    viewport: Viewport;
    revisions: RevisionEntry[];
    arraySize?: ArraySize;
    devToolsEnabled?: boolean;
};
type Heatmap = Int32Array;
type ProcessDataArgs = {
    VCParts: number[];
    VCCalculationMethods: VCCalculationMethodType[];
    clean: boolean;
    isEventAborted: boolean;
    interactionStart: number;
    ttai: number;
    filterComponentsLog: FilterComponentsLogType[];
    ssr?: number;
};
type PerRevision<T> = T[];
export type ApplyChangesError = {
    error: string;
    time: number;
};
export type HandleUpdateArgs = {
    time: number;
    type: ObservedMutationType;
    classification: boolean[];
    intersectionRect: DOMRectReadOnly;
    element: HTMLElement;
    targetName: string;
    ignoreReason?: VCIgnoreReason;
    onError: (error: ApplyChangesError) => void;
    attributeName?: string | null;
    oldValue?: string | null;
    newValue?: string | null;
};
export declare class MultiRevisionHeatmap {
    viewport: Viewport;
    arraySize: ArraySize;
    revisions: RevisionEntry[];
    heatmaps: Heatmap[];
    devToolsEnabled: boolean;
    vcRatios: PerRevision<VCRatioType>;
    componentsLogs: PerRevision<ComponentsLogType>;
    constructor({ viewport, revisions, arraySize, devToolsEnabled }: HeatmapAttrs);
    handleUpdate({ time, type, classification, intersectionRect, element, targetName, ignoreReason, onError, attributeName, oldValue, newValue, }: HandleUpdateArgs): void;
    getData(): {
        heatmaps: Int32Array[];
    };
    getPayloadShapedData(args: ProcessDataArgs): RevisionPayload;
    processData({ VCParts, VCCalculationMethods, filterComponentsLog, ttai, ssr, }: ProcessDataArgs): {
        VC: import("../revisions/types").VCType;
        VCBox: import("../revisions/types").VCBoxType;
        VCEntries: {
            abs: number[][];
            rel: VCEntryType[];
        };
        totalPainted: number;
    }[];
    private mapPixelsToHeatmap;
    private getElementRatio;
    private applyChangesToHeatMap;
    private getIndex;
    private getCleanHeatmap;
    static makeVCReturnObj: <T>(VCParts: number[]) => {
        [key: string]: T | null;
    };
}
export {};
