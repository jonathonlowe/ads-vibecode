"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SSRPlaceholderHandlers = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _selfMeasurements = require("../../../../self-measurements");
var ANCESTOR_LOOKUP_LIMIT = 10;
var SSRPlaceholderHandlers = exports.SSRPlaceholderHandlers = /*#__PURE__*/function () {
  function SSRPlaceholderHandlers() {
    var _this = this;
    (0, _classCallCheck2.default)(this, SSRPlaceholderHandlers);
    (0, _defineProperty2.default)(this, "staticPlaceholders", new Map());
    (0, _defineProperty2.default)(this, "callbacks", new Map());
    (0, _defineProperty2.default)(this, "getSizeCallbacks", new Map());
    (0, _defineProperty2.default)(this, "reactValidateCallbacks", new Map());
    (0, _defineProperty2.default)(this, "EQUALITY_THRESHOLD", 1);
    (0, _defineProperty2.default)(this, "intersectionObserverCallback", function (_ref) {
      var _this$intersectionObs;
      var target = _ref.target,
        boundingClientRect = _ref.boundingClientRect;
      (_this$intersectionObs = _this.intersectionObserver) === null || _this$intersectionObs === void 0 || _this$intersectionObs.unobserve(target);
      if (!(target instanceof HTMLElement)) {
        // impossible case - keep typescript healthy
        return;
      }
      var staticKey = target.dataset.ssrPlaceholder || '';
      if (staticKey) {
        if (_this.staticPlaceholders.has(staticKey) && _this.callbacks.has(staticKey)) {
          // validation
          var _resolve = _this.callbacks.get(staticKey);
          if (!_resolve) {
            return;
          }
          var rect = _this.staticPlaceholders.get(staticKey);
          var hasSameSizePosition = _this.hasSameSizePosition(rect, boundingClientRect);
          if (hasSameSizePosition || _this.isDummyRect(rect)) {
            _resolve(hasSameSizePosition);
          } else {
            requestAnimationFrame(function () {
              var targetRect = target.getBoundingClientRect();
              var hasSameSizePosition = _this.hasSameSizePosition(rect, targetRect);
              _resolve(hasSameSizePosition);
            });
          }
          _this.callbacks.delete(staticKey);
        }
      } else {
        var key = target.dataset.ssrPlaceholderReplace || '';
        var _resolve2 = _this.reactValidateCallbacks.get(key);
        if (!_resolve2) {
          return;
        }
        var _rect = _this.staticPlaceholders.get(key);
        var _hasSameSizePosition = _this.hasSameSizePosition(_rect, boundingClientRect);
        if (_hasSameSizePosition || _this.isDummyRect(_rect)) {
          _resolve2(_hasSameSizePosition);
        } else {
          requestAnimationFrame(function () {
            var targetRect = target.getBoundingClientRect();
            var hasSameSizePosition = _this.hasSameSizePosition(_rect, targetRect);
            _resolve2(hasSameSizePosition);
          });
        }
        _this.staticPlaceholders.delete(staticKey);
        _this.reactValidateCallbacks.delete(staticKey);
      }
    });
    var operationTimer = (0, _selfMeasurements.markProfilingStart)('SSRPlaceholderHandlers constructor');
    if (typeof IntersectionObserver === 'function') {
      // Only instantiate the IntersectionObserver if it's supported
      this.intersectionObserver = new IntersectionObserver(function (entries) {
        return entries.filter(function (entry) {
          return entry.intersectionRatio > 0;
        }).forEach(_this.intersectionObserverCallback);
      });
    }
    if (window.document) {
      try {
        var existingElements = document.querySelectorAll('[data-ssr-placeholder]');
        existingElements.forEach(function (el) {
          var _el$dataset;
          if (el instanceof HTMLElement && el !== null && el !== void 0 && (_el$dataset = el.dataset) !== null && _el$dataset !== void 0 && _el$dataset.ssrPlaceholder) {
            var _window$__SSR_PLACEHO, _this$intersectionObs2;
            var width = -1;
            var height = -1;
            var x = -1;
            var y = -1;
            var boundingClientRect = (_window$__SSR_PLACEHO = window.__SSR_PLACEHOLDERS_DIMENSIONS__) === null || _window$__SSR_PLACEHO === void 0 ? void 0 : _window$__SSR_PLACEHO[el.dataset.ssrPlaceholder];
            if (boundingClientRect) {
              width = boundingClientRect.width;
              height = boundingClientRect.height;
              x = boundingClientRect.x;
              y = boundingClientRect.y;
            }
            _this.staticPlaceholders.set(el.dataset.ssrPlaceholder, {
              width: width,
              height: height,
              x: x,
              y: y
            });
            (_this$intersectionObs2 = _this.intersectionObserver) === null || _this$intersectionObs2 === void 0 || _this$intersectionObs2.observe(el);
          }
        });
      } catch (e) {} finally {
        delete window.__SSR_PLACEHOLDERS_DIMENSIONS__;
      }
    }
    this.clear = (0, _selfMeasurements.withProfiling)(this.clear.bind(this), ['vc']);
    this.isPlaceholder = (0, _selfMeasurements.withProfiling)(this.isPlaceholder.bind(this), ['vc']);
    this.isPlaceholderReplacement = (0, _selfMeasurements.withProfiling)(this.isPlaceholderReplacement.bind(this), ['vc']);
    this.isPlaceholderIgnored = (0, _selfMeasurements.withProfiling)(this.isPlaceholderIgnored.bind(this), ['vc']);
    this.findNearestPlaceholderContainerIfIgnored = (0, _selfMeasurements.withProfiling)(this.findNearestPlaceholderContainerIfIgnored.bind(this), ['vc']);
    this.checkIfExistedAndSizeMatching = (0, _selfMeasurements.withProfiling)(this.checkIfExistedAndSizeMatching.bind(this), ['vc']);
    this.getSize = (0, _selfMeasurements.withProfiling)(this.getSize.bind(this), ['vc']);
    this.validateReactComponentMatchToPlaceholder = (0, _selfMeasurements.withProfiling)(this.validateReactComponentMatchToPlaceholder.bind(this), ['vc']);
    this.hasSameSizePosition = (0, _selfMeasurements.withProfiling)(this.hasSameSizePosition.bind(this), ['vc']);
    this.isDummyRect = (0, _selfMeasurements.withProfiling)(this.isDummyRect.bind(this), ['vc']);
    this.intersectionObserverCallback = (0, _selfMeasurements.withProfiling)(this.intersectionObserverCallback.bind(this), ['vc']);
    (0, _selfMeasurements.markProfilingEnd)(operationTimer, {
      tags: ['vc']
    });
  }
  return (0, _createClass2.default)(SSRPlaceholderHandlers, [{
    key: "clear",
    value: function clear() {
      this.staticPlaceholders = new Map();
      this.callbacks = new Map();
      this.getSizeCallbacks = new Map();
      this.reactValidateCallbacks = new Map();
    }
  }, {
    key: "isPlaceholder",
    value: function isPlaceholder(element) {
      return Boolean(element.dataset.ssrPlaceholder);
    }
  }, {
    key: "isPlaceholderReplacement",
    value: function isPlaceholderReplacement(element) {
      return Boolean(element.dataset.ssrPlaceholderReplace);
    }
  }, {
    key: "isPlaceholderIgnored",
    value: function isPlaceholderIgnored(element) {
      // data-ssr-placeholder-ignored doesn't have a value.
      return 'ssrPlaceholderIgnored' in element.dataset;
    }
  }, {
    key: "findNearestPlaceholderContainerIfIgnored",
    value: function findNearestPlaceholderContainerIfIgnored(element) {
      if (!this.isPlaceholderIgnored(element)) {
        return element;
      }
      var ancestor = element.parentElement;
      var i = 0;
      while (ancestor && i < ANCESTOR_LOOKUP_LIMIT) {
        if (this.isPlaceholder(ancestor) || this.isPlaceholderReplacement(ancestor)) {
          return ancestor;
        }
        ancestor = ancestor.parentElement;
        i++;
      }
      return element;
    }
  }, {
    key: "checkIfExistedAndSizeMatching",
    value: function checkIfExistedAndSizeMatching(el) {
      var _this2 = this;
      el = this.findNearestPlaceholderContainerIfIgnored(el);
      var id = el.dataset.ssrPlaceholder || '';
      return new Promise(function (resolve) {
        if (!_this2.staticPlaceholders.has(id)) {
          resolve(false);
          return;
        } else {
          var _this2$intersectionOb;
          _this2.callbacks.set(id, resolve);
          (_this2$intersectionOb = _this2.intersectionObserver) === null || _this2$intersectionOb === void 0 || _this2$intersectionOb.observe(el);
        }
      });
    }
  }, {
    key: "getSize",
    value: function getSize(el) {
      var _this3 = this;
      return new Promise(function (resolve) {
        var _this3$intersectionOb;
        _this3.getSizeCallbacks.set(el.dataset.ssrPlaceholder || '', resolve);
        (_this3$intersectionOb = _this3.intersectionObserver) === null || _this3$intersectionOb === void 0 || _this3$intersectionOb.observe(el);
      });
    }
  }, {
    key: "validateReactComponentMatchToPlaceholder",
    value: function validateReactComponentMatchToPlaceholder(el) {
      var _this4 = this;
      el = this.findNearestPlaceholderContainerIfIgnored(el);
      var id = el.dataset.ssrPlaceholderReplace || '';
      return new Promise(function (resolve) {
        if (!_this4.staticPlaceholders.has(id)) {
          resolve(false);
          return;
        } else {
          var _this4$intersectionOb;
          _this4.reactValidateCallbacks.set(id, resolve);
          (_this4$intersectionOb = _this4.intersectionObserver) === null || _this4$intersectionOb === void 0 || _this4$intersectionOb.observe(el);
        }
      });
    }
  }, {
    key: "hasSameSizePosition",
    value: function hasSameSizePosition(rect, boundingClientRect) {
      return rect && Math.abs(rect.x - boundingClientRect.x) < this.EQUALITY_THRESHOLD && Math.abs(rect.y - boundingClientRect.y) < this.EQUALITY_THRESHOLD && Math.abs(rect.width - boundingClientRect.width) < this.EQUALITY_THRESHOLD && Math.abs(rect.height - boundingClientRect.height) < this.EQUALITY_THRESHOLD || false;
    }
  }, {
    key: "isDummyRect",
    value: function isDummyRect(rect) {
      return rect && rect.width < 0 && rect.height < 0 || false;
    }
  }]);
}();