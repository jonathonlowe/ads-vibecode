"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVCRevisionsData = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _hiddenTiming = require("../../hidden-timing");
var _selfMeasurements = require("../../self-measurements");
var _revisions = require("./revisions/revisions");
var VCParts = ['25', '50', '75', '80', '85', '90', '95', '98', '99'];
var READONLY_EMPTY_ARRAY = Array.from({
  length: 0
});

// Helper function to create vcDetails object to avoid code duplication
var createVCDetails = (0, _selfMeasurements.withProfiling)(function createVCDetails(calculatedVC, shouldHaveVCmetric) {
  if (!shouldHaveVCmetric || !calculatedVC || !calculatedVC.VC || !calculatedVC.VCBox) {
    return {};
  }
  var details = {};
  var VC = calculatedVC.VC,
    VCBox = calculatedVC.VCBox; // Destructure once to avoid repeated property access

  for (var _i = 0, _VCParts = VCParts; _i < _VCParts.length; _i++) {
    var key = _VCParts[_i];
    details[key] = {
      t: VC[key],
      e: VCBox[key] || READONLY_EMPTY_ARRAY
    };
  }
  return details;
}, ['vc']);

// Optimized implementation (current one)
var getVCRevisionsData = exports.getVCRevisionsData = (0, _selfMeasurements.withProfiling)(function getVCRevisionsData(_ref) {
  var fullPrefix = _ref.fullPrefix,
    interaction = _ref.interaction,
    isVCClean = _ref.isVCClean,
    isEventAborted = _ref.isEventAborted,
    multiHeatmap = _ref.multiHeatmap,
    ssr = _ref.ssr,
    calculatedVC = _ref.calculatedVC,
    calculatedVCNext = _ref.calculatedVCNext;
  if (!(0, _platformFeatureFlags.fg)('platform_ufo_vc_observer_new')) {
    if (!multiHeatmap) {
      return null;
    }
    return (0, _defineProperty2.default)({}, "".concat(fullPrefix, "vc:rev"), multiHeatmap === null || multiHeatmap === void 0 ? void 0 : multiHeatmap.getPayloadShapedData({
      VCParts: VCParts.map(function (v) {
        return parseInt(v);
      }),
      VCCalculationMethods: (0, _revisions.getRevisions)().map(function (_ref2) {
        var classifier = _ref2.classifier;
        return classifier.VCCalculationMethod;
      }),
      filterComponentsLog: (0, _revisions.getRevisions)().map(function (_ref3) {
        var classifier = _ref3.classifier;
        return classifier.filterComponentsLog;
      }),
      isEventAborted: isEventAborted,
      interactionStart: interaction.start,
      ttai: interaction.end,
      ssr: ssr,
      clean: isVCClean
    }));
  }

  // Calculate these conditions once
  var pageVisibilityUpToTTAI = (0, _hiddenTiming.getPageVisibilityState)(interaction.start, interaction.end);
  var isVisiblePageVisibleUpToTTAI = pageVisibilityUpToTTAI === 'visible';
  var shouldHaveVCmetric = isVCClean && !isEventAborted && isVisiblePageVisibleUpToTTAI;

  // Create the V2 revision object which is always needed
  var ttvcV2Revision = {
    revision: 'fy25.02',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVCNext.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVCNext, shouldHaveVCmetric)
  };
  if ((0, _platformFeatureFlags.fg)('platform_ufo_disable_ttvc_v1')) {
    return (0, _defineProperty2.default)({}, "".concat(fullPrefix, "vc:rev"), [ttvcV2Revision]);
  }

  // Only create ttvcV1Revision when we're actually going to use it
  var ttvcV1Revision = {
    revision: 'fy25.01',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVC.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVC, shouldHaveVCmetric)
  };
  return (0, _defineProperty2.default)({}, "".concat(fullPrefix, "vc:rev"), [ttvcV1Revision, ttvcV2Revision]);
}, ['vc']);