import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { getConfig } from '../config';
import { withProfiling } from '../self-measurements';
import { VCObserver } from '../vc/vc-observer';
const POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT = 3000;
export default class PostInteractionLog {
  constructor() {
    /**
     * Basic info about interaction that has just finished
     */
    _defineProperty(this, "lastInteractionFinish", null);
    /**
     * Array of observed react render timings
     */
    _defineProperty(this, "reactProfilerTimings", []);
    /**
     * Store the scheduled sink timeout Id so that it can be cancelled when needed
     */
    _defineProperty(this, "sinkTimeoutId", null);
    /**
     * independent VC observer, that observes until `custom.post-interaction-logs` event is sent
     */
    _defineProperty(this, "vcObserver", null);
    _defineProperty(this, "vcObserverSSRConfig", null);
    /**
     * Handler function to process / send the observation data
     */
    _defineProperty(this, "sinkHandlerFn", () => {});
    this.initializeVCObserver = withProfiling(this.initializeVCObserver.bind(this));
    this.startVCObserver = withProfiling(this.startVCObserver.bind(this));
    this.setVCObserverSSRConfig = withProfiling(this.setVCObserverSSRConfig.bind(this));
    this.setLastInteractionFinishVCResult = withProfiling(this.setLastInteractionFinishVCResult.bind(this));
    this.reset = withProfiling(this.reset.bind(this));
    this.hasData = withProfiling(this.hasData.bind(this));
    this.sendPostInteractionLog = withProfiling(this.sendPostInteractionLog.bind(this));
    this.onInteractionComplete = withProfiling(this.onInteractionComplete.bind(this));
    this.addProfilerTimings = withProfiling(this.addProfilerTimings.bind(this));
  }
  initializeVCObserver(options) {
    if (this.vcObserver === null) {
      this.vcObserver = new VCObserver({
        ...options,
        isPostInteraction: true
      });
    }
  }
  startVCObserver({
    startTime
  }) {
    var _this$vcObserver;
    (_this$vcObserver = this.vcObserver) === null || _this$vcObserver === void 0 ? void 0 : _this$vcObserver.start({
      startTime
    });
  }
  setVCObserverSSRConfig(vcObserverSSRConfig) {
    this.vcObserverSSRConfig = vcObserverSSRConfig;
  }

  /**
   * Set the VC result as per the last interaction
   * Used to compare diffs of VC updates vs post interaction VC observer
   * @param result - VC result as calculated by UFO create payload
   */
  setLastInteractionFinishVCResult(result) {
    this.lastInteractionFinishVCResult = result;
  }
  /**
   * Set the fn that would be invoked to process / send the observation data
   */
  sinkHandler(sinkHandlerFn) {
    this.sinkHandlerFn = sinkHandlerFn;
  }

  /**
   * Reset state of the log
   */
  reset() {
    this.lastInteractionFinish = null;
    this.reactProfilerTimings = [];
    if (this.sinkTimeoutId != null) {
      clearTimeout(this.sinkTimeoutId);
      this.sinkTimeoutId = null;
    }
    this.setVCObserverSSRConfig(null);
  }

  /**
   * Check if there is data in the log
   */
  hasData() {
    var _this$reactProfilerTi;
    return ((_this$reactProfilerTi = this.reactProfilerTimings) === null || _this$reactProfilerTi === void 0 ? void 0 : _this$reactProfilerTi.length) > 0;
  }

  /**
   * Send the log if there is data
   */
  async sendPostInteractionLog() {
    var _this$vcObserver3, _getConfig2, _getConfig2$experimen;
    if (!this.hasData() || !this.lastInteractionFinish || !this.sinkHandlerFn) {
      var _getConfig, _getConfig$experiment;
      this.reset();
      if ((_getConfig = getConfig()) !== null && _getConfig !== void 0 && (_getConfig$experiment = _getConfig.experimentalInteractionMetrics) !== null && _getConfig$experiment !== void 0 && _getConfig$experiment.enabled) {
        var _this$vcObserver2;
        (_this$vcObserver2 = this.vcObserver) === null || _this$vcObserver2 === void 0 ? void 0 : _this$vcObserver2.stop();
      }
      return;
    }
    const postInteractionFinishVCResult = await ((_this$vcObserver3 = this.vcObserver) === null || _this$vcObserver3 === void 0 ? void 0 : _this$vcObserver3.getVCResult({
      start: this.lastInteractionFinish.start,
      stop: performance.now(),
      tti: -1,
      // no need for TTI value here
      isEventAborted: !!this.lastInteractionFinish.abortReason,
      prefix: 'ufo',
      ...this.vcObserverSSRConfig
    }));
    if ((_getConfig2 = getConfig()) !== null && _getConfig2 !== void 0 && (_getConfig2$experimen = _getConfig2.experimentalInteractionMetrics) !== null && _getConfig2$experimen !== void 0 && _getConfig2$experimen.enabled) {
      var _this$vcObserver4;
      (_this$vcObserver4 = this.vcObserver) === null || _this$vcObserver4 === void 0 ? void 0 : _this$vcObserver4.stop();
    }
    this.sinkHandlerFn({
      lastInteractionFinish: this.lastInteractionFinish,
      reactProfilerTimings: this.reactProfilerTimings,
      // NOTE: invoking `getVCResult` at latest possible point in time here (not earlier) to get the most accurate result (from performance.now())
      postInteractionFinishVCResult,
      lastInteractionFinishVCResult: this.lastInteractionFinishVCResult
    });
    this.reset();
  }

  /**
   * This fn should be invoked when an interaction has finished
   * Basic details about the finished interaction will be recorded
   * A timeout will be setup to send the post interaction observation after some time.
   */
  onInteractionComplete({
    ufoName,
    start,
    end,
    id,
    abortReason,
    abortedByInteractionName,
    routeName,
    type,
    experimentalTTAI,
    experimentalVC90
  }) {
    var _getConfig3;
    this.lastInteractionFinish = {
      ufoName,
      start,
      end,
      id,
      abortReason,
      abortedByInteractionName,
      routeName,
      type,
      experimentalTTAI,
      experimentalVC90
    };
    const timeout = ((_getConfig3 = getConfig()) === null || _getConfig3 === void 0 ? void 0 : _getConfig3.timeWindowForLateMutationsInMilliseconds) || POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT;
    this.sinkTimeoutId = window.setTimeout(async () => {
      await this.sendPostInteractionLog();
    }, timeout);
  }

  /**
   * This fn should be invoked when a React render happens after interaction has finished
   */
  addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
    if (this.lastInteractionFinish != null) {
      this.reactProfilerTimings.push({
        type,
        actualDuration,
        baseDuration,
        startTime,
        commitTime,
        labelStack
      });
    }
  }
}