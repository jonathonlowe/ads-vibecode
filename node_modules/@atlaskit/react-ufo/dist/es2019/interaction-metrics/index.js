import { v4 as createUUID } from 'uuid';
import coinflip from '../coinflip';
import { getAwaitBM3TTIList, getCapabilityRate, getConfig } from '../config';
import { experimentalVC, getExperimentalVCMetrics, onExperimentalInteractionComplete } from '../create-experimental-interaction-metrics-payload';
import { clearActiveTrace } from '../experience-trace-id-context';
import { allFeatureFlagsAccessed, currentFeatureFlagsAccessed } from '../feature-flags-accessed';
import { getInteractionId } from '../interaction-id-context';
import { withProfiling } from '../self-measurements';
import { getVCObserver } from '../vc';
import { interactions } from './common/constants';
import PostInteractionLog from './post-interaction-log';
const PreviousInteractionLog = {
  name: undefined,
  isAborted: undefined
};
export const postInteractionLog = new PostInteractionLog();
const interactionQueue = [];
const segmentCache = new Map();
const CLEANUP_TIMEOUT = 60 * 1000;
const CLEANUP_TIMEOUT_AFTER_APDEX = 15 * 1000;
const segmentObservers = [];
export const getActiveInteraction = withProfiling(function getActiveInteraction() {
  const interactionId = getInteractionId();
  if (!interactionId.current) {
    return;
  }
  return interactions.get(interactionId.current);
});
const isPerformanceTracingEnabled = withProfiling(function isPerformanceTracingEnabled() {
  var _getConfig;
  return ((_getConfig = getConfig()) === null || _getConfig === void 0 ? void 0 : _getConfig.enableAdditionalPerformanceMarks) || window.__REACT_UFO_ENABLE_PERF_TRACING || process.env.NODE_ENV !== 'production';
});
const labelStackToString = withProfiling(function labelStackToString(labelStack, name) {
  var _stack$map;
  const stack = [...(labelStack !== null && labelStack !== void 0 ? labelStack : [])];
  if (name) {
    stack.push({
      name
    });
  }
  return (_stack$map = stack.map(l => l.name)) === null || _stack$map === void 0 ? void 0 : _stack$map.join('/');
});
const labelStackToIdString = withProfiling(function labelStackToIdString(labelStack) {
  var _labelStack$map;
  return labelStack === null || labelStack === void 0 ? void 0 : (_labelStack$map = labelStack.map(l => 'segmentId' in l ? `${l.name}:${l.segmentId}` : `${l.name}`)) === null || _labelStack$map === void 0 ? void 0 : _labelStack$map.join('/');
});
const addSegmentObserver = withProfiling(function addSegmentObserver(observer) {
  segmentObservers.push(observer);
  for (const segmentInfo of segmentCache.values()) {
    observer.onAdd(segmentInfo);
  }
});
const removeSegmentObserver = withProfiling(function removeSegmentObserver(observer) {
  const index = segmentObservers.findIndex(obs => obs === observer);
  if (index !== -1) {
    segmentObservers.splice(index, 1);
  }
});
export const remove = withProfiling(function remove(interactionId) {
  interactions.delete(interactionId);
});
export const updatePageLoadInteractionName = withProfiling(function updatePageLoadInteractionName(ufoName, routeName = ufoName) {
  const interaction = getActiveInteraction();
  if (!interaction || interaction.type !== 'page_load' && interaction.type !== 'transition') {
    return;
  }
  interaction.ufoName = ufoName;
  interaction.routeName = routeName;
});
export const addMetadata = withProfiling(function addMetadata(interactionId, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(key => {
      interaction.metaData[key] = data[key];
    });
  }
});
export const addCustomData = withProfiling(function addCustomData(interactionId, labelStack, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(i => {
      interaction.customData.push({
        labelStack,
        data: {
          [i]: data[i]
        }
      });
    });
  }
});
export const addCustomTiming = withProfiling(function addCustomTiming(interactionId, labelStack, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.customTimings.push({
      labelStack,
      data
    });
    if (isPerformanceTracingEnabled()) {
      for (const [key, timingData] of Object.entries(data)) {
        const {
          startTime,
          endTime
        } = timingData;
        try {
          // for Firefox 102 and older
          performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, key)} [custom_timing]`, {
            start: startTime,
            end: endTime
          });
        } catch (e) {
          // do nothing
        }
      }
    }
  }
});
export const addMark = withProfiling(function addMark(interactionId, type, name, labelStack, time = performance.now()) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.marks.push({
      type,
      name,
      labelStack,
      time
    });
  }
  if (isPerformanceTracingEnabled()) {
    performance.mark(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
      startTime: time
    });
  }
});
export const addMarkToAll = withProfiling(function addMarkToAll(type, name, labelStack, time = performance.now()) {
  interactions.forEach(interaction => {
    interaction.marks.push({
      type,
      name,
      labelStack,
      time
    });
  });
  if (isPerformanceTracingEnabled()) {
    performance.mark(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
      startTime: time
    });
  }
});
export const addSpan = withProfiling(function addSpan(interactionId, type, name, labelStack, start, end = performance.now(), size) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.spans.push({
      type,
      name,
      labelStack,
      start,
      end,
      size
    });
    if (isPerformanceTracingEnabled()) {
      try {
        // for Firefox 102 and older
        performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
          start,
          end
        });
      } catch (e) {
        // do nothing
      }
    }
  }
});
export const addSpanToAll = withProfiling(function addSpanToAll(type, name, labelStack, start, end = performance.now(), size = 0) {
  interactions.forEach(interaction => {
    interaction.spans.push({
      type,
      name,
      labelStack,
      start,
      end,
      size
    });
  });
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
        start,
        end
      });
    } catch (e) {
      // do nothing
    }
  }
});
export const addPreload = withProfiling(function addPreload(moduleId, timestamp) {
  addMarkToAll('bundle_preload', moduleId, null, timestamp);
});
export const addLoad = withProfiling(function addLoad(identifier, start, end) {
  addSpanToAll('bundle_load', identifier, null, start, end - start);
});
const moduleLoadingRequests = {};
export const extractModuleName = withProfiling(function extractModuleName(input) {
  let result = input !== null && input !== void 0 ? input : '';
  result = result.replace(/^\.\/src\/packages\//, '');
  result = result.replace(/^\.\/node_modules\//, '');
  result = result.replace(/(\/src)?\/(index|main)\.(tsx|ts|js|jsx)$/, '');
  return result;
});
const addHoldCriterion = withProfiling(function addHoldCriterion(id, labelStack, name, startTime) {
  var _window$__CRITERION__;
  if (!((_window$__CRITERION__ = window.__CRITERION__) !== null && _window$__CRITERION__ !== void 0 && _window$__CRITERION__.addUFOHold)) {
    return;
  }
  window.__CRITERION__.addUFOHold(id, labelStackToString(labelStack), name, startTime);
});
const removeHoldCriterion = withProfiling(function removeHoldCriterion(id) {
  var _window$__CRITERION__2;
  if (!((_window$__CRITERION__2 = window.__CRITERION__) !== null && _window$__CRITERION__2 !== void 0 && _window$__CRITERION__2.removeUFOHold)) {
    return;
  }
  window.__CRITERION__.removeUFOHold(id);
});
export const addHold = withProfiling(function addHold(interactionId, labelStack, name, experimental) {
  const interaction = interactions.get(interactionId);
  const id = createUUID();
  if (interaction != null) {
    var _getConfig2, _getConfig2$experimen;
    const start = performance.now();
    const holdActive = {
      labelStack,
      name,
      start
    };
    if ((_getConfig2 = getConfig()) !== null && _getConfig2 !== void 0 && (_getConfig2$experimen = _getConfig2.experimentalInteractionMetrics) !== null && _getConfig2$experimen !== void 0 && _getConfig2$experimen.enabled && experimental) {
      interaction.holdExpActive.set(id, {
        ...holdActive,
        start
      });
    }
    if (!experimental) {
      interaction.holdActive.set(id, {
        ...holdActive,
        start
      });
    }
    addHoldCriterion(id, labelStack, name, start);
    return () => {
      const end = performance.now();
      if (isPerformanceTracingEnabled()) {
        try {
          // for Firefox 102 and older
          performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [hold]`, {
            start,
            end
          });
        } catch (e) {
          // do nothing
        }
      }
      removeHoldCriterion(id);
      const currentInteraction = interactions.get(interactionId);
      const currentHold = interaction.holdActive.get(id);
      const expHold = interaction.holdExpActive.get(id);
      if (currentInteraction != null) {
        if (currentHold != null) {
          currentInteraction.holdInfo.push({
            ...currentHold,
            end
          });
          interaction.holdActive.delete(id);
        }
        if (expHold != null) {
          currentInteraction.holdExpInfo.push({
            ...expHold,
            end
          });
          interaction.holdExpActive.delete(id);
        }
      }
    };
  }
  return () => {};
});
export const addHoldByID = withProfiling(function addHoldByID(interactionId, labelStack, name, id, ignoreOnSubmit) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const start = performance.now();
    interaction.holdActive.set(id, {
      labelStack,
      name,
      start,
      ignoreOnSubmit
    });
    addHoldCriterion(id, labelStack, name, start);
  }
  return () => {};
});
export const removeHoldByID = withProfiling(function removeHoldByID(interactionId, id) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const end = performance.now();
    const currentInteraction = interactions.get(interactionId);
    const currentHold = interaction.holdActive.get(id);
    if (currentInteraction != null && currentHold != null) {
      currentInteraction.holdInfo.push({
        ...currentHold,
        end
      });
      interaction.holdActive.delete(id);
      removeHoldCriterion(id);
    }
  }
});
export const getCurrentInteractionType = withProfiling(function getCurrentInteractionType(interactionId) {
  const interaction = interactions.get(interactionId);
  if (interaction) {
    return interaction.type;
  }
  return null;
});
export const ModuleLoadingProfiler = {
  onPreload: withProfiling(function onPreload(moduleId, _priority) {
    addPreload(extractModuleName(moduleId), performance.now());
  }),
  onLoadStart: withProfiling(function onLoadStart(info) {
    const timeoutId = setTimeout(() => {
      delete moduleLoadingRequests[info.identifier];
    }, 30000);
    const request = {
      start: performance.now(),
      timeoutId
    };
    moduleLoadingRequests[info.identifier] = request;
  }),
  onLoadComplete: withProfiling(function onLoadComplete(info) {
    const request = moduleLoadingRequests[info.identifier];
    if (request) {
      clearTimeout(request.timeoutId);
      delete moduleLoadingRequests[info.identifier];
      addLoad(extractModuleName(info.identifier), request.start, performance.now());
    }
  }),
  placeholderFallBackMounted: withProfiling(function placeholderFallBackMounted(id, moduleId) {
    const interactionId = getInteractionId();
    const currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    addHoldByID(currentInteractionId, [], moduleId, id);
  }),
  placeholderFallBackUnmounted: withProfiling(function placeholderFallBackUnmounted(id) {
    const interactionId = getInteractionId();
    const currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    removeHoldByID(currentInteractionId, id);
  })
};
export const addError = withProfiling(function addError(interactionId, name, labelStack, errorType, errorMessage, errorStack, forcedError) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.errors.push({
      name,
      labelStack,
      errorType,
      errorMessage,
      errorStack,
      forcedError
    });
  }
});
export const addErrorToAll = withProfiling(function addErrorToAll(name, labelStack, errorType, errorMessage, errorStack) {
  interactions.forEach(interaction => {
    interaction.errors.push({
      name,
      labelStack,
      errorType,
      errorMessage,
      errorStack
    });
  });
});
export const addProfilerTimings = withProfiling(function addProfilerTimings(interactionId, labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
  var _getConfig3, _getConfig3$postInter;
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${labelStackToString(labelStack)} [react-profiler] ${type}`, {
        start: startTime,
        duration: actualDuration
      });
    } catch (e) {
      // do nothing
    }
  }
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.reactProfilerTimings.push({
      labelStack,
      type,
      actualDuration,
      baseDuration,
      startTime,
      commitTime
    });
  } else if ((_getConfig3 = getConfig()) !== null && _getConfig3 !== void 0 && (_getConfig3$postInter = _getConfig3.postInteractionLog) !== null && _getConfig3$postInter !== void 0 && _getConfig3$postInter.enabled) {
    postInteractionLog.addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime);
  }
});
const pushToQueue = withProfiling(function pushToQueue(id, data) {
  interactionQueue.push({
    id,
    data
  });
});
let handleInteraction = pushToQueue;
const callCleanUpCallbacks = withProfiling(function callCleanUpCallbacks(interaction) {
  interaction.cleanupCallbacks.reverse().forEach(cleanUpCallback => {
    cleanUpCallback();
  });
});
const finishInteraction = withProfiling(function finishInteraction(id, data, endTime = performance.now()) {
  var _getConfig4, _getConfig4$vc, _getConfig5, _getConfig5$experimen;
  data.end = endTime;
  try {
    // for Firefox 102 and older
    performance.measure(`ðŸ›¸ [${data.type}] ${data.ufoName} [ttai]`, {
      start: data.start,
      end: data.end
    });
  } catch (e) {
    // do nothing
  }
  if (data.featureFlags) {
    data.featureFlags.during = Object.fromEntries(currentFeatureFlagsAccessed);
  }
  clearActiveTrace();
  callCleanUpCallbacks(data);
  if ((_getConfig4 = getConfig()) !== null && _getConfig4 !== void 0 && (_getConfig4$vc = _getConfig4.vc) !== null && _getConfig4$vc !== void 0 && _getConfig4$vc.stopVCAtInteractionFinish) {
    data.vc = getVCObserver().getVCRawData();
  }
  if (!((_getConfig5 = getConfig()) !== null && _getConfig5 !== void 0 && (_getConfig5$experimen = _getConfig5.experimentalInteractionMetrics) !== null && _getConfig5$experimen !== void 0 && _getConfig5$experimen.enabled)) {
    remove(id);
  }
  PreviousInteractionLog.name = data.ufoName || 'unknown';
  PreviousInteractionLog.isAborted = data.abortReason != null;
  if (data.ufoName) {
    handleInteraction(id, data);
  }
  if (isPerformanceTracingEnabled()) {
    const profilerTimingMap = new Map();
    data.reactProfilerTimings.forEach(profilerTiming => {
      const labelStackId = labelStackToIdString(profilerTiming.labelStack);
      if (labelStackId) {
        var _profilerTimingMap$ge, _timing$start, _timing$end;
        const timing = (_profilerTimingMap$ge = profilerTimingMap.get(labelStackId)) !== null && _profilerTimingMap$ge !== void 0 ? _profilerTimingMap$ge : {
          labelStack: profilerTiming.labelStack
        };
        timing.start = profilerTiming.startTime < ((_timing$start = timing.start) !== null && _timing$start !== void 0 ? _timing$start : Number.MAX_SAFE_INTEGER) ? profilerTiming.startTime : timing.start;
        timing.end = profilerTiming.commitTime > ((_timing$end = timing.end) !== null && _timing$end !== void 0 ? _timing$end : Number.MIN_SAFE_INTEGER) ? profilerTiming.commitTime : timing.end;
        profilerTimingMap.set(labelStackId, timing);
      }
    });
    try {
      // for Firefox 102 and older
      for (const [, {
        labelStack,
        start,
        end
      }] of profilerTimingMap.entries()) {
        performance.measure(`ðŸ›¸ ${labelStackToString(labelStack)} [segment_ttai]`, {
          start,
          end
        });
      }
    } catch (e) {
      // do nothing
    }
  }
  try {
    // dispatch a global window event to notify the measure is completed
    window.dispatchEvent(new CustomEvent('UFO_FINISH_INTERACTION', {
      detail: data
    }));
  } catch (error) {
    // do nothing
  }
});
export const sinkInteractionHandler = withProfiling(function sinkInteractionHandler(sinkFn) {
  if (handleInteraction === pushToQueue) {
    handleInteraction = sinkFn;
    interactionQueue.forEach(interaction => {
      sinkFn(interaction.id, interaction.data);
    });
    interactionQueue.length = 0;
  }
});
export const sinkPostInteractionLogHandler = withProfiling(function sinkPostInteractionLogHandler(sinkFn) {
  postInteractionLog.sinkHandler(sinkFn);
});

// a flag to prevent multiple submitting
let activeSubmitted = false;
export const tryComplete = withProfiling(function tryComplete(interactionId, endTime) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const noMoreActiveHolds = interaction.holdActive.size === 0;
    const noMoreExpHolds = interaction.holdExpActive.size === 0;
    const postInteraction = async () => {
      var _getConfig6, _getConfig6$postInter, _getConfig8, _getConfig8$experimen;
      if ((_getConfig6 = getConfig()) !== null && _getConfig6 !== void 0 && (_getConfig6$postInter = _getConfig6.postInteractionLog) !== null && _getConfig6$postInter !== void 0 && _getConfig6$postInter.enabled) {
        var _getConfig7, _getConfig7$experimen;
        let experimentalVC90;
        let experimentalTTAI;
        if ((_getConfig7 = getConfig()) !== null && _getConfig7 !== void 0 && (_getConfig7$experimen = _getConfig7.experimentalInteractionMetrics) !== null && _getConfig7$experimen !== void 0 && _getConfig7$experimen.enabled) {
          var _await$getExperimenta;
          experimentalVC90 = (_await$getExperimenta = await getExperimentalVCMetrics(interaction)) === null || _await$getExperimenta === void 0 ? void 0 : _await$getExperimenta['metric:experimental:vc90'];
          const {
            start,
            end
          } = interaction;
          experimentalTTAI = !interaction.abortReason ? Math.round(end - start) : undefined;
        }
        postInteractionLog.onInteractionComplete({
          ...interaction,
          experimentalTTAI,
          experimentalVC90
        });
      }
      if ((_getConfig8 = getConfig()) !== null && _getConfig8 !== void 0 && (_getConfig8$experimen = _getConfig8.experimentalInteractionMetrics) !== null && _getConfig8$experimen !== void 0 && _getConfig8$experimen.enabled) {
        remove(interactionId);
      }
      activeSubmitted = false;
    };
    if (noMoreActiveHolds) {
      if (!activeSubmitted) {
        finishInteraction(interactionId, interaction, endTime);
        activeSubmitted = true;
      }
      if (noMoreExpHolds) {
        var _getConfig9, _getConfig9$experimen;
        if ((_getConfig9 = getConfig()) !== null && _getConfig9 !== void 0 && (_getConfig9$experimen = _getConfig9.experimentalInteractionMetrics) !== null && _getConfig9$experimen !== void 0 && _getConfig9$experimen.enabled) {
          onExperimentalInteractionComplete(interactionId, interaction, endTime);
        }
        postInteraction();
      }
    }
  }
});
const callCancelCallbacks = withProfiling(function callCancelCallbacks(interaction) {
  interaction.cancelCallbacks.reverse().forEach(cancelCallback => {
    cancelCallback();
  });
});
export const abort = withProfiling(function abort(interactionId, abortReason) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    var _getConfig10, _getConfig10$experime;
    callCancelCallbacks(interaction);
    interaction.abortReason = abortReason;
    finishInteraction(interactionId, interaction);
    if ((_getConfig10 = getConfig()) !== null && _getConfig10 !== void 0 && (_getConfig10$experime = _getConfig10.experimentalInteractionMetrics) !== null && _getConfig10$experime !== void 0 && _getConfig10$experime.enabled) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  }
});
export const abortByNewInteraction = withProfiling(function abortByNewInteraction(interactionId, interactionName) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    var _getConfig11, _getConfig11$experime;
    callCancelCallbacks(interaction);
    interaction.abortReason = 'new_interaction';
    interaction.abortedByInteractionName = interactionName;
    finishInteraction(interactionId, interaction);
    if ((_getConfig11 = getConfig()) !== null && _getConfig11 !== void 0 && (_getConfig11$experime = _getConfig11.experimentalInteractionMetrics) !== null && _getConfig11$experime !== void 0 && _getConfig11$experime.enabled) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  }
});
export const abortAll = withProfiling(function abortAll(abortReason, abortedByInteractionName) {
  interactions.forEach((interaction, interactionId) => {
    var _getConfig12, _getConfig12$experime;
    const noMoreHolds = interaction.holdActive.size === 0;
    if (!noMoreHolds) {
      callCancelCallbacks(interaction);
      interaction.abortReason = abortReason;
      if (abortedByInteractionName != null) {
        interaction.abortedByInteractionName = abortedByInteractionName;
      }
    }
    finishInteraction(interactionId, interaction);
    if ((_getConfig12 = getConfig()) !== null && _getConfig12 !== void 0 && (_getConfig12$experime = _getConfig12.experimentalInteractionMetrics) !== null && _getConfig12$experime !== void 0 && _getConfig12$experime.enabled) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  });
});
export const addOnCancelCallback = withProfiling(function addOnCancelCallback(id, cancelCallback) {
  const interaction = interactions.get(id);
  interaction === null || interaction === void 0 ? void 0 : interaction.cancelCallbacks.push(cancelCallback);
});
export const addNewInteraction = withProfiling(function addNewInteraction(interactionId, ufoName, type, startTime, rate, labelStack, routeName, trace = null) {
  var _getConfig13, _getConfig13$postInte;
  if ((_getConfig13 = getConfig()) !== null && _getConfig13 !== void 0 && (_getConfig13$postInte = _getConfig13.postInteractionLog) !== null && _getConfig13$postInte !== void 0 && _getConfig13$postInte.enabled) {
    postInteractionLog.reset();
  }
  let previousTime = startTime;
  let timeoutTime = CLEANUP_TIMEOUT;
  const timerID = setTimeout(() => {
    abort(interactionId, 'timeout');
  }, CLEANUP_TIMEOUT);
  function changeTimeout(newTime) {
    // we compare if the time left is lower than the new time to no
    // extend the timeout beyond the initial waiting time
    const currentTime = performance.now();
    const timeLeft = timeoutTime - (currentTime - previousTime);
    if (timeLeft < newTime) {
      return;
    }
    clearTimeout(this.timerID);
    const newTimerID = setTimeout(() => {
      abort(interactionId, 'timeout');
    }, newTime);
    timeoutTime = newTime;
    previousTime = currentTime;
    this.timerID = newTimerID;
  }
  const addFeatureFlagsToInteraction = coinflip(getCapabilityRate('feature_flag_access'));
  const metrics = {
    id: interactionId,
    start: startTime,
    end: 0,
    ufoName,
    type,
    previousInteractionName: PreviousInteractionLog.name,
    isPreviousInteractionAborted: PreviousInteractionLog.isAborted === true,
    marks: [],
    customData: [],
    customTimings: [],
    spans: [],
    requestInfo: [],
    reactProfilerTimings: [],
    holdInfo: [],
    holdExpInfo: [],
    holdActive: new Map(),
    holdExpActive: new Map(),
    // measure when we execute this code
    // from this, we can measure the input delay -
    // how long the browser took to hand execution back to JS)
    measureStart: performance.now(),
    rate,
    cancelCallbacks: [],
    metaData: {},
    errors: [],
    apdex: [],
    labelStack,
    routeName: routeName !== null && routeName !== void 0 ? routeName : ufoName,
    featureFlags: addFeatureFlagsToInteraction ? {
      prior: Object.fromEntries(allFeatureFlagsAccessed),
      during: {}
    } : undefined,
    knownSegments: [],
    cleanupCallbacks: [],
    awaitReactProfilerCount: 0,
    redirects: [],
    timerID,
    changeTimeout,
    trace
  };
  if (addFeatureFlagsToInteraction) {
    currentFeatureFlagsAccessed.clear();
  }
  interactions.set(interactionId, metrics);
  const segmentObserver = {
    onAdd(segment) {
      metrics.knownSegments.push(segment);
    },
    onRemove() {}
  };
  addSegmentObserver(segmentObserver);
  metrics.cleanupCallbacks.push(() => {
    removeSegmentObserver(segmentObserver);
  });
  metrics.cleanupCallbacks.push(() => {
    clearTimeout(metrics.timerID);
  });
  const awaitBM3TTIList = getAwaitBM3TTIList();
  if (awaitBM3TTIList.includes(ufoName)) {
    addHoldByID(interactionId, [], ufoName, ufoName, true);
  }
  if (type === 'transition') {
    var _getConfig14, _getConfig14$experime;
    getVCObserver().start({
      startTime
    });
    postInteractionLog.startVCObserver({
      startTime
    });
    if ((_getConfig14 = getConfig()) !== null && _getConfig14 !== void 0 && (_getConfig14$experime = _getConfig14.experimentalInteractionMetrics) !== null && _getConfig14$experime !== void 0 && _getConfig14$experime.enabled) {
      experimentalVC.start({
        startTime
      });
    }
  }
});
export const addBrowserMetricEvent = withProfiling(function addBrowserMetricEvent(event) {
  const interaction = getActiveInteraction();
  if (interaction) {
    var _event$config;
    interaction.legacyMetrics = interaction.legacyMetrics || [];
    interaction.legacyMetrics.push(event);
    if ((interaction.type === 'page_load' || interaction.type === 'transition') && ((_event$config = event.config) === null || _event$config === void 0 ? void 0 : _event$config.type) === 'PAGE_LOAD') {
      interaction.changeTimeout(CLEANUP_TIMEOUT_AFTER_APDEX);
      removeHoldByID(interaction.id, interaction.ufoName);
    }
  }
});
export const addApdexToAll = withProfiling(function addApdexToAll(apdex) {
  interactions.forEach((interaction, key) => {
    interaction.apdex.push(apdex);
    try {
      var _apdex$startTime;
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${apdex.key} [bm3_tti]`, {
        start: (_apdex$startTime = apdex.startTime) !== null && _apdex$startTime !== void 0 ? _apdex$startTime : interaction.start,
        end: apdex.stopTime
      });
    } catch (e) {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      interaction.changeTimeout(CLEANUP_TIMEOUT_AFTER_APDEX);
      removeHoldByID(key, interaction.ufoName);
    }
  });
});
export const addApdex = withProfiling(function addApdex(interactionId, apdexInfo) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.apdex.push(apdexInfo);
    try {
      var _apdexInfo$startTime;
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${apdexInfo.key} [bm3_tti]`, {
        start: (_apdexInfo$startTime = apdexInfo.startTime) !== null && _apdexInfo$startTime !== void 0 ? _apdexInfo$startTime : interaction.start,
        end: apdexInfo.stopTime
      });
    } catch (e) {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      interaction.changeTimeout(CLEANUP_TIMEOUT_AFTER_APDEX);
      removeHoldByID(interactionId, interaction.ufoName);
    }
  }
});
export const addRequestInfo = withProfiling(function addRequestInfo(interactionId, labelStack, requestInfo) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.requestInfo.push({
      labelStack,
      ...requestInfo
    });
  }
});
const isSegmentLabel = withProfiling(function isSegmentLabel(obj) {
  return obj && typeof obj.name === 'string' && typeof obj.segmentId === 'string';
});
const getSegmentCacheKey = withProfiling(function getSegmentCacheKey(labelStack) {
  return labelStack.map(l => {
    if (isSegmentLabel(l)) {
      return `${l.name}_${l.segmentId}`;
    }
    return l.name;
  }).join('|');
});
export const addSegment = withProfiling(function addSegment(labelStack) {
  const key = getSegmentCacheKey(labelStack);
  const existingSegment = segmentCache.get(key);
  if (!existingSegment) {
    const segmentInfo = {
      labelStack
    };
    segmentCache.set(key, segmentInfo);
    segmentObservers.forEach(observer => {
      observer.onAdd(segmentInfo);
    });
  }
});
export const removeSegment = withProfiling(function removeSegment(labelStack) {
  const key = getSegmentCacheKey(labelStack);
  const segmentInfo = segmentCache.get(key);
  if (segmentInfo) {
    segmentCache.delete(JSON.stringify(labelStack));
    segmentObservers.forEach(observer => {
      observer.onRemove(segmentInfo);
    });
  }
});
export const addRedirect = withProfiling(function addRedirect(interactionId, fromUfoName, nextUfoName, nextRouteName, time) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.ufoName = nextUfoName;
    interaction.routeName = nextRouteName;
    interaction.redirects.push({
      fromInteractionName: fromUfoName,
      time
    });
    if (isPerformanceTracingEnabled()) {
      const prevRedirect = interaction.redirects.at(-2);
      try {
        var _prevRedirect$time;
        // for Firefox 102 and older
        performance.measure(`ðŸ›¸ ${nextUfoName} [redirect]`, {
          start: (_prevRedirect$time = prevRedirect === null || prevRedirect === void 0 ? void 0 : prevRedirect.time) !== null && _prevRedirect$time !== void 0 ? _prevRedirect$time : interaction.start,
          end: time
        });
      } catch (e) {
        // do nothing
      }
    }
  }
});
export const interactionSpans = [];
const defaultLabelStack = [{
  name: 'custom'
}];
export const addCustomSpans = withProfiling(function addCustomSpans(name, start, end = performance.now(), size = 0, labelStack = defaultLabelStack) {
  const customSpan = {
    type: 'custom',
    name,
    start,
    end,
    labelStack,
    size
  };
  interactionSpans.push(customSpan);
});