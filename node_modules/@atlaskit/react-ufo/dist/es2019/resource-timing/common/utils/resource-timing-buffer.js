import { roundEpsilon } from '../../../round-number';
import { withProfiling } from '../../../self-measurements';
const getPerformanceObject = () => {
  var _window;
  return ((_window = window) !== null && _window !== void 0 ? _window : {}).performance;
};
const getPerformanceObserverObject = () => {
  var _window2;
  return ((_window2 = window) !== null && _window2 !== void 0 ? _window2 : {}).PerformanceObserver;
};
export const resourceTimingBuffer = {
  timings: [],
  maxSize: 1000,
  observer: null,
  transformResource: withProfiling(function transformResource(entry) {
    var _entry$serverTiming, _entry$serverTiming2;
    const duration = roundEpsilon(entry.duration);

    // prioritising atl-edge
    const totalBackendTimeEntry = ((_entry$serverTiming = entry.serverTiming) === null || _entry$serverTiming === void 0 ? void 0 : _entry$serverTiming.find(timing => timing.name === 'atl-edge')) || ((_entry$serverTiming2 = entry.serverTiming) === null || _entry$serverTiming2 === void 0 ? void 0 : _entry$serverTiming2.find(
    // timing name should come from per-product config in the future
    timing => timing.name === 'total' || timing.name === 'filter-request-papi'));
    const serverTime = totalBackendTimeEntry ? roundEpsilon(totalBackendTimeEntry.duration) : undefined;
    const networkTime = serverTime ? duration - serverTime : undefined;
    return {
      name: entry.name,
      initiatorType: entry.initiatorType,
      transferSize: entry.transferSize,
      startTime: roundEpsilon(entry.startTime),
      duration: roundEpsilon(entry.duration),
      fetchStart: roundEpsilon(entry.fetchStart || 0),
      workerStart: roundEpsilon(entry.workerStart || 0),
      responseStart: roundEpsilon(entry.responseStart || 0),
      requestStart: roundEpsilon(entry.requestStart || 0),
      serverTime,
      networkTime,
      encodedSize: roundEpsilon(entry.encodedBodySize),
      decodedSize: roundEpsilon(entry.decodedBodySize)
    };
  }),
  start: withProfiling(function start() {
    var _performance$getEntri;
    const performance = getPerformanceObject();
    const PerformanceObserver = getPerformanceObserverObject();
    if (!PerformanceObserver || !performance || typeof PerformanceObserver === 'undefined') {
      return;
    }
    if (resourceTimingBuffer.observer) {
      return;
    }
    const resources = (_performance$getEntri = performance.getEntriesByType) === null || _performance$getEntri === void 0 ? void 0 : _performance$getEntri.call(performance, 'resource');
    if (resources) {
      resourceTimingBuffer.timings = resources.map(resource => resourceTimingBuffer.transformResource(resource));
    }
    resourceTimingBuffer.observer = new PerformanceObserver(resourceTimingBuffer.addTimings);
    resourceTimingBuffer.observer.observe({
      entryTypes: ['resource']
    });
  }),
  stop: withProfiling(function stop() {
    if (resourceTimingBuffer.observer) {
      resourceTimingBuffer.observer.disconnect();
      resourceTimingBuffer.observer = null;
    }
    resourceTimingBuffer.timings = [];
  }),
  addTimings: withProfiling(function addTimings(list) {
    const entries = list.getEntries().map(entry => resourceTimingBuffer.transformResource(entry));
    const overflow = resourceTimingBuffer.timings.length + entries.length;
    if (overflow > resourceTimingBuffer.maxSize) {
      const fieldsToRemove = overflow - resourceTimingBuffer.maxSize;
      resourceTimingBuffer.timings.splice(0, fieldsToRemove);
    }
    resourceTimingBuffer.timings.push(...entries);
  })
};
const isValidTiming = withProfiling(function isValidTiming(timing, startTime, endTime) {
  return timing.startTime >= startTime && timing.startTime + timing.duration <= endTime;
});
export const filterResourceTimings = withProfiling(function filterResourceTimings(startTime, endTime) {
  const performance = getPerformanceObject();
  const PerformanceObserver = getPerformanceObserverObject();
  if (!PerformanceObserver || !resourceTimingBuffer.observer) {
    const resources = performance === null || performance === void 0 ? void 0 : performance.getEntriesByType('resource');
    if (resources) {
      return resources.filter(timing => isValidTiming(timing, startTime, endTime));
    }
    return null;
  }
  return resourceTimingBuffer.timings.filter(timing => isValidTiming(timing, startTime, endTime));
});