import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _CHRSummary;
import { fg } from '@atlaskit/platform-feature-flags';
import { withProfiling } from '../self-measurements';
import { calculateTransferType, checkIfTimingsAvailable, DISK_KEY, getTypeOfRequest, MEMORY_KEY, NETWORK_KEY, round } from './utils';
export class CHRSummary {
  constructor() {
    _defineProperty(this, "bundles", {
      [MEMORY_KEY]: 0,
      [DISK_KEY]: 0,
      [NETWORK_KEY]: 0
    });
    _defineProperty(this, "bundlesCount", 0);
    _defineProperty(this, "size", {
      [MEMORY_KEY]: 0,
      [DISK_KEY]: 0,
      [NETWORK_KEY]: 0
    });
    _defineProperty(this, "sizeTotal", 0);
    this.add = withProfiling(this.add.bind(this));
  }
  add(asset) {
    const encodedSize = asset.encodedSize || 0;
    const type = calculateTransferType(asset.name, asset.initiatorType, asset.duration, asset.transferSize);
    if (type === null) {
      return;
    }
    this.bundles[type] += 1;
    this.bundlesCount += 1;
    this.size[type] += encodedSize;
    this.sizeTotal += encodedSize;
  }
}
_CHRSummary = CHRSummary;
_defineProperty(CHRSummary, "makePayload", withProfiling(function makePayload(summary) {
  const {
    size,
    bundlesCount,
    sizeTotal
  } = summary;
  const cachedSize = size[MEMORY_KEY] + size[DISK_KEY];
  const sizeRatio = round(cachedSize / summary.sizeTotal);
  return {
    size: sizeTotal,
    chr: sizeRatio,
    count: bundlesCount
  };
}));
export class CHRReporter {
  constructor() {
    _defineProperty(this, "all", new CHRSummary());
    _defineProperty(this, "allAtlassian", new CHRSummary());
    _defineProperty(this, "preloaded", new CHRSummary());
    _defineProperty(this, "defaultAllowedTypes", ['js']);
    this.get = withProfiling(this.get.bind(this));
  }
  get(resourceTimings, assetsConfig, SSRDoneTime) {
    try {
      if (resourceTimings === null) {
        return null;
      }
      resourceTimings.forEach(entry => {
        if (!checkIfTimingsAvailable(entry)) {
          return;
        }
        const hasNanValues = fg('platform_ufo_assets_check_for_nan') ? entry.encodedSize === undefined || entry.encodedSize === null : false;
        if (entry.encodedSize === entry.decodedSize || hasNanValues) {
          // incorrectly reported or lack of size
          return;
        }
        const type = getTypeOfRequest(entry);
        if (!(assetsConfig.allowedTypes || this.defaultAllowedTypes).includes(type)) {
          return;
        }
        if (assetsConfig.classification.all) {
          this.all.add(entry);
        }
        if (assetsConfig.classification.allAtlassian({
          entry
        })) {
          this.allAtlassian.add(entry);
        }
        if (assetsConfig.classification.preloaded({
          entry,
          SSRDoneTime
        })) {
          this.preloaded.add(entry);
        }
      });
      if (this.all.bundlesCount === 0) {
        return null;
      }
      const CHRData = {
        all: CHRSummary.makePayload(this.all),
        allAtlassian: CHRSummary.makePayload(this.allAtlassian),
        preloaded: CHRSummary.makePayload(this.preloaded)
      };
      return CHRData;
    } catch (error) {
      return null;
    }
  }
}