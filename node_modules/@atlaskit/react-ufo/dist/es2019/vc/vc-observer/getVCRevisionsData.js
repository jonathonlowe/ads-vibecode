import { fg } from '@atlaskit/platform-feature-flags';
import { getPageVisibilityState } from '../../hidden-timing';
import { withProfiling } from '../../self-measurements';
import { getRevisions } from './revisions/revisions';
const VCParts = ['25', '50', '75', '80', '85', '90', '95', '98', '99'];
const READONLY_EMPTY_ARRAY = Array.from({
  length: 0
});

// Helper function to create vcDetails object to avoid code duplication
const createVCDetails = withProfiling(function createVCDetails(calculatedVC, shouldHaveVCmetric) {
  if (!shouldHaveVCmetric || !calculatedVC || !calculatedVC.VC || !calculatedVC.VCBox) {
    return {};
  }
  const details = {};
  const {
    VC,
    VCBox
  } = calculatedVC; // Destructure once to avoid repeated property access

  for (const key of VCParts) {
    details[key] = {
      t: VC[key],
      e: VCBox[key] || READONLY_EMPTY_ARRAY
    };
  }
  return details;
}, ['vc']);

// Optimized implementation (current one)
export const getVCRevisionsData = withProfiling(function getVCRevisionsData({
  fullPrefix,
  interaction,
  isVCClean,
  isEventAborted,
  multiHeatmap,
  ssr,
  calculatedVC,
  calculatedVCNext
}) {
  if (!fg('platform_ufo_vc_observer_new')) {
    if (!multiHeatmap) {
      return null;
    }
    return {
      [`${fullPrefix}vc:rev`]: multiHeatmap === null || multiHeatmap === void 0 ? void 0 : multiHeatmap.getPayloadShapedData({
        VCParts: VCParts.map(v => parseInt(v)),
        VCCalculationMethods: getRevisions().map(({
          classifier
        }) => classifier.VCCalculationMethod),
        filterComponentsLog: getRevisions().map(({
          classifier
        }) => classifier.filterComponentsLog),
        isEventAborted,
        interactionStart: interaction.start,
        ttai: interaction.end,
        ssr,
        clean: isVCClean
      })
    };
  }

  // Calculate these conditions once
  const pageVisibilityUpToTTAI = getPageVisibilityState(interaction.start, interaction.end);
  const isVisiblePageVisibleUpToTTAI = pageVisibilityUpToTTAI === 'visible';
  const shouldHaveVCmetric = isVCClean && !isEventAborted && isVisiblePageVisibleUpToTTAI;

  // Create the V2 revision object which is always needed
  const ttvcV2Revision = {
    revision: 'fy25.02',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVCNext.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVCNext, shouldHaveVCmetric)
  };
  if (fg('platform_ufo_disable_ttvc_v1')) {
    return {
      [`${fullPrefix}vc:rev`]: [ttvcV2Revision]
    };
  }

  // Only create ttvcV1Revision when we're actually going to use it
  const ttvcV1Revision = {
    revision: 'fy25.01',
    clean: isVCClean,
    'metric:vc90': shouldHaveVCmetric ? calculatedVC.VC['90'] : null,
    vcDetails: createVCDetails(calculatedVC, shouldHaveVCmetric)
  };
  return {
    [`${fullPrefix}vc:rev`]: [ttvcV1Revision, ttvcV2Revision]
  };
}, ['vc']);