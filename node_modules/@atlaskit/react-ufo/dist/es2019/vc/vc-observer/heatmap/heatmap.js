import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { getPageVisibilityState } from '../../../hidden-timing';
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../../self-measurements';
const UNUSED_SECTOR = 0;
export class MultiRevisionHeatmap {
  constructor({
    viewport,
    revisions,
    arraySize,
    devToolsEnabled
  }) {
    _defineProperty(this, "arraySize", {
      w: 200,
      h: 200
    });
    _defineProperty(this, "mapPixelsToHeatmap", (left, top, width, height) => {
      const {
        w,
        h
      } = this.viewport;
      const l = Math.floor(left / w * this.arraySize.w);
      const t = Math.floor(top / h * this.arraySize.h);
      const r = Math.ceil((left + width) / w * this.arraySize.w);
      const b = Math.ceil((top + height) / h * this.arraySize.h);

      // correct values to min - 0, max - arraySize
      const result = {
        l: Math.max(0, l),
        t: Math.max(0, t),
        r: Math.min(this.arraySize.w, r),
        b: Math.min(this.arraySize.h, b)
      };
      return result;
    });
    _defineProperty(this, "getElementRatio", mappedValues => {
      const {
        r,
        l,
        b,
        t
      } = mappedValues;
      return (r - l) * (b - t) / (this.arraySize.w * this.arraySize.h);
    });
    const operationTimer = markProfilingStart('MultiRevisionHeatmap constructor');
    this.viewport = viewport;
    this.revisions = revisions;
    if (arraySize) {
      this.arraySize = arraySize;
    }
    this.heatmaps = new Array(revisions.length);
    this.componentsLogs = new Array(revisions.length);
    this.vcRatios = new Array(revisions.length);
    this.devToolsEnabled = devToolsEnabled || false;
    revisions.forEach(({}, i) => {
      this.heatmaps[i] = this.getCleanHeatmap();
      this.componentsLogs[i] = {};
      this.vcRatios[i] = {};
    });
    this.handleUpdate = withProfiling(this.handleUpdate.bind(this), ['vc']);
    this.getData = withProfiling(this.getData.bind(this), ['vc']);
    this.getPayloadShapedData = withProfiling(this.getPayloadShapedData.bind(this), ['vc']);
    this.processData = withProfiling(this.processData.bind(this), ['vc']);
    this.mapPixelsToHeatmap = withProfiling(this.mapPixelsToHeatmap.bind(this), ['vc']);
    this.getElementRatio = withProfiling(this.getElementRatio.bind(this), ['vc']);
    this.applyChangesToHeatMap = withProfiling(this.applyChangesToHeatMap.bind(this), ['vc']);
    this.getIndex = withProfiling(this.getIndex.bind(this), ['vc']);
    this.getCleanHeatmap = withProfiling(this.getCleanHeatmap.bind(this), ['vc']);
    markProfilingEnd(operationTimer);
  }
  handleUpdate({
    time,
    type,
    classification,
    intersectionRect,
    element,
    targetName,
    ignoreReason,
    onError,
    attributeName,
    oldValue,
    newValue
  }) {
    const mappedValues = this.mapPixelsToHeatmap(intersectionRect.left, intersectionRect.top, intersectionRect.width, intersectionRect.height);
    const result = this.applyChangesToHeatMap(mappedValues, time, classification);
    if (result !== true) {
      onError(result);
    }
    const componentRatio = this.getElementRatio(mappedValues);
    this.revisions.forEach((_, i) => {
      if (classification[i]) {
        this.vcRatios[i][targetName] = componentRatio;
      }
      if (!this.componentsLogs[i][time]) {
        this.componentsLogs[i][time] = [];
      }
      this.componentsLogs[i][time].push({
        __debug__element: this.devToolsEnabled ? new WeakRef(element) : null,
        intersectionRect,
        targetName,
        ignoreReason,
        attributeName,
        oldValue,
        newValue
      });
    });
  }
  getData() {
    return {
      heatmaps: this.heatmaps
    };
  }
  getPayloadShapedData(args) {
    const pageVisibilityUpToTTAI = getPageVisibilityState(args.interactionStart, args.ttai);
    const result = this.processData(args);
    const payload = this.revisions.map((rev, i) => {
      var _vcDetails$;
      const vcDetails = {};
      args.VCParts.forEach(VCPart => {
        vcDetails[VCPart] = {
          t: result[i].VC[VCPart] || 0,
          e: Array.from(result[i].VCBox[VCPart] || [])
        };
      });
      return {
        revision: rev.name,
        vcDetails,
        clean: args.clean,
        'metric:vc90': args.clean && !args.isEventAborted && pageVisibilityUpToTTAI === 'visible' ? vcDetails === null || vcDetails === void 0 ? void 0 : (_vcDetails$ = vcDetails['90']) === null || _vcDetails$ === void 0 ? void 0 : _vcDetails$.t : null
      };
    });
    return payload;
  }
  processData({
    VCParts,
    VCCalculationMethods,
    filterComponentsLog,
    ttai,
    ssr = UNUSED_SECTOR
  }) {
    return this.heatmaps.map((heatmap, i) => {
      const lastUpdate = {};
      let totalPainted = 0;
      let componentsLog = this.componentsLogs[i];
      if (ssr !== UNUSED_SECTOR) {
        var _window$document;
        const element = {
          __debug__element: new WeakRef((_window$document = window.document) === null || _window$document === void 0 ? void 0 : _window$document.body),
          intersectionRect: {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0,
            width: this.viewport.w,
            height: this.viewport.h,
            toJSON() {
              return {};
            }
          },
          targetName: 'SSR'
        };
        if (!componentsLog[ssr]) {
          componentsLog[ssr] = [];
        }
        componentsLog[ssr].push(element);
      }
      for (let i = 0; i < heatmap.length; i++) {
        const rounded = Math.floor(heatmap[i] === UNUSED_SECTOR && ssr !== UNUSED_SECTOR ? ssr : heatmap[i]);
        totalPainted += rounded !== UNUSED_SECTOR ? 1 : 0;
        if (rounded !== UNUSED_SECTOR) {
          lastUpdate[rounded] = lastUpdate[rounded] ? lastUpdate[rounded] + 1 : 1;
        }
      }
      const entries = Object.entries(lastUpdate).map(a => [parseInt(a[0], 10), a[1]]).sort((a, b) => a[0] > b[0] ? 1 : -1);

      // @todo remove it once fixed as described: https://product-fabric.atlassian.net/browse/AFO-3443
      componentsLog = filterComponentsLog[i]({
        componentsLog,
        ttai
      });
      const {
        VC,
        VCBox
      } = VCCalculationMethods[i]({
        VCParts,
        componentsLog,
        entries,
        totalPainted
      });
      const VCEntries = entries.reduce((acc, [timestamp, entryPainted], i) => {
        var _acc$abs, _componentsLog$timest;
        const currentlyPainted = entryPainted + (((_acc$abs = acc.abs[i - 1]) === null || _acc$abs === void 0 ? void 0 : _acc$abs[1]) || 0);
        const currentlyPaintedRatio = Math.round(currentlyPainted / totalPainted * 1000) / 10;
        const logEntry = (_componentsLog$timest = componentsLog[timestamp]) === null || _componentsLog$timest === void 0 ? void 0 : _componentsLog$timest.map(v => v.targetName);
        acc.abs.push([timestamp, currentlyPainted]);
        acc.rel.push({
          time: timestamp,
          vc: currentlyPaintedRatio,
          elements: logEntry
        });
        return acc;
      }, {
        abs: [],
        rel: []
      });
      return {
        VC,
        VCBox,
        VCEntries,
        totalPainted
      };
    });
  }
  applyChangesToHeatMap(a, time, classification) {
    const {
      l,
      t,
      r,
      b
    } = a;
    const size = classification.length;
    for (let row = t; row < b; row++) {
      if (this.heatmaps[0][row] === undefined) {
        try {
          return {
            error: `index - ${row}`,
            time
          };
        } catch (e) {
          return {
            error: 'row error',
            time
          };
        }
      } else {
        for (let heatmapIndex = 0; heatmapIndex < size; heatmapIndex++) {
          if (classification[heatmapIndex]) {
            this.heatmaps[heatmapIndex].fill(time, this.getIndex(l, row), this.getIndex(r, row));
          }
        }
      }
    }
    return true;
  }
  getIndex(x, y) {
    return x + this.arraySize.w * y;
  }
  getCleanHeatmap() {
    return new Int32Array(this.arraySize.w * this.arraySize.h);
  }
}
_defineProperty(MultiRevisionHeatmap, "makeVCReturnObj", withProfiling(function makeVCReturnObj(VCParts) {
  const vc = {};
  VCParts.forEach(v => {
    vc[v] = null;
  });
  return vc;
}, ['vc']));