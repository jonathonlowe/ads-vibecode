import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../../../self-measurements';
const ANCESTOR_LOOKUP_LIMIT = 10;
export class SSRPlaceholderHandlers {
  constructor() {
    _defineProperty(this, "staticPlaceholders", new Map());
    _defineProperty(this, "callbacks", new Map());
    _defineProperty(this, "getSizeCallbacks", new Map());
    _defineProperty(this, "reactValidateCallbacks", new Map());
    _defineProperty(this, "EQUALITY_THRESHOLD", 1);
    _defineProperty(this, "intersectionObserverCallback", ({
      target,
      boundingClientRect
    }) => {
      var _this$intersectionObs;
      (_this$intersectionObs = this.intersectionObserver) === null || _this$intersectionObs === void 0 ? void 0 : _this$intersectionObs.unobserve(target);
      if (!(target instanceof HTMLElement)) {
        // impossible case - keep typescript healthy
        return;
      }
      const staticKey = target.dataset.ssrPlaceholder || '';
      if (staticKey) {
        if (this.staticPlaceholders.has(staticKey) && this.callbacks.has(staticKey)) {
          // validation
          const resolve = this.callbacks.get(staticKey);
          if (!resolve) {
            return;
          }
          const rect = this.staticPlaceholders.get(staticKey);
          const hasSameSizePosition = this.hasSameSizePosition(rect, boundingClientRect);
          if (hasSameSizePosition || this.isDummyRect(rect)) {
            resolve(hasSameSizePosition);
          } else {
            requestAnimationFrame(() => {
              const targetRect = target.getBoundingClientRect();
              const hasSameSizePosition = this.hasSameSizePosition(rect, targetRect);
              resolve(hasSameSizePosition);
            });
          }
          this.callbacks.delete(staticKey);
        }
      } else {
        const key = target.dataset.ssrPlaceholderReplace || '';
        const resolve = this.reactValidateCallbacks.get(key);
        if (!resolve) {
          return;
        }
        const rect = this.staticPlaceholders.get(key);
        const hasSameSizePosition = this.hasSameSizePosition(rect, boundingClientRect);
        if (hasSameSizePosition || this.isDummyRect(rect)) {
          resolve(hasSameSizePosition);
        } else {
          requestAnimationFrame(() => {
            const targetRect = target.getBoundingClientRect();
            const hasSameSizePosition = this.hasSameSizePosition(rect, targetRect);
            resolve(hasSameSizePosition);
          });
        }
        this.staticPlaceholders.delete(staticKey);
        this.reactValidateCallbacks.delete(staticKey);
      }
    });
    const operationTimer = markProfilingStart('SSRPlaceholderHandlers constructor');
    if (typeof IntersectionObserver === 'function') {
      // Only instantiate the IntersectionObserver if it's supported
      this.intersectionObserver = new IntersectionObserver(entries => entries.filter(entry => entry.intersectionRatio > 0).forEach(this.intersectionObserverCallback));
    }
    if (window.document) {
      try {
        const existingElements = document.querySelectorAll('[data-ssr-placeholder]');
        existingElements.forEach(el => {
          var _el$dataset;
          if (el instanceof HTMLElement && el !== null && el !== void 0 && (_el$dataset = el.dataset) !== null && _el$dataset !== void 0 && _el$dataset.ssrPlaceholder) {
            var _window$__SSR_PLACEHO, _this$intersectionObs2;
            let width = -1;
            let height = -1;
            let x = -1;
            let y = -1;
            const boundingClientRect = (_window$__SSR_PLACEHO = window.__SSR_PLACEHOLDERS_DIMENSIONS__) === null || _window$__SSR_PLACEHO === void 0 ? void 0 : _window$__SSR_PLACEHO[el.dataset.ssrPlaceholder];
            if (boundingClientRect) {
              width = boundingClientRect.width;
              height = boundingClientRect.height;
              x = boundingClientRect.x;
              y = boundingClientRect.y;
            }
            this.staticPlaceholders.set(el.dataset.ssrPlaceholder, {
              width,
              height,
              x,
              y
            });
            (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 ? void 0 : _this$intersectionObs2.observe(el);
          }
        });
      } catch (e) {} finally {
        delete window.__SSR_PLACEHOLDERS_DIMENSIONS__;
      }
    }
    this.clear = withProfiling(this.clear.bind(this), ['vc']);
    this.isPlaceholder = withProfiling(this.isPlaceholder.bind(this), ['vc']);
    this.isPlaceholderReplacement = withProfiling(this.isPlaceholderReplacement.bind(this), ['vc']);
    this.isPlaceholderIgnored = withProfiling(this.isPlaceholderIgnored.bind(this), ['vc']);
    this.findNearestPlaceholderContainerIfIgnored = withProfiling(this.findNearestPlaceholderContainerIfIgnored.bind(this), ['vc']);
    this.checkIfExistedAndSizeMatching = withProfiling(this.checkIfExistedAndSizeMatching.bind(this), ['vc']);
    this.getSize = withProfiling(this.getSize.bind(this), ['vc']);
    this.validateReactComponentMatchToPlaceholder = withProfiling(this.validateReactComponentMatchToPlaceholder.bind(this), ['vc']);
    this.hasSameSizePosition = withProfiling(this.hasSameSizePosition.bind(this), ['vc']);
    this.isDummyRect = withProfiling(this.isDummyRect.bind(this), ['vc']);
    this.intersectionObserverCallback = withProfiling(this.intersectionObserverCallback.bind(this), ['vc']);
    markProfilingEnd(operationTimer, {
      tags: ['vc']
    });
  }
  clear() {
    this.staticPlaceholders = new Map();
    this.callbacks = new Map();
    this.getSizeCallbacks = new Map();
    this.reactValidateCallbacks = new Map();
  }
  isPlaceholder(element) {
    return Boolean(element.dataset.ssrPlaceholder);
  }
  isPlaceholderReplacement(element) {
    return Boolean(element.dataset.ssrPlaceholderReplace);
  }
  isPlaceholderIgnored(element) {
    // data-ssr-placeholder-ignored doesn't have a value.
    return 'ssrPlaceholderIgnored' in element.dataset;
  }
  findNearestPlaceholderContainerIfIgnored(element) {
    if (!this.isPlaceholderIgnored(element)) {
      return element;
    }
    let ancestor = element.parentElement;
    let i = 0;
    while (ancestor && i < ANCESTOR_LOOKUP_LIMIT) {
      if (this.isPlaceholder(ancestor) || this.isPlaceholderReplacement(ancestor)) {
        return ancestor;
      }
      ancestor = ancestor.parentElement;
      i++;
    }
    return element;
  }
  checkIfExistedAndSizeMatching(el) {
    el = this.findNearestPlaceholderContainerIfIgnored(el);
    const id = el.dataset.ssrPlaceholder || '';
    return new Promise(resolve => {
      if (!this.staticPlaceholders.has(id)) {
        resolve(false);
        return;
      } else {
        var _this$intersectionObs3;
        this.callbacks.set(id, resolve);
        (_this$intersectionObs3 = this.intersectionObserver) === null || _this$intersectionObs3 === void 0 ? void 0 : _this$intersectionObs3.observe(el);
      }
    });
  }
  getSize(el) {
    return new Promise(resolve => {
      var _this$intersectionObs4;
      this.getSizeCallbacks.set(el.dataset.ssrPlaceholder || '', resolve);
      (_this$intersectionObs4 = this.intersectionObserver) === null || _this$intersectionObs4 === void 0 ? void 0 : _this$intersectionObs4.observe(el);
    });
  }
  validateReactComponentMatchToPlaceholder(el) {
    el = this.findNearestPlaceholderContainerIfIgnored(el);
    const id = el.dataset.ssrPlaceholderReplace || '';
    return new Promise(resolve => {
      if (!this.staticPlaceholders.has(id)) {
        resolve(false);
        return;
      } else {
        var _this$intersectionObs5;
        this.reactValidateCallbacks.set(id, resolve);
        (_this$intersectionObs5 = this.intersectionObserver) === null || _this$intersectionObs5 === void 0 ? void 0 : _this$intersectionObs5.observe(el);
      }
    });
  }
  hasSameSizePosition(rect, boundingClientRect) {
    return rect && Math.abs(rect.x - boundingClientRect.x) < this.EQUALITY_THRESHOLD && Math.abs(rect.y - boundingClientRect.y) < this.EQUALITY_THRESHOLD && Math.abs(rect.width - boundingClientRect.width) < this.EQUALITY_THRESHOLD && Math.abs(rect.height - boundingClientRect.height) < this.EQUALITY_THRESHOLD || false;
  }
  isDummyRect(rect) {
    return rect && rect.width < 0 && rect.height < 0 || false;
  }
}