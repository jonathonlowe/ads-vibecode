import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../../../self-measurements';
const placeholderDataKey = 'editorLnvPlaceholder'; // data-editor-lnv-placeholder
const replaceDataKey = 'editorLnvPlaceholderReplace'; // data-editor-lnv-placeholder-replace

export class EditorLnvHandler {
  constructor() {
    _defineProperty(this, "placeholders", new Map());
    _defineProperty(this, "getSizeCallbacks", new Map());
    _defineProperty(this, "isAddedPlaceholderMatchingSizeCallbacks", new Map());
    _defineProperty(this, "isAddedReplaceMatchingSizeCallbacks", new Map());
    _defineProperty(this, "intersectionObserverCallback", ({
      target,
      boundingClientRect
    }) => {
      var _target$dataset, _target$dataset2;
      this.intersectionObserver.unobserve(target);
      if (!(target instanceof HTMLElement)) {
        return;
      }
      const placeholderId = (_target$dataset = target.dataset) === null || _target$dataset === void 0 ? void 0 : _target$dataset[placeholderDataKey];
      if (placeholderId && this.getSizeCallbacks.has(placeholderId)) {
        const resolve = this.getSizeCallbacks.get(placeholderId);
        this.getSizeCallbacks.delete(placeholderId);
        if (!resolve) {
          return;
        }
        resolve({
          x: boundingClientRect.x,
          y: boundingClientRect.y,
          width: boundingClientRect.width,
          height: boundingClientRect.height
        });
        return;
      }
      if (placeholderId && this.isAddedPlaceholderMatchingSizeCallbacks.has(placeholderId)) {
        const resolve = this.isAddedPlaceholderMatchingSizeCallbacks.get(placeholderId);
        this.isAddedPlaceholderMatchingSizeCallbacks.delete(placeholderId);
        if (!resolve) {
          return;
        }
        const placeholder = this.placeholders.get(placeholderId);
        if (!placeholder) {
          resolve(false);
          return;
        }
        resolve(this.areRectsSameSize(placeholder, boundingClientRect));
        return;
      }
      const replaceId = (_target$dataset2 = target.dataset) === null || _target$dataset2 === void 0 ? void 0 : _target$dataset2[replaceDataKey];
      if (replaceId && this.isAddedReplaceMatchingSizeCallbacks.has(replaceId)) {
        const resolve = this.isAddedReplaceMatchingSizeCallbacks.get(replaceId);
        this.isAddedReplaceMatchingSizeCallbacks.delete(replaceId);
        if (!resolve) {
          return;
        }
        const placeholder = this.placeholders.get(replaceId);
        if (!placeholder) {
          resolve(false);
          return;
        }
        this.placeholders.delete(replaceId);
        resolve(this.areRectsSameSize(placeholder, boundingClientRect));
        return;
      }
    });
    const operationTimer = markProfilingStart('EditorLnvHandler constructor');
    this.intersectionObserver = new IntersectionObserver(entries => entries.filter(entry => entry.intersectionRatio > 0).forEach(this.intersectionObserverCallback));
    this.shouldHandleAddedNode = withProfiling(this.shouldHandleAddedNode.bind(this), ['vc']);
    this.handleAddedNode = withProfiling(this.handleAddedNode.bind(this), ['vc']);
    this.clear = withProfiling(this.clear.bind(this), ['vc']);
    this.handleAddedPlaceholderNode = withProfiling(this.handleAddedPlaceholderNode.bind(this), ['vc']);
    this.handleAddedReplaceNode = withProfiling(this.handleAddedReplaceNode.bind(this), ['vc']);
    this.isExistingPlaceholder = withProfiling(this.isExistingPlaceholder.bind(this), ['vc']);
    this.registerPlaceholder = withProfiling(this.registerPlaceholder.bind(this), ['vc']);
    this.getSize = withProfiling(this.getSize.bind(this), ['vc']);
    this.isAddedPlaceholderMatchingSize = withProfiling(this.isAddedPlaceholderMatchingSize.bind(this), ['vc']);
    this.isAddedReplaceMatchingSize = withProfiling(this.isAddedReplaceMatchingSize.bind(this), ['vc']);
    this.areRectsSameSize = withProfiling(this.areRectsSameSize.bind(this), ['vc']);
    this.intersectionObserverCallback = withProfiling(this.intersectionObserverCallback.bind(this), ['vc']);
    markProfilingEnd(operationTimer, {
      tags: ['vc']
    });
  }
  shouldHandleAddedNode(el) {
    var _el$dataset, _el$dataset2;
    return ((_el$dataset = el.dataset) === null || _el$dataset === void 0 ? void 0 : _el$dataset[placeholderDataKey]) || ((_el$dataset2 = el.dataset) === null || _el$dataset2 === void 0 ? void 0 : _el$dataset2[replaceDataKey]);
  }
  handleAddedNode(el) {
    var _el$dataset3, _el$dataset4;
    // If it placeholder does not already exist, add it to the map
    const placeholderId = (_el$dataset3 = el.dataset) === null || _el$dataset3 === void 0 ? void 0 : _el$dataset3[placeholderDataKey];
    if (placeholderId) {
      return this.handleAddedPlaceholderNode(el, placeholderId);
    }
    const replaceId = (_el$dataset4 = el.dataset) === null || _el$dataset4 === void 0 ? void 0 : _el$dataset4[replaceDataKey];
    if (replaceId) {
      return this.handleAddedReplaceNode(el, replaceId);
    }
    return Promise.resolve({
      shouldIgnore: false
    });
  }
  clear() {
    this.placeholders.clear();
    this.intersectionObserver.disconnect();
  }
  handleAddedPlaceholderNode(el, placeholderId) {
    if (this.isExistingPlaceholder(placeholderId)) {
      return this.isAddedPlaceholderMatchingSize(el, placeholderId).then(isMatching => ({
        shouldIgnore: isMatching
      }));
    }
    return this.registerPlaceholder(el, placeholderId).then(() => ({
      shouldIgnore: false
    }));
  }
  handleAddedReplaceNode(el, placeholderId) {
    if (this.isExistingPlaceholder(placeholderId)) {
      return this.isAddedReplaceMatchingSize(el, placeholderId).then(isMatching => ({
        shouldIgnore: isMatching
      }));
    }
    return Promise.resolve({
      shouldIgnore: false
    });
  }
  isExistingPlaceholder(placeholderId) {
    return this.placeholders.has(placeholderId);
  }
  registerPlaceholder(el, placeholderId) {
    return this.getSize(el, placeholderId).then(size => {
      this.placeholders.set(placeholderId, size);
    });
  }
  getSize(el, placeholderId) {
    return new Promise(resolve => {
      this.getSizeCallbacks.set(placeholderId, resolve);
      this.intersectionObserver.observe(el);
    });
  }
  isAddedPlaceholderMatchingSize(el, placeholderId) {
    return new Promise(resolve => {
      this.isAddedPlaceholderMatchingSizeCallbacks.set(placeholderId, resolve);
      this.intersectionObserver.observe(el);
    });
  }
  isAddedReplaceMatchingSize(el, placeholderId) {
    return new Promise(resolve => {
      this.isAddedReplaceMatchingSizeCallbacks.set(placeholderId, resolve);
      this.intersectionObserver.observe(el);
    });
  }
  areRectsSameSize(a, b) {
    return Math.abs(a.width - b.width) < 1 && Math.abs(a.height - b.height) < 1;
  }
}