import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { withProfiling } from '../../../self-measurements';
import { ViewportUpdateClassifier } from './ViewportUpdateClassifier';
const legacyIgnoreReasons = ['image', 'ssr-hydration', 'editor-lazy-node-view'];
export class FY25_01Classifier extends ViewportUpdateClassifier {
  VCCalculationMethod({
    VCParts,
    entries,
    totalPainted,
    componentsLog
  }) {
    const VC = {};
    const VCBox = {};
    entries.reduce((acc = 0, v) => {
      let VCRatio = v[1] / totalPainted + acc;
      const time = v[0];

      // @todo apply fix to include small changes into accumulator
      const preciseCurrRatio = Math.round(100 * (v[1] / totalPainted));
      const preciseAccRatio = Math.round(acc * 100);
      VCRatio = (preciseCurrRatio + preciseAccRatio) / 100;
      VCParts.forEach(value => {
        if ((VC[value] === null || VC[value] === undefined) && VCRatio >= value / 100) {
          var _componentsLog$time;
          VC[value] = time;
          VCBox[value] = new Set();
          (_componentsLog$time = componentsLog[time]) === null || _componentsLog$time === void 0 ? void 0 : _componentsLog$time.forEach(v => {
            var _VCBox$value;
            return (_VCBox$value = VCBox[value]) === null || _VCBox$value === void 0 ? void 0 : _VCBox$value.add(v.targetName);
          });
        }
      });
      return VCRatio;
    }, 0);
    return {
      VC,
      VCBox
    };
  }
  constructor() {
    super();
    _defineProperty(this, "revision", 'fy25.01');
    _defineProperty(this, "types", ['html', 'text']);
    _defineProperty(this, "filters", [{
      name: 'default-ignore-reasons',
      filter: ({
        type,
        ignoreReason
      }) => {
        return !ignoreReason || !legacyIgnoreReasons.includes(ignoreReason);
      }
    }]);
    this.mergeConfig();
    this.VCCalculationMethod = withProfiling(this.VCCalculationMethod.bind(this), ['vc']);
  }
}
export const revFY25_01Classifier = new FY25_01Classifier();