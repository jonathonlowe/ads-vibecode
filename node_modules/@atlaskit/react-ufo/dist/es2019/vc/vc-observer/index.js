import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _VCObserver;
import { fg } from '@atlaskit/platform-feature-flags';
import { markProfilingEnd, markProfilingStart, withProfiling } from '../../self-measurements';
import { attachAbortListeners } from './attachAbortListeners';
import { getVCRevisionsData } from './getVCRevisionsData';
import { getViewportHeight, getViewportWidth } from './getViewport';
import { MultiRevisionHeatmap } from './heatmap/heatmap';
import { Observers } from './observers';
import { getRevisions } from './revisions/revisions';
const abortReason = {
  scroll: 'scroll',
  keypress: 'keypress',
  resize: 'resize',
  error: 'error'
};
const UNUSED_SECTOR = 0;
const filterComponentsLog = withProfiling(function filterComponentsLog(log) {
  return Object.fromEntries(Object.entries(log).map(([timestamp, entries]) => [Number(timestamp), entries.map(entry => {
    const {
      __debug__element,
      ...rest
    } = entry;
    return rest;
  })]));
}, ['vc']);
export class VCObserver {
  constructor(options) {
    /* abort logic */
    _defineProperty(this, "abortReason", {
      reason: null,
      info: '',
      timestamp: -1,
      blocking: false
    });
    _defineProperty(this, "outOfBoundaryInfo", '');
    _defineProperty(this, "viewport", {
      w: 0,
      h: 0
    });
    /* heatmap */
    _defineProperty(this, "arraySize", 0);
    _defineProperty(this, "multiHeatmap", null);
    _defineProperty(this, "componentsLog", {});
    _defineProperty(this, "vcRatios", {});
    _defineProperty(this, "active", false);
    _defineProperty(this, "totalTime", 0);
    _defineProperty(this, "startTime", 0);
    _defineProperty(this, "_startMeasureTimestamp", -1);
    _defineProperty(this, "ssr", {
      reactRendered: -1
    });
    _defineProperty(this, "unbind", []);
    _defineProperty(this, "getAbortReasonInfo", () => {
      if (this.abortReason.reason === null) {
        return null;
      }
      const info = this.abortReason.info !== '' ? ` ${this.abortReason.info}` : '';
      return `${this.abortReason.reason}${info}`;
    });
    _defineProperty(this, "getVCRawData", () => {
      this.measureStart();
      if (!this.active) {
        this.measureStop();
        return null;
      }
      this.stop();
      const abortReasonInfo = this.getAbortReasonInfo();
      this.measureStop();
      return {
        abortReasonInfo,
        abortReason: {
          ...this.abortReason
        },
        heatmap: this.heatmap,
        heatmapNext: this.heatmapNext,
        multiHeatmap: this.multiHeatmap,
        outOfBoundaryInfo: this.outOfBoundaryInfo,
        totalTime: Math.round(this.totalTime + this.observers.getTotalTime()),
        componentsLog: {
          ...this.componentsLog
        },
        viewport: {
          ...this.viewport
        },
        oldDomUpdatesEnabled: this.oldDomUpdatesEnabled,
        devToolsEnabled: this.devToolsEnabled,
        ratios: this.vcRatios
      };
    });
    _defineProperty(this, "getVCResult", async ({
      start,
      stop,
      tti,
      prefix,
      ssr,
      vc,
      isEventAborted
    }) => {
      const startTime = performance.now();
      // add local measurement
      const fullPrefix = prefix !== undefined && prefix !== '' ? `${prefix}:` : '';
      const rawData = vc !== undefined ? vc : this.getVCRawData();
      if (rawData === null) {
        return {};
      }
      const {
        abortReason,
        abortReasonInfo,
        heatmap,
        heatmapNext,
        outOfBoundaryInfo,
        totalTime,
        componentsLog,
        viewport,
        devToolsEnabled,
        ratios,
        multiHeatmap
      } = rawData;
      if (abortReasonInfo !== null && abortReason.blocking) {
        // exposing data to devtools
        try {
          if (devToolsEnabled && !this.isPostInteraction) {
            window.__vcNotAvailableReason = abortReasonInfo;
          }
        } catch (e) {}
        return {
          [`${fullPrefix}vc:state`]: false,
          [`${fullPrefix}vc:abort:reason`]: abortReasonInfo,
          [`${fullPrefix}vc:abort:timestamp`]: abortReason.timestamp
        };
      }
      const isTTVCv1Disabled = fg('platform_ufo_disable_ttvc_v1');
      const ttvcV1Result = isTTVCv1Disabled ? {
        VC: {},
        VCBox: {},
        VCEntries: {
          abs: [],
          rel: [],
          speedIndex: -1
        },
        totalPainted: -1
      } : VCObserver.calculateVC({
        heatmap,
        ssr,
        componentsLog: {
          ...componentsLog
        },
        viewport
      });
      const {
        VC,
        VCBox,
        VCEntries,
        totalPainted
      } = ttvcV1Result;
      const _componentsLog = {};
      Object.entries(this.componentsLog).forEach(([_timestamp, value]) => {
        const timestamp = Number(_timestamp);
        if (stop > timestamp) {
          _componentsLog[timestamp] = value;
        }
      });
      const vcNext = VCObserver.calculateVC({
        heatmap: heatmapNext,
        ssr,
        componentsLog: _componentsLog,
        viewport
      });
      try {
        if (!this.isPostInteraction) {
          VCObserver.VCParts.forEach(key => {
            if (isTTVCv1Disabled) {
              const duration = vcNext.VC[key];
              if (duration !== null && duration !== undefined) {
                performance.measure(`VC${key}`, {
                  start,
                  duration
                });
                performance.measure(`VC_Next${key}`, {
                  start,
                  duration
                });
              }
            } else {
              const ttvcV1duration = VC[key];
              if (ttvcV1duration !== null && ttvcV1duration !== undefined) {
                performance.measure(`VC${key}`, {
                  start,
                  duration: ttvcV1duration
                });
              }
              const ttvcV2duration = vcNext.VC[key];
              if (ttvcV2duration !== null && ttvcV2duration !== undefined) {
                performance.measure(`VC_Next${key}`, {
                  start,
                  duration: ttvcV2duration
                });
              }
            }
          });
        }
      } catch (e) {
        /* empty */
      }
      const outOfBoundary = outOfBoundaryInfo ? {
        [`${fullPrefix}vc:oob`]: outOfBoundaryInfo
      } : {};
      //const oldDomUpdates = oldDomUpdatesEnabled ? { [`${fullPrefix}vc:old:dom`]: vcNext.VCBox } : {};

      const stopTime = performance.now();

      // exposing data to devtools
      try {
        if (!this.isPostInteraction && devToolsEnabled) {
          const ttvcV1DevToolInfo = isTTVCv1Disabled ? undefined : {
            entries: VCEntries.rel,
            log: componentsLog,
            metrics: {
              '75': VC['75'],
              '80': VC['80'],
              '85': VC['85'],
              '90': VC['90'],
              '95': VC['95'],
              '98': VC['98'],
              '99': VC['99'],
              tti,
              ttai: stop - start
            },
            start,
            stop,
            heatmap,
            ratios
          };
          const ttvcV2DevToolInfo = {
            entries: vcNext.VCEntries.rel,
            log: componentsLog,
            metrics: {
              '75': vcNext.VC['75'],
              '80': vcNext.VC['80'],
              '85': vcNext.VC['85'],
              '90': vcNext.VC['90'],
              '95': vcNext.VC['95'],
              '98': vcNext.VC['98'],
              '99': vcNext.VC['99'],
              tti,
              ttai: stop - start
            },
            start,
            stop,
            heatmap: heatmapNext,
            ratios
          };
          if (isTTVCv1Disabled) {
            window.__vc = ttvcV2DevToolInfo;
            window.__vcNext = ttvcV2DevToolInfo;
          } else {
            window.__vc = ttvcV1DevToolInfo;
            window.__vcNext = ttvcV2DevToolInfo;
          }

          // Emitting a custom event to make it available in the Chrome extension
          window.dispatchEvent(new CustomEvent('vcReady', {
            detail: {
              log: filterComponentsLog(componentsLog),
              entries: isTTVCv1Disabled ? vcNext.VCEntries.rel : VCEntries.rel
            }
          }));
        }
      } catch (e) {
        /*  do nothing */
      }
      const isVCClean = !abortReasonInfo;
      const revisionsData = getVCRevisionsData({
        fullPrefix,
        interaction: {
          start,
          end: stop
        },
        isVCClean,
        multiHeatmap,
        ssr,
        calculatedVC: {
          VC,
          VCBox
        },
        calculatedVCNext: {
          VC: vcNext.VC,
          VCBox: vcNext.VCBox
        },
        isEventAborted
      });
      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      const isCalcSpeedIndexEnabled = fg('ufo-calc-speed-index');
      const speedIndex = {
        [`ufo:speedIndex`]: isTTVCv1Disabled ? vcNext.VCEntries.speedIndex : VCEntries.speedIndex,
        [`ufo:next:speedIndex`]: vcNext.VCEntries.speedIndex
      };
      if (isTTVCv1Disabled) {
        return {
          [`${fullPrefix}vc:size`]: viewport,
          [`${fullPrefix}vc:time`]: Math.round(totalTime + (stopTime - startTime)),
          [`${fullPrefix}vc:ratios`]: ratios,
          ...outOfBoundary,
          [`${fullPrefix}vc:ignored`]: this.getIgnoredElements(componentsLog),
          ...revisionsData,
          ...(isCalcSpeedIndexEnabled ? speedIndex : {})
        };
      }
      return {
        'metrics:vc': VC,
        [`${fullPrefix}vc:state`]: true,
        [`${fullPrefix}vc:clean`]: isVCClean,
        [`${fullPrefix}vc:dom`]: VCBox,
        [`${fullPrefix}vc:updates`]: fg('platform_ufo_vc_observer_new') ? undefined : VCEntries.rel.slice(0, 50),
        // max 50
        [`${fullPrefix}vc:size`]: viewport,
        [`${fullPrefix}vc:time`]: Math.round(totalTime + (stopTime - startTime)),
        [`${fullPrefix}vc:total`]: totalPainted,
        [`${fullPrefix}vc:ratios`]: ratios,
        ...outOfBoundary,
        [`${fullPrefix}vc:next`]: vcNext.VC,
        [`${fullPrefix}vc:next:updates`]: fg('platform_ufo_vc_observer_new') ? undefined : vcNext.VCEntries.rel.slice(0, 50),
        // max 50
        [`${fullPrefix}vc:next:dom`]: vcNext.VCBox,
        [`${fullPrefix}vc:ignored`]: this.getIgnoredElements(componentsLog),
        ...revisionsData,
        ...(isCalcSpeedIndexEnabled ? speedIndex : {})
      };
    });
    _defineProperty(this, "handleUpdate", (rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue) => {
      this.measureStart();
      this.legacyHandleUpdate(rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue);
      if (!fg('platform_ufo_vc_observer_new')) {
        this.onViewportChangeDetected({
          timestamp: rawTime,
          intersectionRect,
          targetName,
          element,
          type,
          ignoreReason,
          attributeName,
          oldValue,
          newValue
        });
      }
      this.measureStop();
    });
    _defineProperty(this, "legacyHandleUpdate", (rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue) => {
      if (this.abortReason.reason === null || this.abortReason.blocking === false) {
        const time = Math.round(rawTime - this.startTime);
        const mappedValues = this.mapPixelsToHeatmap(intersectionRect.left, intersectionRect.top, intersectionRect.width, intersectionRect.height);
        this.vcRatios[targetName] = this.getElementRatio(mappedValues);
        if (!ignoreReason) {
          this.applyChangesToHeatMap(mappedValues, time, this.heatmapNext);
        }
        const isTTVCv1Disabled = fg('platform_ufo_disable_ttvc_v1');
        if (!isTTVCv1Disabled && (!ignoreReason || ignoreReason === 'not-visible') && type !== 'attr') {
          this.applyChangesToHeatMap(mappedValues, time, this.heatmap);
        }
        if (!this.componentsLog[time]) {
          this.componentsLog[time] = [];
        }
        this.componentsLog[time].push({
          __debug__element: this.devToolsEnabled ? new WeakRef(element) : null,
          type,
          intersectionRect,
          targetName,
          ignoreReason,
          attributeName,
          oldValue,
          newValue
        });
      }
    });
    _defineProperty(this, "onViewportChangeDetected", ({
      element,
      type,
      ignoreReason,
      timestamp,
      targetName,
      intersectionRect,
      attributeName,
      oldValue,
      newValue
    }) => {
      if (this.multiHeatmap === null) {
        return;
      }
      // @todo add abort reason handling
      const time = Math.round(timestamp - this.startTime);
      const revisions = getRevisions();
      const revisionsClassification = revisions.map(revision => {
        return revision.classifier.classifyUpdate({
          element,
          type,
          ignoreReason
        });
      }, []);
      this.multiHeatmap.handleUpdate({
        time,
        targetName,
        intersectionRect,
        type,
        element,
        classification: revisionsClassification,
        onError: error => {
          this.setAbortReason(abortReason.error, error.time, error.error);
        },
        attributeName,
        oldValue,
        newValue
      });
    });
    _defineProperty(this, "mapPixelsToHeatmap", (left, top, width, height) => {
      const {
        w,
        h
      } = this.viewport;
      const l = Math.floor(left / w * this.arraySize);
      const t = Math.floor(top / h * this.arraySize);
      const r = Math.ceil((left + width) / w * this.arraySize);
      const b = Math.ceil((top + height) / h * this.arraySize);

      // that info is temporary to get info why it goes over boundary
      if (this.outOfBoundaryInfo === '') {
        let outOfBoundaryInfo = '';
        if (r > this.arraySize) {
          outOfBoundaryInfo += ` r ${r} ! ${left} ${width}`;
        }
        if (b > this.arraySize) {
          outOfBoundaryInfo += ` r ${r} ! ${top} ${height}`;
        }
        this.outOfBoundaryInfo = outOfBoundaryInfo;
      }

      // correct values to min - 0, max - arraySize
      const result = {
        l: Math.max(0, l),
        t: Math.max(0, t),
        r: Math.min(this.arraySize, r),
        b: Math.min(this.arraySize, b)
      };
      return result;
    });
    _defineProperty(this, "getElementRatio", mappedValues => {
      const {
        r,
        l,
        b,
        t
      } = mappedValues;
      return (r - l) * (b - t) / (this.arraySize * this.arraySize);
    });
    _defineProperty(this, "abortReasonCallback", (key, time) => {
      switch (key) {
        case 'wheel':
          this.setAbortReason(abortReason.scroll, time);
          break;
        case 'keydown':
          this.setAbortReason(abortReason.keypress, time);
          break;
        case 'resize':
          this.setAbortReason(abortReason.resize, time);
          break;
      }
    });
    _defineProperty(this, "attachAbortListeners", () => {
      var _window;
      this.detachAbortListeners();
      let unbinds = attachAbortListeners(window, this.viewport, this.abortReasonCallback);
      if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
        var _window2;
        Object.entries(window.__SSR_ABORT_LISTENERS__.aborts).forEach(([key, time]) => {
          if (time) {
            this.abortReasonCallback(key, time);
          }
        });
        unbinds = unbinds.concat(window.__SSR_ABORT_LISTENERS__.unbinds);
        (_window2 = window) === null || _window2 === void 0 ? true : delete _window2.__SSR_ABORT_LISTENERS__;
      }
      this.unbind = unbinds;
    });
    const operationTimer = markProfilingStart('VCObserver constructor');
    this.arraySize = options.heatmapSize || 200;
    this.devToolsEnabled = options.devToolsEnabled || false;
    this.oldDomUpdatesEnabled = options.oldDomUpdates || false;
    this.observers = new Observers({
      selectorConfig: options.selectorConfig || {
        id: false,
        testId: false,
        role: false,
        className: true,
        dataVC: true
      }
    });
    this.heatmap = fg('platform_ufo_disable_ttvc_v1') ? [] : this.getCleanHeatmap();
    this.heatmapNext = this.getCleanHeatmap();
    this.multiHeatmap = new MultiRevisionHeatmap({
      viewport: this.viewport,
      revisions: getRevisions(),
      devToolsEnabled: this.devToolsEnabled
    });
    this.isPostInteraction = options.isPostInteraction || false;
    this.start = withProfiling(this.start.bind(this), ['vc']);
    this.stop = withProfiling(this.stop.bind(this), ['vc']);
    this.getAbortReasonInfo = withProfiling(this.getAbortReasonInfo.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getVCRawData = withProfiling(this.getVCRawData.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getIgnoredElements = withProfiling(this.getIgnoredElements.bind(this), ['vc']);
    this.getVCResult = withProfiling(this.getVCResult.bind(this), ['vc']);
    this.setSSRElement = withProfiling(this.setSSRElement.bind(this), ['vc']);
    this.setReactRootRenderStart = withProfiling(this.setReactRootRenderStart.bind(this), ['vc']);
    this.setReactRootRenderStop = withProfiling(this.setReactRootRenderStop.bind(this), ['vc']);
    this.handleUpdate = withProfiling(this.handleUpdate.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.legacyHandleUpdate = withProfiling(this.legacyHandleUpdate.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.onViewportChangeDetected = withProfiling(this.onViewportChangeDetected.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.setAbortReason = withProfiling(this.setAbortReason.bind(this), ['vc']);
    this.resetState = withProfiling(this.resetState.bind(this), ['vc']);
    this.setViewportSize = withProfiling(this.setViewportSize.bind(this), ['vc']);
    this.mapPixelsToHeatmap = withProfiling(this.mapPixelsToHeatmap.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.getElementRatio = withProfiling(this.getElementRatio.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.applyChangesToHeatMap = withProfiling(this.applyChangesToHeatMap.bind(this), ['vc']);
    this.abortReasonCallback = withProfiling(this.abortReasonCallback.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.attachAbortListeners = withProfiling(this.attachAbortListeners.bind(this), ['vc']); // TODO: confirm correct value of `this`
    this.detachAbortListeners = withProfiling(this.detachAbortListeners.bind(this), ['vc']);
    this.measureStart = withProfiling(this.measureStart.bind(this), ['vc']);
    this.measureStop = withProfiling(this.measureStop.bind(this), ['vc']);
    markProfilingEnd(operationTimer, {
      tags: ['vc']
    });
  }
  start({
    startTime
  }) {
    this.active = true;
    if (this.observers.isBrowserSupported()) {
      this.setViewportSize();
      this.resetState();
      this.startTime = startTime;
      this.attachAbortListeners();
      this.observers.subscribeResults(this.handleUpdate);
      this.observers.observe();
    } else {
      this.setAbortReason('not-supported', startTime);
    }
  }
  stop() {
    this.observers.disconnect();
    this.detachAbortListeners();
  }
  getIgnoredElements(componentsLog) {
    return Object.values(componentsLog).flat().filter(({
      ignoreReason
    }) => Boolean(ignoreReason)).map(({
      targetName,
      ignoreReason
    }) => ({
      targetName,
      ignoreReason
    }));
  }
  setSSRElement(element) {
    this.observers.setReactRootElement(element);
  }
  setReactRootRenderStart(startTime = performance.now()) {
    this.observers.setReactRootRenderStart(startTime);
  }
  setReactRootRenderStop(stopTime = performance.now()) {
    this.observers.setReactRootRenderStop(stopTime);
  }
  setAbortReason(abort, timestamp, info = '') {
    if (this.abortReason.reason === null || this.abortReason.blocking === false) {
      this.abortReason.reason = abort;
      this.abortReason.info = info;
      this.abortReason.timestamp = timestamp;
      this.abortReason.blocking = abort !== abortReason.scroll;
      if (this.abortReason.blocking) {
        this.detachAbortListeners();
      }
    }
  }
  resetState() {
    this.abortReason = {
      reason: null,
      info: '',
      timestamp: -1,
      blocking: false
    };
    this.detachAbortListeners();
    this.heatmap = fg('platform_ufo_disable_ttvc_v1') ? [] : this.getCleanHeatmap();
    this.heatmapNext = this.getCleanHeatmap();
    this.multiHeatmap = new MultiRevisionHeatmap({
      viewport: this.viewport,
      revisions: getRevisions(),
      devToolsEnabled: this.devToolsEnabled
    });
    this.totalTime = 0;
    this.componentsLog = {};
    this.vcRatios = {};
  }
  getCleanHeatmap() {
    return Array(this.arraySize).fill('').map(() => Array(this.arraySize).fill(UNUSED_SECTOR));
  }
  setViewportSize() {
    this.viewport.w = getViewportWidth();
    this.viewport.h = getViewportHeight();
  }
  applyChangesToHeatMap(a, time, heatmap) {
    const {
      l,
      t,
      r,
      b
    } = a;
    const localHeatmap = heatmap;
    for (let row = t; row < b; row++) {
      for (let col = l; col < r; col++) {
        if (localHeatmap[row] === undefined) {
          try {
            this.setAbortReason(abortReason.error, time, `index - ${row}`);
          } catch (e) {
            this.setAbortReason(abortReason.error, time, 'row error');
          }
          return;
        } else {
          localHeatmap[row][col] = time;
        }
      }
    }
  }
  detachAbortListeners() {
    this.unbind.forEach(fn => fn());
    this.unbind = [];
  }
  measureStart() {
    this._startMeasureTimestamp = performance.now();
  }
  measureStop() {
    if (this._startMeasureTimestamp === -1) {
      return;
    }
    this.totalTime += performance.now() - this._startMeasureTimestamp;
    this._startMeasureTimestamp = -1;
  }
}
_VCObserver = VCObserver;
/** config * */
_defineProperty(VCObserver, "VCParts", ['25', '50', '75', '80', '85', '90', '95', '98', '99']);
_defineProperty(VCObserver, "calculateVC", withProfiling(function calculateVC({
  heatmap,
  ssr = UNUSED_SECTOR,
  componentsLog,
  viewport
}) {
  const lastUpdate = {};
  let totalPainted = 0;
  if (ssr !== UNUSED_SECTOR) {
    var _window$document;
    const element = {
      __debug__element: new WeakRef((_window$document = window.document) === null || _window$document === void 0 ? void 0 : _window$document.body),
      intersectionRect: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        x: 0,
        y: 0,
        width: viewport.w,
        height: viewport.h,
        toJSON() {
          return {};
        }
      },
      targetName: 'SSR'
    };
    if (!componentsLog[ssr]) {
      componentsLog[ssr] = [];
    }
    componentsLog[ssr].push(element);
  }
  heatmap.forEach(line => {
    line.forEach(entry => {
      const rounded = Math.floor(entry === UNUSED_SECTOR && ssr !== UNUSED_SECTOR ? ssr : entry);
      totalPainted += rounded !== UNUSED_SECTOR ? 1 : 0;
      if (rounded !== UNUSED_SECTOR) {
        lastUpdate[rounded] = lastUpdate[rounded] ? lastUpdate[rounded] + 1 : 1;
      }
    });
  });
  const entries = Object.entries(lastUpdate).map(a => [parseInt(a[0], 10), a[1]]).sort((a, b) => a[0] > b[0] ? 1 : -1);
  const VC = _VCObserver.makeVCReturnObj();
  const VCBox = _VCObserver.makeVCReturnObj();

  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
  const isCalcSpeedIndexEnabled = fg('ufo-calc-speed-index');
  entries.reduce((acc = 0, v) => {
    const currRatio = v[1] / totalPainted;
    let VCRatio = currRatio + acc;
    const preciseCurrRatio = Math.round(100 * (v[1] / totalPainted));
    const preciseAccRatio = Math.round(acc * 100);
    VCRatio = (preciseCurrRatio + preciseAccRatio) / 100;
    const time = v[0];
    _VCObserver.VCParts.forEach(key => {
      const value = parseInt(key, 10);
      if ((VC[key] === null || VC[key] === undefined) && VCRatio >= value / 100) {
        var _componentsLog$time;
        VC[key] = time;
        VCBox[key] = [...new Set((_componentsLog$time = componentsLog[time]) === null || _componentsLog$time === void 0 ? void 0 : _componentsLog$time.filter(v => !v.ignoreReason).map(v => v.targetName))];
      }
    });
    return VCRatio;
  }, 0);
  const VCEntries = entries.reduce((acc, [timestamp, entryPainted], i) => {
    var _acc$abs, _componentsLog$timest, _acc$rel$vc, _acc$rel;
    const currentlyPainted = entryPainted + (((_acc$abs = acc.abs[i - 1]) === null || _acc$abs === void 0 ? void 0 : _acc$abs[1]) || 0);
    const currentlyPaintedRatio = Math.round(currentlyPainted / totalPainted * 1000) / 10;
    const logEntry = [...new Set((_componentsLog$timest = componentsLog[timestamp]) === null || _componentsLog$timest === void 0 ? void 0 : _componentsLog$timest.filter(v => !v.ignoreReason).map(v => v.targetName))];
    const ratioDelta = (currentlyPaintedRatio - ((_acc$rel$vc = (_acc$rel = acc.rel[i - 1]) === null || _acc$rel === void 0 ? void 0 : _acc$rel.vc) !== null && _acc$rel$vc !== void 0 ? _acc$rel$vc : 0)) / 100;
    if (isCalcSpeedIndexEnabled) {
      const speedIndex = timestamp * ratioDelta;
      acc.speedIndex += speedIndex;
    }
    acc.abs.push([timestamp, currentlyPainted]);
    acc.rel.push({
      time: timestamp,
      vc: currentlyPaintedRatio,
      elements: logEntry
    });
    return acc;
  }, {
    abs: [],
    rel: [],
    speedIndex: 0
  });
  VCEntries.speedIndex = Math.round(VCEntries.speedIndex);
  return {
    VC,
    VCBox,
    VCEntries,
    totalPainted
  };
}, ['vc']));
_defineProperty(VCObserver, "makeVCReturnObj", withProfiling(function makeVCReturnObj() {
  const vc = {};
  _VCObserver.VCParts.forEach(v => {
    vc[v] = null;
  });
  return vc;
}, ['vc']));