import { withProfiling } from '../../../../self-measurements';
const createMutationObserver = withProfiling(function createMutationObserver(props) {
  if (!window || typeof window.IntersectionObserver !== 'function') {
    return null;
  }
  const onAttributeMutation = withProfiling(props.onAttributeMutation, ['vc']);
  const onChildListMutation = withProfiling(props.onChildListMutation, ['vc']);
  const onMutationFinished = typeof props.onMutationFinished === 'function' ? withProfiling(props.onMutationFinished, ['vc']) : undefined;
  const mutationObserverCallback = withProfiling(function mutationObserverCallback(mutations) {
    const addedNodes = [];
    const removedNodes = [];
    const targets = [];
    for (const mut of mutations) {
      if (!(mut.target instanceof HTMLElement)) {
        continue;
      }
      if (mut.type === 'attributes') {
        var _mut$oldValue;
        /*
        	"MutationObserver was explicitly designed to work that way, but I can't now recall the reasoning.
        	I think it might have been something along the lines that for consistency every setAttribute call should create a record.
        	Conceptually there is after all a mutation: there is an old value replaced with a new one,
        	and whether or not they are the same doesn't really matter.
        	And Custom elements should work the same way as MutationObserver."
        	https://github.com/whatwg/dom/issues/520#issuecomment-336574796
        */
        const oldValue = (_mut$oldValue = mut.oldValue) !== null && _mut$oldValue !== void 0 ? _mut$oldValue : undefined;
        const newValue = mut.attributeName ? mut.target.getAttribute(mut.attributeName) : undefined;
        if (oldValue !== newValue) {
          var _mut$attributeName;
          onAttributeMutation({
            target: mut.target,
            attributeName: (_mut$attributeName = mut.attributeName) !== null && _mut$attributeName !== void 0 ? _mut$attributeName : 'unknown'
          });
        }
        continue;
      } else if (mut.type === 'childList') {
        var _mut$addedNodes, _mut$removedNodes;
        ((_mut$addedNodes = mut.addedNodes) !== null && _mut$addedNodes !== void 0 ? _mut$addedNodes : []).forEach(node => {
          if (node instanceof HTMLElement) {
            addedNodes.push(node);
          }
        });
        ((_mut$removedNodes = mut.removedNodes) !== null && _mut$removedNodes !== void 0 ? _mut$removedNodes : []).forEach(node => {
          if (node instanceof HTMLElement) {
            removedNodes.push(node);
          }
        });
      }
      targets.push(mut.target);
    }
    onChildListMutation({
      addedNodes,
      removedNodes
    });
    onMutationFinished === null || onMutationFinished === void 0 ? void 0 : onMutationFinished({
      targets
    });
  });
  const observer = new MutationObserver(mutationObserverCallback);
  return observer;
}, ['vc']);
export default createMutationObserver;