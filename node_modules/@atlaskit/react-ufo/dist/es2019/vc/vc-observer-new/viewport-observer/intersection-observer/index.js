import { withProfiling } from '../../../../self-measurements';
const isValidEntry = withProfiling(function isValidEntry(entry) {
  return entry.isIntersecting && entry.intersectionRect.width > 0 && entry.intersectionRect.height > 0;
}, ['vc']);
export function createIntersectionObserver(args) {
  if (!window || typeof window.IntersectionObserver !== 'function') {
    return null;
  }
  const onEntry = withProfiling(args.onEntry, ['vc']);
  const onObserved = typeof args.onObserved === 'function' ? withProfiling(args.onObserved, ['vc']) : undefined;
  const callbacksPerElement = new WeakMap();
  const intersectionObserverCallback = withProfiling(function intersectionObserverCallback(entries) {
    const validEntries = [];
    const startTime = performance.now();
    entries.forEach(entry => {
      var _mutationTag;
      if (!(entry.target instanceof HTMLElement) || !isValidEntry(entry)) {
        return;
      }
      let mutationTag = null;
      let mutationData = null;
      const tagOrCallback = callbacksPerElement.get(entry.target);
      if (typeof tagOrCallback === 'function') {
        const tagOrCallbackResult = tagOrCallback({
          target: entry.target,
          rect: entry.intersectionRect
        });
        if (!tagOrCallbackResult) {
          mutationTag = 'unknown';
        } else if (typeof tagOrCallbackResult === 'string') {
          mutationTag = tagOrCallbackResult;
        } else {
          mutationTag = tagOrCallbackResult.type;
          mutationData = tagOrCallbackResult.mutationData;
        }
      } else if (typeof tagOrCallback === 'string') {
        mutationTag = tagOrCallback;
      }
      onEntry({
        target: entry.target,
        rect: entry.intersectionRect,
        time: entry.time,
        type: (_mutationTag = mutationTag) !== null && _mutationTag !== void 0 ? _mutationTag : 'unknown',
        mutationData
      });
      validEntries.push(new WeakRef(entry.target));
      callbacksPerElement.delete(entry.target);
      observer.unobserve(entry.target);
    });
    onObserved === null || onObserved === void 0 ? void 0 : onObserved({
      time: startTime,
      elements: validEntries
    });
  });
  const observer = new IntersectionObserver(intersectionObserverCallback);
  return {
    disconnect: () => {
      observer.disconnect();
    },
    unobserve: target => {
      observer.unobserve(target);
    },
    watchAndTag: (target, tagOrCallback) => {
      callbacksPerElement.set(target, tagOrCallback);
      observer.observe(target);
    }
  };
}