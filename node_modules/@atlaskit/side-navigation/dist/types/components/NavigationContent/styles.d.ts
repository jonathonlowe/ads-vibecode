interface StyleOpts {
    showTopScrollIndicator?: boolean;
}
/**
 * This outer container css contains the "real" scroll indicators which are
 * always rendered to the screen.
 * They are "conditionally" shown from the users perspective using the inner container CSS
 * which has other pseudo elements which "mask" the "real" scroll indicators.
 */
export declare const outerContainerCSS: (opts: StyleOpts & {
    scrollbarWidth: number;
}) => {
    readonly display: "flex";
    readonly height: "100%";
    readonly overflow: "hidden";
    readonly position: "relative";
    readonly '&::before': {
        readonly content: "''";
        readonly display: "block";
        readonly left: "var(--ds-space-100)";
        readonly right: number;
        readonly height: 2;
        readonly borderRadius: "var(--ds-border-radius-050)";
        readonly backgroundColor: "var(--ds-menu-seperator-color, var(--ds-border))";
        readonly position: "absolute";
        readonly zIndex: 1;
    };
    readonly '&::after': {
        readonly content: "''";
        readonly position: "absolute";
        readonly display: "block";
        readonly borderRadius: "var(--ds-border-radius-050)";
        readonly flexShrink: 0;
        readonly height: 2;
        readonly left: "var(--ds-space-100)";
        readonly right: number;
        readonly bottom: 0;
        readonly zIndex: 1;
        readonly backgroundColor: "var(--ds-menu-seperator-color, var(--ds-border))";
    };
};
/**
 * This inner container css contains the "mask" logic for the scroll indicators.
 * Essentially they cover (mask) the "real" scroll indicators when the user is scrolled
 * to the top or bottom of the container.
 */
export declare const innerContainerCSS: (opts: StyleOpts) => {
    readonly '&::after': {
        readonly borderRadius: "var(--ds-border-radius-050)";
        readonly content: "''";
        readonly display: "block";
        readonly flexShrink: 0;
        readonly height: 2;
        readonly marginTop: "auto";
        readonly position: "relative";
        readonly zIndex: 2;
        readonly backgroundColor: "var(--ds-menu-scroll-indicator-color, var(--ds-surface))";
    };
    readonly '&::before'?: {
        readonly borderRadius: "var(--ds-border-radius-050)";
        readonly content: "''";
        readonly left: 0;
        readonly right: 0;
        readonly height: 2;
        readonly backgroundColor: "var(--ds-menu-scroll-indicator-color, var(--ds-surface))";
        readonly position: "absolute";
        readonly display: "block";
        readonly zIndex: 2;
    } | undefined;
    readonly display: "flex";
    readonly overflow: "auto";
    readonly width: "100%";
    readonly position: "relative";
    readonly boxSizing: "border-box";
    readonly flexDirection: "column";
};
export declare const containerCSS: (opts: StyleOpts) => {
    readonly marginTop: 0 | 2;
    readonly marginLeft: "var(--ds-space-100)";
    readonly marginRight: "var(--ds-space-100)";
    readonly position: "relative";
    readonly '& [data-ds--menu--heading-item]': {
        readonly marginBottom: "var(--ds-space-075)";
        readonly marginTop: "var(--ds-space-200)";
    };
    readonly '& [data-ds--menu--skeleton-heading-item]': {
        readonly marginTop: number;
        readonly marginBottom: number;
    };
};
export {};
