import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import uuidV4 from 'uuid/v4';
import { UploadController, globalMediaEventEmitter, RequestError } from '@atlaskit/media-client';
import { RECENTS_COLLECTION } from '@atlaskit/media-client/constants';
import { EventEmitter2 } from 'eventemitter2';
import { getPreviewFromImage } from '../util/getPreviewFromImage';
import { LocalFileSource } from '../service/types';
import { getPreviewFromBlob } from '../util/getPreviewFromBlob';
import { getRandomHex, isMimeTypeSupportedByBrowser, getMediaTypeFromMimeType } from '@atlaskit/media-common';
var generateTraceContext = function generateTraceContext() {
  return {
    traceId: getRandomHex(8)
  };
};
export var UploadServiceImpl = /*#__PURE__*/function () {
  function UploadServiceImpl(tenantMediaClient, tenantUploadParams, shouldCopyFileToRecents) {
    var _this = this;
    var maxUploadBatchSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 255;
    _classCallCheck(this, UploadServiceImpl);
    _defineProperty(this, "emit", function (event, payload) {
      _this.emitter.emit(event, payload);
    });
    _defineProperty(this, "onFileSuccess", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cancellableFileUpload, fileId, traceContext) {
        var mediaFile;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              mediaFile = cancellableFileUpload.mediaFile;
              _this.emit('file-converting', {
                file: mediaFile,
                traceContext: traceContext
              });
              cancellableFileUpload.cancel = function () {
                _this.releaseCancellableFile(mediaFile);
              };
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "onFileError", function (mediaFile, name, error, traceContext) {
      _this.releaseCancellableFile(mediaFile);
      if (error === 'canceled') {
        // Specific error coming from chunkinator via rejected fileId promise.
        // We do not want to trigger error in this case.
        return;
      }
      var description = error instanceof Error ? error.message : error;
      var rawError = error instanceof Error ? error : undefined;
      _this.emit('file-upload-error', {
        fileId: mediaFile.id,
        error: {
          fileId: mediaFile.id,
          name: name,
          description: description,
          rawError: rawError
        },
        traceContext: traceContext
      });
    });
    this.tenantMediaClient = tenantMediaClient;
    this.tenantUploadParams = tenantUploadParams;
    this.shouldCopyFileToRecents = shouldCopyFileToRecents;
    this.maxUploadBatchSize = maxUploadBatchSize;
    this.emitter = new EventEmitter2();
    this.cancellableFilesUploads = {};
  }
  return _createClass(UploadServiceImpl, [{
    key: "setUploadParams",
    value: function setUploadParams(uploadParams) {
      this.tenantUploadParams = uploadParams;
    }

    // Used for testing
  }, {
    key: "createUploadController",
    value: function createUploadController() {
      return new UploadController();
    }
  }, {
    key: "addFiles",
    value: function addFiles(files) {
      this.addFilesWithSource(files.map(function (file) {
        return {
          file: file,
          source: LocalFileSource.LocalUpload
        };
      }));
    }
  }, {
    key: "addFile",
    value: function addFile(file, replaceFileId) {
      this.addFilesWithSource([{
        file: file,
        source: LocalFileSource.LocalUpload,
        replaceFileId: replaceFileId
      }]);
    }
  }, {
    key: "addFilesWithSource",
    value: function () {
      var _addFilesWithSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(files) {
        var traceContext,
          batches,
          iterator,
          _args2 = arguments;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              traceContext = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : generateTraceContext();
              batches = [];
              for (iterator = 0; iterator < files.length; iterator += this.maxUploadBatchSize) {
                batches.push(this.addFilesAndUpload(files.slice(iterator, iterator + this.maxUploadBatchSize), traceContext));
              }
              _context2.next = 5;
              return Promise.all(batches);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function addFilesWithSource(_x4) {
        return _addFilesWithSource.apply(this, arguments);
      }
      return addFilesWithSource;
    }()
  }, {
    key: "isCancellableFileUpload",
    value: function isCancellableFileUpload(fileUpload) {
      return fileUpload !== null;
    }
  }, {
    key: "cancel",
    value: function cancel(id) {
      var _this2 = this;
      if (id) {
        var cancellableFileUpload = this.cancellableFilesUploads[id];
        if (cancellableFileUpload && cancellableFileUpload.cancel) {
          cancellableFileUpload.cancel();
        }
      } else {
        Object.keys(this.cancellableFilesUploads).forEach(function (key) {
          var cancellableFileUpload = _this2.cancellableFilesUploads[key];
          if (cancellableFileUpload.cancel) {
            cancellableFileUpload.cancel();
          }
        });
      }
    }
  }, {
    key: "on",
    value: function on(event, listener) {
      this.emitter.on(event, listener);
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      this.emitter.off(event, listener);
    }
  }, {
    key: "addFilesAndUpload",
    value: function () {
      var _addFilesAndUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(files, traceContext) {
        var _this3 = this;
        var creationDate, userMediaClient, tenantMediaClient, shouldCopyFileToRecents, mediaClient, _this$tenantUploadPar, collectionTentant, expireAfter, collection, touchFileDescriptors, i, _files$i, replaceFileId, file, touchedFiles, caughtError, cancellableFileUploads, filteredCancellableFileUploads, mediaFiles;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(files.length === 0)) {
                _context3.next = 2;
                break;
              }
              return _context3.abrupt("return");
            case 2:
              creationDate = Date.now();
              userMediaClient = this.userMediaClient, tenantMediaClient = this.tenantMediaClient, shouldCopyFileToRecents = this.shouldCopyFileToRecents;
              mediaClient = shouldCopyFileToRecents ? tenantMediaClient : userMediaClient;
              _this$tenantUploadPar = this.tenantUploadParams, collectionTentant = _this$tenantUploadPar.collection, expireAfter = _this$tenantUploadPar.expireAfter;
              collection = shouldCopyFileToRecents ? collectionTentant : RECENTS_COLLECTION;
              if (mediaClient) {
                _context3.next = 9;
                break;
              }
              return _context3.abrupt("return");
            case 9:
              touchFileDescriptors = [];
              for (i = 0; i < files.length; i++) {
                _files$i = files[i], replaceFileId = _files$i.replaceFileId, file = _files$i.file;
                touchFileDescriptors.push({
                  fileId: replaceFileId || uuidV4(),
                  occurrenceKey: uuidV4(),
                  collection: collection,
                  size: file.size,
                  expireAfter: expireAfter
                });
              }
              _context3.prev = 11;
              _context3.next = 14;
              return mediaClient.file.touchFiles(touchFileDescriptors, collection, traceContext);
            case 14:
              touchedFiles = _context3.sent;
              _context3.next = 20;
              break;
            case 17:
              _context3.prev = 17;
              _context3.t0 = _context3["catch"](11);
              caughtError = _context3.t0;
            case 20:
              cancellableFileUploads = files.map(function (_ref2, i) {
                var _touchedFiles, _touchedFiles2, _caughtError$metadata;
                var file = _ref2.file,
                  source = _ref2.source;
                var _touchFileDescriptors = touchFileDescriptors[i],
                  id = _touchFileDescriptors.fileId,
                  occurrenceKey = _touchFileDescriptors.occurrenceKey;

                // exclude rejected files from being uploaded
                var rejectedFile = (_touchedFiles = touchedFiles) === null || _touchedFiles === void 0 || (_touchedFiles = _touchedFiles.rejected) === null || _touchedFiles === void 0 ? void 0 : _touchedFiles.find(function (_ref3) {
                  var rejectedFileId = _ref3.fileId;
                  return rejectedFileId === id;
                });
                if (rejectedFile) {
                  if (_this3.fileRejectionHandler) {
                    _this3.fileRejectionHandler({
                      reason: 'fileSizeLimitExceeded',
                      fileName: file.name,
                      limit: rejectedFile.error.limit
                    });
                  }
                  return null;
                }

                // exclude empty files from being uploaded
                if (file.size === 0) {
                  if (_this3.fileEmptyHandler) {
                    _this3.fileEmptyHandler({
                      reason: 'fileEmpty',
                      fileName: file.name
                    });
                  }
                  return null;
                }
                var touchedFile = (_touchedFiles2 = touchedFiles) === null || _touchedFiles2 === void 0 ? void 0 : _touchedFiles2.created.find(function (touchedFile) {
                  return touchedFile.fileId === id;
                });
                var deferredUploadId;
                var isIdConflictError = caughtError instanceof RequestError && ((_caughtError$metadata = caughtError.metadata) === null || _caughtError$metadata === void 0 ? void 0 : _caughtError$metadata.statusCode) === 409;
                if (touchedFile) {
                  deferredUploadId = Promise.resolve(touchedFile.uploadId);
                } else if (isIdConflictError) {
                  // will occur when the backend receives a fileId that already exists in which case
                  // we will create a single upload session for that file and use that uploadId
                  deferredUploadId = mediaClient.mediaStore.createUpload(1, collection, traceContext).then(function (res) {
                    return res.data[0].id;
                  });
                } else {
                  // in the case of unexpected errors, we want to defer the throwing of the error
                  // until after the files-added has been emitted,
                  // allows editor to show a broken media card for unexpected errors
                  deferredUploadId = Promise.reject(caughtError);
                }
                var uploadableFile = {
                  collection: collection,
                  content: file,
                  name: file.name,
                  mimeType: file.type,
                  size: file.size
                };
                var uploadableUpfrontIds = {
                  id: id,
                  occurrenceKey: occurrenceKey,
                  deferredUploadId: deferredUploadId
                };
                var controller = _this3.createUploadController();
                var sourceFileObservable = mediaClient.file.upload(uploadableFile, controller, uploadableUpfrontIds, traceContext);
                var mediaFile = {
                  id: id,
                  name: file.name,
                  size: file.size,
                  creationDate: creationDate,
                  type: file.type,
                  occurrenceKey: occurrenceKey
                };
                var cancellableFileUpload = {
                  mediaFile: mediaFile,
                  file: file,
                  source: source,
                  cancel: function cancel() {
                    // we can't do "cancellableFileUpload.cancel = controller.abort" because will change the "this" mediaClient
                    controller.abort();
                  }
                };
                var _sourceFileObservable = sourceFileObservable.subscribe({
                    next: function next(state) {
                      if (state.status === 'processing' || state.status === 'processed' || state.status === 'failed-processing') {
                        unsubscribe();
                        if (shouldCopyFileToRecents) {
                          mediaClient.emit('file-added', state);
                          globalMediaEventEmitter.emit('file-added', state);
                        }
                        _this3.onFileSuccess(cancellableFileUpload, id, traceContext);
                      }
                      if (state.status === 'error') {
                        _this3.onFileError(mediaFile, 'upload_fail', state.message || 'no-message', traceContext);
                      }
                    },
                    error: function error(_error) {
                      _this3.onFileError(mediaFile, 'upload_fail', _error, traceContext);
                    }
                  }),
                  unsubscribe = _sourceFileObservable.unsubscribe;
                _this3.cancellableFilesUploads[id] = cancellableFileUpload;
                return cancellableFileUpload;
              });
              filteredCancellableFileUploads = cancellableFileUploads.filter(this.isCancellableFileUpload);
              mediaFiles = filteredCancellableFileUploads.map(function (cancellableFileUpload) {
                return cancellableFileUpload.mediaFile;
              });
              this.emit('files-added', {
                files: mediaFiles,
                traceContext: traceContext
              });
              this.emitPreviews(filteredCancellableFileUploads);
            case 25:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[11, 17]]);
      }));
      function addFilesAndUpload(_x5, _x6) {
        return _addFilesAndUpload.apply(this, arguments);
      }
      return addFilesAndUpload;
    }()
  }, {
    key: "emitPreviews",
    value: function emitPreviews(cancellableFileUploads) {
      var _this4 = this;
      cancellableFileUploads.forEach(function (cancellableFileUpload) {
        var file = cancellableFileUpload.file,
          mediaFile = cancellableFileUpload.mediaFile,
          source = cancellableFileUpload.source;
        var type = file.type;
        var mediaType = _this4.getMediaTypeFromFile(file);
        if (!isMimeTypeSupportedByBrowser(type)) {
          _this4.emit('file-preview-update', {
            file: mediaFile,
            preview: {}
          });
          return;
        }
        if (mediaType === 'image') {
          getPreviewFromImage(file, source === LocalFileSource.PastedScreenshot ? window.devicePixelRatio : undefined).then(function (preview) {
            _this4.emit('file-preview-update', {
              file: mediaFile,
              preview: preview
            });
          });
        } else {
          getPreviewFromBlob(mediaType, file).then(function (preview) {
            _this4.emit('file-preview-update', {
              file: mediaFile,
              preview: preview
            });
          }).catch(function () {
            return _this4.emit('file-preview-update', {
              file: mediaFile,
              preview: {}
            });
          });
        }
      });
    }
  }, {
    key: "getMediaTypeFromFile",
    value: function getMediaTypeFromFile(file) {
      var type = file.type;
      return getMediaTypeFromMimeType(type);
    }
  }, {
    key: "releaseCancellableFile",
    value: function releaseCancellableFile(mediaFile) {
      delete this.cancellableFilesUploads[mediaFile.id];
    }
  }, {
    key: "onFileEmpty",
    value: function onFileEmpty(handler) {
      this.fileEmptyHandler = handler;
    }
  }, {
    key: "onFileRejection",
    value: function onFileRejection(handler) {
      this.fileRejectionHandler = handler;
    }
  }]);
}();