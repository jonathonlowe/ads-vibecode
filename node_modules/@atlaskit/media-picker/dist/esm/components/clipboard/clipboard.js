import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _ClipboardImpl;
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React from 'react';
import { withAnalyticsEvents } from '@atlaskit/analytics-next';
import { ANALYTICS_MEDIA_CHANNEL, withMediaAnalyticsContext } from '@atlaskit/media-common';
import { LocalUploadComponentReact } from '../localUploadReact';
import { LocalFileSource } from '../../service/types';
import { getPackageAttributes } from '../../util/analytics';
import { appendTimestamp } from '../../util/appendTimestamp';
import ErrorFlagGroup from '../errorFlagGroup/ErrorFlagGroup';
export var getFilesFromClipboard = function getFilesFromClipboard(files) {
  return Array.from(files).map(function (file) {
    if (file.type.indexOf('image/') === 0) {
      var name = appendTimestamp(file.name, file.lastModified);
      return new File([file], name, {
        type: file.type
      });
    } else {
      return file;
    }
  });
};
var defaultConfig = {
  uploadParams: {}
};
var COMPONENT_NAME = 'clipboard';
var ClipboardImpl = /*#__PURE__*/function () {
  function ClipboardImpl(uploadService, container, onPaste, createAnalyticsEvent, featureFlags) {
    var _this = this;
    _classCallCheck(this, ClipboardImpl);
    _defineProperty(this, "handleEvent", function (event) {
      var _this$onPaste;
      var clipboardData = event.clipboardData;
      if ((_this$onPaste = _this.onPaste) !== null && _this$onPaste !== void 0 && _this$onPaste.call(_this, event)) {
        return;
      }

      // From https://product-fabric.atlassian.net/browse/MEX-1281 ,disable the handler if event target is input
      if (event.target instanceof HTMLInputElement) {
        return;
      }
      if (clipboardData && clipboardData.files) {
        var fileSource = clipboardData.types.length === 1 ? LocalFileSource.PastedScreenshot : LocalFileSource.PastedFile;
        var filesArray = getFilesFromClipboard(clipboardData.files).map(function (file) {
          return {
            file: file,
            source: fileSource
          };
        });
        if (filesArray.length > 0) {
          _this.onFilesPasted(filesArray);
        }
      }
    });
    this.uploadService = uploadService;
    this.container = container;
    this.onPaste = onPaste;
    this.createAnalyticsEvent = createAnalyticsEvent;
    this.featureFlags = featureFlags;
  }
  return _createClass(ClipboardImpl, [{
    key: "activate",
    value: function activate() {
      this.deactivate();
      if (!this.container) {
        document.addEventListener('paste', ClipboardImpl.legacyHandleEvent);
        ClipboardImpl.instances.push(this);
      } else {
        this.container.addEventListener('paste', this.handleEvent);
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (!this.container) {
        var index = ClipboardImpl.instances.indexOf(this);
        if (index > -1) {
          ClipboardImpl.instances.splice(index, 1);
        } else {
          /**
           * We want to remove the handleEvent only when there are no more instances.
           * Since handleEvent is static, if we remove it right away, and there is still an active instance,
           * we will loose the clipboard functionality.
           */
          document.removeEventListener('paste', ClipboardImpl.legacyHandleEvent);
        }
      } else {
        this.container.removeEventListener('paste', this.handleEvent);
      }
    }
  }, {
    key: "onFilesPasted",
    value: function onFilesPasted(files) {
      this.uploadService.addFilesWithSource(files);
      this.fireAnalyticsEvent(files);
    }
  }, {
    key: "fireAnalyticsEvent",
    value: function fireAnalyticsEvent(files) {
      if (this.createAnalyticsEvent) {
        var payload = {
          eventType: 'ui',
          action: 'pasted',
          actionSubject: 'clipboard',
          attributes: {
            fileCount: files.length,
            fileAttributes: files.map(function (_ref) {
              var _ref$file = _ref.file,
                type = _ref$file.type,
                size = _ref$file.size,
                source = _ref.source;
              return {
                fileSource: source,
                fileMimetype: type,
                fileSize: size
              };
            })
          }
        };
        var analyticsEvent = this.createAnalyticsEvent(payload);
        analyticsEvent.fire(ANALYTICS_MEDIA_CHANNEL);
      }
    }

    // The existing (semi)singleton (last in `instances`) event handler is proven to be problematic
    // Replaced with the new mechanism in https://product-fabric.atlassian.net/browse/MEX-2454
    // Remove after product adoption / rollout
  }], [{
    key: "latestInstance",
    get: function get() {
      return ClipboardImpl.instances[ClipboardImpl.instances.length - 1];
    }
  }]);
}();
_ClipboardImpl = ClipboardImpl;
_defineProperty(ClipboardImpl, "instances", []);
_defineProperty(ClipboardImpl, "legacyHandleEvent", function (event) {
  // From https://product-fabric.atlassian.net/browse/MEX-1281 ,disable the handler if event target is input
  if (event.target instanceof HTMLInputElement) {
    return;
  }

  // last in, first served to support multiple instances listening at once
  var instance = _ClipboardImpl.latestInstance;
  if (instance) {
    /*
         Browser behaviour for getting files from the clipboard is very inconsistent and buggy.
         @see https://hello.atlassian.net/wiki/spaces/FIL/pages/141485494/RFC+099+Clipboard+browser+inconsistency
          TODO https://product-fabric.atlassian.net/browse/BMPT-1285 Investigate implementation
       */
    var clipboardData = event.clipboardData;
    if (clipboardData && clipboardData.files) {
      var fileSource = clipboardData.types.length === 1 ? LocalFileSource.PastedScreenshot : LocalFileSource.PastedFile;
      var filesArray = getFilesFromClipboard(clipboardData.files).map(function (file) {
        return {
          file: file,
          source: fileSource
        };
      });
      // only the latest instance gets the event

      if (filesArray.length > 0) {
        instance.onFilesPasted.call(instance, filesArray);
      }
    }
  }
});
export var ClipboardBase = /*#__PURE__*/function (_LocalUploadComponent) {
  function ClipboardBase(props) {
    var _this2;
    _classCallCheck(this, ClipboardBase);
    _this2 = _callSuper(this, ClipboardBase, [props, COMPONENT_NAME]);
    _this2.clipboard = new ClipboardImpl(_this2.uploadService, _this2.props.config.container, _this2.props.config.onPaste, _this2.props.createAnalyticsEvent, props.featureFlags);
    return _this2;
  }
  _inherits(ClipboardBase, _LocalUploadComponent);
  return _createClass(ClipboardBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.clipboard.activate();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.featureFlags !== this.props.featureFlags) {
        this.clipboard.featureFlags = this.props.featureFlags;
      }
      // refreshes uploadParams as only set once in parent constructor
      if (prevProps.config.uploadParams !== this.props.config.uploadParams) {
        this.setUploadParams(this.props.config.uploadParams);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clipboard.deactivate();
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement(ErrorFlagGroup, {
        flagData: this.state.errorFlags,
        onFlagDismissed: this.dismissErrorFlag
      });
    }
  }]);
}(LocalUploadComponentReact);
_defineProperty(ClipboardBase, "defaultProps", {
  config: defaultConfig
});
export default ClipboardBase;
export var Clipboard = withMediaAnalyticsContext(getPackageAttributes(COMPONENT_NAME))(withAnalyticsEvents()(ClipboardBase));