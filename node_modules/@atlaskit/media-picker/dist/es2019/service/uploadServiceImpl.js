import _defineProperty from "@babel/runtime/helpers/defineProperty";
import uuidV4 from 'uuid/v4';
import { UploadController, globalMediaEventEmitter, RequestError } from '@atlaskit/media-client';
import { RECENTS_COLLECTION } from '@atlaskit/media-client/constants';
import { EventEmitter2 } from 'eventemitter2';
import { getPreviewFromImage } from '../util/getPreviewFromImage';
import { LocalFileSource } from '../service/types';
import { getPreviewFromBlob } from '../util/getPreviewFromBlob';
import { getRandomHex, isMimeTypeSupportedByBrowser, getMediaTypeFromMimeType } from '@atlaskit/media-common';
const generateTraceContext = () => ({
  traceId: getRandomHex(8)
});
export class UploadServiceImpl {
  constructor(tenantMediaClient, tenantUploadParams, shouldCopyFileToRecents, maxUploadBatchSize = 255 // Max supported batch is 255. We parametrise it for testing purposes
  ) {
    _defineProperty(this, "emit", (event, payload) => {
      this.emitter.emit(event, payload);
    });
    _defineProperty(this, "onFileSuccess", async (cancellableFileUpload, fileId, traceContext) => {
      const {
        mediaFile
      } = cancellableFileUpload;
      this.emit('file-converting', {
        file: mediaFile,
        traceContext
      });
      cancellableFileUpload.cancel = () => {
        this.releaseCancellableFile(mediaFile);
      };
    });
    _defineProperty(this, "onFileError", (mediaFile, name, error, traceContext) => {
      this.releaseCancellableFile(mediaFile);
      if (error === 'canceled') {
        // Specific error coming from chunkinator via rejected fileId promise.
        // We do not want to trigger error in this case.
        return;
      }
      const description = error instanceof Error ? error.message : error;
      const rawError = error instanceof Error ? error : undefined;
      this.emit('file-upload-error', {
        fileId: mediaFile.id,
        error: {
          fileId: mediaFile.id,
          name,
          description,
          rawError
        },
        traceContext
      });
    });
    this.tenantMediaClient = tenantMediaClient;
    this.tenantUploadParams = tenantUploadParams;
    this.shouldCopyFileToRecents = shouldCopyFileToRecents;
    this.maxUploadBatchSize = maxUploadBatchSize;
    this.emitter = new EventEmitter2();
    this.cancellableFilesUploads = {};
  }
  setUploadParams(uploadParams) {
    this.tenantUploadParams = uploadParams;
  }

  // Used for testing
  createUploadController() {
    return new UploadController();
  }
  addFiles(files) {
    this.addFilesWithSource(files.map(file => ({
      file,
      source: LocalFileSource.LocalUpload
    })));
  }
  addFile(file, replaceFileId) {
    this.addFilesWithSource([{
      file,
      source: LocalFileSource.LocalUpload,
      replaceFileId
    }]);
  }
  async addFilesWithSource(files, traceContext = generateTraceContext()) {
    const batches = [];
    for (let iterator = 0; iterator < files.length; iterator += this.maxUploadBatchSize) {
      batches.push(this.addFilesAndUpload(files.slice(iterator, iterator + this.maxUploadBatchSize), traceContext));
    }
    await Promise.all(batches);
  }
  isCancellableFileUpload(fileUpload) {
    return fileUpload !== null;
  }
  cancel(id) {
    if (id) {
      const cancellableFileUpload = this.cancellableFilesUploads[id];
      if (cancellableFileUpload && cancellableFileUpload.cancel) {
        cancellableFileUpload.cancel();
      }
    } else {
      Object.keys(this.cancellableFilesUploads).forEach(key => {
        const cancellableFileUpload = this.cancellableFilesUploads[key];
        if (cancellableFileUpload.cancel) {
          cancellableFileUpload.cancel();
        }
      });
    }
  }
  on(event, listener) {
    this.emitter.on(event, listener);
  }
  off(event, listener) {
    this.emitter.off(event, listener);
  }
  async addFilesAndUpload(files, traceContext) {
    if (files.length === 0) {
      return;
    }
    const creationDate = Date.now();
    const {
      userMediaClient,
      tenantMediaClient,
      shouldCopyFileToRecents
    } = this;
    const mediaClient = shouldCopyFileToRecents ? tenantMediaClient : userMediaClient;
    const {
      collection: collectionTentant,
      expireAfter
    } = this.tenantUploadParams;
    const collection = shouldCopyFileToRecents ? collectionTentant : RECENTS_COLLECTION;
    if (!mediaClient) {
      return;
    }
    const touchFileDescriptors = [];
    for (let i = 0; i < files.length; i++) {
      const {
        replaceFileId,
        file
      } = files[i];
      touchFileDescriptors.push({
        fileId: replaceFileId || uuidV4(),
        occurrenceKey: uuidV4(),
        collection,
        size: file.size,
        expireAfter
      });
    }
    let touchedFiles;
    let caughtError;
    try {
      touchedFiles = await mediaClient.file.touchFiles(touchFileDescriptors, collection, traceContext);
    } catch (error) {
      caughtError = error;
    }
    const cancellableFileUploads = files.map(({
      file,
      source
    }, i) => {
      var _touchedFiles, _touchedFiles$rejecte, _touchedFiles2, _caughtError$metadata;
      const {
        fileId: id,
        occurrenceKey
      } = touchFileDescriptors[i];

      // exclude rejected files from being uploaded
      const rejectedFile = (_touchedFiles = touchedFiles) === null || _touchedFiles === void 0 ? void 0 : (_touchedFiles$rejecte = _touchedFiles.rejected) === null || _touchedFiles$rejecte === void 0 ? void 0 : _touchedFiles$rejecte.find(({
        fileId: rejectedFileId
      }) => rejectedFileId === id);
      if (rejectedFile) {
        if (this.fileRejectionHandler) {
          this.fileRejectionHandler({
            reason: 'fileSizeLimitExceeded',
            fileName: file.name,
            limit: rejectedFile.error.limit
          });
        }
        return null;
      }

      // exclude empty files from being uploaded
      if (file.size === 0) {
        if (this.fileEmptyHandler) {
          this.fileEmptyHandler({
            reason: 'fileEmpty',
            fileName: file.name
          });
        }
        return null;
      }
      const touchedFile = (_touchedFiles2 = touchedFiles) === null || _touchedFiles2 === void 0 ? void 0 : _touchedFiles2.created.find(touchedFile => touchedFile.fileId === id);
      let deferredUploadId;
      const isIdConflictError = caughtError instanceof RequestError && ((_caughtError$metadata = caughtError.metadata) === null || _caughtError$metadata === void 0 ? void 0 : _caughtError$metadata.statusCode) === 409;
      if (touchedFile) {
        deferredUploadId = Promise.resolve(touchedFile.uploadId);
      } else if (isIdConflictError) {
        // will occur when the backend receives a fileId that already exists in which case
        // we will create a single upload session for that file and use that uploadId
        deferredUploadId = mediaClient.mediaStore.createUpload(1, collection, traceContext).then(res => {
          return res.data[0].id;
        });
      } else {
        // in the case of unexpected errors, we want to defer the throwing of the error
        // until after the files-added has been emitted,
        // allows editor to show a broken media card for unexpected errors
        deferredUploadId = Promise.reject(caughtError);
      }
      const uploadableFile = {
        collection,
        content: file,
        name: file.name,
        mimeType: file.type,
        size: file.size
      };
      const uploadableUpfrontIds = {
        id,
        occurrenceKey,
        deferredUploadId
      };
      const controller = this.createUploadController();
      const sourceFileObservable = mediaClient.file.upload(uploadableFile, controller, uploadableUpfrontIds, traceContext);
      const mediaFile = {
        id,
        name: file.name,
        size: file.size,
        creationDate,
        type: file.type,
        occurrenceKey
      };
      const cancellableFileUpload = {
        mediaFile,
        file,
        source,
        cancel: () => {
          // we can't do "cancellableFileUpload.cancel = controller.abort" because will change the "this" mediaClient
          controller.abort();
        }
      };
      const {
        unsubscribe
      } = sourceFileObservable.subscribe({
        next: state => {
          if (state.status === 'processing' || state.status === 'processed' || state.status === 'failed-processing') {
            unsubscribe();
            if (shouldCopyFileToRecents) {
              mediaClient.emit('file-added', state);
              globalMediaEventEmitter.emit('file-added', state);
            }
            this.onFileSuccess(cancellableFileUpload, id, traceContext);
          }
          if (state.status === 'error') {
            this.onFileError(mediaFile, 'upload_fail', state.message || 'no-message', traceContext);
          }
        },
        error: error => {
          this.onFileError(mediaFile, 'upload_fail', error, traceContext);
        }
      });
      this.cancellableFilesUploads[id] = cancellableFileUpload;
      return cancellableFileUpload;
    });
    const filteredCancellableFileUploads = cancellableFileUploads.filter(this.isCancellableFileUpload);
    const mediaFiles = filteredCancellableFileUploads.map(cancellableFileUpload => cancellableFileUpload.mediaFile);
    this.emit('files-added', {
      files: mediaFiles,
      traceContext
    });
    this.emitPreviews(filteredCancellableFileUploads);
  }
  emitPreviews(cancellableFileUploads) {
    cancellableFileUploads.forEach(cancellableFileUpload => {
      const {
        file,
        mediaFile,
        source
      } = cancellableFileUpload;
      const {
        type
      } = file;
      const mediaType = this.getMediaTypeFromFile(file);
      if (!isMimeTypeSupportedByBrowser(type)) {
        this.emit('file-preview-update', {
          file: mediaFile,
          preview: {}
        });
        return;
      }
      if (mediaType === 'image') {
        getPreviewFromImage(file, source === LocalFileSource.PastedScreenshot ? window.devicePixelRatio : undefined).then(preview => {
          this.emit('file-preview-update', {
            file: mediaFile,
            preview
          });
        });
      } else {
        getPreviewFromBlob(mediaType, file).then(preview => {
          this.emit('file-preview-update', {
            file: mediaFile,
            preview
          });
        }).catch(() => this.emit('file-preview-update', {
          file: mediaFile,
          preview: {}
        }));
      }
    });
  }
  getMediaTypeFromFile(file) {
    const {
      type
    } = file;
    return getMediaTypeFromMimeType(type);
  }
  releaseCancellableFile(mediaFile) {
    delete this.cancellableFilesUploads[mediaFile.id];
  }
  onFileEmpty(handler) {
    this.fileEmptyHandler = handler;
  }
  onFileRejection(handler) {
    this.fileRejectionHandler = handler;
  }
}