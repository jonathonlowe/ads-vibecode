import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { withAnalyticsEvents } from '@atlaskit/analytics-next';
import { ANALYTICS_MEDIA_CHANNEL, withMediaAnalyticsContext } from '@atlaskit/media-common';
import { LocalUploadComponentReact } from '../localUploadReact';
import { getPackageAttributes } from '../../util/analytics';
import ErrorFlagGroup from '../errorFlagGroup/ErrorFlagGroup';
function dragContainsFiles(event) {
  if (!event.dataTransfer) {
    return false;
  }
  const {
    types
  } = event.dataTransfer;
  return Array.from(types).indexOf('Files') > -1;
}
const COMPONENT_NAME = 'dropzone';
export class DropzoneBase extends LocalUploadComponentReact {
  constructor(props) {
    super(props, COMPONENT_NAME);
    _defineProperty(this, "uiActive", false);
    _defineProperty(this, "addContainerListeners", container => {
      const target = container !== null && container !== void 0 ? container : this.getContainer();
      // TODO: migrate this file to Pragmatic drag and drop
      /* eslint-disable @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop */
      target.addEventListener('dragover', this.onDragOver, false);
      target.addEventListener('dragleave', this.onDragLeave, false);
      target.addEventListener('drop', this.onFileDropped);
      /* eslint-enable @atlaskit/design-system/no-direct-use-of-web-platform-drag-and-drop */
    });
    _defineProperty(this, "removeContainerListeners", container => {
      const target = container !== null && container !== void 0 ? container : this.getContainer();
      target.removeEventListener('dragover', this.onDragOver, false);
      target.removeEventListener('dragleave', this.onDragLeave, false);
      target.removeEventListener('drop', this.onFileDropped);
    });
    _defineProperty(this, "onDragOver", event => {
      event.preventDefault();
      if (event.dataTransfer && dragContainsFiles(event)) {
        const dataTransfer = event.dataTransfer;
        let allowed;
        try {
          allowed = dataTransfer.effectAllowed;
        } catch (e) {} // the error is expected in IE11

        dataTransfer.dropEffect = 'move' === allowed || 'linkMove' === allowed ? 'move' : 'copy';
        const length = this.getDraggedItemsLength(dataTransfer);
        // [EDM-1636]: needed in order to make multiple dropzones in the page to work
        event.stopPropagation();
        this.emitDragOver({
          length
        });
      }
    });
    _defineProperty(this, "onDragLeave", e => {
      if (e.dataTransfer) {
        e.preventDefault();
        let length = 0;
        if (dragContainsFiles(e)) {
          const dataTransfer = e.dataTransfer;
          length = this.getDraggedItemsLength(dataTransfer);
        }
        this.emitDragLeave({
          length
        });
      }
    });
    _defineProperty(this, "onFileDropped", async dragEvent => {
      if (!dragEvent.dataTransfer) {
        return;
      }
      dragEvent.preventDefault();
      dragEvent.stopPropagation();
      // refreshes uploadParams as only set once in parent constructor
      this.setUploadParams(this.props.config.uploadParams);
      this.onDrop(dragEvent);
      const files = Array.from(dragEvent.dataTransfer.files);
      this.uploadService.addFiles(files);
    });
    _defineProperty(this, "onDrop", e => {
      if (e.dataTransfer && dragContainsFiles(e)) {
        const dataTransfer = e.dataTransfer;
        const fileCount = this.getDraggedItemsLength(dataTransfer);
        this.sendAnalyticsAndEmitDragLeave(fileCount);
      }
    });
    _defineProperty(this, "sendAnalyticsAndEmitDragLeave", fileCount => {
      this.fireAnalyticsEvent('droppedInto', fileCount);
      if (this.props.onDrop) {
        this.props.onDrop();
      }
      this.emitDragLeave({
        length: fileCount
      });
    });
  }
  getContainer() {
    const {
      config: {
        container
      }
    } = this.props;
    return container || document.body;
  }
  componentDidMount() {
    const {
      onCancelFn
    } = this.props;
    this.addContainerListeners(this.getContainer());
    if (onCancelFn) {
      onCancelFn(this.cancel);
    }
  }
  componentWillUnmount() {
    this.removeContainerListeners(this.getContainer());
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    const {
      config: {
        container: newContainer
      }
    } = nextProps;
    const {
      config: {
        container: oldContainer
      }
    } = this.props;
    if (newContainer !== oldContainer) {
      this.removeContainerListeners(oldContainer);
      this.addContainerListeners(newContainer);
    }
  }
  // Cross-browser way of getting dragged items length, we prioritize "items" if present
  // https://www.w3.org/TR/html51/editing.html#the-datatransfer-interface
  // This method is used on 'dragover' and we have no way to retrieve FileSystemFileEntry,
  // which contains info about if the dropped item is a file or directory. That info is only
  // available on 'drop'
  getDraggedItemsLength(dataTransfer) {
    if (dataTransfer.items) {
      const items = Array.from(dataTransfer.items);
      return items.filter(i => i.kind === 'file').length;
    }
    // This is required for IE11
    return dataTransfer.files.length;
  }
  emitDragOver(payload) {
    if (!this.uiActive) {
      const {
        onDragEnter
      } = this.props;
      this.uiActive = true;
      this.fireAnalyticsEvent('draggedInto', payload.length);
      if (onDragEnter) {
        onDragEnter(payload);
      }
    }
  }
  emitDragLeave(payload) {
    if (this.uiActive) {
      this.uiActive = false;
      /*
          when drag over child elements, container will issue dragleave and then dragover immediately.
          The 50ms timeout will prevent from issuing that "false" dragleave event
          */
      window.setTimeout(() => {
        if (!this.uiActive) {
          const {
            onDragLeave
          } = this.props;
          this.fireAnalyticsEvent('draggedOut', payload.length);
          if (onDragLeave) {
            onDragLeave(payload);
          }
        }
      }, 50);
    }
  }
  fireAnalyticsEvent(action, fileCount) {
    const {
      createAnalyticsEvent
    } = this.props;
    if (createAnalyticsEvent) {
      const payload = {
        eventType: 'ui',
        actionSubject: 'dropzone',
        action,
        attributes: {
          fileCount
        }
      };
      const analyticsEvent = createAnalyticsEvent(payload);
      analyticsEvent.fire(ANALYTICS_MEDIA_CHANNEL);
    }
  }
  render() {
    return /*#__PURE__*/React.createElement(ErrorFlagGroup, {
      flagData: this.state.errorFlags,
      onFlagDismissed: this.dismissErrorFlag
    });
  }
}
export default DropzoneBase;
export const Dropzone = withMediaAnalyticsContext(getPackageAttributes(COMPONENT_NAME))(withAnalyticsEvents()(DropzoneBase));