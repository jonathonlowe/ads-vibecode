"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilesFromClipboard = exports.default = exports.ClipboardBase = exports.Clipboard = void 0;
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _analyticsNext = require("@atlaskit/analytics-next");
var _mediaCommon = require("@atlaskit/media-common");
var _localUploadReact = require("../localUploadReact");
var _types = require("../../service/types");
var _analytics = require("../../util/analytics");
var _appendTimestamp = require("../../util/appendTimestamp");
var _ErrorFlagGroup = _interopRequireDefault(require("../errorFlagGroup/ErrorFlagGroup"));
var _ClipboardImpl;
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var getFilesFromClipboard = exports.getFilesFromClipboard = function getFilesFromClipboard(files) {
  return Array.from(files).map(function (file) {
    if (file.type.indexOf('image/') === 0) {
      var name = (0, _appendTimestamp.appendTimestamp)(file.name, file.lastModified);
      return new File([file], name, {
        type: file.type
      });
    } else {
      return file;
    }
  });
};
var defaultConfig = {
  uploadParams: {}
};
var COMPONENT_NAME = 'clipboard';
var ClipboardImpl = /*#__PURE__*/function () {
  function ClipboardImpl(uploadService, container, onPaste, createAnalyticsEvent, featureFlags) {
    var _this = this;
    (0, _classCallCheck2.default)(this, ClipboardImpl);
    (0, _defineProperty2.default)(this, "handleEvent", function (event) {
      var _this$onPaste;
      var clipboardData = event.clipboardData;
      if ((_this$onPaste = _this.onPaste) !== null && _this$onPaste !== void 0 && _this$onPaste.call(_this, event)) {
        return;
      }

      // From https://product-fabric.atlassian.net/browse/MEX-1281 ,disable the handler if event target is input
      if (event.target instanceof HTMLInputElement) {
        return;
      }
      if (clipboardData && clipboardData.files) {
        var fileSource = clipboardData.types.length === 1 ? _types.LocalFileSource.PastedScreenshot : _types.LocalFileSource.PastedFile;
        var filesArray = getFilesFromClipboard(clipboardData.files).map(function (file) {
          return {
            file: file,
            source: fileSource
          };
        });
        if (filesArray.length > 0) {
          _this.onFilesPasted(filesArray);
        }
      }
    });
    this.uploadService = uploadService;
    this.container = container;
    this.onPaste = onPaste;
    this.createAnalyticsEvent = createAnalyticsEvent;
    this.featureFlags = featureFlags;
  }
  return (0, _createClass2.default)(ClipboardImpl, [{
    key: "activate",
    value: function activate() {
      this.deactivate();
      if (!this.container) {
        document.addEventListener('paste', ClipboardImpl.legacyHandleEvent);
        ClipboardImpl.instances.push(this);
      } else {
        this.container.addEventListener('paste', this.handleEvent);
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (!this.container) {
        var index = ClipboardImpl.instances.indexOf(this);
        if (index > -1) {
          ClipboardImpl.instances.splice(index, 1);
        } else {
          /**
           * We want to remove the handleEvent only when there are no more instances.
           * Since handleEvent is static, if we remove it right away, and there is still an active instance,
           * we will loose the clipboard functionality.
           */
          document.removeEventListener('paste', ClipboardImpl.legacyHandleEvent);
        }
      } else {
        this.container.removeEventListener('paste', this.handleEvent);
      }
    }
  }, {
    key: "onFilesPasted",
    value: function onFilesPasted(files) {
      this.uploadService.addFilesWithSource(files);
      this.fireAnalyticsEvent(files);
    }
  }, {
    key: "fireAnalyticsEvent",
    value: function fireAnalyticsEvent(files) {
      if (this.createAnalyticsEvent) {
        var payload = {
          eventType: 'ui',
          action: 'pasted',
          actionSubject: 'clipboard',
          attributes: {
            fileCount: files.length,
            fileAttributes: files.map(function (_ref) {
              var _ref$file = _ref.file,
                type = _ref$file.type,
                size = _ref$file.size,
                source = _ref.source;
              return {
                fileSource: source,
                fileMimetype: type,
                fileSize: size
              };
            })
          }
        };
        var analyticsEvent = this.createAnalyticsEvent(payload);
        analyticsEvent.fire(_mediaCommon.ANALYTICS_MEDIA_CHANNEL);
      }
    }

    // The existing (semi)singleton (last in `instances`) event handler is proven to be problematic
    // Replaced with the new mechanism in https://product-fabric.atlassian.net/browse/MEX-2454
    // Remove after product adoption / rollout
  }], [{
    key: "latestInstance",
    get: function get() {
      return ClipboardImpl.instances[ClipboardImpl.instances.length - 1];
    }
  }]);
}();
_ClipboardImpl = ClipboardImpl;
(0, _defineProperty2.default)(ClipboardImpl, "instances", []);
(0, _defineProperty2.default)(ClipboardImpl, "legacyHandleEvent", function (event) {
  // From https://product-fabric.atlassian.net/browse/MEX-1281 ,disable the handler if event target is input
  if (event.target instanceof HTMLInputElement) {
    return;
  }

  // last in, first served to support multiple instances listening at once
  var instance = _ClipboardImpl.latestInstance;
  if (instance) {
    /*
         Browser behaviour for getting files from the clipboard is very inconsistent and buggy.
         @see https://hello.atlassian.net/wiki/spaces/FIL/pages/141485494/RFC+099+Clipboard+browser+inconsistency
          TODO https://product-fabric.atlassian.net/browse/BMPT-1285 Investigate implementation
       */
    var clipboardData = event.clipboardData;
    if (clipboardData && clipboardData.files) {
      var fileSource = clipboardData.types.length === 1 ? _types.LocalFileSource.PastedScreenshot : _types.LocalFileSource.PastedFile;
      var filesArray = getFilesFromClipboard(clipboardData.files).map(function (file) {
        return {
          file: file,
          source: fileSource
        };
      });
      // only the latest instance gets the event

      if (filesArray.length > 0) {
        instance.onFilesPasted.call(instance, filesArray);
      }
    }
  }
});
var ClipboardBase = exports.ClipboardBase = /*#__PURE__*/function (_LocalUploadComponent) {
  function ClipboardBase(props) {
    var _this2;
    (0, _classCallCheck2.default)(this, ClipboardBase);
    _this2 = _callSuper(this, ClipboardBase, [props, COMPONENT_NAME]);
    _this2.clipboard = new ClipboardImpl(_this2.uploadService, _this2.props.config.container, _this2.props.config.onPaste, _this2.props.createAnalyticsEvent, props.featureFlags);
    return _this2;
  }
  (0, _inherits2.default)(ClipboardBase, _LocalUploadComponent);
  return (0, _createClass2.default)(ClipboardBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.clipboard.activate();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.featureFlags !== this.props.featureFlags) {
        this.clipboard.featureFlags = this.props.featureFlags;
      }
      // refreshes uploadParams as only set once in parent constructor
      if (prevProps.config.uploadParams !== this.props.config.uploadParams) {
        this.setUploadParams(this.props.config.uploadParams);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clipboard.deactivate();
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react.default.createElement(_ErrorFlagGroup.default, {
        flagData: this.state.errorFlags,
        onFlagDismissed: this.dismissErrorFlag
      });
    }
  }]);
}(_localUploadReact.LocalUploadComponentReact);
(0, _defineProperty2.default)(ClipboardBase, "defaultProps", {
  config: defaultConfig
});
var _default = exports.default = ClipboardBase;
var Clipboard = exports.Clipboard = (0, _mediaCommon.withMediaAnalyticsContext)((0, _analytics.getPackageAttributes)(COMPONENT_NAME))((0, _analyticsNext.withAnalyticsEvents)()(ClipboardBase));