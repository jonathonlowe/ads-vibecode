"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findInsertedLocation = findInsertedLocation;
exports.getSelectionType = getSelectionType;
exports.getStateContext = getStateContext;
var _analytics = require("@atlaskit/editor-common/analytics");
var _analytics2 = require("@atlaskit/editor-common/utils/analytics");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _cellSelection = require("@atlaskit/editor-tables/cell-selection");
function getSelectionType(selection) {
  var _selection$constructo;
  var type;
  var position;
  if ((selection === null || selection === void 0 || (_selection$constructo = selection.constructor) === null || _selection$constructo === void 0 ? void 0 : _selection$constructo.name) === 'GapCursorSelection') {
    type = _analytics.SELECTION_TYPE.GAP_CURSOR;
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    position = selection.side;
  } else if (selection instanceof _cellSelection.CellSelection) {
    type = _analytics.SELECTION_TYPE.CELL;
  } else if (selection instanceof _state.NodeSelection) {
    type = _analytics.SELECTION_TYPE.NODE;
  } else if (selection.from !== selection.to) {
    type = _analytics.SELECTION_TYPE.RANGED;
  } else {
    type = _analytics.SELECTION_TYPE.CURSOR;
    var from = selection.from,
      $from = selection.$from;
    if (from === $from.start()) {
      position = _analytics.SELECTION_POSITION.START;
    } else if (from === $from.end()) {
      position = _analytics.SELECTION_POSITION.END;
    } else {
      position = _analytics.SELECTION_POSITION.MIDDLE;
    }
  }
  return {
    type: type,
    position: position
  };
}
function findInsertedLocation(oldSelection, newSelection) {
  var schema = newSelection.$from.doc.type.schema;
  var _schema$nodes = schema.nodes,
    paragraph = _schema$nodes.paragraph,
    table = _schema$nodes.table;
  if (oldSelection instanceof _cellSelection.CellSelection) {
    return table.name;
  }
  var insertLocationInfo = (0, _utils.findParentNode)(function (node) {
    return node.type !== paragraph;
  })(oldSelection);
  var parentNodePos = newSelection.$from.doc.resolve((insertLocationInfo === null || insertLocationInfo === void 0 ? void 0 : insertLocationInfo.start) || 0);

  // Keep going one level above the attempted insert position till we find a node that contains the current cursor position in it's range
  while (parentNodePos.end() < newSelection.$from.pos) {
    parentNodePos = newSelection.$from.doc.resolve(parentNodePos.start(Math.max(parentNodePos.depth - 1, 0)));
  }
  return parentNodePos.node().type.name;
}
function getStateContext(selection, payload, tr) {
  if (!payload.attributes) {
    return payload;
  }
  var _getSelectionType = getSelectionType(selection),
    type = _getSelectionType.type,
    position = _getSelectionType.position;
  payload.attributes.selectionType = type;
  if (position) {
    payload.attributes.selectionPosition = position;
  }
  var insertLocation = (0, _analytics2.findInsertLocation)(selection);
  if (payload.action === _analytics.ACTION.INSERTED && payload.actionSubject !== _analytics.ACTION_SUBJECT.ANNOTATION && payload.actionSubject !== _analytics.ACTION_SUBJECT.EDITOR_PLUGIN_AI) {
    payload.attributes.insertedLocation = findInsertedLocation(selection, tr.selection);
  }
  if (payload.action === _analytics.ACTION.INSERTED && payload.actionSubject === _analytics.ACTION_SUBJECT.DOCUMENT && payload.attributes) {
    payload.attributes.insertLocation = insertLocation;
  } else {
    payload.attributes.nodeLocation = insertLocation;
  }
  return payload;
}