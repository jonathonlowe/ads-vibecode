"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskItemNodeView = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bindEventListener = require("bind-event-listener");
var _steps = require("@atlaskit/adf-schema/steps");
var _messages = require("@atlaskit/editor-common/messages");
var _monitoring = require("@atlaskit/editor-common/monitoring");
var _model = require("@atlaskit/editor-prosemirror/model");
var _helpers = require("../pm-plugins/helpers");
var _taskItemNodeSpec = require("./taskItemNodeSpec");
var TaskItemNodeView = exports.TaskItemNodeView = /*#__PURE__*/function () {
  function TaskItemNodeView(node, view, getPos, _ref) {
    var _this = this;
    var api = _ref.api,
      placeholder = _ref.placeholder,
      intl = _ref.intl;
    (0, _classCallCheck2.default)(this, TaskItemNodeView);
    (0, _defineProperty2.default)(this, "dom", document.createElement('span'));
    (0, _defineProperty2.default)(this, "handleOnClick", function (event) {
      var _this$api;
      if (!((_this$api = _this.api) !== null && _this$api !== void 0 && (_this$api = _this$api.taskDecision) !== null && _this$api !== void 0 && (_this$api = _this$api.sharedState.currentState()) !== null && _this$api !== void 0 && _this$api.hasEditPermission)) {
        event.stopImmediatePropagation();
        event.preventDefault();
        var pos = _this.getPos();
        if (typeof pos === 'number') {
          (0, _helpers.openRequestEditPopupAt)(_this.view, pos);
        }
        return;
      }
    });
    (0, _defineProperty2.default)(this, "handleOnChange", function () {
      var _this$api2;
      var tr = _this.view.state.tr;
      var nodePos = _this.getPos();
      if (typeof nodePos !== 'number') {
        return;
      }
      var _this$node$attrs = _this.node.attrs,
        localId = _this$node$attrs.localId,
        state = _this$node$attrs.state;
      var isDone = state === 'DONE';
      var nextState = isDone ? 'TODO' : 'DONE';
      var currentTaskDecisionState = (_this$api2 = _this.api) === null || _this$api2 === void 0 ? void 0 : _this$api2.taskDecision.sharedState.currentState();

      // logic is inspired from packages/elements/task-decision/src/components/ResourcedTaskItem.tsx
      if (currentTaskDecisionState !== null && currentTaskDecisionState !== void 0 && currentTaskDecisionState.taskDecisionProvider && _this.objectId) {
        currentTaskDecisionState === null || currentTaskDecisionState === void 0 || currentTaskDecisionState.taskDecisionProvider.toggleTask({
          localId: localId,
          objectAri: _this.objectId
        }, isDone ? 'DONE' : 'TODO');
      }

      // SetAttrsStep should be used to prevent task updates from being dropped when mapping task ticks
      // from a previous version of the document, such as a published page.
      tr.step(new _steps.SetAttrsStep(nodePos, {
        state: nextState,
        localId: localId
      }));
      tr.setMeta('scrollIntoView', false);
      _this.view.dispatch(tr);
    });
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.intl = intl;
    this.api = api;
    this.view = view;
    try {
      var domPlaceholder = placeholder !== null && placeholder !== void 0 ? placeholder : this.intl.formatMessage(_messages.tasksAndDecisionsMessages.taskPlaceholder);
      var _DOMSerializer$render = _model.DOMSerializer.renderSpec(document, (0, _taskItemNodeSpec.taskItemToDom)(node, domPlaceholder)),
        dom = _DOMSerializer$render.dom,
        contentDOM = _DOMSerializer$render.contentDOM;
      if (!(dom instanceof HTMLElement)) {
        // It's safe to throw error here because, the code is wrapped in try-catch.
        // However, it should never happen because `DOMSerializer.renderSpec()` should always return HTMLElement.
        throw new Error('DOMSerializer.renderSpec() did not return HTMLElement');
      }
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.input = this.dom.querySelector('input[type="checkbox"]');
      this.unbindInputDom = (0, _bindEventListener.bindAll)(this.input, [{
        type: 'click',
        listener: this.handleOnClick
      }, {
        type: 'change',
        listener: this.handleOnChange
      }]);
      this.objectId = this.getObjectAri();
      this.updatePlaceholder(node);
    } catch (error) {
      TaskItemNodeView.logError(error instanceof Error ? error : new Error('Unknown error on TaskItemNodeView constructor'));
      this.renderFallback();
    }
  }
  return (0, _createClass2.default)(TaskItemNodeView, [{
    key: "getContextIdentifierProvider",
    value: function getContextIdentifierProvider() {
      var _this$api3;
      return (_this$api3 = this.api) === null || _this$api3 === void 0 || (_this$api3 = _this$api3.contextIdentifier) === null || _this$api3 === void 0 || (_this$api3 = _this$api3.sharedState.currentState()) === null || _this$api3 === void 0 ? void 0 : _this$api3.contextIdentifierProvider;
    }
  }, {
    key: "getObjectAri",
    value: function getObjectAri() {
      var provider = this.getContextIdentifierProvider();
      if (provider) {
        return provider.objectId;
      }
      return undefined;
    }
  }, {
    key: "isContentEmpty",
    value: function isContentEmpty(node) {
      return node.content.childCount === 0;
    }
  }, {
    key: "renderFallback",
    value: function renderFallback() {
      var _this$node$firstChild;
      var fallbackElementInput = document.createElement('input');
      fallbackElementInput.setAttribute('type', 'checkbox');
      var fallbackElementText = document.createElement('span');
      fallbackElementText.innerText = ((_this$node$firstChild = this.node.firstChild) === null || _this$node$firstChild === void 0 ? void 0 : _this$node$firstChild.text) || '';
      this.dom.appendChild(fallbackElementInput);
      this.dom.appendChild(fallbackElementText);
    }

    // Update the placeholder visibility based on content
  }, {
    key: "updatePlaceholder",
    value: function updatePlaceholder(node) {
      var currentIsContentEmpty = this.isContentEmpty(node);
      if (currentIsContentEmpty !== this.emptyContent) {
        var _this$contentDOM;
        this.emptyContent = currentIsContentEmpty;
        (_this$contentDOM = this.contentDOM) === null || _this$contentDOM === void 0 || _this$contentDOM.toggleAttribute('data-empty', currentIsContentEmpty);
      }
    }
  }, {
    key: "update",
    value: function update(node) {
      if (node.type !== this.node.type) {
        return false;
      }
      this.updatePlaceholder(node);
      if (!node.sameMarkup(this.node)) {
        if (node.attrs.state !== this.node.attrs.state) {
          this.dom.setAttribute('data-task-state', node.attrs.state);
          this.dom.setAttribute('state', node.attrs.state);
        }
        this.node = node;
      }
      return true;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      if (!this.contentDOM) {
        return true;
      }
      return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.unbindInputDom) {
        this.unbindInputDom();
      }
      this.contentDOM = undefined;
      this.input = undefined;
      this.objectId = undefined;
      this.emptyContent = undefined;
      this.api = undefined;
    }
  }], [{
    key: "logError",
    value: function logError(error) {
      void (0, _monitoring.logException)(error, {
        location: 'editor-plugin-date/DateNodeView'
      });
    }
  }]);
}();