import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { createRule } from '@atlaskit/editor-common/utils';
import { NodeSelection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { canInsert } from '@atlaskit/editor-prosemirror/utils';
import { createPlugin, leafNodeReplacementCharacter } from '@atlaskit/prosemirror-input-rules';
import { changeInDepth, getListTypes, insertTaskDecisionAction } from './insert-commands';
var createListRule = function createListRule(editorAnalyticsAPI, getContextIdentifierProvider) {
  return function (regex, listType, itemAttrs) {
    return createRule(regex, function (state, _match, start, end) {
      var paragraph = state.schema.nodes.paragraph;
      var _getListTypes = getListTypes(listType, state.schema),
        list = _getListTypes.list;
      var $end = state.doc.resolve(end);
      var $endOfParent = state.doc.resolve($end.after());
      // Only allow creating list in nodes that support them.
      // Parent must be a paragraph as we don't want this applying to headings
      if ($end.parent.type !== paragraph || !canInsert($endOfParent, list.createAndFill())) {
        return null;
      }
      var insertTr = insertTaskDecisionAction(editorAnalyticsAPI, getContextIdentifierProvider)(state, listType, INPUT_METHOD.FORMATTING, addItem(start, end), undefined, undefined, itemAttrs);
      return insertTr;
    });
  };
};
var isCursorInsideList = function isCursorInsideList($pos) {
  var _$pos$node;
  return ((_$pos$node = $pos.node($pos.depth - 1)) === null || _$pos$node === void 0 ? void 0 : _$pos$node.type.name) === 'listItem';
};
var processShortcutForNestedTask = function processShortcutForNestedTask(content, $from, tr, list, item, listLocalId, itemLocalId, itemAttrs) {
  //Extracting the content into the 'contentWithoutShortcut' from 'content' after removing the keyboard shortcut text, i.e., '[] '.
  var contentWithoutShortcut = content.cut($from.pos - $from.start(), content.size);
  tr.insert($from.after(), list.create({
    localId: listLocalId
  }, [item.create(_objectSpread({
    localId: itemLocalId
  }, itemAttrs), contentWithoutShortcut)])).setSelection(new TextSelection(tr.doc.resolve($from.after()))).delete($from.start(), $from.end());
};
var addItem = function addItem(start, end) {
  return function (_ref) {
    var tr = _ref.tr,
      state = _ref.state,
      list = _ref.list,
      item = _ref.item,
      listLocalId = _ref.listLocalId,
      itemLocalId = _ref.itemLocalId,
      itemAttrs = _ref.itemAttrs;
    var $from = state.selection.$from,
      schema = state.schema;
    var hardBreak = schema.nodes.hardBreak;
    var content = $from.node($from.depth).content;
    var shouldBreakNode = false;
    content.forEach(function (node, offset) {
      if (node.type === hardBreak && offset < start) {
        shouldBreakNode = true;
      }
    });
    if (!shouldBreakNode) {
      if (isCursorInsideList($from)) {
        processShortcutForNestedTask(content, $from, tr, list, item, listLocalId, itemLocalId, itemAttrs);
        return tr;
      }
      tr.replaceRangeWith($from.before(), $from.after(), list.create({
        localId: listLocalId
      }, [item.create(_objectSpread({
        localId: itemLocalId
      }, itemAttrs), content)])).delete(start + 1, end + 1).setSelection(new TextSelection(tr.doc.resolve(start + 1)));
      return tr;
    }
    var depthAdjustment = changeInDepth($from, tr.selection.$from);
    tr.split($from.pos).setSelection(new NodeSelection(tr.doc.resolve($from.pos + 1))).replaceSelectionWith(list.create({
      localId: listLocalId
    }, [item.create(_objectSpread({
      localId: itemLocalId
    }, itemAttrs), tr.doc.nodeAt($from.pos + 1).content)])).setSelection(new TextSelection(tr.doc.resolve($from.pos + depthAdjustment))).delete(start, end + 1);
    return tr;
  };
};
export var inputRulePlugin = function inputRulePlugin(editorAnalyticsAPI, getContextIdentifierProvider) {
  return function (schema, featureFlags) {
    var rules = [];
    var _schema$nodes = schema.nodes,
      decisionList = _schema$nodes.decisionList,
      decisionItem = _schema$nodes.decisionItem,
      taskList = _schema$nodes.taskList,
      taskItem = _schema$nodes.taskItem;
    if (decisionList && decisionItem) {
      rules.push(createListRule(editorAnalyticsAPI, getContextIdentifierProvider)(
      // Ignored via go/ees005
      // eslint-disable-next-line require-unicode-regexp
      new RegExp("(^|".concat(leafNodeReplacementCharacter, ")\\<\\>\\s$")), 'decisionList'));
    }
    if (taskList && taskItem) {
      rules.push(createListRule(editorAnalyticsAPI, getContextIdentifierProvider)(
      // Ignored via go/ees005
      // eslint-disable-next-line require-unicode-regexp
      new RegExp("(^|".concat(leafNodeReplacementCharacter, ")\\[\\]\\s$")), 'taskList'));
      rules.push(createListRule(editorAnalyticsAPI, getContextIdentifierProvider)(
      // Ignored via go/ees005
      // eslint-disable-next-line require-unicode-regexp
      new RegExp("(^|".concat(leafNodeReplacementCharacter, ")\\[x\\]\\s$")), 'taskList', {
        state: 'DONE'
      }));
    }
    return new SafePlugin(createPlugin('tasks-and-decisions', rules, {
      isBlockNodeRule: true
    }));
  };
};
export default inputRulePlugin;