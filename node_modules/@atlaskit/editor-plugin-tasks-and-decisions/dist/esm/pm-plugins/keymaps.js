import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { uuid } from '@atlaskit/adf-schema';
import { SetAttrsStep } from '@atlaskit/adf-schema/steps';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INDENT_DIRECTION, INDENT_TYPE, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { toggleTaskItemCheckbox } from '@atlaskit/editor-common/keymaps';
import { deleteEmptyParagraphAndMoveBlockUp, filterCommand as filter, isEmptySelectionAtEnd, isEmptySelectionAtStart } from '@atlaskit/editor-common/utils';
import { autoJoin, chainCommands } from '@atlaskit/editor-prosemirror/commands';
import { keymap } from '@atlaskit/editor-prosemirror/keymap';
import { Fragment, Slice } from '@atlaskit/editor-prosemirror/model';
import { TextSelection } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeOfType, findParentNodeOfTypeClosestToPos, hasParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { joinAtCut, liftSelection, wrapSelectionInTaskList } from './commands';
import { findFirstParentListNode, getBlockRange, getCurrentIndentLevel, getTaskItemIndex, isActionOrDecisionItem, isActionOrDecisionList, isEmptyTaskDecision, isInsideDecision, isInsideTask, isInsideTaskOrDecisionItem, isTable, liftBlock, walkOut } from './helpers';
import { insertTaskDecisionWithAnalytics } from './insert-commands';
import { normalizeTaskItemsSelection } from './utils';
var indentationAnalytics = function indentationAnalytics(curIndentLevel, direction, inputMethod) {
  return {
    action: ACTION.FORMATTED,
    actionSubject: ACTION_SUBJECT.TEXT,
    actionSubjectId: ACTION_SUBJECT_ID.FORMAT_INDENT,
    eventType: EVENT_TYPE.TRACK,
    attributes: {
      inputMethod: inputMethod,
      previousIndentationLevel: curIndentLevel,
      newIndentLevel: direction === INDENT_DIRECTION.OUTDENT ? curIndentLevel - 1 : curIndentLevel + 1,
      direction: direction,
      indentType: INDENT_TYPE.TASK_LIST
    }
  };
};
var nodeAfter = function nodeAfter($pos) {
  return $pos.doc.resolve($pos.end()).nodeAfter;
};
var actionDecisionFollowsOrNothing = function actionDecisionFollowsOrNothing($pos) {
  var after = nodeAfter($pos);
  return !after || isActionOrDecisionItem(after);
};
var joinTaskDecisionFollowing = function joinTaskDecisionFollowing(state, dispatch) {
  // only run if selection is at end of text, and inside a task or decision item
  if (!isEmptySelectionAtEnd(state) || !isInsideTaskOrDecisionItem(state) || !dispatch) {
    return false;
  }
  // look for the node after this current one
  var $next = walkOut(state.selection.$from);

  // if there's no taskItem or taskList following, then
  // we just do the normal behaviour
  var _state$schema$nodes = state.schema.nodes,
    taskList = _state$schema$nodes.taskList,
    taskItem = _state$schema$nodes.taskItem,
    decisionList = _state$schema$nodes.decisionList,
    decisionItem = _state$schema$nodes.decisionItem,
    paragraph = _state$schema$nodes.paragraph,
    bulletList = _state$schema$nodes.bulletList,
    orderedList = _state$schema$nodes.orderedList,
    listItem = _state$schema$nodes.listItem;
  var parentList = findParentNodeOfTypeClosestToPos($next, [taskList, taskItem, decisionList, decisionItem]);
  if (!parentList) {
    if ($next.parent.type === paragraph) {
      // try to join paragraph and taskList when backspacing
      return joinAtCut($next.doc.resolve($next.pos))(state, dispatch);
    }
    // If the item we are joining is a list
    if ($next.parent.type === bulletList || $next.parent.type === orderedList) {
      // If the list has an item
      if ($next.parent.firstChild && $next.parent.firstChild.type === listItem) {
        // Place the cursor at the first listItem
        var resolvedStartPos = state.doc.resolve($next.pos + 1);
        // Unindent the first listItem.
        // As if placing your cursor just after the first dot of the list (before the text)
        // and pressing Shift-Tab.
        var tr = liftBlock(state.tr, resolvedStartPos, resolvedStartPos);

        // If autoJoin not used, two ul/ol elements appear rather than one with multiple li elements
        return autoJoin(function (state, dispatch) {
          if (tr) {
            if (dispatch) {
              dispatch(tr);
            }
            return true;
          }
          return false;
        }, ['bulletList', 'orderedList'])(state, dispatch);
      }
    }
  }
  return false;
};
export var getUnindentCommand = function getUnindentCommand(editorAnalyticsAPI) {
  return function () {
    var inputMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INPUT_METHOD.KEYBOARD;
    return filter(isInsideTask, function (state, dispatch) {
      var normalizedSelection = normalizeTaskItemsSelection(state.selection);
      var curIndentLevel = getCurrentIndentLevel(normalizedSelection);
      if (!curIndentLevel || curIndentLevel === 1) {
        return false;
      }
      return withAnalytics(editorAnalyticsAPI, indentationAnalytics(curIndentLevel, INDENT_DIRECTION.OUTDENT, inputMethod))(autoJoin(liftSelection, ['taskList']))(state, dispatch);
    });
  };
};

// if selection is decision item or first action item in table cell
// then dont consume the Tab, as table-keymap should tab to the next cell
var shouldLetTabThroughInTable = function shouldLetTabThroughInTable(state) {
  var curIndentLevel = getCurrentIndentLevel(state.selection);
  var curIndex = getTaskItemIndex(state);
  var _state$schema$nodes2 = state.schema.nodes,
    tableCell = _state$schema$nodes2.tableCell,
    tableHeader = _state$schema$nodes2.tableHeader;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var cell = findParentNodeOfType([tableCell, tableHeader])(state.selection);
  if ((curIndentLevel === 1 && curIndex === 0 || isInsideDecision(state)) && cell) {
    return true;
  }
  return false;
};
export var getIndentCommand = function getIndentCommand(editorAnalyticsAPI) {
  return function () {
    var inputMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INPUT_METHOD.KEYBOARD;
    return filter(isInsideTask, function (state, dispatch) {
      var normalizedSelection = normalizeTaskItemsSelection(state.selection);
      var curIndentLevel = getCurrentIndentLevel(normalizedSelection);
      if (!curIndentLevel || curIndentLevel >= 6) {
        return true;
      }
      return withAnalytics(editorAnalyticsAPI, indentationAnalytics(curIndentLevel, INDENT_DIRECTION.INDENT, inputMethod))(autoJoin(wrapSelectionInTaskList, ['taskList']))(state, dispatch);
    });
  };
};
var backspaceFrom = function backspaceFrom(editorAnalyticsAPI) {
  return function ($from) {
    return function (state, dispatch) {
      // previous was empty, just delete backwards
      var taskBefore = $from.doc.resolve($from.before());
      if (taskBefore.nodeBefore && isActionOrDecisionItem(taskBefore.nodeBefore) && taskBefore.nodeBefore.nodeSize === 2) {
        return false;
      }

      // if nested, just unindent
      var _state$schema$nodes3 = state.schema.nodes,
        taskList = _state$schema$nodes3.taskList,
        paragraph = _state$schema$nodes3.paragraph;
      if ($from.node($from.depth - 2).type === taskList) {
        return getUnindentCommand(editorAnalyticsAPI)()(state, dispatch);
      }

      // bottom level, should "unwrap" taskItem contents into paragraph
      // we achieve this by slicing the content out, and replacing
      if (actionDecisionFollowsOrNothing($from)) {
        if (dispatch) {
          var taskContent = state.doc.slice($from.start(), $from.end()).content;

          // might be end of document after
          var slice = taskContent.size ? paragraph.createChecked(undefined, taskContent) : paragraph.createChecked();
          dispatch(splitListItemWith(state.tr, slice, $from, true));
        }
        return true;
      }
      return false;
    };
  };
};
var backspace = function backspace(editorAnalyticsAPI) {
  return filter(isEmptySelectionAtStart, autoJoin(chainCommands(function (state, dispatch) {
    return joinAtCut(state.selection.$from)(state, dispatch);
  }, filter(isInsideTaskOrDecisionItem, function (state, dispatch) {
    return backspaceFrom(editorAnalyticsAPI)(state.selection.$from)(state, dispatch);
  })), ['taskList', 'decisionList']));
};
var unindentTaskOrUnwrapTaskDecisionFollowing = function unindentTaskOrUnwrapTaskDecisionFollowing(state, dispatch) {
  var $from = state.selection.$from,
    _state$schema$nodes4 = state.schema.nodes,
    taskList = _state$schema$nodes4.taskList,
    doc = _state$schema$nodes4.doc,
    paragraph = _state$schema$nodes4.paragraph,
    tr = state.tr;

  // only run if cursor is at the end of the node
  if (!isEmptySelectionAtEnd(state) || !dispatch) {
    return false;
  }

  // look for the node after this current one
  var $next = walkOut($from);

  // this is a top-level node it wont have $next.before()
  if (!$next.parent || $next.parent.type === doc) {
    return false;
  }

  // if nested, just unindent
  if ($next.node($next.depth - 2).type === taskList ||
  // this is for the case when we are on a non-nested item and next one is nested
  $next.node($next.depth - 1).type === taskList && $next.parent.type === taskList) {
    liftBlock(tr, $next, $next);
    dispatch(tr);
    return true;
  }

  // if next node is of same type, remove the node wrapping and create paragraph
  if (!isTable($next.nodeAfter) && isActionOrDecisionItem($from.parent) && actionDecisionFollowsOrNothing($from) &&
  // only forward delete if the node is same type
  $next.node().type.name === $from.node().type.name) {
    var taskContent = state.doc.slice($next.start(), $next.end()).content;

    // might be end of document after
    var slice = taskContent.size ? paragraph.createChecked(undefined, taskContent) : [];
    dispatch(splitListItemWith(tr, slice, $next, false));
    return true;
  }
  return false;
};
var deleteForwards = autoJoin(chainCommands(deleteEmptyParagraphAndMoveBlockUp(isActionOrDecisionList), joinTaskDecisionFollowing, unindentTaskOrUnwrapTaskDecisionFollowing), ['taskList', 'decisionList']);
var deleteExtraListItem = function deleteExtraListItem(tr, $from) {
  /*
     After we replace actionItem with empty list item if there's the anomaly of extra empty list item
     the cursor moves inside the first taskItem of splitted taskList
     so the extra list item present above the list item containing taskList & cursor
   */

  var $currentFrom = tr.selection.$from;
  var listItemContainingActionList = tr.doc.resolve($currentFrom.start($currentFrom.depth - 2));
  var emptyListItem = tr.doc.resolve(listItemContainingActionList.before() - 1);
  tr.delete(emptyListItem.start(), listItemContainingActionList.pos);
};
var processNestedActionItem = function processNestedActionItem(tr, $from, previousListItemPos) {
  var parentListNode = findFirstParentListNode($from);
  var previousChildCountOfList = parentListNode === null || parentListNode === void 0 ? void 0 : parentListNode.node.childCount;
  var currentParentListNode = findFirstParentListNode(tr.doc.resolve(tr.mapping.map($from.pos)));
  var currentChildCountOfList = currentParentListNode === null || currentParentListNode === void 0 ? void 0 : currentParentListNode.node.childCount;

  /*
     While replacing range with empty list item an extra list item gets created in some of the scenarios
     After splitting only one extra listItem should be created else an extra listItem is created
   */
  if (previousChildCountOfList && currentChildCountOfList && previousChildCountOfList + 1 !== currentChildCountOfList) {
    deleteExtraListItem(tr, $from);
  }

  // Set custom selection for nested action inside lists using previosuly calculated previousListItem position
  var stableResolvedPos = tr.doc.resolve(previousListItemPos);
  tr.setSelection(TextSelection.create(tr.doc, stableResolvedPos.after() + 2));
};
var splitListItemWith = function splitListItemWith(tr, content, $from, setSelection) {
  var _frag$firstChild;
  var origDoc = tr.doc;

  // split just before the current item
  // we can only split if there was a list item before us
  var container = $from.node($from.depth - 2);
  var posInList = $from.index($from.depth - 1);
  var shouldSplit = !(!isActionOrDecisionList(container) && posInList === 0);
  var frag = Fragment.from(content);
  var isNestedActionInsideLists = frag.childCount === 1 && ((_frag$firstChild = frag.firstChild) === null || _frag$firstChild === void 0 ? void 0 : _frag$firstChild.type.name) === 'listItem';

  /* We don't split the list item if it's nested inside lists
     to have consistent behaviour and their resolution.
   */
  if (shouldSplit && !isNestedActionInsideLists) {
    // this only splits a node to delete it, so we probably don't need a random uuid
    // but generate one anyway for correctness
    tr = tr.split($from.pos, 1, [{
      type: $from.parent.type,
      attrs: {
        localId: uuid.generate()
      }
    }]);
  }
  /*
     In case of nested action inside lists we explicitly set the cursor
     We need to insert it relatively to previous doc structure
     So we calculate the position of previous list item and save that position
     (The cursor can be placed easily next to list item)
   */
  var previousListItemPos = isNestedActionInsideLists ? $from.start($from.depth - 2) : 0;

  // and delete the action at the current pos
  // we can do this because we know either first new child will be taskItem or nothing at all

  tr = tr.replace(tr.mapping.map($from.start() - 2), tr.mapping.map($from.end() + 2), frag.size ? new Slice(frag, 0, 0) : Slice.empty);

  // put cursor inside paragraph
  if (setSelection && !isNestedActionInsideLists) {
    tr = tr.setSelection(new TextSelection(tr.doc.resolve($from.pos + 1 - (shouldSplit ? 0 : 2))));
  }
  // lift list up if the node after the initial one was a taskList
  // which means it would have empty placeholder content if we just immediately delete it
  // if it's a taskItem then it can stand alone, so it's fine
  var $oldAfter = origDoc.resolve($from.after());

  // if different levels then we shouldn't lift
  if ($oldAfter.depth === $from.depth - 1) {
    if ($oldAfter.nodeAfter && isActionOrDecisionList($oldAfter.nodeAfter)) {
      // getBlockRange expects to be inside the taskItem
      var pos = tr.mapping.map($oldAfter.pos + 2);
      var $after = tr.doc.resolve(pos);
      var blockRange = getBlockRange($after, tr.doc.resolve($after.after($after.depth - 1) - 1));
      if (blockRange) {
        tr = tr.lift(blockRange, blockRange.depth - 1).scrollIntoView();
      }

      // we delete 1 past the range of the empty taskItem
      // otherwise we hit a bug in prosemirror-transform:
      // Cannot read property 'content' of undefined
      tr = tr.deleteRange(pos - 3, pos - 1);
    }
  }
  if (isNestedActionInsideLists) {
    processNestedActionItem(tr, $from, previousListItemPos);
  }
  return tr;
};
var creatParentListItemFragement = function creatParentListItemFragement(state) {
  return state.schema.nodes.listItem.create({}, state.schema.nodes.paragraph.create());
};
var splitListItem = function splitListItem(state, dispatch) {
  var tr = state.tr,
    $from = state.selection.$from;
  var paragraph = state.schema.nodes.paragraph;
  var listItem = state.schema.nodes.listItem;
  if (actionDecisionFollowsOrNothing($from)) {
    if (dispatch) {
      if (hasParentNodeOfType(listItem)(tr.selection)) {
        // if we're inside a list item, then we pass in a fragment containing a new list item not a paragraph
        dispatch(splitListItemWith(tr, creatParentListItemFragement(state), $from, true));
        return true;
      }
      dispatch(splitListItemWith(tr, paragraph.createChecked(), $from, true));
    }
    return true;
  }
  return false;
};
var enter = function enter(editorAnalyticsAPI, getContextIdentifier) {
  return filter(isInsideTaskOrDecisionItem, chainCommands(filter(isEmptyTaskDecision, chainCommands(getUnindentCommand(editorAnalyticsAPI)(), splitListItem)), function (state, dispatch) {
    var selection = state.selection,
      schema = state.schema;
    var taskItem = schema.nodes.taskItem;
    var $from = selection.$from,
      $to = selection.$to;
    var node = $from.node($from.depth);
    var nodeType = node && node.type;
    var listType = nodeType === taskItem ? 'taskList' : 'decisionList';
    var addItem = function addItem(_ref) {
      var tr = _ref.tr,
        itemLocalId = _ref.itemLocalId;
      // ED-8932: When cursor is at the beginning of a task item, instead of split, we insert above.
      if ($from.pos === $to.pos && $from.parentOffset === 0) {
        var newTask = nodeType.createAndFill({
          localId: itemLocalId
        });
        if (newTask) {
          // Current position will point to text node, but we want to insert above the taskItem node
          return tr.insert($from.pos - 1, newTask);
        }
      }
      return tr.split($from.pos, 1, [{
        type: nodeType,
        attrs: {
          localId: itemLocalId
        }
      }]);
    };
    var insertTr = insertTaskDecisionWithAnalytics(editorAnalyticsAPI, getContextIdentifier)(state, listType, INPUT_METHOD.KEYBOARD, addItem);
    if (insertTr && dispatch) {
      insertTr.scrollIntoView();
      dispatch(insertTr);
    }
    return true;
  }));
};
var cmdOptEnter = filter(isInsideTaskOrDecisionItem, function (state, dispatch) {
  var selection = state.selection,
    schema = state.schema;
  var taskItem = schema.nodes.taskItem;
  var $from = selection.$from;
  var node = $from.node($from.depth);
  var nodeType = node && node.type;
  var nodePos = $from.before($from.depth);
  if (nodeType === taskItem) {
    var tr = state.tr;
    tr.step(new SetAttrsStep(nodePos, {
      state: node.attrs.state === 'TODO' ? 'DONE' : 'TODO',
      localId: node.attrs.localId
    }));
    if (tr && dispatch) {
      dispatch(tr);
    }
  }
  return true;
});
export function keymapPlugin(schema, api, allowNestedTasks, consumeTabs) {
  var _api$analytics3, _api$analytics4;
  var getContextIdentifier = function getContextIdentifier() {
    var _api$contextIdentifie;
    return api === null || api === void 0 || (_api$contextIdentifie = api.contextIdentifier) === null || _api$contextIdentifie === void 0 || (_api$contextIdentifie = _api$contextIdentifie.sharedState.currentState()) === null || _api$contextIdentifie === void 0 ? void 0 : _api$contextIdentifie.contextIdentifierProvider;
  };
  var indentHandlers = {
    'Shift-Tab': filter([isInsideTaskOrDecisionItem, function (state) {
      return !shouldLetTabThroughInTable(state);
    }], function (state, dispatch) {
      var _api$analytics;
      return getUnindentCommand(api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions)(INPUT_METHOD.KEYBOARD)(state, dispatch) || !!consumeTabs;
    }),
    Tab: filter([isInsideTaskOrDecisionItem, function (state) {
      return !shouldLetTabThroughInTable(state);
    }], function (state, dispatch) {
      var _api$analytics2;
      return getIndentCommand(api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions)(INPUT_METHOD.KEYBOARD)(state, dispatch) || !!consumeTabs;
    })
  };
  var defaultHandlers = consumeTabs ? {
    'Shift-Tab': isInsideTaskOrDecisionItem,
    Tab: isInsideTaskOrDecisionItem
  } : {};
  var keymaps = _objectSpread(_defineProperty({
    Backspace: backspace(api === null || api === void 0 || (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions),
    Delete: deleteForwards,
    'Ctrl-d': deleteForwards,
    Enter: enter(api === null || api === void 0 || (_api$analytics4 = api.analytics) === null || _api$analytics4 === void 0 ? void 0 : _api$analytics4.actions, getContextIdentifier)
  }, toggleTaskItemCheckbox.common, cmdOptEnter), allowNestedTasks ? indentHandlers : defaultHandlers);
  return keymap(keymaps);
}
export default keymapPlugin;