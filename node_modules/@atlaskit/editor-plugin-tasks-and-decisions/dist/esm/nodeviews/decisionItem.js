import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import React from 'react';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import DecisionItem from '../ui/Decision';
import { useShowPlaceholder } from './hooks/use-show-placeholder';
var DecisionItemWrapper = function DecisionItemWrapper(_ref) {
  var api = _ref.api,
    editorView = _ref.editorView,
    forwardRef = _ref.forwardRef,
    isContentNodeEmpty = _ref.isContentNodeEmpty,
    getPos = _ref.getPos;
  var showPlaceholder = useShowPlaceholder({
    editorView: editorView,
    isContentNodeEmpty: isContentNodeEmpty,
    getPos: getPos,
    api: api
  });
  return /*#__PURE__*/React.createElement(DecisionItem, {
    contentRef: forwardRef,
    showPlaceholder: showPlaceholder
  });
};
var Decision = /*#__PURE__*/function (_ReactNodeView) {
  function Decision() {
    _classCallCheck(this, Decision);
    return _callSuper(this, Decision, arguments);
  }
  _inherits(Decision, _ReactNodeView);
  return _createClass(Decision, [{
    key: "isContentEmpty",
    value: function isContentEmpty(node) {
      return node.content.childCount === 0;
    }
  }, {
    key: "initWithAPI",
    value: function initWithAPI(api) {
      this.api = api;
      this.init();
      return this;
    }
  }, {
    key: "createDomRef",
    value: function createDomRef() {
      var domRef = document.createElement('li');
      domRef.style.listStyleType = 'none';
      return domRef;
    }
  }, {
    key: "getContentDOM",
    value: function getContentDOM() {
      var dom = document.createElement('div');
      // setting a className prevents PM/Chrome mutation observer from
      // incorrectly deleting nodes
      dom.className = 'decision-item';
      return {
        dom: dom
      };
    }
  }, {
    key: "render",
    value: function render(_props, forwardRef) {
      var isContentNodeEmpty = this.isContentEmpty(this.node);
      return /*#__PURE__*/React.createElement(DecisionItemWrapper, {
        forwardRef: forwardRef,
        isContentNodeEmpty: isContentNodeEmpty,
        api: this.api
        // The getPosHandler type is wrong, there is no `boolean` in the real implementation
        // @ts-expect-error 2322: Type 'getPosHandler' is not assignable to type '() => number | undefined'.
        ,
        getPos: this.getPos,
        editorView: this.view
      });
    }
  }, {
    key: "viewShouldUpdate",
    value: function viewShouldUpdate(nextNode) {
      return this.isContentEmpty(this.node) && !this.isContentEmpty(nextNode) || this.isContentEmpty(nextNode) && !this.isContentEmpty(this.node);
    }
  }, {
    key: "update",
    value: function update(node, decorations) {
      return _superPropGet(Decision, "update", this, 3)([node, decorations]);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      if (!this.contentDOM) {
        return true;
      }
      return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
    }
  }]);
}(ReactNodeView);
export var decisionItemNodeView = function decisionItemNodeView(portalProviderAPI, eventDispatcher, api) {
  return function (node, view, getPos) {
    return new Decision(node, view, getPos, portalProviderAPI, eventDispatcher, {}).initWithAPI(api);
  };
};