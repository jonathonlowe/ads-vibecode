/* taskItem.tsx generated by @compiled/babel-plugin v0.36.1 */
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import "./taskItem.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import { useEffect, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { SetAttrsStep } from '@atlaskit/adf-schema/steps';
import { AnalyticsListener } from '@atlaskit/analytics-next';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE, MODE, PLATFORMS } from '@atlaskit/editor-common/analytics';
import { tasksAndDecisionsMessages } from '@atlaskit/editor-common/messages';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import Heading from '@atlaskit/heading';
import EditorDoneIcon from '@atlaskit/icon/core/migration/check-mark--editor-done';
import { fg } from '@atlaskit/platform-feature-flags';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import Popup from '@atlaskit/popup';
import { Box, Pressable, Stack } from '@atlaskit/primitives/compiled';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import TaskItem from '../ui/Task';
import { useShowPlaceholder } from './hooks/use-show-placeholder';
var TRYING_REQUEST_TIMEOUT = 3000;
var wrapperStyles = null;
var wrapperBoxStyles = null;
var dotStyles = null;

// eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage -- This rule thinks this isn't a `css()` call due to the name mapping
var dotStylesUnbounded = null;
var pressableStyles = {
  pressable: "_ca0qze3t _n3tdze3t _19bvze3t _u5f3ze3t _1wybdlk8 _syaz1e6v _bfhksm61 _9oik1r31 _1bnx8stv _jf4cnqa1 _9h8h16c2"
};
var RequestedMessage = function RequestedMessage() {
  var _useIntl = useIntl(),
    formatMessage = _useIntl.formatMessage;
  return /*#__PURE__*/React.createElement(React.Fragment, null, formatMessage(tasksAndDecisionsMessages.requestToEdit), /*#__PURE__*/React.createElement(EditorDoneIcon, {
    label: "requested-to-edit",
    color: "var(--ds-icon-disabled, #091E424F)"
  }));
};
var RequestToEditButton = function RequestToEditButton(_ref) {
  var onClick = _ref.onClick;
  var _useIntl2 = useIntl(),
    formatMessage = _useIntl2.formatMessage;
  return /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Pressable, {
    onClick: onClick,
    xcss: pressableStyles.pressable
  }, formatMessage(tasksAndDecisionsMessages.requestToEdit)));
};
var anaylyticsEventPayload = function anaylyticsEventPayload(action) {
  return {
    action: action,
    actionSubject: ACTION_SUBJECT.REQUEST_TO_EDIT_POP_UP,
    eventType: EVENT_TYPE.UI,
    attributes: {
      platform: PLATFORMS.WEB,
      mode: MODE.EDITOR
    }
  };
};
var TaskItemWrapper = function TaskItemWrapper(_ref2) {
  var localId = _ref2.localId,
    forwardRef = _ref2.forwardRef,
    isDone = _ref2.isDone,
    onChange = _ref2.onChange,
    placeholder = _ref2.placeholder,
    providerFactory = _ref2.providerFactory,
    isContentNodeEmpty = _ref2.isContentNodeEmpty,
    api = _ref2.api,
    getPos = _ref2.getPos,
    editorView = _ref2.editorView;
  var hasRequestedEditPermission = useSharedPluginStateSelector(api, 'taskDecision.hasRequestedEditPermission');
  var focusedTaskItemLocalId = useSharedPluginStateSelector(api, 'taskDecision.focusedTaskItemLocalId');
  var isFocused = Boolean(focusedTaskItemLocalId === localId);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isOpen = _useState2[0],
    setIsOpen = _useState2[1];
  var _useState3 = useState(hasRequestedEditPermission),
    _useState4 = _slicedToArray(_useState3, 2),
    requested = _useState4[0],
    setRequested = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    tryingRequest = _useState6[0],
    setTryingRequest = _useState6[1];
  var _useIntl3 = useIntl(),
    formatMessage = _useIntl3.formatMessage;
  useEffect(function () {
    if (fg('editor_request_to_edit_task')) {
      setRequested(hasRequestedEditPermission);
    }
  }, [hasRequestedEditPermission]);
  useEffect(function () {
    if (!tryingRequest && fg('editor_request_to_edit_task')) {
      var timout = setTimeout(function () {
        setTryingRequest(false);
      }, TRYING_REQUEST_TIMEOUT);
      return function () {
        return clearTimeout(timout);
      };
    }
  }, [tryingRequest]);
  var showPlaceholder = useShowPlaceholder({
    editorView: editorView,
    isContentNodeEmpty: isContentNodeEmpty,
    getPos: getPos,
    api: api
  });
  var onHandleEdit = function onHandleEdit(editorAnalyticsAPI) {
    if (fg('editor_request_to_edit_task')) {
      var _api$taskDecision;
      setTryingRequest(true);
      var tr = editorView.state.tr;
      var nodePos = getPos();
      if (typeof nodePos !== 'number') {
        return;
      }
      tr.setMeta('scrollIntoView', false);
      if (!(api !== null && api !== void 0 && (_api$taskDecision = api.taskDecision) !== null && _api$taskDecision !== void 0 && (_api$taskDecision = _api$taskDecision.sharedState.currentState()) !== null && _api$taskDecision !== void 0 && _api$taskDecision.hasEditPermission)) {
        var _api$taskDecision2;
        var requestToEdit = api === null || api === void 0 || (_api$taskDecision2 = api.taskDecision) === null || _api$taskDecision2 === void 0 || (_api$taskDecision2 = _api$taskDecision2.sharedState.currentState()) === null || _api$taskDecision2 === void 0 ? void 0 : _api$taskDecision2.requestToEditContent;
        if (requestToEdit) {
          requestToEdit();
        }
      }
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(anaylyticsEventPayload(ACTION.REQUEST_TO_EDIT))(tr);
      editorView.dispatch(tr);
    }
  };
  var onHandleDismiss = function onHandleDismiss(editorAnalyticsAPI) {
    editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.fireAnalyticsEvent(anaylyticsEventPayload(ACTION.DISMISSED));
    setIsOpen(false);
  };
  var onHandleClick = function onHandleClick() {
    if (fg('editor_request_to_edit_task')) {
      setIsOpen(true);
    }
  };
  if (!fg('editor_request_to_edit_task')) {
    return /*#__PURE__*/React.createElement(TaskItem, {
      taskId: localId,
      contentRef: forwardRef,
      isDone: isDone,
      onChange: onChange,
      isFocused: isFocused,
      showPlaceholder: showPlaceholder,
      placeholder: placeholder,
      providers: providerFactory,
      api: api
    });
  }
  return /*#__PURE__*/React.createElement(Popup, {
    isOpen: isOpen,
    onClose: function onClose() {
      var _api$analytics;
      return onHandleDismiss(api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions);
    },
    content: function content() {
      var _api$editorViewMode;
      return /*#__PURE__*/React.createElement("div", {
        className: ax(["_1e0c1txw _2lx21bp4 _p12f1qwj _ca0qpxbi _u5f31ejb _n3tdpxbi _19bv1ejb"])
      }, /*#__PURE__*/React.createElement(Stack, {
        space: "space.150"
      }, /*#__PURE__*/React.createElement(Heading, {
        size: "xsmall"
      }, formatMessage(tasksAndDecisionsMessages.editAccessTitle)), /*#__PURE__*/React.createElement("div", null, formatMessage(tasksAndDecisionsMessages.requestToEditDescription)), /*#__PURE__*/React.createElement("div", {
        className: ax(["_zulp1b66 _1e0c1txw _4cvr1h6o _syaz1lh4"])
      }, tryingRequest || requested ? /*#__PURE__*/React.createElement(RequestedMessage, null) : /*#__PURE__*/React.createElement(RequestToEditButton, {
        onClick: (api === null || api === void 0 || (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 || (_api$editorViewMode = _api$editorViewMode.sharedState.currentState()) === null || _api$editorViewMode === void 0 ? void 0 : _api$editorViewMode.mode) === 'view' ? function () {
          var _api$analytics2;
          return onHandleEdit(api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions);
        } : undefined
      }), /*#__PURE__*/React.createElement("div", {
        className: ax(["_19pku2gc _otyru2gc _18u0u2gc _2hwxu2gc _1e0c1o8l _1bsbyh40 _4t3iyh40 _bfhkc8cv", "_2rko1ssb"])
      }), /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Pressable, {
        onClick: function onClick() {
          var _api$analytics3;
          return onHandleDismiss(api === null || api === void 0 || (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions);
        },
        xcss: pressableStyles.pressable
      }, formatMessage(tasksAndDecisionsMessages.dismiss))))));
    },
    trigger: function trigger(triggerProps) {
      var _api$taskDecision3;
      return /*#__PURE__*/React.createElement(TaskItem, {
        taskId: localId,
        contentRef: forwardRef,
        inputRef: triggerProps.ref,
        isDone: isDone,
        onChange: onChange,
        onClick: onHandleClick,
        isFocused: isFocused,
        showPlaceholder: showPlaceholder,
        placeholder: placeholder,
        providers: providerFactory,
        disableOnChange: !(api !== null && api !== void 0 && (_api$taskDecision3 = api.taskDecision) !== null && _api$taskDecision3 !== void 0 && (_api$taskDecision3 = _api$taskDecision3.sharedState.currentState()) !== null && _api$taskDecision3 !== void 0 && _api$taskDecision3.hasEditPermission),
        api: api
      });
    },
    placement: 'bottom-start'
  });
};
var Task = /*#__PURE__*/function (_ReactNodeView) {
  function Task() {
    var _this;
    _classCallCheck(this, Task);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, Task, [].concat(args));
    _defineProperty(_this, "handleOnChange", function (taskId, isChecked) {
      var _this$api;
      var tr = _this.view.state.tr;
      var nodePos = _this.getPos();
      if (typeof nodePos !== 'number') {
        return false;
      }

      // SetAttrsStep should be used to prevent task updates from being dropped when mapping task ticks
      // from a previous version of the document, such as a published page.
      tr.step(new SetAttrsStep(nodePos, {
        state: isChecked ? 'DONE' : 'TODO',
        localId: taskId
      }));
      tr.setMeta('scrollIntoView', false);

      /**
       * This is a test implementation to call the request to edit mutation
       * from within editor when toggling a task where a user has no edit access.
       *
       * This will eventially be handled by https://product-fabric.atlassian.net/browse/ED-24773
       * to connect up the correct user action
       */
      if (!((_this$api = _this.api) !== null && _this$api !== void 0 && (_this$api = _this$api.taskDecision) !== null && _this$api !== void 0 && (_this$api = _this$api.sharedState.currentState()) !== null && _this$api !== void 0 && _this$api.hasEditPermission) && fg('editor_request_to_edit_task')) {
        var _this$api2;
        var requestToEdit = (_this$api2 = _this.api) === null || _this$api2 === void 0 || (_this$api2 = _this$api2.taskDecision) === null || _this$api2 === void 0 || (_this$api2 = _this$api2.sharedState.currentState()) === null || _this$api2 === void 0 ? void 0 : _this$api2.requestToEditContent;
        if (requestToEdit) {
          requestToEdit();
        }
      }
      _this.view.dispatch(tr);
    });
    /**
     * Dynamically generates analytics data relating to the parent list.
     *
     * Required to be dynamic, as list (in prosemirror model) may have
     * changed (e.g. item movements, or additional items in list).
     * This node view will have not rerendered for those changes, so
     * cannot render the position and listSize into the
     * AnalyticsContext at initial render time.
     */
    _defineProperty(_this, "addListAnalyticsData", function (event) {
      try {
        var nodePos = _this.getPos();
        if (typeof nodePos !== 'number') {
          return false;
        }
        var resolvedPos = _this.view.state.doc.resolve(nodePos);
        var position = resolvedPos.index();
        var listSize = resolvedPos.parent.childCount;
        var listLocalId = resolvedPos.parent.attrs.localId;
        event.update(function (payload) {
          var _this$api3;
          var _payload$attributes = payload.attributes,
            attributes = _payload$attributes === void 0 ? {} : _payload$attributes,
            actionSubject = payload.actionSubject;
          if (actionSubject !== 'action') {
            // Not action related, ignore
            return payload;
          }
          return _objectSpread(_objectSpread({}, payload), {}, {
            attributes: _objectSpread(_objectSpread({}, attributes), {}, {
              position: position,
              listSize: listSize,
              listLocalId: listLocalId
            }, fg('editor_request_to_edit_task') && {
              hasEditPermission: (_this$api3 = _this.api) === null || _this$api3 === void 0 || (_this$api3 = _this$api3.taskDecision) === null || _this$api3 === void 0 || (_this$api3 = _this$api3.sharedState.currentState()) === null || _this$api3 === void 0 ? void 0 : _this$api3.hasEditPermission
            })
          });
        });
      } catch (e) {
        // This can occur if pos is NaN (seen it in some test cases)
        // Act defensively here, and lose some analytics data rather than
        // cause any user facing error.
      }
    });
    return _this;
  }
  _inherits(Task, _ReactNodeView);
  return _createClass(Task, [{
    key: "initWithAPI",
    value: function initWithAPI(api) {
      this.api = api;
      this.init();
      return this;
    }
  }, {
    key: "isContentEmpty",
    value: function isContentEmpty(node) {
      return node.content.childCount === 0;
    }
  }, {
    key: "createDomRef",
    value: function createDomRef() {
      var domRef = document.createElement('div');
      domRef.style.listStyleType = 'none';
      return domRef;
    }
  }, {
    key: "getContentDOM",
    value: function getContentDOM() {
      var dom = document.createElement('div');
      // setting a className prevents PM/Chrome mutation observer from
      // incorrectly deleting nodes
      dom.className = 'task-item';
      return {
        dom: dom
      };
    }
  }, {
    key: "render",
    value: function render(props, forwardRef) {
      var _this$node$attrs = this.node.attrs,
        localId = _this$node$attrs.localId,
        state = _this$node$attrs.state;
      var isContentNodeEmpty = this.isContentEmpty(this.node);
      return /*#__PURE__*/React.createElement(AnalyticsListener, {
        channel: "fabric-elements",
        onEvent: this.addListAnalyticsData
      }, /*#__PURE__*/React.createElement(TaskItemWrapper, {
        localId: localId,
        forwardRef: forwardRef,
        isDone: state === 'DONE',
        onChange: this.handleOnChange,
        isContentNodeEmpty: isContentNodeEmpty,
        placeholder: props.placeholder,
        providerFactory: props.providerFactory
        // The getPosHandler type is wrong, there is no `boolean` in the real implementation
        // @ts-expect-error 2322: Type 'getPosHandler' is not assignable to type '() => number | undefined'.
        ,
        getPos: this.getPos,
        editorView: this.view,
        api: this.api
      }));
    }
  }, {
    key: "viewShouldUpdate",
    value: function viewShouldUpdate(nextNode) {
      return this.isContentEmpty(this.node) && !this.isContentEmpty(nextNode) || this.isContentEmpty(nextNode) && !this.isContentEmpty(this.node);
    }
  }, {
    key: "update",
    value: function update(node, decorations) {
      return _superPropGet(Task, "update", this, 3)([node, decorations, undefined, function (currentNode, newNode) {
        return !!(currentNode.attrs.state === newNode.attrs.state);
      }]);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      if (!this.contentDOM) {
        return true;
      }
      return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
    }
  }]);
}(ReactNodeView);
export function taskItemNodeViewFactory(portalProviderAPI, eventDispatcher, providerFactory, api, intl, placeholder) {
  return function (node, view, getPos) {
    return new Task(node, view, getPos, portalProviderAPI, eventDispatcher, {
      placeholder: placeholder,
      providerFactory: providerFactory
    }).initWithAPI(api);
  };
}