/* taskItem.tsx generated by @compiled/babel-plugin v0.36.1 */
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "./taskItem.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { useEffect, useState } from 'react';
import { useIntl } from 'react-intl-next';
import { SetAttrsStep } from '@atlaskit/adf-schema/steps';
import { AnalyticsListener } from '@atlaskit/analytics-next';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE, MODE, PLATFORMS } from '@atlaskit/editor-common/analytics';
import { tasksAndDecisionsMessages } from '@atlaskit/editor-common/messages';
import ReactNodeView from '@atlaskit/editor-common/react-node-view';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import Heading from '@atlaskit/heading';
import EditorDoneIcon from '@atlaskit/icon/core/migration/check-mark--editor-done';
import { fg } from '@atlaskit/platform-feature-flags';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import Popup from '@atlaskit/popup';
import { Box, Pressable, Stack } from '@atlaskit/primitives/compiled';
// Ignored via go/ees005
// eslint-disable-next-line import/no-named-as-default
import TaskItem from '../ui/Task';
import { useShowPlaceholder } from './hooks/use-show-placeholder';
const TRYING_REQUEST_TIMEOUT = 3000;
const wrapperStyles = null;
const wrapperBoxStyles = null;
const dotStyles = null;

// eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage -- This rule thinks this isn't a `css()` call due to the name mapping
const dotStylesUnbounded = null;
const pressableStyles = {
  pressable: "_ca0qze3t _n3tdze3t _19bvze3t _u5f3ze3t _1wybdlk8 _syaz1e6v _bfhksm61 _9oik1r31 _1bnx8stv _jf4cnqa1 _9h8h16c2"
};
const RequestedMessage = () => {
  const {
    formatMessage
  } = useIntl();
  return /*#__PURE__*/React.createElement(React.Fragment, null, formatMessage(tasksAndDecisionsMessages.requestToEdit), /*#__PURE__*/React.createElement(EditorDoneIcon, {
    label: "requested-to-edit",
    color: "var(--ds-icon-disabled, #091E424F)"
  }));
};
const RequestToEditButton = ({
  onClick
}) => {
  const {
    formatMessage
  } = useIntl();
  return /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Pressable, {
    onClick: onClick,
    xcss: pressableStyles.pressable
  }, formatMessage(tasksAndDecisionsMessages.requestToEdit)));
};
const anaylyticsEventPayload = action => {
  return {
    action,
    actionSubject: ACTION_SUBJECT.REQUEST_TO_EDIT_POP_UP,
    eventType: EVENT_TYPE.UI,
    attributes: {
      platform: PLATFORMS.WEB,
      mode: MODE.EDITOR
    }
  };
};
const TaskItemWrapper = ({
  localId,
  forwardRef,
  isDone,
  onChange,
  placeholder,
  providerFactory,
  isContentNodeEmpty,
  api,
  getPos,
  editorView
}) => {
  const hasRequestedEditPermission = useSharedPluginStateSelector(api, 'taskDecision.hasRequestedEditPermission');
  const focusedTaskItemLocalId = useSharedPluginStateSelector(api, 'taskDecision.focusedTaskItemLocalId');
  const isFocused = Boolean(focusedTaskItemLocalId === localId);
  const [isOpen, setIsOpen] = useState(false);
  const [requested, setRequested] = useState(hasRequestedEditPermission);
  const [tryingRequest, setTryingRequest] = useState(false);
  const {
    formatMessage
  } = useIntl();
  useEffect(() => {
    if (fg('editor_request_to_edit_task')) {
      setRequested(hasRequestedEditPermission);
    }
  }, [hasRequestedEditPermission]);
  useEffect(() => {
    if (!tryingRequest && fg('editor_request_to_edit_task')) {
      const timout = setTimeout(() => {
        setTryingRequest(false);
      }, TRYING_REQUEST_TIMEOUT);
      return () => clearTimeout(timout);
    }
  }, [tryingRequest]);
  const showPlaceholder = useShowPlaceholder({
    editorView,
    isContentNodeEmpty,
    getPos,
    api
  });
  const onHandleEdit = editorAnalyticsAPI => {
    if (fg('editor_request_to_edit_task')) {
      var _api$taskDecision, _api$taskDecision$sha;
      setTryingRequest(true);
      const {
        tr
      } = editorView.state;
      const nodePos = getPos();
      if (typeof nodePos !== 'number') {
        return;
      }
      tr.setMeta('scrollIntoView', false);
      if (!(api !== null && api !== void 0 && (_api$taskDecision = api.taskDecision) !== null && _api$taskDecision !== void 0 && (_api$taskDecision$sha = _api$taskDecision.sharedState.currentState()) !== null && _api$taskDecision$sha !== void 0 && _api$taskDecision$sha.hasEditPermission)) {
        var _api$taskDecision2, _api$taskDecision2$sh;
        const requestToEdit = api === null || api === void 0 ? void 0 : (_api$taskDecision2 = api.taskDecision) === null || _api$taskDecision2 === void 0 ? void 0 : (_api$taskDecision2$sh = _api$taskDecision2.sharedState.currentState()) === null || _api$taskDecision2$sh === void 0 ? void 0 : _api$taskDecision2$sh.requestToEditContent;
        if (requestToEdit) {
          requestToEdit();
        }
      }
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 ? void 0 : editorAnalyticsAPI.attachAnalyticsEvent(anaylyticsEventPayload(ACTION.REQUEST_TO_EDIT))(tr);
      editorView.dispatch(tr);
    }
  };
  const onHandleDismiss = editorAnalyticsAPI => {
    editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 ? void 0 : editorAnalyticsAPI.fireAnalyticsEvent(anaylyticsEventPayload(ACTION.DISMISSED));
    setIsOpen(false);
  };
  const onHandleClick = () => {
    if (fg('editor_request_to_edit_task')) {
      setIsOpen(true);
    }
  };
  if (!fg('editor_request_to_edit_task')) {
    return /*#__PURE__*/React.createElement(TaskItem, {
      taskId: localId,
      contentRef: forwardRef,
      isDone: isDone,
      onChange: onChange,
      isFocused: isFocused,
      showPlaceholder: showPlaceholder,
      placeholder: placeholder,
      providers: providerFactory,
      api: api
    });
  }
  return /*#__PURE__*/React.createElement(Popup, {
    isOpen: isOpen,
    onClose: () => {
      var _api$analytics;
      return onHandleDismiss(api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions);
    },
    content: () => {
      var _api$editorViewMode, _api$editorViewMode$s;
      return /*#__PURE__*/React.createElement("div", {
        className: ax(["_1e0c1txw _2lx21bp4 _p12f1qwj _ca0qpxbi _u5f31ejb _n3tdpxbi _19bv1ejb"])
      }, /*#__PURE__*/React.createElement(Stack, {
        space: "space.150"
      }, /*#__PURE__*/React.createElement(Heading, {
        size: "xsmall"
      }, formatMessage(tasksAndDecisionsMessages.editAccessTitle)), /*#__PURE__*/React.createElement("div", null, formatMessage(tasksAndDecisionsMessages.requestToEditDescription)), /*#__PURE__*/React.createElement("div", {
        className: ax(["_zulp1b66 _1e0c1txw _4cvr1h6o _syaz1lh4"])
      }, tryingRequest || requested ? /*#__PURE__*/React.createElement(RequestedMessage, null) : /*#__PURE__*/React.createElement(RequestToEditButton, {
        onClick: (api === null || api === void 0 ? void 0 : (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : (_api$editorViewMode$s = _api$editorViewMode.sharedState.currentState()) === null || _api$editorViewMode$s === void 0 ? void 0 : _api$editorViewMode$s.mode) === 'view' ? () => {
          var _api$analytics2;
          return onHandleEdit(api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions);
        } : undefined
      }), /*#__PURE__*/React.createElement("div", {
        className: ax(["_19pku2gc _otyru2gc _18u0u2gc _2hwxu2gc _1e0c1o8l _1bsbyh40 _4t3iyh40 _bfhkc8cv", "_2rko1ssb"])
      }), /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Pressable, {
        onClick: () => {
          var _api$analytics3;
          return onHandleDismiss(api === null || api === void 0 ? void 0 : (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions);
        },
        xcss: pressableStyles.pressable
      }, formatMessage(tasksAndDecisionsMessages.dismiss))))));
    },
    trigger: triggerProps => {
      var _api$taskDecision3, _api$taskDecision3$sh;
      return /*#__PURE__*/React.createElement(TaskItem, {
        taskId: localId,
        contentRef: forwardRef,
        inputRef: triggerProps.ref,
        isDone: isDone,
        onChange: onChange,
        onClick: onHandleClick,
        isFocused: isFocused,
        showPlaceholder: showPlaceholder,
        placeholder: placeholder,
        providers: providerFactory,
        disableOnChange: !(api !== null && api !== void 0 && (_api$taskDecision3 = api.taskDecision) !== null && _api$taskDecision3 !== void 0 && (_api$taskDecision3$sh = _api$taskDecision3.sharedState.currentState()) !== null && _api$taskDecision3$sh !== void 0 && _api$taskDecision3$sh.hasEditPermission),
        api: api
      });
    },
    placement: 'bottom-start'
  });
};
class Task extends ReactNodeView {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "handleOnChange", (taskId, isChecked) => {
      var _this$api, _this$api$taskDecisio, _this$api$taskDecisio2;
      const {
        tr
      } = this.view.state;
      const nodePos = this.getPos();
      if (typeof nodePos !== 'number') {
        return false;
      }

      // SetAttrsStep should be used to prevent task updates from being dropped when mapping task ticks
      // from a previous version of the document, such as a published page.
      tr.step(new SetAttrsStep(nodePos, {
        state: isChecked ? 'DONE' : 'TODO',
        localId: taskId
      }));
      tr.setMeta('scrollIntoView', false);

      /**
       * This is a test implementation to call the request to edit mutation
       * from within editor when toggling a task where a user has no edit access.
       *
       * This will eventially be handled by https://product-fabric.atlassian.net/browse/ED-24773
       * to connect up the correct user action
       */
      if (!((_this$api = this.api) !== null && _this$api !== void 0 && (_this$api$taskDecisio = _this$api.taskDecision) !== null && _this$api$taskDecisio !== void 0 && (_this$api$taskDecisio2 = _this$api$taskDecisio.sharedState.currentState()) !== null && _this$api$taskDecisio2 !== void 0 && _this$api$taskDecisio2.hasEditPermission) && fg('editor_request_to_edit_task')) {
        var _this$api2, _this$api2$taskDecisi, _this$api2$taskDecisi2;
        const requestToEdit = (_this$api2 = this.api) === null || _this$api2 === void 0 ? void 0 : (_this$api2$taskDecisi = _this$api2.taskDecision) === null || _this$api2$taskDecisi === void 0 ? void 0 : (_this$api2$taskDecisi2 = _this$api2$taskDecisi.sharedState.currentState()) === null || _this$api2$taskDecisi2 === void 0 ? void 0 : _this$api2$taskDecisi2.requestToEditContent;
        if (requestToEdit) {
          requestToEdit();
        }
      }
      this.view.dispatch(tr);
    });
    /**
     * Dynamically generates analytics data relating to the parent list.
     *
     * Required to be dynamic, as list (in prosemirror model) may have
     * changed (e.g. item movements, or additional items in list).
     * This node view will have not rerendered for those changes, so
     * cannot render the position and listSize into the
     * AnalyticsContext at initial render time.
     */
    _defineProperty(this, "addListAnalyticsData", event => {
      try {
        const nodePos = this.getPos();
        if (typeof nodePos !== 'number') {
          return false;
        }
        const resolvedPos = this.view.state.doc.resolve(nodePos);
        const position = resolvedPos.index();
        const listSize = resolvedPos.parent.childCount;
        const listLocalId = resolvedPos.parent.attrs.localId;
        event.update(payload => {
          var _this$api3, _this$api3$taskDecisi, _this$api3$taskDecisi2;
          const {
            attributes = {},
            actionSubject
          } = payload;
          if (actionSubject !== 'action') {
            // Not action related, ignore
            return payload;
          }
          return {
            ...payload,
            attributes: {
              ...attributes,
              position,
              listSize,
              listLocalId,
              ...(fg('editor_request_to_edit_task') && {
                hasEditPermission: (_this$api3 = this.api) === null || _this$api3 === void 0 ? void 0 : (_this$api3$taskDecisi = _this$api3.taskDecision) === null || _this$api3$taskDecisi === void 0 ? void 0 : (_this$api3$taskDecisi2 = _this$api3$taskDecisi.sharedState.currentState()) === null || _this$api3$taskDecisi2 === void 0 ? void 0 : _this$api3$taskDecisi2.hasEditPermission
              })
            }
          };
        });
      } catch (e) {
        // This can occur if pos is NaN (seen it in some test cases)
        // Act defensively here, and lose some analytics data rather than
        // cause any user facing error.
      }
    });
  }
  initWithAPI(api) {
    this.api = api;
    this.init();
    return this;
  }
  isContentEmpty(node) {
    return node.content.childCount === 0;
  }
  createDomRef() {
    const domRef = document.createElement('div');
    domRef.style.listStyleType = 'none';
    return domRef;
  }
  getContentDOM() {
    const dom = document.createElement('div');
    // setting a className prevents PM/Chrome mutation observer from
    // incorrectly deleting nodes
    dom.className = 'task-item';
    return {
      dom
    };
  }
  render(props, forwardRef) {
    const {
      localId,
      state
    } = this.node.attrs;
    const isContentNodeEmpty = this.isContentEmpty(this.node);
    return /*#__PURE__*/React.createElement(AnalyticsListener, {
      channel: "fabric-elements",
      onEvent: this.addListAnalyticsData
    }, /*#__PURE__*/React.createElement(TaskItemWrapper, {
      localId: localId,
      forwardRef: forwardRef,
      isDone: state === 'DONE',
      onChange: this.handleOnChange,
      isContentNodeEmpty: isContentNodeEmpty,
      placeholder: props.placeholder,
      providerFactory: props.providerFactory
      // The getPosHandler type is wrong, there is no `boolean` in the real implementation
      // @ts-expect-error 2322: Type 'getPosHandler' is not assignable to type '() => number | undefined'.
      ,
      getPos: this.getPos,
      editorView: this.view,
      api: this.api
    }));
  }
  viewShouldUpdate(nextNode) {
    return this.isContentEmpty(this.node) && !this.isContentEmpty(nextNode) || this.isContentEmpty(nextNode) && !this.isContentEmpty(this.node);
  }
  update(node, decorations) {
    return super.update(node, decorations, undefined, (currentNode, newNode) => !!(currentNode.attrs.state === newNode.attrs.state));
  }
  ignoreMutation(mutation) {
    if (!this.contentDOM) {
      return true;
    }
    return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
  }
}
export function taskItemNodeViewFactory(portalProviderAPI, eventDispatcher, providerFactory, api, intl, placeholder) {
  return (node, view, getPos) => {
    return new Task(node, view, getPos, portalProviderAPI, eventDispatcher, {
      placeholder,
      providerFactory
    }).initWithAPI(api);
  };
}