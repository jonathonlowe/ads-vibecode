import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { bindAll } from 'bind-event-listener';
import { SetAttrsStep } from '@atlaskit/adf-schema/steps';
import { tasksAndDecisionsMessages } from '@atlaskit/editor-common/messages';
import { logException } from '@atlaskit/editor-common/monitoring';
import { DOMSerializer } from '@atlaskit/editor-prosemirror/model';
import { openRequestEditPopupAt } from '../pm-plugins/helpers';
import { taskItemToDom } from './taskItemNodeSpec';
export class TaskItemNodeView {
  static logError(error) {
    void logException(error, {
      location: 'editor-plugin-date/DateNodeView'
    });
  }
  constructor(node, view, getPos, {
    api,
    placeholder,
    intl
  }) {
    _defineProperty(this, "dom", document.createElement('span'));
    _defineProperty(this, "handleOnClick", event => {
      var _this$api, _this$api$taskDecisio, _this$api$taskDecisio2;
      if (!((_this$api = this.api) !== null && _this$api !== void 0 && (_this$api$taskDecisio = _this$api.taskDecision) !== null && _this$api$taskDecisio !== void 0 && (_this$api$taskDecisio2 = _this$api$taskDecisio.sharedState.currentState()) !== null && _this$api$taskDecisio2 !== void 0 && _this$api$taskDecisio2.hasEditPermission)) {
        event.stopImmediatePropagation();
        event.preventDefault();
        const pos = this.getPos();
        if (typeof pos === 'number') {
          openRequestEditPopupAt(this.view, pos);
        }
        return;
      }
    });
    _defineProperty(this, "handleOnChange", () => {
      var _this$api2;
      const {
        tr
      } = this.view.state;
      const nodePos = this.getPos();
      if (typeof nodePos !== 'number') {
        return;
      }
      const {
        localId,
        state
      } = this.node.attrs;
      const isDone = state === 'DONE';
      const nextState = isDone ? 'TODO' : 'DONE';
      const currentTaskDecisionState = (_this$api2 = this.api) === null || _this$api2 === void 0 ? void 0 : _this$api2.taskDecision.sharedState.currentState();

      // logic is inspired from packages/elements/task-decision/src/components/ResourcedTaskItem.tsx
      if (currentTaskDecisionState !== null && currentTaskDecisionState !== void 0 && currentTaskDecisionState.taskDecisionProvider && this.objectId) {
        currentTaskDecisionState === null || currentTaskDecisionState === void 0 ? void 0 : currentTaskDecisionState.taskDecisionProvider.toggleTask({
          localId,
          objectAri: this.objectId
        }, isDone ? 'DONE' : 'TODO');
      }

      // SetAttrsStep should be used to prevent task updates from being dropped when mapping task ticks
      // from a previous version of the document, such as a published page.
      tr.step(new SetAttrsStep(nodePos, {
        state: nextState,
        localId: localId
      }));
      tr.setMeta('scrollIntoView', false);
      this.view.dispatch(tr);
    });
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.intl = intl;
    this.api = api;
    this.view = view;
    try {
      const domPlaceholder = placeholder !== null && placeholder !== void 0 ? placeholder : this.intl.formatMessage(tasksAndDecisionsMessages.taskPlaceholder);
      const {
        dom,
        contentDOM
      } = DOMSerializer.renderSpec(document, taskItemToDom(node, domPlaceholder));
      if (!(dom instanceof HTMLElement)) {
        // It's safe to throw error here because, the code is wrapped in try-catch.
        // However, it should never happen because `DOMSerializer.renderSpec()` should always return HTMLElement.
        throw new Error('DOMSerializer.renderSpec() did not return HTMLElement');
      }
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.input = this.dom.querySelector('input[type="checkbox"]');
      this.unbindInputDom = bindAll(this.input, [{
        type: 'click',
        listener: this.handleOnClick
      }, {
        type: 'change',
        listener: this.handleOnChange
      }]);
      this.objectId = this.getObjectAri();
      this.updatePlaceholder(node);
    } catch (error) {
      TaskItemNodeView.logError(error instanceof Error ? error : new Error('Unknown error on TaskItemNodeView constructor'));
      this.renderFallback();
    }
  }
  getContextIdentifierProvider() {
    var _this$api3, _this$api3$contextIde, _this$api3$contextIde2;
    return (_this$api3 = this.api) === null || _this$api3 === void 0 ? void 0 : (_this$api3$contextIde = _this$api3.contextIdentifier) === null || _this$api3$contextIde === void 0 ? void 0 : (_this$api3$contextIde2 = _this$api3$contextIde.sharedState.currentState()) === null || _this$api3$contextIde2 === void 0 ? void 0 : _this$api3$contextIde2.contextIdentifierProvider;
  }
  getObjectAri() {
    const provider = this.getContextIdentifierProvider();
    if (provider) {
      return provider.objectId;
    }
    return undefined;
  }
  isContentEmpty(node) {
    return node.content.childCount === 0;
  }
  renderFallback() {
    var _this$node$firstChild;
    const fallbackElementInput = document.createElement('input');
    fallbackElementInput.setAttribute('type', 'checkbox');
    const fallbackElementText = document.createElement('span');
    fallbackElementText.innerText = ((_this$node$firstChild = this.node.firstChild) === null || _this$node$firstChild === void 0 ? void 0 : _this$node$firstChild.text) || '';
    this.dom.appendChild(fallbackElementInput);
    this.dom.appendChild(fallbackElementText);
  }

  // Update the placeholder visibility based on content
  updatePlaceholder(node) {
    const currentIsContentEmpty = this.isContentEmpty(node);
    if (currentIsContentEmpty !== this.emptyContent) {
      var _this$contentDOM;
      this.emptyContent = currentIsContentEmpty;
      (_this$contentDOM = this.contentDOM) === null || _this$contentDOM === void 0 ? void 0 : _this$contentDOM.toggleAttribute('data-empty', currentIsContentEmpty);
    }
  }
  update(node) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.updatePlaceholder(node);
    if (!node.sameMarkup(this.node)) {
      if (node.attrs.state !== this.node.attrs.state) {
        this.dom.setAttribute('data-task-state', node.attrs.state);
        this.dom.setAttribute('state', node.attrs.state);
      }
      this.node = node;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.contentDOM) {
      return true;
    }
    return !this.contentDOM.contains(mutation.target) && mutation.type !== 'selection';
  }
  destroy() {
    if (this.unbindInputDom) {
      this.unbindInputDom();
    }
    this.contentDOM = undefined;
    this.input = undefined;
    this.objectId = undefined;
    this.emptyContent = undefined;
    this.api = undefined;
  }
}