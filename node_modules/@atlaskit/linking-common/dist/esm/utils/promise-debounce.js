/**
 * Given a callback function returns a promise that resolves to the result of calling the callback function but is
 * debounced (execution is cancelled and promise will remain pending if `promiseDebounce` is re-called within the `time` interval)
 * @param cb Callback which returns result to be resolved
 * @param time Debounce interval
 * @returns Function that returns debounced promise
 */
export function promiseDebounce(cb, time) {
  var timeoutId;

  // Returns a promise that fires the debounce fn and pushes a resolver
  // to have the debounced result resolved
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    timeoutId && clearTimeout(timeoutId);
    return new Promise(function (resolve, reject) {
      timeoutId = setTimeout(function () {
        cb.apply(void 0, args).then(resolve).catch(reject);
      }, time);
    });
  };
}