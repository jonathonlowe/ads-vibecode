"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkFormat = void 0;
var _ = require("../");
var _text = require("../../text");
var _linkResolver = require("./link-resolver");
var _linkParser = require("./link-parser");
// [http://www.example.com] and [Example|http://www.example.com]
// Ignored via go/ees005
// eslint-disable-next-line require-unicode-regexp
var LINK_FORMAT_REGEXP = /^\[([^\[\]\n]+)]/;
var linkFormat = exports.linkFormat = function linkFormat(_ref) {
  var input = _ref.input,
    position = _ref.position,
    schema = _ref.schema,
    context = _ref.context;
  var match = input.substring(position).match(LINK_FORMAT_REGEXP);

  /**
   * The following token types will be ignored in parsing
   * the content of a table cell
   */
  var ignoreTokenTypes = [_.TokenType.DOUBLE_DASH_SYMBOL, _.TokenType.TRIPLE_DASH_SYMBOL, _.TokenType.QUADRUPLE_DASH_SYMBOL, _.TokenType.TABLE, _.TokenType.RULER,
  // We want to avoid recursion
  _.TokenType.LINK_TEXT, _.TokenType.LINK_FORMAT];
  if (!match) {
    return fallback();
  }
  var content = (0, _linkParser.parseContentLink)(match[1]);
  var resolvedLink = (0, _linkResolver.resolveLink)(content, schema, context);
  if (resolvedLink) {
    return resolvedLink;
  }
  var nodes = (0, _text.parseString)({
    schema: schema,
    context: context,
    ignoreTokenTypes: ignoreTokenTypes,
    input: match[0]
  });
  return {
    type: 'pmnode',
    nodes: nodes,
    length: match[0].length
  };
};
function fallback() {
  return {
    type: 'text',
    text: '[',
    length: 1
  };
}