"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlLinkResolver = urlLinkResolver;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _index = require("../index");
var _adfSchema = require("@atlaskit/adf-schema");
var _text = require("../../text");
var _text2 = require("../../utils/text");
function urlLinkResolver(link, schema, context) {
  var output = [];
  var url = link.notLinkBody;
  var textRepresentation = link.linkBody || link.notLinkBody;
  if (!(0, _adfSchema.isSafeUrl)(url)) {
    return;
  }
  var ignoreTokenTypes = [_index.TokenType.DOUBLE_DASH_SYMBOL, _index.TokenType.TRIPLE_DASH_SYMBOL, _index.TokenType.QUADRUPLE_DASH_SYMBOL, _index.TokenType.LINK_TEXT, _index.TokenType.ISSUE_KEY];
  var rawContent = (0, _text.parseString)({
    ignoreTokenTypes: ignoreTokenTypes,
    schema: schema,
    context: context,
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    input: textRepresentation.replace(/^mailto:/, '')
  });
  var decoratedContent = rawContent.map(function (n) {
    var mark = schema.marks.link.create({
      href: url
    });

    // We don't want to mix `code` mark with others
    if (n.type.name === 'text' && !(0, _text2.hasAnyOfMarks)(n, ['link', 'code'])) {
      return n.mark([].concat((0, _toConsumableArray2.default)(n.marks), [mark]));
    }
    return n;
  });
  output.push.apply(output, (0, _toConsumableArray2.default)(decoratedContent));
  if (!hasTextNode(rawContent)) {
    var mark = schema.marks.link.create({
      href: url
    });
    var linkTextNode = schema.text(textRepresentation, [mark]);
    output.push(linkTextNode);
  }
  return output;
}
function hasTextNode(nodes) {
  return nodes.find(function (n) {
    return n.type.name === 'text';
  });
}