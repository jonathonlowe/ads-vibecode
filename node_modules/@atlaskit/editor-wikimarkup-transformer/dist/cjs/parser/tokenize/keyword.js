"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.macroKeywordTokenMap = void 0;
exports.parseIssueKeyword = parseIssueKeyword;
exports.parseLeadingKeyword = parseLeadingKeyword;
exports.parseMacroKeyword = parseMacroKeyword;
exports.parseOtherKeyword = parseOtherKeyword;
var _ = require("./");
var _list = require("./list");
var macroKeywordTokenMap = exports.macroKeywordTokenMap = [{
  type: _.TokenType.ADF_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{adf/i
}, {
  type: _.TokenType.ANCHOR_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{anchor/i
}, {
  type: _.TokenType.CODE_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{code/i
}, {
  type: _.TokenType.QUOTE_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{quote/i
}, {
  type: _.TokenType.NOFORMAT_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{noformat/i
}, {
  type: _.TokenType.PANEL_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{panel/i
}, {
  type: _.TokenType.COLOR_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{color/
}, {
  type: _.TokenType.LOREM_MACRO,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^{loremipsum/i
}];

/**
 * The order of this mapping determind which keyword
 * will be checked first, so it matters.
 */
var keywordTokenMap = {
  '[': _.TokenType.LINK_FORMAT,
  http: _.TokenType.LINK_TEXT,
  ftp: _.TokenType.LINK_TEXT,
  jamfselfservice: _.TokenType.LINK_TEXT,
  irc: _.TokenType.LINK_TEXT,
  mailto: _.TokenType.LINK_TEXT,
  '\\\\': _.TokenType.FORCE_LINE_BREAK,
  '\r': _.TokenType.HARD_BREAK,
  '\n': _.TokenType.HARD_BREAK,
  '\r\n': _.TokenType.HARD_BREAK,
  '!': _.TokenType.MEDIA,
  '----': _.TokenType.QUADRUPLE_DASH_SYMBOL,
  '---': _.TokenType.TRIPLE_DASH_SYMBOL,
  '--': _.TokenType.DOUBLE_DASH_SYMBOL,
  '{-}': _.TokenType.DELETED,
  '{+}': _.TokenType.INSERTED,
  '{*}': _.TokenType.STRONG,
  '{^}': _.TokenType.SUPERSCRIPT,
  '{~}': _.TokenType.SUBSCRIPT,
  '{_}': _.TokenType.EMPHASIS,
  '{{{}': _.TokenType.MONOSPACE,
  '{??}': _.TokenType.CITATION,
  '-': _.TokenType.DELETED,
  '+': _.TokenType.INSERTED,
  '*': _.TokenType.STRONG,
  '^': _.TokenType.SUPERSCRIPT,
  '~': _.TokenType.SUBSCRIPT,
  _: _.TokenType.EMPHASIS,
  '{{': _.TokenType.MONOSPACE,
  '??': _.TokenType.CITATION
};
var keywordTokenMapKeys = Object.keys(keywordTokenMap);
function parseMacroKeyword(input) {
  for (var i = 0; i < macroKeywordTokenMap.length; i++) {
    var keyword = macroKeywordTokenMap[i];
    if (keyword.regex.test(input)) {
      return {
        type: keyword.type
      };
    }
  }
  return null;
}
function parseOtherKeyword(input) {
  for (var i = 0; i < keywordTokenMapKeys.length; i++) {
    if (input.startsWith(keywordTokenMapKeys[i])) {
      return {
        type: keywordTokenMap[keywordTokenMapKeys[i]]
      };
    }
  }

  // Look for a emoji
  var char = input.charAt(0);
  if ([':', '(', ';'].indexOf(char) !== -1) {
    return {
      // This potentially can be a emoji. The emoji parser will fail out if it's not
      type: _.TokenType.EMOJI
    };
  }
  return null;
}

/**
 * These keywords only take effect when it's at the
 * beginning of the line
 * The order of the mapping matters. We should not put
 * LIST in front of RULER for example.
 */
var leadingKeywordTokenMap = [{
  type: _.TokenType.QUOTE,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^bq\./
}, {
  type: _.TokenType.HEADING,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^h[1-6]\./
}, {
  type: _.TokenType.RULER,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^-{4,5}(\s|$)/
}, {
  type: _.TokenType.TRIPLE_DASH_SYMBOL,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^-{3}\s/
}, {
  type: _.TokenType.DOUBLE_DASH_SYMBOL,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^-{2}\s/
}, {
  // Lists are limited to max 20 levels of depth
  type: _.TokenType.LIST,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: new RegExp("^([*#]{1,".concat(_list.MAX_LIST_DEPTH, "}|-) "))
}, {
  type: _.TokenType.TABLE,
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  regex: /^\|{1,2}/
}];
function parseLeadingKeyword(input) {
  for (var i = 0; i < leadingKeywordTokenMap.length; i++) {
    var keyword = leadingKeywordTokenMap[i];
    if (keyword.regex.test(input)) {
      return {
        type: keyword.type
      };
    }
  }
  return null;
}
function parseIssueKeyword(input, issueKeyRegex) {
  if (issueKeyRegex && issueKeyRegex.test(input)) {
    return {
      type: _.TokenType.ISSUE_KEY
    };
  }
  return null;
}