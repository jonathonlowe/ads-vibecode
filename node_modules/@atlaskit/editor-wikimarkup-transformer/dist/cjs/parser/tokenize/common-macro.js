"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commonMacro = commonMacro;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
// TODO: Create a type for rawContentProcessor which will be shared among parsers

function commonMacro(input, schema, opt) {
  /**
   * Forging the opening regex, the result would look something like
   * /^\{(quote)(?::([^\{\n\}]*))?\}/i
   */
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  var opening = new RegExp("^{(".concat(opt.keyword, ")(?::([^{\n}]*))?}"), 'i');
  var matchOpening = input.match(opening);
  if (!matchOpening) {
    return fallback(input);
  }
  var _matchOpening = (0, _slicedToArray2.default)(matchOpening, 3),
    name = _matchOpening[1],
    rawAttrs = _matchOpening[2];
  var openingLength = matchOpening[0].length;
  if (!opt.paired) {
    /**
     * Some macros do not have a closing symbol, for example
     * {anchor:here} {loremipsum}
     */
    return opt.rawContentProcessor(rawAttrs, '', openingLength, schema, opt.context);
  }

  /**
   * Forging the closing regex, the result would look something like
   * /\{quote\}/
   */
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  var closing = new RegExp("{".concat(name, "}"));
  var matchClosing = closing.exec(input.substring(openingLength));
  var rawContent = '';
  if (matchClosing) {
    rawContent = input.substring(openingLength, openingLength + matchClosing.index);
  }
  var length = matchClosing ? openingLength + matchClosing.index + matchClosing[0].length : openingLength;
  return opt.rawContentProcessor(rawAttrs, rawContent, length, schema, opt.context);
}
function fallback(input) {
  return {
    type: 'text',
    text: input.substr(0, 1),
    length: 1
  };
}