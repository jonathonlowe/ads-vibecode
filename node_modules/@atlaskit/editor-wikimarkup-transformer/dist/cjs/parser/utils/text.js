"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSurroundingSymbols = exports.StringBuffer = void 0;
exports.hasAnyOfMarks = hasAnyOfMarks;
exports.isBlank = isBlank;
exports.isDigit = isDigit;
exports.isNotBlank = isNotBlank;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
/**
 * Check if the node has certain marks
 */
function hasAnyOfMarks(node, types) {
  return node.marks.findIndex(function (m) {
    return types.findIndex(function (t) {
      return m.type.name === t;
    }) !== -1;
  }) !== -1;
}
function isDigit(value) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return !!value.match(/^\d$/);
}
function isBlank(value) {
  return value === null || value.trim() === '';
}
function isNotBlank(value) {
  return !isBlank(value);
}

/**
 * ESS-2375 Returns the beginning and closing symbol to parse a token
 */
var getSurroundingSymbols = exports.getSurroundingSymbols = function getSurroundingSymbols(trimmedInput, openingText, closingText) {
  var openingSymbol = trimmedInput.startsWith("{".concat(openingText, "}")) ? "{".concat(openingText, "}") : openingText;
  var endIndex = trimmedInput.indexOf(closingText, openingSymbol === "{".concat(openingText, "}") ? openingText.length + 2 : openingText.length);
  var closingSymbol = endIndex > -1 && trimmedInput.charAt(endIndex - 1) === '{' && trimmedInput.charAt(endIndex + closingText.length) === '}' ? "{".concat(closingText, "}") : closingText;
  return {
    openingSymbol: openingSymbol,
    closingSymbol: closingSymbol
  };
};

// TODO This is using strings which makes it potentially a performance bottleneck
var StringBuffer = exports.StringBuffer = /*#__PURE__*/function () {
  function StringBuffer() {
    var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    (0, _classCallCheck2.default)(this, StringBuffer);
    this.buffer = buffer;
  }
  return (0, _createClass2.default)(StringBuffer, [{
    key: "indexOf",
    value: function indexOf(value) {
      return this.buffer.indexOf(value);
    }
  }, {
    key: "lastIndexOf",
    value: function lastIndexOf(value) {
      return this.buffer.lastIndexOf(value);
    }
  }, {
    key: "charAt",
    value: function charAt(index) {
      return this.buffer.charAt(index);
    }
  }, {
    key: "length",
    value: function length() {
      return this.buffer.length;
    }
  }, {
    key: "delete",
    value: function _delete(start, end) {
      this.buffer = this.buffer.substring(0, start) + this.buffer.substring(end);
    }
  }, {
    key: "append",
    value: function append(value) {
      this.buffer += value;
    }
  }, {
    key: "substring",
    value: function substring(start, end) {
      return this.buffer.substring(start, end);
    }
  }, {
    key: "deleteCharAt",
    value: function deleteCharAt(index) {
      this.delete(index, index + 1);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.buffer;
    }
  }]);
}();