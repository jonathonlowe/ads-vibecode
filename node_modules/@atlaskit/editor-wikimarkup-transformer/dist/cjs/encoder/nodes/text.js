"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.text = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _keyword = require("../../parser/tokenize/keyword");
var _code = require("../marks/code");
var _color = require("../marks/color");
var _em = require("../marks/em");
var _link = require("../marks/link");
var _strike = require("../marks/strike");
var _strong = require("../marks/strong");
var _subsup = require("../marks/subsup");
var _underline = require("../marks/underline");
/**
 * The order of the mapping matters.
 * For example, textColor will be a macro {color} so
 * we want to process other marks before it.
 */
var markEncoderMapping = new Map([['em', _em.em], ['strike', _strike.strike], ['strong', _strong.strong], ['subsup', _subsup.subsup], ['underline', _underline.underline], ['textColor', _color.textColor], ['link', _link.link], ['code', _code.code]]);

/**
 * ADFEXP-131: Improved logic for escaping metacharacters "[" and "!"
 * Before this change, any instance of "[" and "!" was being escaped
 * "[" is used for mentions
 * "!" is used for media
 */
var MENTION_ESCAPE_PATTERN = '(\\[~)'; // Matches pattern like [~
var MEDIA_ESCAPE_PATTERN = '(![^ !]+)(!)'; // Matches non space content between two consecutive "!" e.g. !filename.txt!
var MEDIA_GROUP_ESCAPE_PATTERN = '(\\[\\^[^ ]+)(\\])'; // Matches non space content between two consecutive "[^" "]" e.g. [^filename.txt]

/**
 * Checks if the node's content needs to be escaped before continuing processing.
 * Currently, the `code` mark and `codeBlock` nodes handle their own escaping, and
 * therefore, should not be escaped here.
 *
 * @param node the current node to encode
 * @param parent the parent node, if exist
 * @returns true if the node should have its text escaped when encoding to wikimarkup.
 */
var isEscapeNeeded = function isEscapeNeeded(node, parent) {
  return !(parent && parent.type.name === 'codeBlock' || node.marks.find(function (m) {
    return m.type.name === 'code';
  }) !== undefined);
};
/**
 * ESS-2569: Removing the backsalshes from the regex
 * ADFEXP-131: Improved logic for escaping metacharacters "[" and "!"
 */
function escapingWikiFormatter(text) {
  var pattern = [MENTION_ESCAPE_PATTERN].concat((0, _toConsumableArray2.default)(_keyword.macroKeywordTokenMap.map(function (macro) {
    return "(".concat(macro.regex.source.replace('^', ''), ")");
  }))).join('|');
  return text
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  .replace(new RegExp(pattern, 'g'), '\\$&')
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  .replace(new RegExp(MEDIA_ESCAPE_PATTERN, 'g'), '\\$1\\$2') // Extra step required for media as currently both ends need to be escaped e.q. !filename.txt!
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  .replace(new RegExp(MEDIA_GROUP_ESCAPE_PATTERN, 'g'), '\\$1\\$2');
}
var text = exports.text = function text(node) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    parent = _ref.parent;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var result = isEscapeNeeded(node, parent) ? escapingWikiFormatter(node.text) : node.text;
  markEncoderMapping.forEach(function (encoder, markName) {
    var mark = node.marks.find(function (m) {
      return m.type.name === markName;
    });
    if (mark) {
      result = encoder(result, mark.attrs);
    }
  });
  return result;
};