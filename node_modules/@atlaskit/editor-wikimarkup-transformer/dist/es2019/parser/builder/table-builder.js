import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * Return the cell type based on the delimeter
 */
function getType(style) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return /\|\|/.test(style) ? 'tableHeader' : 'tableCell';
}
export class TableBuilder {
  constructor(schema) {
    _defineProperty(this, "emptyTableCell", () => {
      const {
        tableCell,
        paragraph
      } = this.schema.nodes;
      return tableCell.createChecked({}, paragraph.createChecked());
    });
    _defineProperty(this, "emptyTableRow", () => {
      const {
        tableRow
      } = this.schema.nodes;
      return tableRow.createChecked({}, this.emptyTableCell());
    });
    /**
     * Build prosemirror table node
     * @returns {PMNode}
     */
    _defineProperty(this, "buildTableNode", () => {
      const {
        root
      } = this;
      const {
        table
      } = this.schema.nodes;
      const content = root.rows.map(this.buildTableRowNode);
      if (content.length === 0) {
        content.push(this.emptyTableRow());
      }
      return table.createChecked({}, content);
    });
    /**
     * Build prosemirror tr node
     * @returns {PMNode}
     */
    _defineProperty(this, "buildTableRowNode", row => {
      const {
        tableRow
      } = this.schema.nodes;
      return tableRow.createChecked({}, row.cells.map(this.buildTableCellNode));
    });
    /**
     * Build prosemirror td/th node
     * @param {TableCell} cell
     * @returns {PMNode}
     */
    _defineProperty(this, "buildTableCellNode", cell => {
      const {
        type,
        content
      } = cell;
      if (content.length === 0) {
        content.push(this.schema.nodes.paragraph.createChecked());
      }
      const cellNode = this.schema.nodes[type];
      return cellNode.createChecked({}, content);
    });
    this.schema = schema;
    this.root = {
      rows: []
    };
  }

  /**
   * Return the type of the base element
   * @returns {string}
   */
  get type() {
    return 'table';
  }

  /**
   * Add new cells to the table
   * @param {AddCellArgs[]} cells
   */
  add(cells) {
    if (!cells.length) {
      return;
    }
    // Iterate the cells and create TH/TD based on the delimeter
    let index = 0;
    for (const cell of cells) {
      const {
        content,
        style
      } = cell;
      const cellType = getType(style);

      // For the first item, determine if it's a new row or not
      if (index === 0) {
        this.addRow();
      }
      const newCell = {
        type: cellType,
        content
      };
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.lastRow.cells.push(newCell);
      index += 1;
    }
  }

  /**
   * Build a prosemirror table from the data
   * @returns {PMNode}
   */
  buildPMNode() {
    return this.buildTableNode();
  }
  /**
   * Add a new row to the table
   */
  addRow() {
    const {
      rows
    } = this.root;
    const row = {
      cells: []
    };
    rows.push(row);
    this.lastRow = row;
  }
}