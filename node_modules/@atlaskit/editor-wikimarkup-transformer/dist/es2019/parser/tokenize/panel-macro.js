import { commonMacro } from './common-macro';
import { parseString } from '../text';
import { parseAttrs } from '../utils/attrs';
import { normalizePMNodes } from '../utils/normalize';
import { getPanelType } from '../utils/panel-type';
import { title } from '../utils/title';
const allowedNodeType = ['paragraph', 'heading', 'orderedList', 'bulletList'];
export const panelMacro = ({
  input,
  position,
  schema,
  context
}) => {
  return commonMacro(input.substring(position), schema, {
    keyword: 'panel',
    paired: true,
    context,
    rawContentProcessor
  });
};
const rawContentProcessor = (rawAttrs, rawContent, length, schema, context) => {
  const output = [];
  const parsedAttrs = parseAttrs(rawAttrs);
  const nodeAttrs = {
    ...parsedAttrs,
    panelType: getPanelType(parsedAttrs)
  };
  const parsedContent = parseString({
    schema,
    context,
    ignoreTokenTypes: [],
    input: rawContent
  });
  const normalizedContent = normalizePMNodes(parsedContent, schema);
  let contentBuffer = parsedAttrs.title ? [title(parsedAttrs.title, schema)] : [];
  for (const n of normalizedContent) {
    if (allowedNodeType.indexOf(n.type.name) !== -1) {
      contentBuffer.push(n);
    } else {
      const panelNode = schema.nodes.panel.createChecked(nodeAttrs, contentBuffer.length ? contentBuffer : schema.nodes.paragraph.createChecked());
      contentBuffer = [];
      output.push(panelNode);
      output.push(n);
    }
  }
  if (contentBuffer.length > 0) {
    const panelNode = schema.nodes.panel.createChecked(nodeAttrs, contentBuffer);
    output.push(panelNode);
  }
  return {
    type: 'pmnode',
    nodes: output.length ? output : [emptyPanel(schema)],
    length
  };
};
function emptyPanel(schema) {
  const p = schema.nodes.paragraph.createChecked();
  return schema.nodes.panel.createChecked({}, p);
}