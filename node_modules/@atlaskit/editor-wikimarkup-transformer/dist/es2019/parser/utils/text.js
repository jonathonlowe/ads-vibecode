/**
 * Check if the node has certain marks
 */
export function hasAnyOfMarks(node, types) {
  return node.marks.findIndex(m => types.findIndex(t => m.type.name === t) !== -1) !== -1;
}
export function isDigit(value) {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return !!value.match(/^\d$/);
}
export function isBlank(value) {
  return value === null || value.trim() === '';
}
export function isNotBlank(value) {
  return !isBlank(value);
}

/**
 * ESS-2375 Returns the beginning and closing symbol to parse a token
 */
export const getSurroundingSymbols = (trimmedInput, openingText, closingText) => {
  const openingSymbol = trimmedInput.startsWith(`{${openingText}}`) ? `{${openingText}}` : openingText;
  const endIndex = trimmedInput.indexOf(closingText, openingSymbol === `{${openingText}}` ? openingText.length + 2 : openingText.length);
  const closingSymbol = endIndex > -1 && trimmedInput.charAt(endIndex - 1) === '{' && trimmedInput.charAt(endIndex + closingText.length) === '}' ? `{${closingText}}` : closingText;
  return {
    openingSymbol,
    closingSymbol
  };
};

// TODO This is using strings which makes it potentially a performance bottleneck
export class StringBuffer {
  constructor(buffer = '') {
    this.buffer = buffer;
  }
  indexOf(value) {
    return this.buffer.indexOf(value);
  }
  lastIndexOf(value) {
    return this.buffer.lastIndexOf(value);
  }
  charAt(index) {
    return this.buffer.charAt(index);
  }
  length() {
    return this.buffer.length;
  }
  delete(start, end) {
    this.buffer = this.buffer.substring(0, start) + this.buffer.substring(end);
  }
  append(value) {
    this.buffer += value;
  }
  substring(start, end) {
    return this.buffer.substring(start, end);
  }
  deleteCharAt(index) {
    this.delete(index, index + 1);
  }
  toString() {
    return this.buffer;
  }
}