import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { TokenType } from './';
import { hasAnyOfMarks, getSurroundingSymbols } from '../utils/text';
import { commonFormatter } from './common-formatter';
import { parseString } from '../text';
import { EM_DASH } from '../../char';
export var citation = function citation(_ref) {
  var input = _ref.input,
    position = _ref.position,
    schema = _ref.schema,
    context = _ref.context;
  /**
   * The following token types will be ignored in parsing
   * the content
   */
  var ignoreTokenTypes = [TokenType.DOUBLE_DASH_SYMBOL, TokenType.TRIPLE_DASH_SYMBOL, TokenType.QUADRUPLE_DASH_SYMBOL, TokenType.ISSUE_KEY];
  // Add code mark to each text
  var contentDecorator = function contentDecorator(n, index) {
    var mark = schema.marks.em.create();
    // We don't want to mix `code` mark with others
    if (n.type.name === 'text' && !hasAnyOfMarks(n, ['em', 'code'])) {
      if (index === 0) {
        // @ts-ignore - [unblock prosemirror bump] allow assign to readonly
        n.text = "".concat(EM_DASH, " ").concat(n.text);
      }
      return n.mark([].concat(_toConsumableArray(n.marks), [mark]));
    }
    return n;
  };
  var rawContentProcessor = function rawContentProcessor(raw, length) {
    var content = parseString({
      ignoreTokenTypes: ignoreTokenTypes,
      schema: schema,
      context: context,
      input: raw
    });
    var decoratedContent = content.map(contentDecorator);
    return {
      type: 'pmnode',
      nodes: decoratedContent,
      length: length
    };
  };
  var _getSurroundingSymbol = getSurroundingSymbols(input.substring(position), '??', '??'),
    openingSymbol = _getSurroundingSymbol.openingSymbol,
    closingSymbol = _getSurroundingSymbol.closingSymbol;
  return commonFormatter(input, position, schema, {
    opening: openingSymbol,
    closing: closingSymbol,
    context: context,
    rawContentProcessor: rawContentProcessor
  });
};