import { isNotBlank } from '../utils/text';

/**
 * Inline Card From Text (ICFT).
 *
 * When we convert WikiMarkup to ADF we stamp all issue keys URLs with the
 * #icft= syntax to identify  which keys should be involved by brackets
 * [XX-999] from the ones which should be blue links in the ADF to WikiMarkup
 * convertion.
 */
// Ignored via go/ees005
// eslint-disable-next-line require-unicode-regexp
export var INLINE_CARD_FROM_TEXT_STAMP = /(#icft=)([A-Z][A-Z]+-[0-9]+)/;
export var issueKey = function issueKey(_ref) {
  var input = _ref.input,
    position = _ref.position,
    schema = _ref.schema,
    context = _ref.context;
  // This scenario happens when context is empty
  if (!context.issueKeyRegex) {
    return fallback(input, position);
  }
  var match = input.substring(position).match(context.issueKeyRegex);
  if (!match) {
    return fallback(input, position);
  }
  var issue = getIssue(context, match[0]);

  // This scenario happens when context doesn't has all the issues inside a markup
  if (!issue) {
    return fallback(input, position);
  }
  var charBefore = input.charAt(position - 1);
  var charAfter = input.charAt(position + issue.key.length);
  if (isNotBlank(charBefore) && isNotAllowedChars(charBefore) || isNotBlank(charAfter) && isNotAllowedChars(charAfter)) {
    return fallback(input, position);
  }
  return {
    type: 'pmnode',
    nodes: buildInlineCard(schema, issue),
    length: match[0].length
  };
};
var fallback = function fallback(input, position) {
  return {
    type: 'text',
    text: input.substr(position, 1),
    length: 1
  };
};
export var getIssue = function getIssue(context, key) {
  return context.conversion && context.conversion.inlineCardConversion && context.conversion.inlineCardConversion[key] ? {
    key: key,
    url: context.conversion.inlineCardConversion[key]
  } : null;
};
export var buildInlineCard = function buildInlineCard(schema, issue) {
  return [schema.nodes.inlineCard.createChecked({
    url: withInlineCardFromTextStamp(issue)
  })];
};
var withInlineCardFromTextStamp = function withInlineCardFromTextStamp(issue) {
  return INLINE_CARD_FROM_TEXT_STAMP.test(issue.url) ? issue.url : "".concat(issue.url, "#icft=").concat(issue.key);
};

// Ignored via go/ees005
// eslint-disable-next-line require-unicode-regexp
var isNotAllowedChars = function isNotAllowedChars(char) {
  return !/\s|\(|\)|!|\.|\,|\/|\:/.test(char);
};
export var buildIssueKeyRegex = function buildIssueKeyRegex(inlineCardConversion) {
  if (!inlineCardConversion) {
    return undefined;
  }
  var pattern = Object.keys(inlineCardConversion).join('|');
  if (!pattern) {
    return undefined;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return new RegExp("^(".concat(pattern, ")"));
};