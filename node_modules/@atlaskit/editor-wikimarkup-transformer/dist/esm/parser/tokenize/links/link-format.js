import { TokenType } from '../';
import { parseString } from '../../text';
import { resolveLink } from './link-resolver';
import { parseContentLink } from './link-parser';

// [http://www.example.com] and [Example|http://www.example.com]
// Ignored via go/ees005
// eslint-disable-next-line require-unicode-regexp
var LINK_FORMAT_REGEXP = /^\[([^\[\]\n]+)]/;
export var linkFormat = function linkFormat(_ref) {
  var input = _ref.input,
    position = _ref.position,
    schema = _ref.schema,
    context = _ref.context;
  var match = input.substring(position).match(LINK_FORMAT_REGEXP);

  /**
   * The following token types will be ignored in parsing
   * the content of a table cell
   */
  var ignoreTokenTypes = [TokenType.DOUBLE_DASH_SYMBOL, TokenType.TRIPLE_DASH_SYMBOL, TokenType.QUADRUPLE_DASH_SYMBOL, TokenType.TABLE, TokenType.RULER,
  // We want to avoid recursion
  TokenType.LINK_TEXT, TokenType.LINK_FORMAT];
  if (!match) {
    return fallback();
  }
  var content = parseContentLink(match[1]);
  var resolvedLink = resolveLink(content, schema, context);
  if (resolvedLink) {
    return resolvedLink;
  }
  var nodes = parseString({
    schema: schema,
    context: context,
    ignoreTokenTypes: ignoreTokenTypes,
    input: match[0]
  });
  return {
    type: 'pmnode',
    nodes: nodes,
    length: match[0].length
  };
};
function fallback() {
  return {
    type: 'text',
    text: '[',
    length: 1
  };
}