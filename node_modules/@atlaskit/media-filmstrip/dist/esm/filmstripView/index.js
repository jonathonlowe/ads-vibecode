import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React from 'react';
import debounce from 'debounce';
import { FilmStripList, FilmStripListItem, FilmStripListWrapper, FilmStripViewWrapper, LeftArrow, RightArrow } from './wrappers';
export { LeftArrow, RightArrow } from './wrappers';
var DURATION_MIN = 0.5;
var DURATION_MAX = 1.0;
var EXTRA_PADDING = 4;
export var MUTATION_CONFIG = {
  attributes: true,
  childList: true,
  subtree: true,
  characterData: true
};
export var MediaFilmStripListItemSelector = 'media-filmstrip-list-item';
export var FilmstripView = /*#__PURE__*/function (_React$Component) {
  function FilmstripView(props) {
    var _this;
    _classCallCheck(this, FilmstripView);
    _this = _callSuper(this, FilmstripView, [props]);
    _defineProperty(_this, "previousOffset", 0);
    _defineProperty(_this, "state", {
      bufferWidth: 0,
      windowWidth: 0,
      touchMoveStartPosition: 0,
      isTouchMoveInProgress: false
    });
    _defineProperty(_this, "handleSizeChange", function () {
      // get the new widths
      var _this2 = _this,
        windowElement = _this2.windowElement,
        bufferElement = _this2.bufferElement;
      var bufferWidth = 0;
      var windowWidth = 0;
      var childOffsets = [];
      if (windowElement && bufferElement) {
        bufferWidth = bufferElement.getBoundingClientRect().width;
        windowWidth = windowElement.getBoundingClientRect().width;

        // we're calculating `left` based on `width` because `rect.left` can be a negative value after resizing the window (considered scrolled??)
        var children = Array.prototype.slice.call(bufferElement.children, 0);
        var left = 0;
        childOffsets = children.map(function (child, index) {
          var width = child.getBoundingClientRect().width;
          var offset = {
            left: left,
            right: left + width - 1
          };
          left += width;
          return offset;
        });
      }

      // make sure the state has changed before we update state and notify the integrator
      // (otherwise, since this method() is called in componentDidUpdate() we'll recurse until the stack size is exceeded)
      var _this$state = _this.state,
        prevBufferWidth = _this$state.bufferWidth,
        prevWindowWidth = _this$state.windowWidth;
      if (bufferWidth === prevBufferWidth && windowWidth === prevWindowWidth) {
        // NOTE: we're not checking here if childOffsets has changed... if the children change size but
        // result in the exact same size buffer, we're not going to update, resulting in incorrect navigations
        return;
      }

      // store the widths
      _this.setState({
        bufferWidth: bufferWidth,
        windowWidth: windowWidth
      }, function () {
        _this.childOffsets = childOffsets;

        // notify the integrator
        var onSize = _this.props.onSize;
        if (onSize) {
          onSize({
            offset: Math.min(_this.maxOffset, _this.offset),
            offsets: childOffsets,
            width: windowWidth,
            minOffset: _this.minOffset,
            maxOffset: _this.maxOffset
          });
        }
      });
    });
    _defineProperty(_this, "handleWindowElementChange", function (windowElement) {
      _this.windowElement = windowElement;
      _this.handleSizeChange();
    });
    _defineProperty(_this, "handleBufferElementChange", function (bufferElement) {
      if (!bufferElement) {
        return;
      }
      _this.bufferElement = bufferElement;
      _this.handleSizeChange();
      _this.initMutationObserver();
    });
    _defineProperty(_this, "handleMutation", function (mutationList) {
      // there are edge cases where the DOM may change outside of the normal React life-cycle
      // https://product-fabric.atlassian.net/browse/MSW-425
      _this.handleSizeChange();
    });
    _defineProperty(_this, "handleLeftClick", function (event) {
      // Stop the click event from bubling up and being handled by other components
      // See https://product-fabric.atlassian.net/browse/MSW-165
      event.stopPropagation();
      var onScroll = _this.props.onScroll;
      if (onScroll) {
        var windowWidth = _this.state.windowWidth;
        var newOffset = _this.getClosestForLeft(_this.offset - windowWidth);
        if (newOffset >= _this.offset) {
          // if for some reason we tried to scroll left but it didn't scroll or scrolls right instead (can happen when container is too narrow)
          // just try to scroll by the windowWidth
          newOffset = Math.max(_this.offset - windowWidth, _this.minOffset);
        }
        onScroll({
          direction: 'left',
          offset: newOffset,
          animate: true
        });
      }
    });
    _defineProperty(_this, "handleRightClick", function (event) {
      // Stop the click event from bubling up and being handled by other components
      // See https://product-fabric.atlassian.net/browse/MSW-165
      event.stopPropagation();
      var onScroll = _this.props.onScroll;
      if (onScroll) {
        var windowWidth = _this.state.windowWidth;
        var newOffset = _this.getClosestForRight(_this.offset + windowWidth);
        if (newOffset <= _this.offset) {
          // if for some reason we tried to scroll right but it didn't scroll or scrolls left instead (can happen when container is too narrow)
          // just try to scroll by the windowWidth
          newOffset = Math.min(_this.offset + windowWidth, _this.maxOffset);
        }
        onScroll({
          direction: 'right',
          offset: newOffset,
          animate: true
        });
      }
    });
    _defineProperty(_this, "handleScroll", function (event) {
      var isHorizontalScroll = Math.abs(event.deltaX) > Math.abs(event.deltaY);
      if (!isHorizontalScroll) {
        return;
      }

      // don't actually let the element scroll because we'll fake scrolling with `transform: translateX()`
      event.preventDefault();

      // notify the integrator of the offset change
      var onScroll = _this.props.onScroll;
      if (onScroll && isHorizontalScroll) {
        var newOffset = Math.max(_this.minOffset, Math.min(_this.maxOffset, _this.offset + event.deltaX));
        onScroll({
          direction: event.deltaX < 0 ? 'left' : 'right',
          offset: newOffset,
          animate: false
        });
      }
    });
    _defineProperty(_this, "handleTouchStart", function (event) {
      if (event.touches[0]) {
        _this.setState({
          touchMoveStartPosition: event.touches[0].clientX,
          isTouchMoveInProgress: true
        });
      }
    });
    _defineProperty(_this, "handleTouchEnd", function (event) {
      if (event.touches[0]) {
        _this.setState({
          touchMoveStartPosition: event.touches[0].clientX,
          isTouchMoveInProgress: false
        });
      }
    });
    _defineProperty(_this, "handleTouchMove", function (event) {
      var onScroll = _this.props.onScroll;
      if (_this.state.isTouchMoveInProgress && onScroll) {
        var currentPosition = event.touches[0].clientX;
        var newOffset = _this.state.touchMoveStartPosition ? _this.offset - (currentPosition - _this.state.touchMoveStartPosition) : _this.offset;
        onScroll({
          direction: newOffset > _this.offset ? 'left' : 'right',
          offset: newOffset,
          animate: false
        });
      }
    });
    _this.childOffsets = [];
    try {
      _this.mutationObserver = new MutationObserver(debounce(_this.handleMutation, 30, true));
    } catch (e) {
      // in the case where we are running on an unsupported browser,
      // or where tests include the FilmstripView but do not mock the MutationObserver - we catch it and handle safely here.
      // NOTE: this won't effect the component, it just means mutations won't be observerd
    }
    return _this;
  }
  _inherits(FilmstripView, _React$Component);
  return _createClass(FilmstripView, [{
    key: "offset",
    get: function get() {
      var offset = this.props.offset;
      if (!offset) {
        return 0;
      }
      return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
    }
  }, {
    key: "minOffset",
    get: function get() {
      return 0;
    }

    /**
     * The furthest we can scroll, where the end of the buffer is just in view
     */
  }, {
    key: "maxOffset",
    get: function get() {
      var _this$state2 = this.state,
        bufferWidth = _this$state2.bufferWidth,
        windowWidth = _this$state2.windowWidth;
      return Math.max(this.minOffset, bufferWidth - windowWidth - 1);
    }
  }, {
    key: "canGoLeft",
    get: function get() {
      return this.offset > this.minOffset;
    }
  }, {
    key: "canGoRight",
    get: function get() {
      return this.offset < this.maxOffset;
    }
  }, {
    key: "transitionDuration",
    get: function get() {
      var animate = this.props.animate;
      var windowWidth = this.state.windowWidth;
      if (!animate) {
        return 0;
      }
      if (Math.abs(this.offset - this.previousOffset) < 1e-6) {
        return DURATION_MIN;
      } else {
        var diff = Math.abs(this.offset - this.previousOffset);
        var relativeOffset = diff / windowWidth;
        var duration = DURATION_MAX - DURATION_MIN * relativeOffset;
        return Math.max(Math.min(duration, DURATION_MAX), DURATION_MIN);
      }
    }
  }, {
    key: "initMutationObserver",
    value: function initMutationObserver() {
      var mutationObserver = this.mutationObserver;
      if (mutationObserver && this.bufferElement) {
        mutationObserver.disconnect();
        mutationObserver.observe(this.bufferElement, MUTATION_CONFIG);
      }
    }
  }, {
    key: "triggerScrollEvent",
    value: function triggerScrollEvent() {
      if (!this.windowElement) {
        return;
      }
      var event = document.createEvent('MouseEvents');
      event.initEvent('scroll', true, true);
      this.windowElement.dispatchEvent(event);
    }

    // find the child that is cut off on the left edge of the window and change the window offset to
    // start to the left of that child
  }, {
    key: "getClosestForLeft",
    value: function getClosestForLeft(offset) {
      var leftWindowEdge = Math.min(this.maxOffset, Math.max(this.minOffset, offset));
      for (var i = 0; i < this.childOffsets.length; ++i) {
        var childBounds = this.childOffsets[i];
        if (leftWindowEdge >= childBounds.left && leftWindowEdge <= childBounds.right) {
          var newOffset = i === 0 ? childBounds.left : childBounds.right;
          if (newOffset >= EXTRA_PADDING) {
            return newOffset - EXTRA_PADDING; // show extra padding from the next sibling for aesthetic reasons
          } else {
            return newOffset;
          }
        }
      }
      return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
    }

    // find the child that is cut off on the right edge of the window and change the window offset
    // to finish at start of the next child
  }, {
    key: "getClosestForRight",
    value: function getClosestForRight(offset) {
      var windowWidth = this.state.windowWidth;
      var rightWindowEdge = Math.min(this.maxOffset, Math.max(this.minOffset, offset)) + windowWidth;
      for (var i = 0; i < this.childOffsets.length; ++i) {
        var childBounds = this.childOffsets[i];
        if (rightWindowEdge >= childBounds.left && rightWindowEdge <= childBounds.right) {
          var newOffset = (i === this.childOffsets.length - 1 ? childBounds.right : childBounds.left) - windowWidth;
          if (newOffset + EXTRA_PADDING <= this.maxOffset) {
            return newOffset + EXTRA_PADDING; // show extra padding from the next sibling for aesthetic reasons
          } else {
            return newOffset;
          }
        }
      }
      return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
    }
  }, {
    key: "renderLeftArrow",
    value: function renderLeftArrow() {
      var canGoLeft = this.canGoLeft;
      if (!canGoLeft) {
        return null;
      }
      return /*#__PURE__*/React.createElement(LeftArrow, {
        onClick: this.handleLeftClick
      });
    }
  }, {
    key: "renderRightArrow",
    value: function renderRightArrow() {
      var canGoRight = this.canGoRight;
      if (!canGoRight) {
        return null;
      }
      return /*#__PURE__*/React.createElement(RightArrow, {
        onClick: this.handleRightClick
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.previousOffset = this.offset;
      window.addEventListener('resize', this.handleSizeChange);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var mutationObserver = this.mutationObserver;
      window.removeEventListener('resize', this.handleSizeChange);
      if (mutationObserver) {
        mutationObserver.disconnect();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this3 = this;
      this.previousOffset = this.offset;

      // trigger a "real" scroll event so lazily loaded cards realize they've been shown
      // note: we have to wait for the transition to end, otherwise the cards not visible when the scroll
      // event is triggered will be forever stuck in the loading screen (due to the lazy load)
      window.setTimeout(function () {
        return _this3.triggerScrollEvent();
      }, this.transitionDuration * 1000);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
        animate = _this$props.animate,
        children = _this$props.children,
        testId = _this$props.testId;
      var transform = "translateX(".concat(-this.offset, "px)");
      var transitionProperty = animate ? 'transform' : 'none';
      var transitionDuration = "".concat(this.transitionDuration, "s");
      return /*#__PURE__*/React.createElement(FilmStripViewWrapper, {
        "data-testid": testId
      }, this.renderLeftArrow(), /*#__PURE__*/React.createElement(FilmStripListWrapper, {
        ref: this.handleWindowElementChange,
        onWheel: this.handleScroll,
        onTouchStart: this.handleTouchStart,
        onTouchMove: this.handleTouchMove,
        onTouchEnd: this.handleTouchEnd,
        "data-testid": "filmstrip-list-wrapper"
      }, /*#__PURE__*/React.createElement(FilmStripList, {
        ref: this.handleBufferElementChange
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
        ,
        style: {
          transform: transform,
          transitionProperty: transitionProperty,
          transitionDuration: transitionDuration
        }
      }, React.Children.map(children, mapReactChildToReactNode))), this.renderRightArrow());
    }
  }]);
}(React.Component);
_defineProperty(FilmstripView, "defaultProps", {
  animate: false,
  offset: 0
});
function mapReactChildToReactNode(child, index) {
  var key = isReactElement(child) && child.key || index;
  return /*#__PURE__*/React.createElement(FilmStripListItem, {
    key: key,
    index: key
  }, child);
}
function isReactElement(child) {
  return !!child.type;
}