import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import debounce from 'debounce';
import { FilmStripList, FilmStripListItem, FilmStripListWrapper, FilmStripViewWrapper, LeftArrow, RightArrow } from './wrappers';
export { LeftArrow, RightArrow } from './wrappers';
const DURATION_MIN = 0.5;
const DURATION_MAX = 1.0;
const EXTRA_PADDING = 4;
export const MUTATION_CONFIG = {
  attributes: true,
  childList: true,
  subtree: true,
  characterData: true
};
export const MediaFilmStripListItemSelector = 'media-filmstrip-list-item';
export class FilmstripView extends React.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "previousOffset", 0);
    _defineProperty(this, "state", {
      bufferWidth: 0,
      windowWidth: 0,
      touchMoveStartPosition: 0,
      isTouchMoveInProgress: false
    });
    _defineProperty(this, "handleSizeChange", () => {
      // get the new widths
      const {
        windowElement,
        bufferElement
      } = this;
      let bufferWidth = 0;
      let windowWidth = 0;
      let childOffsets = [];
      if (windowElement && bufferElement) {
        bufferWidth = bufferElement.getBoundingClientRect().width;
        windowWidth = windowElement.getBoundingClientRect().width;

        // we're calculating `left` based on `width` because `rect.left` can be a negative value after resizing the window (considered scrolled??)
        const children = Array.prototype.slice.call(bufferElement.children, 0);
        let left = 0;
        childOffsets = children.map((child, index) => {
          const width = child.getBoundingClientRect().width;
          const offset = {
            left,
            right: left + width - 1
          };
          left += width;
          return offset;
        });
      }

      // make sure the state has changed before we update state and notify the integrator
      // (otherwise, since this method() is called in componentDidUpdate() we'll recurse until the stack size is exceeded)
      const {
        bufferWidth: prevBufferWidth,
        windowWidth: prevWindowWidth
      } = this.state;
      if (bufferWidth === prevBufferWidth && windowWidth === prevWindowWidth) {
        // NOTE: we're not checking here if childOffsets has changed... if the children change size but
        // result in the exact same size buffer, we're not going to update, resulting in incorrect navigations
        return;
      }

      // store the widths
      this.setState({
        bufferWidth,
        windowWidth
      }, () => {
        this.childOffsets = childOffsets;

        // notify the integrator
        const {
          onSize
        } = this.props;
        if (onSize) {
          onSize({
            offset: Math.min(this.maxOffset, this.offset),
            offsets: childOffsets,
            width: windowWidth,
            minOffset: this.minOffset,
            maxOffset: this.maxOffset
          });
        }
      });
    });
    _defineProperty(this, "handleWindowElementChange", windowElement => {
      this.windowElement = windowElement;
      this.handleSizeChange();
    });
    _defineProperty(this, "handleBufferElementChange", bufferElement => {
      if (!bufferElement) {
        return;
      }
      this.bufferElement = bufferElement;
      this.handleSizeChange();
      this.initMutationObserver();
    });
    _defineProperty(this, "handleMutation", mutationList => {
      // there are edge cases where the DOM may change outside of the normal React life-cycle
      // https://product-fabric.atlassian.net/browse/MSW-425
      this.handleSizeChange();
    });
    _defineProperty(this, "handleLeftClick", event => {
      // Stop the click event from bubling up and being handled by other components
      // See https://product-fabric.atlassian.net/browse/MSW-165
      event.stopPropagation();
      const {
        onScroll
      } = this.props;
      if (onScroll) {
        const {
          windowWidth
        } = this.state;
        let newOffset = this.getClosestForLeft(this.offset - windowWidth);
        if (newOffset >= this.offset) {
          // if for some reason we tried to scroll left but it didn't scroll or scrolls right instead (can happen when container is too narrow)
          // just try to scroll by the windowWidth
          newOffset = Math.max(this.offset - windowWidth, this.minOffset);
        }
        onScroll({
          direction: 'left',
          offset: newOffset,
          animate: true
        });
      }
    });
    _defineProperty(this, "handleRightClick", event => {
      // Stop the click event from bubling up and being handled by other components
      // See https://product-fabric.atlassian.net/browse/MSW-165
      event.stopPropagation();
      const {
        onScroll
      } = this.props;
      if (onScroll) {
        const {
          windowWidth
        } = this.state;
        let newOffset = this.getClosestForRight(this.offset + windowWidth);
        if (newOffset <= this.offset) {
          // if for some reason we tried to scroll right but it didn't scroll or scrolls left instead (can happen when container is too narrow)
          // just try to scroll by the windowWidth
          newOffset = Math.min(this.offset + windowWidth, this.maxOffset);
        }
        onScroll({
          direction: 'right',
          offset: newOffset,
          animate: true
        });
      }
    });
    _defineProperty(this, "handleScroll", event => {
      const isHorizontalScroll = Math.abs(event.deltaX) > Math.abs(event.deltaY);
      if (!isHorizontalScroll) {
        return;
      }

      // don't actually let the element scroll because we'll fake scrolling with `transform: translateX()`
      event.preventDefault();

      // notify the integrator of the offset change
      const {
        onScroll
      } = this.props;
      if (onScroll && isHorizontalScroll) {
        const newOffset = Math.max(this.minOffset, Math.min(this.maxOffset, this.offset + event.deltaX));
        onScroll({
          direction: event.deltaX < 0 ? 'left' : 'right',
          offset: newOffset,
          animate: false
        });
      }
    });
    _defineProperty(this, "handleTouchStart", event => {
      if (event.touches[0]) {
        this.setState({
          touchMoveStartPosition: event.touches[0].clientX,
          isTouchMoveInProgress: true
        });
      }
    });
    _defineProperty(this, "handleTouchEnd", event => {
      if (event.touches[0]) {
        this.setState({
          touchMoveStartPosition: event.touches[0].clientX,
          isTouchMoveInProgress: false
        });
      }
    });
    _defineProperty(this, "handleTouchMove", event => {
      const {
        onScroll
      } = this.props;
      if (this.state.isTouchMoveInProgress && onScroll) {
        const currentPosition = event.touches[0].clientX;
        const newOffset = this.state.touchMoveStartPosition ? this.offset - (currentPosition - this.state.touchMoveStartPosition) : this.offset;
        onScroll({
          direction: newOffset > this.offset ? 'left' : 'right',
          offset: newOffset,
          animate: false
        });
      }
    });
    this.childOffsets = [];
    try {
      this.mutationObserver = new MutationObserver(debounce(this.handleMutation, 30, true));
    } catch (e) {
      // in the case where we are running on an unsupported browser,
      // or where tests include the FilmstripView but do not mock the MutationObserver - we catch it and handle safely here.
      // NOTE: this won't effect the component, it just means mutations won't be observerd
    }
  }
  get offset() {
    const {
      offset
    } = this.props;
    if (!offset) {
      return 0;
    }
    return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
  }
  get minOffset() {
    return 0;
  }

  /**
   * The furthest we can scroll, where the end of the buffer is just in view
   */
  get maxOffset() {
    const {
      bufferWidth,
      windowWidth
    } = this.state;
    return Math.max(this.minOffset, bufferWidth - windowWidth - 1);
  }
  get canGoLeft() {
    return this.offset > this.minOffset;
  }
  get canGoRight() {
    return this.offset < this.maxOffset;
  }
  get transitionDuration() {
    const {
      animate
    } = this.props;
    const {
      windowWidth
    } = this.state;
    if (!animate) {
      return 0;
    }
    if (Math.abs(this.offset - this.previousOffset) < 1e-6) {
      return DURATION_MIN;
    } else {
      const diff = Math.abs(this.offset - this.previousOffset);
      const relativeOffset = diff / windowWidth;
      const duration = DURATION_MAX - DURATION_MIN * relativeOffset;
      return Math.max(Math.min(duration, DURATION_MAX), DURATION_MIN);
    }
  }
  initMutationObserver() {
    const {
      mutationObserver
    } = this;
    if (mutationObserver && this.bufferElement) {
      mutationObserver.disconnect();
      mutationObserver.observe(this.bufferElement, MUTATION_CONFIG);
    }
  }
  triggerScrollEvent() {
    if (!this.windowElement) {
      return;
    }
    const event = document.createEvent('MouseEvents');
    event.initEvent('scroll', true, true);
    this.windowElement.dispatchEvent(event);
  }

  // find the child that is cut off on the left edge of the window and change the window offset to
  // start to the left of that child
  getClosestForLeft(offset) {
    const leftWindowEdge = Math.min(this.maxOffset, Math.max(this.minOffset, offset));
    for (let i = 0; i < this.childOffsets.length; ++i) {
      const childBounds = this.childOffsets[i];
      if (leftWindowEdge >= childBounds.left && leftWindowEdge <= childBounds.right) {
        const newOffset = i === 0 ? childBounds.left : childBounds.right;
        if (newOffset >= EXTRA_PADDING) {
          return newOffset - EXTRA_PADDING; // show extra padding from the next sibling for aesthetic reasons
        } else {
          return newOffset;
        }
      }
    }
    return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
  }

  // find the child that is cut off on the right edge of the window and change the window offset
  // to finish at start of the next child
  getClosestForRight(offset) {
    const {
      windowWidth
    } = this.state;
    const rightWindowEdge = Math.min(this.maxOffset, Math.max(this.minOffset, offset)) + windowWidth;
    for (let i = 0; i < this.childOffsets.length; ++i) {
      const childBounds = this.childOffsets[i];
      if (rightWindowEdge >= childBounds.left && rightWindowEdge <= childBounds.right) {
        const newOffset = (i === this.childOffsets.length - 1 ? childBounds.right : childBounds.left) - windowWidth;
        if (newOffset + EXTRA_PADDING <= this.maxOffset) {
          return newOffset + EXTRA_PADDING; // show extra padding from the next sibling for aesthetic reasons
        } else {
          return newOffset;
        }
      }
    }
    return Math.min(this.maxOffset, Math.max(this.minOffset, offset));
  }
  renderLeftArrow() {
    const {
      canGoLeft
    } = this;
    if (!canGoLeft) {
      return null;
    }
    return /*#__PURE__*/React.createElement(LeftArrow, {
      onClick: this.handleLeftClick
    });
  }
  renderRightArrow() {
    const {
      canGoRight
    } = this;
    if (!canGoRight) {
      return null;
    }
    return /*#__PURE__*/React.createElement(RightArrow, {
      onClick: this.handleRightClick
    });
  }
  componentDidMount() {
    this.previousOffset = this.offset;
    window.addEventListener('resize', this.handleSizeChange);
  }
  componentWillUnmount() {
    const {
      mutationObserver
    } = this;
    window.removeEventListener('resize', this.handleSizeChange);
    if (mutationObserver) {
      mutationObserver.disconnect();
    }
  }
  componentDidUpdate() {
    this.previousOffset = this.offset;

    // trigger a "real" scroll event so lazily loaded cards realize they've been shown
    // note: we have to wait for the transition to end, otherwise the cards not visible when the scroll
    // event is triggered will be forever stuck in the loading screen (due to the lazy load)
    window.setTimeout(() => this.triggerScrollEvent(), this.transitionDuration * 1000);
  }
  render() {
    const {
      animate,
      children,
      testId
    } = this.props;
    const transform = `translateX(${-this.offset}px)`;
    const transitionProperty = animate ? 'transform' : 'none';
    const transitionDuration = `${this.transitionDuration}s`;
    return /*#__PURE__*/React.createElement(FilmStripViewWrapper, {
      "data-testid": testId
    }, this.renderLeftArrow(), /*#__PURE__*/React.createElement(FilmStripListWrapper, {
      ref: this.handleWindowElementChange,
      onWheel: this.handleScroll,
      onTouchStart: this.handleTouchStart,
      onTouchMove: this.handleTouchMove,
      onTouchEnd: this.handleTouchEnd,
      "data-testid": "filmstrip-list-wrapper"
    }, /*#__PURE__*/React.createElement(FilmStripList, {
      ref: this.handleBufferElementChange
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      ,
      style: {
        transform,
        transitionProperty,
        transitionDuration
      }
    }, React.Children.map(children, mapReactChildToReactNode))), this.renderRightArrow());
  }
}
_defineProperty(FilmstripView, "defaultProps", {
  animate: false,
  offset: 0
});
function mapReactChildToReactNode(child, index) {
  const key = isReactElement(child) && child.key || index;
  return /*#__PURE__*/React.createElement(FilmStripListItem, {
    key: key,
    index: key
  }, child);
}
function isReactElement(child) {
  return !!child.type;
}