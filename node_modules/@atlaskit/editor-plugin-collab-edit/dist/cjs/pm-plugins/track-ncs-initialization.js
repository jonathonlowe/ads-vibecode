"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackNCSInitializationPluginKey = exports.createPlugin = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _collab = require("@atlaskit/editor-common/collab");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _state = require("@atlaskit/editor-prosemirror/state");
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _utils = require("./utils");
var trackNCSInitializationPluginKey = exports.trackNCSInitializationPluginKey = new _state.PluginKey('collabTrackNCSInitializationPlugin');
var createPlugin = exports.createPlugin = function createPlugin() {
  return new _safePlugin.SafePlugin({
    key: trackNCSInitializationPluginKey,
    state: {
      init: function init() {
        return {
          collabInitialisedAt: null,
          firstChangeAfterInitAt: null,
          firstContentBodyChangeAfterInitAt: null
        };
      },
      apply: function apply(transaction, prevPluginState, oldState) {
        if (Boolean(transaction.getMeta('collabInitialised'))) {
          return {
            collabInitialisedAt: Date.now(),
            firstChangeAfterInitAt: null,
            firstContentBodyChangeAfterInitAt: null
          };
        }
        var shouldCheckDocument = prevPluginState.collabInitialisedAt && !prevPluginState.firstContentBodyChangeAfterInitAt;
        if (!shouldCheckDocument) {
          return prevPluginState;
        }
        var isRemote = (0, _utils.originalTransactionHasMeta)(transaction, 'isRemote');
        var isDocumentReplaceFromRemote = isRemote && (0, _utils.originalTransactionHasMeta)(transaction, 'replaceDocument');
        if (isDocumentReplaceFromRemote) {
          return prevPluginState;
        }
        if ((0, _collab.isDirtyTransaction)(transaction)) {
          return prevPluginState;
        }
        if (transaction.docChanged && !transaction.doc.eq(oldState.doc)) {
          // For analytics purposes, inline comment annotations are not considered as edits to the document body
          // Transaction may contain other steps, but we know that they won't be user-generated (non synthetic) steps
          // Additionally, for analytics purposes we do not want to trigger on other participants' changes (i.e. remote changes)
          var isAnnotationStep = !!transaction.steps.find(function (step) {
            var _step$mark;
            return step instanceof _transform.AddMarkStep && ((_step$mark = step.mark) === null || _step$mark === void 0 || (_step$mark = _step$mark.type) === null || _step$mark === void 0 ? void 0 : _step$mark.name) === 'annotation';
          });
          return {
            collabInitialisedAt: prevPluginState.collabInitialisedAt,
            firstChangeAfterInitAt: Date.now(),
            firstContentBodyChangeAfterInitAt: isAnnotationStep || isRemote ? prevPluginState.firstContentBodyChangeAfterInitAt : Date.now()
          };
        }
        return prevPluginState;
      }
    },
    props: {
      attributes: function attributes(editorState) {
        var trackPluginState = trackNCSInitializationPluginKey.getState(editorState);
        return (0, _defineProperty2.default)({}, 'data-has-collab-initialised', "".concat(Boolean(trackPluginState === null || trackPluginState === void 0 ? void 0 : trackPluginState.collabInitialisedAt)));
      }
    }
  });
};