"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerAllCustomSteps = exports.handleTelePointer = exports.handlePresence = exports.handleInit = exports.handleConnection = exports.getSendableSelection = exports.applyRemoteSteps = exports.applyRemoteData = void 0;
var allAdfSchemaSteps = _interopRequireWildcard(require("@atlaskit/adf-schema/steps"));
var allAtlaskitCustomSteps = _interopRequireWildcard(require("@atlaskit/custom-steps"));
var _state = require("@atlaskit/editor-prosemirror/state");
var _transform = require("@atlaskit/editor-prosemirror/transform");
var _prosemirrorCollab = require("@atlaskit/prosemirror-collab");
var _utils = require("./utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Ignored via go/ees005
// eslint-disable-next-line import/no-namespace

// Ignored via go/ees005
// eslint-disable-next-line import/no-namespace

/*
 * This is a non-op function to force ProseMirror to load and register all custom steps in the same bundle
 */
var registerAllCustomSteps = exports.registerAllCustomSteps = function registerAllCustomSteps() {
  Object.entries(allAtlaskitCustomSteps).forEach(function () {});
  Object.entries(allAdfSchemaSteps).forEach(function () {});
};
var handleInit = exports.handleInit = function handleInit(initData, view, options, editorAnalyticsApi) {
  var doc = initData.doc,
    json = initData.json,
    version = initData.version,
    reserveCursor = initData.reserveCursor;
  if (doc) {
    var state = view.state;
    var tr = (0, _utils.replaceDocument)(doc, state, version, options, reserveCursor, editorAnalyticsApi);
    tr.setMeta('isRemote', true);
    view.dispatch(tr);
  } else if (json) {
    applyRemoteSteps(json, view);
  }
};
var handleConnection = exports.handleConnection = function handleConnection(connectionData, view) {
  var tr = view.state.tr;
  view.dispatch(tr.setMeta('sessionId', connectionData));
};
var handlePresence = exports.handlePresence = function handlePresence(presenceData, view) {
  var tr = view.state.tr;
  view.dispatch(tr.setMeta('presence', presenceData));
};
var applyRemoteData = exports.applyRemoteData = function applyRemoteData(remoteData, view, options) {
  var json = remoteData.json,
    _remoteData$userIds = remoteData.userIds,
    userIds = _remoteData$userIds === void 0 ? [] : _remoteData$userIds;
  if (json) {
    applyRemoteSteps(json, view, userIds, options);
  }
};
var applyRemoteSteps = exports.applyRemoteSteps = function applyRemoteSteps(json, view, userIds, options) {
  if (!json || !json.length) {
    return;
  }
  var state = view.state,
    schema = view.state.schema;
  var steps = json.map(function (step) {
    return _transform.Step.fromJSON(schema, step);
  });
  var tr;
  if (options && options.useNativePlugin && userIds) {
    tr = (0, _prosemirrorCollab.receiveTransaction)(state, steps, userIds, {
      mapSelectionBackward: true
    });
  } else {
    tr = state.tr;
    steps.forEach(function (step) {
      return tr.step(step);
    });
  }
  if (tr) {
    tr.setMeta('addToHistory', false);
    tr.setMeta('isRemote', true);

    /*
     * Persist marks across transactions. Fixes an issue where
     * marks are lost if remote transactions are dispatched
     * between a user creating the mark and typing.
     */
    if (state.tr.storedMarks) {
      tr.setStoredMarks(state.tr.storedMarks);
    }
    view.dispatch(tr);
  }
};
var handleTelePointer = exports.handleTelePointer = function handleTelePointer(telepointerData, view) {
  var tr = view.state.tr;
  view.dispatch(tr.setMeta('telepointer', telepointerData));
};
function isAllSelection(selection) {
  return selection instanceof _state.AllSelection;
}
function isNodeSelection(selection) {
  return selection instanceof _state.NodeSelection;
}
var getSendableSelection = exports.getSendableSelection = function getSendableSelection(selection) {
  /**
   * <kbd>CMD + A</kbd> triggers a AllSelection
   * <kbd>escape</kbd> triggers a NodeSelection
   */
  return {
    type: 'textSelection',
    anchor: selection.anchor,
    head: isAllSelection(selection) || isNodeSelection(selection) ? selection.head - 1 : selection.head
  };
};