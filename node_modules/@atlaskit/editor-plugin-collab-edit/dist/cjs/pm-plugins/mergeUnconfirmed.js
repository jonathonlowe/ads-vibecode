"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeUnconfirmedSteps = mergeUnconfirmedSteps;
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _state = require("@atlaskit/editor-prosemirror/state");
// Based on: `packages/editor/prosemirror-collab/src/index.ts`
var LockableRebaseable = /*#__PURE__*/(0, _createClass2.default)(function LockableRebaseable(step, inverted, origin) {
  (0, _classCallCheck2.default)(this, LockableRebaseable);
  this.step = step;
  this.inverted = inverted;
  this.origin = origin;
});
var isLocked = function isLocked(step) {
  if (step.origin instanceof _state.Transaction) {
    return step.origin.getMeta('mergeIsLocked');
  }
  return false;
};

/**
 * Merge a set of steps together to reduce the total number of steps stored in memory.
 *
 * All steps passing through here should be "lockable" (ie. can be locked by the document service)
 * so that it can be indicated they have already been sent (or are about to be sent) to the backend
 * and cannot be merged.
 *
 * @param steps Rebaseable steps
 * @returns Rebaseable steps
 */
function mergeUnconfirmedSteps(steps, api) {
  var mergedSteps = steps.reduce(function (acc, rebaseable) {
    var _api$connectivity;
    var lastStep = acc[acc.length - 1];
    var isOffline = (api === null || api === void 0 || (_api$connectivity = api.connectivity) === null || _api$connectivity === void 0 || (_api$connectivity = _api$connectivity.sharedState.currentState()) === null || _api$connectivity === void 0 ? void 0 : _api$connectivity.mode) === 'offline';
    if (isOffline && lastStep && !isLocked(lastStep) && !isLocked(rebaseable)) {
      var mergedStep = lastStep.step.merge(rebaseable.step);
      var _inverted = rebaseable.inverted.merge(lastStep.inverted);
      // Always take the origin of the new step.
      // We use this in packages/editor/collab-provider/src/document/document-service.ts:commitUnconfirmedSteps
      // to confirm that the last transaction has been sent. Since we're taking the latest this still works as expected
      // As we want to wait until all the transactions have been pushed through
      var _origin = lastStep.origin;
      if (mergedStep && _inverted) {
        acc[acc.length - 1] = new LockableRebaseable(mergedStep, _inverted, _origin instanceof _state.Transaction ? _origin.setMeta('isOffline', isOffline) : _origin);
        return acc;
      }
    }
    return acc.concat(new LockableRebaseable(rebaseable.step, rebaseable.inverted, rebaseable.origin instanceof _state.Transaction ? rebaseable.origin.setMeta('isOffline', rebaseable.origin.getMeta('isOffline') === true || isOffline) : rebaseable.origin));
  }, []);
  return mergedSteps;
}