import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { isDirtyTransaction } from '@atlaskit/editor-common/collab';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { PluginKey } from '@atlaskit/editor-prosemirror/state';
import { AddMarkStep } from '@atlaskit/editor-prosemirror/transform';
import { originalTransactionHasMeta } from './utils';
export var trackNCSInitializationPluginKey = new PluginKey('collabTrackNCSInitializationPlugin');
export var createPlugin = function createPlugin() {
  return new SafePlugin({
    key: trackNCSInitializationPluginKey,
    state: {
      init: function init() {
        return {
          collabInitialisedAt: null,
          firstChangeAfterInitAt: null,
          firstContentBodyChangeAfterInitAt: null
        };
      },
      apply: function apply(transaction, prevPluginState, oldState) {
        if (Boolean(transaction.getMeta('collabInitialised'))) {
          return {
            collabInitialisedAt: Date.now(),
            firstChangeAfterInitAt: null,
            firstContentBodyChangeAfterInitAt: null
          };
        }
        var shouldCheckDocument = prevPluginState.collabInitialisedAt && !prevPluginState.firstContentBodyChangeAfterInitAt;
        if (!shouldCheckDocument) {
          return prevPluginState;
        }
        var isRemote = originalTransactionHasMeta(transaction, 'isRemote');
        var isDocumentReplaceFromRemote = isRemote && originalTransactionHasMeta(transaction, 'replaceDocument');
        if (isDocumentReplaceFromRemote) {
          return prevPluginState;
        }
        if (isDirtyTransaction(transaction)) {
          return prevPluginState;
        }
        if (transaction.docChanged && !transaction.doc.eq(oldState.doc)) {
          // For analytics purposes, inline comment annotations are not considered as edits to the document body
          // Transaction may contain other steps, but we know that they won't be user-generated (non synthetic) steps
          // Additionally, for analytics purposes we do not want to trigger on other participants' changes (i.e. remote changes)
          var isAnnotationStep = !!transaction.steps.find(function (step) {
            var _step$mark;
            return step instanceof AddMarkStep && ((_step$mark = step.mark) === null || _step$mark === void 0 || (_step$mark = _step$mark.type) === null || _step$mark === void 0 ? void 0 : _step$mark.name) === 'annotation';
          });
          return {
            collabInitialisedAt: prevPluginState.collabInitialisedAt,
            firstChangeAfterInitAt: Date.now(),
            firstContentBodyChangeAfterInitAt: isAnnotationStep || isRemote ? prevPluginState.firstContentBodyChangeAfterInitAt : Date.now()
          };
        }
        return prevPluginState;
      }
    },
    props: {
      attributes: function attributes(editorState) {
        var trackPluginState = trackNCSInitializationPluginKey.getState(editorState);
        return _defineProperty({}, 'data-has-collab-initialised', "".concat(Boolean(trackPluginState === null || trackPluginState === void 0 ? void 0 : trackPluginState.collabInitialisedAt)));
      }
    }
  });
};