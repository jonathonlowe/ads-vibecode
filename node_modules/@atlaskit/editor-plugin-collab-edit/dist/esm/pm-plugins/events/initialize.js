import memoizeOne from 'memoize-one';
import { Step } from '@atlaskit/editor-prosemirror/transform';
import { pluginKey } from '../main/plugin-key';
import { subscribe } from './handlers';
var initCollab = function initCollab(collabEditProvider, view) {
  if (collabEditProvider.initialize) {
    collabEditProvider.initialize(function () {
      return view.state;
    }, function (json) {
      return Step.fromJSON(view.state.schema, json);
    });
  }
};
var initNewCollab = function initNewCollab(collabEditProvider, view, editorApi, onSyncUpError) {
  collabEditProvider.setup({
    getState: function getState() {
      return view.state;
    },
    editorApi: editorApi,
    onSyncUpError: onSyncUpError
  });
};
var initCollabMemo = memoizeOne(initCollab);
export var initialize = function initialize(_ref) {
  var options = _ref.options,
    providerFactory = _ref.providerFactory,
    view = _ref.view,
    featureFlags = _ref.featureFlags,
    editorAnalyticsApi = _ref.editorAnalyticsApi,
    pluginInjectionApi = _ref.pluginInjectionApi;
  return function (provider) {
    // eslint-disable-next-line prefer-const
    var cleanup;
    var pluginState = pluginKey.getState(view.state);
    if (pluginState !== null && pluginState !== void 0 && pluginState.isReady && cleanup) {
      cleanup();
    }
    cleanup = subscribe(view, provider, options, featureFlags, providerFactory, editorAnalyticsApi);

    // Initialize provider
    if (options.useNativePlugin) {
      // ED-13912 For NCS we don't want to use memoizeOne because it causes
      // infinite text while changing page-width
      initNewCollab(provider, view, pluginInjectionApi, options.onSyncUpError);
    } else {
      /**
       * We only want to initialise once, if we reload/reconfigure this plugin
       * We dont want to re-init collab, it would break existing sessions
       */
      initCollabMemo(provider, view);
    }
    return cleanup;
  };
};