import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import { Transaction } from '@atlaskit/editor-prosemirror/state';
// Based on: `packages/editor/prosemirror-collab/src/index.ts`
var LockableRebaseable = /*#__PURE__*/_createClass(function LockableRebaseable(step, inverted, origin) {
  _classCallCheck(this, LockableRebaseable);
  this.step = step;
  this.inverted = inverted;
  this.origin = origin;
});
var isLocked = function isLocked(step) {
  if (step.origin instanceof Transaction) {
    return step.origin.getMeta('mergeIsLocked');
  }
  return false;
};

/**
 * Merge a set of steps together to reduce the total number of steps stored in memory.
 *
 * All steps passing through here should be "lockable" (ie. can be locked by the document service)
 * so that it can be indicated they have already been sent (or are about to be sent) to the backend
 * and cannot be merged.
 *
 * @param steps Rebaseable steps
 * @returns Rebaseable steps
 */
export function mergeUnconfirmedSteps(steps, api) {
  var mergedSteps = steps.reduce(function (acc, rebaseable) {
    var _api$connectivity;
    var lastStep = acc[acc.length - 1];
    var isOffline = (api === null || api === void 0 || (_api$connectivity = api.connectivity) === null || _api$connectivity === void 0 || (_api$connectivity = _api$connectivity.sharedState.currentState()) === null || _api$connectivity === void 0 ? void 0 : _api$connectivity.mode) === 'offline';
    if (isOffline && lastStep && !isLocked(lastStep) && !isLocked(rebaseable)) {
      var mergedStep = lastStep.step.merge(rebaseable.step);
      var _inverted = rebaseable.inverted.merge(lastStep.inverted);
      // Always take the origin of the new step.
      // We use this in packages/editor/collab-provider/src/document/document-service.ts:commitUnconfirmedSteps
      // to confirm that the last transaction has been sent. Since we're taking the latest this still works as expected
      // As we want to wait until all the transactions have been pushed through
      var _origin = lastStep.origin;
      if (mergedStep && _inverted) {
        acc[acc.length - 1] = new LockableRebaseable(mergedStep, _inverted, _origin instanceof Transaction ? _origin.setMeta('isOffline', isOffline) : _origin);
        return acc;
      }
    }
    return acc.concat(new LockableRebaseable(rebaseable.step, rebaseable.inverted, rebaseable.origin instanceof Transaction ? rebaseable.origin.setMeta('isOffline', rebaseable.origin.getMeta('isOffline') === true || isOffline) : rebaseable.origin));
  }, []);
  return mergedSteps;
}