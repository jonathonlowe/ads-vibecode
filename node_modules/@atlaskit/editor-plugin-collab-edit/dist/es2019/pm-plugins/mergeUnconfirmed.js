import { Transaction } from '@atlaskit/editor-prosemirror/state';
// Based on: `packages/editor/prosemirror-collab/src/index.ts`
class LockableRebaseable {
  constructor(step, inverted, origin) {
    this.step = step;
    this.inverted = inverted;
    this.origin = origin;
  }
}
const isLocked = step => {
  if (step.origin instanceof Transaction) {
    return step.origin.getMeta('mergeIsLocked');
  }
  return false;
};

/**
 * Merge a set of steps together to reduce the total number of steps stored in memory.
 *
 * All steps passing through here should be "lockable" (ie. can be locked by the document service)
 * so that it can be indicated they have already been sent (or are about to be sent) to the backend
 * and cannot be merged.
 *
 * @param steps Rebaseable steps
 * @returns Rebaseable steps
 */
export function mergeUnconfirmedSteps(steps, api) {
  const mergedSteps = steps.reduce((acc, rebaseable) => {
    var _api$connectivity, _api$connectivity$sha;
    const lastStep = acc[acc.length - 1];
    const isOffline = (api === null || api === void 0 ? void 0 : (_api$connectivity = api.connectivity) === null || _api$connectivity === void 0 ? void 0 : (_api$connectivity$sha = _api$connectivity.sharedState.currentState()) === null || _api$connectivity$sha === void 0 ? void 0 : _api$connectivity$sha.mode) === 'offline';
    if (isOffline && lastStep && !isLocked(lastStep) && !isLocked(rebaseable)) {
      const mergedStep = lastStep.step.merge(rebaseable.step);
      const inverted = rebaseable.inverted.merge(lastStep.inverted);
      // Always take the origin of the new step.
      // We use this in packages/editor/collab-provider/src/document/document-service.ts:commitUnconfirmedSteps
      // to confirm that the last transaction has been sent. Since we're taking the latest this still works as expected
      // As we want to wait until all the transactions have been pushed through
      const origin = lastStep.origin;
      if (mergedStep && inverted) {
        acc[acc.length - 1] = new LockableRebaseable(mergedStep, inverted, origin instanceof Transaction ? origin.setMeta('isOffline', isOffline) : origin);
        return acc;
      }
    }
    return acc.concat(new LockableRebaseable(rebaseable.step, rebaseable.inverted, rebaseable.origin instanceof Transaction ? rebaseable.origin.setMeta('isOffline', rebaseable.origin.getMeta('isOffline') === true || isOffline) : rebaseable.origin));
  }, []);
  return mergedSteps;
}