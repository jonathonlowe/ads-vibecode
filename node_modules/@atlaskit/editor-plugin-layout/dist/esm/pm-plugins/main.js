import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { createSelectionClickHandler } from '@atlaskit/editor-common/selection';
import { filterCommand as filter } from '@atlaskit/editor-common/utils';
import { keydownHandler } from '@atlaskit/editor-prosemirror/keymap';
import { Fragment } from '@atlaskit/editor-prosemirror/model';
import { NodeSelection, Selection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeClosestToPos, findParentNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { fixColumnSizes, fixColumnStructure, getSelectedLayout } from './actions';
import { EVEN_DISTRIBUTED_COL_WIDTHS } from './consts';
import { pluginKey } from './plugin-key';
import { getMaybeLayoutSection } from './utils';
export var DEFAULT_LAYOUT = 'two_equal';
var isWholeSelectionInsideLayoutColumn = function isWholeSelectionInsideLayoutColumn(state) {
  // Since findParentNodeOfType doesn't check if selection.to shares the parent, we do this check ourselves
  var fromParent = findParentNodeOfType(state.schema.nodes.layoutColumn)(state.selection);
  if (fromParent) {
    var isToPosInsideSameLayoutColumn = state.selection.from < fromParent.pos + fromParent.node.nodeSize;
    return isToPosInsideSameLayoutColumn;
  }
  return false;
};
var moveCursorToNextColumn = function moveCursorToNextColumn(state, dispatch) {
  var selection = state.selection;
  var _state$schema$nodes = state.schema.nodes,
    layoutColumn = _state$schema$nodes.layoutColumn,
    layoutSection = _state$schema$nodes.layoutSection;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var section = findParentNodeOfType(layoutSection)(selection);
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var column = findParentNodeOfType(layoutColumn)(selection);
  if (column.node !== section.node.lastChild) {
    var $nextColumn = state.doc.resolve(column.pos + column.node.nodeSize);
    var shiftedSelection = TextSelection.findFrom($nextColumn, 1);
    if (dispatch) {
      dispatch(state.tr.setSelection(shiftedSelection));
    }
  }
  return true;
};
var getNodeDecoration = function getNodeDecoration(pos, node) {
  return [Decoration.node(pos, pos + node.nodeSize, {
    class: 'selected'
  })];
};
var getInitialPluginState = function getInitialPluginState(options, state) {
  var maybeLayoutSection = getMaybeLayoutSection(state);
  var allowBreakout = options.allowBreakout || false;
  var addSidebarLayouts = options.UNSAFE_addSidebarLayouts || false;
  var allowSingleColumnLayout = options.UNSAFE_allowSingleColumnLayout || false;
  var pos = maybeLayoutSection ? maybeLayoutSection.pos : null;
  var selectedLayout = getSelectedLayout(maybeLayoutSection && maybeLayoutSection.node, DEFAULT_LAYOUT);
  return {
    pos: pos,
    allowBreakout: allowBreakout,
    addSidebarLayouts: addSidebarLayouts,
    selectedLayout: selectedLayout,
    allowSingleColumnLayout: allowSingleColumnLayout,
    isResizing: false
  };
};

// To prevent a single-column layout,
// if a user attempts to delete a layout column and
// we will force remove the content instead.
// There are some edge cases where user can delete a layout column
// see packages/editor/editor-plugin-layout-tests/src/__tests__/unit/delete.ts
var handleDeleteLayoutColumn = function handleDeleteLayoutColumn(state, dispatch) {
  var sel = state.selection;
  if (sel instanceof NodeSelection && sel.node.type.name === 'layoutColumn' && sel.$from.parent.type.name === 'layoutSection' && sel.$from.parent.childCount === 2 && dispatch && editorExperiment('advanced_layouts', true) && !editorExperiment('single_column_layouts', true)) {
    var _sel$$from$parent$las, _sel$$from$parent$fir;
    var tr = state.tr;
    var layoutContentFragment = sel.$from.parentOffset === 0 ? Fragment.from((_sel$$from$parent$las = sel.$from.parent.lastChild) === null || _sel$$from$parent$las === void 0 ? void 0 : _sel$$from$parent$las.content) : Fragment.from((_sel$$from$parent$fir = sel.$from.parent.firstChild) === null || _sel$$from$parent$fir === void 0 ? void 0 : _sel$$from$parent$fir.content);
    var parent = findParentNodeClosestToPos(sel.$from, function (node) {
      return node.type.name === 'layoutSection';
    });
    if (parent) {
      var layoutSectionPos = tr.mapping.map(parent.pos);
      var layoutSectionNodeSize = parent.node.nodeSize;
      dispatch(state.tr.replaceWith(layoutSectionPos, layoutSectionPos + layoutSectionNodeSize, layoutContentFragment));
      return true;
    }
    return false;
  }
  return false;
};
export default (function (options) {
  return new SafePlugin({
    key: pluginKey,
    state: {
      init: function init(_, state) {
        return getInitialPluginState(options, state);
      },
      apply: function apply(tr, pluginState, oldState, newState) {
        var _tr$getMeta, _pluginKey$getState;
        var isResizing = editorExperiment('single_column_layouts', true) ? (_tr$getMeta = tr.getMeta('is-resizer-resizing')) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : (_pluginKey$getState = pluginKey.getState(oldState)) === null || _pluginKey$getState === void 0 ? void 0 : _pluginKey$getState.isResizing : false;
        if (tr.docChanged || tr.selectionSet) {
          var maybeLayoutSection = getMaybeLayoutSection(newState);
          var newPluginState = _objectSpread(_objectSpread({}, pluginState), {}, {
            pos: maybeLayoutSection ? maybeLayoutSection.pos : null,
            isResizing: isResizing,
            selectedLayout: getSelectedLayout(maybeLayoutSection && maybeLayoutSection.node,
            // Ignored via go/ees005
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            pluginState.selectedLayout)
          });
          return newPluginState;
        }
        return _objectSpread(_objectSpread({}, pluginState), {}, {
          isResizing: isResizing
        });
      }
    },
    props: {
      decorations: function decorations(state) {
        var layoutState = pluginKey.getState(state);
        if (layoutState.pos !== null) {
          return DecorationSet.create(state.doc, getNodeDecoration(layoutState.pos, state.doc.nodeAt(layoutState.pos)));
        }
        return undefined;
      },
      handleKeyDown: keydownHandler({
        Tab: filter(isWholeSelectionInsideLayoutColumn, moveCursorToNextColumn),
        'Mod-Backspace': handleDeleteLayoutColumn,
        'Mod-Delete': handleDeleteLayoutColumn,
        Backspace: handleDeleteLayoutColumn,
        Delete: handleDeleteLayoutColumn
      }),
      handleClickOn: createSelectionClickHandler(['layoutColumn'], function (target) {
        return target.hasAttribute('data-layout-section') || target.hasAttribute('data-layout-column');
      }, {
        useLongPressSelection: options.useLongPressSelection || false,
        getNodeSelectionPos: function getNodeSelectionPos(state, nodePos) {
          return state.doc.resolve(nodePos).before();
        }
      })
    },
    appendTransaction: function appendTransaction(transactions, _oldState, newState) {
      var changes = [];
      transactions.forEach(function (prevTr) {
        // remap change segments across the transaction set
        changes.forEach(function (change) {
          return {
            from: prevTr.mapping.map(change.from),
            to: prevTr.mapping.map(change.to),
            slice: change.slice
          };
        });

        // don't consider transactions that don't mutate
        if (!prevTr.docChanged) {
          return;
        }
        var change = fixColumnSizes(prevTr, newState);
        if (change) {
          changes.push(change);
        }
      });
      if (editorExperiment('advanced_layouts', true) && changes.length === 1) {
        var _change$slice$content, _change$slice$content2;
        var change = changes[0];
        // When editorExperiment('single_column_layouts', true) is on
        // delete can create a single column layout
        // otherwise we replace the single column layout with its content
        if (!editorExperiment('single_column_layouts', true) && change.slice.content.childCount === 1 && ((_change$slice$content = change.slice.content.firstChild) === null || _change$slice$content === void 0 ? void 0 : _change$slice$content.type.name) === 'layoutColumn' && ((_change$slice$content2 = change.slice.content.firstChild) === null || _change$slice$content2 === void 0 ? void 0 : _change$slice$content2.attrs.width) === EVEN_DISTRIBUTED_COL_WIDTHS[1]) {
          var tr = newState.tr;
          var content = change.slice.content.firstChild.content;
          tr.replaceWith(change.from - 1, change.to, content);
          return tr;
        }
      }
      if (changes.length) {
        var _tr = newState.tr;
        var selection = newState.selection.toJSON();
        changes.forEach(function (change) {
          _tr.replaceRange(change.from, change.to, change.slice);
        });

        // selecting and deleting across columns in 3 col layouts can remove
        // a layoutColumn so we fix the structure here
        _tr = fixColumnStructure(newState) || _tr;
        if (_tr.docChanged) {
          _tr.setSelection(Selection.fromJSON(_tr.doc, selection));
          return _tr;
        }
      }
      return;
    }
  });
});