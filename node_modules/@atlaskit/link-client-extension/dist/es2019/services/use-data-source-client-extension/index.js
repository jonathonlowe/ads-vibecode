import { useCallback, useMemo } from 'react';
import { LRUMap } from 'lru_map';
import { useSmartLinkContext } from '@atlaskit/link-provider';
import { request } from '@atlaskit/linking-common';
import { useResolverUrl } from '../use-resolver-url';
const URL_RESPONSE_CACHE_SIZE = 50;
export const datasourceDetailsResponsePromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export const datasourceDataResponsePromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export const datasourceActionsPermissionsPromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export const DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE = 20;
export const useDatasourceClientExtension = () => {
  const {
    connections: {
      client
    }
  } = useSmartLinkContext();
  const resolverUrl = useResolverUrl(client);
  const cachedRequest = async (cacheKeyId, data, url, lruMap, force) => {
    var _Intl;
    const cacheKeyData = {
      ...data,
      // Sort fields to use cached version of response regardless of the order
      ...('fields' in data ? {
        fields: [...(data.fields || [])].sort()
      } : {}),
      ...('fieldKeys' in data ? {
        fieldKeys: [...(data.fieldKeys || [])].sort()
      } : {})
    };
    const cacheKey = JSON.stringify({
      cacheKeyId,
      cacheKeyData
    });
    if (force) {
      lruMap.delete(cacheKey);
    }
    let responsePromise = lruMap.get(cacheKey);
    if (responsePromise) {
      return responsePromise;
    }
    const headers = {
      /**
       * This header exists to enable the backend to process relative time, eg: "today", with respect to user timezone.
       * eg: used in "confluence-object-provider" to process confluence SLLV requests to filter data for relative time.
       */
      'origin-timezone': (_Intl = Intl) === null || _Intl === void 0 ? void 0 : _Intl.DateTimeFormat().resolvedOptions().timeZone
    };
    try {
      responsePromise = request('post', url, data, headers, [200, 201, 202, 203, 204]);
      lruMap.set(cacheKey, responsePromise);
      return await responsePromise;
    } catch (e) {
      lruMap.delete(cacheKey);
      throw e;
    }
  };
  const uncachedRequest = async (data, url) => {
    const responsePromise = request('post', url, data, undefined, [200, 201, 202, 203, 204]);
    return responsePromise;
  };
  const getDatasourceDetails = useCallback(async (datasourceId, data, force = false) => cachedRequest(datasourceId, data, `${resolverUrl}/datasource/${datasourceId}/fetch/details`, datasourceDetailsResponsePromiseCache, force), [resolverUrl]);
  const getDatasourceData = useCallback(async (datasourceId, data, force = false) => cachedRequest(datasourceId, data, `${resolverUrl}/datasource/${datasourceId}/fetch/data`, datasourceDataResponsePromiseCache, force), [resolverUrl]);
  const getDatasourceActionsAndPermissions = useCallback(async (data, force = false) => {
    const resolvedCacheIdKey = 'datasourceId' in data ? data.datasourceId : data.integrationKey;
    // This is just to prevent empty string being passed up to ORS and causing issues.
    if (!resolvedCacheIdKey) {
      throw new Error('No target was supplied to retrieve actions for');
    }
    return cachedRequest(resolvedCacheIdKey, data, `${resolverUrl}/actions`, datasourceActionsPermissionsPromiseCache, force);
  }, [resolverUrl]);
  const executeAtomicAction = useCallback(async data => uncachedRequest(data, `${resolverUrl}/actions/execute`), [resolverUrl]);
  const invalidateDatasourceDataCacheByAri = useCallback(ari => {
    datasourceDataResponsePromiseCache.forEach(async (value, key) => {
      const response = await value;
      const targetFound = response.data.items.some(item => {
        var _item$ari;
        return ((_item$ari = item['ari']) === null || _item$ari === void 0 ? void 0 : _item$ari.data) === ari;
      });
      if (targetFound) {
        datasourceDataResponsePromiseCache.delete(key);
      }
    });
  }, []);
  return useMemo(() => ({
    getDatasourceDetails,
    getDatasourceData,
    getDatasourceActionsAndPermissions,
    executeAtomicAction,
    invalidateDatasourceDataCacheByAri
  }), [getDatasourceDetails, getDatasourceData, getDatasourceActionsAndPermissions, executeAtomicAction, invalidateDatasourceDataCacheByAri]);
};