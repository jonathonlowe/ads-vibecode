import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useCallback, useMemo } from 'react';
import { LRUMap } from 'lru_map';
import { useSmartLinkContext } from '@atlaskit/link-provider';
import { request } from '@atlaskit/linking-common';
import { useResolverUrl } from '../use-resolver-url';
var URL_RESPONSE_CACHE_SIZE = 50;
export var datasourceDetailsResponsePromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export var datasourceDataResponsePromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export var datasourceActionsPermissionsPromiseCache = new LRUMap(URL_RESPONSE_CACHE_SIZE);
export var DEFAULT_GET_DATASOURCE_DATA_PAGE_SIZE = 20;
export var useDatasourceClientExtension = function useDatasourceClientExtension() {
  var _useSmartLinkContext = useSmartLinkContext(),
    client = _useSmartLinkContext.connections.client;
  var resolverUrl = useResolverUrl(client);
  var cachedRequest = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cacheKeyId, data, url, lruMap, force) {
      var _Intl;
      var cacheKeyData, cacheKey, responsePromise, headers;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            cacheKeyData = _objectSpread(_objectSpread(_objectSpread({}, data), 'fields' in data ? {
              fields: _toConsumableArray(data.fields || []).sort()
            } : {}), 'fieldKeys' in data ? {
              fieldKeys: _toConsumableArray(data.fieldKeys || []).sort()
            } : {});
            cacheKey = JSON.stringify({
              cacheKeyId: cacheKeyId,
              cacheKeyData: cacheKeyData
            });
            if (force) {
              lruMap.delete(cacheKey);
            }
            responsePromise = lruMap.get(cacheKey);
            if (!responsePromise) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", responsePromise);
          case 6:
            headers = {
              /**
               * This header exists to enable the backend to process relative time, eg: "today", with respect to user timezone.
               * eg: used in "confluence-object-provider" to process confluence SLLV requests to filter data for relative time.
               */
              'origin-timezone': (_Intl = Intl) === null || _Intl === void 0 ? void 0 : _Intl.DateTimeFormat().resolvedOptions().timeZone
            };
            _context.prev = 7;
            responsePromise = request('post', url, data, headers, [200, 201, 202, 203, 204]);
            lruMap.set(cacheKey, responsePromise);
            _context.next = 12;
            return responsePromise;
          case 12:
            return _context.abrupt("return", _context.sent);
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](7);
            lruMap.delete(cacheKey);
            throw _context.t0;
          case 19:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[7, 15]]);
    }));
    return function cachedRequest(_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  var uncachedRequest = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data, url) {
      var responsePromise;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            responsePromise = request('post', url, data, undefined, [200, 201, 202, 203, 204]);
            return _context2.abrupt("return", responsePromise);
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function uncachedRequest(_x6, _x7) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getDatasourceDetails = useCallback( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(datasourceId, data) {
      var force,
        _args3 = arguments;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            force = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;
            return _context3.abrupt("return", cachedRequest(datasourceId, data, "".concat(resolverUrl, "/datasource/").concat(datasourceId, "/fetch/details"), datasourceDetailsResponsePromiseCache, force));
          case 2:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function (_x8, _x9) {
      return _ref3.apply(this, arguments);
    };
  }(), [resolverUrl]);
  var getDatasourceData = useCallback( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(datasourceId, data) {
      var force,
        _args4 = arguments;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            force = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : false;
            return _context4.abrupt("return", cachedRequest(datasourceId, data, "".concat(resolverUrl, "/datasource/").concat(datasourceId, "/fetch/data"), datasourceDataResponsePromiseCache, force));
          case 2:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function (_x10, _x11) {
      return _ref4.apply(this, arguments);
    };
  }(), [resolverUrl]);
  var getDatasourceActionsAndPermissions = useCallback( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data) {
      var force,
        resolvedCacheIdKey,
        _args5 = arguments;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            force = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
            resolvedCacheIdKey = 'datasourceId' in data ? data.datasourceId : data.integrationKey; // This is just to prevent empty string being passed up to ORS and causing issues.
            if (resolvedCacheIdKey) {
              _context5.next = 4;
              break;
            }
            throw new Error('No target was supplied to retrieve actions for');
          case 4:
            return _context5.abrupt("return", cachedRequest(resolvedCacheIdKey, data, "".concat(resolverUrl, "/actions"), datasourceActionsPermissionsPromiseCache, force));
          case 5:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return function (_x12) {
      return _ref5.apply(this, arguments);
    };
  }(), [resolverUrl]);
  var executeAtomicAction = useCallback( /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(data) {
      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", uncachedRequest(data, "".concat(resolverUrl, "/actions/execute")));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    return function (_x13) {
      return _ref6.apply(this, arguments);
    };
  }(), [resolverUrl]);
  var invalidateDatasourceDataCacheByAri = useCallback(function (ari) {
    datasourceDataResponsePromiseCache.forEach( /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(value, key) {
        var response, targetFound;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return value;
            case 2:
              response = _context7.sent;
              targetFound = response.data.items.some(function (item) {
                var _item$ari;
                return ((_item$ari = item['ari']) === null || _item$ari === void 0 ? void 0 : _item$ari.data) === ari;
              });
              if (targetFound) {
                datasourceDataResponsePromiseCache.delete(key);
              }
            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      return function (_x14, _x15) {
        return _ref7.apply(this, arguments);
      };
    }());
  }, []);
  return useMemo(function () {
    return {
      getDatasourceDetails: getDatasourceDetails,
      getDatasourceData: getDatasourceData,
      getDatasourceActionsAndPermissions: getDatasourceActionsAndPermissions,
      executeAtomicAction: executeAtomicAction,
      invalidateDatasourceDataCacheByAri: invalidateDatasourceDataCacheByAri
    };
  }, [getDatasourceDetails, getDatasourceData, getDatasourceActionsAndPermissions, executeAtomicAction, invalidateDatasourceDataCacheByAri]);
};