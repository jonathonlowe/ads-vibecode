import React, { useLayoutEffect, useState } from 'react';
import { TRIGGER_METHOD } from '@atlaskit/editor-common/analytics';
import { blur, toggleMatchCase } from '../pm-plugins/commands';
import { activateWithAnalytics, cancelSearchWithAnalytics, findNextWithAnalytics, findPrevWithAnalytics, findWithAnalytics, replaceAllWithAnalytics, replaceWithAnalytics } from '../pm-plugins/commands-with-analytics';
import FindReplaceDropdown from './FindReplaceDropdown';
import FindReplaceToolbarButton from './FindReplaceToolbarButton';

// light implementation of useSharedPluginState(). This is due to findreplace
// being the only plugin that previously used WithPluginState with
// debounce=false. That was implemented because of text sync issues
// between editor & findreplace dialog.
// To address under ENGHEALTH-5853
const useSharedPluginStateNoDebounce = api => {
  var _api$findReplace;
  const [state, setState] = useState(api === null || api === void 0 ? void 0 : (_api$findReplace = api.findReplace) === null || _api$findReplace === void 0 ? void 0 : _api$findReplace.sharedState.currentState());
  useLayoutEffect(() => {
    var _api$findReplace2;
    const unsub = api === null || api === void 0 ? void 0 : (_api$findReplace2 = api.findReplace) === null || _api$findReplace2 === void 0 ? void 0 : _api$findReplace2.sharedState.onChange(({
      nextSharedState
    }) => {
      setState(nextSharedState);
    });
    return () => {
      unsub === null || unsub === void 0 ? void 0 : unsub();
    };
  }, [api]);
  return {
    findReplaceState: state
  };
};
const FindReplaceToolbarButtonWithState = ({
  popupsBoundariesElement,
  popupsMountPoint,
  popupsScrollableElement,
  isToolbarReducedSpacing,
  editorView,
  containerElement,
  dispatchAnalyticsEvent,
  takeFullWidth,
  api,
  isButtonHidden,
  doesNotHaveButton
}) => {
  var _api$analytics;
  const editorAnalyticsAPI = api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions;
  const {
    findReplaceState
  } = useSharedPluginStateNoDebounce(api);
  if (!editorView) {
    return null;
  }

  // we need the editor to be in focus for scrollIntoView() to work
  // so we focus it while we run the command, then put focus back into
  // whatever element was previously focused in find replace component
  const runWithEditorFocused = fn => {
    const activeElement = document.activeElement;
    editorView.focus();
    fn();
    activeElement === null || activeElement === void 0 ? void 0 : activeElement.focus();
  };
  const dispatchCommand = cmd => {
    const {
      state,
      dispatch
    } = editorView;
    cmd(state, dispatch);
  };
  const handleActivate = () => {
    runWithEditorFocused(() => dispatchCommand(activateWithAnalytics(editorAnalyticsAPI)({
      triggerMethod: TRIGGER_METHOD.TOOLBAR
    })));
  };
  const handleFind = keyword => {
    runWithEditorFocused(() => dispatchCommand(findWithAnalytics(editorAnalyticsAPI)({
      editorView,
      containerElement,
      keyword
    })));
  };
  const handleFindNext = ({
    triggerMethod
  }) => {
    runWithEditorFocused(() => dispatchCommand(findNextWithAnalytics(editorAnalyticsAPI)({
      triggerMethod
    })));
  };
  const handleFindPrev = ({
    triggerMethod
  }) => {
    runWithEditorFocused(() => dispatchCommand(findPrevWithAnalytics(editorAnalyticsAPI)({
      triggerMethod
    })));
  };
  const handleReplace = ({
    triggerMethod,
    replaceText
  }) => {
    runWithEditorFocused(() => dispatchCommand(replaceWithAnalytics(editorAnalyticsAPI)({
      triggerMethod,
      replaceText
    })));
  };
  const handleReplaceAll = ({
    replaceText
  }) => {
    runWithEditorFocused(() => dispatchCommand(replaceAllWithAnalytics(editorAnalyticsAPI)({
      replaceText
    })));
  };
  const handleFindBlur = () => {
    dispatchCommand(blur());
  };
  const handleCancel = ({
    triggerMethod
  }) => {
    dispatchCommand(cancelSearchWithAnalytics(editorAnalyticsAPI)({
      triggerMethod
    }));
    editorView.focus();
  };
  const handleToggleMatchCase = () => {
    dispatchCommand(toggleMatchCase());
  };
  if (!findReplaceState) {
    return null;
  }
  const DropDownComponent = doesNotHaveButton ? FindReplaceDropdown : FindReplaceToolbarButton;
  return /*#__PURE__*/React.createElement(DropDownComponent, {
    shouldMatchCase: findReplaceState.shouldMatchCase,
    onToggleMatchCase: handleToggleMatchCase,
    isActive: findReplaceState.isActive,
    findText: findReplaceState.findText,
    index: findReplaceState.index,
    numMatches: findReplaceState.matches.length,
    replaceText: findReplaceState.replaceText,
    shouldFocus: findReplaceState.shouldFocus,
    popupsBoundariesElement: popupsBoundariesElement,
    popupsMountPoint: popupsMountPoint,
    popupsScrollableElement: popupsScrollableElement,
    isReducedSpacing: !!isToolbarReducedSpacing,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    onFindBlur: handleFindBlur,
    onCancel: handleCancel,
    onActivate: handleActivate,
    onFind: handleFind,
    onFindNext: handleFindNext,
    onFindPrev: handleFindPrev,
    onReplace: handleReplace,
    onReplaceAll: handleReplaceAll,
    takeFullWidth: !!takeFullWidth,
    isButtonHidden: isButtonHidden
  });
};
export default /*#__PURE__*/React.memo(FindReplaceToolbarButtonWithState);