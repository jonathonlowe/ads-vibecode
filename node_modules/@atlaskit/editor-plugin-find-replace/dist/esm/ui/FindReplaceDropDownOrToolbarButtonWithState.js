import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useLayoutEffect, useState } from 'react';
import { TRIGGER_METHOD } from '@atlaskit/editor-common/analytics';
import { blur, toggleMatchCase } from '../pm-plugins/commands';
import { activateWithAnalytics, cancelSearchWithAnalytics, findNextWithAnalytics, findPrevWithAnalytics, findWithAnalytics, replaceAllWithAnalytics, replaceWithAnalytics } from '../pm-plugins/commands-with-analytics';
import FindReplaceDropdown from './FindReplaceDropdown';
import FindReplaceToolbarButton from './FindReplaceToolbarButton';

// light implementation of useSharedPluginState(). This is due to findreplace
// being the only plugin that previously used WithPluginState with
// debounce=false. That was implemented because of text sync issues
// between editor & findreplace dialog.
// To address under ENGHEALTH-5853
var useSharedPluginStateNoDebounce = function useSharedPluginStateNoDebounce(api) {
  var _api$findReplace;
  var _useState = useState(api === null || api === void 0 || (_api$findReplace = api.findReplace) === null || _api$findReplace === void 0 ? void 0 : _api$findReplace.sharedState.currentState()),
    _useState2 = _slicedToArray(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  useLayoutEffect(function () {
    var _api$findReplace2;
    var unsub = api === null || api === void 0 || (_api$findReplace2 = api.findReplace) === null || _api$findReplace2 === void 0 ? void 0 : _api$findReplace2.sharedState.onChange(function (_ref) {
      var nextSharedState = _ref.nextSharedState;
      setState(nextSharedState);
    });
    return function () {
      unsub === null || unsub === void 0 || unsub();
    };
  }, [api]);
  return {
    findReplaceState: state
  };
};
var FindReplaceToolbarButtonWithState = function FindReplaceToolbarButtonWithState(_ref2) {
  var _api$analytics;
  var popupsBoundariesElement = _ref2.popupsBoundariesElement,
    popupsMountPoint = _ref2.popupsMountPoint,
    popupsScrollableElement = _ref2.popupsScrollableElement,
    isToolbarReducedSpacing = _ref2.isToolbarReducedSpacing,
    editorView = _ref2.editorView,
    containerElement = _ref2.containerElement,
    dispatchAnalyticsEvent = _ref2.dispatchAnalyticsEvent,
    takeFullWidth = _ref2.takeFullWidth,
    api = _ref2.api,
    isButtonHidden = _ref2.isButtonHidden,
    doesNotHaveButton = _ref2.doesNotHaveButton;
  var editorAnalyticsAPI = api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions;
  var _useSharedPluginState = useSharedPluginStateNoDebounce(api),
    findReplaceState = _useSharedPluginState.findReplaceState;
  if (!editorView) {
    return null;
  }

  // we need the editor to be in focus for scrollIntoView() to work
  // so we focus it while we run the command, then put focus back into
  // whatever element was previously focused in find replace component
  var runWithEditorFocused = function runWithEditorFocused(fn) {
    var activeElement = document.activeElement;
    editorView.focus();
    fn();
    activeElement === null || activeElement === void 0 || activeElement.focus();
  };
  var dispatchCommand = function dispatchCommand(cmd) {
    var state = editorView.state,
      dispatch = editorView.dispatch;
    cmd(state, dispatch);
  };
  var handleActivate = function handleActivate() {
    runWithEditorFocused(function () {
      return dispatchCommand(activateWithAnalytics(editorAnalyticsAPI)({
        triggerMethod: TRIGGER_METHOD.TOOLBAR
      }));
    });
  };
  var handleFind = function handleFind(keyword) {
    runWithEditorFocused(function () {
      return dispatchCommand(findWithAnalytics(editorAnalyticsAPI)({
        editorView: editorView,
        containerElement: containerElement,
        keyword: keyword
      }));
    });
  };
  var handleFindNext = function handleFindNext(_ref3) {
    var triggerMethod = _ref3.triggerMethod;
    runWithEditorFocused(function () {
      return dispatchCommand(findNextWithAnalytics(editorAnalyticsAPI)({
        triggerMethod: triggerMethod
      }));
    });
  };
  var handleFindPrev = function handleFindPrev(_ref4) {
    var triggerMethod = _ref4.triggerMethod;
    runWithEditorFocused(function () {
      return dispatchCommand(findPrevWithAnalytics(editorAnalyticsAPI)({
        triggerMethod: triggerMethod
      }));
    });
  };
  var handleReplace = function handleReplace(_ref5) {
    var triggerMethod = _ref5.triggerMethod,
      replaceText = _ref5.replaceText;
    runWithEditorFocused(function () {
      return dispatchCommand(replaceWithAnalytics(editorAnalyticsAPI)({
        triggerMethod: triggerMethod,
        replaceText: replaceText
      }));
    });
  };
  var handleReplaceAll = function handleReplaceAll(_ref6) {
    var replaceText = _ref6.replaceText;
    runWithEditorFocused(function () {
      return dispatchCommand(replaceAllWithAnalytics(editorAnalyticsAPI)({
        replaceText: replaceText
      }));
    });
  };
  var handleFindBlur = function handleFindBlur() {
    dispatchCommand(blur());
  };
  var handleCancel = function handleCancel(_ref7) {
    var triggerMethod = _ref7.triggerMethod;
    dispatchCommand(cancelSearchWithAnalytics(editorAnalyticsAPI)({
      triggerMethod: triggerMethod
    }));
    editorView.focus();
  };
  var handleToggleMatchCase = function handleToggleMatchCase() {
    dispatchCommand(toggleMatchCase());
  };
  if (!findReplaceState) {
    return null;
  }
  var DropDownComponent = doesNotHaveButton ? FindReplaceDropdown : FindReplaceToolbarButton;
  return /*#__PURE__*/React.createElement(DropDownComponent, {
    shouldMatchCase: findReplaceState.shouldMatchCase,
    onToggleMatchCase: handleToggleMatchCase,
    isActive: findReplaceState.isActive,
    findText: findReplaceState.findText,
    index: findReplaceState.index,
    numMatches: findReplaceState.matches.length,
    replaceText: findReplaceState.replaceText,
    shouldFocus: findReplaceState.shouldFocus,
    popupsBoundariesElement: popupsBoundariesElement,
    popupsMountPoint: popupsMountPoint,
    popupsScrollableElement: popupsScrollableElement,
    isReducedSpacing: !!isToolbarReducedSpacing,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    onFindBlur: handleFindBlur,
    onCancel: handleCancel,
    onActivate: handleActivate,
    onFind: handleFind,
    onFindNext: handleFindNext,
    onFindPrev: handleFindPrev,
    onReplace: handleReplace,
    onReplaceAll: handleReplaceAll,
    takeFullWidth: !!takeFullWidth,
    isButtonHidden: isButtonHidden
  });
};
export default /*#__PURE__*/React.memo(FindReplaceToolbarButtonWithState);