import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { pluginFactory } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { DecorationSet } from '@atlaskit/editor-prosemirror/view';
import reducer from './reducer';
import { decorationKey, findAnnotationsInSelection, inlineCommentPluginKey, isBlockNodeAnnotationsSelected, isSelectedAnnotationsChanged } from './utils';
var handleDocChanged = function handleDocChanged(tr, prevPluginState) {
  if (!tr.getMeta('replaceDocument')) {
    return getSelectionChangedHandler(false)(tr, prevPluginState);
  }
  return _objectSpread(_objectSpread({}, prevPluginState), {}, {
    dirtyAnnotations: true
  });
};

/**
 * We clear bookmark on the following conditions:
 * 1. if current selection is an empty selection, or
 * 2. if the current selection and bookmark selection are different
 */
export var shouldClearBookMarkCheck = function shouldClearBookMarkCheck(tr, editorState, bookmark) {
  if (editorState.selection.empty || !bookmark) {
    return true;
  } else if (editorState.selection instanceof NodeSelection) {
    var bookmarkSelection = bookmark === null || bookmark === void 0 ? void 0 : bookmark.resolve(tr.doc);
    if (bookmarkSelection instanceof NodeSelection) {
      var selectionNode = editorState.selection.node;
      var bookmarkNode = bookmarkSelection.node;

      /**
       * Currently, after updating the alt text of a mediaSingle node,
       * the selection moves to the media node.
       * (then will append a transaction to its parent node)
       */
      if (selectionNode.type.name === 'media' && bookmarkNode.type.name === 'mediaSingle') {
        var _bookmarkNode$firstCh;
        return !((_bookmarkNode$firstCh = bookmarkNode.firstChild) !== null && _bookmarkNode$firstCh !== void 0 && _bookmarkNode$firstCh.eq(selectionNode));
      } else {
        return !bookmarkNode.eq(selectionNode);
      }
    }
  }

  // by default we discard bookmark
  return true;
};
var getSelectionChangedHandler = function getSelectionChangedHandler(reopenCommentView) {
  return function (tr, pluginState) {
    if (pluginState.skipSelectionHandling) {
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        skipSelectionHandling: false
      }, reopenCommentView && {
        isInlineCommentViewClosed: false
      });
    }
    if (
    // If pluginState.selectedAnnotations is annotations of block node, i.e. when a new comment is created,
    // we keep it as it is so that we can show comment view component with the newly created comment
    isBlockNodeAnnotationsSelected(tr.selection, pluginState.selectedAnnotations)) {
      return _objectSpread(_objectSpread({}, pluginState), reopenCommentView && {
        isInlineCommentViewClosed: false
      });
    }
    var selectedAnnotations = findAnnotationsInSelection(tr.selection, tr.doc);
    if (selectedAnnotations.length === 0) {
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        selectedAnnotations: selectedAnnotations,
        isInlineCommentViewClosed: true,
        selectAnnotationMethod: undefined
      });
    }
    if (isSelectedAnnotationsChanged(selectedAnnotations, pluginState.selectedAnnotations)) {
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        selectedAnnotations: selectedAnnotations,
        selectAnnotationMethod: undefined
      }, reopenCommentView && {
        isInlineCommentViewClosed: false
      });
    }
    return _objectSpread(_objectSpread(_objectSpread({}, pluginState), reopenCommentView && {
      isInlineCommentViewClosed: false
    }), {}, {
      selectAnnotationMethod: undefined
    });
  };
};
var _pluginFactory = pluginFactory(inlineCommentPluginKey, reducer, {
    onSelectionChanged: getSelectionChangedHandler(true),
    onDocChanged: handleDocChanged,
    mapping: function mapping(tr, pluginState, editorState) {
      var draftDecorationSet = pluginState.draftDecorationSet,
        bookmark = pluginState.bookmark;
      var mappedDecorationSet = DecorationSet.empty,
        mappedBookmark;
      var hasMappedDecorations = false;
      if (draftDecorationSet) {
        mappedDecorationSet = draftDecorationSet.map(tr.mapping, tr.doc);
      }
      hasMappedDecorations = mappedDecorationSet.find(undefined, undefined, function (spec) {
        return Object.values(decorationKey).includes(spec.key);
      }).length > 0;

      // When changes to decoration target make decoration invalid (e.g. delete text, add mark to node),
      // we need to reset bookmark to hide create component and to avoid invalid draft being published
      // We only perform this change when document selection has changed.
      if (!hasMappedDecorations && shouldClearBookMarkCheck(tr, editorState, bookmark)) {
        return _objectSpread(_objectSpread({}, pluginState), {}, {
          draftDecorationSet: mappedDecorationSet,
          bookmark: undefined
        });
      }
      if (bookmark) {
        mappedBookmark = bookmark.map(tr.mapping);
      }

      // return same pluginState if mappings did not change
      if (mappedBookmark === bookmark && mappedDecorationSet === draftDecorationSet) {
        return pluginState;
      }
      return _objectSpread(_objectSpread({}, pluginState), {}, {
        draftDecorationSet: mappedDecorationSet,
        bookmark: mappedBookmark
      });
    }
  }),
  createPluginState = _pluginFactory.createPluginState,
  createCommand = _pluginFactory.createCommand;
export { createPluginState, createCommand };