import { AnnotationTypes } from '@atlaskit/adf-schema';
import { getRangeInlineNodeNames } from '@atlaskit/editor-common/utils';
import { findDomRefAtPos } from '@atlaskit/editor-prosemirror/utils';
import { setInlineCommentDraftState, createAnnotation } from '../editor-commands';
import { AnnotationSelectionType } from '../types';
import { inlineCommentPluginKey, isSelectionValid } from './utils';
var ERROR_REASON_DRAFT_NOT_STARTED = 'draft-not-started';
var ERROR_REASON_DRAFT_IN_PROGRESS = 'draft-in-progress';
var ERROR_REASON_RANGE_MISSING = 'range-no-longer-exists';
var ERROR_REASON_RANGE_INVALID = 'invalid-range';
var domRefFromPos = function domRefFromPos(view, position) {
  var dom;
  try {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    dom = findDomRefAtPos(position, view.domAtPos.bind(view));
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn(error);
    return undefined;
  }
  return dom;
};
export var allowAnnotation = function allowAnnotation(editorView, options) {
  return function () {
    var _ref = inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref.isDrafting,
      draftDecorationSet = _ref.draftDecorationSet;
    if (isDrafting) {
      return false;
    }
    var decoration = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();

    // If a draft decoration exists then we should block the user from creating a new one.
    if (!!(decoration !== null && decoration !== void 0 && decoration.length)) {
      return false;
    }
    return isSelectionValid(editorView.state) === AnnotationSelectionType.VALID;
  };
};
export var startDraft = function startDraft(editorView, options) {
  return function () {
    var _getRangeInlineNodeNa, _options$annotationMa;
    var _ref2 = inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref2.isDrafting;
    if (isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_IN_PROGRESS
      };
    }
    setInlineCommentDraftState(options.editorAnalyticsAPI)(true)(editorView.state, editorView.dispatch);
    var _ref3 = inlineCommentPluginKey.getState(editorView.state) || {},
      draftDecorationSet = _ref3.draftDecorationSet;
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();

    // If the matching decorations is not found containing the id, it means something went wrong with the draft.
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_RANGE_INVALID
      };
    }
    var from = decorations[0].from;
    var targetElement = domRefFromPos(editorView, from);
    var inlineNodeTypes = (_getRangeInlineNodeNa = getRangeInlineNodeNames({
      doc: editorView.state.doc,
      pos: {
        from: from,
        to: decorations[decorations.length - 1].to
      }
    })) !== null && _getRangeInlineNodeNa !== void 0 ? _getRangeInlineNodeNa : [];
    (_options$annotationMa = options.annotationManager) === null || _options$annotationMa === void 0 || _options$annotationMa.emit({
      name: 'draftAnnotationStarted',
      data: {
        targetElement: targetElement,
        actionResult: undefined,
        inlineNodeTypes: inlineNodeTypes
      }
    });
    return {
      success: true,
      targetElement: targetElement,
      // In Editor the action result is undefined, because the editor will perform the transaction on the document.
      actionResult: undefined,
      inlineNodeTypes: inlineNodeTypes
    };
  };
};
export var clearDraft = function clearDraft(editorView, options) {
  return function () {
    var _ref4 = inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref4.isDrafting,
      draftDecorationSet = _ref4.draftDecorationSet;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    setInlineCommentDraftState(options.editorAnalyticsAPI)(false)(editorView.state, editorView.dispatch);
    !editorView.hasFocus() && editorView.focus();
    return {
      success: true
    };
  };
};
export var applyDraft = function applyDraft(editorView, options) {
  return function (id) {
    var _ref5 = inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref5.isDrafting,
      draftDecorationSet = _ref5.draftDecorationSet,
      bookmark = _ref5.bookmark;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length) || !bookmark) {
      return {
        success: false,
        reason: ERROR_REASON_RANGE_MISSING
      };
    }
    var from = decorations[0].from;
    createAnnotation(options.editorAnalyticsAPI, options.api)(id, AnnotationTypes.INLINE_COMMENT, options.provider.supportedBlockNodes)(editorView.state, editorView.dispatch);
    !editorView.hasFocus() && editorView.focus();

    // Using the original decoration from position we should be able to locate the new target element.
    // This is because the new annotation will be created at the same position as the draft decoration.
    var targetElement = domRefFromPos(editorView, from);
    return {
      success: true,
      // Get the dom element from the newly created annotation and return it here.
      targetElement: targetElement
    };
  };
};
export var getDraft = function getDraft(editorView, options) {
  return function () {
    var _getRangeInlineNodeNa2;
    var _ref6 = inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref6.isDrafting,
      draftDecorationSet = _ref6.draftDecorationSet;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var from = decorations[0].from;
    var targetElement = domRefFromPos(editorView, from);
    var inlineNodeTypes = (_getRangeInlineNodeNa2 = getRangeInlineNodeNames({
      doc: editorView.state.doc,
      pos: {
        from: from,
        to: decorations[decorations.length - 1].to
      }
    })) !== null && _getRangeInlineNodeNa2 !== void 0 ? _getRangeInlineNodeNa2 : [];
    return {
      success: true,
      inlineNodeTypes: inlineNodeTypes,
      targetElement: targetElement,
      actionResult: undefined
    };
  };
};