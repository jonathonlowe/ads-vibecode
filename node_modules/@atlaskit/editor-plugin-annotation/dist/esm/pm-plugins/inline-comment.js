import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { AnnotationTypes } from '@atlaskit/adf-schema';
import { RESOLVE_METHOD } from '@atlaskit/editor-common/analytics';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { clearDirtyMark, closeComponent, setHoveredAnnotation, setInlineCommentsVisibility, setSelectedAnnotation, updateInlineCommentResolvedState, updateMouseState } from '../editor-commands';
import { getAnnotationViewClassname, getBlockAnnotationViewClassname } from '../nodeviews';
import { allowAnnotation, applyDraft, clearDraft, getDraft, startDraft } from './annotation-manager-hooks';
import { createPluginState } from './plugin-factory';
import { decorationKey, getAllAnnotations, getPluginState, inlineCommentPluginKey } from './utils';
var fetchProviderStates = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(provider, annotationIds) {
    var data, result;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!((!provider || !provider.getState) && fg('use_comments_data_annotation_updater'))) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return", {});
        case 2:
          _context.next = 4;
          return provider.getState(annotationIds);
        case 4:
          data = _context.sent;
          result = {};
          data.forEach(function (annotation) {
            if (annotation.annotationType === AnnotationTypes.INLINE_COMMENT) {
              result[annotation.id] = annotation.state.resolved;
            }
          });
          return _context.abrupt("return", result);
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function fetchProviderStates(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

// fetchState is unable to return a command as it's runs async and may dispatch at a later time
// Requires `editorView` instead of the decomposition as the async means state may end up stale
var fetchState = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(provider, annotationIds, editorView, editorAnalyticsAPI) {
    var inlineCommentStates;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!((!annotationIds || !annotationIds.length) && !fg('use_comments_data_annotation_updater'))) {
            _context2.next = 2;
            break;
          }
          return _context2.abrupt("return");
        case 2:
          _context2.next = 4;
          return fetchProviderStates(provider, annotationIds);
        case 4:
          inlineCommentStates = _context2.sent;
          if (!(Object.keys(inlineCommentStates).length === 0 && fg('use_comments_data_annotation_updater'))) {
            _context2.next = 7;
            break;
          }
          return _context2.abrupt("return");
        case 7:
          if (editorView.dispatch) {
            updateInlineCommentResolvedState(editorAnalyticsAPI)(inlineCommentStates)(editorView.state, editorView.dispatch);
          }
        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function fetchState(_x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();
var initialState = function initialState() {
  var disallowOnWhitespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var featureFlagsPluginState = arguments.length > 1 ? arguments[1] : undefined;
  return {
    annotations: {},
    selectedAnnotations: [],
    hoveredAnnotations: [],
    mouseData: {
      isSelecting: false
    },
    disallowOnWhitespace: disallowOnWhitespace,
    isInlineCommentViewClosed: false,
    isVisible: true,
    skipSelectionHandling: false,
    featureFlagsPluginState: featureFlagsPluginState,
    isDrafting: false
  };
};
var hideToolbar = function hideToolbar(state, dispatch) {
  return function () {
    updateMouseState({
      isSelecting: true
    })(state, dispatch);
  };
};

// Subscribe to updates from consumer
var onResolve = function onResolve(editorAnalyticsAPI) {
  return function (state, dispatch) {
    return function (annotationId) {
      updateInlineCommentResolvedState(editorAnalyticsAPI)(_defineProperty({}, annotationId, true), RESOLVE_METHOD.CONSUMER)(state, dispatch);
    };
  };
};
var onUnResolve = function onUnResolve(editorAnalyticsAPI) {
  return function (state, dispatch) {
    return function (annotationId) {
      updateInlineCommentResolvedState(editorAnalyticsAPI)(_defineProperty({}, annotationId, false))(state, dispatch);
    };
  };
};
var onMouseUp = function onMouseUp(state, dispatch) {
  return function (e) {
    var _ref3 = getPluginState(state) || {},
      mouseData = _ref3.mouseData;
    if (mouseData !== null && mouseData !== void 0 && mouseData.isSelecting) {
      updateMouseState({
        isSelecting: false
      })(state, dispatch);
    }
  };
};
var onSetVisibility = function onSetVisibility(view) {
  return function (isVisible) {
    var state = view.state,
      dispatch = view.dispatch;
    setInlineCommentsVisibility(isVisible)(state, dispatch);
    if (isVisible) {
      // PM retains focus when we click away from the editor.
      // This will restore the visual aspect of the selection,
      // otherwise it will seem a floating toolbar will appear
      // for no reason.
      view.focus();
    }
  };
};
export var inlineCommentPlugin = function inlineCommentPlugin(options) {
  var provider = options.provider,
    featureFlagsPluginState = options.featureFlagsPluginState,
    annotationManager = options.annotationManager;
  return new SafePlugin({
    key: inlineCommentPluginKey,
    state: createPluginState(options.dispatch, initialState(provider.disallowOnWhitespace, featureFlagsPluginState)),
    view: function view(editorView) {
      if (annotationManager && fg('platform_editor_comments_api_manager')) {
        annotationManager.hook('allowAnnotation', allowAnnotation(editorView, options));
        annotationManager.hook('startDraft', startDraft(editorView, options));
        annotationManager.hook('clearDraft', clearDraft(editorView, options));
        annotationManager.hook('applyDraft', applyDraft(editorView, options));
        annotationManager.hook('getDraft', getDraft(editorView, options));
      }
      // Get initial state
      // Need to pass `editorView` to mitigate editor state going stale
      fetchState(provider, getAllAnnotations(editorView.state.doc), editorView, options.editorAnalyticsAPI);
      var resolve = function resolve(annotationId) {
        return onResolve(options.editorAnalyticsAPI)(editorView.state, editorView.dispatch)(annotationId);
      };
      var unResolve = function unResolve(annotationId) {
        return onUnResolve(options.editorAnalyticsAPI)(editorView.state, editorView.dispatch)(annotationId);
      };
      var mouseUp = function mouseUp(event) {
        return onMouseUp(editorView.state, editorView.dispatch)(event);
      };
      var setVisibility = function setVisibility(isVisible) {
        return onSetVisibility(editorView)(isVisible);
      };
      var setSelectedAnnotationFn = function setSelectedAnnotationFn(annotationId) {
        var pluginState = getPluginState(editorView.state);
        if (fg('platform_editor_listen_for_focussed_query_param')) {
          // When feature flag is true, only close if no annotationId
          if (!annotationId) {
            closeComponent()(editorView.state, editorView.dispatch);
          } else {
            setSelectedAnnotation(annotationId)(editorView.state, editorView.dispatch);
          }
        } else {
          // When feature flag is false, close if:
          // 1. No annotationId OR
          // 2. View is closed and annotation clicks are enabled
          var shouldClose = !annotationId || (pluginState === null || pluginState === void 0 ? void 0 : pluginState.isInlineCommentViewClosed) && fg('platform_editor_listen_for_annotation_clicks');
          if (shouldClose) {
            closeComponent()(editorView.state, editorView.dispatch);
          } else {
            setSelectedAnnotation(annotationId)(editorView.state, editorView.dispatch);
          }
        }
      };
      var setHoveredAnnotationFn = function setHoveredAnnotationFn(annotationId) {
        if (!annotationId) {
          closeComponent()(editorView.state, editorView.dispatch);
        } else {
          setHoveredAnnotation(annotationId)(editorView.state, editorView.dispatch);
        }
      };
      var removeHoveredannotationFn = function removeHoveredannotationFn() {
        setHoveredAnnotation('')(editorView.state, editorView.dispatch);
      };
      var closeInlineCommentFn = function closeInlineCommentFn() {
        closeComponent()(editorView.state, editorView.dispatch);
      };
      var updateSubscriber = provider.updateSubscriber;
      if (updateSubscriber) {
        updateSubscriber.on('resolve', resolve).on('delete', resolve).on('unresolve', unResolve).on('create', unResolve).on('setvisibility', setVisibility).on('setselectedannotation', setSelectedAnnotationFn).on('sethoveredannotation', setHoveredAnnotationFn).on('removehoveredannotation', removeHoveredannotationFn).on('closeinlinecomment', closeInlineCommentFn);
      }

      // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
      editorView.root.addEventListener('mouseup', mouseUp);
      return {
        update: function update(view, _prevState) {
          if (fg('confluence_comments_select_comment_experience')) {
            var _prevSelectedAnnotati;
            var _ref4 = getPluginState(view.state) || {},
              selectedAnnotations = _ref4.selectedAnnotations;
            var _ref5 = getPluginState(_prevState) || {},
              prevSelectedAnnotations = _ref5.selectedAnnotations;

            // If the new state has a selected annotation, and it's different from the previous one
            // then we mark the select annotation experience as complete
            if (selectedAnnotations && selectedAnnotations.length !== 0 && selectedAnnotations[0].id !== (prevSelectedAnnotations === null || prevSelectedAnnotations === void 0 || (_prevSelectedAnnotati = prevSelectedAnnotations[0]) === null || _prevSelectedAnnotati === void 0 ? void 0 : _prevSelectedAnnotati.id)) {
              var _options$selectCommen;
              (_options$selectCommen = options.selectCommentExperience) === null || _options$selectCommen === void 0 || _options$selectCommen.selectAnnotation.complete(selectedAnnotations[0].id);
            }
          }
          var _ref6 = getPluginState(view.state) || {},
            dirtyAnnotations = _ref6.dirtyAnnotations;
          if (!dirtyAnnotations) {
            return;
          }
          clearDirtyMark()(view.state, view.dispatch);
          fetchState(provider, getAllAnnotations(view.state.doc), view, options.editorAnalyticsAPI);
        },
        destroy: function destroy() {
          // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
          editorView.root.removeEventListener('mouseup', mouseUp);
          if (updateSubscriber) {
            updateSubscriber.off('resolve', resolve).off('delete', resolve).off('unresolve', unResolve).off('create', unResolve).off('setvisibility', setVisibility).off('setselectedannotation', setSelectedAnnotationFn).off('sethoveredannotation', setHoveredAnnotationFn).off('removehoveredannotation', removeHoveredannotationFn).off('closeinlinecomment', closeInlineCommentFn);
          }
        }
      };
    },
    props: {
      handleDOMEvents: {
        mousedown: function mousedown(view) {
          var pluginState = getPluginState(view.state);
          if (!(pluginState !== null && pluginState !== void 0 && pluginState.mouseData.isSelecting)) {
            hideToolbar(view.state, view.dispatch)();
          }
          return false;
        },
        dragstart: function dragstart(view, event) {
          // Mouseup won't be triggered after dropping
          // Hence, update the mouse data to cancel selecting when drag starts
          return onMouseUp(view.state, view.dispatch)(event);
        },
        click: function click(view, event) {
          var _event$target$closest, _pluginState$selected;
          if (!fg('platform_editor_listen_for_annotation_clicks')) {
            return false;
          }
          if (!(event.target instanceof HTMLElement)) {
            return false;
          }

          // Find the nearest ancestor (or self) with the data-id attribute
          var annotationId = (_event$target$closest = event.target.closest('[data-id]')) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.getAttribute('data-id');
          if (!annotationId) {
            return false;
          }
          var pluginState = getPluginState(view.state);
          var isSelected = pluginState === null || pluginState === void 0 || (_pluginState$selected = pluginState.selectedAnnotations) === null || _pluginState$selected === void 0 ? void 0 : _pluginState$selected.some(function (selectedAnnotation) {
            return selectedAnnotation.id === annotationId;
          });
          // If the annotation is selected and the inline comment view is open, do nothing
          // as the user is already in the comment view.
          if (isSelected && !(pluginState !== null && pluginState !== void 0 && pluginState.isInlineCommentViewClosed)) {
            return false;
          }
          var _ref7 = pluginState || {},
            annotations = _ref7.annotations;
          var isUnresolved = annotations && annotations[annotationId] === false;
          if (!isUnresolved) {
            return false;
          }
          setSelectedAnnotation(annotationId)(view.state, view.dispatch);
          return true;
        }
      },
      decorations: function decorations(state) {
        // highlight comments, depending on state
        var _ref8 = getPluginState(state) || {},
          draftDecorationSet = _ref8.draftDecorationSet,
          annotations = _ref8.annotations,
          selectedAnnotations = _ref8.selectedAnnotations,
          isVisible = _ref8.isVisible,
          isInlineCommentViewClosed = _ref8.isInlineCommentViewClosed,
          hoveredAnnotations = _ref8.hoveredAnnotations;
        var decorations = draftDecorationSet !== null && draftDecorationSet !== void 0 ? draftDecorationSet : DecorationSet.empty;
        var focusDecorations = [];
        state.doc.descendants(function (node, pos) {
          var _provider$supportedBl;
          // Inline comment on mediaInline is not supported as part of comments on media project
          // Thus, we skip the decoration for mediaInline node
          if (node.type.name === 'mediaInline') {
            return false;
          }
          var isSupportedBlockNode = node.isBlock && ((_provider$supportedBl = provider.supportedBlockNodes) === null || _provider$supportedBl === void 0 ? void 0 : _provider$supportedBl.includes(node.type.name));
          node.marks.filter(function (mark) {
            return mark.type === state.schema.marks.annotation;
          }).forEach(function (mark) {
            if (isVisible) {
              var isUnresolved = !!annotations && annotations[mark.attrs.id] === false;
              var isSelected = !isInlineCommentViewClosed && !!(selectedAnnotations !== null && selectedAnnotations !== void 0 && selectedAnnotations.some(function (selectedAnnotation) {
                return selectedAnnotation.id === mark.attrs.id;
              }));
              var isHovered = !isInlineCommentViewClosed && !!(hoveredAnnotations !== null && hoveredAnnotations !== void 0 && hoveredAnnotations.some(function (hoveredAnnotation) {
                return hoveredAnnotation.id === mark.attrs.id;
              }));
              if (isSupportedBlockNode) {
                focusDecorations.push(Decoration.node(pos, pos + node.nodeSize, {
                  class: "".concat(getBlockAnnotationViewClassname(isUnresolved, isSelected), " ").concat(isUnresolved)
                }, {
                  key: decorationKey.block
                }));
              } else {
                if (fg('editor_inline_comments_on_inline_nodes')) {
                  if (node.isText) {
                    focusDecorations.push(Decoration.inline(pos, pos + node.nodeSize, {
                      class: "".concat(getAnnotationViewClassname(isUnresolved, isSelected, isHovered), " ").concat(isUnresolved),
                      nodeName: 'span'
                    }));
                  } else {
                    focusDecorations.push(Decoration.node(pos, pos + node.nodeSize, {
                      class: "".concat(getAnnotationViewClassname(isUnresolved, isSelected, isHovered), " ").concat(isUnresolved)
                    }, {
                      key: decorationKey.block
                    }));
                  }
                } else {
                  focusDecorations.push(Decoration.inline(pos, pos + node.nodeSize, {
                    class: "".concat(getAnnotationViewClassname(isUnresolved, isSelected, isHovered), " ").concat(isUnresolved),
                    nodeName: 'span'
                  }));
                }
              }
            }
          });
        });
        decorations = decorations.add(state.doc, focusDecorations);
        return decorations;
      }
    }
  });
};