import React from 'react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { setInlineCommentDraftState, showInlineCommentForBlockNode } from './editor-commands';
import { annotationWithToDOMFix } from './nodeviews/annotationMark';
import { inlineCommentPlugin } from './pm-plugins/inline-comment';
import { keymapPlugin } from './pm-plugins/keymap';
import { buildSuppressedToolbar, buildToolbar, shouldSuppressFloatingToolbar } from './pm-plugins/toolbar';
import { getPluginState, hasAnyUnResolvedAnnotationInPage, stripNonExistingAnnotations } from './pm-plugins/utils';
import { InlineCommentView } from './ui/InlineCommentView';
export const annotationPlugin = ({
  config: annotationProviders,
  api
}) => {
  var _api$featureFlags, _api$analytics;
  const featureFlags = api === null || api === void 0 ? void 0 : (_api$featureFlags = api.featureFlags) === null || _api$featureFlags === void 0 ? void 0 : _api$featureFlags.sharedState.currentState();
  return {
    name: 'annotation',
    marks() {
      return [{
        name: 'annotation',
        mark: annotationWithToDOMFix
      }];
    },
    actions: {
      hasAnyUnResolvedAnnotationInPage,
      stripNonExistingAnnotations,
      setInlineCommentDraftState: setInlineCommentDraftState(api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions, annotationProviders === null || annotationProviders === void 0 ? void 0 : annotationProviders.inlineComment.supportedBlockNodes),
      showCommentForBlockNode: showInlineCommentForBlockNode(annotationProviders === null || annotationProviders === void 0 ? void 0 : annotationProviders.inlineComment.supportedBlockNodes)
    },
    getSharedState(editorState) {
      if (!editorState) {
        return undefined;
      }
      const pluginState = getPluginState(editorState) || undefined;
      const clonedPluginState = Object.assign({}, pluginState);
      clonedPluginState === null || clonedPluginState === void 0 ? true : delete clonedPluginState.featureFlagsPluginState;
      return clonedPluginState;
    },
    pmPlugins: () => [{
      name: 'annotation',
      plugin: ({
        dispatch
      }) => {
        if (annotationProviders) {
          var _api$analytics2;
          return inlineCommentPlugin({
            dispatch,
            provider: annotationProviders.inlineComment,
            editorAnalyticsAPI: api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions,
            featureFlagsPluginState: featureFlags,
            selectCommentExperience: annotationProviders.selectCommentExperience,
            annotationManager: annotationProviders.annotationManager,
            api
          });
        }
        return;
      }
    }, {
      name: 'annotationKeymap',
      plugin: () => {
        if (annotationProviders) {
          var _api$analytics3;
          return keymapPlugin(api === null || api === void 0 ? void 0 : (_api$analytics3 = api.analytics) === null || _api$analytics3 === void 0 ? void 0 : _api$analytics3.actions);
        }
        return;
      }
    }],
    pluginsOptions: {
      floatingToolbar(state) {
        if (!fg('platform_editor_fix_toolbar_comment_jump')) {
          return;
        }
        const pluginState = getPluginState(state);
        const bookmark = pluginState === null || pluginState === void 0 ? void 0 : pluginState.bookmark;
        if (shouldSuppressFloatingToolbar({
          state,
          bookmark
        })) {
          return buildSuppressedToolbar(state);
        }
      },
      selectionToolbar(state, intl) {
        if (!annotationProviders) {
          return;
        }
        const pluginState = getPluginState(state);
        if (pluginState && pluginState.isVisible && !pluginState.bookmark && !pluginState.mouseData.isSelecting) {
          var _api$analytics4;
          const {
            isToolbarAbove
          } = annotationProviders.inlineComment;
          const toolbarConfig = buildToolbar(api === null || api === void 0 ? void 0 : (_api$analytics4 = api.analytics) === null || _api$analytics4 === void 0 ? void 0 : _api$analytics4.actions)({
            state,
            intl,
            isToolbarAbove,
            api,
            createCommentExperience: annotationProviders.createCommentExperience,
            annotationManager: annotationProviders.annotationManager
          });
          if (!toolbarConfig) {
            return undefined;
          } else {
            return {
              ...toolbarConfig,
              rank: editorExperiment('platform_editor_controls', 'variant1') ? 1 : undefined
            };
          }
        }
      }
    },
    contentComponent({
      editorView,
      dispatchAnalyticsEvent
    }) {
      if (!annotationProviders) {
        return null;
      }
      return /*#__PURE__*/React.createElement(AnnotationContentComponent, {
        api: api,
        editorView: editorView,
        annotationProviders: annotationProviders,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent
      });
    }
  };
};
function AnnotationContentComponent({
  api,
  editorView,
  annotationProviders,
  dispatchAnalyticsEvent
}) {
  var _api$analytics5;
  const {
    annotationState: inlineCommentState
  } = useSharedPluginState(api, ['annotation']);
  if (inlineCommentState && !inlineCommentState.isVisible) {
    return null;
  }
  return /*#__PURE__*/React.createElement("div", {
    "data-editor-popup": "true"
  }, /*#__PURE__*/React.createElement(InlineCommentView, {
    providers: annotationProviders,
    editorView: editorView,
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    editorAnalyticsAPI: api === null || api === void 0 ? void 0 : (_api$analytics5 = api.analytics) === null || _api$analytics5 === void 0 ? void 0 : _api$analytics5.actions,
    editorAPI: api
  }));
}