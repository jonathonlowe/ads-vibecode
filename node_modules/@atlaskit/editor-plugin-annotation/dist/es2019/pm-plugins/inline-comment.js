import { AnnotationTypes } from '@atlaskit/adf-schema';
import { RESOLVE_METHOD } from '@atlaskit/editor-common/analytics';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { Decoration, DecorationSet } from '@atlaskit/editor-prosemirror/view';
import { fg } from '@atlaskit/platform-feature-flags';
import { clearDirtyMark, closeComponent, setHoveredAnnotation, setInlineCommentsVisibility, setSelectedAnnotation, updateInlineCommentResolvedState, updateMouseState } from '../editor-commands';
import { getAnnotationViewClassname, getBlockAnnotationViewClassname } from '../nodeviews';
import { allowAnnotation, applyDraft, clearDraft, getDraft, startDraft } from './annotation-manager-hooks';
import { createPluginState } from './plugin-factory';
import { decorationKey, getAllAnnotations, getPluginState, inlineCommentPluginKey } from './utils';
const fetchProviderStates = async (provider, annotationIds) => {
  if ((!provider || !provider.getState) && fg('use_comments_data_annotation_updater')) {
    return {};
  }
  const data = await provider.getState(annotationIds);
  const result = {};
  data.forEach(annotation => {
    if (annotation.annotationType === AnnotationTypes.INLINE_COMMENT) {
      result[annotation.id] = annotation.state.resolved;
    }
  });
  return result;
};

// fetchState is unable to return a command as it's runs async and may dispatch at a later time
// Requires `editorView` instead of the decomposition as the async means state may end up stale
const fetchState = async (provider, annotationIds, editorView, editorAnalyticsAPI) => {
  if ((!annotationIds || !annotationIds.length) && !fg('use_comments_data_annotation_updater')) {
    return;
  }
  const inlineCommentStates = await fetchProviderStates(provider, annotationIds);
  if (Object.keys(inlineCommentStates).length === 0 && fg('use_comments_data_annotation_updater')) {
    return;
  }
  if (editorView.dispatch) {
    updateInlineCommentResolvedState(editorAnalyticsAPI)(inlineCommentStates)(editorView.state, editorView.dispatch);
  }
};
const initialState = (disallowOnWhitespace = false, featureFlagsPluginState) => {
  return {
    annotations: {},
    selectedAnnotations: [],
    hoveredAnnotations: [],
    mouseData: {
      isSelecting: false
    },
    disallowOnWhitespace,
    isInlineCommentViewClosed: false,
    isVisible: true,
    skipSelectionHandling: false,
    featureFlagsPluginState,
    isDrafting: false
  };
};
const hideToolbar = (state, dispatch) => () => {
  updateMouseState({
    isSelecting: true
  })(state, dispatch);
};

// Subscribe to updates from consumer
const onResolve = editorAnalyticsAPI => (state, dispatch) => annotationId => {
  updateInlineCommentResolvedState(editorAnalyticsAPI)({
    [annotationId]: true
  }, RESOLVE_METHOD.CONSUMER)(state, dispatch);
};
const onUnResolve = editorAnalyticsAPI => (state, dispatch) => annotationId => {
  updateInlineCommentResolvedState(editorAnalyticsAPI)({
    [annotationId]: false
  })(state, dispatch);
};
const onMouseUp = (state, dispatch) => e => {
  const {
    mouseData
  } = getPluginState(state) || {};
  if (mouseData !== null && mouseData !== void 0 && mouseData.isSelecting) {
    updateMouseState({
      isSelecting: false
    })(state, dispatch);
  }
};
const onSetVisibility = view => isVisible => {
  const {
    state,
    dispatch
  } = view;
  setInlineCommentsVisibility(isVisible)(state, dispatch);
  if (isVisible) {
    // PM retains focus when we click away from the editor.
    // This will restore the visual aspect of the selection,
    // otherwise it will seem a floating toolbar will appear
    // for no reason.
    view.focus();
  }
};
export const inlineCommentPlugin = options => {
  const {
    provider,
    featureFlagsPluginState,
    annotationManager
  } = options;
  return new SafePlugin({
    key: inlineCommentPluginKey,
    state: createPluginState(options.dispatch, initialState(provider.disallowOnWhitespace, featureFlagsPluginState)),
    view(editorView) {
      if (annotationManager && fg('platform_editor_comments_api_manager')) {
        annotationManager.hook('allowAnnotation', allowAnnotation(editorView, options));
        annotationManager.hook('startDraft', startDraft(editorView, options));
        annotationManager.hook('clearDraft', clearDraft(editorView, options));
        annotationManager.hook('applyDraft', applyDraft(editorView, options));
        annotationManager.hook('getDraft', getDraft(editorView, options));
      }
      // Get initial state
      // Need to pass `editorView` to mitigate editor state going stale
      fetchState(provider, getAllAnnotations(editorView.state.doc), editorView, options.editorAnalyticsAPI);
      const resolve = annotationId => onResolve(options.editorAnalyticsAPI)(editorView.state, editorView.dispatch)(annotationId);
      const unResolve = annotationId => onUnResolve(options.editorAnalyticsAPI)(editorView.state, editorView.dispatch)(annotationId);
      const mouseUp = event => onMouseUp(editorView.state, editorView.dispatch)(event);
      const setVisibility = isVisible => onSetVisibility(editorView)(isVisible);
      const setSelectedAnnotationFn = annotationId => {
        const pluginState = getPluginState(editorView.state);
        if (fg('platform_editor_listen_for_focussed_query_param')) {
          // When feature flag is true, only close if no annotationId
          if (!annotationId) {
            closeComponent()(editorView.state, editorView.dispatch);
          } else {
            setSelectedAnnotation(annotationId)(editorView.state, editorView.dispatch);
          }
        } else {
          // When feature flag is false, close if:
          // 1. No annotationId OR
          // 2. View is closed and annotation clicks are enabled
          const shouldClose = !annotationId || (pluginState === null || pluginState === void 0 ? void 0 : pluginState.isInlineCommentViewClosed) && fg('platform_editor_listen_for_annotation_clicks');
          if (shouldClose) {
            closeComponent()(editorView.state, editorView.dispatch);
          } else {
            setSelectedAnnotation(annotationId)(editorView.state, editorView.dispatch);
          }
        }
      };
      const setHoveredAnnotationFn = annotationId => {
        if (!annotationId) {
          closeComponent()(editorView.state, editorView.dispatch);
        } else {
          setHoveredAnnotation(annotationId)(editorView.state, editorView.dispatch);
        }
      };
      const removeHoveredannotationFn = () => {
        setHoveredAnnotation('')(editorView.state, editorView.dispatch);
      };
      const closeInlineCommentFn = () => {
        closeComponent()(editorView.state, editorView.dispatch);
      };
      const {
        updateSubscriber
      } = provider;
      if (updateSubscriber) {
        updateSubscriber.on('resolve', resolve).on('delete', resolve).on('unresolve', unResolve).on('create', unResolve).on('setvisibility', setVisibility).on('setselectedannotation', setSelectedAnnotationFn).on('sethoveredannotation', setHoveredAnnotationFn).on('removehoveredannotation', removeHoveredannotationFn).on('closeinlinecomment', closeInlineCommentFn);
      }

      // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
      editorView.root.addEventListener('mouseup', mouseUp);
      return {
        update(view, _prevState) {
          if (fg('confluence_comments_select_comment_experience')) {
            var _prevSelectedAnnotati;
            const {
              selectedAnnotations
            } = getPluginState(view.state) || {};
            const {
              selectedAnnotations: prevSelectedAnnotations
            } = getPluginState(_prevState) || {};

            // If the new state has a selected annotation, and it's different from the previous one
            // then we mark the select annotation experience as complete
            if (selectedAnnotations && selectedAnnotations.length !== 0 && selectedAnnotations[0].id !== (prevSelectedAnnotations === null || prevSelectedAnnotations === void 0 ? void 0 : (_prevSelectedAnnotati = prevSelectedAnnotations[0]) === null || _prevSelectedAnnotati === void 0 ? void 0 : _prevSelectedAnnotati.id)) {
              var _options$selectCommen;
              (_options$selectCommen = options.selectCommentExperience) === null || _options$selectCommen === void 0 ? void 0 : _options$selectCommen.selectAnnotation.complete(selectedAnnotations[0].id);
            }
          }
          const {
            dirtyAnnotations
          } = getPluginState(view.state) || {};
          if (!dirtyAnnotations) {
            return;
          }
          clearDirtyMark()(view.state, view.dispatch);
          fetchState(provider, getAllAnnotations(view.state.doc), view, options.editorAnalyticsAPI);
        },
        destroy() {
          // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
          editorView.root.removeEventListener('mouseup', mouseUp);
          if (updateSubscriber) {
            updateSubscriber.off('resolve', resolve).off('delete', resolve).off('unresolve', unResolve).off('create', unResolve).off('setvisibility', setVisibility).off('setselectedannotation', setSelectedAnnotationFn).off('sethoveredannotation', setHoveredAnnotationFn).off('removehoveredannotation', removeHoveredannotationFn).off('closeinlinecomment', closeInlineCommentFn);
          }
        }
      };
    },
    props: {
      handleDOMEvents: {
        mousedown: view => {
          const pluginState = getPluginState(view.state);
          if (!(pluginState !== null && pluginState !== void 0 && pluginState.mouseData.isSelecting)) {
            hideToolbar(view.state, view.dispatch)();
          }
          return false;
        },
        dragstart: (view, event) => {
          // Mouseup won't be triggered after dropping
          // Hence, update the mouse data to cancel selecting when drag starts
          return onMouseUp(view.state, view.dispatch)(event);
        },
        click: (view, event) => {
          var _event$target$closest, _pluginState$selected;
          if (!fg('platform_editor_listen_for_annotation_clicks')) {
            return false;
          }
          if (!(event.target instanceof HTMLElement)) {
            return false;
          }

          // Find the nearest ancestor (or self) with the data-id attribute
          const annotationId = (_event$target$closest = event.target.closest('[data-id]')) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.getAttribute('data-id');
          if (!annotationId) {
            return false;
          }
          const pluginState = getPluginState(view.state);
          const isSelected = pluginState === null || pluginState === void 0 ? void 0 : (_pluginState$selected = pluginState.selectedAnnotations) === null || _pluginState$selected === void 0 ? void 0 : _pluginState$selected.some(selectedAnnotation => selectedAnnotation.id === annotationId);
          // If the annotation is selected and the inline comment view is open, do nothing
          // as the user is already in the comment view.
          if (isSelected && !(pluginState !== null && pluginState !== void 0 && pluginState.isInlineCommentViewClosed)) {
            return false;
          }
          const {
            annotations
          } = pluginState || {};
          const isUnresolved = annotations && annotations[annotationId] === false;
          if (!isUnresolved) {
            return false;
          }
          setSelectedAnnotation(annotationId)(view.state, view.dispatch);
          return true;
        }
      },
      decorations(state) {
        // highlight comments, depending on state
        const {
          draftDecorationSet,
          annotations,
          selectedAnnotations,
          isVisible,
          isInlineCommentViewClosed,
          hoveredAnnotations
        } = getPluginState(state) || {};
        let decorations = draftDecorationSet !== null && draftDecorationSet !== void 0 ? draftDecorationSet : DecorationSet.empty;
        const focusDecorations = [];
        state.doc.descendants((node, pos) => {
          var _provider$supportedBl;
          // Inline comment on mediaInline is not supported as part of comments on media project
          // Thus, we skip the decoration for mediaInline node
          if (node.type.name === 'mediaInline') {
            return false;
          }
          const isSupportedBlockNode = node.isBlock && ((_provider$supportedBl = provider.supportedBlockNodes) === null || _provider$supportedBl === void 0 ? void 0 : _provider$supportedBl.includes(node.type.name));
          node.marks.filter(mark => mark.type === state.schema.marks.annotation).forEach(mark => {
            if (isVisible) {
              const isUnresolved = !!annotations && annotations[mark.attrs.id] === false;
              const isSelected = !isInlineCommentViewClosed && !!(selectedAnnotations !== null && selectedAnnotations !== void 0 && selectedAnnotations.some(selectedAnnotation => selectedAnnotation.id === mark.attrs.id));
              const isHovered = !isInlineCommentViewClosed && !!(hoveredAnnotations !== null && hoveredAnnotations !== void 0 && hoveredAnnotations.some(hoveredAnnotation => hoveredAnnotation.id === mark.attrs.id));
              if (isSupportedBlockNode) {
                focusDecorations.push(Decoration.node(pos, pos + node.nodeSize, {
                  class: `${getBlockAnnotationViewClassname(isUnresolved, isSelected)} ${isUnresolved}`
                }, {
                  key: decorationKey.block
                }));
              } else {
                if (fg('editor_inline_comments_on_inline_nodes')) {
                  if (node.isText) {
                    focusDecorations.push(Decoration.inline(pos, pos + node.nodeSize, {
                      class: `${getAnnotationViewClassname(isUnresolved, isSelected, isHovered)} ${isUnresolved}`,
                      nodeName: 'span'
                    }));
                  } else {
                    focusDecorations.push(Decoration.node(pos, pos + node.nodeSize, {
                      class: `${getAnnotationViewClassname(isUnresolved, isSelected, isHovered)} ${isUnresolved}`
                    }, {
                      key: decorationKey.block
                    }));
                  }
                } else {
                  focusDecorations.push(Decoration.inline(pos, pos + node.nodeSize, {
                    class: `${getAnnotationViewClassname(isUnresolved, isSelected, isHovered)} ${isUnresolved}`,
                    nodeName: 'span'
                  }));
                }
              }
            }
          });
        });
        decorations = decorations.add(state.doc, focusDecorations);
        return decorations;
      }
    }
  });
};