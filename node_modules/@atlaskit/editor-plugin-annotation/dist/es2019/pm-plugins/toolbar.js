import React from 'react';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD, MODE } from '@atlaskit/editor-common/analytics';
import { ToolTipContent, addInlineComment } from '@atlaskit/editor-common/keymaps';
import { currentMediaNodeWithPos } from '@atlaskit/editor-common/media-single';
import { annotationMessages } from '@atlaskit/editor-common/messages';
import { calculateToolbarPositionAboveSelection, calculateToolbarPositionTrackHead, getRangeInlineNodeNames } from '@atlaskit/editor-common/utils';
import CommentIcon from '@atlaskit/icon/core/comment';
import { fg } from '@atlaskit/platform-feature-flags';
import { setInlineCommentDraftState } from '../editor-commands';
import { AnnotationSelectionType, AnnotationTestIds } from '../types';
import { getPluginState, isSelectionValid, resolveDraftBookmark } from './utils';
export const getValidNodes = state => {
  const {
    schema
  } = state;
  const {
    annotation
  } = schema.marks;
  return Object.keys(schema.nodes).reduce((acc, current) => {
    const type = schema.nodes[current];
    if (type.allowsMarkType(annotation)) {
      acc.push(type);
    }
    return acc;
  }, []);
};
/**
 * Should suppress toolbars when the user is creating an inline comment
 * This only applies when the selection range exactly matches the bookmark range
 * which should be the case immediately after the comment button is clicked
 * if the user creates a different selection range, the floating toolbar should still be shown
 */
export const shouldSuppressFloatingToolbar = ({
  state,
  bookmark
}) => {
  if (!bookmark) {
    return false;
  }
  const {
    tr
  } = state;
  const resolvedBookmark = bookmark.resolve(tr.doc);
  const isSelectionMatchingBookmark = resolvedBookmark.to === tr.selection.to && resolvedBookmark.from === tr.selection.from;
  return isSelectionMatchingBookmark;
};
export const buildSuppressedToolbar = state => {
  return {
    items: [],
    nodeType: getValidNodes(state),
    title: 'Annotation suppressed toolbar',
    __suppressAllToolbars: true
  };
};
export const buildToolbar = editorAnalyticsAPI => ({
  state,
  intl,
  isToolbarAbove = false,
  _supportedNodes = [],
  api,
  createCommentExperience,
  annotationManager
}) => {
  var _api$connectivity, _api$connectivity$sha, _api$connectivity$sha2;
  const {
    schema
  } = state;
  const selectionValid = isSelectionValid(state);
  const isMediaSelected = currentMediaNodeWithPos(state);

  // comments on media can only be added via media floating toolbar
  if (isMediaSelected || selectionValid === AnnotationSelectionType.INVALID) {
    return undefined;
  }
  const createCommentMessage = intl.formatMessage(annotationMessages.createComment);
  const commentDisabledMessage = intl.formatMessage(fg('editor_inline_comments_on_inline_nodes') ? annotationMessages.createCommentDisabled : annotationMessages.createCommentInvalid);
  const createComment = {
    type: 'button',
    showTitle: true,
    disabled: selectionValid === AnnotationSelectionType.DISABLED || (api === null || api === void 0 ? void 0 : (_api$connectivity = api.connectivity) === null || _api$connectivity === void 0 ? void 0 : (_api$connectivity$sha = _api$connectivity.sharedState) === null || _api$connectivity$sha === void 0 ? void 0 : (_api$connectivity$sha2 = _api$connectivity$sha.currentState()) === null || _api$connectivity$sha2 === void 0 ? void 0 : _api$connectivity$sha2.mode) === 'offline',
    testId: AnnotationTestIds.floatingToolbarCreateButton,
    interactionName: 'start-inline-comment-action',
    icon: CommentIcon,
    iconFallback: CommentIcon,
    tooltipContent: selectionValid === AnnotationSelectionType.DISABLED ? commentDisabledMessage : /*#__PURE__*/React.createElement(ToolTipContent, {
      description: createCommentMessage,
      keymap: addInlineComment
    }),
    title: createCommentMessage,
    onMount: () => {
      var _getRangeInlineNodeNa;
      // Check if the selection includes an non-text inline node
      const inlineCommentPluginState = getPluginState(state);
      const inlineNodeNames = (_getRangeInlineNodeNa = getRangeInlineNodeNames({
        doc: state.doc,
        pos: resolveDraftBookmark(state, inlineCommentPluginState === null || inlineCommentPluginState === void 0 ? void 0 : inlineCommentPluginState.bookmark)
      })) !== null && _getRangeInlineNodeNa !== void 0 ? _getRangeInlineNodeNa : [];
      const isNonTextInlineNodeInludedInComment = inlineNodeNames.filter(nodeName => nodeName !== 'text').length > 0;
      if (editorAnalyticsAPI) {
        editorAnalyticsAPI.fireAnalyticsEvent({
          action: ACTION.VIEWED,
          actionSubject: ACTION_SUBJECT.BUTTON,
          actionSubjectId: ACTION_SUBJECT_ID.INLINE_COMMENT,
          eventType: EVENT_TYPE.UI,
          attributes: {
            isNonTextInlineNodeInludedInComment,
            isDisabled: selectionValid === AnnotationSelectionType.DISABLED,
            inputMethod: INPUT_METHOD.FLOATING_TB,
            mode: MODE.EDITOR
          }
        });
      }
    },
    onClick: (state, dispatch) => {
      if (editorAnalyticsAPI) {
        editorAnalyticsAPI.fireAnalyticsEvent({
          action: ACTION.CLICKED,
          actionSubject: ACTION_SUBJECT.BUTTON,
          actionSubjectId: ACTION_SUBJECT_ID.CREATE_INLINE_COMMENT_FROM_HIGHLIGHT_ACTIONS_MENU,
          eventType: EVENT_TYPE.UI,
          attributes: {
            source: 'highlightActionsMenu',
            pageMode: 'edit'
          }
        });
      }
      if (fg('platform_editor_comments_api_manager')) {
        if (!annotationManager) {
          // TODO: EDITOR-188 - If we've reached here and the manager is not initialized, we should
          // dispatch an analytics event to indicate that the user has clicked the button but
          // the action was not completed.
          return false;
        }
        annotationManager.checkPreemptiveGate().then(canStartDraft => {
          if (canStartDraft) {
            createCommentExperience === null || createCommentExperience === void 0 ? void 0 : createCommentExperience.start({
              attributes: {
                pageClass: 'editor',
                commentType: 'inline'
              }
            });
            createCommentExperience === null || createCommentExperience === void 0 ? void 0 : createCommentExperience.initExperience.start();
            const {
              success
            } = annotationManager.startDraft();
            if (!success) {
              // TODO: EDITOR-188 - Report start draft attempt failed.
            }
          } else {
            // TODO: EDITOR-188 - Dispatch analytics event
          }
        }).catch(() => {
          // TODO: EDITOR-188 - Handle preemptive gate check error and dispatch analytics event
        });
        return true;
      } else {
        createCommentExperience === null || createCommentExperience === void 0 ? void 0 : createCommentExperience.start({
          attributes: {
            pageClass: 'editor',
            commentType: 'inline'
          }
        });
        createCommentExperience === null || createCommentExperience === void 0 ? void 0 : createCommentExperience.initExperience.start();
        return setInlineCommentDraftState(editorAnalyticsAPI)(true)(state, dispatch);
      }
    },
    supportsViewMode: true // TODO: MODES-3950 - Clean up this floating toolbar view mode logic,
  };
  const {
    annotation
  } = schema.marks;
  const validNodes = Object.keys(schema.nodes).reduce((acc, current) => {
    const type = schema.nodes[current];
    if (type.allowsMarkType(annotation)) {
      acc.push(type);
    }
    return acc;
  }, []);
  const toolbarTitle = intl.formatMessage(annotationMessages.toolbar);
  const calcToolbarPosition = isToolbarAbove ? calculateToolbarPositionAboveSelection : calculateToolbarPositionTrackHead;
  const onPositionCalculated = calcToolbarPosition(toolbarTitle);
  return {
    title: toolbarTitle,
    nodeType: fg('platform_editor_fix_toolbar_comment_jump') ? getValidNodes(state) : validNodes,
    items: [createComment],
    onPositionCalculated,
    pluginName: 'annotation'
  };
};