"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startDraft = exports.getDraft = exports.clearDraft = exports.applyDraft = exports.allowAnnotation = void 0;
var _adfSchema = require("@atlaskit/adf-schema");
var _utils = require("@atlaskit/editor-common/utils");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _editorCommands = require("../editor-commands");
var _types = require("../types");
var _utils3 = require("./utils");
var ERROR_REASON_DRAFT_NOT_STARTED = 'draft-not-started';
var ERROR_REASON_DRAFT_IN_PROGRESS = 'draft-in-progress';
var ERROR_REASON_RANGE_MISSING = 'range-no-longer-exists';
var ERROR_REASON_RANGE_INVALID = 'invalid-range';
var domRefFromPos = function domRefFromPos(view, position) {
  var dom;
  try {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    dom = (0, _utils2.findDomRefAtPos)(position, view.domAtPos.bind(view));
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn(error);
    return undefined;
  }
  return dom;
};
var allowAnnotation = exports.allowAnnotation = function allowAnnotation(editorView, options) {
  return function () {
    var _ref = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref.isDrafting,
      draftDecorationSet = _ref.draftDecorationSet;
    if (isDrafting) {
      return false;
    }
    var decoration = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();

    // If a draft decoration exists then we should block the user from creating a new one.
    if (!!(decoration !== null && decoration !== void 0 && decoration.length)) {
      return false;
    }
    return (0, _utils3.isSelectionValid)(editorView.state) === _types.AnnotationSelectionType.VALID;
  };
};
var startDraft = exports.startDraft = function startDraft(editorView, options) {
  return function () {
    var _getRangeInlineNodeNa, _options$annotationMa;
    var _ref2 = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref2.isDrafting;
    if (isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_IN_PROGRESS
      };
    }
    (0, _editorCommands.setInlineCommentDraftState)(options.editorAnalyticsAPI)(true)(editorView.state, editorView.dispatch);
    var _ref3 = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      draftDecorationSet = _ref3.draftDecorationSet;
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();

    // If the matching decorations is not found containing the id, it means something went wrong with the draft.
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_RANGE_INVALID
      };
    }
    var from = decorations[0].from;
    var targetElement = domRefFromPos(editorView, from);
    var inlineNodeTypes = (_getRangeInlineNodeNa = (0, _utils.getRangeInlineNodeNames)({
      doc: editorView.state.doc,
      pos: {
        from: from,
        to: decorations[decorations.length - 1].to
      }
    })) !== null && _getRangeInlineNodeNa !== void 0 ? _getRangeInlineNodeNa : [];
    (_options$annotationMa = options.annotationManager) === null || _options$annotationMa === void 0 || _options$annotationMa.emit({
      name: 'draftAnnotationStarted',
      data: {
        targetElement: targetElement,
        actionResult: undefined,
        inlineNodeTypes: inlineNodeTypes
      }
    });
    return {
      success: true,
      targetElement: targetElement,
      // In Editor the action result is undefined, because the editor will perform the transaction on the document.
      actionResult: undefined,
      inlineNodeTypes: inlineNodeTypes
    };
  };
};
var clearDraft = exports.clearDraft = function clearDraft(editorView, options) {
  return function () {
    var _ref4 = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref4.isDrafting,
      draftDecorationSet = _ref4.draftDecorationSet;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    (0, _editorCommands.setInlineCommentDraftState)(options.editorAnalyticsAPI)(false)(editorView.state, editorView.dispatch);
    !editorView.hasFocus() && editorView.focus();
    return {
      success: true
    };
  };
};
var applyDraft = exports.applyDraft = function applyDraft(editorView, options) {
  return function (id) {
    var _ref5 = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref5.isDrafting,
      draftDecorationSet = _ref5.draftDecorationSet,
      bookmark = _ref5.bookmark;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length) || !bookmark) {
      return {
        success: false,
        reason: ERROR_REASON_RANGE_MISSING
      };
    }
    var from = decorations[0].from;
    (0, _editorCommands.createAnnotation)(options.editorAnalyticsAPI, options.api)(id, _adfSchema.AnnotationTypes.INLINE_COMMENT, options.provider.supportedBlockNodes)(editorView.state, editorView.dispatch);
    !editorView.hasFocus() && editorView.focus();

    // Using the original decoration from position we should be able to locate the new target element.
    // This is because the new annotation will be created at the same position as the draft decoration.
    var targetElement = domRefFromPos(editorView, from);
    return {
      success: true,
      // Get the dom element from the newly created annotation and return it here.
      targetElement: targetElement
    };
  };
};
var getDraft = exports.getDraft = function getDraft(editorView, options) {
  return function () {
    var _getRangeInlineNodeNa2;
    var _ref6 = _utils3.inlineCommentPluginKey.getState(editorView.state) || {},
      isDrafting = _ref6.isDrafting,
      draftDecorationSet = _ref6.draftDecorationSet;
    if (!isDrafting) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var decorations = draftDecorationSet === null || draftDecorationSet === void 0 ? void 0 : draftDecorationSet.find();
    if (!(decorations !== null && decorations !== void 0 && decorations.length)) {
      return {
        success: false,
        reason: ERROR_REASON_DRAFT_NOT_STARTED
      };
    }
    var from = decorations[0].from;
    var targetElement = domRefFromPos(editorView, from);
    var inlineNodeTypes = (_getRangeInlineNodeNa2 = (0, _utils.getRangeInlineNodeNames)({
      doc: editorView.state.doc,
      pos: {
        from: from,
        to: decorations[decorations.length - 1].to
      }
    })) !== null && _getRangeInlineNodeNa2 !== void 0 ? _getRangeInlineNodeNa2 : [];
    return {
      success: true,
      inlineNodeTypes: inlineNodeTypes,
      targetElement: targetElement,
      actionResult: undefined
    };
  };
};