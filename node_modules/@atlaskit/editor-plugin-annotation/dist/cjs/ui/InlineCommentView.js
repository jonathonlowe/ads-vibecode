"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InlineCommentView = InlineCommentView;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _adfSchema = require("@atlaskit/adf-schema");
var _analytics = require("@atlaskit/editor-common/analytics");
var _utils = require("@atlaskit/editor-common/utils");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _editorCommands = require("../editor-commands");
var _utils3 = require("../pm-plugins/utils");
var _types = require("../types");
var _AnnotationViewWrapper = require("./AnnotationViewWrapper");
var findPosForDOM = function findPosForDOM(sel) {
  var $from = sel.$from,
    from = sel.from;

  // Retrieve current TextNode
  var index = $from.index();
  var node = index < $from.parent.childCount && $from.parent.child(index);

  // Right edge of a mark.
  if (!node && $from.nodeBefore && $from.nodeBefore.isText && $from.nodeBefore.marks.find(function (mark) {
    return mark.type.name === 'annotation';
  })) {
    return from - 1;
  }
  return from;
};
function InlineCommentView(_ref) {
  var providers = _ref.providers,
    editorView = _ref.editorView,
    editorAnalyticsAPI = _ref.editorAnalyticsAPI,
    editorAPI = _ref.editorAPI,
    dispatchAnalyticsEvent = _ref.dispatchAnalyticsEvent;
  // As inlineComment is the only annotation present, this function is not generic
  var inlineCommentProvider = providers.inlineComment;
  var state = editorView.state,
    dispatch = editorView.dispatch;
  var CreateComponent = inlineCommentProvider.createComponent,
    ViewComponent = inlineCommentProvider.viewComponent;
  var inlineCommentState = (0, _utils3.getPluginState)(state);
  var _ref2 = inlineCommentState || {},
    bookmark = _ref2.bookmark,
    selectedAnnotations = _ref2.selectedAnnotations,
    annotations = _ref2.annotations,
    isInlineCommentViewClosed = _ref2.isInlineCommentViewClosed,
    isOpeningMediaCommentFromToolbar = _ref2.isOpeningMediaCommentFromToolbar;
  var annotationsList = (0, _utils3.getAllAnnotations)(editorView.state.doc);
  var selection = (0, _utils3.getSelectionPositions)(state, inlineCommentState);
  var position = findPosForDOM(selection);
  var dom;
  try {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    dom = (0, _utils2.findDomRefAtPos)(position, editorView.domAtPos.bind(editorView));
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn(error);
    if (dispatchAnalyticsEvent) {
      var payload = {
        action: _analytics.ACTION.ERRORED,
        actionSubject: _analytics.ACTION_SUBJECT.CONTENT_COMPONENT,
        eventType: _analytics.EVENT_TYPE.OPERATIONAL,
        attributes: {
          component: _analytics.CONTENT_COMPONENT.INLINE_COMMENT,
          selection: selection.toJSON(),
          position: position,
          docSize: editorView.state.doc.nodeSize,
          error: error.toString()
        }
      };
      dispatchAnalyticsEvent(payload);
    }
  }
  if (!dom) {
    return null;
  }

  // Create Component
  if (bookmark) {
    if (!CreateComponent) {
      return null;
    }
    var inlineNodeTypes = (0, _utils.getRangeInlineNodeNames)({
      doc: state.doc,
      pos: selection
    });

    //getting all text between bookmarked positions
    var textSelection = state.doc.textBetween(selection.from, selection.to);
    return /*#__PURE__*/_react.default.createElement("div", {
      "data-testid": _types.AnnotationTestIds.floatingComponent,
      "data-editor-popup": "true"
    }, /*#__PURE__*/_react.default.createElement(CreateComponent, {
      dom: dom,
      textSelection: textSelection,
      onCreate: function onCreate(id) {
        if (!(0, _platformFeatureFlags.fg)('platform_editor_comments_api_manager')) {
          var createAnnotationResult = (0, _editorCommands.createAnnotation)(editorAnalyticsAPI, editorAPI)(id, _adfSchema.AnnotationTypes.INLINE_COMMENT, inlineCommentProvider.supportedBlockNodes)(editorView.state, editorView.dispatch);
          !editorView.hasFocus() && editorView.focus();
          if (!createAnnotationResult && (0, _platformFeatureFlags.fg)('confluence_frontend_handle_annotation_error')) {
            throw new Error('Failed to create annotation');
          }
        }
      },
      onClose: function onClose() {
        if (!(0, _platformFeatureFlags.fg)('platform_editor_comments_api_manager')) {
          (0, _editorCommands.setInlineCommentDraftState)(editorAnalyticsAPI)(false)(editorView.state, editorView.dispatch);
          !editorView.hasFocus() && editorView.focus();
        }
      },
      inlineNodeTypes: inlineNodeTypes,
      isOpeningMediaCommentFromToolbar: isOpeningMediaCommentFromToolbar
    }));
  }

  // View Component
  var activeAnnotations = (selectedAnnotations === null || selectedAnnotations === void 0 ? void 0 : selectedAnnotations.filter(function (mark) {
    return annotations && annotations[mark.id] === false;
  })) || [];
  if (!ViewComponent || activeAnnotations.length === 0) {
    return null;
  }
  var onAnnotationViewed = function onAnnotationViewed() {
    var _editorView$state$doc;
    if (!dispatchAnalyticsEvent) {
      return;
    }
    var _ref3 = inlineCommentState || {},
      selectAnnotationMethod = _ref3.selectAnnotationMethod;

    // fire analytics
    var payload = {
      action: _analytics.ACTION.VIEWED,
      actionSubject: _analytics.ACTION_SUBJECT.ANNOTATION,
      actionSubjectId: _analytics.ACTION_SUBJECT_ID.INLINE_COMMENT,
      eventType: _analytics.EVENT_TYPE.TRACK,
      attributes: {
        overlap: activeAnnotations.length ? activeAnnotations.length - 1 : 0,
        targetNodeType: (_editorView$state$doc = editorView.state.doc.nodeAt(position)) === null || _editorView$state$doc === void 0 ? void 0 : _editorView$state$doc.type.name,
        method: selectAnnotationMethod
      }
    };
    dispatchAnalyticsEvent(payload);
  };
  if (isInlineCommentViewClosed || !selectedAnnotations) {
    return null;
  }

  // For view mode, the finding of inline node types is a bit more complex,
  // that's why we will not provide it as a `inlineNodeTypes` props to the view component,
  // to speed up the rendering process.
  var getInlineNodeTypes = function getInlineNodeTypes(annotationId) {
    return (0, _utils.getAnnotationInlineNodeTypes)(editorView.state, annotationId);
  };
  return /*#__PURE__*/_react.default.createElement(_AnnotationViewWrapper.AnnotationViewWrapper, {
    "data-editor-popup": "true",
    "data-testid": _types.AnnotationTestIds.floatingComponent,
    key: (0, _utils3.getAnnotationViewKey)(activeAnnotations),
    onViewed: onAnnotationViewed
  }, /*#__PURE__*/_react.default.createElement(ViewComponent, {
    annotationsList: annotationsList,
    annotations: activeAnnotations,
    getInlineNodeTypes: getInlineNodeTypes,
    dom: dom,
    onDelete: function onDelete(id) {
      return (0, _editorCommands.removeInlineCommentNearSelection)(id, inlineCommentProvider.supportedBlockNodes)(editorView.state, dispatch);
    },
    onResolve: function onResolve(id) {
      return (0, _editorCommands.updateInlineCommentResolvedState)(editorAnalyticsAPI)((0, _defineProperty2.default)({}, id, true), _analytics.RESOLVE_METHOD.COMPONENT)(editorView.state, editorView.dispatch);
    },
    onClose: function onClose() {
      (0, _editorCommands.closeComponent)()(editorView.state, editorView.dispatch);
    },
    isOpeningMediaCommentFromToolbar: isOpeningMediaCommentFromToolbar
  }));
}