import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _typeof from "@babel/runtime/helpers/typeof";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// Disable no-re-export rule for entry point files
/* eslint-disable @atlaskit/editor/no-re-export */

import isEqual from 'lodash/isEqual';
import { codeBlockToJSON, dataConsumerToJSON, expandToJSON, fragmentToJSON, linkToJSON, mediaSingleToJSON, mediaToJSON, mentionToJSON, tableToJSON, toJSONTableCell, toJSONTableHeader } from '@atlaskit/adf-schema';
import { defaultSchema, getSchemaBasedOnStage } from '@atlaskit/adf-schema/schema-default';
import { markOverrideRuleFor } from './markOverrideRules';
import { sanitizeNode } from './sanitize/sanitize-node';
export var SchemaStage = /*#__PURE__*/function (SchemaStage) {
  SchemaStage["FINAL"] = "final";
  SchemaStage["STAGE_0"] = "stage0";
  return SchemaStage;
}({});
var isType = function isType(type) {
  return function (node) {
    return node.type.name === type;
  };
};
var isCodeBlock = isType('codeBlock');
var isMediaNode = isType('media');
var isMediaInline = isType('mediaInline');
var isMediaSingleNode = isType('mediaSingle');
var isMentionNode = isType('mention');
var isParagraph = isType('paragraph');
var isHeading = isType('heading');
var isTable = isType('table');
var isTableCell = isType('tableCell');
var isTableHeader = isType('tableHeader');
var isLinkMark = isType('link');
var isUnsupportedMark = isType('unsupportedMark');
var isUnsupportedNodeAttributeMark = isType('unsupportedNodeAttribute');
var isExpand = isType('expand');
var isNestedExpand = isType('nestedExpand');
var isUnsupportedNode = function isUnsupportedNode(node) {
  return isType('unsupportedBlock')(node) || isType('unsupportedInline')(node);
};
var isDataConsumer = isType('dataConsumer');
var isFragmentMark = isType('fragment');
var isHardBreak = isType('hardBreak');

// eslint-disable-next-line @typescript-eslint/no-explicit-any
var _filterNull = function filterNull(subject) {
  var output = _objectSpread({}, subject);
  // eslint-disable-next-line guard-for-in
  for (var key in output) {
    var current = output[key];
    if (current === null) {
      var _output = output,
        unusedKey = _output[key],
        filteredObj = _objectWithoutProperties(_output, [key].map(_toPropertyKey));
      output = filteredObj;
    } else if (_typeof(current) === 'object' && !Array.isArray(current)) {
      output[key] = _filterNull(current);
    }
  }
  return output;
};
var createDocFromContent = function createDocFromContent(content) {
  return {
    version: 1,
    type: 'doc',
    content: content || []
  };
};
var emptyDoc = createDocFromContent([{
  type: 'paragraph',
  content: []
}]);
var _toJSON = function toJSON(node, mentionMap) {
  var obj = {
    type: node.type.name
  };
  if (isUnsupportedNode(node)) {
    return node.attrs.originalValue;
  } else if (isMediaNode(node)) {
    obj.attrs = mediaToJSON(node).attrs;
  } else if (isMediaSingleNode(node)) {
    obj.attrs = mediaSingleToJSON(node).attrs;
  } else if (isMediaInline(node)) {
    obj.attrs = mediaToJSON(node).attrs;
  } else if (isMentionNode(node)) {
    obj.attrs = mentionToJSON(node).attrs;
  } else if (isCodeBlock(node)) {
    obj.attrs = codeBlockToJSON(node).attrs;
  } else if (isTable(node)) {
    obj.attrs = tableToJSON(node).attrs;
  } else if (isTableCell(node)) {
    obj.attrs = toJSONTableCell(node).attrs;
  } else if (isTableHeader(node)) {
    obj.attrs = toJSONTableHeader(node).attrs;
  } else if (isExpand(node) || isNestedExpand(node)) {
    obj.attrs = expandToJSON(node).attrs;
  } else if (node.attrs && Object.keys(node.attrs).length) {
    obj.attrs = node.attrs;
  }
  if (obj.attrs) {
    obj.attrs = _filterNull(obj.attrs);
  }
  if (isMentionNode(node) && mentionMap) {
    var _text, _obj$attrs;
    // If the mentionMap exists and has a name defined then we should use it and prepend @ to the begining of it.
    var name = !!(mentionMap !== null && mentionMap !== void 0 && mentionMap[node.attrs.id]) ? "@".concat(mentionMap[node.attrs.id]) : '';
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var text = (_text = (_obj$attrs = obj.attrs) === null || _obj$attrs === void 0 ? void 0 : _obj$attrs.text) !== null && _text !== void 0 ? _text : '';
    obj.attrs = _objectSpread(_objectSpread({}, obj.attrs), {}, {
      // If an explicit text value is set on the mention then that should take priority over the mentionMap value.
      text: !!text ? text : name
    });
  }

  // Remove the attrs property if it's empty, this is currently limited to paragraph nodes.
  if (isParagraph(node) && obj.attrs && !Object.keys(obj.attrs).length) {
    delete obj.attrs;
  }

  // Hard break has optional attr.text which was added for PM <-> ADF compatibility.
  // No need to preserve it.
  if (isHardBreak(node)) {
    delete obj.attrs;
  }
  if (node.isText) {
    obj.text = node.textContent;
  } else {
    node.content.forEach(function (child) {
      obj.content = obj.content || [];
      obj.content.push(_toJSON(child, mentionMap));
    });
  }
  if (isParagraph(node) || isHeading(node)) {
    obj.content = obj.content || [];
  }
  if (node.marks.length) {
    // Run any custom mark serialisers
    var parsedMarks = node.marks.map(function (mark) {
      if (isUnsupportedMark(mark)) {
        return canOverrideMark(mark, node.marks) ? null : mark.attrs.originalValue;
      } else if (isUnsupportedNodeAttributeMark(mark)) {
        return null;
      } else if (isLinkMark(mark)) {
        return linkToJSON(mark);
      } else if (isDataConsumer(mark)) {
        var _serialised$attrs$sou;
        var serialised = dataConsumerToJSON(mark);
        return !serialised.attrs.sources || ((_serialised$attrs$sou = serialised.attrs.sources) === null || _serialised$attrs$sou === void 0 ? void 0 : _serialised$attrs$sou.length) === 0 ? null : serialised;
      } else if (isFragmentMark(mark)) {
        var fragmentMark = fragmentToJSON(mark);
        if (!fragmentMark.attrs.localId) {
          return null;
        }
        return fragmentMark;
      } else {
        return mark.toJSON();
      }
    }).filter(function (maybeMark) {
      return maybeMark !== null;
    });

    // Only set if we have a non-empty array, otherwise explicitly undefine it (as we only run this path if `node.marks.length`)
    obj.marks = (parsedMarks === null || parsedMarks === void 0 ? void 0 : parsedMarks.length) > 0 ? parsedMarks : undefined;
    var nodeAttributeMark = node.marks.find(isUnsupportedNodeAttributeMark);
    if (nodeAttributeMark && nodeAttributeMark.attrs.type.nodeType === obj.type) {
      obj.attrs = _objectSpread({}, getUnwrappedNodeAttributes(node, nodeAttributeMark, obj));
    }
  }
  return obj;
};
var canOverrideMark = function canOverrideMark(mark, existingMarks) {
  if (existingMarks.some(function (e) {
    return mark.attrs.originalValue.type === e.type.name;
  })) {
    return markOverrideRuleFor(mark.attrs.originalValue.type).canOverrideUnsupportedMark();
  }
  return false;
};
var getUnwrappedNodeAttributes = function getUnwrappedNodeAttributes(node, mark, obj) {
  var nodeAttributes = node.type.spec.attrs;
  var attributes = _objectSpread(_objectSpread({}, mark.attrs.unsupported), obj.attrs);
  // Ignored via go/ees005
  // eslint-disable-next-line no-var
  for (var key in obj.attrs) {
    if (obj.attrs.hasOwnProperty(key)) {
      var attribute = nodeAttributes ? nodeAttributes[key] : null;
      if (attribute) {
        if (attribute.default === node.attrs[key] && mark.attrs.unsupported[key]) {
          return _objectSpread(_objectSpread({}, attributes), {}, _defineProperty({}, key, mark.attrs.unsupported[key]));
        }
      }
    }
  }
  return attributes;
};
export var JSONTransformer = /*#__PURE__*/function () {
  /**
   * @param schema The current editor schema
   * @param mentionMap An optional mapping of user IDs to mention names. This is used by the encoder to substitute empty
   * mention node.attr.text values with mapped names.
   */
  function JSONTransformer() {
    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSchema;
    var mentionMap = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, JSONTransformer);
    this.schema = schema;
    this.mentionMap = mentionMap;
  }
  return _createClass(JSONTransformer, [{
    key: "encode",
    value: function encode(node) {
      var _this = this;
      var content = [];
      node.content.forEach(function (child) {
        content.push(sanitizeNode(_toJSON(child, _this.mentionMap)));
      });
      if (!content || isEqual(content, emptyDoc.content)) {
        return createDocFromContent([]);
      }
      return createDocFromContent(content);
    }
  }, {
    key: "internalParse",
    value: function internalParse(content, schema) {
      var doc = schema.nodeFromJSON(content);
      doc.check();
      return doc;
    }
  }, {
    key: "parse",
    value: function parse(content, stage) {
      if (content.type !== 'doc') {
        throw new Error('Expected content format to be ADF');
      }
      var schema = !!stage ? getSchemaBasedOnStage(stage) : this.schema;
      if (!content.content || content.content.length === 0) {
        return this.internalParse(emptyDoc, schema);
      }
      return this.internalParse(content, schema);
    }

    /**
     * This method is used to encode a single node
     */
  }, {
    key: "encodeNode",
    value: function encodeNode(node) {
      return sanitizeNode(_toJSON(node, this.mentionMap));
    }
  }]);
}();