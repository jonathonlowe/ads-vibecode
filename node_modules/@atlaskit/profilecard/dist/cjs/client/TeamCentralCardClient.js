"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.buildReportingLinesQuery = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _CachingClient2 = _interopRequireDefault(require("./CachingClient"));
var _getOrgIdForCloudIdFromAGG = require("./getOrgIdForCloudIdFromAGG");
var _graphqlUtils = require("./graphqlUtils");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var UNSHARDED_PREFIX = '/gateway/api/watermelon';
var buildReportingLinesQuery = exports.buildReportingLinesQuery = function buildReportingLinesQuery(aaid) {
  return {
    query: "\n    fragment ReportingLinesUserPII on UserPII {\n      name\n      picture\n    }\n\n    fragment ReportingLinesUserFragment on ReportingLinesUser {\n      accountIdentifier\n      identifierType\n      pii {\n        ...ReportingLinesUserPII\n      }\n    }\n\n    query ReportingLines($aaid: String) {\n      reportingLines(aaidOrHash: $aaid) {\n        managers {\n          ...ReportingLinesUserFragment\n        }\n        reports {\n          ...ReportingLinesUserFragment\n        }\n      }\n    }\n  ",
    variables: {
      aaid: aaid
    }
  };
};
var orgContainsAnyWorkspacePromiseCache = new Map();
var orgIdPromiseCache = new Map();
var workspaceExistsWithTypePromiseCache = new Map();
var TeamCentralCardClient = /*#__PURE__*/function (_CachingClient) {
  /**
   * Simple circuit breaker to avoid making unnecessary calls to Team Central on auth failures
   * This is to handle the case where products may have provided teamCentralUrl, but the site itself
   * doesn't actually have any TC product.
   *
   * There's currently no way to reset this circuit breaker, but that's fine. This is meant to
   * catch a pretty specific edge case.
   */

  function TeamCentralCardClient(options) {
    var _this;
    (0, _classCallCheck2.default)(this, TeamCentralCardClient);
    _this = _callSuper(this, TeamCentralCardClient, [options]);
    _this.options = options;
    _this.bypassOnFailure = false;
    _this.orgContainsAnyWorkspacePromise = _this.createOrgContainsAnyWorkspacePromise(options);
    _this.workspaceExistsWithTypePromise = _this.preloadWorkspaceExistsWithType(options.cloudId);
    _this.orgIdPromise = _this.preloadOrgId(options.gatewayGraphqlUrl, options.cloudId, options.orgId);
    return _this;
  }
  (0, _inherits2.default)(TeamCentralCardClient, _CachingClient);
  return (0, _createClass2.default)(TeamCentralCardClient, [{
    key: "createOrgContainsAnyWorkspacePromise",
    value: function createOrgContainsAnyWorkspacePromise(config) {
      if (config.cloudId) {
        var promise = orgContainsAnyWorkspacePromiseCache.get(config.cloudId);
        if (!promise) {
          promise = this.getOrgContainsAnyWorkspace(config.cloudId);
          orgContainsAnyWorkspacePromiseCache.set(config.cloudId, promise);
        }
        return promise;
      }
      return Promise.resolve(true);
    }
  }, {
    key: "getReportingLines",
    value: function getReportingLines(userId) {
      var _this2 = this;
      return this.orgContainsAnyWorkspacePromise.then(function (orgContainsAnyWorkspace) {
        if (orgContainsAnyWorkspace) {
          if (!userId) {
            return Promise.reject(new Error('userId missing'));
          }
          var cache = _this2.getCachedProfile(userId);
          if (cache) {
            return Promise.resolve(cache);
          }
          if (_this2.bypassOnFailure) {
            return Promise.resolve({});
          }
          return new Promise(function (resolve) {
            _this2.makeRequest(userId).then(function (data) {
              var enhancedData = {
                managers: _this2.filterReportingLinesUser(data === null || data === void 0 ? void 0 : data.managers),
                reports: _this2.filterReportingLinesUser(data === null || data === void 0 ? void 0 : data.reports)
              };
              if (_this2.cache) {
                _this2.setCachedProfile(userId, enhancedData);
              }
              resolve(enhancedData);
            }).catch(function (error) {
              if ((error === null || error === void 0 ? void 0 : error.status) === 401 || (error === null || error === void 0 ? void 0 : error.status) === 403) {
                // Trigger circuit breaker
                _this2.bypassOnFailure = true;
              }

              /**
               * Reporting lines aren't part of the critical path of profile card.
               * Just resolve with empty values instead of bubbling up the error.
               */
              resolve({});
            });
          });
        }
        return Promise.resolve({
          managers: [],
          reports: []
        });
      }, function () {
        return Promise.resolve({
          managers: [],
          reports: []
        });
      });
    }

    /**
     * `public` so that mock client can override it; do not use it otherwise!
     */
  }, {
    key: "makeRequest",
    value: (function () {
      var _makeRequest = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(userId) {
        var query, response;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.options.teamCentralDisabled === true)) {
                _context.next = 2;
                break;
              }
              throw new Error('makeRequest cannot be called when the client has been disabled');
            case 2:
              query = buildReportingLinesQuery(userId);
              _context.next = 5;
              return (0, _graphqlUtils.directoryGraphqlQuery)('/gateway/api/watermelon/graphql?operationName=ReportingLines', query);
            case 5:
              response = _context.sent;
              return _context.abrupt("return", response.reportingLines);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function makeRequest(_x) {
        return _makeRequest.apply(this, arguments);
      }
      return makeRequest;
    }())
  }, {
    key: "checkWorkspaceExists",
    value: function () {
      var _checkWorkspaceExists = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var workspaceExistsPromise;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              workspaceExistsPromise = (0, _platformFeatureFlags.fg)('enable_ptc_townsquare_reporting_lines_unsharded') ? this.workspaceExistsWithTypePromise.then(function (workspaceExistsWithType) {
                return workspaceExistsWithType !== undefined;
              }) : this.orgContainsAnyWorkspacePromise;
              return _context2.abrupt("return", workspaceExistsPromise.then(function (workspaceExistsWithType) {
                if (workspaceExistsWithType) {
                  return Promise.resolve(true);
                }
                return Promise.resolve(false);
              }, function () {
                return Promise.resolve(false);
              }));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function checkWorkspaceExists() {
        return _checkWorkspaceExists.apply(this, arguments);
      }
      return checkWorkspaceExists;
    }()
  }, {
    key: "getIsGlobalExperienceWorkspace",
    value: function () {
      var _getIsGlobalExperienceWorkspace = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.workspaceExistsWithTypePromise;
            case 2:
              _context3.t0 = _context3.sent;
              return _context3.abrupt("return", _context3.t0 === 'GLOBAL_EXPERIENCE');
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getIsGlobalExperienceWorkspace() {
        return _getIsGlobalExperienceWorkspace.apply(this, arguments);
      }
      return getIsGlobalExperienceWorkspace;
    }()
  }, {
    key: "getOrgId",
    value: function getOrgId() {
      return this.orgIdPromise;
    }
  }, {
    key: "preloadWorkspaceExistsWithType",
    value: function preloadWorkspaceExistsWithType(cloudId) {
      if (cloudId === undefined) {
        return Promise.resolve(undefined);
      }
      var maybeWorkspaceExistsWithTypePromise = workspaceExistsWithTypePromiseCache.get(cloudId);
      if (maybeWorkspaceExistsWithTypePromise !== undefined) {
        return maybeWorkspaceExistsWithTypePromise;
      }
      var workspaceExistsWithTypePromise = this.getWorkspaceExistsWithType(cloudId);
      workspaceExistsWithTypePromiseCache.set(cloudId, workspaceExistsWithTypePromise);
      return workspaceExistsWithTypePromise;
    }
  }, {
    key: "getOrgContainsAnyWorkspace",
    value: function getOrgContainsAnyWorkspace(cloudId) {
      if (cloudId) {
        return fetch(((0, _platformFeatureFlags.fg)('enable_ptc_townsquare_reporting_lines_unsharded') ? UNSHARDED_PREFIX : this.getShardedApiPath(cloudId)) + "/organization/containsAnyWorkspace?cloudId=".concat(cloudId)).then(function (res) {
          return !res || res && res.ok;
        });
      } else {
        return Promise.resolve(false);
      }
    }
  }, {
    key: "getWorkspaceExistsWithType",
    value: function () {
      var _getWorkspaceExistsWithType = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(cloudId) {
        var response, workspaceType;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return fetch("".concat(this.getShardedApiPath(cloudId), "/workspace/existsWithWorkspaceType?cloudId=").concat(cloudId), {
                credentials: 'include'
              });
            case 3:
              response = _context4.sent;
              if (!response.ok) {
                _context4.next = 9;
                break;
              }
              _context4.next = 7;
              return response.text();
            case 7:
              workspaceType = _context4.sent;
              return _context4.abrupt("return", Promise.resolve(workspaceType));
            case 9:
              _context4.next = 14;
              break;
            case 11:
              _context4.prev = 11;
              _context4.t0 = _context4["catch"](0);
              return _context4.abrupt("return", Promise.resolve(undefined));
            case 14:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 11]]);
      }));
      function getWorkspaceExistsWithType(_x2) {
        return _getWorkspaceExistsWithType.apply(this, arguments);
      }
      return getWorkspaceExistsWithType;
    }()
  }, {
    key: "preloadOrgId",
    value: function preloadOrgId(gatewayGraphqlUrl, cloudId, orgId) {
      if (cloudId === undefined) {
        return Promise.resolve(null);
      }
      if (orgId !== undefined) {
        return Promise.resolve(orgId);
      }
      var maybeOrgIdForCloudIdPromise = orgIdPromiseCache.get(cloudId);
      if (maybeOrgIdForCloudIdPromise !== undefined) {
        return maybeOrgIdForCloudIdPromise;
      }
      var orgIdForCloudIdPromise = (0, _getOrgIdForCloudIdFromAGG.getOrgIdForCloudIdFromAGG)(gatewayGraphqlUrl, cloudId);
      orgIdPromiseCache.set(cloudId, orgIdForCloudIdPromise);
      return orgIdForCloudIdPromise;
    }
  }, {
    key: "getShardedApiPath",
    value: function getShardedApiPath(cloudId) {
      return "/gateway/api/townsquare/s/".concat(cloudId);
    }
  }, {
    key: "filterReportingLinesUser",
    value: function filterReportingLinesUser() {
      var users = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return users.filter(function (user) {
        return user.identifierType === 'ATLASSIAN_ID';
      });
    }
  }]);
}(_CachingClient2.default);
var _default = exports.default = TeamCentralCardClient;