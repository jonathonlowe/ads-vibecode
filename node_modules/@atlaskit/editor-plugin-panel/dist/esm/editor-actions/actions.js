import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { PanelType } from '@atlaskit/adf-schema';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { getPanelTypeBackgroundNoTokens } from '@atlaskit/editor-common/panel';
import { wrapSelectionIn } from '@atlaskit/editor-common/utils';
import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { findParentNodeOfType, findSelectedNodeOfType, removeParentNodeOfType, removeSelectedNode } from '@atlaskit/editor-prosemirror/utils';
import { findPanel } from '../pm-plugins/utils/utils';
export var removePanel = function removePanel(editorAnalyticsAPI) {
  return function (state, dispatch) {
    var nodes = state.schema.nodes,
      tr = state.tr;
    var payload = {
      action: ACTION.DELETED,
      actionSubject: ACTION_SUBJECT.PANEL,
      attributes: {
        inputMethod: INPUT_METHOD.TOOLBAR
      },
      eventType: EVENT_TYPE.TRACK
    };
    var deleteTr = tr;
    if (findSelectedNodeOfType(nodes.panel)(tr.selection)) {
      deleteTr = removeSelectedNode(tr);
    } else if (findParentNodeOfType(nodes.panel)(tr.selection)) {
      deleteTr = removeParentNodeOfType(nodes.panel)(tr);
    }
    if (!deleteTr) {
      return false;
    }
    if (dispatch) {
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(deleteTr);
      dispatch(deleteTr);
    }
    return true;
  };
};
export var changePanelType = function changePanelType(editorAnalyticsAPI) {
  return function (panelType) {
    var panelOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var allowCustomPanel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return function (state, dispatch) {
      var nodes = state.schema.nodes,
        tr = state.tr;
      var panelNode = findPanel(state);
      if (panelNode === undefined) {
        return false;
      }
      var newType = panelType;
      var previousType = panelNode.node.attrs.panelType;
      var newTr;
      if (allowCustomPanel) {
        var previousColor = panelNode.node.attrs.panelType === 'custom' ? panelNode.node.attrs.panelColor || 'none' : getPanelTypeBackgroundNoTokens(previousType);
        var previousIcon = panelNode.node.attrs.panelIcon;
        var previousIconId = panelNode.node.attrs.panelIconId;
        var previousIconText = panelNode.node.attrs.panelIconText;
        var newPanelOptions = _objectSpread({
          color: previousColor,
          emoji: previousIcon,
          emojiId: previousIconId,
          emojiText: previousIconText
        }, panelOptions);
        newTr = tr.setNodeMarkup(panelNode.pos, nodes.panel, {
          panelIcon: newPanelOptions.emoji,
          panelIconId: newPanelOptions.emojiId,
          panelIconText: newPanelOptions.emojiText,
          panelColor: newPanelOptions.color,
          panelType: panelType
        });
      } else {
        newTr = tr.setNodeMarkup(panelNode.pos, nodes.panel, {
          panelType: panelType
        });
      }
      var payload = {
        action: ACTION.CHANGED_TYPE,
        actionSubject: ACTION_SUBJECT.PANEL,
        attributes: {
          newType: newType,
          previousType: previousType
        },
        eventType: EVENT_TYPE.TRACK
      };

      // Select the panel if it was previously selected
      var newTrWithSelection = state.selection instanceof NodeSelection && state.selection.node.type.name === 'panel' ? newTr.setSelection(new NodeSelection(tr.doc.resolve(panelNode.pos))) : newTr;
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(newTrWithSelection);
      newTrWithSelection.setMeta('scrollIntoView', false);
      if (dispatch) {
        dispatch(newTrWithSelection);
      }
      return true;
    };
  };
};
export function insertPanelWithAnalytics(inputMethod, analyticsAPI) {
  return withAnalytics(analyticsAPI, {
    action: ACTION.INSERTED,
    actionSubject: ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: ACTION_SUBJECT_ID.PANEL,
    attributes: {
      inputMethod: inputMethod,
      panelType: PanelType.INFO // only info panels can be inserted via this action
    },
    eventType: EVENT_TYPE.TRACK
  })(function (state, dispatch) {
    var nodes = state.schema.nodes;
    if (nodes.panel && nodes.paragraph) {
      return wrapSelectionIn(nodes.panel)(state, dispatch);
    }
    return false;
  });
}