"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changePanelType = void 0;
exports.insertPanelWithAnalytics = insertPanelWithAnalytics;
exports.removePanel = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _adfSchema = require("@atlaskit/adf-schema");
var _analytics = require("@atlaskit/editor-common/analytics");
var _editorAnalytics = require("@atlaskit/editor-common/editor-analytics");
var _panel = require("@atlaskit/editor-common/panel");
var _utils = require("@atlaskit/editor-common/utils");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils2 = require("@atlaskit/editor-prosemirror/utils");
var _utils3 = require("../pm-plugins/utils/utils");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var removePanel = exports.removePanel = function removePanel(editorAnalyticsAPI) {
  return function (state, dispatch) {
    var nodes = state.schema.nodes,
      tr = state.tr;
    var payload = {
      action: _analytics.ACTION.DELETED,
      actionSubject: _analytics.ACTION_SUBJECT.PANEL,
      attributes: {
        inputMethod: _analytics.INPUT_METHOD.TOOLBAR
      },
      eventType: _analytics.EVENT_TYPE.TRACK
    };
    var deleteTr = tr;
    if ((0, _utils2.findSelectedNodeOfType)(nodes.panel)(tr.selection)) {
      deleteTr = (0, _utils2.removeSelectedNode)(tr);
    } else if ((0, _utils2.findParentNodeOfType)(nodes.panel)(tr.selection)) {
      deleteTr = (0, _utils2.removeParentNodeOfType)(nodes.panel)(tr);
    }
    if (!deleteTr) {
      return false;
    }
    if (dispatch) {
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(deleteTr);
      dispatch(deleteTr);
    }
    return true;
  };
};
var changePanelType = exports.changePanelType = function changePanelType(editorAnalyticsAPI) {
  return function (panelType) {
    var panelOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var allowCustomPanel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return function (state, dispatch) {
      var nodes = state.schema.nodes,
        tr = state.tr;
      var panelNode = (0, _utils3.findPanel)(state);
      if (panelNode === undefined) {
        return false;
      }
      var newType = panelType;
      var previousType = panelNode.node.attrs.panelType;
      var newTr;
      if (allowCustomPanel) {
        var previousColor = panelNode.node.attrs.panelType === 'custom' ? panelNode.node.attrs.panelColor || 'none' : (0, _panel.getPanelTypeBackgroundNoTokens)(previousType);
        var previousIcon = panelNode.node.attrs.panelIcon;
        var previousIconId = panelNode.node.attrs.panelIconId;
        var previousIconText = panelNode.node.attrs.panelIconText;
        var newPanelOptions = _objectSpread({
          color: previousColor,
          emoji: previousIcon,
          emojiId: previousIconId,
          emojiText: previousIconText
        }, panelOptions);
        newTr = tr.setNodeMarkup(panelNode.pos, nodes.panel, {
          panelIcon: newPanelOptions.emoji,
          panelIconId: newPanelOptions.emojiId,
          panelIconText: newPanelOptions.emojiText,
          panelColor: newPanelOptions.color,
          panelType: panelType
        });
      } else {
        newTr = tr.setNodeMarkup(panelNode.pos, nodes.panel, {
          panelType: panelType
        });
      }
      var payload = {
        action: _analytics.ACTION.CHANGED_TYPE,
        actionSubject: _analytics.ACTION_SUBJECT.PANEL,
        attributes: {
          newType: newType,
          previousType: previousType
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      };

      // Select the panel if it was previously selected
      var newTrWithSelection = state.selection instanceof _state.NodeSelection && state.selection.node.type.name === 'panel' ? newTr.setSelection(new _state.NodeSelection(tr.doc.resolve(panelNode.pos))) : newTr;
      editorAnalyticsAPI === null || editorAnalyticsAPI === void 0 || editorAnalyticsAPI.attachAnalyticsEvent(payload)(newTrWithSelection);
      newTrWithSelection.setMeta('scrollIntoView', false);
      if (dispatch) {
        dispatch(newTrWithSelection);
      }
      return true;
    };
  };
};
function insertPanelWithAnalytics(inputMethod, analyticsAPI) {
  return (0, _editorAnalytics.withAnalytics)(analyticsAPI, {
    action: _analytics.ACTION.INSERTED,
    actionSubject: _analytics.ACTION_SUBJECT.DOCUMENT,
    actionSubjectId: _analytics.ACTION_SUBJECT_ID.PANEL,
    attributes: {
      inputMethod: inputMethod,
      panelType: _adfSchema.PanelType.INFO // only info panels can be inserted via this action
    },
    eventType: _analytics.EVENT_TYPE.TRACK
  })(function (state, dispatch) {
    var nodes = state.schema.nodes;
    if (nodes.panel && nodes.paragraph) {
      return (0, _utils.wrapSelectionIn)(nodes.panel)(state, dispatch);
    }
    return false;
  });
}