"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.collab = collab;
exports.getCollabState = getCollabState;
exports.getDocBeforeUnconfirmedSteps = getDocBeforeUnconfirmedSteps;
exports.rebaseSteps = rebaseSteps;
exports.receiveTransaction = receiveTransaction;
exports.sendableSteps = sendableSteps;
exports.syncFromAnotherSource = syncFromAnotherSource;
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _uuid = require("uuid");
var _state = require("@atlaskit/editor-prosemirror/state");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var Rebaseable = /*#__PURE__*/(0, _createClass2.default)(function Rebaseable(step, inverted, origin) {
  (0, _classCallCheck2.default)(this, Rebaseable);
  this.step = step;
  this.inverted = inverted;
  this.origin = origin;
}); /// Undo a given set of steps, apply a set of other steps, and then
/// redo them @internal
function rebaseSteps(steps, over, transform) {
  for (var i = steps.length - 1; i >= 0; i--) {
    transform.step(steps[i].inverted);
  }
  for (var _i = 0; _i < over.length; _i++) {
    transform.step(over[_i]);
  }
  var result = [];
  for (var _i2 = 0, mapFrom = steps.length; _i2 < steps.length; _i2++) {
    var mapped = steps[_i2].step.map(transform.mapping.slice(mapFrom));
    mapFrom--;
    if (mapped && !transform.maybeStep(mapped).failed) {
      // Open ticket for setMirror https://github.com/ProseMirror/prosemirror/issues/869
      // @ts-expect-error
      transform.mapping.setMirror(mapFrom, transform.steps.length - 1);
      result.push(new Rebaseable(mapped, mapped.invert(transform.docs[transform.docs.length - 1]), steps[_i2].origin));
    }
  }
  return result;
}

// This state field accumulates changes that have to be sent to the
// central authority in the collaborating group and makes it possible
// to integrate changes made by peers into our local document. It is
// defined by the plugin, and will be available as the `collab` field
// in the resulting editor state.
var CollabState = /*#__PURE__*/(0, _createClass2.default)(function CollabState(
// The version number of the last update received from the central
// authority. Starts at 0 or the value of the `version` property
// in the option object, for the editor's value when the option
// was enabled.
version,
// The local steps that havent been successfully sent to the
// server yet.
unconfirmed) {
  (0, _classCallCheck2.default)(this, CollabState);
  this.version = version;
  this.unconfirmed = unconfirmed;
});
function unconfirmedFrom(transform) {
  var result = [];
  for (var i = 0; i < transform.steps.length; i++) {
    // Filter out the analytics steps, they don't need to be sent to the collab service
    // Commented out because it broke undo behaviour

    // TODO: ED-26957 - Figure out how it broke undo
    // if (transform.steps[i] instanceof AnalyticsStep) {
    //   continue;
    // }

    result.push(new Rebaseable(transform.steps[i], transform.steps[i].invert(transform.docs[i]), transform));
  }
  return result;
}
var collabKey = new _state.PluginKey('collab');
/// Creates a plugin that enables the collaborative editing framework
/// for the editor.
function collab() {
  var _config$transformUnco;
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var conf = {
    version: config.version || 0,
    clientID:
    // eslint-disable-next-line eqeqeq
    // generate a temporary id as clientId when it is null or undefined
    // prefix temp-pc- indicates prosemirror-collab
    config.clientID == null || !config.clientID ? "temp-pc-".concat((0, _uuid.v4)()) : config.clientID
  };
  var transformUnconfirmed = (_config$transformUnco = config.transformUnconfirmed) !== null && _config$transformUnco !== void 0 ? _config$transformUnco : function (steps) {
    return steps;
  };
  return new _state.Plugin({
    key: collabKey,
    state: {
      init: function init() {
        return new CollabState(conf.version, []);
      },
      apply: function apply(tr, collab) {
        var newState = tr.getMeta(collabKey);
        if (newState) {
          if ((0, _experiments.editorExperiment)('platform_editor_offline_editing_web', true)) {
            return new CollabState(newState.version, transformUnconfirmed(newState.unconfirmed));
          } else {
            return newState;
          }
        }
        if (tr.docChanged) {
          return new CollabState(collab.version, transformUnconfirmed(collab.unconfirmed.concat(unconfirmedFrom(tr))));
        }
        return collab;
      }
    },
    config: conf,
    // This is used to notify the history plugin to not merge steps,
    // so that the history can be rebased.
    historyPreserveItems: true
  });
}

/**
 * Get the document before the unconfirmed steps were applied.
 * This is used to facilitate tab syncing across multiple tabs while offline, by returning the document before the unconfirmed steps were
 * applied we can ensure each tab starts from the same doc.
 * @param state The editor state
 * @returns The document before the unconfirmed steps were applied
 */
function getDocBeforeUnconfirmedSteps(state) {
  var _collabKey$getState;
  var tr = state.tr;
  var _ref = (_collabKey$getState = collabKey.getState(state)) !== null && _collabKey$getState !== void 0 ? _collabKey$getState : {},
    version = _ref.version,
    unconfirmed = _ref.unconfirmed;
  if (version === undefined || !unconfirmed) {
    return tr.doc;
  }

  // undo unconfirmed steps
  for (var i = unconfirmed.length - 1; i >= 0; i--) {
    tr.step(unconfirmed[i].inverted);
  }
  return tr.doc;
}

/**
 * Sync the document, version and unconfirmed steps from another source.
 * This is used to facilitate tab syncing across multiple tabs while offline, because we no longer have access to the central authority.
 *
 * @param state The editor state
 * @param version the version number of the last update received from the central authority
 * @param docJSON the document corresponding with the version
 * @param unconfirmedSteps the unconfirmed steps that havent been successfully sent to the server yet
 * @returns A transaction that represents the new state of the editor after receiving the new steps, doc and version
 */
function syncFromAnotherSource(state, version,
// eslint-disable-next-line @typescript-eslint/no-explicit-any
docJSON, unconfirmedSteps) {
  var tr = state.tr;
  var doc = state.schema.nodeFromJSON(docJSON);
  var _tr$selection = tr.selection,
    from = _tr$selection.from,
    to = _tr$selection.to;
  tr.replaceWith(0, state.doc.content.size, doc);
  tr.setSelection(_state.TextSelection.create(tr.doc, Math.min(tr.mapping.map(from), tr.doc.nodeSize), Math.min(tr.mapping.map(to), tr.doc.nodeSize)));

  // apply new unconfirmed steps to doc
  for (var i = 0; i < unconfirmedSteps.length; i++) {
    tr.step(unconfirmedSteps[i]);
  }
  var offset = 1; // offset by 1 to account for the initial replace step
  var newUnconfirmed = tr.steps.slice(offset).map(function (step, i) {
    var index = i + offset;
    var doc = tr.docs[index];
    return new Rebaseable(step, step.invert(doc), tr);
  });
  return tr.setMeta('addToHistory', false).setMeta(collabKey, new CollabState(version, newUnconfirmed));
}

/// Create a transaction that represents a set of new steps received from
/// the authority. Applying this transaction moves the state forward to
/// adjust to the authority's view of the document.
function receiveTransaction(state, steps, clientIDs) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Pushes a set of steps (received from the central authority) into
  // the editor state (which should have the collab plugin enabled).
  // Will recognize its own changes, and confirm unconfirmed steps as
  // appropriate. Remaining unconfirmed steps will be rebased over
  // remote steps.
  var collabState = collabKey.getState(state);
  var version = ((collabState === null || collabState === void 0 ? void 0 : collabState.version) || 0) + steps.length;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,  @typescript-eslint/no-explicit-any
  var ourID = collabKey.get(state).spec.config.clientID;

  // Find out which prefix of the steps originated with us
  var ours = 0;
  // eslint-disable-next-line eqeqeq
  while (ours < clientIDs.length && clientIDs[ours] == ourID) {
    ++ours;
  }
  var unconfirmed = (collabState === null || collabState === void 0 ? void 0 : collabState.unconfirmed.slice(ours)) || [];
  steps = ours ? steps.slice(ours) : steps;

  // If all steps originated with us, we're done.
  if (!steps.length) {
    return state.tr.setMeta(collabKey, new CollabState(version, unconfirmed));
  }
  var nUnconfirmed = unconfirmed.length;
  var tr = state.tr;
  if (nUnconfirmed) {
    unconfirmed = rebaseSteps(unconfirmed, steps, tr);
  } else {
    for (var i = 0; i < steps.length; i++) {
      tr.step(steps[i]);
    }
    unconfirmed = [];
  }
  var newCollabState = new CollabState(version, unconfirmed);
  if (options && options.mapSelectionBackward && state.selection instanceof _state.TextSelection) {
    tr.setSelection(new _state.TextSelection(tr.doc.resolve(tr.mapping.map(state.selection.anchor, -1)), tr.doc.resolve(tr.mapping.map(state.selection.head, -1))));
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    tr.updated &= ~1;
  }
  return tr.setMeta('rebased', nUnconfirmed).setMeta('rebasedData', {
    unconfirmedSteps: (collabState === null || collabState === void 0 ? void 0 : collabState.unconfirmed.slice(ours)) || [],
    remoteSteps: steps,
    stepsAfterRebase: unconfirmed,
    versionBefore: version
  }).setMeta('addToHistory', false).setMeta(collabKey, newCollabState);
}

/// Provides data describing the editor's unconfirmed steps, which need
/// to be sent to the central authority. Returns null when there is
/// nothing to send.
///
/// `origins` holds the _original_ transactions that produced each
/// steps. This can be useful for looking up time stamps and other
/// metadata for the steps, but note that the steps may have been
/// rebased, whereas the origin transactions are still the old,
/// unchanged objects.
function sendableSteps(state) {
  var collabState = collabKey.getState(state);
  if (!collabState) {
    return null;
  }

  // eslint-disable-next-line eqeqeq
  if (collabState.unconfirmed.length == 0) {
    return null;
  }
  return {
    version: collabState.version,
    steps: collabState.unconfirmed.map(function (s) {
      return s.step;
    }),
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any
    clientID: collabKey.get(state).spec.config.clientID,
    get origins() {
      return (
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._origins || (
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._origins = collabState === null || collabState === void 0 ? void 0 : collabState.unconfirmed.map(function (s) {
          return s.origin;
        }))
      );
    }
  };
}

/// Get the collab state which would holds the version up to which the collab plugin has synced with the central authority.
/// Override getVersion to getCollabState to gain the benefit on analytics / monitoring in collab-provider
/// Override PR: https://stash.atlassian.com/projects/ATLASSIAN/repos/atlassian-frontend-monorepo/pull-requests/142331/overview
function getCollabState(state) {
  return collabKey.getState(state);
}