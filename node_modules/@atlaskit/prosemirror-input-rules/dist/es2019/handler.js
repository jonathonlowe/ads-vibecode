import { leafNodeReplacementCharacter, MAX_REGEX_MATCH, TEXT_INPUT_RULE_TRANSACTION_KEY } from './constants';
import { isGapCursorSelection } from './editor-common';
export const createInputEventHandler = ({
  rules,
  pluginKey,
  allowInsertTextOnDocument,
  onInputEvent,
  onBeforeRegexMatch
}) => ({
  view,
  from,
  to,
  text
}) => {
  if (view.composing) {
    return false;
  }
  const state = view.state;
  const $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) {
    return false;
  }
  if (onInputEvent && !onInputEvent({
    state,
    from,
    to
  })) {
    return false;
  }
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_REGEX_MATCH), $from.parentOffset, undefined, leafNodeReplacementCharacter) + text;
  const result = findMatchOnRules({
    rules,
    textBefore,
    from,
    to,
    state
  });
  if (!result) {
    return false;
  }
  const tr = allowInsertTextOnDocument ? state.tr.insertText(text, from, to) : state.tr;
  tr.setMeta(TEXT_INPUT_RULE_TRANSACTION_KEY, true);
  tr.setMeta(pluginKey, {
    textInserted: text,
    from: result.from,
    to: result.to,
    matchedRule: result.matchedRule
  });
  if (onBeforeRegexMatch) {
    onBeforeRegexMatch(tr);
  }
  view.dispatch(tr);
  return true;
};
function findMatchOnRules({
  rules,
  textBefore,
  from,
  to,
  state
}) {
  for (let i = 0; i < rules.length; i++) {
    var _textBefore$at;
    const rule = rules[i];

    // Some plugins like Typeahead require a whitespace before a trigger character.
    // We want them to fire inside a gap cursor. Yet, a gap cursor is not considered a whitespace,
    // and `textBefore` contains the text in the previous block before the gap cursor.
    // Here is a workaround: if we inside a gap cursor, match the input rule only against the last typed character
    // (which may be a typeahead trigger) and ignore the rest.
    const matchString = isGapCursorSelection(state.selection) ? (_textBefore$at = textBefore.at(-1)) !== null && _textBefore$at !== void 0 ? _textBefore$at : '' : textBefore;
    const match = rule.match.exec(matchString);
    if (!match) {
      continue;
    }
    const parentNodeStartAt = state.selection.$from.start();
    const offset = Math.max(0, state.selection.$from.parentOffset - MAX_REGEX_MATCH);
    const fromFixed = Math.max(parentNodeStartAt + match.index + offset, 1);
    const transform = rule.handler(state, match, fromFixed, to);
    if (transform) {
      return {
        from: fromFixed,
        to,
        matchedRule: {
          ...rule,
          result: match
        }
      };
    }
  }
  return null;
}