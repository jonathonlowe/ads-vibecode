"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInputRulePlugin = createInputRulePlugin;
var _state = require("@atlaskit/editor-prosemirror/state");
var _constants = require("./constants");
var _handler = require("./handler");
function createInputRulePlugin(pluginName, rules) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var onInputEvent = options === null || options === void 0 ? void 0 : options.onInputEvent;
  var onBeforeRegexMatch = options === null || options === void 0 ? void 0 : options.onBeforeRegexMatch;
  var allowInsertTextOnDocument = Boolean(options === null || options === void 0 ? void 0 : options.allowInsertTextOnDocument);
  var pluginKey = new _state.PluginKey("inputRulePlugin__".concat(pluginName));
  var inputEvent = (0, _handler.createInputEventHandler)({
    allowInsertTextOnDocument: allowInsertTextOnDocument,
    pluginKey: pluginKey,
    rules: rules,
    onInputEvent: onInputEvent,
    onBeforeRegexMatch: onBeforeRegexMatch
  });
  return {
    key: pluginKey,
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(pluginKey);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    appendTransaction: function appendTransaction(transactions, oldState, newState) {
      var transactionWithInputRuleMeta = transactions.find(function (tr) {
        return tr.getMeta(pluginKey);
      });
      var pluginState = transactionWithInputRuleMeta === null || transactionWithInputRuleMeta === void 0 ? void 0 : transactionWithInputRuleMeta.getMeta(pluginKey);
      if (!pluginState || !transactionWithInputRuleMeta) {
        return null;
      }
      var matchedRule = pluginState.matchedRule,
        from = pluginState.from,
        to = pluginState.to;
      var result = matchedRule.result;
      var mappedTo = transactionWithInputRuleMeta.mapping.map(to);
      var tr = matchedRule.handler(newState, result, from, mappedTo);
      if (!tr) {
        return null;
      }
      tr.setMeta(_constants.TEXT_INPUT_RULE_TRANSACTION_KEY, true);
      if (matchedRule.onHandlerApply) {
        matchedRule.onHandlerApply(newState, tr, matchedRule.result);
      }
      return tr;
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return inputEvent({
          view: view,
          from: from,
          to: to,
          text: text
        });
      },
      handleDOMEvents: {
        compositionend: function compositionend(view) {
          setTimeout(function () {
            var selection = view.state.selection;
            if (!(selection instanceof _state.TextSelection)) {
              return;
            }
            var $cursor = selection.$cursor;
            if ($cursor) {
              inputEvent({
                view: view,
                from: $cursor.pos,
                to: $cursor.pos,
                text: ''
              });
            }
          });
          return false;
        }
      }
    },
    // @ts-ignore This is used by prosemirror-view to apply input rules on text input event.
    // However, there is no typing ffor this, yet.
    isInputRules: true
  };
}