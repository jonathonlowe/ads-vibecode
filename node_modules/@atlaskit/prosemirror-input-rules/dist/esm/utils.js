import { closeHistory } from '@atlaskit/editor-prosemirror/history';
import { NodeSelection, TextSelection } from '@atlaskit/editor-prosemirror/state';
import { isGapCursorSelection } from './editor-common';
import { createInputRulePlugin } from './plugin';
var hasUnsupportedMarks = function hasUnsupportedMarks(state, start, end, marksNameUnsupported) {
  var isUnsupportedMark = function isUnsupportedMark(node) {
    return (marksNameUnsupported || []).includes(node.type.name);
  };
  var $from = state.doc.resolve(start);
  var $to = state.doc.resolve(end);
  var marksInSelection = start === end ? $from.marks() : $from.marksAcross($to);
  return (marksInSelection || []).some(isUnsupportedMark);
};
var isCursorInsideUnsupportedMarks = function isCursorInsideUnsupportedMarks(state, marksNameUnsupported) {
  var _$cursor$nodeBefore;
  var selection = state.selection;
  if (!(selection instanceof TextSelection)) {
    return false;
  }
  var $cursor = selection.$cursor;
  var isUnsupportedMark = function isUnsupportedMark(node) {
    return marksNameUnsupported.includes(node.type.name);
  };
  return Boolean($cursor === null || $cursor === void 0 || (_$cursor$nodeBefore = $cursor.nodeBefore) === null || _$cursor$nodeBefore === void 0 || (_$cursor$nodeBefore = _$cursor$nodeBefore.marks) === null || _$cursor$nodeBefore === void 0 ? void 0 : _$cursor$nodeBefore.some(isUnsupportedMark));
};
export var createPlugin = function createPlugin(pluginName, rules) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$isBlockNodeR = options.isBlockNodeRule,
    isBlockNodeRule = _options$isBlockNodeR === void 0 ? false : _options$isBlockNodeR,
    _options$allowInsertT = options.allowInsertTextOnDocument,
    allowInsertTextOnDocument = _options$allowInsertT === void 0 ? true : _options$allowInsertT;
  var onInputEvent = function onInputEvent(_ref) {
    var state = _ref.state,
      from = _ref.from,
      to = _ref.to;
    var unsupportedMarks = isBlockNodeRule ? ['code', 'link', 'typeAheadQuery'] : ['code'];
    var $from = state.selection.$from;
    var isInline = state.selection instanceof NodeSelection && state.selection.node.type.isInline;
    if ($from.parent.type.spec.code || !(state.selection instanceof TextSelection) && !isGapCursorSelection(state.selection) && !isInline || hasUnsupportedMarks(state, from, to, unsupportedMarks) || isBlockNodeRule && isCursorInsideUnsupportedMarks(state, unsupportedMarks)) {
      return false;
    }
    return true;
  };
  return createInputRulePlugin(pluginName, rules, {
    allowInsertTextOnDocument: allowInsertTextOnDocument,
    onInputEvent: onInputEvent,
    onBeforeRegexMatch: function onBeforeRegexMatch(tr) {
      closeHistory(tr);
    }
  });
};