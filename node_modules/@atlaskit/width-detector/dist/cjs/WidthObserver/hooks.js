"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInView = useInView;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireDefault(require("react"));
function useInView() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var ref = _react.default.useRef();
  var observerInstance = _react.default.useRef();
  var _React$useState = _react.default.useState({
      inView: false,
      entry: undefined,
      target: undefined
    }),
    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
    state = _React$useState2[0],
    setState = _React$useState2[1];
  var threshold = options.threshold,
    root = options.root,
    rootMargin = options.rootMargin;
  var setRef = _react.default.useCallback(function (node) {
    observerInstance.current = new IntersectionObserver(function (entries) {
      if (entries && entries.length) {
        var intersection = entries[0];
        var isIntersecting = intersection.isIntersecting,
          intersectionRatio = intersection.intersectionRatio;
        if (intersectionRatio >= 0) {
          // Note: `0` will be used here when an array of numbers is passed as the threshold, which doesn't feel right
          var numericThreshold = typeof threshold === 'number' ? threshold : 0;
          var inView = intersectionRatio >= numericThreshold;
          if (isIntersecting !== undefined) {
            inView = inView && isIntersecting;
          }
          setState({
            inView: inView,
            entry: intersection,
            target: node
          });
        }
      }
    }, {
      threshold: threshold,
      root: root,
      rootMargin: rootMargin
    });
    if (ref.current) {
      observerInstance.current.unobserve(ref.current);
    }
    if (node) {
      observerInstance.current.observe(node);
    }

    // Store a reference to the node
    ref.current = node;
  }, [threshold, root, rootMargin]);

  /**
   * Unsubscribe IntersectionObserver before unmounting a component.
   */
  _react.default.useEffect(function () {
    return function () {
      if (observerInstance.current && ref.current) {
        observerInstance.current.unobserve(ref.current);
      }
    };
  }, []);
  return [setRef, state.inView, state.target, state.entry];
}