import { MentionNameStatus, } from '../types';
import { fireAnalyticsMentionHydrationEvent } from '../util/analytics';
export class DefaultMentionNameResolver {
    constructor(client, analyticsProps = {}) {
        this.nameCache = new Map();
        this.nameQueue = new Map();
        this.nameStartTime = new Map();
        this.processingQueue = new Map();
        this.debounce = 0;
        this.processQueue = () => {
            clearTimeout(this.debounce);
            this.debounce = 0;
            const { queue, extraQueue } = this.splitQueueAtLimit();
            this.nameQueue = extraQueue;
            this.processingQueue = new Map([...this.processingQueue, ...queue]);
            this.client
                .lookupMentionNames(Array.from(queue.keys()))
                .then(response => {
                response.forEach(mentionDetail => {
                    const { id } = mentionDetail;
                    queue.delete(id);
                    this.resolveQueueItem(mentionDetail);
                });
                queue.forEach((_callback, id) => {
                    // No response from client for these ids treat as unknown
                    this.resolveQueueItem({
                        id,
                        status: MentionNameStatus.UNKNOWN,
                    });
                });
            })
                .catch(() => {
                // Service completely failed, reject all items in the queue
                queue.forEach((_callback, id) => {
                    this.resolveQueueItem({
                        id,
                        status: MentionNameStatus.SERVICE_ERROR,
                    });
                });
            });
            // Make sure anything left in the queue gets processed.
            if (this.nameQueue.size > 0) {
                this.scheduleProcessQueue();
            }
        };
        this.client = client;
        this.fireHydrationEvent = fireAnalyticsMentionHydrationEvent(analyticsProps);
    }
    lookupName(id) {
        const name = this.nameCache.get(id);
        if (name) {
            this.fireAnalytics(true, name);
            return name;
        }
        return new Promise(resolve => {
            const processingItems = this.processingQueue.get(id);
            if (processingItems) {
                this.processingQueue.set(id, [...processingItems, resolve]);
            }
            const queuedItems = this.nameQueue.get(id) || [];
            this.nameQueue.set(id, [...queuedItems, resolve]);
            if (queuedItems.length === 0 && !processingItems) {
                this.nameStartTime.set(id, Date.now());
            }
            this.scheduleProcessQueue();
            if (this.isQueueAtLimit()) {
                this.processQueue();
            }
        });
    }
    cacheName(id, name) {
        this.nameCache.set(id, {
            id,
            name,
            status: MentionNameStatus.OK,
        });
    }
    scheduleProcessQueue() {
        if (!this.debounce) {
            this.debounce = window.setTimeout(this.processQueue, DefaultMentionNameResolver.waitForBatch);
        }
    }
    isQueueAtLimit() {
        return this.nameQueue.size >= this.client.getLookupLimit();
    }
    splitQueueAtLimit() {
        const values = Array.from(this.nameQueue.entries());
        const splitPoint = this.client.getLookupLimit();
        return {
            queue: new Map(values.slice(0, splitPoint)),
            extraQueue: new Map(values.slice(splitPoint)),
        };
    }
    resolveQueueItem(mentionDetail) {
        const { id } = mentionDetail;
        const resolvers = this.processingQueue.get(id);
        if (resolvers) {
            this.processingQueue.delete(id);
            this.nameCache.set(id, mentionDetail);
            resolvers.forEach(resolve => {
                try {
                    resolve(mentionDetail);
                }
                catch {
                    // ignore - exception in consumer
                }
            });
            this.fireAnalytics(false, mentionDetail);
        }
    }
    fireAnalytics(fromCache, mentionDetail) {
        const { id } = mentionDetail;
        const action = mentionDetail.status === MentionNameStatus.OK ? 'completed' : 'failed';
        const start = this.nameStartTime.get(id);
        const duration = start ? Date.now() - start : 0;
        this.nameStartTime.delete(id);
        this.fireHydrationEvent(action, id, fromCache, duration);
    }
}
DefaultMentionNameResolver.waitForBatch = 100; // ms
//# sourceMappingURL=MentionNameResolver.js.map