import { withAnalyticsEvents, } from '@atlaskit/analytics-next';
import React from 'react';
import * as UtilAnalytics from '../../util/analytics';
import uniqueId from '../../util/id';
import debug from '../../util/logger';
import Popup from '../Popup';
import ResourcedMentionList from '../ResourcedMentionList';
import { MentionPickerInfoStyle, MentionPickerStyle } from './styles';
/**
 * @class MentionPicker
 */
export class MentionPicker extends React.PureComponent {
    constructor(props) {
        super(props);
        this.selectNext = () => {
            if (this.mentionListRef) {
                this.mentionListRef.selectNext();
            }
        };
        this.selectPrevious = () => {
            if (this.mentionListRef) {
                this.mentionListRef.selectPrevious();
            }
        };
        this.selectIndex = (index, callback) => {
            if (this.mentionListRef) {
                this.mentionListRef.selectIndex(index, callback);
            }
        };
        this.selectId = (id, callback) => {
            if (this.mentionListRef) {
                this.mentionListRef.selectId(id, callback);
            }
        };
        this.chooseCurrentSelection = () => {
            if (this.mentionListRef) {
                this.mentionListRef.chooseCurrentSelection();
            }
        };
        this.mentionsCount = () => {
            if (this.mentionListRef) {
                return this.mentionListRef.mentionsCount();
            }
            return 0;
        };
        /**
         * Called after the 'visible' state is changed to decide whether the onOpen or onClose
         * handlers should be called.
         *
         * It should be noted that the visible state of the component is not considered in
         * this function. Instead the old state and new state should be passed as parameters.
         */
        this.onFilterVisibilityChange = (oldVisibility, newVisibility) => {
            if (oldVisibility !== newVisibility) {
                if (newVisibility) {
                    if (this.props.onOpen) {
                        this.props.onOpen();
                    }
                }
                else {
                    if (this.props.onClose) {
                        this.props.onClose();
                    }
                }
            }
        };
        // internal, used for callbacks
        this.filterChange = (mentions, query, stats) => {
            debug('ak-mention-picker.filterChange', mentions.length);
            const wasVisible = this.state.visible;
            const visible = mentions.length > 0;
            this.setState({
                visible,
            });
            this.onFilterVisibilityChange(wasVisible, visible);
            UtilAnalytics.fireAnalyticsMentionTypeaheadEvent(this.props)('rendered', stats && stats.duration, mentions.map(mention => mention.id), query);
        };
        this.filterError = error => {
            debug('ak-mention-picker.filterError', error);
            const wasVisible = this.state.visible;
            this.setState({
                visible: true,
                info: undefined,
            });
            this.onFilterVisibilityChange(wasVisible, true);
        };
        this.filterInfo = info => {
            debug('ak-mention-picker.filterInfo', info);
            this.setState({
                info,
            });
        };
        this.handleMentionListRef = (ref) => {
            this.mentionListRef = ref;
        };
        this.subscriberKey = uniqueId('ak-mention-picker');
        this.state = {
            visible: false,
        };
        this.applyPropChanges({}, props);
    }
    componentDidMount() {
        this.subscribeResourceProvider(this.props.resourceProvider);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        this.applyPropChanges(this.props, nextProps);
    }
    componentWillUnmount() {
        this.unsubscribeResourceProvider(this.props.resourceProvider);
    }
    // Internal
    applyPropChanges(prevProps, nextProps) {
        const oldResourceProvider = prevProps.resourceProvider;
        const newResourceProvider = nextProps.resourceProvider;
        const resourceProviderChanged = oldResourceProvider !== newResourceProvider;
        // resource provider
        if (resourceProviderChanged) {
            this.unsubscribeResourceProvider(oldResourceProvider);
            this.subscribeResourceProvider(newResourceProvider);
        }
    }
    subscribeResourceProvider(resourceProvider) {
        if (resourceProvider) {
            resourceProvider.subscribe(this.subscriberKey, this.filterChange, this.filterError, this.filterInfo, undefined);
        }
    }
    unsubscribeResourceProvider(resourceProvider) {
        if (resourceProvider) {
            resourceProvider.unsubscribe(this.subscriberKey);
        }
    }
    render() {
        const { createTeamPath, resourceProvider, presenceProvider, onSelection, query, target, position, zIndex, offsetX, offsetY, showTeamMentionsHighlight, } = this.props;
        const { visible, info } = this.state;
        const resourceMentionList = (React.createElement(ResourcedMentionList, { resourceProvider: resourceProvider, presenceProvider: presenceProvider, onSelection: onSelection, query: query, ref: this.handleMentionListRef, isTeamMentionHighlightEnabled: !!showTeamMentionsHighlight, createTeamPath: createTeamPath }));
        const infoContent = info && !visible ? (React.createElement(MentionPickerInfoStyle, null,
            React.createElement("p", null, info))) : null;
        let content;
        if (position) {
            debug('target, position', target, position);
            if (target) {
                content = (React.createElement(Popup, { target: target, relativePosition: position, zIndex: zIndex, offsetX: offsetX, offsetY: offsetY },
                    React.createElement("div", null,
                        resourceMentionList,
                        infoContent)));
            }
            else {
                // don't show if we have a position, but no target yet
                content = null;
            }
        }
        else {
            content = (React.createElement("div", null,
                resourceMentionList,
                infoContent));
        }
        return (
        /* old classnames are essential for Confluence tests */
        React.createElement(MentionPickerStyle, { className: "ak-mention-picker", visible: visible || info }, content));
    }
}
MentionPicker.defaultProps = {
    onSelection: () => { },
    onOpen: () => { },
    onClose: () => { },
};
export const MentionPickerWithAnalytics = withAnalyticsEvents({})(MentionPicker);
export default MentionPickerWithAnalytics;
//# sourceMappingURL=index.js.map