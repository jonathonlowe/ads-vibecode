import { AbstractResource, utils as serviceUtils, } from '@atlaskit/util-service-support';
import { selectedToneStorageKey } from '../util/constants';
import { isMediaEmoji, isPromise, toEmojiId } from '../util/type-helpers';
import debug from '../util/logger';
import EmojiLoader from './EmojiLoader';
import EmojiRepository from './EmojiRepository';
import SiteEmojiResource from './media/SiteEmojiResource';
/**
 * Checks if the emojiProvider can support uploading at a feature level.
 *
 * Follow this up with an isUploadSupported() check to see if the provider is actually
 * configured to support uploads.
 */
export const supportsUploadFeature = (emojiProvider) => {
    const { isUploadSupported, prepareForUpload, uploadCustomEmoji, } = emojiProvider;
    return !!(isUploadSupported && prepareForUpload && uploadCustomEmoji);
};
export class EmojiResource extends AbstractResource {
    constructor(config) {
        super();
        this.activeLoaders = 0;
        this.retries = new Map();
        this.isLoaded = () => this.activeLoaders === 0 && this.emojiRepository;
        this.recordConfig = config.recordConfig;
        this.currentUser = config.currentUser;
        // Ensure order is retained by tracking until all done.
        const emojiResponses = [];
        this.activeLoaders = config.providers.length;
        config.providers.forEach((provider, index) => {
            const loader = new EmojiLoader(provider);
            const emojis = loader.loadEmoji();
            emojis
                .then(emojiResponse => {
                emojiResponses[index] = emojiResponse;
                this.initEmojiRepository(emojiResponses);
                this.initSiteEmojiResource(emojiResponse, provider).then(() => {
                    this.activeLoaders--;
                    this.performRetries();
                    this.refreshLastFilter();
                });
            })
                .catch(reason => {
                this.activeLoaders--;
                this.notifyError(reason);
            });
        });
        if (typeof window !== 'undefined' && window.localStorage) {
            this.selectedTone = this.loadStoredTone();
        }
        if (config.providers.length === 0) {
            throw new Error('No providers specified');
        }
    }
    initEmojiRepository(emojiResponses) {
        let emojis = [];
        emojiResponses.forEach(emojiResponse => {
            emojis = emojis.concat(emojiResponse.emojis);
        });
        this.emojiRepository = new EmojiRepository(emojis);
    }
    initSiteEmojiResource(emojiResponse, provider) {
        if (!this.siteEmojiResource && emojiResponse.mediaApiToken) {
            this.siteEmojiResource = new SiteEmojiResource(provider, emojiResponse.mediaApiToken);
            // Prime cache type + optimistic rendering by checking first Emoji.
            // If this is fails, it won't be primed until a good emoji is loaded later.
            const { emojis } = emojiResponse;
            if (emojis.length) {
                const done = this.siteEmojiResource.optimisticRendering(emojis[0]);
                if (isPromise(done)) {
                    return done
                        .then(() => {
                        debug('Primed siteEmojiResource');
                    })
                        .catch(() => {
                        debug('Failed to prime siteEmojiResource');
                    });
                }
                else {
                    debug('Already primed siteEmojiResource');
                }
            }
            else {
                debug('No emoji to prime siteEmojiResource with');
            }
        }
        return Promise.resolve();
    }
    performRetries() {
        const currentRetries = this.retries;
        this.retries = new Map();
        currentRetries.forEach((resolveReject, retry) => {
            const result = retry();
            if (isPromise(result)) {
                result
                    .then(response => {
                    resolveReject.resolve(response);
                })
                    .catch(reason => {
                    resolveReject.reject(reason);
                });
            }
            else {
                resolveReject.resolve(result);
            }
        });
    }
    loadStoredTone() {
        const storedToneString = window.localStorage.getItem(selectedToneStorageKey);
        if (storedToneString) {
            const storedTone = parseInt(storedToneString, 10);
            return !isNaN(storedTone) ? storedTone : undefined;
        }
        return undefined;
    }
    refreshLastFilter() {
        if (typeof this.lastQuery !== 'undefined') {
            const { query, options } = this.lastQuery;
            this.filter(query, options);
        }
    }
    retryIfLoading(retry, defaultResponse) {
        if (!this.isLoaded()) {
            return new Promise((resolve, reject) => {
                this.retries.set(retry, { resolve, reject });
            });
        }
        return Promise.resolve(defaultResponse);
    }
    notifyResult(result) {
        if (this.lastQuery && result.query === this.lastQuery.query) {
            super.notifyResult(result);
        }
    }
    loadMediaEmoji(emoji, useAlt) {
        if (!this.siteEmojiResource || !isMediaEmoji(emoji)) {
            return emoji;
        }
        return this.siteEmojiResource.loadMediaEmoji(emoji, useAlt);
    }
    optimisticMediaRendering(emoji, useAlt) {
        if (!isMediaEmoji(emoji)) {
            return true;
        }
        if (!this.siteEmojiResource) {
            // Shouldn't have a media emoji without a siteEmojiResouce, but anyway ;)
            return false;
        }
        const optimistic = this.siteEmojiResource.optimisticRendering(emoji, useAlt);
        if (isPromise(optimistic)) {
            // Not sure yet, so lets say no for now (this should normally be primed in most/all cases)
            return false;
        }
        return optimistic;
    }
    filter(query, options) {
        this.lastQuery = {
            query,
            options,
        };
        if (this.emojiRepository) {
            this.notifyResult(this.emojiRepository.search(query, options));
        }
        else {
            // not ready
            this.notifyNotReady();
        }
    }
    findByShortName(shortName) {
        if (this.isLoaded()) {
            // Wait for all emoji to load before looking by shortName (to ensure correct priority)
            return this.emojiRepository.findByShortName(shortName);
        }
        return this.retryIfLoading(() => this.findByShortName(shortName), undefined);
    }
    findByEmojiId(emojiId) {
        const { id, shortName } = emojiId;
        if (this.emojiRepository) {
            if (id) {
                const emoji = this.emojiRepository.findById(id);
                if (emoji) {
                    return emoji;
                }
                if (this.isLoaded()) {
                    // all loaded but not found by id, try server to see if
                    // this is a newly uploaded emoji
                    if (this.siteEmojiResource) {
                        return this.siteEmojiResource.findEmoji(emojiId).then(emoji => {
                            if (!emoji) {
                                // if not, fallback to searching by shortName to
                                // at least render an alternative
                                return this.findByShortName(shortName);
                            }
                            this.addUnknownEmoji(emoji);
                            return emoji;
                        });
                    }
                    // if not, fallback to searching by shortName to
                    // at least render an alternative
                    return this.findByShortName(shortName);
                }
            }
            else {
                // no id fallback to shortName
                return this.findByShortName(shortName);
            }
        }
        return this.retryIfLoading(() => this.findByEmojiId(emojiId), undefined);
    }
    findById(id) {
        if (this.isLoaded()) {
            return this.emojiRepository.findById(id);
        }
        return this.retryIfLoading(() => this.findById(id), undefined);
    }
    findInCategory(categoryId) {
        if (this.isLoaded()) {
            return Promise.resolve(this.emojiRepository.findInCategory(categoryId));
        }
        return this.retryIfLoading(() => this.findInCategory(categoryId), []);
    }
    getAsciiMap() {
        if (this.isLoaded()) {
            return Promise.resolve(this.emojiRepository.getAsciiMap());
        }
        return this.retryIfLoading(() => this.getAsciiMap(), new Map());
    }
    getFrequentlyUsed(options) {
        if (this.isLoaded()) {
            return Promise.resolve(this.emojiRepository.getFrequentlyUsed(options));
        }
        return this.retryIfLoading(() => this.getFrequentlyUsed(options), []);
    }
    /**
     * Record the selection of an emoji to a remote service if 'recordConfig' has been supplied.
     * Regardless of the recordConfig, emoji selections will always be recorded on the EmojiRepository
     * for the purposes of tracking the frequency of use.
     *
     * @param emoji The full description of the emoji to record usage for.
     */
    recordSelection(emoji) {
        const { recordConfig } = this;
        if (this.emojiRepository) {
            this.emojiRepository.used(emoji);
        }
        if (recordConfig) {
            const queryParams = {
                emojiId: toEmojiId(emoji),
            };
            const requestInit = {
                method: 'POST',
            };
            return serviceUtils.requestService(recordConfig, {
                queryParams,
                requestInit,
            });
        }
        return Promise.resolve();
    }
    deleteSiteEmoji(emoji) {
        if (this.siteEmojiResource && emoji.id) {
            return this.siteEmojiResource
                .deleteEmoji(emoji)
                .then(success => {
                if (success && this.emojiRepository) {
                    this.emojiRepository.delete(emoji);
                    return true;
                }
                return false;
            })
                .catch(err => {
                // eslint-disable-next-line no-console
                console.error('failed to delete site emoji', err);
                return false;
            });
        }
        return this.retryIfLoading(() => this.deleteSiteEmoji(emoji), false);
    }
    getSelectedTone() {
        return this.selectedTone;
    }
    setSelectedTone(tone) {
        this.selectedTone = tone;
        if (window.localStorage) {
            try {
                window.localStorage.setItem(selectedToneStorageKey, tone ? tone.toString() : '');
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error('failed to store selected emoji skin tone', e);
            }
        }
    }
    calculateDynamicCategories() {
        if (this.isLoaded()) {
            return Promise.resolve(this.emojiRepository.getDynamicCategoryList());
        }
        return this.retryIfLoading(() => this.calculateDynamicCategories(), []);
    }
    getCurrentUser() {
        return this.currentUser;
    }
    addUnknownEmoji(emoji) {
        if (this.emojiRepository) {
            this.emojiRepository.addUnknownEmoji(emoji);
        }
    }
}
export default class UploadingEmojiResource extends EmojiResource {
    constructor(config) {
        super(config);
        this.allowUpload = !!config.allowUpload;
    }
    isUploadSupported() {
        if (!this.allowUpload) {
            return Promise.resolve(false);
        }
        if (this.siteEmojiResource) {
            return this.siteEmojiResource.hasUploadToken();
        }
        return this.retryIfLoading(() => this.isUploadSupported(), false);
    }
    uploadCustomEmoji(upload) {
        return this.isUploadSupported().then(supported => {
            if (!supported || !this.siteEmojiResource) {
                return Promise.reject('No media api support is configured');
            }
            return this.siteEmojiResource.uploadEmoji(upload).then(emoji => {
                this.addUnknownEmoji(emoji);
                this.refreshLastFilter();
                return emoji;
            });
        });
    }
    prepareForUpload() {
        if (this.siteEmojiResource) {
            this.siteEmojiResource.prepareForUpload();
        }
        return this.retryIfLoading(() => this.prepareForUpload(), undefined);
    }
}
//# sourceMappingURL=EmojiResource.js.map