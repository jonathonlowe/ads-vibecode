import classNames from 'classnames';
import PropTypes from 'prop-types';
import React from 'react';
import { PureComponent } from 'react';
import { List as VirtualList } from 'react-virtualized/dist/commonjs/List';
import { customCategory, userCustomTitle } from '../../util/constants';
import { CategoryDescriptionMap, } from './categories';
import CategoryTracker from './CategoryTracker';
import { sizes } from './EmojiPickerSizes';
import { CategoryHeadingItem, EmojisRowItem, LoadingItem, virtualItemRenderer, } from './EmojiPickerVirtualItems';
import * as styles from './styles';
import EmojiPickerListSearch from './EmojiPickerListSearch';
const categoryClassname = 'emoji-category';
const byOrder = (orderableA, orderableB) => (orderableA.order || 0) - (orderableB.order || 0);
export default class EmojiPickerVirtualList extends PureComponent {
    constructor(props) {
        super(props);
        this.virtualItems = [];
        this.categoryTracker = new CategoryTracker();
        this.onEmojiMouseEnter = (emojiId, emoji) => {
            if (this.props.onEmojiActive) {
                this.props.onEmojiActive(emojiId, emoji);
            }
        };
        this.onSearch = (e) => {
            if (this.props.onSearch) {
                this.props.onSearch(e.target.value);
            }
        };
        this.buildVirtualItemFromGroup = (group) => {
            const { onEmojiSelected, onEmojiDelete } = this.props;
            const items = [];
            items.push(new CategoryHeadingItem({
                id: group.category,
                title: group.title,
                className: categoryClassname,
            }));
            let remainingEmojis = group.emojis;
            while (remainingEmojis.length > 0) {
                const rowEmojis = remainingEmojis.slice(0, sizes.emojiPerRow);
                remainingEmojis = remainingEmojis.slice(sizes.emojiPerRow);
                items.push(new EmojisRowItem({
                    emojis: rowEmojis,
                    title: group.title,
                    showDelete: group.title === userCustomTitle,
                    onSelected: onEmojiSelected,
                    onDelete: onEmojiDelete,
                    onMouseMove: this.onEmojiMouseEnter,
                }));
            }
            return items;
        };
        this.buildVirtualItems = (props, _state) => {
            const { emojis, loading, query } = props;
            let items = [];
            this.categoryTracker.reset();
            if (loading) {
                items.push(new LoadingItem());
            }
            else {
                if (query) {
                    const search = CategoryDescriptionMap.SEARCH;
                    // Only a single "result" category
                    items = [
                        ...items,
                        ...this.buildVirtualItemFromGroup({
                            category: 'SEARCH',
                            title: search.name,
                            emojis,
                            order: search.order,
                        }),
                    ];
                }
                else {
                    // Group by category
                    // Not searching show in categories.
                    this.allEmojiGroups.forEach(group => {
                        // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
                        // by not passing it to irrelevant groups
                        this.categoryTracker.add(group.emojis[0].category, items.length);
                        items = [...items, ...this.buildVirtualItemFromGroup(group)];
                    });
                }
            }
            const rowCountChanged = this.virtualItems.length !== items.length;
            this.virtualItems = items;
            const list = this.refs.list;
            if (!rowCountChanged && list) {
                // Row count has not changed, so need to tell list to rerender.
                list.forceUpdateGrid();
            }
            if (!query && list) {
                // VirtualList can apply stale heights since it performs a shallow
                // compare to check if the list has changed. Should manually recompute
                // row heights for the case when frequent category come in later
                list.recomputeRowHeights();
            }
        };
        this.addToCategoryMap = (categoryToGroupMap, emoji, category) => {
            if (!categoryToGroupMap[category]) {
                const categoryDefinition = CategoryDescriptionMap[category];
                categoryToGroupMap[category] = {
                    emojis: [],
                    title: categoryDefinition.name,
                    category,
                    order: categoryDefinition.order,
                };
            }
            categoryToGroupMap[category].emojis.push(emoji);
            return categoryToGroupMap;
        };
        this.groupByCategory = (currentUser) => (categoryToGroupMap, emoji) => {
            this.addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
            // separate user emojis
            if (emoji.category === customCategory &&
                currentUser &&
                emoji.creatorUserId === currentUser.id) {
                this.addToCategoryMap(categoryToGroupMap, emoji, 'USER_CUSTOM');
            }
            return categoryToGroupMap;
        };
        this.buildEmojiGroupedByCategory = (emojis, currentUser) => {
            const categoryToGroupMap = emojis.reduce(this.groupByCategory(currentUser), {});
            this.allEmojiGroups = Object.keys(categoryToGroupMap)
                .map((key) => categoryToGroupMap[key])
                .map(group => {
                if (group.category !== 'FREQUENT') {
                    group.emojis.sort(byOrder);
                }
                return group;
            })
                .sort(byOrder);
        };
        this.repaintList = () => {
            if (this.refs.root) {
                const root = this.refs.root;
                const display = root.style.display;
                root.style.display = 'none';
                // we need to access offset to force repaint
                // eslint-disable-next-line no-unused-expressions
                root.offsetHeight;
                root.style.display = display;
            }
        };
        /**
         * Checks if list is showing a new CategoryId
         * to inform selector to change active category
         */
        this.checkCategoryIdChange = (indexes) => {
            const { startIndex } = indexes;
            // FS-1844 Fix a rendering problem when scrolling to the top
            if (startIndex === 0) {
                this.repaintList();
            }
            if (!this.props.query) {
                // Calculate category in view - only relevant if categories shown, i.e. no query
                const list = this.refs.list;
                const currentCategory = this.categoryTracker.findNearestCategoryAbove(startIndex, list);
                if (currentCategory && this.activeCategoryId !== currentCategory) {
                    this.activeCategoryId = currentCategory;
                    if (this.props.onCategoryActivated) {
                        this.props.onCategoryActivated(currentCategory);
                    }
                }
            }
        };
        this.rowSize = ({ index }) => this.virtualItems[index].height;
        this.renderRow = (context) => virtualItemRenderer(this.virtualItems, context);
        this.buildEmojiGroupedByCategory(props.emojis, props.currentUser);
        this.buildVirtualItems(props, this.state);
    }
    getChildContext() {
        const { emoji } = this.context;
        return {
            emoji: {
                ...emoji,
            },
        };
    }
    UNSAFE_componentWillUpdate(nextProps, nextState) {
        if (this.props.emojis !== nextProps.emojis ||
            this.props.selectedTone !== nextProps.selectedTone ||
            this.props.loading !== nextProps.loading ||
            this.props.query !== nextProps.query) {
            if (!nextProps.query) {
                // Only refresh if no query
                this.buildEmojiGroupedByCategory(nextProps.emojis, nextProps.currentUser);
            }
            this.buildVirtualItems(nextProps, nextState);
        }
    }
    /**
     * Scrolls to a category in the list view
     */
    reveal(category) {
        const row = this.categoryTracker.getRow(category);
        const list = this.refs.list;
        list.scrollToRow(row);
    }
    scrollToBottom() {
        const list = this.refs.list;
        list.scrollToRow(this.virtualItems.length);
    }
    render() {
        const { onMouseLeave, onMouseEnter, query } = this.props;
        const classes = [styles.emojiPickerList];
        return (React.createElement("div", { ref: "root", className: classNames(classes), onMouseLeave: onMouseLeave, onMouseEnter: onMouseEnter },
            React.createElement(EmojiPickerListSearch, { onChange: this.onSearch, query: query }),
            React.createElement(VirtualList, { ref: "list", height: sizes.listHeight, overscanRowCount: 5, rowCount: this.virtualItems.length, rowHeight: this.rowSize, rowRenderer: this.renderRow, scrollToAlignment: "start", width: sizes.listWidth, className: styles.virtualList, onRowsRendered: this.checkCategoryIdChange })));
    }
}
EmojiPickerVirtualList.contextTypes = {
    emoji: PropTypes.object,
};
EmojiPickerVirtualList.childContextTypes = {
    emoji: PropTypes.object,
};
EmojiPickerVirtualList.defaultProps = {
    onEmojiSelected: () => { },
    onEmojiActive: () => { },
    onEmojiDelete: () => { },
    onCategoryActivated: () => { },
    onSearch: () => { },
};
//# sourceMappingURL=EmojiPickerList.js.map