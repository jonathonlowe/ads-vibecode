import AkFieldBase from '@atlaskit/field-base';
import React from 'react';
import { PureComponent } from 'react';
import { FormattedMessage } from 'react-intl';
import * as ImageUtil from '../../util/image';
import debug from '../../util/logger';
import { messages } from '../i18n';
import EmojiErrorMessage from './EmojiErrorMessage';
import EmojiUploadPreview from './EmojiUploadPreview';
import FileChooser from './FileChooser';
import { UploadStatus } from './internal-types';
import * as styles from './styles';
const disallowedReplacementsMap = new Map([
    [':', ''],
    ['!', ''],
    ['@', ''],
    ['#', ''],
    ['%', ''],
    ['^', ''],
    ['&', ''],
    ['*', ''],
    ['(', ''],
    [')', ''],
    [' ', '_'],
]);
const sanitizeName = (name) => {
    // prevent / replace certain characters, allow others
    disallowedReplacementsMap.forEach((replaceWith, exclude) => {
        name = name.split(exclude).join(replaceWith);
    });
    return name;
};
const maxNameLength = 50;
const toEmojiName = (uploadName) => {
    const name = uploadName.split('_').join(' ');
    return `${name.substr(0, 1).toLocaleUpperCase()}${name.substr(1)}`;
};
class ChooseEmojiFile extends PureComponent {
    constructor() {
        super(...arguments);
        this.onKeyDown = event => {
            if (event.key === 'Escape') {
                this.props.onUploadCancelled();
            }
        };
    }
    render() {
        const { name = '', onChooseFile, onClick, onNameChange, errorMessage, } = this.props;
        const disableChooser = !name;
        // Note: FileChooser.accept does not work in Electron due to a bug: https://product-fabric.atlassian.net/browse/FS-1626
        return (React.createElement("div", { className: styles.emojiUpload },
            React.createElement("div", { className: styles.uploadChooseFileMessage },
                React.createElement(FormattedMessage, Object.assign({}, messages.addCustomEmojiLabel), message => React.createElement("h5", null, message))),
            React.createElement("div", { className: styles.uploadChooseFileRow },
                React.createElement("span", { className: styles.uploadChooseFileEmojiName },
                    React.createElement(AkFieldBase, { appearance: "standard", isCompact: true, defaultIsFocused: true, isFitContainerWidthEnabled: true },
                        React.createElement(FormattedMessage, Object.assign({}, messages.emojiPlaceholder), message => (React.createElement(FormattedMessage, Object.assign({}, messages.emojiNameAriaLabel), ariaLabel => (React.createElement("input", { placeholder: message, "aria-label": ariaLabel, maxLength: maxNameLength, onChange: onNameChange, onKeyDown: this.onKeyDown, value: name, ref: "name", autoFocus: true }))))))),
                React.createElement("span", { className: styles.uploadChooseFileBrowse },
                    React.createElement(FormattedMessage, Object.assign({}, messages.emojiChooseFileTitle), message => (React.createElement(FormattedMessage, Object.assign({}, messages.emojiChooseFileAriaLabel), ariaLabel => (React.createElement(FileChooser, { label: message, onChange: onChooseFile, onClick: onClick, accept: "image/png,image/jpeg,image/gif", ariaLabel: ariaLabel, isDisabled: disableChooser }))))))),
            React.createElement("div", { className: styles.emojiUploadBottom }, !errorMessage ? (React.createElement("p", null,
                React.createElement(FormattedMessage, Object.assign({}, messages.emojiImageRequirements)))) : (React.createElement(EmojiErrorMessage, { className: styles.emojiChooseFileErrorMessage, message: errorMessage })))));
    }
}
export default class EmojiUploadPicker extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            uploadStatus: UploadStatus.Waiting,
            chooseEmojiErrorMessage: undefined,
        };
        this.onNameChange = (event) => {
            let newName = sanitizeName(event.target.value);
            if (this.state.name !== newName) {
                this.setState({
                    name: newName,
                });
            }
        };
        this.onAddEmoji = () => {
            const { onUploadEmoji } = this.props;
            const { filename, name, previewImage, uploadStatus } = this.state;
            if (uploadStatus === UploadStatus.Uploading) {
                return;
            }
            if (filename && name && previewImage) {
                const notifyUpload = (size) => {
                    const { width, height } = size;
                    this.setState({
                        uploadStatus: UploadStatus.Uploading,
                    });
                    onUploadEmoji({
                        name: toEmojiName(name),
                        shortName: `:${name}:`,
                        filename,
                        dataURL: previewImage,
                        width,
                        height,
                    }, uploadStatus === UploadStatus.Error);
                };
                ImageUtil.getNaturalImageSize(previewImage)
                    .then(size => {
                    notifyUpload(size);
                })
                    .catch(error => {
                    debug('getNaturalImageSize error', error);
                    // Just set arbitrary size, worse case is it may render
                    // in wrong aspect ratio in some circumstances.
                    notifyUpload({
                        width: 32,
                        height: 32,
                    });
                });
            }
        };
        this.errorOnUpload = (event) => {
            debug('File load error: ', event);
            this.setState({
                chooseEmojiErrorMessage: messages.emojiUploadFailed,
            });
            this.cancelChooseFile();
        };
        this.onFileLoad = (file) => (f) => {
            return ImageUtil.parseImage(f.target.result)
                .then(() => {
                const state = {
                    previewImage: f.target.result,
                    filename: file.name,
                };
                this.setState(state);
            })
                .catch(() => {
                this.setState({
                    chooseEmojiErrorMessage: messages.emojiInvalidImage,
                });
                this.cancelChooseFile();
            });
        };
        this.cancelChooseFile = () => {
            this.setState({
                previewImage: undefined,
            });
        };
        this.onChooseFile = (event) => {
            const files = event.target.files;
            if (files.length) {
                const reader = new FileReader();
                const file = files[0];
                if (ImageUtil.hasFileExceededSize(file)) {
                    this.setState({
                        chooseEmojiErrorMessage: messages.emojiImageTooBig,
                    });
                    this.cancelChooseFile();
                    return;
                }
                reader.addEventListener('load', this.onFileLoad(file));
                reader.addEventListener('abort', this.errorOnUpload);
                reader.addEventListener('error', this.errorOnUpload);
                reader.readAsDataURL(file);
            }
            else {
                this.cancelChooseFile();
            }
        };
        this.clearUploadPicker = () => {
            this.setState({
                name: undefined,
                previewImage: undefined,
                uploadStatus: UploadStatus.Waiting,
            });
        };
        if (props.errorMessage) {
            this.state.uploadStatus = UploadStatus.Error;
        }
        if (props.initialUploadName) {
            this.state.name = sanitizeName(props.initialUploadName);
        }
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        const updatedState = {};
        if (nextProps.errorMessage) {
            updatedState.uploadStatus = UploadStatus.Error;
        }
        else {
            if (this.state.uploadStatus === UploadStatus.Error) {
                updatedState.uploadStatus = UploadStatus.Waiting;
            }
        }
        if (nextProps.initialUploadName) {
            if (!this.state.name) {
                updatedState.name = sanitizeName(nextProps.initialUploadName);
            }
        }
        this.setState(updatedState);
    }
    render() {
        const { errorMessage, onUploadCancelled } = this.props;
        const { name, previewImage, uploadStatus, chooseEmojiErrorMessage, } = this.state;
        const cancelUpload = () => {
            this.clearUploadPicker();
            onUploadCancelled();
        };
        if (name && previewImage) {
            return (React.createElement(EmojiUploadPreview, { errorMessage: errorMessage, name: name, onAddEmoji: this.onAddEmoji, onUploadCancelled: cancelUpload, previewImage: previewImage, uploadStatus: uploadStatus }));
        }
        return (React.createElement(ChooseEmojiFile, { name: name, onChooseFile: this.onChooseFile, onClick: this.props.onFileChooserClicked, onNameChange: this.onNameChange, onUploadCancelled: cancelUpload, errorMessage: chooseEmojiErrorMessage ? (React.createElement(FormattedMessage, Object.assign({}, chooseEmojiErrorMessage))) : (undefined) }));
    }
}
//# sourceMappingURL=EmojiUploadPicker.js.map