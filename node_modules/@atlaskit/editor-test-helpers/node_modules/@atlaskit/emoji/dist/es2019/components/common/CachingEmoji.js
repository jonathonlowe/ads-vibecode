import PropTypes from 'prop-types';
import React from 'react';
import { PureComponent } from 'react';
import { shouldUseAltRepresentation } from '../../api/EmojiUtils';
import { isEmojiDescription, isMediaEmoji, isPromise, } from '../../util/type-helpers';
import debug from '../../util/logger';
import Emoji from './Emoji';
import EmojiPlaceholder from './EmojiPlaceholder';
/**
 * Renders an emoji from a cached image, if required.
 */
export const CachingEmoji = (props) => {
    // Optimisation to only render the class based CachingMediaEmoji if necessary
    // slight performance hit, which accumulates for a large number of emoji.
    const { placeholderSize, ...emojiProps } = props;
    if (isMediaEmoji(props.emoji)) {
        return React.createElement(CachingMediaEmoji, Object.assign({}, props));
    }
    return React.createElement(Emoji, Object.assign({}, emojiProps));
};
/**
 * Rendering a media emoji image from a cache for media emoji, with different
 * rendering paths depending on caching strategy.
 */
export class CachingMediaEmoji extends PureComponent {
    constructor(props, context) {
        super(props, context);
        this.mounted = false;
        this.handleLoadError = (_emojiId, emoji) => {
            const { invalidImage } = this.state;
            if (invalidImage || !emoji) {
                // do nothing, bad image
                return;
            }
            this.setState({
                cachedEmoji: this.loadEmoji(emoji, this.context, true),
            });
        };
        this.state = {
            cachedEmoji: this.loadEmoji(props.emoji, context, false),
        };
    }
    componentDidMount() {
        this.mounted = true;
    }
    componentWillUnmount() {
        this.mounted = false;
    }
    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
        if (nextProps.emoji !== this.props.emoji) {
            if (this.mounted) {
                this.setState({
                    cachedEmoji: this.loadEmoji(nextProps.emoji, nextContext, false),
                });
            }
        }
    }
    loadEmoji(emoji, context, forceLoad) {
        if (!context.emoji) {
            return undefined;
        }
        const { emojiProvider } = context.emoji;
        if (!emojiProvider) {
            return undefined;
        }
        const { fitToHeight } = this.props;
        const useAlt = shouldUseAltRepresentation(emoji, fitToHeight);
        const optimisticRendering = emojiProvider.optimisticMediaRendering(emoji, useAlt);
        if (optimisticRendering && !forceLoad) {
            debug('Optimistic rendering', emoji.shortName);
            return emoji;
        }
        debug('Loading image via media cache', emoji.shortName);
        const loadedEmoji = emojiProvider.loadMediaEmoji(emoji, useAlt);
        if (isPromise(loadedEmoji)) {
            loadedEmoji
                .then(cachedEmoji => {
                if (this.mounted) {
                    this.setState({
                        cachedEmoji,
                        invalidImage: !cachedEmoji,
                    });
                }
            })
                .catch(() => {
                if (this.mounted) {
                    this.setState({
                        cachedEmoji: undefined,
                        invalidImage: true,
                    });
                }
            });
            return undefined;
        }
        if (isEmojiDescription(loadedEmoji)) {
            return loadedEmoji;
        }
        return undefined;
    }
    render() {
        const { cachedEmoji } = this.state;
        const { children, placeholderSize, ...otherProps } = this.props;
        let emojiComponent;
        if (cachedEmoji) {
            emojiComponent = (React.createElement(Emoji, Object.assign({}, otherProps, { emoji: cachedEmoji, onLoadError: this.handleLoadError })));
        }
        else {
            const { emoji, placeholderSize, showTooltip, fitToHeight } = this.props;
            const { shortName, representation } = emoji;
            emojiComponent = (React.createElement(EmojiPlaceholder, { size: fitToHeight || placeholderSize, shortName: shortName, showTooltip: showTooltip, representation: representation }));
        }
        return emojiComponent;
    }
}
CachingMediaEmoji.contextTypes = {
    emoji: PropTypes.object,
};
export default CachingEmoji;
//# sourceMappingURL=CachingEmoji.js.map