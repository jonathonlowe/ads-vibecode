import classNames from 'classnames';
import PropTypes from 'prop-types';
import React from 'react';
import uuid from 'uuid';
import { PureComponent } from 'react';
import { defaultListLimit } from '../../util/constants';
import { toEmojiId } from '../../util/type-helpers';
import { SearchSort, } from '../../types';
import debug from '../../util/logger';
import { typeaheadCancelledEvent, typeaheadSelectedEvent, typeaheadRenderedEvent, } from '../../util/analytics';
import { createRecordSelectionDefault } from '../common/RecordSelectionDefault';
import EmojiList from './EmojiTypeAheadList';
import * as styles from './styles';
const isFullShortName = (query) => query &&
    query.length > 1 &&
    query.charAt(0) === ':' &&
    query.charAt(query.length - 1) === ':';
const uniqueExactShortNameMatchIndex = (searchResult, query) => {
    if (!query) {
        return undefined;
    }
    query = query.toLowerCase();
    let matchIndex;
    let index = 0;
    for (const emoji of searchResult.emojis) {
        if (query && emoji.shortName.toLowerCase() === query) {
            if (matchIndex === undefined) {
                matchIndex = index;
            }
            else {
                return;
            }
        }
        index++;
    }
    return matchIndex;
};
export default class EmojiTypeAheadComponent extends PureComponent {
    constructor(props) {
        super(props);
        this.emojiListRef = null;
        this.openTime = 0;
        this.renderStartTime = 0;
        this.selectNext = () => {
            if (this.emojiListRef) {
                this.emojiListRef.selectNext();
            }
        };
        this.selectPrevious = () => {
            if (this.emojiListRef) {
                this.emojiListRef.selectPrevious();
            }
        };
        this.chooseCurrentSelection = () => {
            this.pressed = true;
            if (this.emojiListRef) {
                this.emojiListRef.chooseCurrentSelection();
            }
        };
        this.count = () => {
            const { emojis } = this.state;
            return (emojis && emojis.length) || 0;
        };
        this.getTone = (tone) => {
            return typeof tone === 'undefined'
                ? undefined
                : tone >= 0 && tone <= 5
                    ? ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'][tone]
                    : undefined;
        };
        this.onSearchResult = (result) => {
            const { emojis, query } = result;
            const wasVisible = this.state.visible;
            const visible = emojis.length > 0;
            this.fireAnalyticsEvent(typeaheadRenderedEvent(Date.now() - this.renderStartTime, query, emojis));
            debug('emoji-typeahead.applyPropChanges', emojis.length, wasVisible, visible);
            this.setState({
                emojis: emojis,
                visible,
                loading: false,
            });
            if (isFullShortName(query)) {
                const matchIndex = uniqueExactShortNameMatchIndex(result, query);
                if (matchIndex !== undefined) {
                    const onSelect = createRecordSelectionDefault(this.props.emojiProvider, this.props.onSelection, analytic => this.fireAnalyticsEvent(analytic('typeahead')));
                    this.fireSelectionEvent(result.emojis[matchIndex], true);
                    onSelect(toEmojiId(result.emojis[matchIndex]), result.emojis[matchIndex]);
                }
            }
            if (wasVisible !== visible) {
                if (visible) {
                    if (this.props.onOpen) {
                        this.props.onOpen();
                    }
                }
                else {
                    if (this.props.onClose) {
                        this.props.onClose();
                    }
                }
            }
        };
        this.onProviderChange = {
            result: this.onSearchResult,
        };
        this.onEmojiListRef = (ref) => {
            this.emojiListRef = ref;
        };
        this.state = {
            visible: true,
            emojis: [],
            loading: true,
        };
        if (this.props.onOpen) {
            this.props.onOpen();
        }
        this.openTime = Date.now();
        this.renderStartTime = this.openTime;
        this.selectedTone = props.emojiProvider.getSelectedTone();
        this.pressed = false;
        this.sessionId = uuid();
        this.selected = false;
    }
    getChildContext() {
        return {
            emoji: {
                emojiProvider: this.props.emojiProvider,
            },
        };
    }
    componentDidMount() {
        const { emojiProvider } = this.props;
        emojiProvider.subscribe(this.onProviderChange);
        this.onSearch(this.props.query);
    }
    componentWillUnmount() {
        const { emojiProvider, query } = this.props;
        const { emojis } = this.state;
        emojiProvider.unsubscribe(this.onProviderChange);
        if (!this.selected) {
            this.fireAnalyticsEvent(typeaheadCancelledEvent(Date.now() - this.openTime, query, emojis));
        }
        this.sessionId = uuid();
        this.selected = false;
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        const prevEmojiProvider = this.props.emojiProvider;
        const nextEmojiProvider = nextProps.emojiProvider;
        if (prevEmojiProvider !== nextEmojiProvider) {
            prevEmojiProvider.unsubscribe(this.onProviderChange);
            nextEmojiProvider.subscribe(this.onProviderChange);
            this.onSearch(nextProps.query);
        }
        else if (this.props.query !== nextProps.query) {
            this.onSearch(nextProps.query);
        }
    }
    fireAnalyticsEvent(payload) {
        if (!this.props.createAnalyticsEvent) {
            return;
        }
        payload.attributes.sessionId = this.sessionId;
        this.props.createAnalyticsEvent(payload).fire('fabric-elements');
    }
    onSearch(query) {
        const { emojiProvider, listLimit } = this.props;
        const options = {
            limit: listLimit || defaultListLimit,
            skinTone: this.selectedTone,
        };
        if (query && query.replace(':', '').length > 0) {
            options.sort = SearchSort.Default;
        }
        else {
            // if empty query (i.e. typeahead triggered only) then only sort by usage
            options.sort = SearchSort.UsageFrequency;
        }
        this.renderStartTime = Date.now();
        emojiProvider.filter(query, options);
    }
    fireSelectionEvent(emoji, exactMatch) {
        const { query } = this.props;
        const { emojis } = this.state;
        this.selected = true;
        this.fireAnalyticsEvent(typeaheadSelectedEvent(exactMatch || this.pressed, Date.now() - this.openTime, emoji, emojis, query, exactMatch));
    }
    render() {
        const { emojiProvider, onSelection } = this.props;
        const recordUsageOnSelection = createRecordSelectionDefault(emojiProvider, (emojiId, emoji, event) => {
            this.fireSelectionEvent(emoji);
            if (onSelection) {
                onSelection(emojiId, emoji, event);
            }
        }, analytic => this.fireAnalyticsEvent(analytic('typeahead')));
        const { visible, emojis, loading } = this.state;
        const style = {
            display: visible ? 'block' : 'none',
        };
        const classes = classNames(['ak-emoji-typeahead', styles.emojiTypeAhead]);
        return (React.createElement("div", { style: style, className: classes },
            React.createElement(EmojiList, { emojis: emojis, onEmojiSelected: recordUsageOnSelection, ref: this.onEmojiListRef, loading: loading })));
    }
}
EmojiTypeAheadComponent.childContextTypes = {
    emoji: PropTypes.object,
};
EmojiTypeAheadComponent.defaultProps = {
    onSelection: () => { },
    onOpen: () => { },
    onClose: () => { },
    listLimit: defaultListLimit,
};
//# sourceMappingURL=EmojiTypeAheadComponent.js.map