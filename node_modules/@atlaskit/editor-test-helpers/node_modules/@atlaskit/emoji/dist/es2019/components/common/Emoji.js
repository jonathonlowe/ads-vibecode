import Button from '@atlaskit/button';
import CrossCircleIcon from '@atlaskit/icon/glyph/cross-circle';
import { colors } from '@atlaskit/theme';
import Tooltip from '@atlaskit/tooltip';
import classNames from 'classnames';
import React from 'react';
import { shouldUseAltRepresentation } from '../../api/EmojiUtils';
import { deleteEmojiLabel } from '../../util/constants';
import { isImageRepresentation, isMediaRepresentation, isSpriteRepresentation, toEmojiId, } from '../../util/type-helpers';
import { leftClick } from '../../util/mouse';
import * as styles from './styles';
const handleMouseDown = (props, event) => {
    // Clicked emoji delete button
    if (event.target instanceof Element &&
        event.target.getAttribute('aria-label') === deleteEmojiLabel) {
        return;
    }
    const { emoji, onSelected } = props;
    event.preventDefault();
    if (onSelected && leftClick(event)) {
        onSelected(toEmojiId(emoji), emoji, event);
    }
};
const handleMouseMove = (props, event) => {
    const { emoji, onMouseMove } = props;
    if (onMouseMove) {
        onMouseMove(toEmojiId(emoji), emoji, event);
    }
};
const handleDelete = (props, event) => {
    const { emoji, onDelete } = props;
    if (onDelete) {
        onDelete(toEmojiId(emoji), emoji, event);
    }
};
const handleImageError = (props, event) => {
    const { emoji, onLoadError } = props;
    // Hide error state (but keep space for it)
    if (event.target) {
        const target = event.target;
        target.style.visibility = 'hidden';
    }
    if (onLoadError) {
        onLoadError(toEmojiId(emoji), emoji, event);
    }
};
// Pure functional components are used in favour of class based components, due to the performance!
// When rendering 1500+ emoji using class based components had a significant impact.
const renderAsSprite = (props) => {
    const { emoji, fitToHeight, selected, selectOnHover, className, showTooltip, } = props;
    const representation = emoji.representation;
    const sprite = representation.sprite;
    const classes = {
        [styles.emojiContainer]: true,
        [styles.emojiNode]: true,
        [styles.selected]: selected,
        [styles.selectOnHover]: selectOnHover,
    };
    if (className) {
        classes[className] = true;
    }
    let sizing = {};
    if (fitToHeight) {
        sizing = {
            width: `${fitToHeight}px`,
            height: `${fitToHeight}px`,
        };
    }
    const xPositionInPercent = (100 / (sprite.column - 1)) * (representation.xIndex - 0);
    const yPositionInPercent = (100 / (sprite.row - 1)) * (representation.yIndex - 0);
    const style = {
        backgroundImage: `url(${sprite.url})`,
        backgroundPosition: `${xPositionInPercent}% ${yPositionInPercent}%`,
        backgroundSize: `${sprite.column * 100}% ${sprite.row * 100}%`,
        ...sizing,
    };
    const emojiNode = (React.createElement("span", { className: styles.emojiSprite, style: style }, "\u00A0"));
    return (React.createElement("span", { className: classNames(classes), onMouseDown: event => {
            handleMouseDown(props, event);
        }, onMouseMove: event => {
            handleMouseMove(props, event);
        }, "aria-label": emoji.shortName }, showTooltip ? (React.createElement(Tooltip, { tag: "span", content: emoji.shortName }, emojiNode)) : (emojiNode)));
};
// Keep as pure functional component, see renderAsSprite.
const renderAsImage = (props) => {
    const { emoji, fitToHeight, selected, selectOnHover, className, showTooltip, showDelete, } = props;
    const classes = {
        [styles.emoji]: true,
        [styles.emojiNode]: true,
        [styles.selected]: selected,
        [styles.selectOnHover]: selectOnHover,
        [styles.emojiImage]: true,
    };
    if (className) {
        classes[className] = true;
    }
    let width;
    let height;
    let src;
    const representation = shouldUseAltRepresentation(emoji, fitToHeight)
        ? emoji.altRepresentation
        : emoji.representation;
    if (isImageRepresentation(representation)) {
        src = representation.imagePath;
        width = representation.width;
        height = representation.height;
    }
    else if (isMediaRepresentation(representation)) {
        src = representation.mediaPath;
        width = representation.width;
        height = representation.height;
    }
    let deleteButton;
    if (showDelete) {
        deleteButton = (React.createElement("span", { className: styles.deleteButton },
            React.createElement(Button, { iconBefore: React.createElement(CrossCircleIcon, { label: deleteEmojiLabel, primaryColor: colors.N500, size: "small" }), onClick: (event) => handleDelete(props, event), appearance: "subtle-link", spacing: "none" })));
    }
    let sizing = {};
    if (fitToHeight && width && height) {
        // Presize image, to prevent reflow due to size changes after loading
        sizing = {
            width: (fitToHeight / height) * width,
            height: fitToHeight,
        };
    }
    const onError = (event) => {
        handleImageError(props, event);
    };
    // Pass src attribute as key to force React to rerender img node since browser does not
    // change preview image until loaded
    const emojiNode = (React.createElement("img", Object.assign({ src: src, key: src, alt: emoji.shortName, "data-emoji-short-name": emoji.shortName, "data-emoji-id": emoji.id, "data-emoji-text": emoji.fallback || emoji.shortName, className: "emoji", style: { visibility: 'visible' }, onError: onError }, sizing)));
    return (React.createElement("span", { className: classNames(classes), onMouseDown: event => {
            handleMouseDown(props, event);
        }, onMouseMove: event => {
            handleMouseMove(props, event);
        }, "aria-label": emoji.shortName },
        deleteButton,
        showTooltip ? (React.createElement(Tooltip, { tag: "span", content: emoji.shortName }, emojiNode)) : (emojiNode)));
};
export const Emoji = (props) => {
    const { emoji } = props;
    if (isSpriteRepresentation(emoji.representation)) {
        return renderAsSprite(props);
    }
    return renderAsImage(props);
};
export default Emoji;
//# sourceMappingURL=Emoji.js.map