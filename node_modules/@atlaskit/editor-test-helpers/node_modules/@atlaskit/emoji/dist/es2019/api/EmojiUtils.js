import { utils as serviceUtils, } from '@atlaskit/util-service-support';
import { isImageRepresentation, isSpriteServiceRepresentation, convertImageToMediaRepresentation, buildEmojiDescriptionWithAltRepresentation, } from '../util/type-helpers';
import debug from '../util/logger';
export const emojiRequest = (provider, options) => {
    const { getRatio = getPixelRatio, ...serviceConfig } = provider;
    const scaleQueryParams = calculateScale(getRatio);
    const { queryParams = {}, ...otherOptions } = options || {};
    const requestOptions = {
        ...otherOptions,
        queryParams: {
            ...scaleQueryParams,
            ...queryParams,
        },
    };
    return serviceUtils.requestService(serviceConfig, requestOptions);
};
const calculateScale = (getRatio) => {
    // Retina display
    if (getRatio() > 1) {
        return { scale: 'XHDPI', altScale: 'XXXHDPI' };
    }
    // Default set used for desktop
    return { altScale: 'XHDPI' };
};
export const getPixelRatio = () => {
    return window.devicePixelRatio;
};
export const getAltRepresentation = (reps) => {
    // Invalid reps handled outside function - logic may change depending what the service returns
    return reps[calculateScale(getPixelRatio).altScale];
};
export const isMediaApiUrl = (url, meta) => !!(meta && meta.mediaApiToken && url.indexOf(meta.mediaApiToken.url) === 0);
export const denormaliseServiceRepresentation = (representation, meta) => {
    if (isSpriteServiceRepresentation(representation) &&
        meta &&
        meta.spriteSheets) {
        const { height, width, x, y, xIndex, yIndex, spriteRef, } = representation;
        const spriteSheet = meta.spriteSheets[spriteRef];
        if (spriteSheet) {
            return {
                sprite: spriteSheet,
                height,
                width,
                x,
                y,
                xIndex,
                yIndex,
            };
        }
    }
    else if (isImageRepresentation(representation)) {
        const { height, width, imagePath } = representation;
        if (isMediaApiUrl(imagePath, meta)) {
            return convertImageToMediaRepresentation(representation);
        }
        return {
            height,
            width,
            imagePath,
        };
    }
    debug('failed conversion for representation', representation, meta);
    return undefined;
};
export const denormaliseServiceAltRepresentation = (altReps, meta) => {
    return !altReps || altReps === {}
        ? undefined
        : denormaliseServiceRepresentation(getAltRepresentation(altReps), meta);
};
export const denormaliseSkinEmoji = (emoji, meta) => {
    if (!emoji.skinVariations) {
        return [];
    }
    const skinEmoji = emoji.skinVariations;
    const baseId = emoji.id;
    return skinEmoji.map((skin) => {
        const { representation, altRepresentations, ...other } = skin;
        return {
            baseId: baseId,
            representation: denormaliseServiceRepresentation(representation, meta),
            altRepresentation: denormaliseServiceAltRepresentation(altRepresentations, meta),
            ...other,
        };
    });
};
/**
 * Denormalised an emoji response (emojis + sprite references) into an array of
 * emoji with local sprite definitions.
 */
export const denormaliseEmojiServiceResponse = (emojiData) => {
    const emojis = emojiData.emojis.map((emoji) => {
        const newRepresentation = denormaliseServiceRepresentation(emoji.representation, emojiData.meta);
        const altRepresentation = denormaliseServiceAltRepresentation(emoji.altRepresentations, emojiData.meta);
        const newSkinVariations = denormaliseSkinEmoji(emoji, emojiData.meta);
        // create trimmedServiceDesc which is emoji with no representations or skinVariations
        const { representation, skinVariations, altRepresentations, ...trimmedServiceDesc } = emoji;
        const response = {
            ...trimmedServiceDesc,
            representation: newRepresentation,
            skinVariations: newSkinVariations,
        };
        return buildEmojiDescriptionWithAltRepresentation(response, altRepresentation);
    });
    const mediaApiToken = emojiData.meta && emojiData.meta.mediaApiToken;
    return {
        emojis,
        mediaApiToken,
    };
};
const getHeight = (fitToHeight) => getPixelRatio() > 1 ? fitToHeight * 2 : fitToHeight;
export const shouldUseAltRepresentation = (emoji, fitToHeight) => !!(fitToHeight &&
    emoji.altRepresentation &&
    getHeight(fitToHeight) > emoji.representation.height);
//# sourceMappingURL=EmojiUtils.js.map