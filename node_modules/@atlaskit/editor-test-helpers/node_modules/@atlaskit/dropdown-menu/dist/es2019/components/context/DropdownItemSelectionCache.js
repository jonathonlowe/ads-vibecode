import React, { Component } from 'react';
import find from 'array-find';
import PropTypes from 'prop-types';
import { selectionCacheContext } from '../../util/contextNamespace';
const isItemInList = (itemList, itemId, groupId) => Boolean(find(itemList, item => item.id === itemId && item.groupId === groupId));
export default class DropdownItemSelectionCache extends Component {
    constructor() {
        super(...arguments);
        // Need to store selectedItemValues in state rather than component instance property
        // to ensure that re-render happens down the tree via context when selectedItemValues
        // is updated.
        this.state = {
            lastCacheUpdate: 0,
        };
        this.selectedItems = []; // eslint-disable-line react/sort-comp
        // If any radio/checkbox items have defaultSelected applied, we need to keep track of whether
        // each of those items has had it's state set to 'selected'. This is because when the dropdown
        // menu is closed and then opened again, all of the radio/checkbox items re-mount so they
        // try to again apply their defaultSelected status. defaultSelected should only be applied on
        // the initial mount, as users can change the value post-mount. Alternatively, products can use
        // the isSelected prop with the onClick handler to control the selected state manually if needed.
        this.alreadyDefaultedItems = []; // eslint-disable-line react/sort-comp
        this.handleItemSelectionsChanged = (groupId, newGroupSelections) => {
            const newSelectedItems = [
                ...this.selectedItems.filter(item => item.groupId !== groupId),
                ...newGroupSelections,
            ];
            this.selectedItems = newSelectedItems;
            // We store selectedItems in an instance variable (this.selectedItems) instead of state,
            // because if multiple children update the cache at the same time it causes unexpected
            // behaviour due to the asynchronous behaviour of setState. So we need to trigger setState
            // with a different value to cause the children to be updated with their new selection values.
            this.setState({ lastCacheUpdate: Date.now() });
        };
    }
    getChildContext() {
        return {
            [selectionCacheContext]: {
                // This function returns true/false describing whether the supplied navigation item
                // (which must have a unique item and group ID) is currently selected - this is used
                // by radio and checkbox dropdown items to retreive their 'selected' state when they
                // re-mount, which happens when the dropdown is closed and then re-opened.
                isItemSelected: (groupId, itemId) => isItemInList(this.selectedItems, itemId, groupId),
                itemsInGroup: (groupId) => this.selectedItems.filter((item) => item.groupId === groupId),
                itemSelectionsChanged: this.handleItemSelectionsChanged,
                hasItemAlreadyHadDefaultSelectedApplied: (groupId, itemId) => isItemInList(this.alreadyDefaultedItems, itemId, groupId),
                markItemAsDefaultApplied: (groupId, itemId) => {
                    this.alreadyDefaultedItems.push({ id: itemId, groupId });
                },
            },
        };
    }
    render() {
        return React.createElement("div", null, this.props.children);
    }
}
DropdownItemSelectionCache.childContextTypes = {
    [selectionCacheContext]: PropTypes.shape({
        isItemSelected: PropTypes.func,
        itemsInGroup: PropTypes.func,
        itemSelectionsChanged: PropTypes.func,
    }),
};
//# sourceMappingURL=DropdownItemSelectionCache.js.map