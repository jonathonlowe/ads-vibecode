import * as specs from './specs';
const isDefined = (x) => x != null;
const isNumber = (x) => typeof x === 'number' && !isNaN(x) && isFinite(x);
const isInteger = (x) => typeof x === 'number' && isFinite(x) && Math.floor(x) === x;
const isBoolean = (x) => x === true || x === false || toString.call(x) === '[object Boolean]';
// This is a kludge, might replace with something like _.isString in future
const isString = (s) => typeof s === 'string' || s instanceof String;
const isPlainObject = (x) => typeof x === 'object' && x !== null && !Array.isArray(x);
const copy = (source, dest, key) => {
    dest[key] = source[key];
    return dest;
};
// Helpers
const makeArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
function isForceContentValidationSpec(x) {
    return isDefined(x.forceContentValidation);
}
function mapMarksItems(spec, fn = (x) => x) {
    const { items, ...rest } = spec.props.marks;
    return {
        ...spec,
        props: {
            ...spec.props,
            marks: {
                ...rest,
                /**
                 * `Text & MarksObject<Mark-1>` produces `items: ['mark-1']`
                 * `Text & MarksObject<Mark-1 | Mark-2>` produces `items: [['mark-1', 'mark-2']]`
                 */
                items: items.length
                    ? Array.isArray(items[0])
                        ? items.map(fn)
                        : [fn(items)]
                    : [[]],
            },
        },
    };
}
const partitionObject = (obj, predicate) => Object.keys(obj).reduce((acc, key) => {
    acc[predicate(key, obj[key], obj) ? 0 : 1].push(key);
    return acc;
}, [[], []]);
// TODO: no-implicit-any
function createSpec(nodes, marks) {
    return Object.keys(specs).reduce((newSpecs, k) => {
        const spec = { ...specs[k] };
        if (spec.props) {
            spec.props = { ...spec.props };
            if (isString(spec.props.content)) {
                spec.props.content = specs[spec.props.content];
            }
            if (spec.props.content) {
                if (!spec.props.content.items) {
                    /**
                     * Flatten
                     *
                     * Input:
                     * [ { type: 'array', items: [ 'tableHeader' ] }, { type: 'array', items: [ 'tableCell' ] } ]
                     *
                     * Output:
                     * { type: 'array', items: [ [ 'tableHeader' ], [ 'tableCell' ] ] }
                     */
                    spec.props.content = {
                        type: 'array',
                        items: (spec.props.content || []).map(arr => arr.items),
                    };
                }
                else {
                    spec.props.content = { ...spec.props.content };
                }
                spec.props.content.items = spec.props.content.items
                    // ['inline'] => [['emoji', 'hr', ...]]
                    // ['media'] => [['media']]
                    .map(item => isString(item)
                    ? Array.isArray(specs[item])
                        ? specs[item]
                        : [item]
                    : item)
                    // [['emoji', 'hr', 'inline_code']] => [['emoji', 'hr', ['text', { marks: {} }]]]
                    .map((item) => item
                    .map(subItem => Array.isArray(specs[subItem])
                    ? specs[subItem]
                    : isString(subItem)
                        ? subItem
                        : // Now `NoMark` produces `items: []`, should be fixed in generator
                            ['text', subItem])
                    // Remove unsupported nodes & marks
                    // Filter nodes
                    .filter(subItem => 
                // When Mark or `nodes` is undefined don't filter
                !nodes
                    ? true
                    : nodes.indexOf(Array.isArray(subItem) ? subItem[0] : subItem) > -1)
                    // Filter marks
                    .map(subItem => Array.isArray(subItem) && marks
                    ? /**
                       * TODO: Probably try something like immer, but it's 3.3kb gzipped.
                       * Not worth it just for this.
                       */
                        [subItem[0], mapMarksItems(subItem[1])]
                    : subItem));
            }
        }
        newSpecs[k] = spec;
        return newSpecs;
    }, {});
}
function getOptionsForType(type, list) {
    if (!list) {
        return {};
    }
    for (let i = 0, len = list.length; i < len; i++) {
        const spec = list[i];
        let name = spec;
        let options = {};
        if (Array.isArray(spec)) {
            [name, options] = spec;
        }
        if (name === type) {
            return options;
        }
    }
    return false;
}
export function validateAttrs(spec, value) {
    // extension_node parameters has no type
    if (!isDefined(spec.type)) {
        return !!spec.optional;
    }
    if (!isDefined(value)) {
        return !!spec.optional;
    }
    switch (spec.type) {
        case 'boolean':
            return isBoolean(value);
        case 'number':
            return (isNumber(value) &&
                (isDefined(spec.minimum) ? spec.minimum <= value : true) &&
                (isDefined(spec.maximum) ? spec.maximum >= value : true));
        case 'integer':
            return (isInteger(value) &&
                (isDefined(spec.minimum) ? spec.minimum <= value : true) &&
                (isDefined(spec.maximum) ? spec.maximum >= value : true));
        case 'string':
            return (isString(value) &&
                (isDefined(spec.minLength) ? spec.minLength <= value.length : true) &&
                (spec.pattern ? new RegExp(spec.pattern).test(value) : true));
        case 'object':
            return isPlainObject(value);
        case 'array':
            if (!isForceContentValidationSpec(spec)) {
                const types = spec.items;
                const lastTypeIndex = types.length - 1;
                if (Array.isArray(value)) {
                    // We are doing this to support tuple which can be defined as [number, string]
                    // NOTE: Not validating tuples strictly
                    return value.every((x, i) => validateAttrs(types[Math.min(i, lastTypeIndex)], x));
                }
            }
            return false;
        case 'enum':
            return isString(value) && spec.values.indexOf(value) > -1;
    }
    return false;
}
const getUnsupportedOptions = (spec) => {
    if (spec && spec.props && spec.props.content) {
        const { allowUnsupportedBlock, allowUnsupportedInline, } = spec.props.content;
        return { allowUnsupportedBlock, allowUnsupportedInline };
    }
    return {};
};
const invalidChildContent = (child, errorCallback, parentSpec) => {
    const message = `${child.type}: invalid content.`;
    if (!errorCallback) {
        throw new Error(message);
    }
    else {
        return errorCallback({ ...child }, {
            code: 'INVALID_CONTENT',
            message,
        }, getUnsupportedOptions(parentSpec));
    }
};
export function validator(nodes, marks, options) {
    const validatorSpecs = createSpec(nodes, marks);
    const { mode = 'strict', allowPrivateAttributes = false } = options || {};
    const validate = (entity, errorCallback, allowed, parentSpec) => {
        const { type } = entity;
        let newEntity = { ...entity };
        const err = (code, msg, meta) => {
            const message = `${type}: ${msg}.`;
            if (errorCallback) {
                return {
                    valid: false,
                    entity: errorCallback(newEntity, { code, message, meta }, getUnsupportedOptions(parentSpec)),
                };
            }
            else {
                throw new Error(message);
            }
        };
        if (type) {
            const typeOptions = getOptionsForType(type, allowed);
            if (typeOptions === false) {
                return err('INVALID_TYPE', 'type not allowed here');
            }
            const spec = validatorSpecs[type];
            if (!spec) {
                return err('INVALID_TYPE', `${type}: No validation spec found for type!`);
            }
            const validator = {
                ...spec,
                ...typeOptions,
                // options with props can override props of spec
                ...(spec.props
                    ? { props: { ...spec.props, ...(typeOptions['props'] || {}) } }
                    : {}),
            };
            if (validator) {
                // Required Props
                // For array format where `required` is an array
                if (validator.required) {
                    if (!validator.required.every(prop => isDefined(entity[prop]))) {
                        return err('MISSING_PROPERTIES', 'required prop missing');
                    }
                }
                if (validator.props) {
                    // Check text
                    if (validator.props.text) {
                        if (isDefined(entity.text) &&
                            !validateAttrs(validator.props.text, entity.text)) {
                            return err('INVALID_TEXT', `'text' validation failed`);
                        }
                    }
                    // Content Length
                    if (validator.props.content &&
                        isDefined(validator.props.content.minItems) &&
                        entity.content) {
                        const length = entity.content.length;
                        if (validator.props.content.minItems > length) {
                            const { minItems } = validator.props.content;
                            return err('INVALID_CONTENT_LENGTH', `'content' should have more than ${minItems} child`, { length });
                        }
                    }
                    // Required Props
                    // For object format based on `optional` property
                    const [, missingProps] = partitionObject(validator.props, (k, v) => v.optional || !!entity[k]);
                    if (missingProps.length) {
                        return err('MISSING_PROPERTIES', 'required prop missing', {
                            props: missingProps,
                        });
                    }
                    // Attributes
                    let validatorAttrs = {};
                    // Attributes Validation
                    if (validator.props.attrs && entity.attrs) {
                        const attrOptions = makeArray(validator.props.attrs);
                        let invalidAttrs = [];
                        /**
                         * Attrs can be union type so try each path
                         * attrs: [{ props: { url: { type: 'string' } } }, { props: { data: {} } }],
                         * Gotcha: It will always report the last failure.
                         */
                        for (let i = 0, length = attrOptions.length; i < length; ++i) {
                            const attrOption = attrOptions[i];
                            [, invalidAttrs] = partitionObject(attrOption.props, (k, v) => {
                                // We need to validate the content from that kind of
                                // array against the nodes and marks. @see ED-6325
                                if (isForceContentValidationSpec(v) &&
                                    v.forceContentValidation) {
                                    const items = entity.attrs[k] || [];
                                    const newItems = [];
                                    const specItemsAllowed = v.items;
                                    const entitySet = specItemsAllowed.reduce((xs, x) => xs.concat(x));
                                    for (let i = 0; i < items.length; i++) {
                                        const validateResult = validate(items[i], errorCallback, entitySet, validator);
                                        if (!validateResult.valid && validateResult.entity) {
                                            newItems.push(validateResult.entity);
                                        }
                                    }
                                    newEntity.attrs = { ...newEntity.attrs };
                                    newEntity.attrs[k] = newItems;
                                    return true;
                                }
                                else {
                                    return validateAttrs(v, entity.attrs[k]);
                                }
                            });
                            if (!invalidAttrs.length) {
                                validatorAttrs = attrOption;
                                break;
                            }
                        }
                        if (invalidAttrs.length) {
                            return err('INVALID_ATTRIBUTES', `'attrs' validation failed`, {
                                attrs: invalidAttrs,
                            });
                        }
                    }
                    // Extra Props
                    const [requiredProps, redundantProps] = partitionObject(entity, k => isDefined(validator.props[k]));
                    if (redundantProps.length) {
                        if (mode === 'loose') {
                            newEntity = { type };
                            requiredProps.reduce((acc, p) => copy(entity, acc, p), newEntity);
                        }
                        else {
                            return err('REDUNDANT_PROPERTIES', `redundant props found: ${redundantProps.join(', ')}`, { props: redundantProps });
                        }
                    }
                    // Extra Attributes
                    if (entity.attrs) {
                        const attrs = Object.keys(entity.attrs).filter(k => !(allowPrivateAttributes && k.startsWith('__')));
                        if (!validatorAttrs ||
                            !attrs.every(a => !!validatorAttrs.props[a])) {
                            if (mode === 'loose') {
                                newEntity.attrs = {};
                                attrs
                                    .filter(a => !!validatorAttrs.props[a])
                                    .reduce((acc, p) => copy(entity.attrs || {}, acc, p), newEntity.attrs);
                            }
                            else {
                                const redundantAttrs = attrs.filter(a => !validatorAttrs.props[a]);
                                return err('REDUNDANT_ATTRIBUTES', `redundant attributes found: ${redundantAttrs.join(', ')}`, { attrs: redundantAttrs });
                            }
                        }
                    }
                    // Children
                    if (validator.props.content) {
                        if (entity.content) {
                            newEntity.content = entity.content
                                .map((child, index) => {
                                // Only go inside valid branch
                                const validSets = validator.props.content.items.filter(set => 
                                /**
                                 * Manually treat listItem content as Tuple,
                                 * hopefully tsc has new AST for Tuple in v3.0
                                 */
                                type === 'listItem'
                                    ? true
                                    : set.some(
                                    // [p, hr, ...] or [p, [text, {}], ...]
                                    spec => (Array.isArray(spec) ? spec[0] : spec) ===
                                        child.type));
                                if (validSets.length) {
                                    /**
                                     * In case of multiple valid branches, we are treating them as Tuple.
                                     * Thought this assumption is incorrect but it works for us since we don't
                                     * have any valid alternative branches.
                                     */
                                    const setIndex = validSets.length > 1
                                        ? Math.min(index, validSets.length - 1)
                                        : 0;
                                    const set = validSets[setIndex].filter(item => (Array.isArray(item) ? item[0] : item) === child.type);
                                    if (set.length === 0) {
                                        return invalidChildContent(child, errorCallback, validator);
                                    }
                                    /**
                                     * When there's multiple possible branches try all of them.
                                     * If all of them fails, throw the first one.
                                     * e.g.- [['text', { marks: ['a'] }], ['text', { marks: ['b'] }]]
                                     */
                                    let firstError;
                                    let firstChild;
                                    for (let i = 0, len = set.length; i < len; i++) {
                                        try {
                                            const { valid, entity: newChildEntity } = validate(child, errorCallback, [set[i]], validator);
                                            if (valid) {
                                                return newChildEntity;
                                            }
                                            else {
                                                firstChild = firstChild || newChildEntity;
                                            }
                                        }
                                        catch (error) {
                                            firstError = firstError || error;
                                        }
                                    }
                                    if (!errorCallback) {
                                        throw firstError;
                                    }
                                    else {
                                        return firstChild;
                                    }
                                }
                                else {
                                    return invalidChildContent(child, errorCallback, validator);
                                }
                            })
                                .filter(Boolean);
                        }
                        else if (!validator.props.content.optional) {
                            return err('MISSING_PROPERTIES', 'missing `content` prop');
                        }
                    }
                    // Marks
                    if (entity.marks) {
                        if (validator.props.marks) {
                            const { items } = validator.props.marks;
                            const marksSet = items.length
                                ? Array.isArray(items[0])
                                    ? items[0]
                                    : items
                                : [];
                            const newMarks = entity.marks
                                .filter(mark => mode === 'strict' && marks
                                ? marks.indexOf(mark.type) > -1
                                : true)
                                .map(mark => validate(mark, errorCallback, marksSet, validator).entity)
                                .filter(Boolean);
                            if (newMarks.length) {
                                newEntity.marks = newMarks;
                            }
                            else {
                                delete newEntity.marks;
                                return { valid: false, entity: newEntity };
                            }
                        }
                        else {
                            return err('REDUNDANT_MARKS', 'redundant marks', {
                                marks: Object.keys(entity.marks),
                            });
                        }
                    }
                }
                else {
                    const props = Object.keys(entity);
                    // If there's no validator.props then there shouldn't be any key except `type`
                    if (props.length > 1) {
                        return err('REDUNDANT_PROPERTIES', `redundant props found: ${Object.keys(entity).join(', ')}`, { props });
                    }
                }
            }
        }
        else {
            return err('INVALID_TYPE', 'ProseMirror Node/Mark should contain a `type`');
        }
        return { valid: true, entity: newEntity };
    };
    return validate;
}
//# sourceMappingURL=validator.js.map