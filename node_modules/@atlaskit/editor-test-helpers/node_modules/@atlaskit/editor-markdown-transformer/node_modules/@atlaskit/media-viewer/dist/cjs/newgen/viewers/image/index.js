"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var media_client_1 = require("@atlaskit/media-client");
var media_ui_1 = require("@atlaskit/media-ui");
var domain_1 = require("../../domain");
var error_1 = require("../../error");
var interactive_img_1 = require("./interactive-img");
var base_viewer_1 = require("../base-viewer");
function processedFileStateToMediaItem(file) {
    return {
        type: 'file',
        details: {
            id: file.id,
        },
    };
}
var ImageViewer = /** @class */ (function (_super) {
    tslib_1.__extends(ImageViewer, _super);
    function ImageViewer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onLoad = function () {
            _this.props.onLoad({ status: 'success' });
            _this.onMediaDisplayed();
        };
        _this.onError = function () {
            _this.props.onLoad({
                status: 'error',
                errorMessage: 'Interactive-img render failed',
            });
        };
        return _this;
    }
    Object.defineProperty(ImageViewer.prototype, "initialState", {
        get: function () {
            return { content: domain_1.Outcome.pending() };
        },
        enumerable: true,
        configurable: true
    });
    ImageViewer.prototype.init = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, file, mediaClient, collectionName, orientation_1, objectUrl, originalBinaryImageUrl, isLocalFileReference, preview, _b, value, origin_1, item, controller_1, response, _c, _d, err_1, errorMessage;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = this.props, file = _a.item, mediaClient = _a.mediaClient, collectionName = _a.collectionName;
                        if (file.status === 'error') {
                            return [2 /*return*/];
                        }
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 12, , 13]);
                        orientation_1 = 1;
                        objectUrl = void 0;
                        originalBinaryImageUrl = void 0;
                        isLocalFileReference = false;
                        preview = file.preview;
                        if (!preview) return [3 /*break*/, 6];
                        return [4 /*yield*/, preview];
                    case 2:
                        _b = _e.sent(), value = _b.value, origin_1 = _b.origin;
                        if (!(value instanceof Blob)) return [3 /*break*/, 4];
                        return [4 /*yield*/, media_ui_1.getOrientation(value)];
                    case 3:
                        orientation_1 = _e.sent();
                        objectUrl = URL.createObjectURL(value);
                        isLocalFileReference = origin_1 === 'local';
                        return [3 /*break*/, 5];
                    case 4:
                        objectUrl = value;
                        _e.label = 5;
                    case 5: return [3 /*break*/, 9];
                    case 6:
                        if (!media_client_1.isImageRepresentationReady(file)) return [3 /*break*/, 8];
                        item = processedFileStateToMediaItem(file);
                        controller_1 = typeof AbortController !== 'undefined'
                            ? new AbortController()
                            : undefined;
                        response = mediaClient.getImage(item.details.id, {
                            collection: collectionName,
                            mode: 'fit',
                        }, controller_1, true);
                        this.cancelImageFetch = function () { return controller_1 && controller_1.abort(); };
                        _d = (_c = URL).createObjectURL;
                        return [4 /*yield*/, response];
                    case 7:
                        objectUrl = _d.apply(_c, [_e.sent()]);
                        return [3 /*break*/, 9];
                    case 8:
                        this.setState({
                            content: domain_1.Outcome.pending(),
                        });
                        return [2 /*return*/];
                    case 9:
                        if (!(!isLocalFileReference && // objectUrl at this point is binary file already
                            !media_client_1.isErrorFileState(file) &&
                            file.status !== 'uploading' &&
                            file.mediaType === 'image' &&
                            media_client_1.isImageMimeTypeSupportedByBrowser(file.mimeType))) return [3 /*break*/, 11];
                        return [4 /*yield*/, mediaClient.file.getFileBinaryURL(file.id)];
                    case 10:
                        originalBinaryImageUrl = _e.sent();
                        _e.label = 11;
                    case 11:
                        this.setState({
                            content: domain_1.Outcome.successful({
                                objectUrl: objectUrl,
                                orientation: orientation_1,
                                originalBinaryImageUrl: originalBinaryImageUrl,
                            }),
                        });
                        return [3 /*break*/, 13];
                    case 12:
                        err_1 = _e.sent();
                        // TODO : properly handle aborted requests (MS-2843)
                        if (!media_client_1.isAbortedRequestError(err_1)) {
                            this.setState({
                                content: domain_1.Outcome.failed(error_1.createError('previewFailed', err_1, file)),
                            });
                            errorMessage = err_1.message || err_1.name;
                            this.props.onLoad({ status: 'error', errorMessage: errorMessage });
                        }
                        return [3 /*break*/, 13];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    ImageViewer.prototype.release = function () {
        var _this = this;
        if (this.cancelImageFetch) {
            this.cancelImageFetch();
        }
        this.state.content.whenSuccessful(function (_a) {
            var objectUrl = _a.objectUrl;
            _this.revokeObjectUrl(objectUrl);
        });
    };
    // This method is spied on by some test cases, so don't rename or remove it.
    ImageViewer.prototype.revokeObjectUrl = function (objectUrl) {
        URL.revokeObjectURL(objectUrl);
    };
    ImageViewer.prototype.renderSuccessful = function (content) {
        var _a = this.props, item = _a.item, onClose = _a.onClose, contextId = _a.contextId, collectionName = _a.collectionName;
        var src = contextId
            ? media_client_1.addFileAttrsToUrl(content.objectUrl, {
                id: item.id,
                contextId: contextId,
                collection: collectionName,
            })
            : content.objectUrl;
        return (react_1.default.createElement(interactive_img_1.InteractiveImg, { onLoad: this.onLoad, onError: this.onError, src: src, originalBinaryImageSrc: content.originalBinaryImageUrl, orientation: content.orientation, onClose: onClose }));
    };
    return ImageViewer;
}(base_viewer_1.BaseViewer));
exports.ImageViewer = ImageViewer;
//# sourceMappingURL=index.js.map