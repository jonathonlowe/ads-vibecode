import React from 'react';
import { isExternalImageIdentifier, } from '@atlaskit/media-client';
import deepEqual from 'deep-equal';
import { hideControlsClassName, messages, toHumanReadableMediaSize, MediaButton, } from '@atlaskit/media-ui';
import { FormattedMessage, injectIntl } from 'react-intl';
import { Outcome } from './domain';
import { Header as HeaderWrapper, LeftHeader, RightHeader, MetadataWrapper, MetadataSubText, MedatadataTextWrapper, MetadataIconWrapper, MetadataFileName, } from './styled';
import { MediaTypeIcon } from '@atlaskit/media-ui/media-type-icon';
import { createError } from './error';
import { ToolbarDownloadButton, DisabledToolbarDownloadButton, } from './download';
const initialState = {
    item: Outcome.pending(),
};
export class Header extends React.Component {
    constructor() {
        super(...arguments);
        this.state = initialState;
        this.renderDownload = () => {
            const { item } = this.state;
            const { identifier, mediaClient } = this.props;
            return item.match({
                pending: () => DisabledToolbarDownloadButton,
                failed: () => DisabledToolbarDownloadButton,
                successful: item => (React.createElement(ToolbarDownloadButton, { state: item, identifier: identifier, mediaClient: mediaClient })),
            });
        };
        this.renderSidebarButton = () => {
            const { extensions, isSidebarVisible, onSidebarButtonClick } = this.props;
            if (extensions && extensions.sidebar) {
                return (React.createElement(MediaButton, { isSelected: isSidebarVisible, testId: "media-viewer-sidebar-button", appearance: 'toolbar', onClick: onSidebarButtonClick, iconBefore: extensions.sidebar.icon }));
            }
        };
        this.renderSize = (item) => {
            if (item.size) {
                return this.renderSeparator() + toHumanReadableMediaSize(item.size);
            }
            else {
                return '';
            }
        };
        this.renderSeparator = () => {
            return ' Â· ';
        };
        this.renderFileTypeText = (mediaType) => {
            const mediaTypeTranslationMap = {
                doc: messages.document,
                audio: messages.audio,
                video: messages.video,
                image: messages.image,
                unknown: messages.unknown,
            };
            const message = mediaTypeTranslationMap[mediaType || 'unknown'];
            // Defaulting to unknown again since backend has more mediaTypes than the current supported ones
            return React.createElement(FormattedMessage, Object.assign({}, (message || messages.unknown)));
        };
        this.getMediaIcon = (mediaType) => {
            return React.createElement(MediaTypeIcon, { type: mediaType });
        };
    }
    UNSAFE_componentWillUpdate(nextProps) {
        if (this.needsReset(this.props, nextProps)) {
            this.release();
            this.init(nextProps);
        }
    }
    componentDidMount() {
        this.init(this.props);
    }
    componentWillUnmount() {
        this.release();
    }
    init(props) {
        this.setState(initialState, () => {
            const { mediaClient, identifier } = props;
            if (isExternalImageIdentifier(identifier)) {
                const { name = identifier.dataURI } = identifier;
                // Simulate a processing file state to render right metadata
                const fileState = {
                    status: 'processing',
                    id: name,
                    mediaType: 'image',
                    mimeType: 'image/',
                    name,
                    representations: {},
                    size: 0,
                };
                this.setState({
                    item: Outcome.successful(fileState),
                });
                return;
            }
            const { id } = identifier;
            this.subscription = mediaClient.file
                .getFileState(id, {
                collectionName: identifier.collectionName,
            })
                .subscribe({
                next: file => {
                    this.setState({
                        item: Outcome.successful(file),
                    });
                },
                error: err => {
                    this.setState({
                        item: Outcome.failed(createError('metadataFailed', err)),
                    });
                },
            });
        });
    }
    render() {
        return (React.createElement(HeaderWrapper, { className: hideControlsClassName },
            React.createElement(LeftHeader, null, this.renderMetadata()),
            React.createElement(RightHeader, null,
                this.renderSidebarButton(),
                this.renderDownload())));
    }
    renderMetadata() {
        const { item } = this.state;
        return item.match({
            successful: item => this.renderMetadataLayout(item),
            pending: () => null,
            failed: () => null,
        });
    }
    renderMetadataLayout(item) {
        if (item.status === 'processed' || item.status === 'processing') {
            return (React.createElement(MetadataWrapper, null,
                React.createElement(MetadataIconWrapper, null, this.getMediaIcon(item.mediaType)),
                React.createElement(MedatadataTextWrapper, null,
                    React.createElement(MetadataFileName, { "data-testid": "media-viewer-file-name" }, item.name || React.createElement(FormattedMessage, Object.assign({}, messages.unknown))),
                    React.createElement(MetadataSubText, { "data-testid": "media-viewer-file-metadata-text" },
                        this.renderFileTypeText(item.mediaType),
                        this.renderSize(item)))));
        }
        else {
            return null;
        }
    }
    needsReset(propsA, propsB) {
        return (!deepEqual(propsA.identifier, propsB.identifier) ||
            propsA.mediaClient !== propsB.mediaClient);
    }
    release() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
export default injectIntl(Header);
//# sourceMappingURL=header.js.map