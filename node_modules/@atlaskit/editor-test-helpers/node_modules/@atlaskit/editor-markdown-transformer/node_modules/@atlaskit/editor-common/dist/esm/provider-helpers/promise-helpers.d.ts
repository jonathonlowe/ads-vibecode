export declare enum ResultStatus {
    FULFILLED = "fulfilled",
    FAILED = "failed"
}
declare type FulfiledResult<T> = {
    status: ResultStatus.FULFILLED;
    value: T;
};
declare type RejectedResult = {
    status: ResultStatus.FAILED;
    reason: any;
};
/**
 * Will wait for all promises to resolve or reject, wrapping their real results in
 * object containing the status so it's easy to filter it later. Loosely inspired by
 * [Promise.allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)
 * which can replace this implementation once it makes to the browsers.
 * @param promises
 */
export declare const waitForAllPromises: <T>(promises: Promise<T>[]) => Promise<(RejectedResult | FulfiledResult<T>)[]>;
/**
 * Will resolve on the first fulfilled promise and disregard the remaining ones. Similar to `Promise.race` but won't
 * care about rejected promises.
 * @param promises
 */
export declare const waitForFirstFulfilledPromise: <T>(promises: Promise<T>[]) => Promise<T>;
/**
 * Find all fullfilled promises and return their values
 * @param results
 */
export declare const getOnlyFulfilled: <T>(results: (RejectedResult | FulfiledResult<T>)[]) => T[];
export {};
