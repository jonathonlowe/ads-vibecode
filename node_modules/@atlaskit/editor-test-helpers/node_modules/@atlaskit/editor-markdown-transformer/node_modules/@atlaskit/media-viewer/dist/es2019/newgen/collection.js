import React from 'react';
import { isExternalImageIdentifier, } from '@atlaskit/media-client';
import { Outcome } from './domain';
import ErrorMessage, { createError } from './error';
import { List } from './list';
import { toIdentifier } from './utils';
import { Spinner } from './loading';
const initialState = { items: Outcome.pending() };
export class Collection extends React.Component {
    constructor() {
        super(...arguments);
        this.state = initialState;
        this.onNavigationChange = (item) => {
            const { mediaClient, collectionName, pageSize, onNavigationChange, } = this.props;
            if (this.shouldLoadNext(item)) {
                mediaClient.collection.loadNextPage(collectionName, {
                    limit: pageSize,
                });
            }
            if (onNavigationChange) {
                onNavigationChange(item);
            }
        };
    }
    UNSAFE_componentWillUpdate(nextProps) {
        if (this.needsReset(this.props, nextProps)) {
            this.release();
            this.init(nextProps);
        }
    }
    componentWillUnmount() {
        this.release();
    }
    componentDidMount() {
        this.init(this.props);
    }
    render() {
        const { defaultSelectedItem, mediaClient, onClose, collectionName, showControls, extensions, onSidebarButtonClick, } = this.props;
        return this.state.items.match({
            pending: () => React.createElement(Spinner, null),
            successful: items => {
                const identifiers = items.map(x => toIdentifier(x, collectionName));
                const item = defaultSelectedItem
                    ? { ...defaultSelectedItem, collectionName }
                    : identifiers[0];
                return (React.createElement(List, { items: identifiers, defaultSelectedItem: item, mediaClient: mediaClient, onClose: onClose, onNavigationChange: this.onNavigationChange, showControls: showControls, extensions: extensions, onSidebarButtonClick: onSidebarButtonClick }));
            },
            failed: err => React.createElement(ErrorMessage, { error: err }),
        });
    }
    init(props) {
        this.setState(initialState);
        const { collectionName, mediaClient, defaultSelectedItem, pageSize, } = props;
        this.subscription = mediaClient.collection
            .getItems(collectionName, { limit: pageSize })
            .subscribe({
            next: items => {
                this.setState({
                    items: Outcome.successful(items),
                });
                if (defaultSelectedItem && this.shouldLoadNext(defaultSelectedItem)) {
                    mediaClient.collection.loadNextPage(collectionName, {
                        limit: pageSize,
                    });
                }
            },
            error: () => {
                this.setState({
                    items: Outcome.failed(createError('metadataFailed')),
                });
            },
        });
    }
    release() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    needsReset(propsA, propsB) {
        return (propsA.collectionName !== propsB.collectionName ||
            propsA.mediaClient !== propsB.mediaClient);
    }
    shouldLoadNext(selectedItem) {
        if (isExternalImageIdentifier(selectedItem)) {
            return false;
        }
        const { items } = this.state;
        return items.match({
            pending: () => false,
            failed: () => false,
            successful: items => items.length !== 0 && this.isLastItem(selectedItem, items),
        });
    }
    isLastItem(selectedItem, items) {
        const lastItem = items[items.length - 1];
        const isLastItem = selectedItem.id === lastItem.id &&
            selectedItem.occurrenceKey === lastItem.occurrenceKey;
        return isLastItem;
    }
}
//# sourceMappingURL=collection.js.map