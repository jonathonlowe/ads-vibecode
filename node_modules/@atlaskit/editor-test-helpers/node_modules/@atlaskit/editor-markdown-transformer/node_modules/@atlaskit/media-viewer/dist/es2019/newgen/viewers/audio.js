import React from 'react';
import { globalMediaEventEmitter, } from '@atlaskit/media-client';
import AudioIcon from '@atlaskit/icon/glyph/media-services/audio';
import { Outcome } from '../domain';
import { AudioPlayer, AudioCover, Audio, DefaultCoverWrapper, blanketColor, CustomAudioPlayerWrapper, } from '../styled';
import { createError } from '../error';
import { BaseViewer } from './base-viewer';
import { isIE } from '../utils/isIE';
import { CustomMediaPlayer, } from '@atlaskit/media-ui';
import { getObjectUrlFromFileState } from '../utils/getObjectUrlFromFileState';
const defaultCover = (React.createElement(DefaultCoverWrapper, null,
    React.createElement(AudioIcon, { label: "cover", size: "xlarge", primaryColor: blanketColor })));
const getCoverUrl = (item, mediaClient, collectionName) => mediaClient.getImageUrl(item.id, {
    collection: collectionName,
});
export class AudioViewer extends BaseViewer {
    constructor() {
        super(...arguments);
        this.renderCover = () => {
            const { item } = this.props;
            const { coverUrl } = this.state;
            if (coverUrl && item.status !== 'error') {
                return React.createElement(AudioCover, { src: coverUrl, alt: item.name });
            }
            else {
                return defaultCover;
            }
        };
        this.saveAudioElement = (audioElement) => {
            if (!audioElement) {
                return;
            }
            audioElement.setAttribute('controlsList', 'nodownload');
        };
        this.onFirstPlay = () => {
            const { item } = this.props;
            globalMediaEventEmitter.emit('media-viewed', {
                fileId: item.id,
                viewingLevel: 'full',
            });
        };
        this.loadCover = (coverUrl) => {
            return new Promise(async (resolve, reject) => {
                const img = new Image();
                img.src = coverUrl;
                img.onload = resolve;
                img.onerror = reject;
            });
        };
        this.setCoverUrl = async () => {
            const { mediaClient, item, collectionName } = this.props;
            if (item.status !== 'processed') {
                return;
            }
            const coverUrl = await getCoverUrl(item, mediaClient, collectionName);
            try {
                await this.loadCover(coverUrl);
                this.setState({ coverUrl });
            }
            catch (e) { }
        };
    }
    get initialState() {
        return {
            content: Outcome.pending(),
        };
    }
    renderSuccessful(src) {
        const { showControls, previewCount, onCanPlay, onError } = this.props;
        const useCustomAudioPlayer = !isIE();
        const isAutoPlay = previewCount === 0;
        return useCustomAudioPlayer ? (React.createElement(AudioPlayer, { "data-testid": "media-viewer-audio-content" },
            this.renderCover(),
            React.createElement(CustomAudioPlayerWrapper, null,
                React.createElement(CustomMediaPlayer, { type: "audio", isAutoPlay: isAutoPlay, src: src, isShortcutEnabled: true, showControls: showControls, onCanPlay: onCanPlay, onFirstPlay: this.onFirstPlay, onError: onError })))) : (React.createElement(AudioPlayer, null,
            this.renderCover(),
            React.createElement(CustomAudioPlayerWrapper, null,
                React.createElement(Audio, { autoPlay: isAutoPlay, controls: true, innerRef: this.saveAudioElement, src: src, preload: "metadata" }))));
    }
    async init() {
        const { mediaClient, item, collectionName } = this.props;
        try {
            let audioUrl;
            if (item.status === 'processed') {
                audioUrl = await mediaClient.file.getArtifactURL(item.artifacts, 'audio.mp3', collectionName);
                if (!audioUrl) {
                    throw new Error('No audio artifacts found');
                }
            }
            else {
                audioUrl = await getObjectUrlFromFileState(item);
                if (!audioUrl) {
                    this.setState({
                        content: Outcome.pending(),
                    });
                    return;
                }
            }
            this.setCoverUrl();
            this.setState({
                content: Outcome.successful(audioUrl),
            });
        }
        catch (err) {
            this.setState({
                content: Outcome.failed(createError('previewFailed', err, item)),
            });
        }
    }
    release() {
        const { content } = this.state;
        if (!content.data) {
            return;
        }
        URL.revokeObjectURL(content.data);
    }
}
//# sourceMappingURL=audio.js.map