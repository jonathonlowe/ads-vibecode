import { SortOrder } from '../types';
var ContentType;
(function (ContentType) {
    ContentType[ContentType["NUMBER"] = 0] = "NUMBER";
    ContentType[ContentType["TEXT"] = 5] = "TEXT";
    ContentType[ContentType["MENTION"] = 10] = "MENTION";
    ContentType[ContentType["DATE"] = 15] = "DATE";
    ContentType[ContentType["STATUS"] = 20] = "STATUS";
    ContentType[ContentType["LINK"] = 25] = "LINK";
})(ContentType || (ContentType = {}));
function getLinkMark(node) {
    const [linkMark] = node.marks.filter(mark => mark.type.name === 'link');
    return linkMark || null;
}
function getMetaFromNode(node, options) {
    if (!node) {
        return null;
    }
    const firstChild = node.firstChild;
    if (!firstChild) {
        return null;
    }
    switch (firstChild.type.name) {
        // Text case
        /*
          Get Meta value from the first child if the cell is of type
            * Heading (Any cell where the text is set to a heading type)
            * Paragraph (Normal text)
         */
        case 'heading':
        case 'paragraph': {
            return getMetaFromNode(firstChild, options);
        }
        case 'inlineCard': {
            const attrs = firstChild.attrs;
            const maybeTitle = options.getInlineCardTextFromStore(attrs);
            if (maybeTitle) {
                return {
                    type: ContentType.LINK,
                    value: maybeTitle,
                };
            }
            const url = attrs.url;
            return {
                type: ContentType.LINK,
                value: url ? url : '',
            };
        }
        case 'text': {
            // treat as a link if contain a link
            const linkMark = getLinkMark(firstChild);
            if (linkMark) {
                const value = firstChild.text || '';
                return {
                    type: ContentType.LINK,
                    value,
                };
            }
            const text = firstChild.text || '';
            const firstEmptySpace = text.indexOf(' ');
            const firstWord = firstEmptySpace !== -1 ? text.substring(0, firstEmptySpace) : text;
            const maybeANumber = Number.parseFloat(firstWord);
            if (!Number.isNaN(maybeANumber)) {
                return {
                    type: ContentType.NUMBER,
                    value: maybeANumber,
                };
            }
            return {
                type: ContentType.TEXT,
                value: firstWord,
            };
        }
        case 'status': {
            const text = firstChild.attrs.text;
            return {
                type: ContentType.STATUS,
                value: text,
            };
        }
        case 'date': {
            const timestamp = Number.parseInt(firstChild.attrs.timestamp, 20);
            return {
                type: ContentType.DATE,
                value: timestamp,
            };
        }
        case 'mention': {
            // TODO: Check what should be the fallback when mention does not have a text
            const text = firstChild.attrs.text || '';
            return {
                type: ContentType.MENTION,
                value: text.toLowerCase(),
            };
        }
        default:
            return null;
    }
}
function compareValue(valueA, valueB) {
    if (valueA === valueB) {
        return 0;
    }
    return valueA > valueB ? 1 : -1;
}
/**
 * Compare 2 prosemirror nodes and check if it's greater, equal or less than the other node
 * based on the sort order.
 *
 * @param {Node} nodeA
 * @param {Node} nodeB
 * @returns {(1 | 0 | -1)}
 *
 * For Ascending order:
 *    1  -> NodeA > NodeB
 *    0  -> NodeA === NodeB
 *    -1 -> Node A < NodeB
 * For Descending order:
 *   1  -> NodeA < NodeB
 *   0  -> NodeA === NodeB
 *   -1 -> Node A > NodeB
 *
 * If either node is empty:
 * The empty node is always treated as lower priority,
 * irrespective of the order.
 *
 * If no order is provided the method defaults to Ascending order,
 * like a regular JS sort method.
 */
export const createCompareNodes = (options, order = SortOrder.ASC) => {
    return (nodeA, nodeB) => {
        const metaNodeA = getMetaFromNode(nodeA, options);
        const metaNodeB = getMetaFromNode(nodeB, options);
        /*
          Donot switch the order (Asec or Desc) if either node is null.
          This will ensure that empty cells are always at the bottom during sorting.
        */
        if (metaNodeA === null || metaNodeB === null) {
            return compareMetaFromNode(metaNodeA, metaNodeB);
        }
        return ((order === SortOrder.DESC ? -1 : 1) *
            compareMetaFromNode(metaNodeA, metaNodeB));
    };
};
function compareMetaFromNode(metaNodeA, metaNodeB) {
    if (metaNodeA === metaNodeB) {
        return 0;
    }
    if (metaNodeA === null || metaNodeB === null) {
        return metaNodeB === null ? -1 : 1;
    }
    if (metaNodeA.type !== metaNodeB.type) {
        return metaNodeA.type > metaNodeB.type ? 1 : -1;
    }
    return compareValue(metaNodeA.value, metaNodeB.value);
}
//# sourceMappingURL=compareNodes.js.map