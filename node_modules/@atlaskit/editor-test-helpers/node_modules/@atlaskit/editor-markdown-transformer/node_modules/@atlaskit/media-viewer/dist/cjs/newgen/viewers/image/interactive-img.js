"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var media_ui_1 = require("@atlaskit/media-ui");
var constants_1 = require("@atlaskit/media-client/constants");
var analytics_next_1 = require("@atlaskit/analytics-next");
var vid_hd_circle_1 = tslib_1.__importDefault(require("@atlaskit/icon/glyph/vid-hd-circle"));
var spinner_1 = tslib_1.__importDefault(require("@atlaskit/spinner"));
var colors_1 = require("@atlaskit/theme/colors");
var styled_1 = require("../../styled");
var zoomLevel_1 = require("../../domain/zoomLevel");
var closeOnDirectClick_1 = require("../../utils/closeOnDirectClick");
var zoomControls_1 = require("../../zoomControls");
var closed_1 = require("../../analytics/closed");
var analytics_1 = require("../../analytics");
function zoomLevelAfterResize(newCamera, oldCamera, oldZoomLevel) {
    var isImgScaledToFit = oldZoomLevel.value === oldCamera.scaleDownToFit;
    var zoomLevelToRefit = new zoomLevel_1.ZoomLevel(newCamera.scaleDownToFit);
    return isImgScaledToFit ? zoomLevelToRefit : oldZoomLevel;
}
exports.zoomLevelAfterResize = zoomLevelAfterResize;
var clientRectangle = function (el) {
    var clientWidth = el.clientWidth, clientHeight = el.clientHeight;
    return new media_ui_1.Rectangle(clientWidth, clientHeight);
};
var naturalSizeRectangle = function (el) {
    var naturalWidth = el.naturalWidth, naturalHeight = el.naturalHeight;
    return new media_ui_1.Rectangle(naturalWidth, naturalHeight);
};
var initialState = {
    zoomLevel: new zoomLevel_1.ZoomLevel(1),
    isHDActive: false,
    isHDActivating: false,
    isHDAvailable: false,
    isDragging: false,
    cursorPos: new media_ui_1.Vector2(0, 0),
    hasBeenLoadedOnce: false,
};
var InteractiveImgComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InteractiveImgComponent, _super);
    function InteractiveImgComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = initialState;
        _this.saveWrapperRef = function (ref) { return (_this.wrapper = ref); };
        _this.onImageClicked = function (e) {
            var _a = _this.props, onClose = _a.onClose, onBlanketClicked = _a.onBlanketClicked;
            if (e.target === e.currentTarget && onBlanketClicked) {
                onBlanketClicked();
            }
            closeOnDirectClick_1.closeOnDirectClick(onClose)(e);
        };
        _this.onImgLoad = function (ev) {
            var _a = _this.props, onLoad = _a.onLoad, originalBinaryImageSrc = _a.originalBinaryImageSrc;
            var _b = _this.state, hasBeenLoadedOnce = _b.hasBeenLoadedOnce, oldZoomLevel = _b.zoomLevel, currentCamera = _b.camera;
            var _c = _this.state, isHDActivating = _c.isHDActivating, isHDAvailable = _c.isHDAvailable, isHDActive = _c.isHDActive;
            if (!_this.wrapper) {
                return;
            }
            var viewport = clientRectangle(_this.wrapper);
            var originalImgRect = naturalSizeRectangle(ev.currentTarget);
            var camera = new media_ui_1.Camera(viewport, originalImgRect);
            var newZoomLevel;
            if (hasBeenLoadedOnce && currentCamera) {
                /* This is not first time image is loading. Likely due to new (HD) image is loaded.
                 * In order to keep new image on the same perceived zoom level we need to scale.
                 * It depends on ration between old and new images and current zoom level.
                 * For example:
                 * - old image is 2000px with zoom at 50% (0.5). New image is 4000px. 2000/4000 * 0.5 = 0.25 (25%)
                 * - old image is 2000px with zoom at 200% (2). New image is 4000px. 2000/4000 * 2 = 1 (100%)
                 */
                var previousImageWidth = currentCamera.originalImg.width;
                var newImageWidth = originalImgRect.width;
                newZoomLevel = new zoomLevel_1.ZoomLevel((previousImageWidth / newImageWidth) * oldZoomLevel.value);
                isHDActivating = false;
            }
            else {
                newZoomLevel = new zoomLevel_1.ZoomLevel(camera.scaleDownToFit);
                // If initial (non-HD) image is equal to MAX resolution -
                // this means most likely original image had higher res (because non-HD is downsized and caped off with MAX res)
                isHDAvailable =
                    !!originalBinaryImageSrc &&
                        (originalImgRect.width === constants_1.MAX_RESOLUTION ||
                            originalImgRect.height === constants_1.MAX_RESOLUTION);
                // Automatically activate HD on first load if zoom level is already 100% or bigger
                isHDActive = newZoomLevel.value >= 1;
                if (onLoad) {
                    // Call onLoad only once on initial image render
                    onLoad();
                }
            }
            _this.setState({
                camera: camera,
                zoomLevel: newZoomLevel,
                hasBeenLoadedOnce: true,
                isHDActivating: isHDActivating,
                isHDAvailable: isHDAvailable,
                isHDActive: isHDActive,
            });
        };
        _this.onResize = function () {
            var camera = _this.state.camera;
            if (!_this.wrapper || !camera) {
                return;
            }
            var oldZoomLevel = _this.state.zoomLevel;
            var newViewport = clientRectangle(_this.wrapper);
            var newCamera = camera.resizedViewport(newViewport);
            var newZoomLevel = zoomLevelAfterResize(newCamera, camera, oldZoomLevel);
            _this.setState({
                camera: newCamera,
                zoomLevel: newZoomLevel,
            });
        };
        _this.onZoomChange = function (nextZoomLevel) {
            var camera = _this.state.camera;
            var wrapper = _this.wrapper;
            if (!wrapper || !camera) {
                return;
            }
            var scrollLeft = wrapper.scrollLeft, scrollTop = wrapper.scrollTop;
            var prevOffset = new media_ui_1.Vector2(scrollLeft, scrollTop);
            var _a = _this.state, prevZoomLevel = _a.zoomLevel, prevIsHDActive = _a.isHDActive, prevIsHDActivating = _a.isHDActivating;
            var isHDActive = prevIsHDActive || nextZoomLevel.value >= 1;
            var isHDActivating = prevIsHDActivating || (!prevIsHDActive && isHDActive);
            _this.setState({
                zoomLevel: nextZoomLevel,
                isHDActive: isHDActive,
                isHDActivating: isHDActivating,
            }, function () {
                var _a = camera.scaledOffset(prevOffset, prevZoomLevel.value, nextZoomLevel.value), x = _a.x, y = _a.y;
                wrapper.scrollLeft = x;
                wrapper.scrollTop = y;
            });
        };
        _this.startDragging = function (ev) {
            ev.preventDefault();
            _this.setState({
                isDragging: true,
                cursorPos: new media_ui_1.Vector2(ev.screenX, ev.screenY),
            });
        };
        _this.stopDragging = function (ev) {
            ev.preventDefault();
            _this.setState({ isDragging: false });
        };
        _this.panImage = function (ev) {
            if (_this.state.isDragging && _this.wrapper) {
                var cursorPos = new media_ui_1.Vector2(ev.screenX, ev.screenY);
                var delta = _this.state.cursorPos.sub(cursorPos);
                _this.setState({ cursorPos: cursorPos });
                _this.wrapper.scrollLeft += delta.x;
                _this.wrapper.scrollTop += delta.y;
            }
        };
        return _this;
    }
    InteractiveImgComponent.prototype.componentDidMount = function () {
        this.state = initialState;
        window.addEventListener('resize', this.onResize);
        document.addEventListener('mousemove', this.panImage);
        document.addEventListener('mouseup', this.stopDragging);
    };
    InteractiveImgComponent.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.onResize);
        document.removeEventListener('mousemove', this.panImage);
        document.removeEventListener('mouseup', this.stopDragging);
    };
    InteractiveImgComponent.prototype.renderHDIndicator = function () {
        var _a = this.state, isHDActivating = _a.isHDActivating, isHDAvailable = _a.isHDAvailable, isHDActive = _a.isHDActive;
        if (!isHDAvailable) {
            return null;
        }
        var hdPrimaryColor = isHDActivating ? colors_1.B75 : isHDActive ? colors_1.B200 : colors_1.DN400;
        var hdSecondaryColor = isHDActive && !isHDActivating ? colors_1.N0 : colors_1.DN60;
        var testId = isHDActivating
            ? 'hd-activating'
            : isHDActive
                ? 'hd-active'
                : 'hd-inactive';
        return (react_1.default.createElement(styled_1.HDIconGroupWrapper, { className: media_ui_1.hideControlsClassName },
            isHDActivating ? react_1.default.createElement(spinner_1.default, { appearance: "invert" }) : undefined,
            react_1.default.createElement(styled_1.HDIconWrapper, null,
                react_1.default.createElement(vid_hd_circle_1.default, { primaryColor: hdPrimaryColor, secondaryColor: hdSecondaryColor, label: "hd", testId: testId }))));
    };
    InteractiveImgComponent.prototype.render = function () {
        var _a = this.props, src = _a.src, originalBinaryImageSrc = _a.originalBinaryImageSrc, orientation = _a.orientation, onError = _a.onError;
        var _b = this.state, zoomLevel = _b.zoomLevel, isHDAvailable = _b.isHDAvailable, isHDActive = _b.isHDActive, camera = _b.camera, isDragging = _b.isDragging;
        var canDrag = (camera && zoomLevel.value > camera.scaleToFit) || false;
        // We use style attr instead of SC prop for perf reasons
        var imgStyle = (camera && camera.scaledImg(zoomLevel.value)) || {};
        if (orientation) {
            imgStyle.transform = media_ui_1.getCssFromImageOrientation(orientation);
        }
        var srcToDisplay = isHDAvailable && isHDActive && originalBinaryImageSrc
            ? originalBinaryImageSrc
            : src;
        return (react_1.default.createElement(styled_1.ImageWrapper, { "data-testid": "media-viewer-image-content", onClick: this.onImageClicked, innerRef: this.saveWrapperRef },
            react_1.default.createElement(styled_1.Img, { "data-testid": "media-viewer-image", canDrag: canDrag, isDragging: isDragging, src: srcToDisplay, style: imgStyle, onLoad: this.onImgLoad, onError: onError, onMouseDown: this.startDragging, shouldPixelate: zoomLevel.value > 1 }),
            react_1.default.createElement(styled_1.BaselineExtend, null),
            react_1.default.createElement(zoomControls_1.ZoomControls, { zoomLevel: zoomLevel, onChange: this.onZoomChange }),
            this.renderHDIndicator()));
    };
    return InteractiveImgComponent;
}(react_1.default.Component));
exports.InteractiveImgComponent = InteractiveImgComponent;
exports.InteractiveImg = analytics_next_1.withAnalyticsEvents({
    onBlanketClicked: function (createAnalyticsEvent) {
        var event = createAnalyticsEvent(closed_1.closedEvent('blanket'));
        event.fire(analytics_1.channel);
    },
})(InteractiveImgComponent);
//# sourceMappingURL=interactive-img.js.map