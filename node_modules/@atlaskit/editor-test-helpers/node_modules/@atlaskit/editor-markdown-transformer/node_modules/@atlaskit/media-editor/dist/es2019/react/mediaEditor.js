import React from 'react';
import Spinner from '@atlaskit/spinner';
import { MediaEditorContainer, OutputArea, DrawingCanvas, HiddenTextArea, HiddenTextHelperDiv, SupplementaryCanvas, SpinnerWrapper, } from './styled';
import { Engine } from '../engine/engine';
import { colorWithAlphaSame, dimensionsSame } from '../util';
import { DefaultDrawingArea, } from '../engine/components/drawingArea';
import { DefaultImageProvider, urlImageLoader, } from '../engine/components/imageProvider';
import { DefaultMouseInput } from '../engine/components/mouseInput';
import { DefaultToolbar } from '../engine/components/toolbar';
import { DefaultKeyboardInput } from '../engine/components/keyboardInput';
import { DefaultImageReceiver } from '../engine/components/imageReceiver';
import { DefaultShapeDeleter } from '../engine/components/shapeDeleter';
import { DefaultUndoerRedoer } from '../engine/components/undoerRedoer';
const defaultTextDirection = 'ltr';
export class MediaEditor extends React.Component {
    constructor(props) {
        super(props);
        this.handleOutputAreaInnerRef = (outputArea) => {
            this.outputArea = outputArea;
        };
        this.handleSupplementaryCanvasInnerRef = (canvas) => {
            this.supplementaryCanvas = canvas;
        };
        this.handleHiddenTextAreaInnerRef = (textArea) => {
            this.hiddenTextArea = textArea;
        };
        this.handleHiddenTextHelperDivInnerRef = (div) => {
            this.hiddenTextHelperDiv = div;
        };
        this.handleDrawingCanvasInnerRef = (canvas) => {
            this.canvas = canvas;
        };
        this.renderSpinner = () => (React.createElement(SpinnerWrapper, null,
            React.createElement(Spinner, { size: "large", appearance: "invert" })));
        this.onCanvasClick = () => {
            const { onAnyEdit, shapeParameters, tool } = this.props;
            if (onAnyEdit) {
                onAnyEdit(tool, shapeParameters);
            }
        };
        this.isUnmounted = false;
        this.state = {
            isImageLoaded: false,
        };
    }
    componentDidMount() {
        this.loadEngine();
    }
    componentDidUpdate(prevProps) {
        if (!this.engine) {
            return;
        }
        const currProps = this.props;
        if (currProps.imageUrl !== prevProps.imageUrl) {
            this.unloadEngine();
            this.loadEngine();
        }
        if (this.drawingArea &&
            (!dimensionsSame(currProps.dimensions, prevProps.dimensions) ||
                currProps.screenScaleFactor !== prevProps.screenScaleFactor)) {
            this.drawingArea.setSize(MediaEditor.toOutputSize(currProps));
        }
        if (!colorWithAlphaSame(currProps.backgroundColor, prevProps.backgroundColor)) {
            // TODO inform the core about the new background color
            // https://jira.atlassian.com/browse/FIL-3996
        }
        const { color: currColor, lineWidth: currLineWidth, addShadow: currAddShadow, } = currProps.shapeParameters;
        const { color: prevColor, lineWidth: prevLineWidth, addShadow: prevAddShadow, } = prevProps.shapeParameters;
        if (this.toolbar) {
            if (currColor !== prevColor) {
                this.toolbar.setColor(currColor);
            }
            if (currLineWidth !== prevLineWidth) {
                this.toolbar.setLineWidth(currLineWidth);
            }
            if (currAddShadow !== prevAddShadow) {
                this.toolbar.setAddShadow(currAddShadow);
            }
            if (currProps.tool !== prevProps.tool) {
                this.toolbar.setTool(currProps.tool);
            }
        }
    }
    componentWillUnmount() {
        this.isUnmounted = true;
        this.unloadEngine();
    }
    render() {
        const { isImageLoaded } = this.state;
        const { dimensions } = this.props;
        return (React.createElement(MediaEditorContainer, { style: dimensions },
            !isImageLoaded ? this.renderSpinner() : null,
            React.createElement(OutputArea, { innerRef: this.handleOutputAreaInnerRef, style: dimensions },
                React.createElement(SupplementaryCanvas, { innerRef: this.handleSupplementaryCanvasInnerRef }),
                React.createElement(HiddenTextArea, { autoComplete: 'off', innerRef: this.handleHiddenTextAreaInnerRef }),
                React.createElement(HiddenTextHelperDiv, { innerRef: this.handleHiddenTextHelperDivInnerRef }),
                React.createElement(DrawingCanvas, { onClick: this.onCanvasClick, innerRef: this.handleDrawingCanvasInnerRef, style: dimensions }))));
    }
    loadEngine() {
        const { imageUrl } = this.props;
        DefaultImageProvider.create(() => urlImageLoader(imageUrl), this.supplementaryCanvas)
            .then(imageProvider => {
            // We must not create the engine if the component was unmounted or if the image was changed
            if (this.isUnmounted || imageUrl !== this.props.imageUrl) {
                return;
            }
            this.setState({ isImageLoaded: true });
            // Creating components for the engine
            const outputSize = MediaEditor.toOutputSize(this.props);
            const { backgroundColor } = this.props;
            this.drawingArea = new DefaultDrawingArea(this.canvas, outputSize, backgroundColor);
            const mouseInput = new DefaultMouseInput(this.outputArea);
            this.toolbar = new DefaultToolbar(params => this.props.onShapeParametersChanged(params));
            const keyboardInput = new DefaultKeyboardInput(this.hiddenTextArea, this.supplementaryCanvas, this.hiddenTextHelperDiv);
            const imageReceiver = new DefaultImageReceiver(this.supplementaryCanvas);
            const shapeDeleter = new DefaultShapeDeleter(this.hiddenTextArea);
            const undoerRedoer = new DefaultUndoerRedoer();
            // Creating the engine
            const { shapeParameters, tool: initialTool } = this.props;
            const textDirection = window.getComputedStyle(this.outputArea)
                .direction || defaultTextDirection;
            const config = {
                // eslint-disable-next-line no-console
                onCoreError: (message) => {
                    // eslint-disable-next-line
                    console.error(message);
                },
                shapeParameters,
                initialTool,
                textDirection,
                drawingArea: this.drawingArea,
                imageProvider,
                mouseInput,
                toolbar: this.toolbar,
                keyboardInput,
                imageReceiver,
                shapeDeleter,
                undoerRedoer,
            };
            this.engine = new Engine(config);
            const loadParameters = {
                imageGetter: (format) => this.engine.getBase64Image(format),
            };
            this.props.onLoad(imageUrl, loadParameters);
        })
            .catch(error => this.props.onError(imageUrl, error));
    }
    unloadEngine() {
        if (this.engine) {
            this.engine.unload();
            delete this.engine;
            this.setState({ isImageLoaded: false });
        }
    }
    static toOutputSize(props) {
        const { dimensions } = props;
        const screenScaleFactor = props.screenScaleFactor || MediaEditor.screenScaleFactor;
        return {
            width: dimensions.width * screenScaleFactor,
            height: dimensions.height * screenScaleFactor,
            screenScaleFactor,
        };
    }
    static get screenScaleFactor() {
        return window.devicePixelRatio || 1;
    }
}
export default MediaEditor;
//# sourceMappingURL=mediaEditor.js.map