import React from 'react';
import { PureComponent } from 'react';
import TaskItem from './TaskItem';
import { FabricElementsAnalyticsContext } from '@atlaskit/analytics-namespaced-context';
export default class ResourcedTaskItem extends PureComponent {
    constructor(props) {
        super(props);
        this.mounted = false;
        this.onUpdate = (state) => {
            this.setState({ isDone: state === 'DONE' });
        };
        this.handleOnChange = (taskId, isDone) => {
            const { taskDecisionProvider, objectAri, onChange } = this.props;
            // Optimistically update the task
            this.setState({ isDone });
            if (taskDecisionProvider && objectAri) {
                // Call provider to update task
                taskDecisionProvider.then(provider => {
                    if (!this.mounted) {
                        return;
                    }
                    provider.toggleTask({ localId: taskId, objectAri }, isDone ? 'DONE' : 'TODO');
                    // onChange could trigger a rerender, in order to get the correct state
                    // we should only call onChange once the internal state have been modified
                    if (onChange) {
                        onChange(taskId, isDone);
                    }
                });
            }
            else {
                // No provider - state managed by consumer
                if (onChange) {
                    onChange(taskId, isDone);
                }
            }
        };
        this.state = {
            isDone: props.isDone,
        };
    }
    componentDidMount() {
        this.mounted = true;
        this.subscribe(this.props.taskDecisionProvider, this.props.objectAri, this.props.isDone);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.isDone !== this.props.isDone) {
            // This only occurs for Actions (DONE vs TODO), since Decisions only support DECIDED.
            // If the document is refreshed or changed, we need to reset the local state to match the new
            // source of truth from the revised data.
            this.onUpdate(nextProps.isDone ? 'DONE' : 'TODO');
        }
        if (nextProps.taskDecisionProvider !== this.props.taskDecisionProvider ||
            nextProps.objectAri !== this.props.objectAri) {
            this.unsubscribe();
            this.subscribe(nextProps.taskDecisionProvider, nextProps.objectAri, nextProps.isDone);
        }
    }
    componentWillUnmount() {
        this.unsubscribe();
        this.mounted = false;
    }
    subscribe(taskDecisionProvider, objectAri, isDone) {
        if (taskDecisionProvider && objectAri) {
            taskDecisionProvider.then(provider => {
                if (!this.mounted) {
                    return;
                }
                const { taskId } = this.props;
                const objectKey = { localId: taskId, objectAri };
                const item = {
                    ...objectKey,
                    state: isDone ? 'DONE' : 'TODO',
                    lastUpdateDate: new Date(),
                    type: 'TASK',
                };
                provider.subscribe({ localId: taskId, objectAri }, this.onUpdate, item);
            });
        }
    }
    unsubscribe() {
        const { taskDecisionProvider, taskId, objectAri } = this.props;
        if (taskDecisionProvider && objectAri) {
            taskDecisionProvider.then(provider => {
                provider.unsubscribe({ localId: taskId, objectAri }, this.onUpdate);
            });
        }
    }
    render() {
        const { isDone } = this.state;
        const { appearance, children, contentRef, objectAri, showPlaceholder, placeholder, taskId, disabled, dataAttributes, } = this.props;
        return (React.createElement(FabricElementsAnalyticsContext, { data: {
                objectAri,
            } },
            React.createElement(TaskItem, { isDone: isDone, taskId: taskId, onChange: this.handleOnChange, appearance: appearance, contentRef: contentRef, showPlaceholder: showPlaceholder, placeholder: placeholder, disabled: disabled, dataAttributes: dataAttributes }, children)));
    }
}
ResourcedTaskItem.defaultProps = {
    appearance: 'inline',
};
//# sourceMappingURL=ResourcedTaskItem.js.map