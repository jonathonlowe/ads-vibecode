import { FontInfo } from './fontInfo';
import { renderText } from './textRenderer';
import { getCursorPositions } from './cursorPositions';
// Holds fragments and cursor positions for one paragraph.
// Each fragment has two textures and the position. The paragraph is responsible for releasing the fragment textures.
// The position of the fragment is in the coordinates where the paragraph starts at (0, 0).
// Currently a paragraph can contain only one line, thus we store only x positions of the cursors.
export class Paragraph {
    // if a text contains N UTF-32 code units, we should have N + 1 cursor positions
    constructor(config) {
        this.config = config;
        this.text = '';
        this.direction = 'ltr';
        this.fontSize = 0;
        this.isValid = false; // indicates whether fragments or cursor positions were created for the last update
        this.fragments = []; // text fragments
        this.cursorPositions = []; // x coordinates of the cursor positions
    }
    unload(isContextLost) {
        this.destroy(isContextLost);
    }
    get textFragments() {
        return this.fragments;
    }
    get textCursorPositions() {
        return this.cursorPositions;
    }
    update(text, direction, fontSize) {
        if (text === this.text &&
            direction === this.direction &&
            fontSize === this.fontSize &&
            this.isValid) {
            // The paragraph is up to date.
            // No need to recreate fragments or calculate cursor positions.
            return true;
        }
        this.text = text;
        this.direction = direction;
        this.fontSize = fontSize;
        this.destroy(false); // 'false' because we receive update() only when the context is valid
        this.cursorPositions = [];
        this.isValid = this.createFragments() && this.calculateCursorPositions();
        return this.isValid;
    }
    destroy(isContextLost) {
        this.fragments.forEach(fragment => fragment.unload(isContextLost));
    }
    createFragments() {
        this.fragments = [];
        const { text, direction, fontSize } = this;
        return renderText(this.fragments, {
            text,
            direction,
            fontSize,
            // TODO: Media migration to new repo - textHelperDiv is not expected
            ...this.config,
        });
    }
    calculateCursorPositions() {
        const { text, direction, fontSize } = this;
        const { textHelperDiv } = this.config;
        // We create a helper div, set its font and direction to the required and call getCursorPositions()
        const rootDiv = document.createElement('div');
        textHelperDiv.appendChild(rootDiv);
        rootDiv.style.font = FontInfo.getFontStyle(fontSize);
        rootDiv.style.direction = direction;
        this.cursorPositions = getCursorPositions(text, direction, rootDiv);
        textHelperDiv.removeChild(rootDiv);
        return true;
    }
}
//# sourceMappingURL=paragraph.js.map