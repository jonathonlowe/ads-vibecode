import React from 'react';
import rafSchedule from 'raf-schd';
import { createPortal } from 'react-dom';
import { akEditorFloatingPanelZIndex } from '../../styles/consts';
import { calculatePlacement, calculatePosition, findOverflowScrollParent, validatePosition, } from './utils';
export default class Popup extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            overflowScrollParent: false,
            validPosition: true,
        };
        this.placement = ['', ''];
        this.handleRef = (popup) => {
            if (!popup) {
                return;
            }
            this.initPopup(popup);
        };
        this.scheduledUpdatePosition = rafSchedule((props) => this.updatePosition(props));
        this.onResize = () => this.scheduledUpdatePosition();
    }
    /**
     * Calculates new popup position
     */
    updatePosition(props = this.props, state = this.state) {
        const { target, fitHeight, fitWidth, boundariesElement, offset, onPositionCalculated, onPlacementChanged, alignX, alignY, stick, forcePlacement, allowOutOfBounds, rect, } = props;
        const { popup } = state;
        if (!target || !popup) {
            return;
        }
        const placement = calculatePlacement(target, boundariesElement || document.body, fitWidth, fitHeight, alignX, alignY, forcePlacement);
        if (onPlacementChanged && this.placement.join('') !== placement.join('')) {
            onPlacementChanged(placement);
            this.placement = placement;
        }
        let position = calculatePosition({
            placement,
            popup,
            target,
            stick,
            offset: offset,
            allowOutOfBounds,
            rect,
        });
        position = onPositionCalculated ? onPositionCalculated(position) : position;
        this.setState({
            position,
            validPosition: validatePosition(target),
        });
    }
    cannotSetPopup(popup, target, overflowScrollParent) {
        /**
         * Check whether:
         * 1. Popup's offset targets which means whether or not its possible to correctly position popup along with given target.
         * 2. Popup is inside "overflow: scroll" container, but its offset parent isn't.
         *
         * Currently Popup isn't capable of position itself correctly in case 2,
         * Add "position: relative" to "overflow: scroll" container or to some other FloatingPanel wrapper inside it.
         */
        return (!target ||
            (document.body.contains(target) &&
                popup.offsetParent &&
                !popup.offsetParent.contains(target)) ||
            (overflowScrollParent &&
                !overflowScrollParent.contains(popup.offsetParent)));
    }
    /**
     * Popup initialization.
     * Checks whether it's possible to position popup along given target, and if it's not throws an error.
     */
    initPopup(popup) {
        const { target } = this.props;
        const overflowScrollParent = findOverflowScrollParent(popup);
        if (this.cannotSetPopup(popup, target, overflowScrollParent)) {
            return;
        }
        this.setState({ popup, overflowScrollParent }, this.scheduledUpdatePosition);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        // We are delaying `updatePosition` otherwise it happens before the children
        // get rendered and we end up with a wrong position
        this.scheduledUpdatePosition(newProps);
    }
    componentDidMount() {
        window.addEventListener('resize', this.onResize);
        const { stick } = this.props;
        if (stick) {
            this.scrollElement = findOverflowScrollParent(this.props.target);
        }
        else {
            this.scrollElement = this.props.scrollableElement;
        }
        if (this.scrollElement) {
            this.scrollElement.addEventListener('scroll', this.onResize);
        }
    }
    componentWillUnmount() {
        window.removeEventListener('resize', this.onResize);
        if (this.scrollElement) {
            this.scrollElement.removeEventListener('scroll', this.onResize);
        }
        this.scheduledUpdatePosition.cancel();
    }
    renderPopup() {
        const { position } = this.state;
        const { shouldRenderPopup } = this.props;
        if (shouldRenderPopup && !shouldRenderPopup(position || {})) {
            return null;
        }
        return (React.createElement("div", { ref: this.handleRef, style: {
                position: 'absolute',
                zIndex: this.props.zIndex || akEditorFloatingPanelZIndex,
                ...position,
            }, "aria-label": this.props.ariaLabel || 'Popup', "data-editor-popup": true }, this.props.children));
    }
    render() {
        const { target, mountTo } = this.props;
        const { validPosition } = this.state;
        if (!target || !validPosition) {
            return null;
        }
        if (mountTo) {
            return createPortal(this.renderPopup(), mountTo);
        }
        // Without mountTo property renders popup as is,
        // which means it will be cropped by "overflow: hidden" container.
        return this.renderPopup();
    }
}
Popup.defaultProps = {
    offset: [0, 0],
    allowOutOfBound: false,
};
export { findOverflowScrollParent } from './utils';
//# sourceMappingURL=index.js.map