import { Decoration, DecorationSet } from 'prosemirror-view';
import { getSelectionRect, findTable } from 'prosemirror-utils';
import { TableMap } from 'prosemirror-tables';
import { tableResizeHandleWidth } from '@atlaskit/editor-common';
import { TableCssClassName as ClassName, TableDecorations, } from '../types';
import { getPluginState } from '../pm-plugins/main';
var filterDecorationByKey = function (key, decorationSet) {
    return decorationSet.find(undefined, undefined, function (spec) { return spec.key.indexOf(key) > -1; });
};
var createResizeHandleNode = function (colIndex, colSpanIndex) {
    var node = document.createElement('div');
    node.classList.add(ClassName.RESIZE_HANDLE);
    node.setAttribute('data-col-index', "" + colIndex);
    // index within a merged column
    node.setAttribute('data-colspan-index', "" + colSpanIndex);
    return node;
};
export var findColumnControlSelectedDecoration = function (decorationSet) {
    return filterDecorationByKey(TableDecorations.COLUMN_SELECTED, decorationSet);
};
export var findControlsHoverDecoration = function (decorationSet) {
    return filterDecorationByKey(TableDecorations.ALL_CONTROLS_HOVER, decorationSet);
};
export var createCellHoverDecoration = function (cells, type) {
    return cells.map(function (cell) {
        return Decoration.node(cell.pos, cell.pos + cell.node.nodeSize, {
            class: ClassName.HOVERED_CELL_WARNING,
        }, {
            key: TableDecorations.CELL_CONTROLS_HOVER,
        });
    });
};
export var createControlsHoverDecoration = function (cells, type, danger) {
    return cells.map(function (cell) {
        var classes = [ClassName.HOVERED_CELL];
        if (danger) {
            classes.push(ClassName.HOVERED_CELL_IN_DANGER);
        }
        classes.push(type === 'column'
            ? ClassName.HOVERED_COLUMN
            : type === 'row'
                ? ClassName.HOVERED_ROW
                : ClassName.HOVERED_TABLE);
        var key;
        switch (type) {
            case 'row':
                key = TableDecorations.ROW_CONTROLS_HOVER;
                break;
            case 'column':
                key = TableDecorations.COLUMN_CONTROLS_HOVER;
                break;
            default:
                key = TableDecorations.TABLE_CONTROLS_HOVER;
                break;
        }
        return Decoration.node(cell.pos, cell.pos + cell.node.nodeSize, {
            class: classes.join(' '),
        }, { key: key });
    });
};
export var createColumnSelectedDecorations = function (tr) {
    var selection = tr.selection, doc = tr.doc;
    var table = findTable(selection);
    var rect = getSelectionRect(selection);
    if (!table || !rect) {
        return [];
    }
    var map = TableMap.get(table.node);
    var cellPositions = map.cellsInRect(rect);
    return cellPositions.map(function (pos, index) {
        var cell = doc.nodeAt(pos + table.start);
        return Decoration.node(pos + table.start, pos + table.start + cell.nodeSize, {
            class: ClassName.COLUMN_SELECTED,
        }, {
            key: TableDecorations.COLUMN_SELECTED + "_" + index,
        });
    });
};
export var createColumnControlsDecoration = function (doc, selection, allowColumnResizing) {
    var prevTable = findTable(selection);
    // taking the table node from the document updated by the transaction changes
    var table = doc.nodeAt(prevTable.pos);
    var cells = [];
    table.content.firstChild.descendants(function (child, pos) {
        cells.push({ node: child, pos: pos + prevTable.pos + 2 });
        return false;
    });
    var index = 0;
    var cellsCount = cells.length;
    return cells.map(function (cell, colIndex) {
        var attrs = cell.node.attrs;
        var colspan = attrs.colspan || 1;
        var element = document.createElement('div');
        element.classList.add(ClassName.COLUMN_CONTROLS_DECORATIONS);
        var startIndex = index;
        element.dataset.startIndex = "" + index;
        index += colspan;
        element.dataset.endIndex = "" + index;
        if (allowColumnResizing) {
            var start_1 = 0;
            // looping through colspans and creating resize handle node for each
            Array.from(Array(colspan).keys()).forEach(function (colSpanIndex) {
                var node = createResizeHandleNode(startIndex + colSpanIndex, colSpanIndex);
                var colWidth = (attrs.colwidth || [])[colSpanIndex];
                // last resize handle in the table (we don't want it to go beyond the table width)
                if (colIndex === cellsCount - 1 && colSpanIndex === colspan - 1) {
                    node.style.right = -tableResizeHandleWidth / 2 - 1 + "px";
                }
                else {
                    var offset = tableResizeHandleWidth / 2 + 4;
                    node.style.left = colWidth
                        ? // table has been resized, we position resize handles using values form colWidth attribute
                            colWidth + start_1 - offset + "px"
                        : // table hasn't been resized, we position with cell using %
                            "calc(" + (100 / colspan) * (colSpanIndex + 1) + "% - " + offset + "px)";
                }
                start_1 += colWidth;
                element.appendChild(node);
            });
        }
        return Decoration.widget(cell.pos + 1, 
        // Do not delay the rendering for this Decoration
        // because we need to always render all controls
        // to keep the order safe
        element, {
            key: TableDecorations.COLUMN_CONTROLS_DECORATIONS + "_" + index,
            // this decoration should be the first one, even before gap cursor.
            side: -100,
        });
    });
};
export var updateNodeDecorations = function (node, decorationSet, decorations, key) {
    var filteredDecorations = filterDecorationByKey(key, decorationSet);
    var decorationSetFiltered = decorationSet.remove(filteredDecorations);
    return decorationSetFiltered.add(node, decorations);
};
export var updatePluginStateDecorations = function (state, decorations, key) {
    return updateNodeDecorations(state.doc, getPluginState(state).decorationSet || DecorationSet.empty, decorations, key);
};
//# sourceMappingURL=decoration.js.map