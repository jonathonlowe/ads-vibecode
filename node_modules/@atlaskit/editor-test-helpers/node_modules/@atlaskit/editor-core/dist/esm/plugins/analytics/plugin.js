import { __assign, __read, __spread, __values } from "tslib";
import { Plugin, PluginKey } from 'prosemirror-state';
import { measureRender, isPerformanceAPIAvailable, } from '@atlaskit/editor-common';
import { EVENT_TYPE, ACTION, } from './types';
import { AnalyticsStep } from './analytics-step';
import { fireAnalyticsEvent } from './utils';
export var analyticsPluginKey = new PluginKey('analyticsPlugin');
function createPlugin(createAnalyticsEvent) {
    if (!createAnalyticsEvent) {
        return;
    }
    var hasRequiredPerformanceAPIs = isPerformanceAPIAvailable();
    return new Plugin({
        key: analyticsPluginKey,
        state: {
            init: function () { return null; },
            apply: function (tr) {
                var e_1, _a;
                var meta = tr.getMeta(analyticsPluginKey);
                if (meta) {
                    var _loop_1 = function (analytics) {
                        var payload = analytics.payload, channel = analytics.channel;
                        // Measures how much time it takes to update the DOM after each ProseMirror document update
                        // that has an analytics event.
                        if (hasRequiredPerformanceAPIs &&
                            tr.docChanged &&
                            payload.action !== ACTION.INSERTED &&
                            payload.action !== ACTION.DELETED) {
                            var measureName = payload.actionSubject + ":" + payload.action + ":" + payload.actionSubjectId;
                            measureRender(measureName, function (duration) {
                                fireAnalyticsEvent(createAnalyticsEvent)({
                                    payload: extendPayload(payload, duration),
                                    channel: channel,
                                });
                            });
                        }
                    };
                    try {
                        for (var meta_1 = __values(meta), meta_1_1 = meta_1.next(); !meta_1_1.done; meta_1_1 = meta_1.next()) {
                            var analytics = meta_1_1.value;
                            _loop_1(analytics);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (meta_1_1 && !meta_1_1.done && (_a = meta_1.return)) _a.call(meta_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            },
        },
        appendTransaction: function (transactions, oldState, newState) {
            var analyticsEvents = transactions
                .map(function (tr) {
                return tr.getMeta(analyticsPluginKey);
            })
                .filter(function (analyticsMeta) { return !!analyticsMeta; })
                .reduce(function (allAnalyticsEvents, trAnalyticsEvents) { return __spread(allAnalyticsEvents, trAnalyticsEvents); }, []);
            if (analyticsEvents.length > 0) {
                var tr = newState.tr.step(new AnalyticsStep(createAnalyticsEvent, analyticsEvents));
                // Preserve marks eg. if user clicked bold button with no selection
                if (newState.tr.storedMarks) {
                    tr.setStoredMarks(newState.tr.storedMarks);
                }
                // Preserve active input rule
                // Appending this transaction will deactivate an input rule, as a transaction
                // with steps is interpreted as the doc changing
                // This is needed so undo of autoformatting works as expected, this is a special
                // case handled by prosemirror-inputrules plugin
                var activeInputRulePlugin = newState.plugins.find(function (plugin) { return plugin.spec.isInputRules && plugin.getState(newState); });
                if (activeInputRulePlugin) {
                    var inputRuleState = activeInputRulePlugin.getState(newState);
                    inputRuleState.transform.step(new AnalyticsStep(createAnalyticsEvent, analyticsEvents));
                    tr.setMeta(activeInputRulePlugin, inputRuleState);
                }
                return tr;
            }
            return null;
        },
    });
}
var analyticsPlugin = function (createAnalyticsEvent) { return ({
    pmPlugins: function () {
        return [
            {
                name: 'analyticsPlugin',
                plugin: function () { return createPlugin(createAnalyticsEvent); },
            },
        ];
    },
}); };
export function extendPayload(payload, duration) {
    return __assign(__assign({}, payload), { attributes: __assign(__assign({}, payload.attributes), { duration: duration }), eventType: EVENT_TYPE.OPERATIONAL });
}
export default analyticsPlugin;
//# sourceMappingURL=plugin.js.map