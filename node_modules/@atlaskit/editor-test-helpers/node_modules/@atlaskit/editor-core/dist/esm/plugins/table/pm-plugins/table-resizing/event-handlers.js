import { TableMap } from 'prosemirror-tables';
import { getSelectionRect } from 'prosemirror-utils';
import { tableCellMinWidth, akEditorTableNumberColumnWidth, } from '@atlaskit/editor-common';
import { pluginKey as editorDisabledPluginKey } from '../../../editor-disabled';
import { updateColumnWidths } from '../../transforms';
import { getResizeState, resizeColumn, getLayoutSize, currentColWidth, pointsAtCell, updateControls, } from './utils';
import { getSelectedColumnIndexes } from '../../utils';
import { pluginKey as widthPluginKey } from '../../../width';
import { getPluginState } from './plugin';
import { setDragging, evenColumns } from './commands';
import { getParentNodeWidth } from '../../../../utils/node-width';
export var handleMouseDown = function (view, event, resizeHandlePos, dynamicTextSizing) {
    var state = view.state, dispatch = view.dispatch;
    var editorDisabled = editorDisabledPluginKey.getState(state).editorDisabled;
    var domAtPos = view.domAtPos.bind(view);
    if (editorDisabled ||
        resizeHandlePos === null ||
        !pointsAtCell(state.doc.resolve(resizeHandlePos))) {
        return false;
    }
    event.preventDefault();
    var cell = state.doc.nodeAt(resizeHandlePos);
    var $cell = state.doc.resolve(resizeHandlePos);
    var originalTable = $cell.node(-1);
    var start = $cell.start(-1);
    var dom = domAtPos(start).node;
    while (dom.nodeName !== 'TABLE') {
        dom = dom.parentNode;
    }
    var containerWidth = widthPluginKey.getState(state);
    var parentWidth = getParentNodeWidth(start, state, containerWidth);
    var colIndex = getColIndex(view, event.target, resizeHandlePos);
    var maxSize = parentWidth ||
        getLayoutSize(dom.getAttribute('data-layout'), containerWidth.width, {
            dynamicTextSizing: dynamicTextSizing,
        });
    if (originalTable.attrs.isNumberColumnEnabled) {
        maxSize -= akEditorTableNumberColumnWidth;
    }
    var resizeState = getResizeState({
        minWidth: tableCellMinWidth,
        maxSize: maxSize,
        table: originalTable,
        tableRef: dom,
        start: start,
        domAtPos: domAtPos,
    });
    if (evenColumns({
        resizeState: resizeState,
        table: originalTable,
        start: start,
        event: event,
    })(state, dispatch)) {
        finish(event);
        return true;
    }
    var width = currentColWidth(view, resizeHandlePos, cell
        .attrs);
    setDragging({ startX: event.clientX, startWidth: width })(state, dispatch);
    function finish(event) {
        window.removeEventListener('mouseup', finish);
        window.removeEventListener('mousemove', move);
        var clientX = event.clientX;
        var state = view.state, dispatch = view.dispatch;
        var dragging = getPluginState(state).dragging;
        if (resizeHandlePos === null ||
            !pointsAtCell(state.doc.resolve(resizeHandlePos))) {
            return;
        }
        // resizeHandlePos could be remapped via a collab change.
        // Fetch a fresh reference of the table.
        var $cell = state.doc.resolve(resizeHandlePos);
        var start = $cell.start(-1);
        var table = $cell.node(-1);
        // If we let go in the same place we started, dont need to do anything.
        if (dragging && clientX === dragging.startX) {
            setDragging(null)(state, dispatch);
            return;
        }
        var tr = state.tr;
        if (dragging) {
            var startX = dragging.startX;
            // If the table has changed (via collab for example) don't apply column widths
            // For example, if a table col is deleted we won't be able to reliably remap the new widths
            // There may be a more elegant solution to this, to avoid a jarring experience.
            if (table.eq(originalTable)) {
                var selectionRect = getSelectionRect(state.selection);
                var selectedColumns = selectionRect
                    ? getSelectedColumnIndexes(selectionRect)
                    : [];
                // only selected (or selected - 1) columns should be distributed
                var resizingSelectedColumns = selectedColumns.indexOf(colIndex) > -1 ||
                    selectedColumns.indexOf(colIndex + 1) > -1;
                var newResizeState = resizeColumn(resizeState, colIndex, clientX - startX, dom, resizingSelectedColumns ? selectedColumns : undefined);
                tr = updateColumnWidths(newResizeState, table, start)(tr);
            }
            setDragging(null, tr)(view.state, dispatch);
        }
    }
    function move(event) {
        var clientX = event.clientX, which = event.which;
        var state = view.state;
        var dragging = getPluginState(state).dragging;
        if (!which ||
            !dragging ||
            resizeHandlePos === null ||
            !pointsAtCell(state.doc.resolve(resizeHandlePos))) {
            return finish(event);
        }
        resizeColumn(resizeState, colIndex, clientX - dragging.startX, dom);
        updateControls(state);
    }
    window.addEventListener('mouseup', finish);
    window.addEventListener('mousemove', move);
    return true;
};
function getColIndex(view, resizeHandle, resizeHandlePos) {
    var colIndex = parseInt(resizeHandle.getAttribute('data-col-index') || '-1', 10);
    if (colIndex === -1) {
        var $cell = view.state.doc.resolve(resizeHandlePos);
        var table = $cell.node(-1);
        var map = TableMap.get(table);
        return (map.colCount($cell.pos - $cell.start(-1)) +
            $cell.nodeAfter.attrs.colspan -
            1);
    }
    return colIndex;
}
//# sourceMappingURL=event-handlers.js.map