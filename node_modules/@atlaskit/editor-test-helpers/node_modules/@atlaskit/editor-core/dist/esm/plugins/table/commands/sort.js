import { Selection } from 'prosemirror-state';
import { findTable, convertTableNodeToArrayOfRows, convertArrayOfRowsToTableNode, isCellSelection, getSelectionRect, findCellRectClosestToPos, } from 'prosemirror-utils';
import { compareNodes } from '../utils';
import { SortOrder } from '../types';
import { getPluginState } from '../pm-plugins/main';
import { TableMap } from 'prosemirror-tables';
export var sortByColumn = function (columnIndex, order) {
    if (order === void 0) { order = SortOrder.DESC; }
    return function (state, dispatch) {
        var tr = state.tr;
        var table = findTable(tr.selection);
        if (!table || !table.node) {
            return false;
        }
        var selectionRect = isCellSelection(tr.selection)
            ? getSelectionRect(tr.selection)
            : findCellRectClosestToPos(tr.selection.$from);
        if (!selectionRect) {
            return false;
        }
        var tablePluginState = getPluginState(state);
        var tableArray = convertTableNodeToArrayOfRows(table.node);
        var headerRow;
        if (tablePluginState.isHeaderRowEnabled) {
            headerRow = tableArray.shift();
        }
        var sortedTable = tableArray.sort(function (rowA, rowB) {
            return (order === SortOrder.DESC ? -1 : 1) *
                compareNodes(rowA[columnIndex], rowB[columnIndex]);
        });
        if (headerRow) {
            sortedTable.unshift(headerRow);
        }
        var newTableNode = convertArrayOfRowsToTableNode(table.node, sortedTable);
        tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTableNode);
        if (dispatch) {
            var pos = TableMap.get(table.node).positionAt(selectionRect.top, columnIndex, table.node);
            dispatch(tr.setSelection(Selection.near(tr.doc.resolve(table.start + pos))));
        }
        return true;
    };
};
//# sourceMappingURL=sort.js.map