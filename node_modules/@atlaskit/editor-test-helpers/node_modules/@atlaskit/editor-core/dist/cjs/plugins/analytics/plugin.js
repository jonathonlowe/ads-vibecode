"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_state_1 = require("prosemirror-state");
var editor_common_1 = require("@atlaskit/editor-common");
var types_1 = require("./types");
var analytics_step_1 = require("./analytics-step");
var utils_1 = require("./utils");
exports.analyticsPluginKey = new prosemirror_state_1.PluginKey('analyticsPlugin');
function createPlugin(createAnalyticsEvent) {
    if (!createAnalyticsEvent) {
        return;
    }
    var hasRequiredPerformanceAPIs = editor_common_1.isPerformanceAPIAvailable();
    return new prosemirror_state_1.Plugin({
        key: exports.analyticsPluginKey,
        state: {
            init: function () { return null; },
            apply: function (tr) {
                var e_1, _a;
                var meta = tr.getMeta(exports.analyticsPluginKey);
                if (meta) {
                    var _loop_1 = function (analytics) {
                        var payload = analytics.payload, channel = analytics.channel;
                        // Measures how much time it takes to update the DOM after each ProseMirror document update
                        // that has an analytics event.
                        if (hasRequiredPerformanceAPIs &&
                            tr.docChanged &&
                            payload.action !== types_1.ACTION.INSERTED &&
                            payload.action !== types_1.ACTION.DELETED) {
                            var measureName = payload.actionSubject + ":" + payload.action + ":" + payload.actionSubjectId;
                            editor_common_1.measureRender(measureName, function (duration) {
                                utils_1.fireAnalyticsEvent(createAnalyticsEvent)({
                                    payload: extendPayload(payload, duration),
                                    channel: channel,
                                });
                            });
                        }
                    };
                    try {
                        for (var meta_1 = tslib_1.__values(meta), meta_1_1 = meta_1.next(); !meta_1_1.done; meta_1_1 = meta_1.next()) {
                            var analytics = meta_1_1.value;
                            _loop_1(analytics);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (meta_1_1 && !meta_1_1.done && (_a = meta_1.return)) _a.call(meta_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            },
        },
        appendTransaction: function (transactions, oldState, newState) {
            var analyticsEvents = transactions
                .map(function (tr) {
                return tr.getMeta(exports.analyticsPluginKey);
            })
                .filter(function (analyticsMeta) { return !!analyticsMeta; })
                .reduce(function (allAnalyticsEvents, trAnalyticsEvents) { return tslib_1.__spread(allAnalyticsEvents, trAnalyticsEvents); }, []);
            if (analyticsEvents.length > 0) {
                var tr = newState.tr.step(new analytics_step_1.AnalyticsStep(createAnalyticsEvent, analyticsEvents));
                // Preserve marks eg. if user clicked bold button with no selection
                if (newState.tr.storedMarks) {
                    tr.setStoredMarks(newState.tr.storedMarks);
                }
                // Preserve active input rule
                // Appending this transaction will deactivate an input rule, as a transaction
                // with steps is interpreted as the doc changing
                // This is needed so undo of autoformatting works as expected, this is a special
                // case handled by prosemirror-inputrules plugin
                var activeInputRulePlugin = newState.plugins.find(function (plugin) { return plugin.spec.isInputRules && plugin.getState(newState); });
                if (activeInputRulePlugin) {
                    var inputRuleState = activeInputRulePlugin.getState(newState);
                    inputRuleState.transform.step(new analytics_step_1.AnalyticsStep(createAnalyticsEvent, analyticsEvents));
                    tr.setMeta(activeInputRulePlugin, inputRuleState);
                }
                return tr;
            }
            return null;
        },
    });
}
var analyticsPlugin = function (createAnalyticsEvent) { return ({
    pmPlugins: function () {
        return [
            {
                name: 'analyticsPlugin',
                plugin: function () { return createPlugin(createAnalyticsEvent); },
            },
        ];
    },
}); };
function extendPayload(payload, duration) {
    return tslib_1.__assign(tslib_1.__assign({}, payload), { attributes: tslib_1.__assign(tslib_1.__assign({}, payload.attributes), { duration: duration }), eventType: types_1.EVENT_TYPE.OPERATIONAL });
}
exports.extendPayload = extendPayload;
exports.default = analyticsPlugin;
//# sourceMappingURL=plugin.js.map