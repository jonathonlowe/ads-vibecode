"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var react_dom_1 = require("react-dom");
var react_select_1 = tslib_1.__importDefault(require("react-select"));
var focus_trap_1 = tslib_1.__importDefault(require("focus-trap"));
var react_popper_1 = require("react-popper");
var react_node_resolver_1 = tslib_1.__importDefault(require("react-node-resolver"));
var objects_1 = tslib_1.__importDefault(require("shallow-equal/objects"));
var colors_1 = require("@atlaskit/theme/colors");
var components_1 = require("./components");
/** Are we rendering on the client or server? */
var canUseDOM = function () {
    return Boolean(typeof window !== 'undefined' &&
        window.document &&
        window.document.createElement);
};
// ==============================
// Class
// ==============================
var defaultStyles = {
    groupHeading: function (provided) { return (tslib_1.__assign(tslib_1.__assign({}, provided), { color: colors_1.N80 })); },
};
var defaultPopperProps = {
    modifiers: { offset: { offset: "0, 8" } },
    placement: 'bottom-start',
};
var isEmpty = function (obj) { return Object.keys(obj).length === 0; };
var PopupSelect = /** @class */ (function (_super) {
    tslib_1.__extends(PopupSelect, _super);
    function PopupSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.focusTrap = null;
        _this.menuRef = null;
        _this.selectRef = null;
        _this.targetRef = null;
        _this.state = {
            isOpen: false,
            mergedComponents: components_1.defaultComponents,
            mergedPopperProps: defaultPopperProps,
        };
        // Event Handlers
        // ==============================
        _this.handleKeyDown = function (event) {
            switch (event.key) {
                case 'Escape':
                case 'Esc':
                    _this.close();
                    break;
                default:
            }
            if (_this.props.handleKeyDown) {
                _this.props.handleKeyDown(event);
            }
        };
        _this.handleClick = function (_a) {
            var target = _a.target;
            var isOpen = _this.state.isOpen;
            // appease flow
            if (!(target instanceof Element))
                return;
            // NOTE: Why not use the <Blanket /> component to close?
            // We don't want to interupt the user's flow. Taking this approach allows
            // user to click "through" to other elements and close the popout.
            if (isOpen && _this.menuRef && !_this.menuRef.contains(target)) {
                _this.close();
            }
            // open on target click -- we can't trust consumers to spread the onClick
            // property to the target
            if (!isOpen && _this.targetRef && _this.targetRef.contains(target)) {
                _this.open();
            }
        };
        _this.handleSelectChange = function (value, actionMeta) {
            var _a = _this.props, closeMenuOnSelect = _a.closeMenuOnSelect, onChange = _a.onChange;
            if (closeMenuOnSelect && actionMeta.action !== 'clear')
                _this.close();
            if (onChange)
                onChange(value, actionMeta);
        };
        // Internal Lifecycle
        // ==============================
        _this.open = function () {
            var onOpen = _this.props.onOpen;
            if (onOpen)
                onOpen();
            _this.setState({ isOpen: true }, _this.initialiseFocusTrap);
            if (_this.selectRef) {
                _this.selectRef.select.openMenu('first'); // HACK
            }
            if (typeof window === 'undefined')
                return;
            window.addEventListener('keydown', _this.handleKeyDown);
        };
        _this.initialiseFocusTrap = function () {
            if (!_this.menuRef)
                return;
            var trapConfig = {
                clickOutsideDeactivates: true,
                escapeDeactivates: true,
                fallbackFocus: _this.menuRef,
                returnFocusOnDeactivate: true,
            };
            _this.focusTrap = focus_trap_1.default(_this.menuRef, trapConfig);
            // allow time for the HTMLElement to render
            setTimeout(function () { return _this.focusTrap.activate(); }, 1);
        };
        _this.close = function () {
            var onClose = _this.props.onClose;
            if (onClose)
                onClose();
            _this.setState({ isOpen: false });
            if (_this.focusTrap) {
                _this.focusTrap.deactivate();
            }
            if (typeof window === 'undefined')
                return;
            window.removeEventListener('keydown', _this.handleKeyDown);
        };
        // Refs
        // ==============================
        _this.resolveTargetRef = function (popperRef) { return function (ref) {
            // avoid thrashing fn calls
            if (!_this.targetRef && popperRef && ref) {
                _this.targetRef = ref;
                if (typeof popperRef === 'function') {
                    popperRef(ref);
                }
                else {
                    popperRef.current = ref;
                }
            }
        }; };
        _this.resolveMenuRef = function (popperRef) { return function (ref) {
            _this.menuRef = ref;
            if (typeof popperRef === 'function') {
                popperRef(ref);
            }
            else {
                popperRef.current = ref;
            }
        }; };
        _this.getSelectRef = function (ref) {
            _this.selectRef = ref;
        };
        // Utils
        // ==============================
        // account for groups when counting options
        // this may need to be recursive, right now it just counts one level
        _this.getItemCount = function () {
            var options = _this.props.options;
            var count = 0;
            options.forEach(function (groupOrOption) {
                if (groupOrOption.options) {
                    groupOrOption.options.forEach(function () { return count++; });
                }
                else {
                    count++;
                }
            });
            return count;
        };
        _this.getMaxHeight = function () {
            var maxMenuHeight = _this.props.maxMenuHeight;
            if (!_this.selectRef)
                return maxMenuHeight;
            // subtract the control height to maintain consistency
            var showSearchControl = _this.showSearchControl();
            var controlRef = _this.selectRef.select.controlRef;
            // @ts-ignore React-select provides incomplete types for controlRef
            var offsetHeight = showSearchControl ? controlRef.offsetHeight : 0;
            var maxHeight = maxMenuHeight - offsetHeight;
            return maxHeight;
        };
        // if the threshold is exceeded display the search control
        _this.showSearchControl = function () {
            var searchThreshold = _this.props.searchThreshold;
            return _this.getItemCount() > searchThreshold;
        };
        // Renderers
        // ==============================
        _this.renderSelect = function () {
            var _a = _this.props, footer = _a.footer, maxMenuWidth = _a.maxMenuWidth, minMenuWidth = _a.minMenuWidth, target = _a.target, props = tslib_1.__rest(_a, ["footer", "maxMenuWidth", "minMenuWidth", "target"]);
            var _b = _this.state, isOpen = _b.isOpen, mergedComponents = _b.mergedComponents, mergedPopperProps = _b.mergedPopperProps;
            var showSearchControl = _this.showSearchControl();
            var portalDestination = canUseDOM() ? document.body : null;
            var components = tslib_1.__assign(tslib_1.__assign({}, mergedComponents), { Control: showSearchControl ? mergedComponents.Control : components_1.DummyControl });
            if (!portalDestination || !isOpen)
                return null;
            var popper = (react_1.default.createElement(react_popper_1.Popper, tslib_1.__assign({}, mergedPopperProps), function (_a) {
                var placement = _a.placement, ref = _a.ref, style = _a.style;
                return (react_1.default.createElement(react_node_resolver_1.default, { innerRef: _this.resolveMenuRef(ref) },
                    react_1.default.createElement(components_1.MenuDialog, { style: style, "data-placement": placement, minWidth: minMenuWidth, maxWidth: maxMenuWidth },
                        react_1.default.createElement(react_select_1.default, tslib_1.__assign({ backspaceRemovesValue: false, controlShouldRenderValue: false, isClearable: false, tabSelectsValue: false, menuIsOpen: true, ref: _this.getSelectRef }, props, { isSearchable: showSearchControl, styles: tslib_1.__assign(tslib_1.__assign({}, defaultStyles), props.styles), maxMenuHeight: _this.getMaxHeight(), components: components, onChange: _this.handleSelectChange })),
                        footer)));
            }));
            return mergedPopperProps.positionFixed
                ? popper
                : react_dom_1.createPortal(popper, portalDestination);
        };
        return _this;
    }
    PopupSelect.getDerivedStateFromProps = function (props, state) {
        var newState = {};
        // Merge consumer and default popper props
        var mergedPopperProps = tslib_1.__assign(tslib_1.__assign({}, defaultPopperProps), props.popperProps);
        if (!objects_1.default(mergedPopperProps, state.mergedPopperProps)) {
            newState.mergedPopperProps = mergedPopperProps;
        }
        // Merge consumer and default components
        var mergedComponents = tslib_1.__assign(tslib_1.__assign({}, components_1.defaultComponents), props.components);
        if (!objects_1.default(mergedComponents, state.mergedComponents)) {
            newState.mergedComponents = mergedComponents;
        }
        if (!isEmpty(newState))
            return newState;
        return null;
    };
    PopupSelect.prototype.componentDidMount = function () {
        if (typeof window === 'undefined')
            return;
        window.addEventListener('click', this.handleClick);
    };
    PopupSelect.prototype.componentWillUnmount = function () {
        if (typeof window === 'undefined')
            return;
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeyDown);
    };
    PopupSelect.prototype.render = function () {
        var _this = this;
        var target = this.props.target;
        var isOpen = this.state.isOpen;
        return (react_1.default.createElement(react_popper_1.Manager, null,
            react_1.default.createElement(react_popper_1.Reference, null, function (_a) {
                var ref = _a.ref;
                return target && target({ ref: _this.resolveTargetRef(ref), isOpen: isOpen });
            }),
            this.renderSelect()));
    };
    PopupSelect.defaultProps = {
        closeMenuOnSelect: true,
        components: {},
        maxMenuHeight: 300,
        maxMenuWidth: 440,
        minMenuWidth: 220,
        popperProps: {},
        searchThreshold: 5,
        styles: {},
        options: [],
    };
    return PopupSelect;
}(react_1.PureComponent));
exports.default = PopupSelect;
//# sourceMappingURL=PopupSelect.js.map