import React, { PureComponent } from 'react';
import { createPortal } from 'react-dom';
import Select from 'react-select';
import createFocusTrap from 'focus-trap';
import { Manager, Reference, Popper } from 'react-popper';
import NodeResolver from 'react-node-resolver';
import shallowEqualObjects from 'shallow-equal/objects';
import { N80 } from '@atlaskit/theme/colors';
import { MenuDialog, DummyControl, defaultComponents } from './components';
/** Are we rendering on the client or server? */
const canUseDOM = () => Boolean(typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement);
// ==============================
// Class
// ==============================
const defaultStyles = {
    groupHeading: provided => ({ ...provided, color: N80 }),
};
const defaultPopperProps = {
    modifiers: { offset: { offset: `0, 8` } },
    placement: 'bottom-start',
};
const isEmpty = (obj) => Object.keys(obj).length === 0;
export default class PopupSelect extends PureComponent {
    constructor() {
        super(...arguments);
        this.focusTrap = null;
        this.menuRef = null;
        this.selectRef = null;
        this.targetRef = null;
        this.state = {
            isOpen: false,
            mergedComponents: defaultComponents,
            mergedPopperProps: defaultPopperProps,
        };
        // Event Handlers
        // ==============================
        this.handleKeyDown = (event) => {
            switch (event.key) {
                case 'Escape':
                case 'Esc':
                    this.close();
                    break;
                default:
            }
            if (this.props.handleKeyDown) {
                this.props.handleKeyDown(event);
            }
        };
        this.handleClick = ({ target }) => {
            const { isOpen } = this.state;
            // appease flow
            if (!(target instanceof Element))
                return;
            // NOTE: Why not use the <Blanket /> component to close?
            // We don't want to interupt the user's flow. Taking this approach allows
            // user to click "through" to other elements and close the popout.
            if (isOpen && this.menuRef && !this.menuRef.contains(target)) {
                this.close();
            }
            // open on target click -- we can't trust consumers to spread the onClick
            // property to the target
            if (!isOpen && this.targetRef && this.targetRef.contains(target)) {
                this.open();
            }
        };
        this.handleSelectChange = (value, actionMeta) => {
            const { closeMenuOnSelect, onChange } = this.props;
            if (closeMenuOnSelect && actionMeta.action !== 'clear')
                this.close();
            if (onChange)
                onChange(value, actionMeta);
        };
        // Internal Lifecycle
        // ==============================
        this.open = () => {
            const { onOpen } = this.props;
            if (onOpen)
                onOpen();
            this.setState({ isOpen: true }, this.initialiseFocusTrap);
            if (this.selectRef) {
                this.selectRef.select.openMenu('first'); // HACK
            }
            if (typeof window === 'undefined')
                return;
            window.addEventListener('keydown', this.handleKeyDown);
        };
        this.initialiseFocusTrap = () => {
            if (!this.menuRef)
                return;
            const trapConfig = {
                clickOutsideDeactivates: true,
                escapeDeactivates: true,
                fallbackFocus: this.menuRef,
                returnFocusOnDeactivate: true,
            };
            this.focusTrap = createFocusTrap(this.menuRef, trapConfig);
            // allow time for the HTMLElement to render
            setTimeout(() => this.focusTrap.activate(), 1);
        };
        this.close = () => {
            const { onClose } = this.props;
            if (onClose)
                onClose();
            this.setState({ isOpen: false });
            if (this.focusTrap) {
                this.focusTrap.deactivate();
            }
            if (typeof window === 'undefined')
                return;
            window.removeEventListener('keydown', this.handleKeyDown);
        };
        // Refs
        // ==============================
        this.resolveTargetRef = (popperRef) => (ref) => {
            // avoid thrashing fn calls
            if (!this.targetRef && popperRef && ref) {
                this.targetRef = ref;
                if (typeof popperRef === 'function') {
                    popperRef(ref);
                }
                else {
                    popperRef.current = ref;
                }
            }
        };
        this.resolveMenuRef = (popperRef) => (ref) => {
            this.menuRef = ref;
            if (typeof popperRef === 'function') {
                popperRef(ref);
            }
            else {
                popperRef.current = ref;
            }
        };
        this.getSelectRef = (ref) => {
            this.selectRef = ref;
        };
        // Utils
        // ==============================
        // account for groups when counting options
        // this may need to be recursive, right now it just counts one level
        this.getItemCount = () => {
            const { options } = this.props;
            let count = 0;
            options.forEach((groupOrOption) => {
                if (groupOrOption.options) {
                    groupOrOption.options.forEach(() => count++);
                }
                else {
                    count++;
                }
            });
            return count;
        };
        this.getMaxHeight = () => {
            const { maxMenuHeight } = this.props;
            if (!this.selectRef)
                return maxMenuHeight;
            // subtract the control height to maintain consistency
            const showSearchControl = this.showSearchControl();
            const { controlRef } = this.selectRef.select;
            // @ts-ignore React-select provides incomplete types for controlRef
            const offsetHeight = showSearchControl ? controlRef.offsetHeight : 0;
            const maxHeight = maxMenuHeight - offsetHeight;
            return maxHeight;
        };
        // if the threshold is exceeded display the search control
        this.showSearchControl = () => {
            const { searchThreshold } = this.props;
            return this.getItemCount() > searchThreshold;
        };
        // Renderers
        // ==============================
        this.renderSelect = () => {
            const { footer, maxMenuWidth, minMenuWidth, target, ...props } = this.props;
            const { isOpen, mergedComponents, mergedPopperProps } = this.state;
            const showSearchControl = this.showSearchControl();
            const portalDestination = canUseDOM() ? document.body : null;
            const components = {
                ...mergedComponents,
                Control: showSearchControl ? mergedComponents.Control : DummyControl,
            };
            if (!portalDestination || !isOpen)
                return null;
            const popper = (React.createElement(Popper, Object.assign({}, mergedPopperProps), ({ placement, ref, style }) => {
                return (React.createElement(NodeResolver, { innerRef: this.resolveMenuRef(ref) },
                    React.createElement(MenuDialog, { style: style, "data-placement": placement, minWidth: minMenuWidth, maxWidth: maxMenuWidth },
                        React.createElement(Select, Object.assign({ backspaceRemovesValue: false, controlShouldRenderValue: false, isClearable: false, tabSelectsValue: false, menuIsOpen: true, ref: this.getSelectRef }, props, { isSearchable: showSearchControl, styles: { ...defaultStyles, ...props.styles }, maxMenuHeight: this.getMaxHeight(), components: components, onChange: this.handleSelectChange })),
                        footer)));
            }));
            return mergedPopperProps.positionFixed
                ? popper
                : createPortal(popper, portalDestination);
        };
    }
    static getDerivedStateFromProps(props, state) {
        const newState = {};
        // Merge consumer and default popper props
        const mergedPopperProps = { ...defaultPopperProps, ...props.popperProps };
        if (!shallowEqualObjects(mergedPopperProps, state.mergedPopperProps)) {
            newState.mergedPopperProps = mergedPopperProps;
        }
        // Merge consumer and default components
        const mergedComponents = { ...defaultComponents, ...props.components };
        if (!shallowEqualObjects(mergedComponents, state.mergedComponents)) {
            newState.mergedComponents = mergedComponents;
        }
        if (!isEmpty(newState))
            return newState;
        return null;
    }
    componentDidMount() {
        if (typeof window === 'undefined')
            return;
        window.addEventListener('click', this.handleClick);
    }
    componentWillUnmount() {
        if (typeof window === 'undefined')
            return;
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeyDown);
    }
    render() {
        const { target } = this.props;
        const { isOpen } = this.state;
        return (React.createElement(Manager, null,
            React.createElement(Reference, null, ({ ref }) => target && target({ ref: this.resolveTargetRef(ref), isOpen })),
            this.renderSelect()));
    }
}
PopupSelect.defaultProps = {
    closeMenuOnSelect: true,
    components: {},
    maxMenuHeight: 300,
    maxMenuWidth: 440,
    minMenuWidth: 220,
    popperProps: {},
    searchThreshold: 5,
    styles: {},
    options: [],
};
//# sourceMappingURL=PopupSelect.js.map