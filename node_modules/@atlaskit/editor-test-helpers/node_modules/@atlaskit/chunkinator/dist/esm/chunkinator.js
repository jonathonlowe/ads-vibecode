import { tap } from 'rxjs/operators/tap';
import { concatMap } from 'rxjs/operators/concatMap';
import { fromPromise } from 'rxjs/observable/fromPromise';
import { Subject } from 'rxjs/Subject';
import { slicenator } from './slicenator';
import { hashinator } from './hashinator';
import { probinator } from './probinator';
import { uploadinator } from './uploadinator';
import { processinator } from './processinator';
import { fetchBlob } from './utils';
export var getObservableFromFile = function (file, options, callbacks) {
    return fromPromise(fetchBlob(file)).pipe(concatMap(function (blob) {
        var chunkSize = options.chunkSize;
        var onProgress = callbacks.onProgress;
        var totalChunks = Math.ceil(blob.size / chunkSize);
        var slicenatedBlobs = slicenator(blob, { size: chunkSize });
        var hashinatedBlobs = hashinator(slicenatedBlobs, {
            concurrency: options.hashingConcurrency,
            hasher: options.hashingFunction,
        });
        var probinatedBlobs = probinator(hashinatedBlobs, {
            batchSize: options.probingBatchSize,
            prober: options.probingFunction,
        });
        var uploadedChunks = 0;
        var uploadedBlobs = uploadinator(probinatedBlobs, {
            concurrency: options.uploadingConcurrency,
            uploader: options.uploadingFunction,
        });
        if (onProgress) {
            uploadedBlobs = uploadedBlobs.pipe(tap(function () {
                uploadedChunks += 1;
                onProgress(uploadedChunks / totalChunks);
            }));
        }
        return processinator(uploadedBlobs, {
            batchSize: options.processingBatchSize,
            processor: options.processingFunction,
        });
    }));
};
export var chunkinator = function (file, options, callbacks) {
    return toCancelablePromise(getObservableFromFile(file, options, callbacks));
};
export function toCancelablePromise(observable) {
    var subject = new Subject();
    var subscription = observable.subscribe(subject);
    return {
        response: subject.toPromise(),
        cancel: function () {
            subscription.unsubscribe();
            subject.error('canceled');
        },
    };
}
//# sourceMappingURL=chunkinator.js.map