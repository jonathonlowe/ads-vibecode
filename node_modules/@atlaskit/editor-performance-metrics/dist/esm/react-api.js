import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
/* eslint-disable @atlaskit/editor/no-re-export */
// Entry file in package.json

/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { memo, useEffect, useMemo, useRef } from 'react';
import { createCalculator } from './internals/editorPerformanceMetrics';
import { getGlobalEditorMetricsObserver } from './internals/global';

/**
 *    onTTVC: (optional) Callback function that receives TTVC metrics.
 *       Type: (result: { ttvc: TTVCTargets; relativeTTVC: TTVCTargets }) => void
 *       ttvc: Object containing TTVC values for different percentiles.
 *       relativeTTVC: TTVC values relative to when the component was mounted.
 *
 *    onUserLatency: (optional) Callback function that receives user latency metrics.
 *        Type: (result: { latency: LatencyPercentileTargets }) => void
 *        latency: Object containing latency percentiles for different user event categories.
 *
 *    onTTAI: (Optional) Called once when the first idle time happen after the component is mounted
 *        Type: (result: { idleAt: DOMHighResTimeStamp }) => void
 *        idleAt: This number represents the moment the browser as truly idle
 */

var useTTVC = function useTTVC(_ref) {
  var observer = _ref.observer,
    onTTVC = _ref.onTTVC;
  var mountedAtRef = useRef(performance.now());
  useEffect(function () {
    if (!observer || !onTTVC) {
      return;
    }
    var unsub = observer.onceNextIdle( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {
        var idleAt, timelineBuffer, metrics, ttvc, startedTime, relativeTTVC;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              idleAt = _ref2.idleAt, timelineBuffer = _ref2.timelineBuffer;
              metrics = createCalculator(timelineBuffer);
              _context.next = 4;
              return metrics.calculateVCTargets({
                // Only events that started after the component was created are valid for TTVC calculation
                rangeEventsFilter: {
                  from: mountedAtRef.current,
                  to: 'abort:user-interaction'
                }
              });
            case 4:
              ttvc = _context.sent;
              if (ttvc) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              startedTime = mountedAtRef.current;
              relativeTTVC = Object.entries(ttvc).reduce(function (acc, _ref4) {
                var _ref5 = _slicedToArray(_ref4, 2),
                  percentile = _ref5[0],
                  value = _ref5[1];
                // @ts-ignore
                acc[percentile] = value - startedTime;
                return acc;
              }, {});
              onTTVC({
                ttvc: ttvc,
                relativeTTVC: relativeTTVC
              });
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }());
    return function () {
      unsub();
    };
  }, [observer, onTTVC]);
};
var useLatency = function useLatency(_ref6) {
  var observer = _ref6.observer,
    onUserLatency = _ref6.onUserLatency;
  useEffect(function () {
    if (!observer || !onUserLatency) {
      return;
    }
    var unsub = observer.onIdleBuffer(function (_ref7) {
      var idleAt = _ref7.idleAt,
        timelineBuffer = _ref7.timelineBuffer;
      createCalculator(timelineBuffer).calculateLatencyPercents().then(function (result) {
        if (!result) {
          return;
        }
        onUserLatency({
          latency: result
        });
      });
    });
    return function () {
      unsub();
    };
  }, [observer, onUserLatency]);
};
var useTTAI = function useTTAI(_ref8) {
  var observer = _ref8.observer,
    onTTAI = _ref8.onTTAI;
  useEffect(function () {
    if (!observer || !onTTAI) {
      return;
    }
    var unsub = observer.onceNextIdle(function (_ref9) {
      var idleAt = _ref9.idleAt,
        timelineBuffer = _ref9.timelineBuffer;
      onTTAI({
        idleAt: idleAt
      });
    });
    return function () {
      unsub();
    };
  }, [observer, onTTAI]);
};
export var PerformanceMetrics = /*#__PURE__*/memo(function (_ref10) {
  var onTTVC = _ref10.onTTVC,
    onUserLatency = _ref10.onUserLatency,
    onTTAI = _ref10.onTTAI;
  var observer = useMemo(function () {
    var isSSR = Boolean(process.env.REACT_SSR);
    if (isSSR) {
      return null;
    }
    var observer = getGlobalEditorMetricsObserver();
    if (observer) {
      observer.start({
        startTime: performance.now()
      });
    }
    return observer;
  }, []);
  useEffect(function () {
    return function () {
      if (!observer) {
        return;
      }
      observer.stop();
    };
  }, [observer]);
  useTTVC({
    observer: observer,
    onTTVC: onTTVC
  });
  useLatency({
    observer: observer,
    onUserLatency: onUserLatency
  });
  useTTAI({
    observer: observer,
    onTTAI: onTTAI
  });
  return null;
});
PerformanceMetrics.displayName = 'PerformanceMetrics';