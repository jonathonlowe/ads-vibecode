import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
var MAX_TIMEOUT_DELAY_ALLOWED_TO_BE_WRAPPED = 2000; // 2 seconds
var MAX_NESTED_TIMERS_ALLOWED_TO_BE_WRAPPED = 1;

/**
 * 🧱 Internal Type: Editor FE Platform
 *
 * Wraps the global setTimeout and clearTimeout functions to integrate with a TimelineHoldable instance.
 * This wrapper allows tracking of timer operations within the timeline, providing insights into
 * asynchronous operations that might affect the application's idle state.
 *
 * Key Features:
 * - Integrates setTimeout calls with the TimelineHoldable's hold mechanism.
 * - Automatically releases holds when the timer callback is executed or cleared.
 * - Preserves the original behavior of setTimeout and clearTimeout for non-tracked cases.
 *
 * ⚠️ Important Notes:
 * - To prevent excessive holds and potential performance issues, this wrapper only monitors
 *   timeouts with delays up to 2000ms (2 seconds). Timeouts with larger delays are not wrapped. The `maxTimeoutAllowed` allows you to override the default timeout.
 * - Zero-delay timeouts (used for deferring to the next event loop) are also not wrapped.
 *
 * @param {Object} options - Configuration options for the wrapper.
 * @param {Object} options.globalContext - The global context containing setTimeout and clearTimeout functions.
 *                                         This is typically the global `window` object in browser environments.
 * @param {Object} options.maxTimeoutAllowed - Override the default timeout delay allowed (useful for testing enviroments);
 * @param {typeof setTimeout} options.globalContext.setTimeout - The original setTimeout function to be wrapped.
 * @param {typeof clearTimeout} options.globalContext.clearTimeout - The original clearTimeout function to be wrapped.
 * @param {TimelineHoldable} options.timelineHoldable - An instance implementing the TimelineHoldable interface.
 *                                                      This is used to create and release holds for each tracked timeout.
 *
 * @returns {Function} A cleanup function that, when called, restores the original setTimeout and clearTimeout
 *                     implementations. This should be called when the wrapper is no longer needed to prevent
 *                     memory leaks and ensure proper functionality of the global timer functions.
 *
 * @example
 * const cleanup = wrapperTimers({
 *   globalContext: window,
 *   timelineHoldable: myTimelineInstance
 * });
 *
 * // Later, when the wrapper is no longer needed:
 * cleanup();
 */
export var wrapperTimers = function wrapperTimers(_ref) {
  var globalContext = _ref.globalContext,
    timelineHoldable = _ref.timelineHoldable,
    maxTimeoutAllowed = _ref.maxTimeoutAllowed,
    maxNestedTimers = _ref.maxNestedTimers;
  var timeoutsUnholdMap = new Map();
  var timeoutAllowed = typeof maxTimeoutAllowed === 'number' ? maxTimeoutAllowed : MAX_TIMEOUT_DELAY_ALLOWED_TO_BE_WRAPPED;
  var nestedTimersAllowed = typeof maxNestedTimers === 'number' ? maxNestedTimers : MAX_NESTED_TIMERS_ALLOWED_TO_BE_WRAPPED;
  var originalSetTimeout = globalContext.setTimeout;
  var originalClearTimeout = globalContext.clearTimeout;

  /**
   * This counter is used to prevent recursive wrapping of setTimeout calls.
   *
   * Due to JavaScript's lexical scoping, this variable will be shared across
   * all invocations of the setTimeoutProxy within the same wrapperTimers call.
   * This allows us to track whether we're currently inside a wrapped callback
   * and how deeep.
   *
   * This prevents excessive hold/unhold calls and potential issues with
   * nested timeouts, while still allowing the outer timeout to be tracked.
   *
   */
  var nestedCallsTimerCount = 0;
  var setTimeoutProxy = new Proxy(globalContext.setTimeout, {
    apply: function apply(target, thisArg, args) {
      var delayTime = args.length > 1 && typeof args[1] === 'number' ? args[1] : null;
      var isValidDelayTime = typeof delayTime !== 'number' || delayTime === 0 || delayTime > timeoutAllowed;
      if (isValidDelayTime || nestedCallsTimerCount >= nestedTimersAllowed) {
        return target.apply(thisArg, args);
      }
      var localNestedCounter = nestedCallsTimerCount;
      var unhold = timelineHoldable.hold({
        source: 'setTimeout'
      });
      var timerId = null;
      var callbackProxy = new Proxy(args[0], {
        apply: function apply(callbackTarget, cbThisArg, cbArgs) {
          nestedCallsTimerCount = localNestedCounter + 1;
          try {
            var result = callbackTarget.apply(cbThisArg, cbArgs);
            return result;
          } finally {
            unhold();
            if (timerId !== null) {
              timeoutsUnholdMap.delete(timerId);
            }
          }
        }
      });
      timerId = target.apply(thisArg, [callbackProxy].concat(_toConsumableArray(args.slice(1))));
      timeoutsUnholdMap.set(timerId, new WeakRef(unhold));
      return timerId;
    }
  });
  var clearTimeoutProxy = new Proxy(globalContext.clearTimeout, {
    apply: function apply(target, thisArg, args) {
      var tm = args[0];
      if (typeof tm !== 'number') {
        return target.apply(thisArg, args);
      }
      var unholdRef = timeoutsUnholdMap.get(tm);
      if (unholdRef) {
        var unhold = unholdRef.deref();
        if (unhold) {
          unhold();
        }
        timeoutsUnholdMap.delete(tm);
      }
      return target.apply(thisArg, args);
    }
  });
  globalContext.setTimeout = setTimeoutProxy;
  globalContext.clearTimeout = clearTimeoutProxy;
  return function cleanup() {
    globalContext.setTimeout = originalSetTimeout;
    globalContext.clearTimeout = originalClearTimeout;
  };
};