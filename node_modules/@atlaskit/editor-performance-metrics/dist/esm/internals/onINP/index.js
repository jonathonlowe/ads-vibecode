// Adapted from https://github.com/GoogleChrome/web-vitals/blob/main/src/lib/onINP.ts

import { bindReporter } from './bindReporter';
import { InteractionManager } from './interactions';
import { onHidden } from './onHidden';
import { whenIdle } from './whenIdle';
export var onINP = function onINP(callback) {
  var metric = {
    value: 0,
    delta: 0,
    entries: []
  };
  var reporter = bindReporter(callback);
  var interactionManager = new InteractionManager();
  var handleEntries = function handleEntries(entries) {
    whenIdle(function () {
      entries.forEach(function (entry) {
        return interactionManager.processInteractionEntry(entry);
      });
      var inp = interactionManager.estimateP98LongestInteraction();
      if (inp && inp.latency !== metric.value) {
        metric.value = inp.latency;
        metric.entries = entries;
        reporter(metric);
      }
    });
  };
  var po = observeInteractionEvent(handleEntries);
  var onHiddenCleanup = onHidden(function () {
    handleEntries(po.takeRecords());
    reporter(metric);
  });
  return function () {
    po.disconnect();
    interactionManager.cleanup();
    onHiddenCleanup();
  };
};
var observeInteractionEvent = function observeInteractionEvent(callback) {
  var po = new PerformanceObserver(function (list) {
    // Delay by a microtask to workaround a bug in Safari where the
    // callback is invoked immediately, rather than in a separate task.
    // See: https://github.com/GoogleChrome/web-vitals/issues/277
    Promise.resolve().then(function () {
      callback(list.getEntries());
    });
  });

  // Event Timing entries have their durations rounded to the nearest 8ms,
  // so a duration of 40ms would be any event that spans 2.5 or more frames
  // at 60Hz. This threshold is chosen to strike a balance between usefulness
  // and performance. Running this callback for any interaction that spans
  // just one or two frames is likely not worth the insight that could be
  // gained.
  if (PerformanceObserver.supportedEntryTypes.includes('event')) {
    po.observe({
      type: 'event',
      buffered: true,
      durationThreshold: 40
    });
  }
  if (PerformanceObserver.supportedEntryTypes.includes('first-input')) {
    po.observe({
      type: 'first-input',
      buffered: true
    });
  }
  return po;
};