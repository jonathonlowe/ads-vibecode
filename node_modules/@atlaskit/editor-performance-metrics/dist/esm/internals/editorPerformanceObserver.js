import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/* eslint-disable compat/compat */
import { getEventCategory, searchAncestors } from './dom';
import { DOMObservers } from './DOMObservers';
import { FirstInteractionObserver } from './firstInteractionObserver';
import { getElementName } from './getElementName';
import { UserEventsObserver } from './userEventsObserver';
import { wrapperFetch } from './wrapperFetch';
import { wrapperTimers } from './wrapperTimers';
var defaultOptions = {
  timers: {
    setTimeout: {
      maxTimeoutAllowedToTrack: 2000 // two seconds
    }
  }
};
export var EditorPerformanceObserver = /*#__PURE__*/function () {
  function EditorPerformanceObserver(timeline, givenOptions) {
    var _this = this;
    _classCallCheck(this, EditorPerformanceObserver);
    _defineProperty(this, "startTime", null);
    _defineProperty(this, "isStarted", false);
    _defineProperty(this, "observedTargetRef", null);
    _defineProperty(this, "wrapperApplied", false);
    _defineProperty(this, "wrapperCleanupFunctions", []);
    this.options = Object.assign(defaultOptions, givenOptions || {});
    this.timeline = timeline;
    this.vcSections = new WeakSet();
    // TODO: ED-26959 - make sure to get it from config
    var selectorConfig = {
      id: false,
      testId: true,
      role: false,
      className: false,
      dataVC: true
    };
    this.userEventsObserver = new UserEventsObserver({
      onEventEntries: function onEventEntries(entries) {
        entries.forEach(function (event) {
          var elementName = 'not found';
          var element = event.elementRef.deref();
          if (element) {
            elementName = getElementName(selectorConfig, element);
          }
          var eventCategory = getEventCategory(event.eventName);
          timeline.markEvent({
            type: "user-event:".concat(eventCategory),
            startTime: event.startTime,
            data: {
              category: eventCategory,
              eventName: event.eventName,
              duration: event.duration,
              elementName: elementName
            }
          });
        });
      }
    });
    this.firstInteraction = new FirstInteractionObserver(this.onFirstInteraction.bind(this));
    this.domObservers = new DOMObservers({
      timeline: this.timeline,
      onChange: function onChange(_ref) {
        var _this$observedTargetR;
        var startTime = _ref.startTime,
          elementRef = _ref.elementRef,
          visible = _ref.visible,
          rect = _ref.rect,
          previousRect = _ref.previousRect,
          source = _ref.source;
        if (!visible) {
          // Ignored via go/ees007
          // eslint-disable-next-line @atlaskit/editor/enforce-todo-comment-format
          // TODO: when element is not visible we probably wants to add something
          return;
        }
        var element = elementRef.deref();
        if (!element) {
          return;
        }
        var elementName = getElementName(selectorConfig, element);
        var observedTarget = (_this$observedTargetR = _this.observedTargetRef) === null || _this$observedTargetR === void 0 ? void 0 : _this$observedTargetR.deref();
        var wrapperSection = searchAncestors(element, function (e) {
          var hasSection = _this.vcSections.has(e);
          if (hasSection) {
            return 'found';
          }
          var isRootElement = e.parentElement === observedTarget;
          if (isRootElement) {
            return 'abort';
          }
          return 'continue';
        });
        if (!wrapperSection && element) {
          _this.vcSections.add(element);
        }
        var wrapperSectionName = getElementName(selectorConfig, wrapperSection || element);
        _this.timeline.markEvent({
          type: 'element:changed',
          startTime: startTime,
          data: {
            wrapperSectionName: wrapperSectionName,
            elementName: elementName,
            rect: rect,
            previousRect: previousRect,
            source: source
          }
        });
      },
      onDOMContentChange: function onDOMContentChange(_ref2) {
        var _this$observedTargetR2;
        var targetRef = _ref2.targetRef;
        var mutationTarget = targetRef.deref();
        if (!mutationTarget) {
          return;
        }
        var observedTarget = (_this$observedTargetR2 = _this.observedTargetRef) === null || _this$observedTargetR2 === void 0 ? void 0 : _this$observedTargetR2.deref();
        var isRootChange = mutationTarget.parentElement === observedTarget;
        if (!isRootChange) {
          _this.vcSections.add(mutationTarget);
        }
      }
    });
    this.timeline.onceAllSubscribersCleaned(function () {
      _this.cleanupWrappers();
    });
  }
  return _createClass(EditorPerformanceObserver, [{
    key: "onFirstInteraction",
    value: function onFirstInteraction(_ref3) {
      var event = _ref3.event,
        time = _ref3.time;
      this.timeline.markEvent({
        type: 'abort:user-interaction',
        startTime: time,
        data: {
          source: event
        }
      });
      this.domObservers.disconnect();
    }
  }, {
    key: "start",
    value: function start(_ref4) {
      var startTime = _ref4.startTime;
      if (this.isStarted) {
        return;
      }
      var target = document.body;
      this.observedTargetRef = new WeakRef(target);
      this.startTime = startTime;
      this.domObservers.observe(target);
      this.isStarted = true;
    }
  }, {
    key: "onIdleBuffer",
    value: function onIdleBuffer(cb) {
      this.applyWrappersOnce();
      return this.timeline.onIdleBufferFlush(cb);
    }
  }, {
    key: "onceNextIdle",
    value: function onceNextIdle(cb) {
      this.applyWrappersOnce();
      return this.timeline.onNextIdle(cb);
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.isStarted) {
        return;
      }
      this.isStarted = false;
      this.domObservers.disconnect();
      this.firstInteraction.disconnect();
      this.userEventsObserver.disconnect();
      this.cleanupWrappers();
      this.timeline.cleanupSubscribers();
    }
  }, {
    key: "applyWrappersOnce",
    value: function applyWrappersOnce() {
      if (this.wrapperApplied) {
        return;
      }
      var timersCleanup = wrapperTimers({
        globalContext: globalThis || window,
        timelineHoldable: this.timeline,
        maxTimeoutAllowed: this.options.timers.setTimeout.maxTimeoutAllowedToTrack
      });
      var fetchCleanup = wrapperFetch({
        globalContext: globalThis || window,
        timelineHoldable: this.timeline
      });
      this.wrapperCleanupFunctions.push(timersCleanup, fetchCleanup);
      this.wrapperApplied = true;
    }
  }, {
    key: "cleanupWrappers",
    value: function cleanupWrappers() {
      this.wrapperCleanupFunctions.forEach(function (cleanup) {
        return cleanup();
      });
      this.wrapperCleanupFunctions = [];
      this.wrapperApplied = false;
    }
  }]);
}();