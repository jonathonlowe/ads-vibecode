"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimelineController = void 0;
exports.createTimelineFromEvents = createTimelineFromEvents;
exports.createTimelineFromIdleBuffer = createTimelineFromIdleBuffer;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _backgroundTasks = require("./backgroundTasks");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var defaultOptions = {
  cleanup: {
    eventsThreshold: 3000
  },
  buffer: {
    eventsThreshold: 200,
    cyclesThreshold: 5
  },
  maxHoldDuration: 5000 // five seconds
};

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any

function getRandomId() {
  if (!globalThis.crypto || typeof globalThis.crypto.randomUUID !== 'function') {
    // Not the best fallback, but the crypto.randomUUID is widely available
    return (Math.random() + 1).toString(36).substring(20);
  }
  return globalThis.crypto.randomUUID();
}

/**
 * ðŸ§± Internal Type: Editor FE Platform
 *
 * TimelineController
 *
 * The TimelineController class is a comprehensive system designed to track and
 * manage a series of events over time. It facilitates the recording, retrieval,
 * and cleanup of timeline events, and provides an interface for triggering
 * callbacks when idle buffer conditions are met.
 *
 * Key Functionalities:
 * - Event Management: Allows adding events, sorting them by timestamp, and retrieving them by type.
 * - Idle Detection: Automatically detects idle periods and triggers registered callbacks when conditions are met.
 * - Buffer Management: Maintains an internal buffer of events, with configurable thresholds to trigger callbacks
 *   based on buffer size or idle cycles.
 * - Serialization: Provides functionality to serialize the timeline state into a structured JSON format.
 * - Hold Mechanism: Allows pausing the idle detection for specific operations like setTimeout or fetch.
 *
 * @param {Partial<TimelineOptions>} [givenOptions] - An optional configuration object that allows customization of the timeline's behavior.
 *
 * @example
 * const timeline = new TimelineController({
 *   buffer: { eventsThreshold: 200, cyclesThreshold: 10 },
 *   maxHoldDuration: 5000
 * });
 *
 * // Adding an event
 * timeline.markEvent({
 *   type: 'element:changed',
 *   startTime: performance.now(),
 *   data: { wrapperSectionName: 'section', elementName: 'button', rect: new DOMRect(), source: 'mutation' },
 * });
 *
 * // Registering a buffer flush callback
 * timeline.onIdleBufferFlush(({ idleAt, timelineBuffer }) => {
 *   console.log(`Idle at: ${idleAt}`);
 *   console.log('Events since last idle:', timelineBuffer.getEvents());
 * });
 *
 * // Using the hold mechanism
 * const unhold = timeline.hold({ source: 'setTimeout' });
 * // ... perform some operation ...
 * unhold();
 *
 * // Serializing the timeline
 * const serializedTimeline = timeline.serialise();
 * console.log(serializedTimeline);
 */
var TimelineController = exports.TimelineController = /*#__PURE__*/function () {
  function TimelineController(givenOptions) {
    (0, _classCallCheck2.default)(this, TimelineController);
    (0, _defineProperty2.default)(this, "idleCycleCount", 0);
    (0, _defineProperty2.default)(this, "lastIdleTime", null);
    (0, _defineProperty2.default)(this, "lastIdleTask", null);
    (0, _defineProperty2.default)(this, "allSubscribersCleanedCallback", null);
    this.holdStartTimes = new Map();
    this.options = Object.assign(defaultOptions, givenOptions || {});
    this.unorderedEvents = [];
    this.idleCycleCount = 0;
    this.onIdleBufferFlushCallbacks = new Set();
    this.onNextIdleCallbacks = new Set();
    this.eventsPerType = new Map();
    this.idleBuffer = {
      unorderedEvents: [],
      eventsPerType: new Map()
    };
  }
  return (0, _createClass2.default)(TimelineController, [{
    key: "attemptCleanup",
    value: function attemptCleanup() {
      if (this.unorderedEvents.length <= this.options.cleanup.eventsThreshold) {
        return;
      }
      this.lastIdleTime = null;
      if (this.lastIdleTask) {
        this.lastIdleTask.abort();
      }
      this.lastIdleTask = null;
      var lastSize = this.unorderedEvents.length;
      this.eventsPerType.clear();
      this.unorderedEvents = [{
        type: 'timeline:clean-up',
        startTime: performance.now(),
        data: {
          previousAmountOfEvents: lastSize,
          source: 'manual'
        }
      }];
    }
  }, {
    key: "hold",
    value: function hold(_ref) {
      var _this = this;
      var source = _ref.source;
      var startTime = performance.now();
      var holdId = getRandomId();
      this.holdStartTimes.set(holdId, startTime);
      this.markEvent({
        startTime: startTime,
        type: 'hold-idle:start',
        data: {
          source: source,
          uuid: holdId
        }
      });
      return function () {
        _this.holdStartTimes.delete(holdId);
        var holdEndTime = performance.now();
        _this.markEvent({
          startTime: holdEndTime,
          type: 'hold-idle:end',
          data: {
            source: source,
            duration: holdEndTime - startTime,
            uuid: holdId
          }
        });
        if (_this.holdStartTimes.size === 0) {
          _this.scheduleNextIdle();
        }
      };
    }
  }, {
    key: "cleanupSubscribers",
    value: function cleanupSubscribers() {
      this.flushIdleBuffer(this.idleBuffer);
      this.onIdleBufferFlushCallbacks.clear();
      this.onNextIdleCallbacks.clear();
      this.checkAllSubscribersCleared();
    }
  }, {
    key: "addEventInternal",
    value: function addEventInternal(event) {
      this.unorderedEvents.push(event);
      this.updateEventsPerType(event);
      this.addToIdleBuffer(event);
    }
  }, {
    key: "updateEventsPerType",
    value: function updateEventsPerType(event) {
      var events = this.eventsPerType.get(event.type) || [];
      // @ts-expect-error
      events.push(event);
      this.eventsPerType.set(event.type, events);
    }
  }, {
    key: "addToIdleBuffer",
    value: function addToIdleBuffer(event) {
      this.idleBuffer.unorderedEvents.push(event);
      var events = this.idleBuffer.eventsPerType.get(event.type) || [];
      // @ts-expect-error
      events.push(event);
      this.idleBuffer.eventsPerType.set(event.type, events);
    }
  }, {
    key: "markEvent",
    value: function markEvent(event) {
      this.attemptCleanup();
      this.addEventInternal(event);
      this.scheduleNextIdle();
    }
  }, {
    key: "getEvents",
    value: function getEvents() {
      return this.unorderedEvents.sort(function (a, b) {
        if (a.startTime < b.startTime) {
          return -1;
        }
        if (a.startTime > b.startTime) {
          return 1;
        }
        return 0;
      });
    }
  }, {
    key: "getEventsPerType",
    value: function getEventsPerType(type) {
      var r = this.eventsPerType.get(type) || [];
      return r;
    }
  }, {
    key: "onIdleBufferFlush",
    value: function onIdleBufferFlush(cb) {
      var _this2 = this;
      this.onIdleBufferFlushCallbacks.add(cb);
      return function () {
        _this2.onIdleBufferFlushCallbacks.delete(cb);
        _this2.checkAllSubscribersCleared();
      };
    }
  }, {
    key: "onNextIdle",
    value: function onNextIdle(cb) {
      var _this3 = this;
      this.onNextIdleCallbacks.add(cb);
      return function () {
        _this3.onNextIdleCallbacks.delete(cb);
        _this3.checkAllSubscribersCleared();
      };
    }
  }, {
    key: "onceAllSubscribersCleaned",
    value: function onceAllSubscribersCleaned(callback) {
      this.allSubscribersCleanedCallback = callback;
    }
  }, {
    key: "checkAllSubscribersCleared",
    value: function checkAllSubscribersCleared() {
      if (this.onIdleBufferFlushCallbacks.size === 0 && this.onNextIdleCallbacks.size === 0 && this.allSubscribersCleanedCallback) {
        this.allSubscribersCleanedCallback();
      }
    }
  }, {
    key: "checkHoldTimeout",
    value: function checkHoldTimeout() {
      if (this.holdStartTimes.size === 0) {
        return;
      }
      var currentTime = performance.now();
      var iterator = this.holdStartTimes.entries();
      var _iterator$next$value = (0, _slicedToArray2.default)(iterator.next().value, 2),
        holdId = _iterator$next$value[0],
        holdStartTime = _iterator$next$value[1];
      while (typeof holdStartTime === 'number') {
        var lastHoldDelta = currentTime - holdStartTime;
        if (lastHoldDelta < this.options.maxHoldDuration) {
          return;
        }
        this.addEventInternal({
          type: 'hold-idle:timeout',
          startTime: currentTime,
          data: {
            holdedAt: holdStartTime,
            uuid: holdId
          }
        });
        this.holdStartTimes.delete(holdId);
        var _ref2 = iterator.next().value || [];
        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2);
        holdId = _ref3[0];
        holdStartTime = _ref3[1];
      }
    }
  }, {
    key: "scheduleNextIdle",
    value: function scheduleNextIdle() {
      this.checkHoldTimeout();
      if (this.holdStartTimes.size > 0) {
        return;
      }
      if (this.lastIdleTask) {
        this.lastIdleTask.abort();
      }
      var startAt = performance.now();
      var handleIdleBinded = this.handleIdle.bind(this, startAt);
      this.lastIdleTask = (0, _backgroundTasks.backgroundTask)(handleIdleBinded, {
        // For Timeline idles, we required at least 200ms of non-busy thread
        delay: 200
      });
    }
  }, {
    key: "handleIdle",
    value: function handleIdle(startAt) {
      if (this.holdStartTimes.size > 0) {
        return;
      }
      var idleTimeEvent = {
        type: 'idle-time',
        startTime: performance.now(),
        data: {
          duration: performance.now() - startAt
        }
      };
      this.addEventInternal(idleTimeEvent);
      this.idleCycleCount++;
      this.lastIdleTime = idleTimeEvent;
      var buffer = this.idleBuffer;
      this.attemptFlushIdleBuffer(buffer);
      this.callOnNextIdleCallbacks(buffer);
    }
  }, {
    key: "callOnNextIdleCallbacks",
    value: function callOnNextIdleCallbacks(buffer) {
      var idleAt = performance.now();
      var timelineBuffer = createTimelineFromIdleBuffer(buffer);
      var _iterator = _createForOfIteratorHelper(this.onNextIdleCallbacks),
        _step;
      try {
        var _loop = function _loop() {
          var cb = _step.value;
          (0, _backgroundTasks.backgroundTask)(function () {
            return cb({
              idleAt: idleAt,
              timelineBuffer: timelineBuffer
            });
          });
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this.onNextIdleCallbacks.clear();
    }
  }, {
    key: "attemptFlushIdleBuffer",
    value: function attemptFlushIdleBuffer(buffer) {
      if (!this.options.buffer) {
        this.flushIdleBuffer(buffer);
        return;
      }
      var _this$options$buffer = this.options.buffer,
        eventsThreshold = _this$options$buffer.eventsThreshold,
        cyclesThreshold = _this$options$buffer.cyclesThreshold;
      var hasCrossedEventBufferThreshold = this.idleBuffer.unorderedEvents.length > eventsThreshold;
      var hasCrossedCycleCountThreshold = this.idleCycleCount > cyclesThreshold;
      if (hasCrossedEventBufferThreshold || hasCrossedCycleCountThreshold) {
        this.flushIdleBuffer(buffer);
      }
    }
  }, {
    key: "flushIdleBuffer",
    value: function flushIdleBuffer(buffer) {
      this.clearIdleBuffer();
      var idleAt = performance.now();
      this.idleCycleCount = 0; // Reset cycle count

      var timelineBuffer = createTimelineFromIdleBuffer(buffer);
      var _iterator2 = _createForOfIteratorHelper(this.onIdleBufferFlushCallbacks),
        _step2;
      try {
        var _loop2 = function _loop2() {
          var cb = _step2.value;
          (0, _backgroundTasks.backgroundTask)(function () {
            return cb({
              idleAt: idleAt,
              timelineBuffer: timelineBuffer
            });
          });
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "clearIdleBuffer",
    value: function clearIdleBuffer() {
      this.idleBuffer = {
        unorderedEvents: [],
        eventsPerType: new Map()
      };
    }
  }, {
    key: "serialise",
    value: function serialise() {
      var result = [];
      var _iterator3 = _createForOfIteratorHelper(this.eventsPerType.entries()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = (0, _slicedToArray2.default)(_step3.value, 2),
            key = _step3$value[0],
            value = _step3$value[1];
          // TODO: ED-26959 - maybe implement a proper clone?
          var entry = [key, (0, _toConsumableArray2.default)(value)];

          // @ts-ignore
          result.push(entry);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return result;
    }
  }]);
}();
function createTimelineFromEvents(obj) {
  var eventsPerType = new Map(obj);
  var allEvents = Array.from(eventsPerType.values()).flat();
  return {
    getEvents: function getEvents() {
      return allEvents.sort(function (a, b) {
        if (a.startTime < b.startTime) {
          return -1;
        }
        if (a.startTime > b.startTime) {
          return 1;
        }
        return 0;
      });
    },
    getEventsPerType: function getEventsPerType(type) {
      var r = eventsPerType.get(type) || [];
      return r;
    }
  };
}
function createTimelineFromIdleBuffer(_ref4) {
  var unorderedEvents = _ref4.unorderedEvents,
    eventsPerType = _ref4.eventsPerType;
  var shallowUnorderedEventsCopy = (0, _toConsumableArray2.default)(unorderedEvents);
  var copyEventsPerType = new Map(eventsPerType);
  return {
    getEvents: function getEvents() {
      return shallowUnorderedEventsCopy.sort(function (a, b) {
        if (a.startTime < b.startTime) {
          return -1;
        }
        if (a.startTime > b.startTime) {
          return 1;
        }
        return 0;
      });
    },
    getEventsPerType: function getEventsPerType(type) {
      var r = copyEventsPerType.get(type) || [];
      return r;
    }
  };
}