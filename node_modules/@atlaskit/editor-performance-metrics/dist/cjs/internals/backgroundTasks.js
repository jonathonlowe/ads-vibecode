"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.taskYield = exports.isTaskAborted = exports.backgroundTask = exports.TaskAborted = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
/* eslint-disable compat/compat */

var TaskAborted = exports.TaskAborted = Symbol('BackgroundTaskAborted');

// See https://developer.mozilla.org/en-US/docs/Web/API/Scheduler/

var isTaskAborted = exports.isTaskAborted = function isTaskAborted(maybeTaskAbortedResult) {
  return maybeTaskAbortedResult === TaskAborted;
};

// See https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API
var taskYield = exports.taskYield = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var resolve, p, later;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!('scheduler' in globalThis &&
          // @ts-ignore
          'yield' in globalThis.scheduler)) {
            _context.next = 4;
            break;
          }
          _context.next = 3;
          return scheduler.yield();
        case 3:
          return _context.abrupt("return");
        case 4:
          resolve = function resolve() {};
          p = new Promise(function (a) {
            resolve = a;
          });
          if ('requestIdleCallback' in globalThis || 'requestAnimationFrame' in globalThis) {
            later = globalThis.requestIdleCallback || globalThis.requestAnimationFrame;
            later(function () {
              resolve();
            });
          } else {
            setTimeout(resolve, 0);
          }
          _context.next = 9;
          return p;
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function taskYield() {
    return _ref.apply(this, arguments);
  };
}();
var defaultOptions = {
  delay: 60
};
var backgroundTask = exports.backgroundTask = function backgroundTask(originalTask, givenOptions) {
  var options = Object.assign(defaultOptions, givenOptions || {});
  var taskRef = new WeakRef(originalTask);
  var resolvePromiseResultTask = function resolvePromiseResultTask(arg) {};
  var rejectPromiseResultTask = function rejectPromiseResultTask(e) {};
  var promiseResult = new Promise(function (resolve, reject) {
    resolvePromiseResultTask = resolve;
    rejectPromiseResultTask = reject;
  });
  var executeTask = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var ref, result;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            ref = taskRef.deref();
            if (ref) {
              _context2.next = 3;
              break;
            }
            return _context2.abrupt("return");
          case 3:
            _context2.prev = 3;
            _context2.next = 6;
            return ref(taskYield);
          case 6:
            result = _context2.sent;
            resolvePromiseResultTask(
            // @ts-expect-error
            result);
            _context2.next = 13;
            break;
          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](3);
            rejectPromiseResultTask(_context2.t0);
          case 13:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[3, 10]]);
    }));
    return function executeTask() {
      return _ref2.apply(this, arguments);
    };
  }();
  if ('scheduler' in window) {
    var controller = new AbortController();
    window.scheduler.postTask(executeTask, {
      priority: 'background',
      delay: options.delay,
      signal: controller.signal
    }).catch(function (e) {
      if (e !== 'stop-requested') {
        throw e;
      }
    });
    return {
      abort: function abort() {
        controller.abort('stop-requested');
        resolvePromiseResultTask(TaskAborted);
      },
      result: promiseResult
    };
  }
  if (window.requestIdleCallback) {
    var idleId = window.requestIdleCallback(executeTask, {
      timeout: 10000
    });
    return {
      abort: function abort() {
        cancelIdleCallback(idleId);
        resolvePromiseResultTask(TaskAborted);
      },
      result: promiseResult
    };
  }
  var rafId = window.requestAnimationFrame(executeTask);
  return {
    abort: function abort() {
      cancelAnimationFrame(rafId);
      resolvePromiseResultTask(TaskAborted);
    },
    result: promiseResult
  };
};