import { backgroundTask } from './backgroundTasks';
const ALLOWED_DURATION = 40;
export const processEntry = entry => {
  const {
    startTime,
    // @ts-expect-error
    processingEnd,
    // @ts-expect-error
    processingStart,
    // @ts-expect-error
    target,
    duration,
    name
  } = entry;
  if (typeof processingEnd !== 'number' || typeof processingStart !== 'number') {
    return null;
  }
  const timeToProcessEvent = processingEnd - processingStart;
  if (timeToProcessEvent <= 0) {
    return null;
  }
  if (!(target instanceof HTMLElement)) {
    return null;
  }
  const eventProcessingDuration = processingEnd - startTime;
  if (duration <= ALLOWED_DURATION || eventProcessingDuration <= ALLOWED_DURATION) {
    return null;
  }
  return {
    eventName: name,
    startTime: startTime,
    duration,
    elementRef: new WeakRef(target)
  };
};
export const createPerformanceObserver = cb => {
  return new PerformanceObserver(cb);
};
export class UserEventsObserver {
  constructor({
    onEventEntries
  }) {
    if (typeof globalThis.PerformanceObserver !== 'function') {
      return;
    }
    this.observer = createPerformanceObserver(list => {
      backgroundTask(() => {
        const mappedEvents = list.getEntries().reduce((acc, value) => {
          const transformed = processEntry(value);
          if (transformed) {
            acc.push(transformed);
          }
          return acc;
        }, []);
        onEventEntries(mappedEvents);
      });
    });
    this.observer.observe({
      type: 'event',
      buffered: true,
      // @ts-expect-error
      durationThreshold: 16
    });
  }
  disconnect() {
    var _this$observer;
    (_this$observer = this.observer) === null || _this$observer === void 0 ? void 0 : _this$observer.disconnect();
  }
}