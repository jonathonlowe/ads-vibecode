/* eslint-disable compat/compat */

export const TaskAborted = Symbol('BackgroundTaskAborted');

// See https://developer.mozilla.org/en-US/docs/Web/API/Scheduler/

export const isTaskAborted = maybeTaskAbortedResult => {
  return maybeTaskAbortedResult === TaskAborted;
};

// See https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API
export const taskYield = async () => {
  // This is using globalThis to allow the yield task to be used outside of a browser env
  if ('scheduler' in globalThis &&
  // @ts-ignore
  'yield' in globalThis.scheduler) {
    // @ts-ignore
    await scheduler.yield();
    return;
  }
  let resolve = () => {};
  const p = new Promise(a => {
    resolve = a;
  });
  if ('requestIdleCallback' in globalThis || 'requestAnimationFrame' in globalThis) {
    const later = globalThis.requestIdleCallback || globalThis.requestAnimationFrame;
    later(() => {
      resolve();
    });
  } else {
    setTimeout(resolve, 0);
  }
  await p;
};
const defaultOptions = {
  delay: 60
};
export const backgroundTask = (originalTask, givenOptions) => {
  const options = Object.assign(defaultOptions, givenOptions || {});
  const taskRef = new WeakRef(originalTask);
  let resolvePromiseResultTask = arg => {};
  let rejectPromiseResultTask = e => {};
  const promiseResult = new Promise((resolve, reject) => {
    resolvePromiseResultTask = resolve;
    rejectPromiseResultTask = reject;
  });
  const executeTask = async () => {
    const ref = taskRef.deref();
    if (!ref) {
      return;
    }
    try {
      const result = await ref(taskYield);
      resolvePromiseResultTask(
      // @ts-expect-error
      result);
    } catch (e) {
      rejectPromiseResultTask(e);
    }
  };
  if ('scheduler' in window) {
    const controller = new AbortController();
    window.scheduler.postTask(executeTask, {
      priority: 'background',
      delay: options.delay,
      signal: controller.signal
    }).catch(e => {
      if (e !== 'stop-requested') {
        throw e;
      }
    });
    return {
      abort: () => {
        controller.abort('stop-requested');
        resolvePromiseResultTask(TaskAborted);
      },
      result: promiseResult
    };
  }
  if (window.requestIdleCallback) {
    const idleId = window.requestIdleCallback(executeTask, {
      timeout: 10000
    });
    return {
      abort: () => {
        cancelIdleCallback(idleId);
        resolvePromiseResultTask(TaskAborted);
      },
      result: promiseResult
    };
  }
  const rafId = window.requestAnimationFrame(executeTask);
  return {
    abort: () => {
      cancelAnimationFrame(rafId);
      resolvePromiseResultTask(TaskAborted);
    },
    result: promiseResult
  };
};