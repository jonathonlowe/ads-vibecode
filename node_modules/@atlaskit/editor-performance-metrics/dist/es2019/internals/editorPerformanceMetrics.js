import { backgroundTask, isTaskAborted } from './backgroundTasks';
import { getViewportDimensions } from './dom';
import { createHeatmapFromEvents, createHeatmapFromTimeline, createHeatmapWithAspectRatio } from './heatmap';
import { getLatencyPercentiles, getVCPercentFromHeatmap, getVCPercentileTargets } from './measurements';
const latencyCategories = ['mouse-movement', 'mouse-action', 'keyboard', 'form', 'clipboard', 'drag-and-drop', 'page-resize', 'scroll', 'touch', 'other'];
export class EditorPerformanceMetrics {
  constructor(timeline, viewport = getViewportDimensions()) {
    this.timeline = timeline;
    this.viewport = viewport;
  }
  async calculateLatencyPercents() {
    const promises = latencyCategories.map(category => {
      const events = this.timeline.getEventsPerType(`user-event:${category}`);
      const task = backgroundTask(async taskYield => {
        await taskYield();
        const percentiles = getLatencyPercentiles(events);
        if (!percentiles) {
          return null;
        }
        return {
          [category]: percentiles
        };
      });
      return task.result;
    });
    const allPercentilesProcessed = await Promise.all(promises);
    let isEmpty = true;
    let result = {};
    for (const maybePercentils of allPercentilesProcessed) {
      if (isTaskAborted(maybePercentils) || !maybePercentils) {
        continue;
      }
      result = Object.assign(result, maybePercentils);
      isEmpty = false;
    }
    if (isEmpty) {
      return null;
    }
    return result;
  }
  async calculateLastHeatmap(heatmapSize, rangeEventsFilter) {
    if (!this.viewport) {
      return null;
    }
    const baseheatmap = createHeatmapWithAspectRatio({
      viewport: this.viewport,
      heatmapSize
    });
    if (!rangeEventsFilter) {
      return createHeatmapFromTimeline(this.timeline, baseheatmap);
    }
    const timelineEvents = this.timeline.getEvents();
    const startIndex = timelineEvents.findIndex(event => {
      if (typeof rangeEventsFilter.from === 'number') {
        return event.startTime >= rangeEventsFilter.from;
      }
      return event.type === rangeEventsFilter.from;
    });
    if (startIndex < 0) {
      return null;
    }
    const endIndex = timelineEvents.slice(startIndex).findIndex(event => {
      if (typeof rangeEventsFilter.to === 'number') {
        return event.startTime <= rangeEventsFilter.to;
      }
      return event.type === rangeEventsFilter.to;
    });
    const filteredEventsShallowCopy = endIndex < 0 ? timelineEvents.slice(startIndex) : timelineEvents.slice(startIndex, startIndex + endIndex + 1);
    const filteredEvents = Array.from(filteredEventsShallowCopy);
    const heatmap = await createHeatmapFromEvents(filteredEvents, baseheatmap);
    return heatmap;
  }
  async calculateVCPercents(options) {
    const heatmap = await this.calculateLastHeatmap(options.heatmapSize, options.rangeEventsFilter);
    if (!heatmap) {
      return null;
    }
    const VCPercents = getVCPercentFromHeatmap(heatmap, options);
    return VCPercents;
  }
  async calculateVCTargets(options) {
    const defaultOptions = {
      ignoreNodeReplacements: false,
      ignoreLayoutShifts: false,
      ignoreElementMoved: false,
      heatmapSize: 200,
      rangeEventsFilter: null
    };
    const mergedOptions = Object.assign(defaultOptions, options || {});
    const VCPercents = await this.calculateVCPercents(mergedOptions);
    if (!VCPercents) {
      return null;
    }
    const VCTargets = getVCPercentileTargets(VCPercents);
    return VCTargets;
  }
}
export function createCalculator(timeline, viewport) {
  return new EditorPerformanceMetrics(timeline, viewport);
}