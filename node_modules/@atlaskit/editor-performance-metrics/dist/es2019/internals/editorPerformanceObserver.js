import _defineProperty from "@babel/runtime/helpers/defineProperty";
/* eslint-disable compat/compat */
import { getEventCategory, searchAncestors } from './dom';
import { DOMObservers } from './DOMObservers';
import { FirstInteractionObserver } from './firstInteractionObserver';
import { getElementName } from './getElementName';
import { UserEventsObserver } from './userEventsObserver';
import { wrapperFetch } from './wrapperFetch';
import { wrapperTimers } from './wrapperTimers';
const defaultOptions = {
  timers: {
    setTimeout: {
      maxTimeoutAllowedToTrack: 2000 // two seconds
    }
  }
};
export class EditorPerformanceObserver {
  constructor(timeline, givenOptions) {
    _defineProperty(this, "startTime", null);
    _defineProperty(this, "isStarted", false);
    _defineProperty(this, "observedTargetRef", null);
    _defineProperty(this, "wrapperApplied", false);
    _defineProperty(this, "wrapperCleanupFunctions", []);
    this.options = Object.assign(defaultOptions, givenOptions || {});
    this.timeline = timeline;
    this.vcSections = new WeakSet();
    // TODO: ED-26959 - make sure to get it from config
    const selectorConfig = {
      id: false,
      testId: true,
      role: false,
      className: false,
      dataVC: true
    };
    this.userEventsObserver = new UserEventsObserver({
      onEventEntries: entries => {
        entries.forEach(event => {
          let elementName = 'not found';
          const element = event.elementRef.deref();
          if (element) {
            elementName = getElementName(selectorConfig, element);
          }
          const eventCategory = getEventCategory(event.eventName);
          timeline.markEvent({
            type: `user-event:${eventCategory}`,
            startTime: event.startTime,
            data: {
              category: eventCategory,
              eventName: event.eventName,
              duration: event.duration,
              elementName
            }
          });
        });
      }
    });
    this.firstInteraction = new FirstInteractionObserver(this.onFirstInteraction.bind(this));
    this.domObservers = new DOMObservers({
      timeline: this.timeline,
      onChange: ({
        startTime,
        elementRef,
        visible,
        rect,
        previousRect,
        source
      }) => {
        var _this$observedTargetR;
        if (!visible) {
          // Ignored via go/ees007
          // eslint-disable-next-line @atlaskit/editor/enforce-todo-comment-format
          // TODO: when element is not visible we probably wants to add something
          return;
        }
        const element = elementRef.deref();
        if (!element) {
          return;
        }
        const elementName = getElementName(selectorConfig, element);
        const observedTarget = (_this$observedTargetR = this.observedTargetRef) === null || _this$observedTargetR === void 0 ? void 0 : _this$observedTargetR.deref();
        const wrapperSection = searchAncestors(element, e => {
          const hasSection = this.vcSections.has(e);
          if (hasSection) {
            return 'found';
          }
          const isRootElement = e.parentElement === observedTarget;
          if (isRootElement) {
            return 'abort';
          }
          return 'continue';
        });
        if (!wrapperSection && element) {
          this.vcSections.add(element);
        }
        const wrapperSectionName = getElementName(selectorConfig, wrapperSection || element);
        this.timeline.markEvent({
          type: 'element:changed',
          startTime,
          data: {
            wrapperSectionName,
            elementName,
            rect,
            previousRect,
            source
          }
        });
      },
      onDOMContentChange: ({
        targetRef
      }) => {
        var _this$observedTargetR2;
        const mutationTarget = targetRef.deref();
        if (!mutationTarget) {
          return;
        }
        const observedTarget = (_this$observedTargetR2 = this.observedTargetRef) === null || _this$observedTargetR2 === void 0 ? void 0 : _this$observedTargetR2.deref();
        const isRootChange = mutationTarget.parentElement === observedTarget;
        if (!isRootChange) {
          this.vcSections.add(mutationTarget);
        }
      }
    });
    this.timeline.onceAllSubscribersCleaned(() => {
      this.cleanupWrappers();
    });
  }
  onFirstInteraction({
    event,
    time
  }) {
    this.timeline.markEvent({
      type: 'abort:user-interaction',
      startTime: time,
      data: {
        source: event
      }
    });
    this.domObservers.disconnect();
  }
  start({
    startTime
  }) {
    if (this.isStarted) {
      return;
    }
    const target = document.body;
    this.observedTargetRef = new WeakRef(target);
    this.startTime = startTime;
    this.domObservers.observe(target);
    this.isStarted = true;
  }
  onIdleBuffer(cb) {
    this.applyWrappersOnce();
    return this.timeline.onIdleBufferFlush(cb);
  }
  onceNextIdle(cb) {
    this.applyWrappersOnce();
    return this.timeline.onNextIdle(cb);
  }
  stop() {
    if (!this.isStarted) {
      return;
    }
    this.isStarted = false;
    this.domObservers.disconnect();
    this.firstInteraction.disconnect();
    this.userEventsObserver.disconnect();
    this.cleanupWrappers();
    this.timeline.cleanupSubscribers();
  }
  applyWrappersOnce() {
    if (this.wrapperApplied) {
      return;
    }
    const timersCleanup = wrapperTimers({
      globalContext: globalThis || window,
      timelineHoldable: this.timeline,
      maxTimeoutAllowed: this.options.timers.setTimeout.maxTimeoutAllowedToTrack
    });
    const fetchCleanup = wrapperFetch({
      globalContext: globalThis || window,
      timelineHoldable: this.timeline
    });
    this.wrapperCleanupFunctions.push(timersCleanup, fetchCleanup);
    this.wrapperApplied = true;
  }
  cleanupWrappers() {
    this.wrapperCleanupFunctions.forEach(cleanup => cleanup());
    this.wrapperCleanupFunctions = [];
    this.wrapperApplied = false;
  }
}