import { createIntersectionObserver, createMutationObserver, createPerformanceObserver } from './createBrowserObservers';
function isElementVisible(element) {
  if (!(element instanceof HTMLElement)) {
    return true;
  }
  try {
    const visible = element.checkVisibility({
      // @ts-expect-error
      visibilityProperty: true
    });
    return visible;
  } catch (e) {
    // there is no support for checkVisibility
    return true;
  }
}
function sameRectSize(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.width === b.width && a.height === b.height;
}
function sameRectDimensions(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.width === b.width && a.height === b.height && a.x === b.x && a.y === b.y;
}
export class DOMObservers {
  constructor({
    onDOMContentChange,
    onChange,
    timeline
  }) {
    this.mapVisibleNodeRects = new WeakMap();
    this.timeline = timeline;
    this.intersection = createIntersectionObserver({
      onEntry: ({
        target,
        rect,
        startTime,
        taintedTag
      }) => {
        const visible = isElementVisible(target);
        const lastElementRect = this.mapVisibleNodeRects.get(target);
        this.mapVisibleNodeRects.set(target, rect);
        const source = taintedTag;
        onChange({
          startTime,
          elementRef: new WeakRef(target),
          visible,
          rect,
          previousRect: lastElementRect,
          source
        });
      },
      onObserved: ({
        elements,
        startTime
      }) => {
        this.timeline.markEvent({
          type: 'IntersectionObserver:VisibleNodes',
          startTime,
          data: {
            visibleElements: elements.length
          }
        });
      }
    });
    this.mutations = createMutationObserver({
      onAttributeMutation: ({
        target
      }) => {
        var _this$intersection;
        (_this$intersection = this.intersection) === null || _this$intersection === void 0 ? void 0 : _this$intersection.watchAndTag(target, ({
          target,
          rect
        }) => {
          const lastElementRect = this.mapVisibleNodeRects.get(target);
          if (lastElementRect && sameRectSize(rect, lastElementRect)) {
            return 'mutation:attribute:no-layout-shift';
          }
          return 'mutation:attribute';
        });
      },
      onMutationFinished: ({
        targets
      }) => {
        targets.forEach(target => {
          onDOMContentChange({
            targetRef: new WeakRef(target)
          });
        });
      },
      onChildListMutation: ({
        addedNodes,
        removedNodes
      }) => {
        const removedNodeRects = removedNodes.map(n => this.mapVisibleNodeRects.get(n));
        addedNodes.forEach(addedNode => {
          var _this$intersection4;
          for (const elem of addedNode.querySelectorAll('*')) {
            var _this$intersection2;
            (_this$intersection2 = this.intersection) === null || _this$intersection2 === void 0 ? void 0 : _this$intersection2.watchAndTag(elem, 'mutation:children-element');
          }
          const sameDeletedNode = removedNodes.find(n => n.isEqualNode(addedNode));
          if (sameDeletedNode) {
            var _this$intersection3;
            (_this$intersection3 = this.intersection) === null || _this$intersection3 === void 0 ? void 0 : _this$intersection3.watchAndTag(addedNode, 'mutation:re-mounted');
            return;
          }
          (_this$intersection4 = this.intersection) === null || _this$intersection4 === void 0 ? void 0 : _this$intersection4.watchAndTag(addedNode, ({
            target,
            rect
          }) => {
            const wasDeleted = removedNodeRects.some(nr => sameRectDimensions(nr, rect));
            if (wasDeleted) {
              return 'mutation:node-replacement';
            }
            return 'mutation:root-element';
          });
        });
        this.timeline.markEvent({
          type: 'DOMMutation:finished',
          startTime: performance.now(),
          data: {
            addedNodes: addedNodes.length,
            removedNodes: removedNodes.length
          }
        });
      }
    });
    this.performance = createPerformanceObserver({
      onFirstPaint: startTime => {
        this.timeline.markEvent({
          type: 'performance:first-paint',
          startTime,
          data: {}
        });
      },
      onFirstContentfulPaint: startTime => {
        this.timeline.markEvent({
          type: 'performance:first-contentful-paint',
          startTime,
          data: {}
        });
      },
      onLongTask: ({
        startTime,
        duration
      }) => {
        this.timeline.markEvent({
          type: 'performance:long-task',
          startTime,
          data: {
            duration
          }
        });
      },
      onLayoutShift: ({
        startTime,
        changedRects
      }) => {
        this.timeline.markEvent({
          type: 'performance:layout-shift',
          startTime,
          data: {
            changedRectsAmount: changedRects.length
          }
        });
        changedRects.forEach(({
          node,
          rect
        }) => {
          if (node instanceof HTMLElement) {
            var _this$intersection5;
            (_this$intersection5 = this.intersection) === null || _this$intersection5 === void 0 ? void 0 : _this$intersection5.watchAndTag(node, ({
              target,
              rect
            }) => {
              const lastElementRect = this.mapVisibleNodeRects.get(target);
              if (lastElementRect && sameRectSize(rect, lastElementRect)) {
                return 'layout-shift:element-moved';
              }
              return 'layout-shift';
            });
          }
        });
      }
    });
  }
  observe(target) {
    var _this$mutations, _this$performance, _this$performance2, _this$performance3, _this$performance4;
    (_this$mutations = this.mutations) === null || _this$mutations === void 0 ? void 0 : _this$mutations.observe(target, {
      attributeOldValue: true,
      attributes: true,
      childList: true,
      subtree: true
    });
    (_this$performance = this.performance) === null || _this$performance === void 0 ? void 0 : _this$performance.observe({
      type: 'paint',
      buffered: true
    });
    (_this$performance2 = this.performance) === null || _this$performance2 === void 0 ? void 0 : _this$performance2.observe({
      type: 'largest-contentful-paint',
      buffered: true
    });
    (_this$performance3 = this.performance) === null || _this$performance3 === void 0 ? void 0 : _this$performance3.observe({
      type: 'layout-shift',
      buffered: true,
      // @ts-ignore-error
      durationThreshold: 30
    });
    (_this$performance4 = this.performance) === null || _this$performance4 === void 0 ? void 0 : _this$performance4.observe({
      type: 'longtask',
      buffered: true
    });
  }
  disconnect() {
    var _this$mutations2, _this$performance5, _this$intersection6;
    (_this$mutations2 = this.mutations) === null || _this$mutations2 === void 0 ? void 0 : _this$mutations2.disconnect();
    (_this$performance5 = this.performance) === null || _this$performance5 === void 0 ? void 0 : _this$performance5.disconnect();
    (_this$intersection6 = this.intersection) === null || _this$intersection6 === void 0 ? void 0 : _this$intersection6.disconnect();
  }
}