import type { Timeline } from './timelineInterfaces';
import type { TimelineEvent } from './timelineTypes';
import type { HeatmapEntrySource } from './types';
export type HeatmapEntryData = {
    time: DOMHighResTimeStamp;
    elementName: string | null;
    wrapperSectionName: string | null;
    rect: HeatmapRect | null;
    source: HeatmapEntrySource | null;
    ratio: number | null;
};
export type HeatmapEntry = {
    head: HeatmapEntryData | null;
    previousEntries: Array<HeatmapEntryData>;
};
export declare function createEmptyHeatmapEntry(): HeatmapEntry;
export type Heatmap = {
    map: Array<Array<HeatmapEntry>>;
    height: number;
    width: number;
    scaleX: number;
    scaleY: number;
};
/**
 * Represents a rectangular area in the heatmap.
 */
export type HeatmapRect = {
    left: number;
    top: number;
    right: number;
    bottom: number;
};
export declare function cloneEntry(entry: HeatmapEntry): HeatmapEntry;
/**
 * Clones a 2D array of numbers.
 *
 * This function creates a deep copy of the provided 2D array, which is faster than using `structuredClone`.
 *
 * @param {ReadonlyArray<ReadonlyArray<HeatmapEntry>>} arr - The 2D array to clone.
 * @returns {Array<Array<number>>} A deep copy of the original 2D array.
 */
export declare function cloneArray(arr: ReadonlyArray<ReadonlyArray<HeatmapEntry>>): Array<Array<HeatmapEntry>>;
export declare function isRectInside(a: HeatmapRect | null | undefined, b: HeatmapRect | null | undefined): boolean;
/**
 * Parameters required for transforming a heatmap.
 */
type TransformHeatmapProps = {
    rect: HeatmapRect;
    entry: Omit<HeatmapEntryData, 'source'>;
    transformSource: HeatmapEntrySource | null;
    heatmap: Heatmap;
    onEmptyRow: (props: {
        entry: Omit<HeatmapEntryData, 'source'>;
        row: number;
    }) => void;
};
/**
 * Transforms the heatmap by updating the rectangles with the current start time.
 *
 * Iterates over the specified rectangle area within the heatmap and updates each cell with the provided start time.
 * If a row is undefined, the provided callback is invoked.
 *
 * Attention! This function does mutate the heatmap
 *
 * @param {TransformHeatmapProps} props - The properties for transforming the heatmap.
 * @returns {Heatmap | undefined} The updated heatmap or undefined if a row is not found.
 */
export declare function transformHeatmap({ rect, heatmap, transformSource, onEmptyRow, entry, }: TransformHeatmapProps): void;
/**
 * Maps a DOMRect to a heatmap's coordinate system.
 *
 * Converts the dimensions of a DOMRect to the heatmap's coordinate system using the heatmap's scaling factors.
 *
 * @param {object} props - The properties required for mapping.
 * @param {DOMRect} props.rect - The DOMRect to map.
 * @param {Heatmap} props.heatmap - The heatmap with scaling information.
 * @returns {HeatmapRect} The mapped heatmap rectangle.
 */
export declare function mapDOMRectToHeatmap(props: {
    rect: DOMRect;
    heatmap: Heatmap;
}): HeatmapRect;
/**
 * Calculates the ratio of a heatmap rectangle compared to the full heatmap.
 *
 * This function determines what fraction of the heatmap is covered by the given heatmap rectangle.
 *
 * @param {object} props - The properties required for ratio calculation.
 * @param {HeatmapRect} props.heatmapRect - The heatmap rectangle.
 * @param {Heatmap} props.heatmap - The full heatmap dimensions.
 * @returns {number} The ratio of the rectangle area to the heatmap area.
 */
export declare function getElementRatio(props: {
    rect: HeatmapRect;
    viewport: ViewportDimension;
}): number;
export type ViewportDimension = {
    w: number;
    h: number;
};
/**
 * Initializes a square heatmap with all values set to zero.
 *
 * Creates a 2D array with the specified size, where each value is initialized to zero.
 *
 * @param {number} heatmapSize - The size of the heatmap (both width and height).
 * @returns {HeatmapEntry[][]} A 2D array representing the heatmap, filled with empty HeatmapEntry.
 */
export declare function cleanSquareHeatmap(heatmapSize: number): HeatmapEntry[][];
/**
 * Creates a new heatmap array based on the aspect ratio of the viewport.
 *
 * This function adjusts the heatmap dimensions to match the aspect ratio of the viewport,
 * ensuring that the heatmap scales proportionally to the viewport size. The maximum allowable
 * heatmap size is capped at 1000 to prevent excessive memory usage.
 *
 * @param {ViewportDimension} viewport - The dimensions of the viewport.
 * @param {number} heatmapSize - The base size of the heatmap, capped at a maximum of 1000.
 * @returns {Heatmap} A new heatmap object with calculated dimensions and scaling factors.
 */
export declare function createHeatmapWithAspectRatio({ viewport, heatmapSize, }: {
    viewport: ViewportDimension;
    heatmapSize: number;
}): Heatmap;
export declare function createHeatmapFromEvents(events: ReadonlyArray<TimelineEvent>, initialHeatmap: Heatmap): Promise<Heatmap>;
export declare function createHeatmapFromTimeline(timeline: Timeline, initialHeatmap: Heatmap): Promise<Heatmap>;
export declare function isLayoutShift(entry: HeatmapEntryData | null | undefined): boolean;
export declare function isNodeReplacement(entry: HeatmapEntryData | null | undefined): boolean;
export declare function isElementMoved(entry: HeatmapEntryData | null | undefined): boolean;
export {};
