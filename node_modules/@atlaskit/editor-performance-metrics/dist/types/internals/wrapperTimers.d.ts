import type { TimelineHoldable } from './timelineInterfaces';
/**
 * 🧱 Internal Type: Editor FE Platform
 *
 * Wraps the global setTimeout and clearTimeout functions to integrate with a TimelineHoldable instance.
 * This wrapper allows tracking of timer operations within the timeline, providing insights into
 * asynchronous operations that might affect the application's idle state.
 *
 * Key Features:
 * - Integrates setTimeout calls with the TimelineHoldable's hold mechanism.
 * - Automatically releases holds when the timer callback is executed or cleared.
 * - Preserves the original behavior of setTimeout and clearTimeout for non-tracked cases.
 *
 * ⚠️ Important Notes:
 * - To prevent excessive holds and potential performance issues, this wrapper only monitors
 *   timeouts with delays up to 2000ms (2 seconds). Timeouts with larger delays are not wrapped. The `maxTimeoutAllowed` allows you to override the default timeout.
 * - Zero-delay timeouts (used for deferring to the next event loop) are also not wrapped.
 *
 * @param {Object} options - Configuration options for the wrapper.
 * @param {Object} options.globalContext - The global context containing setTimeout and clearTimeout functions.
 *                                         This is typically the global `window` object in browser environments.
 * @param {Object} options.maxTimeoutAllowed - Override the default timeout delay allowed (useful for testing enviroments);
 * @param {typeof setTimeout} options.globalContext.setTimeout - The original setTimeout function to be wrapped.
 * @param {typeof clearTimeout} options.globalContext.clearTimeout - The original clearTimeout function to be wrapped.
 * @param {TimelineHoldable} options.timelineHoldable - An instance implementing the TimelineHoldable interface.
 *                                                      This is used to create and release holds for each tracked timeout.
 *
 * @returns {Function} A cleanup function that, when called, restores the original setTimeout and clearTimeout
 *                     implementations. This should be called when the wrapper is no longer needed to prevent
 *                     memory leaks and ensure proper functionality of the global timer functions.
 *
 * @example
 * const cleanup = wrapperTimers({
 *   globalContext: window,
 *   timelineHoldable: myTimelineInstance
 * });
 *
 * // Later, when the wrapper is no longer needed:
 * cleanup();
 */
export declare const wrapperTimers: ({ globalContext, timelineHoldable, maxTimeoutAllowed, maxNestedTimers, }: {
    globalContext: unknown & {
        setTimeout: typeof setTimeout;
        clearTimeout: typeof clearTimeout;
    };
    timelineHoldable: TimelineHoldable;
    maxTimeoutAllowed?: number | undefined;
    maxNestedTimers?: number | undefined;
}) => () => void;
