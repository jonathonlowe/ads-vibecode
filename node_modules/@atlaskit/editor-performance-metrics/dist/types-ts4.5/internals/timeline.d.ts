import { type AbortableTask } from './backgroundTasks';
import type { Cleanable, Timeline, TimelineClock, TimelineHoldable, TimelineIdleUnsubcribe, TimelineSerializable, UnHoldFunction, OnIdleBufferFlushCallback } from './timelineInterfaces';
import type { BasicEventTimestamp, EventsGroupedSerialized, ExtractEventTypes, HoldIdleEventSources, IdleTimeEvent, TimelineEvent, TimelineEventNames, TimelineEventsGrouped, TimelineOptions } from './timelineTypes';
export type EventsPerTypeMap = Map<TimelineEventNames, {
    [K in TimelineEventNames]: Array<ExtractEventTypes<TimelineEvent, K>>;
}[TimelineEventNames]>;
export type UnorderedEvents = Array<Readonly<BasicEventTimestamp<any, any>>>;
export type TimelineIdleBuffer = {
    eventsPerType: EventsPerTypeMap;
    unorderedEvents: UnorderedEvents;
};
/**
 * ðŸ§± Internal Type: Editor FE Platform
 *
 * TimelineController
 *
 * The TimelineController class is a comprehensive system designed to track and
 * manage a series of events over time. It facilitates the recording, retrieval,
 * and cleanup of timeline events, and provides an interface for triggering
 * callbacks when idle buffer conditions are met.
 *
 * Key Functionalities:
 * - Event Management: Allows adding events, sorting them by timestamp, and retrieving them by type.
 * - Idle Detection: Automatically detects idle periods and triggers registered callbacks when conditions are met.
 * - Buffer Management: Maintains an internal buffer of events, with configurable thresholds to trigger callbacks
 *   based on buffer size or idle cycles.
 * - Serialization: Provides functionality to serialize the timeline state into a structured JSON format.
 * - Hold Mechanism: Allows pausing the idle detection for specific operations like setTimeout or fetch.
 *
 * @param {Partial<TimelineOptions>} [givenOptions] - An optional configuration object that allows customization of the timeline's behavior.
 *
 * @example
 * const timeline = new TimelineController({
 *   buffer: { eventsThreshold: 200, cyclesThreshold: 10 },
 *   maxHoldDuration: 5000
 * });
 *
 * // Adding an event
 * timeline.markEvent({
 *   type: 'element:changed',
 *   startTime: performance.now(),
 *   data: { wrapperSectionName: 'section', elementName: 'button', rect: new DOMRect(), source: 'mutation' },
 * });
 *
 * // Registering a buffer flush callback
 * timeline.onIdleBufferFlush(({ idleAt, timelineBuffer }) => {
 *   console.log(`Idle at: ${idleAt}`);
 *   console.log('Events since last idle:', timelineBuffer.getEvents());
 * });
 *
 * // Using the hold mechanism
 * const unhold = timeline.hold({ source: 'setTimeout' });
 * // ... perform some operation ...
 * unhold();
 *
 * // Serializing the timeline
 * const serializedTimeline = timeline.serialise();
 * console.log(serializedTimeline);
 */
export declare class TimelineController implements Timeline, TimelineSerializable, TimelineClock, Cleanable, TimelineHoldable {
    unorderedEvents: UnorderedEvents;
    eventsPerType: EventsPerTypeMap;
    onIdleBufferFlushCallbacks: Set<OnIdleBufferFlushCallback>;
    onNextIdleCallbacks: Set<OnIdleBufferFlushCallback>;
    idleCycleCount: number;
    lastIdleTime: IdleTimeEvent | null;
    lastIdleTask: AbortableTask<void> | null;
    options: TimelineOptions;
    idleBuffer: TimelineIdleBuffer;
    private allSubscribersCleanedCallback;
    private holdStartTimes;
    constructor(givenOptions?: Partial<TimelineOptions>);
    attemptCleanup(): void;
    hold({ source }: {
        source: HoldIdleEventSources;
    }): UnHoldFunction;
    cleanupSubscribers(): void;
    private addEventInternal;
    private updateEventsPerType;
    private addToIdleBuffer;
    markEvent(event: TimelineEvent): void;
    getEvents(): ReadonlyArray<TimelineEvent>;
    getEventsPerType<T extends TimelineEventNames>(type: T): TimelineEventsGrouped[T];
    onIdleBufferFlush(cb: OnIdleBufferFlushCallback): TimelineIdleUnsubcribe;
    onNextIdle(cb: OnIdleBufferFlushCallback): TimelineIdleUnsubcribe;
    onceAllSubscribersCleaned(callback: () => void): void;
    private checkAllSubscribersCleared;
    private checkHoldTimeout;
    private scheduleNextIdle;
    private handleIdle;
    private callOnNextIdleCallbacks;
    private attemptFlushIdleBuffer;
    private flushIdleBuffer;
    private clearIdleBuffer;
    serialise(): EventsGroupedSerialized;
}
export declare function createTimelineFromEvents(obj: EventsGroupedSerialized): Timeline;
export declare function createTimelineFromIdleBuffer({ unorderedEvents, eventsPerType, }: TimelineIdleBuffer): Timeline;
