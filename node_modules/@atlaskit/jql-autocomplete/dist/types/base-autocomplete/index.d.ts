import { BufferedTokenStream, Parser, Token } from 'antlr4ts';
import { Position } from '../common/types';
import { RuleSuggestionsWithRuleList, Suggestions } from './types';
/**
 * Antlr-based, grammar agnostic, autocomplete class. Consumers can provide options to adjust the
 * suggestions returned by the autocompletion engine, or extend the class to enrich suggestions with
 * additional contextual data.
 */
export declare class BaseAutocomplete<RuleContext extends {} = {}> {
    private readonly parser;
    private readonly core;
    /**
     * A delimiter token instructs us that we want to get suggestions for the **next** token in the
     * stream. This is useful when you know there are no more characters that will follow a token. For
     * instance, with the following expression `order by field,` the comma is our `caretToken`. If we
     * specify comma as a delimiter token then we will get suggestions for tokens **after** the comma.
     * Without it we would get alternatives for the comma character, e.g. `ASC` and `DESC`.
     */
    private readonly delimiterTokens;
    /**
     * Compute autocomplete suggestions for the given Parser.
     *
     * @param parser Parser instance to compute suggestions for.
     * @param ignoredTokens Tokens which we do not want to return as suggestions, used by [antlr4-c3](https://github.com/mike-lischke/antlr4-c3#ignored-tokens).
     * @param preferredRules Rules we want to return as suggestions, used by [antlr4-c3](https://github.com/mike-lischke/antlr4-c3#preferred-rules).
     * @param delimiterTokens Tokens to use as delimiters. When the caret is positioned at a delimiter
     * token then we'll look for suggestions **after** the current token.
     */
    constructor(parser: Parser, ignoredTokens?: Set<number>, preferredRules?: Set<number>, delimiterTokens?: Set<number>);
    protected getTokenStream(): BufferedTokenStream;
    /**
     * Return the matched text for the current token and range of selected characters.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @private
     */
    private getMatchedText;
    /**
     * Map the provided collection of candidate tokens into {@link TokenSuggestions} using a
     * consumer-friendly token name.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @param collectedCandidateTokens Token suggestions from `antlr4-c3`
     */
    private getCandidateTokens;
    /**
     * Map the provided collection of candidate rules into {@link RuleSuggestionsWithRuleList}. This
     * allows subclasses to assign contextual data to each suggestion.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @param collectedCandidateRules Rule suggestions from `antlr4-c3`
     */
    private getCandidateRules;
    /**
     * Map the provided collection of candidate rules into {@link RuleSuggestionsWithRuleList}.
     *
     * @param collectedCandidateRules Rule suggestions from `antlr4-c3`
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
    private mapCandidateRules;
    /**
     * Return the input token for a given caret position. If the caret is positioned at the start of
     * the input, or no matching token could be found then `undefined` is returned.
     *
     * @param caretStartPosition Caret position.
     * @private
     */
    private getCaretToken;
    /**
     * Determines if the provided token is one of the configured {@link delimiterTokens}.
     *
     * @param caretToken The token matched for a given caret position.
     * @private
     */
    private isCaretAtDelimiterToken;
    /**
     * Determine if the provided token is one of the configured {@link delimiterTokens}, or a hidden
     * token. Hidden token refers to a token on ANTLR's HIDDEN_CHANNEL. This means the token is not
     * represented in the parse tree and effectively ignored.
     *
     * @param caretToken The token matched for a given caret position.
     * @protected
     */
    protected isCaretAtDelimiterOrHiddenToken(caretToken: Token): boolean;
    /**
     * This method has no default implementation. The class which wants to override a specific scenario to calculate replace position,
     * will have to provide implementation. If this method returns null, the position will be calculated by {@see BaseAutocomplete#getReplacePosition}
     *
     * @param replaceStartToken The token which should be used when determining the replacement start
     * position. For token suggestions this will match `maybeCaretToken`, for rules this will refer to
     * the start token where the rule should be replaced.
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @protected
     */
    protected overrideReplacePosition(replaceStartToken: Token | void, maybeCaretToken: Token | void, caretSelectionRange: Position): Position | null;
    /**
     * Determine the range of characters that should be replaced for a token or rule suggestion.
     * Token and rule replacement adheres to the following strategy:
     * - If the caret selection is **inside** a token, then the entire token will be replaced.
     * e.g. `s|tatu|s => story|`
     * - If the caret selection starts **before** a token, then the selection will be replaced.
     * e.g. `|statu|s => story|s`
     * - If the caret selection spans **across** tokens, then the beginning of the start token, up
     * until selection end, will be replaced. e.g. `s|tatus = op|en => story|en`
     *
     *
     * @param replaceStartToken The token which should be used when determining the replacement start
     * position. For token suggestions this will match `maybeCaretToken`, for rules this will refer to
     * the start token where the rule should be replaced.
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @private
     */
    private getReplacePosition;
    /**
     * Return autocomplete suggestions for the provided caret position in the input stream.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
    private getCandidates;
    /**
     * Returns list of expected next tokens based on the provided caret position.
     *
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
    getSuggestionsForCaretPosition(caretSelectionRange: Position): Suggestions<RuleContext>;
    /**
     * Returns list of expected next tokens based on the provided token index.
     *
     * @param tokenIndex Index of the token to retrieve suggestions for.
     */
    getSuggestionsForTokenIndex(tokenIndex: number): Suggestions<RuleContext>;
    /**
     * Subclasses can override this method to assign contextual data to the provided `ruleSuggestions`.
     * For example, a grammar may return the following rule for the RHS of a simple boolean expression:
     * `loading === `
     * ```
     * {
     *   rhs: {
     *     matchedText: '',
     *     replacePosition: [16, 16],
     *     context: {}
     *   }
     * }
     * ```
     * The subclass can enrich this suggestion with the LHS variable reference. e.g.
     * ```
     * {
     *   rhs: {
     *     matchedText: '',
     *     replacePosition: [16, 16],
     *     context: {
     *       lhs: 'loading'
     *     }
     *   }
     * }
     * ```
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param rules Map of {@link RuleSuggestion} to assign context data to keyed by parser rule index.
     * @protected
     */
    protected assignRuleContextData(maybeCaretToken: Token | void, rules: RuleSuggestionsWithRuleList<RuleContext>): RuleSuggestionsWithRuleList<RuleContext>;
}
