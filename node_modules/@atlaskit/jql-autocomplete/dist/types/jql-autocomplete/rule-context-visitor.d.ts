import { BufferedTokenStream, Token } from 'antlr4ts';
import { RuleNode } from 'antlr4ts/tree';
import { JqlAndClauseContext, JqlChangedClauseContext, JqlChangedOperatorContext, JqlComparisonClauseContext, JqlComparisonOperatorContext, JqlEqualsClauseContext, JqlEqualsOperatorContext, JqlFieldContext, JqlInClauseContext, JqlInOperatorContext, JqlIsClauseContext, JqlIsOperatorContext, JqlLikeClauseContext, JqlLikeOperatorContext, JqlListContext, JqlNonNumberFieldContext, JqlNotClauseContext, JqlNumberFieldContext, JqlOrClauseContext, JQLParserVisitor, JqlQueryContext, JqlSubClauseContext, JqlTerminalClauseContext, JqlWasClauseContext, JqlWasInClauseContext, JqlWasInOperatorContext, JqlWasOperatorContext, JqlWhereContext } from '@atlaskit/jql-parser';
import { RuleSuggestion } from '../base-autocomplete/types';
import { JQLRuleContext, JQLRuleContextWithErrors } from './types';
export declare class RuleContextVisitor implements JQLParserVisitor<JQLRuleContext> {
    private readonly ruleList;
    private readonly rule;
    private readonly tokenStream;
    private readonly maybeCaretToken;
    private readonly replacePositionStart;
    constructor(ruleSuggestion: RuleSuggestion<JQLRuleContext>, ruleList: number[], rule: number, tokenStream: BufferedTokenStream, maybeCaretToken: Token | void);
    visitJqlQuery: (ctx: JqlQueryContext) => JQLRuleContext;
    visitJqlWhere: (ctx: JqlWhereContext) => JQLRuleContext;
    visitJqlOrderBy: () => JQLRuleContext;
    visitJqlOrClause: (ctx: JqlOrClauseContext) => JQLRuleContext;
    visitJqlAndClause: (ctx: JqlAndClauseContext) => JQLRuleContext;
    visitJqlNotClause: (ctx: JqlNotClauseContext) => JQLRuleContext;
    visitJqlSubClause: (ctx: JqlSubClauseContext) => JQLRuleContext;
    visitJqlTerminalClause: (ctx: JqlTerminalClauseContext) => JQLRuleContext;
    visitJqlField: (ctx: JqlFieldContext) => JQLRuleContext;
    visitJqlNumberField: (ctx: JqlNumberFieldContext) => JQLRuleContext;
    visitJqlNonNumberField: (ctx: JqlNonNumberFieldContext) => JQLRuleContext;
    visitJqlEqualsClause: (ctx: JqlEqualsClauseContext) => JQLRuleContext;
    visitJqlEqualsOperator: (ctx: JqlEqualsOperatorContext) => JQLRuleContext;
    visitJqlLikeClause: (ctx: JqlLikeClauseContext) => JQLRuleContext;
    visitJqlLikeOperator: (ctx: JqlLikeOperatorContext) => JQLRuleContext;
    visitJqlComparisonClause: (ctx: JqlComparisonClauseContext) => JQLRuleContext;
    visitJqlComparisonOperator: (ctx: JqlComparisonOperatorContext) => JQLRuleContext;
    visitJqlInClause: (ctx: JqlInClauseContext) => JQLRuleContext;
    visitJqlInOperator: (ctx: JqlInOperatorContext) => JQLRuleContext;
    visitJqlIsClause: (ctx: JqlIsClauseContext) => JQLRuleContext;
    visitJqlIsOperator: (ctx: JqlIsOperatorContext) => JQLRuleContext;
    visitJqlWasClause: (ctx: JqlWasClauseContext) => JQLRuleContext;
    visitJqlWasOperator: (ctx: JqlWasOperatorContext) => JQLRuleContext;
    visitJqlWasInClause: (ctx: JqlWasInClauseContext) => JQLRuleContext;
    visitJqlWasInOperator: (ctx: JqlWasInOperatorContext) => JQLRuleContext;
    visitJqlChangedClause: (ctx: JqlChangedClauseContext) => JQLRuleContext;
    visitJqlChangedOperator: (ctx: JqlChangedOperatorContext) => JQLRuleContext;
    visitJqlList: (ctx: JqlListContext) => JQLRuleContext;
    private visitOperator;
    /**
     * Returns whether replace position start for our candidate lies within the provided rule context,
     * or it's a whitespace token starting where the rule context ends. In those cases, we can assume
     * the provided rule context contains the relevant contextual data for our candidate rule.
     *
     * NOTE: This assumption is not airtight and there could be scenarios which violate this
     * assumption if we introduce new candidates or context nodes in the future.
     */
    private isReplacePosAtCtx;
    /**
     * Given a list of parser rule contexts, this function returns which one should be visited
     * based on replace position start (i.e. the parser rule context that contains the relevant
     * information for our candidate rule).
     *
     * This can be called by visitor functions to select the adequate child rule context to visit,
     * for instance when we have multiple terminal clauses in a compound clause.
     */
    private getCtxToVisit;
    /**
     * Recover from the clause type ambiguities described in {@link visitChildren}.
     */
    private getCtxFromErrorNodes;
    /**
     * If this function is called, it means parse tree contains error nodes. In some situations, this
     * is due to ambiguities we can recover from (e.g. "issuetype was ", which can be a WAS or WAS IN
     * clause). To help return the right context in these cases, we expose error nodes in the current
     * rule context, allowing upstream visitors to decide how to handle them.
     */
    visitChildren: (node: RuleNode) => JQLRuleContextWithErrors;
    visit: () => never;
    visitErrorNode: () => never;
    visitTerminal: () => never;
}
