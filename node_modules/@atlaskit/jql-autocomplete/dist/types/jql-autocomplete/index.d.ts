import { Token } from 'antlr4ts';
import { JQLParser } from '@atlaskit/jql-parser';
import { BaseAutocomplete } from '../base-autocomplete';
import { RuleSuggestionsWithRuleList } from '../base-autocomplete/types';
import { Position } from '../common/types';
import { JQLRuleContext, JQLSuggestions } from './types';
export declare class JQLAutocomplete extends BaseAutocomplete<JQLRuleContext> {
    private readonly tree;
    /**
     * Compute autocomplete suggestions for the given JQLParser and parse tree. Parse tree is used
     * when determining the context for rule suggestions. When `tree` is undefined (e.g. if parsing
     * failed due to a syntax error) then correct suggestions will still be returned, but contextual
     * information like field/operator will not be included.
     */
    private constructor();
    /**
     * Parse the provided text and return a new {@link JQLAutocomplete} object (**does** include
     * {@link JQLRuleContext} data for rule suggestions).
     *
     * @param text Text to compute suggestions for.
     * @param ignoredTokens Tokens which we do not want to return as suggestions. When not provided, {@link defaultIgnoredTokens} will be used.
     * @param preferredRules Rules we want to return as suggestions. When not provided, {@link defaultPreferredRules} will be used.
     * @param delimiterTokens Tokens to use as delimiters. When not provided, {@link defaultDelimiterTokens} will be used.
     */
    static fromText(text: string, ignoredTokens?: Set<number>, preferredRules?: Set<number>, delimiterTokens?: Set<number>): JQLAutocomplete;
    /**
     * Return a new {@link JQLAutocomplete} object using the provided parser instance (**does not**
     * include {@link JQLRuleContext} data for rule suggestions).
     *
     * @param parser Parser instance to compute suggestions for.
     * @param ignoredTokens Tokens which we do not want to return as suggestions. When not provided, {@link defaultIgnoredTokens} will be used.
     * @param preferredRules Rules we want to return as suggestions. When not provided, {@link defaultPreferredRules} will be used.
     * @param delimiterTokens Tokens to use as delimiters. When not provided, {@link defaultDelimiterTokens} will be used.
     */
    static fromParser(parser: JQLParser, ignoredTokens?: Set<number>, preferredRules?: Set<number>, delimiterTokens?: Set<number>): JQLAutocomplete;
    /**
     * Walk the parse tree and mutate the provided rules object to add context data for relevant rules.
     *
     * @override
     */
    protected assignRuleContextData(maybeCaretToken: Token | void, rules: RuleSuggestionsWithRuleList<JQLRuleContext>): RuleSuggestionsWithRuleList<JQLRuleContext>;
    getJQLSuggestionsForCaretPosition(caretSelectionRange: Position): JQLSuggestions;
    getJQLSuggestionsForTokenIndex(tokenIndex: number): JQLSuggestions;
    /**
     * Map the provided rule suggestions keyed by parser rule index into {@link JQLRuleSuggestions}
     * using a consumer-friendly rule name.
     *
     * Here we maintain a fixed subset of JQL parse rules which we return as rule suggestions. We map
     * the parse rule index into a predefined string which consumers should use when interpreting
     * rules.
     *
     * Why do we only support a subset of rules? Because otherwise we'd have 2 options:
     * 1. Return all rules keyed by rule index. This means consumers need to import the JQLParser
     * module to interpret the rule and will become more tightly coupled to ANTLR generated
     * dependencies.
     * 2. Return all rules keyed by the rule display name. This will make implementation more fragile
     * as any change to rule names within our grammar has the potential to break all consumers.
     *
     * By only supporting a subset of rules, we can gradually evolve the list as new use cases emerge
     * and ensure that consumers have a stable API they can build upon.
     *
     * @override
     */
    private mapToJQLSuggestions;
    private isCaretAtUnclosedString;
    /**
     *  This method is being overridden for a specific scenario where we encounter string inside an unclosed single quote or double quote.
     *  If this method returns null then the Position calculation will be further processed by getReplacePosition in the base-autocomplete/
     *
     *  @override
     *
     */
    protected overrideReplacePosition(replaceStartToken: Token | void, maybeCaretToken: Token | void, caretSelectionRange: Position): Position | null;
}
