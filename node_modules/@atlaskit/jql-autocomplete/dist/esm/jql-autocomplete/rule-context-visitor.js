import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["errorNodes"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import { ORDER_BY_CLAUSE, WHERE_CLAUSE } from './constants';
import { getPositionFromParserRule, isOperator, normalizeText } from './util';
export var RuleContextVisitor = /*#__PURE__*/_createClass(function RuleContextVisitor(ruleSuggestion, ruleList, rule, tokenStream, maybeCaretToken) {
  var _this = this;
  _classCallCheck(this, RuleContextVisitor);
  _defineProperty(this, "visitJqlQuery", function (ctx) {
    var whereCtx = ctx.jqlWhere();
    var orderByCtx = ctx.jqlOrderBy();
    var ctxToVisit = _this.getCtxToVisit([whereCtx, orderByCtx]);
    var ruleContext = _objectSpread({}, ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(_this));
    if (_this.rule === JQLParser.RULE_jqlField) {
      ruleContext.clause = _this.ruleList.includes(JQLParser.RULE_jqlWhere) ? WHERE_CLAUSE : ORDER_BY_CLAUSE;
    }
    return ruleContext;
  });
  _defineProperty(this, "visitJqlWhere", function (ctx) {
    return ctx.jqlOrClause().accept(_this);
  });
  _defineProperty(this, "visitJqlOrderBy", function () {
    return {};
  });
  _defineProperty(this, "visitJqlOrClause", function (ctx) {
    var ctxToVisit = _this.getCtxToVisit(ctx.jqlAndClause());
    return _objectSpread({}, ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(_this));
  });
  _defineProperty(this, "visitJqlAndClause", function (ctx) {
    var ctxToVisit = _this.getCtxToVisit(ctx.jqlNotClause());
    return _objectSpread({}, ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(_this));
  });
  _defineProperty(this, "visitJqlNotClause", function (ctx) {
    var ctxToVisit = _this.getCtxToVisit([ctx.jqlNotClause(), ctx.jqlSubClause(), ctx.jqlTerminalClause()]);
    return _objectSpread({}, ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(_this));
  });
  _defineProperty(this, "visitJqlSubClause", function (ctx) {
    var orCtx = ctx.jqlOrClause();
    return _objectSpread({}, orCtx === null || orCtx === void 0 ? void 0 : orCtx.accept(_this));
  });
  _defineProperty(this, "visitJqlTerminalClause", function (ctx) {
    var fieldCtx = ctx.jqlField();
    var rhsCtx = ctx.jqlTerminalClauseRhs();
    var _rhsCtx$accept = rhsCtx.accept(_this),
      errorNodes = _rhsCtx$accept.errorNodes,
      rhsRuleContext = _objectWithoutProperties(_rhsCtx$accept, _excluded);
    return _objectSpread(_objectSpread(_objectSpread({}, fieldCtx.accept(_this)), rhsRuleContext), _this.getCtxFromErrorNodes(errorNodes));
  });
  _defineProperty(this, "visitJqlField", function (ctx) {
    if (_this.rule === JQLParser.RULE_jqlField) {
      return {};
    }
    return {
      field: _this.tokenStream.getText(ctx)
    };
  });
  _defineProperty(this, "visitJqlNumberField", function (ctx) {
    return _this.visitJqlField(ctx);
  });
  _defineProperty(this, "visitJqlNonNumberField", function (ctx) {
    return _this.visitJqlField(ctx);
  });
  _defineProperty(this, "visitJqlEqualsClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlEqualsOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlEqualsOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlLikeClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlLikeOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlLikeOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlComparisonClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlComparisonOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlComparisonOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlInClause", function (ctx) {
    var operatorContext = ctx.jqlInOperator().accept(_this);
    var listCtx = ctx.jqlList();
    if (listCtx !== undefined && _this.isReplacePosAtCtx(listCtx)) {
      return _objectSpread(_objectSpread({}, operatorContext), listCtx.accept(_this));
    }
    return _objectSpread({}, operatorContext);
  });
  _defineProperty(this, "visitJqlInOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlIsClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlIsOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlIsOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlWasClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlWasOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlWasOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlWasInClause", function (ctx) {
    var operatorContext = ctx.jqlWasInOperator().accept(_this);
    var listCtx = ctx.jqlList();
    if (listCtx !== undefined && _this.isReplacePosAtCtx(listCtx)) {
      return _objectSpread(_objectSpread({}, operatorContext), listCtx.accept(_this));
    }
    return _objectSpread({}, operatorContext);
  });
  _defineProperty(this, "visitJqlWasInOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlChangedClause", function (ctx) {
    // We can skip visiting operand in this case as this clause type doesn't support list operands
    return ctx.jqlChangedOperator().accept(_this);
  });
  _defineProperty(this, "visitJqlChangedOperator", function (ctx) {
    return _this.visitOperator(ctx);
  });
  _defineProperty(this, "visitJqlList", function (ctx) {
    var _getPositionFromParse = getPositionFromParserRule(ctx.jqlListStart()),
      _getPositionFromParse2 = _slicedToArray(_getPositionFromParse, 2),
      _ = _getPositionFromParse2[0],
      leftParenStop = _getPositionFromParse2[1];
    try {
      var _getPositionFromParse3 = getPositionFromParserRule(ctx.jqlListEnd()),
        _getPositionFromParse4 = _slicedToArray(_getPositionFromParse3, 1),
        rightParenStart = _getPositionFromParse4[0];
      if (_this.replacePositionStart >= leftParenStop && _this.replacePositionStart <= rightParenStart) {
        return {
          isList: true
        };
      }
    } catch (error) {
      // There are some queries (e.g. "project in (jsw jsd") where visiting `jqlListEnd` context
      // results in an error, as RPAREN token doesn't exist and parse tree contains an error node
      // that prevents ANTLR from recovering. For context purposes, this means we are inside the list.
      return {
        isList: true
      };
    }
    return {};
  });
  _defineProperty(this, "visitOperator", function (ctx) {
    // In some situations, e.g. "project was in|", autocomplete returns both operator and operand
    // rules as candidates. For the operand rule, we want to have "was" as operator in context, even
    // though the parse tree in this case says that the operator is "was in". For this reason, we
    // get text before replace position start and check if result is one of the supported operators.
    var textBeforeReplacePosition = _this.tokenStream.getText(ctx).substring(0, _this.replacePositionStart - ctx.start.startIndex);
    var maybeOperator = normalizeText(textBeforeReplacePosition);
    if (isOperator(maybeOperator)) {
      return {
        operator: maybeOperator
      };
    }
    return {};
  });
  /**
   * Returns whether replace position start for our candidate lies within the provided rule context,
   * or it's a whitespace token starting where the rule context ends. In those cases, we can assume
   * the provided rule context contains the relevant contextual data for our candidate rule.
   *
   * NOTE: This assumption is not airtight and there could be scenarios which violate this
   * assumption if we introduce new candidates or context nodes in the future.
   */
  _defineProperty(this, "isReplacePosAtCtx", function (ctx) {
    var _getPositionFromParse5 = getPositionFromParserRule(ctx),
      _getPositionFromParse6 = _slicedToArray(_getPositionFromParse5, 2),
      start = _getPositionFromParse6[0],
      stop = _getPositionFromParse6[1];
    return _this.replacePositionStart >= start && _this.replacePositionStart <= stop || !!_this.maybeCaretToken && _this.maybeCaretToken.type === JQLLexer.MATCHWS && _this.maybeCaretToken.startIndex === stop;
  });
  /**
   * Given a list of parser rule contexts, this function returns which one should be visited
   * based on replace position start (i.e. the parser rule context that contains the relevant
   * information for our candidate rule).
   *
   * This can be called by visitor functions to select the adequate child rule context to visit,
   * for instance when we have multiple terminal clauses in a compound clause.
   */
  _defineProperty(this, "getCtxToVisit", function (contexts) {
    var definedContexts = contexts.filter(function (context) {
      return context !== undefined;
    });
    for (var i = 0; i < definedContexts.length; i++) {
      var ctx = definedContexts[i];
      if (_this.isReplacePosAtCtx(ctx)) {
        return ctx;
      }
    }
    return undefined;
  });
  /**
   * Recover from the clause type ambiguities described in {@link visitChildren}.
   */
  _defineProperty(this, "getCtxFromErrorNodes", function (errorNodes) {
    if (errorNodes !== undefined) {
      var textBeforeReplacePosition = errorNodes.filter(function (errorNode) {
        return errorNode.payload.startIndex < _this.replacePositionStart;
      }).map(function (errorNode) {
        return errorNode.payload.text;
      }).join(' ');
      var maybeOperator = normalizeText(textBeforeReplacePosition);
      if (isOperator(maybeOperator)) {
        return {
          operator: maybeOperator
        };
      }
    }
    return {};
  });
  /**
   * If this function is called, it means parse tree contains error nodes. In some situations, this
   * is due to ambiguities we can recover from (e.g. "issuetype was ", which can be a WAS or WAS IN
   * clause). To help return the right context in these cases, we expose error nodes in the current
   * rule context, allowing upstream visitors to decide how to handle them.
   */
  _defineProperty(this, "visitChildren", function (node) {
    var errorNodes = [];
    for (var i = 0; i < node.childCount; i++) {
      errorNodes.push(node.getChild(i));
    }
    return {
      errorNodes: errorNodes
    };
  });
  _defineProperty(this, "visit", function () {
    throw new Error('Unsupported operation visit(ParseTree)');
  });
  _defineProperty(this, "visitErrorNode", function () {
    throw new Error('Unsupported operation visitErrorNode(ErrorNode)');
  });
  _defineProperty(this, "visitTerminal", function () {
    throw new Error('Unsupported operation visitTerminal(TerminalNode)');
  });
  this.ruleList = ruleList;
  this.rule = rule;
  this.tokenStream = tokenStream;
  this.maybeCaretToken = maybeCaretToken;
  var _ruleSuggestion$repla = _slicedToArray(ruleSuggestion.replacePosition, 1);
  this.replacePositionStart = _ruleSuggestion$repla[0];
});