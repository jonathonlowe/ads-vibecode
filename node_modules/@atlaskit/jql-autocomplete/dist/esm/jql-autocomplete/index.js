import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { CharStreams, CommonTokenStream } from 'antlr4ts';
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import { BaseAutocomplete } from '../base-autocomplete';
import { rulesWithContext, unclosedStringTokens } from './constants';
import { defaultDelimiterTokens, defaultIgnoredTokens, defaultPreferredRules } from './defaults';
import { RuleContextVisitor } from './rule-context-visitor';
import { isPredicateOperand } from './util';
export var JQLAutocomplete = /*#__PURE__*/function (_BaseAutocomplete) {
  _inherits(JQLAutocomplete, _BaseAutocomplete);
  var _super = _createSuper(JQLAutocomplete);
  /**
   * Compute autocomplete suggestions for the given JQLParser and parse tree. Parse tree is used
   * when determining the context for rule suggestions. When `tree` is undefined (e.g. if parsing
   * failed due to a syntax error) then correct suggestions will still be returned, but contextual
   * information like field/operator will not be included.
   */
  function JQLAutocomplete(parser) {
    var _this;
    var ignoredTokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultIgnoredTokens;
    var preferredRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPreferredRules;
    var delimiterTokens = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultDelimiterTokens;
    var tree = arguments.length > 4 ? arguments[4] : undefined;
    _classCallCheck(this, JQLAutocomplete);
    _this = _super.call(this, parser, ignoredTokens, preferredRules, delimiterTokens);
    _this.tree = tree;
    return _this;
  }

  /**
   * Parse the provided text and return a new {@link JQLAutocomplete} object (**does** include
   * {@link JQLRuleContext} data for rule suggestions).
   *
   * @param text Text to compute suggestions for.
   * @param ignoredTokens Tokens which we do not want to return as suggestions. When not provided, {@link defaultIgnoredTokens} will be used.
   * @param preferredRules Rules we want to return as suggestions. When not provided, {@link defaultPreferredRules} will be used.
   * @param delimiterTokens Tokens to use as delimiters. When not provided, {@link defaultDelimiterTokens} will be used.
   */
  _createClass(JQLAutocomplete, [{
    key: "assignRuleContextData",
    value:
    /**
     * Walk the parse tree and mutate the provided rules object to add context data for relevant rules.
     *
     * @override
     */
    function assignRuleContextData(maybeCaretToken, rules) {
      var _this2 = this;
      if (this.tree === undefined) {
        return rules;
      }
      rules.forEach(function (_ref, ruleNumber) {
        var _ref2 = _slicedToArray(_ref, 2),
          ruleSuggestion = _ref2[0],
          ruleList = _ref2[1];
        if (rulesWithContext.includes(ruleNumber)) {
          var _this2$tree$accept, _this2$tree;
          var ruleContextVisitor = new RuleContextVisitor(ruleSuggestion, ruleList, ruleNumber, _this2.getTokenStream(), maybeCaretToken);
          ruleSuggestion.context = (_this2$tree$accept = (_this2$tree = _this2.tree) === null || _this2$tree === void 0 ? void 0 : _this2$tree.accept(ruleContextVisitor)) !== null && _this2$tree$accept !== void 0 ? _this2$tree$accept : null;
        }
      });
      return rules;
    }
  }, {
    key: "getJQLSuggestionsForCaretPosition",
    value: function getJQLSuggestionsForCaretPosition(caretSelectionRange) {
      return this.mapToJQLSuggestions(this.getSuggestionsForCaretPosition(caretSelectionRange));
    }
  }, {
    key: "getJQLSuggestionsForTokenIndex",
    value: function getJQLSuggestionsForTokenIndex(tokenIndex) {
      return this.mapToJQLSuggestions(this.getSuggestionsForTokenIndex(tokenIndex));
    }

    /**
     * Map the provided rule suggestions keyed by parser rule index into {@link JQLRuleSuggestions}
     * using a consumer-friendly rule name.
     *
     * Here we maintain a fixed subset of JQL parse rules which we return as rule suggestions. We map
     * the parse rule index into a predefined string which consumers should use when interpreting
     * rules.
     *
     * Why do we only support a subset of rules? Because otherwise we'd have 2 options:
     * 1. Return all rules keyed by rule index. This means consumers need to import the JQLParser
     * module to interpret the rule and will become more tightly coupled to ANTLR generated
     * dependencies.
     * 2. Return all rules keyed by the rule display name. This will make implementation more fragile
     * as any change to rule names within our grammar has the potential to break all consumers.
     *
     * By only supporting a subset of rules, we can gradually evolve the list as new use cases emerge
     * and ensure that consumers have a stable API they can build upon.
     *
     * @override
     */
  }, {
    key: "mapToJQLSuggestions",
    value: function mapToJQLSuggestions(_ref3) {
      var tokens = _ref3.tokens,
        rules = _ref3.rules;
      var ruleSuggestions = {};
      rules.forEach(function (_ref4, key) {
        var _ref5 = _slicedToArray(_ref4, 2),
          ruleSuggestion = _ref5[0],
          ruleList = _ref5[1];
        switch (key) {
          case JQLParser.RULE_jqlField:
            ruleSuggestions.field = ruleSuggestion;
            break;
          case JQLParser.RULE_jqlCustomField:
            ruleSuggestions.customField = ruleSuggestion;
            break;
          case JQLParser.RULE_jqlEqualsOperator:
          case JQLParser.RULE_jqlLikeOperator:
          case JQLParser.RULE_jqlComparisonOperator:
          case JQLParser.RULE_jqlInOperator:
          case JQLParser.RULE_jqlIsOperator:
          case JQLParser.RULE_jqlWasOperator:
          case JQLParser.RULE_jqlWasInOperator:
          case JQLParser.RULE_jqlChangedOperator:
            ruleSuggestions.operator = ruleSuggestion;
            break;
          case JQLParser.RULE_jqlValue:
            // Disable autocomplete for predicate operands.
            // To be removed when we build proper autocomplete support.
            if (!isPredicateOperand(ruleList)) {
              ruleSuggestions.value = ruleSuggestion;
            }
            break;
          case JQLParser.RULE_jqlListStart:
            // Disable autocomplete for predicate operands.
            // To be removed when we build proper autocomplete support.
            if (!isPredicateOperand(ruleList)) {
              ruleSuggestions.list = ruleSuggestion;
            }
            break;
          case JQLParser.RULE_jqlFunction:
            // Disable autocomplete for predicate operands.
            // To be removed when we build proper autocomplete support.
            if (!isPredicateOperand(ruleList)) {
              ruleSuggestions.function = ruleSuggestion;
            }
            break;
          case JQLParser.RULE_jqlFieldProperty:
            ruleSuggestions.fieldProperty = ruleSuggestion;
            break;
          case JQLParser.RULE_jqlArgument:
            for (var i = ruleList.length - 1; i >= 0; i--) {
              // The argument rule is shared between functions and field properties. We inspect the
              // rule list to determine which rule our suggestion is scoped to.
              if (ruleList[i] === JQLParser.RULE_jqlFunction) {
                ruleSuggestions.functionArgument = ruleSuggestion;
                break;
              }
              if (ruleList[i] === JQLParser.RULE_jqlPropertyArgument) {
                ruleSuggestions.fieldPropertyArgument = ruleSuggestion;
                break;
              }
              if (ruleList[i] === JQLParser.RULE_jqlFieldProperty) {
                ruleSuggestions.fieldPropertyId = ruleSuggestion;
                break;
              }
            }
            break;
          default:
        }
      });
      return {
        tokens: tokens,
        rules: ruleSuggestions
      };
    }
  }, {
    key: "isCaretAtUnclosedString",
    value: function isCaretAtUnclosedString(caretToken) {
      return unclosedStringTokens.includes(caretToken.type);
    }

    /**
     *  This method is being overridden for a specific scenario where we encounter string inside an unclosed single quote or double quote.
     *  If this method returns null then the Position calculation will be further processed by getReplacePosition in the base-autocomplete/
     *
     *  @override
     *
     */
  }, {
    key: "overrideReplacePosition",
    value: function overrideReplacePosition(replaceStartToken, maybeCaretToken, caretSelectionRange) {
      if (maybeCaretToken && this.isCaretAtUnclosedString(maybeCaretToken)) {
        var _caretSelectionRange = _slicedToArray(caretSelectionRange, 2),
          start = _caretSelectionRange[0],
          stop = _caretSelectionRange[1];

        // If the replaceStartToken is not defined (i.e. cursor at beginning of string) or the caret is
        // positioned at a delimiter/hidden token then we want to append at selection start.
        // Otherwise we want our replacement to start from the beginning of specified token.
        var startPosition = replaceStartToken === undefined || this.isCaretAtDelimiterOrHiddenToken(replaceStartToken) ? start : Math.min(replaceStartToken.startIndex, start);
        return [startPosition, stop];
      }
      return null;
    }
  }], [{
    key: "fromText",
    value: function fromText(text, ignoredTokens, preferredRules, delimiterTokens) {
      var charStream = CharStreams.fromString(text);
      var lexer = new JQLLexer(charStream);
      var tokenStream = new CommonTokenStream(lexer);
      var parser = new JQLParser(tokenStream);
      parser.removeErrorListeners();
      return new JQLAutocomplete(parser, ignoredTokens, preferredRules, delimiterTokens, parser.jqlQuery());
    }

    /**
     * Return a new {@link JQLAutocomplete} object using the provided parser instance (**does not**
     * include {@link JQLRuleContext} data for rule suggestions).
     *
     * @param parser Parser instance to compute suggestions for.
     * @param ignoredTokens Tokens which we do not want to return as suggestions. When not provided, {@link defaultIgnoredTokens} will be used.
     * @param preferredRules Rules we want to return as suggestions. When not provided, {@link defaultPreferredRules} will be used.
     * @param delimiterTokens Tokens to use as delimiters. When not provided, {@link defaultDelimiterTokens} will be used.
     */
  }, {
    key: "fromParser",
    value: function fromParser(parser, ignoredTokens, preferredRules, delimiterTokens) {
      return new JQLAutocomplete(parser, ignoredTokens, preferredRules, delimiterTokens);
    }
  }]);
  return JQLAutocomplete;
}(BaseAutocomplete);