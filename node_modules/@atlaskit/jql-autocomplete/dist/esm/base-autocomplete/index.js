import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import { CodeCompletionCore } from 'antlr4-c3/lib/src/CodeCompletionCore';
import { Token } from 'antlr4ts';
import { getMatchedText as _getMatchedText } from './util';

/**
 * Antlr-based, grammar agnostic, autocomplete class. Consumers can provide options to adjust the
 * suggestions returned by the autocompletion engine, or extend the class to enrich suggestions with
 * additional contextual data.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export var BaseAutocomplete = /*#__PURE__*/function () {
  /**
   * A delimiter token instructs us that we want to get suggestions for the **next** token in the
   * stream. This is useful when you know there are no more characters that will follow a token. For
   * instance, with the following expression `order by field,` the comma is our `caretToken`. If we
   * specify comma as a delimiter token then we will get suggestions for tokens **after** the comma.
   * Without it we would get alternatives for the comma character, e.g. `ASC` and `DESC`.
   */

  /**
   * Compute autocomplete suggestions for the given Parser.
   *
   * @param parser Parser instance to compute suggestions for.
   * @param ignoredTokens Tokens which we do not want to return as suggestions, used by [antlr4-c3](https://github.com/mike-lischke/antlr4-c3#ignored-tokens).
   * @param preferredRules Rules we want to return as suggestions, used by [antlr4-c3](https://github.com/mike-lischke/antlr4-c3#preferred-rules).
   * @param delimiterTokens Tokens to use as delimiters. When the caret is positioned at a delimiter
   * token then we'll look for suggestions **after** the current token.
   */
  function BaseAutocomplete(parser) {
    var ignoredTokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    var preferredRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var delimiterTokens = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();
    _classCallCheck(this, BaseAutocomplete);
    this.parser = parser;
    this.core = new CodeCompletionCore(this.parser);
    this.core.ignoredTokens = ignoredTokens;
    this.core.preferredRules = preferredRules;

    // This ensures we get more specific matches for recursive rules, e.g. list operands `status in (`
    this.core.translateRulesTopDown = true;
    this.delimiterTokens = delimiterTokens;
  }
  _createClass(BaseAutocomplete, [{
    key: "getTokenStream",
    value: function getTokenStream() {
      return this.parser.inputStream;
    }

    /**
     * Return the matched text for the current token and range of selected characters.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @private
     */
  }, {
    key: "getMatchedText",
    value: function getMatchedText(maybeCaretToken, caretSelectionRange) {
      if (!maybeCaretToken) {
        return '';
      }

      // If the caret is at a delimiter or hidden token then our matched text should be computed
      // starting at the next token
      var startTokenIndex = this.isCaretAtDelimiterOrHiddenToken(maybeCaretToken) ? maybeCaretToken.tokenIndex + 1 : maybeCaretToken.tokenIndex;
      return _getMatchedText(this.getTokenStream(), startTokenIndex, maybeCaretToken, caretSelectionRange);
    }

    /**
     * Map the provided collection of candidate tokens into {@link TokenSuggestions} using a
     * consumer-friendly token name.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @param collectedCandidateTokens Token suggestions from `antlr4-c3`
     */
  }, {
    key: "getCandidateTokens",
    value: function getCandidateTokens(maybeCaretToken, caretSelectionRange, collectedCandidateTokens) {
      var _this = this;
      var candidateTokens = [];
      collectedCandidateTokens.forEach(function (value, key) {
        var tokenSequence = [key].concat(_toConsumableArray(value)); // handle token sequences that are always used together, e.g. ORDER + BY
        var tokenName = tokenSequence.map(function (tokenType) {
          return _this.parser.vocabulary.getDisplayName(tokenType).replace(/^'|'$/g, '');
        }).join(' ');
        if (tokenName) {
          candidateTokens.push(tokenName);
        }
      });
      candidateTokens.sort();
      var matchedText = this.getMatchedText(maybeCaretToken, caretSelectionRange);
      var replacePosition = this.getReplacePosition(maybeCaretToken, maybeCaretToken, caretSelectionRange);
      return {
        matchedText: matchedText,
        replacePosition: replacePosition,
        values: candidateTokens
      };
    }

    /**
     * Map the provided collection of candidate rules into {@link RuleSuggestionsWithRuleList}. This
     * allows subclasses to assign contextual data to each suggestion.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @param collectedCandidateRules Rule suggestions from `antlr4-c3`
     */
  }, {
    key: "getCandidateRules",
    value: function getCandidateRules(maybeCaretToken, caretSelectionRange, collectedCandidateRules) {
      var rules = this.mapCandidateRules(maybeCaretToken, caretSelectionRange, collectedCandidateRules);
      return this.assignRuleContextData(maybeCaretToken, rules);
    }

    /**
     * Map the provided collection of candidate rules into {@link RuleSuggestionsWithRuleList}.
     *
     * @param collectedCandidateRules Rule suggestions from `antlr4-c3`
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
  }, {
    key: "mapCandidateRules",
    value: function mapCandidateRules(maybeCaretToken, caretSelectionRange, collectedCandidateRules) {
      var _this2 = this;
      var rules = new Map();
      var tokens = this.getTokenStream();
      collectedCandidateRules.forEach(function (_ref, key) {
        var startTokenIndex = _ref.startTokenIndex,
          ruleList = _ref.ruleList;
        var defaultRule;
        var startToken = tokens.get(startTokenIndex);
        var replacePosition = _this2.getReplacePosition(startToken, maybeCaretToken, caretSelectionRange);
        if (!maybeCaretToken) {
          // The only case where maybeCaretToken is not defined is when the cursor is at the beginning of
          // the string. In this case we can safely assume our start position is 0.
          defaultRule = {
            matchedText: '',
            replacePosition: replacePosition,
            context: null
          };
        } else {
          var matchedText = _getMatchedText(tokens, startTokenIndex, maybeCaretToken, caretSelectionRange);
          defaultRule = {
            matchedText: matchedText,
            replacePosition: replacePosition,
            context: null
          };
        }
        rules.set(key, [defaultRule, ruleList]);
      });
      return rules;
    }

    /**
     * Return the input token for a given caret position. If the caret is positioned at the start of
     * the input, or no matching token could be found then `undefined` is returned.
     *
     * @param caretStartPosition Caret position.
     * @private
     */
  }, {
    key: "getCaretToken",
    value: function getCaretToken(caretStartPosition) {
      if (caretStartPosition === 0) {
        return undefined;
      }
      var tokens = this.getTokenStream().getTokens();
      var _iterator = _createForOfIteratorHelper(tokens),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var token = _step.value;
          if (caretStartPosition > token.startIndex && caretStartPosition <= token.stopIndex + 1 || token.type === Token.EOF) {
            return token;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return undefined;
    }

    /**
     * Determines if the provided token is one of the configured {@link delimiterTokens}.
     *
     * @param caretToken The token matched for a given caret position.
     * @private
     */
  }, {
    key: "isCaretAtDelimiterToken",
    value: function isCaretAtDelimiterToken(caretToken) {
      return this.delimiterTokens.has(caretToken.type);
    }

    /**
     * Determine if the provided token is one of the configured {@link delimiterTokens}, or a hidden
     * token. Hidden token refers to a token on ANTLR's HIDDEN_CHANNEL. This means the token is not
     * represented in the parse tree and effectively ignored.
     *
     * @param caretToken The token matched for a given caret position.
     * @protected
     */
  }, {
    key: "isCaretAtDelimiterOrHiddenToken",
    value: function isCaretAtDelimiterOrHiddenToken(caretToken) {
      return this.isCaretAtDelimiterToken(caretToken) || caretToken.channel === Token.HIDDEN_CHANNEL;
    }

    /**
     * This method has no default implementation. The class which wants to override a specific scenario to calculate replace position,
     * will have to provide implementation. If this method returns null, the position will be calculated by {@see BaseAutocomplete#getReplacePosition}
     *
     * @param replaceStartToken The token which should be used when determining the replacement start
     * position. For token suggestions this will match `maybeCaretToken`, for rules this will refer to
     * the start token where the rule should be replaced.
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @protected
     */
  }, {
    key: "overrideReplacePosition",
    value: function overrideReplacePosition(replaceStartToken, maybeCaretToken, caretSelectionRange) {
      return null;
    }

    /**
     * Determine the range of characters that should be replaced for a token or rule suggestion.
     * Token and rule replacement adheres to the following strategy:
     * - If the caret selection is **inside** a token, then the entire token will be replaced.
     * e.g. `s|tatu|s => story|`
     * - If the caret selection starts **before** a token, then the selection will be replaced.
     * e.g. `|statu|s => story|s`
     * - If the caret selection spans **across** tokens, then the beginning of the start token, up
     * until selection end, will be replaced. e.g. `s|tatus = op|en => story|en`
     *
     *
     * @param replaceStartToken The token which should be used when determining the replacement start
     * position. For token suggestions this will match `maybeCaretToken`, for rules this will refer to
     * the start token where the rule should be replaced.
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     * @private
     */
  }, {
    key: "getReplacePosition",
    value: function getReplacePosition(replaceStartToken, maybeCaretToken, caretSelectionRange) {
      // Replace position will be overridden, if only the grammar specific class has overriden method `overrideReplacePosition`
      // else the method `overrideReplacePosition` will return null and the calculation of position will continue further in the current method.
      var overriddenReplacePosition = this.overrideReplacePosition(replaceStartToken, maybeCaretToken, caretSelectionRange);
      if (overriddenReplacePosition) {
        return overriddenReplacePosition;
      }
      var _caretSelectionRange = _slicedToArray(caretSelectionRange, 2),
        start = _caretSelectionRange[0],
        stop = _caretSelectionRange[1];

      // If the replaceStartToken is not defined (i.e. cursor at beginning of string) or the caret is
      // positioned at a delimiter/hidden token then we want to append at selection start.
      // Otherwise we want our replacement to start from the beginning of specified token.
      var startPosition = replaceStartToken === undefined || this.isCaretAtDelimiterOrHiddenToken(replaceStartToken) ? start : Math.min(replaceStartToken.startIndex, start);

      // If the maybeCaretToken is not defined (i.e. cursor at beginning of string) or the caret is
      // positioned at a delimiter/hidden token then we want to replace up until selection stop.
      // Otherwise we want our replacement to replace the entire token beneath the caret.
      var stopPosition = maybeCaretToken === undefined || this.isCaretAtDelimiterOrHiddenToken(maybeCaretToken) ? stop : Math.max(maybeCaretToken.stopIndex + 1, stop);
      return [startPosition, stopPosition];
    }

    /**
     * Return autocomplete suggestions for the provided caret position in the input stream.
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
  }, {
    key: "getCandidates",
    value: function getCandidates(maybeCaretToken, caretSelectionRange) {
      var caretTokenIndex;
      if (maybeCaretToken === undefined) {
        caretTokenIndex = 0;
      } else {
        caretTokenIndex = this.isCaretAtDelimiterToken(maybeCaretToken) ? maybeCaretToken.tokenIndex + 1 : maybeCaretToken.tokenIndex;
      }
      var collectedCandidates = this.core.collectCandidates(caretTokenIndex);
      var tokens = this.getCandidateTokens(maybeCaretToken, caretSelectionRange, collectedCandidates.tokens);
      var rules = this.getCandidateRules(maybeCaretToken, caretSelectionRange, collectedCandidates.rules);
      return {
        tokens: tokens,
        rules: rules
      };
    }

    /**
     * Returns list of expected next tokens based on the provided caret position.
     *
     * @param caretSelectionRange The range of characters that are selected in the input stream. This
     * will determine the `replacePosition` computed for the returned {@link Suggestions}.
     */
  }, {
    key: "getSuggestionsForCaretPosition",
    value: function getSuggestionsForCaretPosition(caretSelectionRange) {
      var maybeCaretToken = this.getCaretToken(caretSelectionRange[0]);
      return this.getCandidates(maybeCaretToken, caretSelectionRange);
    }

    /**
     * Returns list of expected next tokens based on the provided token index.
     *
     * @param tokenIndex Index of the token to retrieve suggestions for.
     */
  }, {
    key: "getSuggestionsForTokenIndex",
    value: function getSuggestionsForTokenIndex(tokenIndex) {
      var caretToken = this.getTokenStream().get(tokenIndex);

      // When token index is provided, we behave as if the caret was at the end of the token
      var caretSelectionRange = [caretToken.stopIndex + 1, caretToken.stopIndex + 1];
      return this.getCandidates(caretToken, caretSelectionRange);
    }

    /**
     * Subclasses can override this method to assign contextual data to the provided `ruleSuggestions`.
     * For example, a grammar may return the following rule for the RHS of a simple boolean expression:
     * `loading === `
     * ```
     * {
     *   rhs: {
     *     matchedText: '',
     *     replacePosition: [16, 16],
     *     context: {}
     *   }
     * }
     * ```
     * The subclass can enrich this suggestion with the LHS variable reference. e.g.
     * ```
     * {
     *   rhs: {
     *     matchedText: '',
     *     replacePosition: [16, 16],
     *     context: {
     *       lhs: 'loading'
     *     }
     *   }
     * }
     * ```
     *
     * @param maybeCaretToken The token to retrieve autocomplete suggestions for. When undefined we
     * return suggestions for the beginning of the input.
     * @param rules Map of {@link RuleSuggestion} to assign context data to keyed by parser rule index.
     * @protected
     */
  }, {
    key: "assignRuleContextData",
    value: function assignRuleContextData(maybeCaretToken, rules) {
      return rules;
    }
  }]);
  return BaseAutocomplete;
}();