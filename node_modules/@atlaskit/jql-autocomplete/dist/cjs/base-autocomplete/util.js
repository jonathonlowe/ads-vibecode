"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMatchedText = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _Interval = require("antlr4ts/misc/Interval");
var getMatchedText = exports.getMatchedText = function getMatchedText(tokenStream, startTokenIndex, stopToken, caretSelectionRange) {
  var matchedText = tokenStream.getText(_Interval.Interval.of(startTokenIndex, stopToken.tokenIndex));
  var _caretSelectionRange = (0, _slicedToArray2.default)(caretSelectionRange, 1),
    caretStartPosition = _caretSelectionRange[0];
  var tokenStopPosition = stopToken.stopIndex + 1;

  // We only want to return the text preceding the caret. If our caret starts before our stop token
  // ends then we need to slice all the characters after the caret from our matched text.
  if (caretStartPosition < tokenStopPosition) {
    var end = caretStartPosition - tokenStopPosition;
    return matchedText.slice(0, end);
  }
  return matchedText;
};