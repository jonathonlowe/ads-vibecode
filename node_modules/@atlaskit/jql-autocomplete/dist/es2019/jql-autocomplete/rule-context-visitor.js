import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { JQLLexer, JQLParser } from '@atlaskit/jql-parser';
import { ORDER_BY_CLAUSE, WHERE_CLAUSE } from './constants';
import { getPositionFromParserRule, isOperator, normalizeText } from './util';
export class RuleContextVisitor {
  constructor(ruleSuggestion, ruleList, rule, tokenStream, maybeCaretToken) {
    _defineProperty(this, "visitJqlQuery", ctx => {
      const whereCtx = ctx.jqlWhere();
      const orderByCtx = ctx.jqlOrderBy();
      const ctxToVisit = this.getCtxToVisit([whereCtx, orderByCtx]);
      const ruleContext = {
        ...(ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(this))
      };
      if (this.rule === JQLParser.RULE_jqlField) {
        ruleContext.clause = this.ruleList.includes(JQLParser.RULE_jqlWhere) ? WHERE_CLAUSE : ORDER_BY_CLAUSE;
      }
      return ruleContext;
    });
    _defineProperty(this, "visitJqlWhere", ctx => {
      return ctx.jqlOrClause().accept(this);
    });
    _defineProperty(this, "visitJqlOrderBy", () => {
      return {};
    });
    _defineProperty(this, "visitJqlOrClause", ctx => {
      const ctxToVisit = this.getCtxToVisit(ctx.jqlAndClause());
      return {
        ...(ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(this))
      };
    });
    _defineProperty(this, "visitJqlAndClause", ctx => {
      const ctxToVisit = this.getCtxToVisit(ctx.jqlNotClause());
      return {
        ...(ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(this))
      };
    });
    _defineProperty(this, "visitJqlNotClause", ctx => {
      const ctxToVisit = this.getCtxToVisit([ctx.jqlNotClause(), ctx.jqlSubClause(), ctx.jqlTerminalClause()]);
      return {
        ...(ctxToVisit === null || ctxToVisit === void 0 ? void 0 : ctxToVisit.accept(this))
      };
    });
    _defineProperty(this, "visitJqlSubClause", ctx => {
      const orCtx = ctx.jqlOrClause();
      return {
        ...(orCtx === null || orCtx === void 0 ? void 0 : orCtx.accept(this))
      };
    });
    _defineProperty(this, "visitJqlTerminalClause", ctx => {
      const fieldCtx = ctx.jqlField();
      const rhsCtx = ctx.jqlTerminalClauseRhs();
      const {
        errorNodes,
        ...rhsRuleContext
      } = rhsCtx.accept(this);
      return {
        ...fieldCtx.accept(this),
        ...rhsRuleContext,
        ...this.getCtxFromErrorNodes(errorNodes)
      };
    });
    _defineProperty(this, "visitJqlField", ctx => {
      if (this.rule === JQLParser.RULE_jqlField) {
        return {};
      }
      return {
        field: this.tokenStream.getText(ctx)
      };
    });
    _defineProperty(this, "visitJqlNumberField", ctx => {
      return this.visitJqlField(ctx);
    });
    _defineProperty(this, "visitJqlNonNumberField", ctx => {
      return this.visitJqlField(ctx);
    });
    _defineProperty(this, "visitJqlEqualsClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlEqualsOperator().accept(this);
    });
    _defineProperty(this, "visitJqlEqualsOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlLikeClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlLikeOperator().accept(this);
    });
    _defineProperty(this, "visitJqlLikeOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlComparisonClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlComparisonOperator().accept(this);
    });
    _defineProperty(this, "visitJqlComparisonOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlInClause", ctx => {
      const operatorContext = ctx.jqlInOperator().accept(this);
      const listCtx = ctx.jqlList();
      if (listCtx !== undefined && this.isReplacePosAtCtx(listCtx)) {
        return {
          ...operatorContext,
          ...listCtx.accept(this)
        };
      }
      return {
        ...operatorContext
      };
    });
    _defineProperty(this, "visitJqlInOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlIsClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlIsOperator().accept(this);
    });
    _defineProperty(this, "visitJqlIsOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlWasClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlWasOperator().accept(this);
    });
    _defineProperty(this, "visitJqlWasOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlWasInClause", ctx => {
      const operatorContext = ctx.jqlWasInOperator().accept(this);
      const listCtx = ctx.jqlList();
      if (listCtx !== undefined && this.isReplacePosAtCtx(listCtx)) {
        return {
          ...operatorContext,
          ...listCtx.accept(this)
        };
      }
      return {
        ...operatorContext
      };
    });
    _defineProperty(this, "visitJqlWasInOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlChangedClause", ctx => {
      // We can skip visiting operand in this case as this clause type doesn't support list operands
      return ctx.jqlChangedOperator().accept(this);
    });
    _defineProperty(this, "visitJqlChangedOperator", ctx => {
      return this.visitOperator(ctx);
    });
    _defineProperty(this, "visitJqlList", ctx => {
      const [_, leftParenStop] = getPositionFromParserRule(ctx.jqlListStart());
      try {
        const [rightParenStart] = getPositionFromParserRule(ctx.jqlListEnd());
        if (this.replacePositionStart >= leftParenStop && this.replacePositionStart <= rightParenStart) {
          return {
            isList: true
          };
        }
      } catch (error) {
        // There are some queries (e.g. "project in (jsw jsd") where visiting `jqlListEnd` context
        // results in an error, as RPAREN token doesn't exist and parse tree contains an error node
        // that prevents ANTLR from recovering. For context purposes, this means we are inside the list.
        return {
          isList: true
        };
      }
      return {};
    });
    _defineProperty(this, "visitOperator", ctx => {
      // In some situations, e.g. "project was in|", autocomplete returns both operator and operand
      // rules as candidates. For the operand rule, we want to have "was" as operator in context, even
      // though the parse tree in this case says that the operator is "was in". For this reason, we
      // get text before replace position start and check if result is one of the supported operators.
      const textBeforeReplacePosition = this.tokenStream.getText(ctx).substring(0, this.replacePositionStart - ctx.start.startIndex);
      const maybeOperator = normalizeText(textBeforeReplacePosition);
      if (isOperator(maybeOperator)) {
        return {
          operator: maybeOperator
        };
      }
      return {};
    });
    /**
     * Returns whether replace position start for our candidate lies within the provided rule context,
     * or it's a whitespace token starting where the rule context ends. In those cases, we can assume
     * the provided rule context contains the relevant contextual data for our candidate rule.
     *
     * NOTE: This assumption is not airtight and there could be scenarios which violate this
     * assumption if we introduce new candidates or context nodes in the future.
     */
    _defineProperty(this, "isReplacePosAtCtx", ctx => {
      const [start, stop] = getPositionFromParserRule(ctx);
      return this.replacePositionStart >= start && this.replacePositionStart <= stop || !!this.maybeCaretToken && this.maybeCaretToken.type === JQLLexer.MATCHWS && this.maybeCaretToken.startIndex === stop;
    });
    /**
     * Given a list of parser rule contexts, this function returns which one should be visited
     * based on replace position start (i.e. the parser rule context that contains the relevant
     * information for our candidate rule).
     *
     * This can be called by visitor functions to select the adequate child rule context to visit,
     * for instance when we have multiple terminal clauses in a compound clause.
     */
    _defineProperty(this, "getCtxToVisit", contexts => {
      const definedContexts = contexts.filter(context => context !== undefined);
      for (let i = 0; i < definedContexts.length; i++) {
        const ctx = definedContexts[i];
        if (this.isReplacePosAtCtx(ctx)) {
          return ctx;
        }
      }
      return undefined;
    });
    /**
     * Recover from the clause type ambiguities described in {@link visitChildren}.
     */
    _defineProperty(this, "getCtxFromErrorNodes", errorNodes => {
      if (errorNodes !== undefined) {
        const textBeforeReplacePosition = errorNodes.filter(errorNode => errorNode.payload.startIndex < this.replacePositionStart).map(errorNode => errorNode.payload.text).join(' ');
        const maybeOperator = normalizeText(textBeforeReplacePosition);
        if (isOperator(maybeOperator)) {
          return {
            operator: maybeOperator
          };
        }
      }
      return {};
    });
    /**
     * If this function is called, it means parse tree contains error nodes. In some situations, this
     * is due to ambiguities we can recover from (e.g. "issuetype was ", which can be a WAS or WAS IN
     * clause). To help return the right context in these cases, we expose error nodes in the current
     * rule context, allowing upstream visitors to decide how to handle them.
     */
    _defineProperty(this, "visitChildren", node => {
      const errorNodes = [];
      for (let i = 0; i < node.childCount; i++) {
        errorNodes.push(node.getChild(i));
      }
      return {
        errorNodes
      };
    });
    _defineProperty(this, "visit", () => {
      throw new Error('Unsupported operation visit(ParseTree)');
    });
    _defineProperty(this, "visitErrorNode", () => {
      throw new Error('Unsupported operation visitErrorNode(ErrorNode)');
    });
    _defineProperty(this, "visitTerminal", () => {
      throw new Error('Unsupported operation visitTerminal(TerminalNode)');
    });
    this.ruleList = ruleList;
    this.rule = rule;
    this.tokenStream = tokenStream;
    this.maybeCaretToken = maybeCaretToken;
    [this.replacePositionStart] = ruleSuggestion.replacePosition;
  }
}