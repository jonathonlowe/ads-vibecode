"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useContentNodeDataProvidersSetup = useContentNodeDataProvidersSetup;
var _react = _interopRequireDefault(require("react"));
var _cache = require("../cache");
var _globalNdpCaches = require("./_global-ndp-caches");
var _lruCache = require("./_lru-cache");
/**
 * The settings for the data providers lru cache,
 * increasing the value will increase the number of data providers that can be stored in the cache.
 */
var lruCacheSettings = {
  page: 5,
  default: 1
};

/**
 * Sets up nodeview data providers for a content node.
 *
 * This will return the cached node data providers if they exist, otherwise it will call the provided getNodeDataProviders function.
 *
 * Note: Calling this has side effects where caches for the nodeview data providers will continue to be built
 * in the background after this resolves to a set of nodeview data providers that can be used.
 */
function useContentNodeDataProvidersSetup(content,
/**
 * Note: changes to this object will not be reflected in the cache.
 */
setupOptions) {
  var _globalNdpCachesContextValue = (0, _globalNdpCaches.useGlobalNdpCachesContext)();
  // Create a cache for the content type if it doesn't exist
  // While this will not result in any existing context consumers getting the updated value.
  // It will ensure that the cache is available for future consumers.
  if (_globalNdpCachesContextValue[content.contentType] === undefined) {
    var _lruCacheSettings$con;
    _globalNdpCachesContextValue[content.contentType] = new _lruCache.LRUCache((_lruCacheSettings$con = lruCacheSettings[content.contentType]) !== null && _lruCacheSettings$con !== void 0 ? _lruCacheSettings$con : lruCacheSettings.default);
  }
  var contentTypeNdpCaches = _globalNdpCachesContextValue[content.contentType];

  // The node data providers should only be rebuilt if the content changes
  // to avoid unnecessary rebuilding of the cache.
  // useRef is used over useMemo as use memo is not a guarantee that the value will be reused
  // - in development it can be called twice
  // - react have made clear that in future versions useMemo may add features that throw away the cache, and [recommend refs](https://react.dev/reference/react/useMemo#caveats) for this use case.
  var currentContentKey = "".concat(content.contentType, "-").concat(content.contentId);
  var contentKeyRef = _react.default.useRef();
  var nodeDataProvidersRef = _react.default.useRef();
  if (contentKeyRef.current !== currentContentKey) {
    contentKeyRef.current = currentContentKey;
    var cachedContentNdps = contentTypeNdpCaches === null || contentTypeNdpCaches === void 0 ? void 0 : contentTypeNdpCaches.get(content.contentId);
    var nodeDataProviders = cachedContentNdps || setupOptions.getNodeDataProviders();

    /**
     * Note: while this will remove old NodeDataProviders from the cache -- these are passed directly to consumers,
     * so removing from the cache will not result in actively used NodeDataProviders being deleted in some way.
     *
     */
    contentTypeNdpCaches.set(content.contentId, nodeDataProviders);
    (0, _cache.buildCaches)({
      adf: setupOptions.adfToUpdateWith,
      nodeDataProviders: nodeDataProviders,
      existingProvidersCache: setupOptions.existingProvidersCache
    }).then(function (warmedNodeDataProvidersCache) {
      var _setupOptions$onCache;
      (_setupOptions$onCache = setupOptions.onCacheWarmed) === null || _setupOptions$onCache === void 0 || _setupOptions$onCache.call(setupOptions, {
        warmedNodeDataProvidersCache: warmedNodeDataProvidersCache,
        nodeDataProviders: nodeDataProviders
      });
    });
    nodeDataProvidersRef.current = nodeDataProviders;
  }
  return nodeDataProvidersRef.current;
}