"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildCaches = buildCaches;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _traverse = require("@atlaskit/adf-utils/traverse");
// eslint-disable-next-line @typescript-eslint/no-unused-vars
// eslint-disable-next-line @typescript-eslint/no-explicit-any
/**
 * Builds {@link NodeDataProvider}s caches for a document.
 *
 * It will traverse the document and call the resolve method for each node.
 * When all promises are resolved, NodeDataProviders will have their caches populated.
 *
 * The providers will then be ready for use with an Editor.
 *
 * To limit the time spent building the cache, a signal can be provided to abort the request.
 *
 * ## Usage
 *
 * @example
 * ```ts
 * buildCaches({
 *  adf: doc,
 *  nodeDataProviders: { emoji: emojiNodeDataProvider, ... },
 *  signal: AbortSignal.timeout(5000),
 * });
 * ```
 *
 * ### Using caches
 *
 * To make use of a cache in another provider (ie. for a cache created on the server), you can retrieve the cache
 * from the provider and pass it to the new provider.
 *
 * @example
 * ```tsx
 * // SSR env
 * const ssrProvidersCaches = await buildCaches({adf, nodeDataProviders: { emoji }})
 *
 * // Client env (providersCaches is the cache from the server)
 * <ContentNodeDataProviders ... existingProvidersCache={ssrProvidersCaches} />
 * ```
 *
 * *Note:* On the client - buildCache is not expected to be used directly.
 *
 * @see {@link ContentNodeDataProviders} for expected client usage.
 */
function buildCaches(_x) {
  return _buildCaches.apply(this, arguments);
}
function _buildCaches() {
  _buildCaches = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {
    var adf, nodeDataProviders, _ref$signal, signal, existingProvidersCache, visitors, promises, _loop, _i, _Object$values, caches, _i2, _Object$values2, nodeDataProvider;
    return _regenerator.default.wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          adf = _ref.adf, nodeDataProviders = _ref.nodeDataProviders, _ref$signal = _ref.signal, signal = _ref$signal === void 0 ? new AbortController().signal : _ref$signal, existingProvidersCache = _ref.existingProvidersCache;
          visitors = {};
          promises = [];
          _loop = /*#__PURE__*/_regenerator.default.mark(function _loop() {
            var _nodeDataProvider, nodeDataProvider;
            return _regenerator.default.wrap(function _loop$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _nodeDataProvider = _Object$values[_i];
                  // widen type to avoid typescript errors with the specific node data provider types
                  nodeDataProvider = _nodeDataProvider;
                  if (existingProvidersCache && existingProvidersCache[nodeDataProvider.nodeName]) {
                    nodeDataProvider.updateCache(existingProvidersCache[nodeDataProvider.nodeName], {
                      strategy: 'merge-override'
                    });
                  }
                  visitors[nodeDataProvider.nodeName] = function (node) {
                    var result = nodeDataProvider.get(node, {
                      signal: signal
                    });
                    if (!isPromise(result)) {
                      nodeDataProvider.cache[nodeDataProvider.nodeToKey(node)] = result;
                      return;
                    }
                    promises.push(result);
                    result.then(function (resolvedValue) {
                      var signalAborted = signal ? signal.aborted : false;
                      if (!signalAborted && resolvedValue !== undefined) {
                        nodeDataProvider.cache[nodeDataProvider.nodeToKey(node)] = resolvedValue;
                      }
                    });
                    return undefined;
                  };
                case 4:
                case "end":
                  return _context.stop();
              }
            }, _loop);
          });
          _i = 0, _Object$values = Object.values(nodeDataProviders);
        case 5:
          if (!(_i < _Object$values.length)) {
            _context2.next = 10;
            break;
          }
          return _context2.delegateYield(_loop(), "t0", 7);
        case 7:
          _i++;
          _context2.next = 5;
          break;
        case 10:
          if (!adf) {
            _context2.next = 16;
            break;
          }
          (0, _traverse.traverse)(adf, visitors);
          _context2.next = 14;
          return Promise.all(promises);
        case 14:
          _context2.next = 18;
          break;
        case 16:
          _context2.next = 18;
          return Promise.resolve();
        case 18:
          caches = {};
          for (_i2 = 0, _Object$values2 = Object.values(nodeDataProviders); _i2 < _Object$values2.length; _i2++) {
            nodeDataProvider = _Object$values2[_i2];
            caches[nodeDataProvider.nodeName] = nodeDataProvider.cache;
          }
          return _context2.abrupt("return", caches);
        case 21:
        case "end":
          return _context2.stop();
      }
    }, _callee);
  }));
  return _buildCaches.apply(this, arguments);
}
function isPromise(obj) {
  return !!obj && ((0, _typeof2.default)(obj) === 'object' || typeof obj === 'function') &&
  // @ts-ignore
  typeof obj.then === 'function';
}