/**
 * This is the base class for creating a node data provider for an editor plugin.
 *
 * ## Usage
 *
 * ### Create a provider
 *
 * @example
 * ```ts
 * class EmojiNodeDataProvider extends NodeDataProvider<
 *  { attrs: EmojiAttributes },
 * { resolvedData: string }
 * > {
 *   constructor({ existingCache }?: { existingCache: Record<string, { resolvedData: string }> }) {
 *     super({ existingCache, nodeName: 'emoji' });
 *   }
 *   nodeToKey(node: { attrs: EmojiAttributes }): string {
 *     return `${node.attrs.shortName}-${node.attrs.text}-${node.attrs.id}`;
 *   }
 *   resolve(node: { attrs: EmojiAttributes }, _?: { signal: AbortSignal }) {
 *     return Promise.resolve({ resolvedData: 'resolved' });
 *   }
 * }
 * ```
 *
 * ### Use the provider
 *
 * @example
 * ```ts
 * const emojiNodeDataProvider = new EmojiNodeDataProvider();
 * ```
 *
 * ### Caching
 *
 * @see {@link buildCaches} for more information on building caches.
 *
 * #### Load an existing provider with a cache
 *
 * @example
 * ```
 * await buildCaches({
 *  adf: docFromSomewhere,
 *  nodeDataProviders: [emojiNodeDataProvider],
 *  signal: AbortSignal.timeout(5000),
 * });
 * emojiNodeDataProvider // { 'key': 'value' }
 * ```
 *
 * ### Load an new provider with an existing cache
 *
 * @example
 * ```
 * const provider1 = new ExampleNodeDataProvider();
 * await buildCaches({adf, nodeDataProviders: [provider1]})
 * provider1.cache // { 'key': 'value' }
 *
 * const provider2 = new ExampleNodeDataProvider({existingCache: provider1.cache});
 * ```
 */
export declare class NodeDataProvider<INode extends ReceivableNode, Result extends unknown> {
    /**
     * This is added to ease building types
     */
    __node: INode;
    private __cache;
    /**
     * This takes a node and returns a key that can be used to cache the result of the resolve function.
     */
    nodeToKey: (node: INode) => string;
    /**
     * This returns the information required to render a node.
     *
     * If unresolvable, this method will throw an error.
     *
     * If signal is aborted, this method will return undefined.
     */
    resolve: (node: INode, _?: {
        signal?: AbortSignal;
    }) => Promise<Result | undefined>;
    /**
     * The adf node name this provider is responsible for.
     */
    nodeName: string;
    constructor({ existingCache, nodeName, nodeToKey, resolve, }: {
        /**
         * A cache to load the provider with.
         *
         * @see {@link buildCaches} for more information on building caches.
         */
        existingCache?: Record<string, Result>;
        /**
         * The adf node name this provider is responsible for.
         *
         * It is used for;
         * - determining if the traverser should use this provider to resolve a node when building caches
         * - identifying the node when submitting analytics events via the helper react hooks
         */
        nodeName: string;
        nodeToKey: typeof NodeDataProvider.prototype.nodeToKey;
        resolve: typeof NodeDataProvider.prototype.resolve;
    });
    /**
     * Updates the providers cache.
     *
     * Useful in scenarios such as SSR where the cache is built on the server and then passed to the client.
     *
     * Avoids the need to provide the cache to the constructor (to allow decoupling creation of node data providers from cache building),
     * and allow for caching to be managed at a group level across multiple providers.
     *
     * This is not expected to be used by consumers, for internal consumption examples;
     * @see {@link buildCaches}
     *
     */
    updateCache(cache: Record<string, Result>, options: {
        strategy: 'merge-override' | 'replace';
    }): void;
    /**
     * This is the cache for the provider.
     */
    get cache(): Record<string, Result>;
    private pending;
    get(node: INode, _?: {
        signal: AbortSignal;
    }): Promise<Result | undefined> | Result;
}
export type ReceivableNode = {
    [key: string]: any;
    attrs: {
        [key: string]: any;
    };
};
export type ResolveOptions = {
    signal: AbortSignal;
};
