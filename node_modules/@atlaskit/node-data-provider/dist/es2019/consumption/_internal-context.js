import React from 'react';
import { buildCaches } from '../cache';
import { useGlobalNdpCachesContext } from './_global-ndp-caches';
import { LRUCache } from './_lru-cache';

/**
 * The settings for the data providers lru cache,
 * increasing the value will increase the number of data providers that can be stored in the cache.
 */
const lruCacheSettings = {
  page: 5,
  default: 1
};

/**
 * Sets up nodeview data providers for a content node.
 *
 * This will return the cached node data providers if they exist, otherwise it will call the provided getNodeDataProviders function.
 *
 * Note: Calling this has side effects where caches for the nodeview data providers will continue to be built
 * in the background after this resolves to a set of nodeview data providers that can be used.
 */
export function useContentNodeDataProvidersSetup(content,
/**
 * Note: changes to this object will not be reflected in the cache.
 */
setupOptions) {
  const _globalNdpCachesContextValue = useGlobalNdpCachesContext();
  // Create a cache for the content type if it doesn't exist
  // While this will not result in any existing context consumers getting the updated value.
  // It will ensure that the cache is available for future consumers.
  if (_globalNdpCachesContextValue[content.contentType] === undefined) {
    var _lruCacheSettings$con;
    _globalNdpCachesContextValue[content.contentType] = new LRUCache((_lruCacheSettings$con = lruCacheSettings[content.contentType]) !== null && _lruCacheSettings$con !== void 0 ? _lruCacheSettings$con : lruCacheSettings.default);
  }
  const contentTypeNdpCaches = _globalNdpCachesContextValue[content.contentType];

  // The node data providers should only be rebuilt if the content changes
  // to avoid unnecessary rebuilding of the cache.
  // useRef is used over useMemo as use memo is not a guarantee that the value will be reused
  // - in development it can be called twice
  // - react have made clear that in future versions useMemo may add features that throw away the cache, and [recommend refs](https://react.dev/reference/react/useMemo#caveats) for this use case.
  const currentContentKey = `${content.contentType}-${content.contentId}`;
  const contentKeyRef = React.useRef();
  const nodeDataProvidersRef = React.useRef();
  if (contentKeyRef.current !== currentContentKey) {
    contentKeyRef.current = currentContentKey;
    const cachedContentNdps = contentTypeNdpCaches === null || contentTypeNdpCaches === void 0 ? void 0 : contentTypeNdpCaches.get(content.contentId);
    const nodeDataProviders = cachedContentNdps || setupOptions.getNodeDataProviders();

    /**
     * Note: while this will remove old NodeDataProviders from the cache -- these are passed directly to consumers,
     * so removing from the cache will not result in actively used NodeDataProviders being deleted in some way.
     *
     */
    contentTypeNdpCaches.set(content.contentId, nodeDataProviders);
    buildCaches({
      adf: setupOptions.adfToUpdateWith,
      nodeDataProviders: nodeDataProviders,
      existingProvidersCache: setupOptions.existingProvidersCache
    }).then(warmedNodeDataProvidersCache => {
      var _setupOptions$onCache;
      (_setupOptions$onCache = setupOptions.onCacheWarmed) === null || _setupOptions$onCache === void 0 ? void 0 : _setupOptions$onCache.call(setupOptions, {
        warmedNodeDataProvidersCache,
        nodeDataProviders
      });
    });
    nodeDataProvidersRef.current = nodeDataProviders;
  }
  return nodeDataProvidersRef.current;
}