import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { TimeRangeWrapper as EmotionTimeRangeWrapper } from './styled-emotion';
import { TimeRangeWrapper as CompiledTimeRangeWrapper } from './styled-compiled';
import Range from '@atlaskit/range';
import { fg } from '@atlaskit/platform-feature-flags';
var increaseVolumeKeys = new Set(['ArrowRight', 'ArrowUp']);
var decreaseVolumeKeys = new Set(['ArrowLeft', 'ArrowDown']);
var VolumeRange = function VolumeRange(props) {
  var _props$isAlwaysActive = props.isAlwaysActive,
    isAlwaysActive = _props$isAlwaysActive === void 0 ? false : _props$isAlwaysActive,
    onChange = props.onChange,
    currentVolume = props.currentVolume,
    onChanged = props.onChanged,
    ariaLabel = props.ariaLabel;
  var wrapperElement = useRef(null);
  var mouseEventsSharedData = useRef({
    dragStartClientX: 0,
    isDragging: false
  });
  var _useState = useState(0),
    _useState2 = _slicedToArray(_useState, 2),
    wrapperElementWidth = _useState2[0],
    _setWrapperElementWidth = _useState2[1];
  var wrapperElementWidthRef = React.useRef(wrapperElementWidth);
  var setWrapperElementWidth = function setWrapperElementWidth(width) {
    wrapperElementWidthRef.current = width;
  };
  var setWrapperWidth = useCallback(function () {
    if (!wrapperElement.current) {
      return;
    }
    setWrapperElementWidth(wrapperElement.current.getBoundingClientRect().width);
  }, []);
  useEffect(function () {
    window.addEventListener('resize', setWrapperWidth);
    return function () {
      window.removeEventListener('resize', setWrapperWidth);
    };
  }, [setWrapperWidth]);
  var onMouseMove = function onMouseMove(e) {
    if (!mouseEventsSharedData.current.isDragging) {
      return;
    }
    e.stopPropagation();
    var onChange = props.onChange,
      currentVolume = props.currentVolume;
    var clientX = e.clientX;
    var absolutePosition = clientX - mouseEventsSharedData.current.dragStartClientX;
    var isOutsideToRight = absolutePosition > wrapperElementWidthRef.current;
    var isOutsideToLeft = absolutePosition < 0;

    // Next to conditions take care of situation where user moves mouse very quickly out to the side
    // left or right. It's very easy to leave thumb not at the end/beginning of a volume line.
    // This will guarantee that in this case thumb will move to appropriate extreme.
    if (isOutsideToRight) {
      absolutePosition = wrapperElementWidthRef.current;
    }
    if (isOutsideToLeft) {
      absolutePosition = 0;
    }
    var newVolumeWithBoundaries = absolutePosition / wrapperElementWidthRef.current;
    if (currentVolume !== newVolumeWithBoundaries) {
      // If value hasn't changed we don't want to call "change"
      onChange(newVolumeWithBoundaries);
    }
  };
  var _onMouseUp = function onMouseUp() {
    // As soon as user finished dragging, we should clean up events.
    document.removeEventListener('mouseup', _onMouseUp);
    document.removeEventListener('mousemove', onMouseMove);
    if (onChanged) {
      onChanged();
    }
    mouseEventsSharedData.current.isDragging = false;
  };
  var onThumbMouseDown = function onThumbMouseDown(e) {
    e.preventDefault();

    // We need to recalculate every time, because width can change (thanks, editor ;-)
    setWrapperWidth();

    // We are implementing drag and drop here. There is no reason to start listening for mouseUp or move
    // before that. Also if we start listening for mouseup before that we could pick up someone else's event
    // For example editors resizing of a inline video player.
    document.addEventListener('mouseup', _onMouseUp);
    document.addEventListener('mousemove', onMouseMove);
    var event = e.nativeEvent;
    var x = event.offsetX;
    var currentVolume = x / wrapperElementWidthRef.current;
    currentVolume = currentVolume > 0 ? currentVolume : 0;
    mouseEventsSharedData.current = {
      dragStartClientX: event.clientX - x,
      isDragging: true
    };
    // As soon as user clicks timeline we want to move thumb over to that place.
    onChange(currentVolume);
  };
  var onThumbKeyDown = function onThumbKeyDown(e) {
    var eventKey = e.key;
    var isShiftPressed = e.shiftKey;
    if (increaseVolumeKeys.has(eventKey) || decreaseVolumeKeys.has(eventKey)) {
      // preventDefault call is needed to keep the volume regulator focused(visible) in FireFox (Editor mode)
      e.preventDefault();
      var newVolume = currentVolume;
      if (increaseVolumeKeys.has(eventKey)) {
        newVolume += isShiftPressed ? 0.1 : 0.01;
      } else if (decreaseVolumeKeys.has(eventKey)) {
        newVolume -= isShiftPressed ? 0.1 : 0.01;
      }
      newVolume = newVolume > 1 ? 1 : newVolume;
      newVolume = newVolume < 0 ? 0 : newVolume;
      onChange(+newVolume.toPrecision(2));
      if (onChanged) {
        onChanged();
      }
    }
  };
  var onInputChange = function onInputChange(newVolume) {
    if (newVolume) {
      onChange(newVolume / 100);
      if (onChanged) {
        onChanged();
      }
    }
  };
  var currentPosition = currentVolume * 100;
  return fg('platform_media_compiled') ? /*#__PURE__*/React.createElement(CompiledTimeRangeWrapper, {
    onMouseDown: onThumbMouseDown,
    onKeyDown: onThumbKeyDown,
    ref: wrapperElement
  }, /*#__PURE__*/React.createElement(Range, {
    tabIndex: 0,
    step: 1,
    min: 0,
    max: 100,
    value: currentPosition,
    onChange: onInputChange,
    "aria-label": ariaLabel
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      width: '100%',
      cursor: 'pointer',
      height: '14px'
    }
  })) : /*#__PURE__*/React.createElement(EmotionTimeRangeWrapper, {
    showAsActive: isAlwaysActive,
    onMouseDown: onThumbMouseDown,
    onKeyDown: onThumbKeyDown,
    ref: wrapperElement
  }, /*#__PURE__*/React.createElement(Range, {
    tabIndex: 0,
    step: 1,
    min: 0,
    max: 100,
    value: currentPosition,
    onChange: onInputChange,
    "aria-label": ariaLabel
  }));
};
export default VolumeRange;