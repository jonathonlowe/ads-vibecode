/* index-compiled.tsx generated by @compiled/babel-plugin v0.36.1 */
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "./index-compiled.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable @atlaskit/design-system/ensure-design-token-usage */
// Keep media player components used in media-viewer to use static colors from the new color palette to
// support the hybrid theming in media viewer https://product-fabric.atlassian.net/browse/DSP-6067
import React from 'react';
import { Component } from 'react';
import PlayIcon from '@atlaskit/icon/core/migration/video-play--vid-play';
import PauseIcon from '@atlaskit/icon/core/migration/video-pause--vid-pause';
import FullScreenIconOn from '@atlaskit/icon/core/migration/fullscreen-enter--vid-full-screen-on';
import FullScreenIconOff from '@atlaskit/icon/core/migration/shrink-diagonal--vid-full-screen-off';
import SoundIcon from '@atlaskit/icon/core/migration/volume-high--hipchat-outgoing-sound';
import HDIcon from '@atlaskit/icon/glyph/vid-hd-circle';
import DownloadIcon from '@atlaskit/icon/core/migration/download';
import { Box, Flex } from '@atlaskit/primitives/compiled';
import MediaButton from '../MediaButton';
import Spinner from '@atlaskit/spinner';
import { WidthObserver } from '@atlaskit/width-detector';
import MediaPlayer from 'react-video-renderer';
import { N0, DN60 } from '@atlaskit/theme/colors';
import { TimeRange } from './timeRange';
import VolumeRange from './volumeRange';
import { CurrentTime, VolumeWrapper, LeftControls, RightControls, VolumeToggleWrapper, MutedIndicator, VolumeTimeRangeWrapper } from './styled';
import { ControlsWrapper } from './styled-compiled';
import { fireAnalyticsEvent, createCustomMediaPlayerScreenEvent, createMediaButtonClickedEvent, createMediaShortcutPressedEvent, createPlayPauseBlanketClickedEvent, createTimeRangeNavigatedEvent, createPlaybackSpeedChangedEvent, createFirstPlayedTrackEvent, createPlayedTrackEvent } from './analytics';
import { formatDuration } from '../formatDuration';
import { Shortcut, keyCodes } from '../shortcut';
import { toggleFullscreen, getFullscreenElement } from './fullscreen';
import { messages } from '../messages';
import simultaneousPlayManager from './simultaneousPlayManager';
import { TimeSaver } from './timeSaver';
import PlaybackSpeedControls from './playbackSpeedControls';
import { PlayPauseBlanket } from './playPauseBlanket';
import Tooltip from '@atlaskit/tooltip';
import { SkipTenBackwardIcon, SkipTenForwardIcon } from '@atlaskit/legacy-custom-icons';
import { fg } from '@atlaskit/platform-feature-flags';
import VideoSkipForwardTenIcon from '@atlaskit/icon/core/video-skip-forward-ten';
import VideoSkipBackwardTenIcon from '@atlaskit/icon/core/video-skip-backward-ten';
var MEDIUM_VIDEO_MAX_WIDTH = 400;
var SMALL_VIDEO_MAX_WIDTH = 160;
var MINIMUM_DURATION_BEFORE_SAVING_TIME = 60;
var VIEWED_TRACKING_SECS = 2;

/* Styles */

var timebarWrapperStyles = {
  root: "_kqswstnw _1bsb1osq _94n5u2gc"
};
var customVideoWrapperStyles = {
  root: "_1bsb1osq _4t3i1osq _uiztglyw"
};
var videoWrapperStyles = {
  root: "_1bsb1osq _4t3i1osq"
};
var timeWrapperStyles = {
  root: "_195gv47k _19pkze3t _otyr1jfw"
};
var spinnerWrapperStyles = {
  root: "_kqswstnw _154ize3t _1ltvze3t _1bsb1osq _4t3i1osq"
};
export var CustomMediaPlayerBase = /*#__PURE__*/function (_Component) {
  function CustomMediaPlayerBase() {
    var _this;
    _classCallCheck(this, CustomMediaPlayerBase);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, CustomMediaPlayerBase, [].concat(args));
    _defineProperty(_this, "videoWrapperRef", /*#__PURE__*/React.createRef());
    _defineProperty(_this, "videoState", {
      isLoading: true,
      buffered: 0,
      currentTime: 0,
      volume: 1,
      status: 'paused',
      duration: 0,
      isMuted: false
    });
    _defineProperty(_this, "wasPlayedOnce", false);
    _defineProperty(_this, "lastCurrentTime", 0);
    _defineProperty(_this, "timeSaver", new TimeSaver(_this.props.lastWatchTimeConfig));
    _defineProperty(_this, "state", {
      isFullScreenEnabled: false,
      playerSize: 'large',
      playbackSpeed: 1
    });
    _defineProperty(_this, "fireFirstPlayedTrackEvent", function () {
      var _this$props = _this.props,
        type = _this$props.type,
        fileId = _this$props.fileId,
        isHDActive = _this$props.isHDActive,
        isHDAvailable = _this$props.isHDAvailable,
        isAutoPlay = _this$props.isAutoPlay,
        createAnalyticsEvent = _this$props.createAnalyticsEvent;
      var _this$state = _this.state,
        isFullScreenEnabled = _this$state.isFullScreenEnabled,
        playerSize = _this$state.playerSize,
        playbackSpeed = _this$state.playbackSpeed;
      fireAnalyticsEvent(createFirstPlayedTrackEvent(type, {
        isAutoPlay: isAutoPlay,
        isHDAvailable: isHDAvailable,
        isHDActive: isHDActive,
        isFullScreenEnabled: isFullScreenEnabled,
        playerSize: playerSize,
        playbackSpeed: playbackSpeed
      }, fileId), createAnalyticsEvent);
    });
    _defineProperty(_this, "onFullScreenChange", function (e) {
      if (e.target !== _this.videoWrapperRef.current) {
        return;
      }
      var currentFullScreenMode = _this.state.isFullScreenEnabled;
      var isFullScreenEnabled = !!getFullscreenElement();
      if (currentFullScreenMode !== isFullScreenEnabled) {
        var _this$props$onFullscr, _this$props2;
        (_this$props$onFullscr = (_this$props2 = _this.props).onFullscreenChange) === null || _this$props$onFullscr === void 0 || _this$props$onFullscr.call(_this$props2, isFullScreenEnabled);
        _this.setState({
          isFullScreenEnabled: isFullScreenEnabled
        });
      }
    });
    _defineProperty(_this, "onTimeChanged", function () {
      _this.createAndFireUIEvent('timeRangeNavigate', 'time');
    });
    _defineProperty(_this, "onVolumeChanged", function () {
      _this.createAndFireUIEvent('volumeRangeNavigate', 'volume');
    });
    _defineProperty(_this, "onCurrentTimeChange", function (currentTime, duration) {
      if (duration - currentTime > MINIMUM_DURATION_BEFORE_SAVING_TIME) {
        _this.timeSaver.defaultTime = currentTime;
      } else {
        _this.timeSaver.defaultTime = 0;
      }
    });
    _defineProperty(_this, "renderCurrentTime", function (_ref) {
      var currentTime = _ref.currentTime,
        duration = _ref.duration;
      return /*#__PURE__*/React.createElement(CurrentTime, {
        draggable: false
      }, formatDuration(currentTime), " / ", formatDuration(duration));
    });
    _defineProperty(_this, "renderHDButton", function () {
      var _this$props3 = _this.props,
        type = _this$props3.type,
        isHDAvailable = _this$props3.isHDAvailable,
        isHDActive = _this$props3.isHDActive,
        onHDToggleClick = _this$props3.onHDToggleClick;
      if (type === 'audio' || !isHDAvailable) {
        return;
      }
      var primaryColor = isHDActive ? '#579DFF' : '#c7d1db';
      var secondaryColor = isHDActive ? N0 : DN60;
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-hd-button",
        onClick: !!onHDToggleClick ? _this.getMediaButtonClickHandler(onHDToggleClick, 'HDButton') : undefined,
        iconBefore:
        /*#__PURE__*/
        //TODO: https://product-fabric.atlassian.net/browse/DSP-20900
        // eslint-disable-next-line @atlaskit/design-system/no-legacy-icons
        React.createElement(HDIcon, {
          primaryColor: primaryColor,
          secondaryColor: secondaryColor,
          label: "hd"
        })
      });
    });
    _defineProperty(_this, "onPlaybackSpeedChange", function (playbackSpeed) {
      if (!_this.actions) {
        return;
      }
      _this.actions.setPlaybackSpeed(playbackSpeed);
      _this.setState({
        playbackSpeed: playbackSpeed
      });
      _this.createAndFireUIEvent('playbackSpeedChange');
    });
    _defineProperty(_this, "renderSpeedControls", function () {
      var playbackSpeed = _this.state.playbackSpeed;
      var originalDimensions = _this.props.originalDimensions;
      return /*#__PURE__*/React.createElement(PlaybackSpeedControls, {
        originalDimensions: originalDimensions,
        playbackSpeed: playbackSpeed,
        onPlaybackSpeedChange: _this.onPlaybackSpeedChange,
        onClick: function onClick() {
          return _this.createAndFireUIEvent('mediaButtonClick', 'playbackSpeedButton');
        }
      });
    });
    _defineProperty(_this, "renderVolume", function (videoState, actions, showSlider) {
      return /*#__PURE__*/React.createElement(VolumeWrapper, {
        showSlider: showSlider
      }, /*#__PURE__*/React.createElement(VolumeToggleWrapper, {
        isMuted: videoState.isMuted
      }, /*#__PURE__*/React.createElement(MutedIndicator, {
        isMuted: videoState.isMuted
      }), /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-volume-toggle-button",
        onClick: _this.getMediaButtonClickHandler(actions.toggleMute, 'muteButton'),
        iconBefore: /*#__PURE__*/React.createElement(SoundIcon, {
          color: "currentColor",
          label: _this.props.intl.formatMessage(messages.volumeMuteButtonAria)
        }),
        "aria-pressed": videoState.isMuted
      })), showSlider && /*#__PURE__*/React.createElement(VolumeTimeRangeWrapper, null, /*#__PURE__*/React.createElement(VolumeRange, {
        onChange: actions.setVolume,
        currentVolume: videoState.volume,
        isAlwaysActive: true,
        onChanged: _this.onVolumeChanged,
        ariaLabel: _this.props.intl.formatMessage(messages.volumeLevelControlAria)
      })));
    });
    _defineProperty(_this, "toggleFullscreen", function () {
      return _this.videoWrapperRef.current && toggleFullscreen(_this.videoWrapperRef.current);
    });
    _defineProperty(_this, "onFullScreenButtonClick", function () {
      _this.toggleFullscreen();
      _this.createAndFireUIEvent('mediaButtonClick', 'fullScreenButton');
    });
    _defineProperty(_this, "onResize", function (width) {
      if (width > MEDIUM_VIDEO_MAX_WIDTH) {
        _this.setState({
          playerSize: 'large'
        });
      } else if (width > SMALL_VIDEO_MAX_WIDTH) {
        _this.setState({
          playerSize: 'medium'
        });
      } else {
        _this.setState({
          playerSize: 'small'
        });
      }
    });
    _defineProperty(_this, "renderFullScreenButton", function () {
      var _this$props4 = _this.props,
        formatMessage = _this$props4.intl.formatMessage,
        type = _this$props4.type;
      if (type === 'audio') {
        return;
      }
      var isFullScreenEnabled = _this.state.isFullScreenEnabled;
      var icon = isFullScreenEnabled ? /*#__PURE__*/React.createElement(FullScreenIconOff, {
        color: "currentColor",
        label: formatMessage(messages.disable_fullscreen)
      }) : /*#__PURE__*/React.createElement(FullScreenIconOn, {
        color: "currentColor",
        label: formatMessage(messages.enable_fullscreen)
      });
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-fullscreen-button",
        onClick: _this.onFullScreenButtonClick,
        iconBefore: icon
      });
    });
    _defineProperty(_this, "renderDownloadButton", function () {
      var onDownloadClick = _this.props.onDownloadClick;
      if (!onDownloadClick) {
        return;
      }
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-download-button",
        onClick: _this.getMediaButtonClickHandler(onDownloadClick, 'downloadButton'),
        iconBefore: /*#__PURE__*/React.createElement(DownloadIcon, {
          color: "currentColor",
          label: "download"
        })
      });
    });
    _defineProperty(_this, "renderShortcuts", function (_ref2) {
      var togglePlayPauseAction = _ref2.togglePlayPauseAction,
        toggleMute = _ref2.toggleMute,
        skipBackward = _ref2.skipBackward,
        skipForward = _ref2.skipForward;
      var isShortcutEnabled = _this.props.isShortcutEnabled;
      var isFullScreenEnabled = _this.state.isFullScreenEnabled;
      var shortcuts = (isShortcutEnabled || isFullScreenEnabled) && [/*#__PURE__*/React.createElement(Shortcut, {
        key: "space-shortcut",
        code: keyCodes.space,
        handler: _this.getKeyboardShortcutHandler(togglePlayPauseAction, 'space')
      }), /*#__PURE__*/React.createElement(Shortcut, {
        key: "m-shortcut",
        code: keyCodes.m,
        handler: _this.getKeyboardShortcutHandler(toggleMute, 'mute')
      })];
      if (shortcuts && isFullScreenEnabled) {
        // Fullscreen shortcuts only. We don't want to override left/right keys in media-viewer settings
        shortcuts.push( /*#__PURE__*/React.createElement(Shortcut, {
          key: "skip-backward-shortcut",
          code: keyCodes.leftArrow,
          handler: _this.getKeyboardShortcutHandler(skipBackward, 'leftArrow')
        }));
        shortcuts.push( /*#__PURE__*/React.createElement(Shortcut, {
          key: "skip-forward-shortcut",
          code: keyCodes.rightArrow,
          handler: _this.getKeyboardShortcutHandler(skipForward, 'rightArrow')
        }));
      }
      return shortcuts;
    });
    _defineProperty(_this, "renderPlayPauseButton", function (isPlaying) {
      var formatMessage = _this.props.intl.formatMessage;
      var toggleButtonIcon = isPlaying ? /*#__PURE__*/React.createElement(PauseIcon, {
        spacing: "spacious",
        color: "currentColor",
        label: formatMessage(messages.pause)
      }) : /*#__PURE__*/React.createElement(PlayIcon, {
        spacing: "spacious",
        color: "currentColor",
        label: formatMessage(messages.play)
      });
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(isPlaying ? messages.pause : messages.play),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-play-toggle-button",
        "data-test-is-playing": isPlaying,
        iconBefore: toggleButtonIcon,
        onClick: isPlaying ? _this.pausePlayByButtonClick : _this.startPlayByButtonClick
      }));
    });
    _defineProperty(_this, "renderSkipBackwardButton", function (skipBackward) {
      var formatMessage = _this.props.intl.formatMessage;
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(messages.skipBackward),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-skip-backward-button",
        iconBefore: /*#__PURE__*/React.createElement(VideoSkipBackwardTenIcon, {
          spacing: "spacious",
          LEGACY_fallbackIcon: SkipTenBackwardIcon,
          label: formatMessage(messages.skipBackward)
        }),
        onClick: _this.getMediaButtonClickHandler(skipBackward, 'skipBackwardButton')
      }));
    });
    _defineProperty(_this, "renderSkipForwardButton", function (skipForward) {
      var formatMessage = _this.props.intl.formatMessage;
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(messages.skipForward),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-skip-forward-button",
        iconBefore: /*#__PURE__*/React.createElement(VideoSkipForwardTenIcon, {
          spacing: "spacious",
          LEGACY_fallbackIcon: SkipTenForwardIcon,
          label: formatMessage(messages.skipForward)
        }),
        onClick: _this.getMediaButtonClickHandler(skipForward, 'skipForwardButton')
      }));
    });
    _defineProperty(_this, "renderSpinner", function () {
      return /*#__PURE__*/React.createElement(Flex, {
        direction: "column",
        alignItems: "center",
        justifyContent: "center",
        xcss: spinnerWrapperStyles.root
      }, /*#__PURE__*/React.createElement(Spinner, {
        appearance: "invert",
        size: "large"
      }));
    });
    _defineProperty(_this, "pause", function () {
      if (_this.actions) {
        _this.actions.pause();
      }
    });
    _defineProperty(_this, "play", function () {
      var onFirstPlay = _this.props.onFirstPlay;
      if (_this.actions) {
        _this.actions.play();
      }
      simultaneousPlayManager.pauseOthers(_this);
      if (!_this.wasPlayedOnce && onFirstPlay) {
        _this.fireFirstPlayedTrackEvent();
        _this.wasPlayedOnce = true;
        onFirstPlay();
      }
    });
    _defineProperty(_this, "getMediaButtonClickHandler", function (action, buttonType) {
      return function () {
        action();
        _this.createAndFireUIEvent('mediaButtonClick', buttonType);
      };
    });
    _defineProperty(_this, "getKeyboardShortcutHandler", function (action, shortcutType) {
      return function () {
        var showControls = _this.props.showControls;
        action();
        if (showControls) {
          showControls();
        }
        _this.createAndFireUIEvent('shortcutPress', shortcutType);
      };
    });
    _defineProperty(_this, "onViewed", function (videoState) {
      var _this$props5 = _this.props,
        createAnalyticsEvent = _this$props5.createAnalyticsEvent,
        fileId = _this$props5.fileId,
        isAutoPlay = _this$props5.isAutoPlay,
        isHDAvailable = _this$props5.isHDAvailable,
        isHDActive = _this$props5.isHDActive,
        type = _this$props5.type;
      var _this$state2 = _this.state,
        isFullScreenEnabled = _this$state2.isFullScreenEnabled,
        playerSize = _this$state2.playerSize,
        playbackSpeed = _this$state2.playbackSpeed;
      var status = videoState.status,
        currentTime = videoState.currentTime;
      if (status === 'playing' && (currentTime < _this.lastCurrentTime || currentTime >= _this.lastCurrentTime + VIEWED_TRACKING_SECS)) {
        fireAnalyticsEvent(createPlayedTrackEvent(type, _objectSpread(_objectSpread({}, videoState), {}, {
          isAutoPlay: isAutoPlay,
          isHDAvailable: isHDAvailable,
          isHDActive: isHDActive,
          isFullScreenEnabled: isFullScreenEnabled,
          playerSize: playerSize,
          playbackSpeed: playbackSpeed
        }), fileId), createAnalyticsEvent);
        _this.lastCurrentTime = currentTime;
      }
    });
    _defineProperty(_this, "resetPendingPlayPauseToggleTimer", function () {
      if (_this.clickToTogglePlayTimeoutId !== undefined) {
        clearTimeout(_this.clickToTogglePlayTimeoutId);
      }
    });
    _defineProperty(_this, "doubleClickToFullscreen", function () {
      _this.resetPendingPlayPauseToggleTimer();
      _this.toggleFullscreen();
      // TODO Add an event similar to "playPauseBlanketClick" but for fullscreen trigger
    });
    _defineProperty(_this, "togglePlayByBlanketClick", function (action) {
      _this.resetPendingPlayPauseToggleTimer();
      _this.clickToTogglePlayTimeoutId = setTimeout(function () {
        action();
        _this.createAndFireUIEvent('playPauseBlanketClick');
      }, 200);
    });
    _defineProperty(_this, "startPlayByBlanketClick", function () {
      _this.togglePlayByBlanketClick(_this.play);
    });
    _defineProperty(_this, "pausePlayByBlanketClick", function () {
      _this.togglePlayByBlanketClick(_this.pause);
    });
    _defineProperty(_this, "startPlayByButtonClick", _this.getMediaButtonClickHandler(_this.play, 'playButton'));
    _defineProperty(_this, "pausePlayByButtonClick", _this.getMediaButtonClickHandler(_this.pause, 'pauseButton'));
    return _this;
  }
  _inherits(CustomMediaPlayerBase, _Component);
  return _createClass(CustomMediaPlayerBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props6 = this.props,
        type = _this$props6.type,
        fileId = _this$props6.fileId,
        isAutoPlay = _this$props6.isAutoPlay,
        isHDAvailable = _this$props6.isHDAvailable,
        isHDActive = _this$props6.isHDActive,
        onFirstPlay = _this$props6.onFirstPlay,
        createAnalyticsEvent = _this$props6.createAnalyticsEvent;
      var _this$state3 = this.state,
        isFullScreenEnabled = _this$state3.isFullScreenEnabled,
        playerSize = _this$state3.playerSize,
        playbackSpeed = _this$state3.playbackSpeed;
      fireAnalyticsEvent(createCustomMediaPlayerScreenEvent(type, {
        isAutoPlay: isAutoPlay,
        isHDAvailable: isHDAvailable,
        isHDActive: isHDActive,
        isFullScreenEnabled: isFullScreenEnabled,
        playerSize: playerSize,
        playbackSpeed: playbackSpeed
      }, fileId), createAnalyticsEvent);
      if (this.videoWrapperRef.current) {
        this.videoWrapperRef.current.addEventListener('fullscreenchange', this.onFullScreenChange);
      }
      simultaneousPlayManager.subscribe(this);
      if (isAutoPlay) {
        simultaneousPlayManager.pauseOthers(this);
        if (onFirstPlay) {
          this.fireFirstPlayedTrackEvent();
          this.wasPlayedOnce = true;
          onFirstPlay();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.videoWrapperRef.current) {
        this.videoWrapperRef.current.removeEventListener('fullscreenchange', this.onFullScreenChange);
      }
      if (this.state.isFullScreenEnabled) {
        var _this$props$onFullscr2, _this$props7;
        (_this$props$onFullscr2 = (_this$props7 = this.props).onFullscreenChange) === null || _this$props$onFullscr2 === void 0 || _this$props$onFullscr2.call(_this$props7, false);
      }
      simultaneousPlayManager.unsubscribe(this);
    }
  }, {
    key: "setActions",
    value: function setActions(actions) {
      // Actions are being sent constantly while the video is playing,
      // though play and pause functions are always the same objects
      if (!this.actions) {
        this.actions = actions;
      }
    }
  }, {
    key: "createAndFireUIEvent",
    value: function createAndFireUIEvent(eventType, actionSubjectId) {
      var _this$props8 = this.props,
        type = _this$props8.type,
        fileId = _this$props8.fileId,
        isHDActive = _this$props8.isHDActive,
        isHDAvailable = _this$props8.isHDAvailable,
        isAutoPlay = _this$props8.isAutoPlay,
        createAnalyticsEvent = _this$props8.createAnalyticsEvent;
      var _this$state4 = this.state,
        isFullScreenEnabled = _this$state4.isFullScreenEnabled,
        playerSize = _this$state4.playerSize,
        playbackSpeed = _this$state4.playbackSpeed;
      var playbackState = _objectSpread(_objectSpread({}, this.videoState), {}, {
        isAutoPlay: isAutoPlay,
        isHDAvailable: isHDAvailable,
        isHDActive: isHDActive,
        isFullScreenEnabled: isFullScreenEnabled,
        playerSize: playerSize,
        playbackSpeed: playbackSpeed
      });
      var analyticsEvent;
      switch (eventType) {
        case 'mediaButtonClick':
          analyticsEvent = createMediaButtonClickedEvent(type, playbackState, actionSubjectId, fileId);
          break;
        case 'shortcutPress':
          analyticsEvent = createMediaShortcutPressedEvent(type, playbackState, actionSubjectId, fileId);
          break;
        case 'playPauseBlanketClick':
          analyticsEvent = createPlayPauseBlanketClickedEvent(type, playbackState, fileId);
          break;
        case 'timeRangeNavigate':
        case 'volumeRangeNavigate':
          analyticsEvent = createTimeRangeNavigatedEvent(type, playbackState, actionSubjectId, fileId);
          break;
        case 'playbackSpeedChange':
          analyticsEvent = createPlaybackSpeedChangedEvent(type, playbackState, fileId);
          break;
        default:
          analyticsEvent = {
            eventType: 'ui',
            action: 'default',
            actionSubject: 'customMediaPlayer',
            attributes: {
              type: type
            }
          };
      }
      fireAnalyticsEvent(analyticsEvent, createAnalyticsEvent);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props9 = this.props,
        type = _this$props9.type,
        src = _this$props9.src,
        isAutoPlay = _this$props9.isAutoPlay,
        onCanPlay = _this$props9.onCanPlay,
        onError = _this$props9.onError,
        poster = _this$props9.poster,
        videoControlsWrapperRef = _this$props9.videoControlsWrapperRef;
      return /*#__PURE__*/React.createElement(Box, {
        xcss: customVideoWrapperStyles.root,
        ref: this.videoWrapperRef,
        testId: "custom-media-player"
      }, /*#__PURE__*/React.createElement(MediaPlayer, {
        sourceType: type,
        src: src,
        autoPlay: isAutoPlay,
        onCanPlay: onCanPlay,
        defaultTime: this.timeSaver.defaultTime,
        onTimeChange: this.onCurrentTimeChange,
        onError: onError,
        poster: poster
      }, function (video, videoState, actions) {
        _this2.onViewed(videoState);
        _this2.setActions(actions);
        //Video State(either prop or variable) is ReadOnly
        _this2.videoState = videoState;
        var status = videoState.status,
          currentTime = videoState.currentTime,
          buffered = videoState.buffered,
          duration = videoState.duration,
          isLoading = videoState.isLoading;
        var playerSize = _this2.state.playerSize;
        var isPlaying = status === 'playing';
        var isLargePlayer = playerSize === 'large';
        var isMediumPlayer = playerSize === 'medium';
        var defaultSkipAmount = 10;
        var skipBackward = function skipBackward() {
          var skipAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSkipAmount;
          var newTime = videoState.currentTime - skipAmount;
          actions.navigate(Math.max(newTime, 0));
        };
        var skipForward = function skipForward() {
          var skipAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSkipAmount;
          var newTime = videoState.currentTime + skipAmount;
          actions.navigate(Math.min(newTime, videoState.duration));
        };
        var shortcuts = _this2.renderShortcuts({
          togglePlayPauseAction: isPlaying ? _this2.pause : _this2.play,
          toggleMute: actions.toggleMute,
          skipBackward: skipBackward,
          skipForward: skipForward
        });
        return /*#__PURE__*/React.createElement(Flex, {
          direction: "column",
          xcss: videoWrapperStyles.root
        }, /*#__PURE__*/React.createElement(WidthObserver, {
          setWidth: _this2.onResize
        }), shortcuts, isLoading && _this2.renderSpinner(), /*#__PURE__*/React.createElement(PlayPauseBlanket, {
          onDoubleClick: _this2.doubleClickToFullscreen,
          onClick: isPlaying ? _this2.pausePlayByBlanketClick : _this2.startPlayByBlanketClick,
          "data-testid": "play-pause-blanket"
        }, video), /*#__PURE__*/React.createElement(ControlsWrapper, {
          ref: videoControlsWrapperRef,
          controlsHidden: _this2.wasPlayedOnce
        }, /*#__PURE__*/React.createElement(Box, {
          xcss: timeWrapperStyles.root
        }, /*#__PURE__*/React.createElement(TimeRange, {
          currentTime: currentTime,
          bufferedTime: buffered,
          duration: duration,
          onChange: actions.navigate,
          onChanged: _this2.onTimeChanged,
          disableThumbTooltip: true,
          skipBackward: skipBackward,
          skipForward: skipForward,
          isAlwaysActive: false
        })), /*#__PURE__*/React.createElement(Flex, {
          alignItems: "center",
          justifyContent: "space-between",
          xcss: timebarWrapperStyles.root
        }, /*#__PURE__*/React.createElement(LeftControls, null, _this2.renderPlayPauseButton(isPlaying), isLargePlayer && _this2.renderSkipBackwardButton(skipBackward), isLargePlayer && _this2.renderSkipForwardButton(skipForward), _this2.renderVolume(videoState, actions, isLargePlayer)), /*#__PURE__*/React.createElement(RightControls, null, (isMediumPlayer || isLargePlayer) && _this2.renderCurrentTime(videoState), isLargePlayer && !fg('platform_media_disable_video_640p_artifact_usage') && _this2.renderHDButton(), isLargePlayer && _this2.renderSpeedControls(), _this2.renderFullScreenButton(), isLargePlayer && _this2.renderDownloadButton()))));
      }));
    }
  }]);
}(Component);