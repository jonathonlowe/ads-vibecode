import _typeof from "@babel/runtime/helpers/typeof";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { SupportedImageMetaTag } from './types';
var XResolution = SupportedImageMetaTag.XResolution,
  YResolution = SupportedImageMetaTag.YResolution;
var loadImage;
export function readJPEGExifMetaData(file) {
  return new Promise( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {
      var module;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (loadImage) {
              _context.next = 5;
              break;
            }
            _context.next = 3;
            return import('blueimp-load-image');
          case 3:
            module = _context.sent;
            loadImage = module.default || module;
          case 5:
            loadImage.parseMetaData(file, function (data) {
              try {
                var tags = data && data.exif ? data.exif.getAll() : {};
                Object.keys(tags).forEach(function (key) {
                  var value = tags[key];
                  if (_typeof(value) === 'object' && (key === XResolution || key === YResolution) && 'numerator' in value) {
                    // some test images had this structure, so just take the numerator value to simplify returned value
                    tags[key] = value.numerator;
                  }
                  if (typeof tags[key] === 'number') {
                    // in case numbers types were auto-converted, keep everything the same between jpeg & png we keep as strings
                    tags[key] = "".concat(tags[key]);
                  }
                });
                resolve(tags);
              } catch (e) {
                reject(e);
              }
            });
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
}