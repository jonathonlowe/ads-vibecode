import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { fileToArrayBuffer } from '../util';
var pngChunksExtract;
export function readPNGXMPMetaData(_x) {
  return _readPNGXMPMetaData.apply(this, arguments);
}
function _readPNGXMPMetaData() {
  _readPNGXMPMetaData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {
    var module, buffer, chunks;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (pngChunksExtract) {
            _context.next = 5;
            break;
          }
          _context.next = 3;
          return import('png-chunks-extract');
        case 3:
          module = _context.sent;
          pngChunksExtract = module.default || module;
        case 5:
          _context.next = 7;
          return fileToArrayBuffer(file);
        case 7:
          buffer = _context.sent;
          chunks = pngChunksExtract(buffer);
          _context.next = 11;
          return parsePNGChunks(chunks);
        case 11:
          return _context.abrupt("return", _context.sent);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _readPNGXMPMetaData.apply(this, arguments);
}
export function parsePNGChunks(_x2) {
  return _parsePNGChunks.apply(this, arguments);
}
function _parsePNGChunks() {
  _parsePNGChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chunks) {
    var iTXt, pHYs, i, chunk, dv, unitSpecifier, PixelPerUnitX, PixelPerUnitY;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          iTXt = '';
          pHYs = {};
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Summary-of-standard-chunks
           * Order of every chunk is not guaranteed.
           * And both iTXt and pHYs are Ancillary chunks.
           */
          i = 0;
        case 3:
          if (!(i < chunks.length)) {
            _context2.next = 12;
            break;
          }
          chunk = chunks[i]; // Must be last
          if (!(chunk.name === 'IEND')) {
            _context2.next = 7;
            break;
          }
          return _context2.abrupt("break", 12);
        case 7:
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Anc-text
           * iTXt contains the useful XMP/XML string data of meta tags
           */
          if (chunk.name === 'iTXt') {
            iTXt = String.fromCharCode.apply(null, Array.from(chunk.data));
          }
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.pHYs
           * Pixels per unit, X axis: 4 bytes (unsigned integer)
           * Pixels per unit, Y axis: 4 bytes (unsigned integer)
           * Unit specifier:          1 byte  (0: unit is unknown 1: unit is the meter)
           */
          if (chunk.name === 'pHYs') {
            dv = new DataView(chunk.data.buffer);
            unitSpecifier = dv.getUint8(8); // meter
            if (unitSpecifier === 1) {
              PixelPerUnitX = dv.getUint32(0);
              PixelPerUnitY = dv.getUint32(4);
              pHYs = {
                PixelPerUnitX: PixelPerUnitX,
                PixelPerUnitY: PixelPerUnitY
              };
            }
          }
        case 9:
          ++i;
          _context2.next = 3;
          break;
        case 12:
          return _context2.abrupt("return", {
            iTXt: iTXt,
            pHYs: pHYs
          });
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _parsePNGChunks.apply(this, arguments);
}