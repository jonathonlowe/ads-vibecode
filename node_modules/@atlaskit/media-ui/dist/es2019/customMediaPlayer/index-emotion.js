import _defineProperty from "@babel/runtime/helpers/defineProperty";
/* eslint-disable @atlaskit/design-system/ensure-design-token-usage */
// Keep media player components used in media-viewer to use static colors from the new color palette to
// support the hybrid theming in media viewer https://product-fabric.atlassian.net/browse/DSP-6067
import React from 'react';
import { Component } from 'react';
import PlayIcon from '@atlaskit/icon/core/migration/video-play--vid-play';
import PauseIcon from '@atlaskit/icon/core/migration/video-pause--vid-pause';
import FullScreenIconOn from '@atlaskit/icon/core/migration/fullscreen-enter--vid-full-screen-on';
import FullScreenIconOff from '@atlaskit/icon/core/migration/shrink-diagonal--vid-full-screen-off';
import SoundIcon from '@atlaskit/icon/core/migration/volume-high--hipchat-outgoing-sound';
import HDIcon from '@atlaskit/icon/glyph/vid-hd-circle';
import DownloadIcon from '@atlaskit/icon/core/migration/download';
import { xcss, Box, Flex } from '@atlaskit/primitives';
import MediaButton from '../MediaButton';
import Spinner from '@atlaskit/spinner';
import { WidthObserver } from '@atlaskit/width-detector';
import MediaPlayer from 'react-video-renderer';
import { N0, DN60 } from '@atlaskit/theme/colors';
import { TimeRange } from './timeRange';
import VolumeRange from './volumeRange';
import { CurrentTime, VolumeWrapper, LeftControls, RightControls, VolumeToggleWrapper, MutedIndicator, VolumeTimeRangeWrapper } from './styled';
import { ControlsWrapper } from './styled-emotion';
import { fireAnalyticsEvent, createCustomMediaPlayerScreenEvent, createMediaButtonClickedEvent, createMediaShortcutPressedEvent, createPlayPauseBlanketClickedEvent, createTimeRangeNavigatedEvent, createPlaybackSpeedChangedEvent, createFirstPlayedTrackEvent, createPlayedTrackEvent } from './analytics';
import { formatDuration } from '../formatDuration';
import { Shortcut, keyCodes } from '../shortcut';
import { toggleFullscreen, getFullscreenElement } from './fullscreen';
import { messages } from '../messages';
import simultaneousPlayManager from './simultaneousPlayManager';
import { TimeSaver } from './timeSaver';
import PlaybackSpeedControls from './playbackSpeedControls';
import { PlayPauseBlanket } from './playPauseBlanket';
import Tooltip from '@atlaskit/tooltip';
import { SkipTenBackwardIcon, SkipTenForwardIcon } from '@atlaskit/legacy-custom-icons';
import { getControlsWrapperClassName } from './getControlsWrapperClassName';
import { fg } from '@atlaskit/platform-feature-flags';
import VideoSkipForwardTenIcon from '@atlaskit/icon/core/video-skip-forward-ten';
import VideoSkipBackwardTenIcon from '@atlaskit/icon/core/video-skip-backward-ten';
const MEDIUM_VIDEO_MAX_WIDTH = 400;
const SMALL_VIDEO_MAX_WIDTH = 160;
const MINIMUM_DURATION_BEFORE_SAVING_TIME = 60;
const VIEWED_TRACKING_SECS = 2;

/* Styles */

const timebarWrapperStyles = xcss({
  position: 'absolute',
  width: '100%',
  bottom: 'space.100'
});
const customVideoWrapperStyles = xcss({
  width: '100%',
  height: '100%',
  userSelect: 'none'
});
const videoWrapperStyles = xcss({
  width: '100%',
  height: '100%'
});
const timeWrapperStyles = xcss({
  marginTop: 'space.0',
  marginInline: 'space.250',
  marginBottom: 'space.500'
});
const spinnerWrapperStyles = xcss({
  position: 'absolute',
  top: 'space.0',
  left: 'space.0',
  width: '100%',
  height: '100%'
});
export class CustomMediaPlayerBase extends Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "videoWrapperRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "videoState", {
      isLoading: true,
      buffered: 0,
      currentTime: 0,
      volume: 1,
      status: 'paused',
      duration: 0,
      isMuted: false
    });
    _defineProperty(this, "wasPlayedOnce", false);
    _defineProperty(this, "lastCurrentTime", 0);
    _defineProperty(this, "timeSaver", new TimeSaver(this.props.lastWatchTimeConfig));
    _defineProperty(this, "state", {
      isFullScreenEnabled: false,
      playerSize: 'large',
      playbackSpeed: 1
    });
    _defineProperty(this, "fireFirstPlayedTrackEvent", () => {
      const {
        type,
        fileId,
        isHDActive,
        isHDAvailable,
        isAutoPlay,
        createAnalyticsEvent
      } = this.props;
      const {
        isFullScreenEnabled,
        playerSize,
        playbackSpeed
      } = this.state;
      fireAnalyticsEvent(createFirstPlayedTrackEvent(type, {
        isAutoPlay,
        isHDAvailable,
        isHDActive,
        isFullScreenEnabled,
        playerSize,
        playbackSpeed
      }, fileId), createAnalyticsEvent);
    });
    _defineProperty(this, "onFullScreenChange", e => {
      if (e.target !== this.videoWrapperRef.current) {
        return;
      }
      const {
        isFullScreenEnabled: currentFullScreenMode
      } = this.state;
      const isFullScreenEnabled = !!getFullscreenElement();
      if (currentFullScreenMode !== isFullScreenEnabled) {
        var _this$props$onFullscr, _this$props;
        (_this$props$onFullscr = (_this$props = this.props).onFullscreenChange) === null || _this$props$onFullscr === void 0 ? void 0 : _this$props$onFullscr.call(_this$props, isFullScreenEnabled);
        this.setState({
          isFullScreenEnabled
        });
      }
    });
    _defineProperty(this, "onTimeChanged", () => {
      this.createAndFireUIEvent('timeRangeNavigate', 'time');
    });
    _defineProperty(this, "onVolumeChanged", () => {
      this.createAndFireUIEvent('volumeRangeNavigate', 'volume');
    });
    _defineProperty(this, "onCurrentTimeChange", (currentTime, duration) => {
      if (duration - currentTime > MINIMUM_DURATION_BEFORE_SAVING_TIME) {
        this.timeSaver.defaultTime = currentTime;
      } else {
        this.timeSaver.defaultTime = 0;
      }
    });
    _defineProperty(this, "renderCurrentTime", ({
      currentTime,
      duration
    }) => /*#__PURE__*/React.createElement(CurrentTime, {
      draggable: false
    }, formatDuration(currentTime), " / ", formatDuration(duration)));
    _defineProperty(this, "renderHDButton", () => {
      const {
        type,
        isHDAvailable,
        isHDActive,
        onHDToggleClick
      } = this.props;
      if (type === 'audio' || !isHDAvailable) {
        return;
      }
      const primaryColor = isHDActive ? '#579DFF' : '#c7d1db';
      const secondaryColor = isHDActive ? N0 : DN60;
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-hd-button",
        onClick: !!onHDToggleClick ? this.getMediaButtonClickHandler(onHDToggleClick, 'HDButton') : undefined,
        iconBefore:
        /*#__PURE__*/
        //TODO: https://product-fabric.atlassian.net/browse/DSP-20900
        // eslint-disable-next-line @atlaskit/design-system/no-legacy-icons
        React.createElement(HDIcon, {
          primaryColor: primaryColor,
          secondaryColor: secondaryColor,
          label: "hd"
        })
      });
    });
    _defineProperty(this, "onPlaybackSpeedChange", playbackSpeed => {
      if (!this.actions) {
        return;
      }
      this.actions.setPlaybackSpeed(playbackSpeed);
      this.setState({
        playbackSpeed
      });
      this.createAndFireUIEvent('playbackSpeedChange');
    });
    _defineProperty(this, "renderSpeedControls", () => {
      const {
        playbackSpeed
      } = this.state;
      const {
        originalDimensions
      } = this.props;
      return /*#__PURE__*/React.createElement(PlaybackSpeedControls, {
        originalDimensions: originalDimensions,
        playbackSpeed: playbackSpeed,
        onPlaybackSpeedChange: this.onPlaybackSpeedChange,
        onClick: () => this.createAndFireUIEvent('mediaButtonClick', 'playbackSpeedButton')
      });
    });
    _defineProperty(this, "renderVolume", (videoState, actions, showSlider) => /*#__PURE__*/React.createElement(VolumeWrapper, {
      showSlider: showSlider
    }, /*#__PURE__*/React.createElement(VolumeToggleWrapper, {
      isMuted: videoState.isMuted
    }, /*#__PURE__*/React.createElement(MutedIndicator, {
      isMuted: videoState.isMuted
    }), /*#__PURE__*/React.createElement(MediaButton, {
      testId: "custom-media-player-volume-toggle-button",
      onClick: this.getMediaButtonClickHandler(actions.toggleMute, 'muteButton'),
      iconBefore: /*#__PURE__*/React.createElement(SoundIcon, {
        color: "currentColor",
        label: this.props.intl.formatMessage(messages.volumeMuteButtonAria)
      }),
      "aria-pressed": videoState.isMuted
    })), showSlider && /*#__PURE__*/React.createElement(VolumeTimeRangeWrapper, null, /*#__PURE__*/React.createElement(VolumeRange, {
      onChange: actions.setVolume,
      currentVolume: videoState.volume,
      isAlwaysActive: true,
      onChanged: this.onVolumeChanged,
      ariaLabel: this.props.intl.formatMessage(messages.volumeLevelControlAria)
    }))));
    _defineProperty(this, "toggleFullscreen", () => this.videoWrapperRef.current && toggleFullscreen(this.videoWrapperRef.current));
    _defineProperty(this, "onFullScreenButtonClick", () => {
      this.toggleFullscreen();
      this.createAndFireUIEvent('mediaButtonClick', 'fullScreenButton');
    });
    _defineProperty(this, "onResize", width => {
      if (width > MEDIUM_VIDEO_MAX_WIDTH) {
        this.setState({
          playerSize: 'large'
        });
      } else if (width > SMALL_VIDEO_MAX_WIDTH) {
        this.setState({
          playerSize: 'medium'
        });
      } else {
        this.setState({
          playerSize: 'small'
        });
      }
    });
    _defineProperty(this, "renderFullScreenButton", () => {
      const {
        intl: {
          formatMessage
        },
        type
      } = this.props;
      if (type === 'audio') {
        return;
      }
      const {
        isFullScreenEnabled
      } = this.state;
      const icon = isFullScreenEnabled ? /*#__PURE__*/React.createElement(FullScreenIconOff, {
        color: "currentColor",
        label: formatMessage(messages.disable_fullscreen)
      }) : /*#__PURE__*/React.createElement(FullScreenIconOn, {
        color: "currentColor",
        label: formatMessage(messages.enable_fullscreen)
      });
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-fullscreen-button",
        onClick: this.onFullScreenButtonClick,
        iconBefore: icon
      });
    });
    _defineProperty(this, "renderDownloadButton", () => {
      const {
        onDownloadClick
      } = this.props;
      if (!onDownloadClick) {
        return;
      }
      return /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-download-button",
        onClick: this.getMediaButtonClickHandler(onDownloadClick, 'downloadButton'),
        iconBefore: /*#__PURE__*/React.createElement(DownloadIcon, {
          color: "currentColor",
          label: "download"
        })
      });
    });
    _defineProperty(this, "renderShortcuts", ({
      togglePlayPauseAction,
      toggleMute,
      skipBackward,
      skipForward
    }) => {
      const {
        isShortcutEnabled
      } = this.props;
      const {
        isFullScreenEnabled
      } = this.state;
      const shortcuts = (isShortcutEnabled || isFullScreenEnabled) && [/*#__PURE__*/React.createElement(Shortcut, {
        key: "space-shortcut",
        code: keyCodes.space,
        handler: this.getKeyboardShortcutHandler(togglePlayPauseAction, 'space')
      }), /*#__PURE__*/React.createElement(Shortcut, {
        key: "m-shortcut",
        code: keyCodes.m,
        handler: this.getKeyboardShortcutHandler(toggleMute, 'mute')
      })];
      if (shortcuts && isFullScreenEnabled) {
        // Fullscreen shortcuts only. We don't want to override left/right keys in media-viewer settings
        shortcuts.push( /*#__PURE__*/React.createElement(Shortcut, {
          key: "skip-backward-shortcut",
          code: keyCodes.leftArrow,
          handler: this.getKeyboardShortcutHandler(skipBackward, 'leftArrow')
        }));
        shortcuts.push( /*#__PURE__*/React.createElement(Shortcut, {
          key: "skip-forward-shortcut",
          code: keyCodes.rightArrow,
          handler: this.getKeyboardShortcutHandler(skipForward, 'rightArrow')
        }));
      }
      return shortcuts;
    });
    _defineProperty(this, "renderPlayPauseButton", isPlaying => {
      const {
        intl: {
          formatMessage
        }
      } = this.props;
      const toggleButtonIcon = isPlaying ? /*#__PURE__*/React.createElement(PauseIcon, {
        spacing: "spacious",
        color: "currentColor",
        label: formatMessage(messages.pause)
      }) : /*#__PURE__*/React.createElement(PlayIcon, {
        spacing: "spacious",
        color: "currentColor",
        label: formatMessage(messages.play)
      });
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(isPlaying ? messages.pause : messages.play),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-play-toggle-button",
        "data-test-is-playing": isPlaying,
        iconBefore: toggleButtonIcon,
        onClick: isPlaying ? this.pausePlayByButtonClick : this.startPlayByButtonClick
      }));
    });
    _defineProperty(this, "renderSkipBackwardButton", skipBackward => {
      const {
        intl: {
          formatMessage
        }
      } = this.props;
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(messages.skipBackward),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-skip-backward-button",
        iconBefore: /*#__PURE__*/React.createElement(VideoSkipBackwardTenIcon, {
          spacing: "spacious",
          LEGACY_fallbackIcon: SkipTenBackwardIcon,
          label: formatMessage(messages.skipBackward)
        }),
        onClick: this.getMediaButtonClickHandler(skipBackward, 'skipBackwardButton')
      }));
    });
    _defineProperty(this, "renderSkipForwardButton", skipForward => {
      const {
        intl: {
          formatMessage
        }
      } = this.props;
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: formatMessage(messages.skipForward),
        position: "top"
      }, /*#__PURE__*/React.createElement(MediaButton, {
        testId: "custom-media-player-skip-forward-button",
        iconBefore: /*#__PURE__*/React.createElement(VideoSkipForwardTenIcon, {
          spacing: "spacious",
          LEGACY_fallbackIcon: SkipTenForwardIcon,
          label: formatMessage(messages.skipForward)
        }),
        onClick: this.getMediaButtonClickHandler(skipForward, 'skipForwardButton')
      }));
    });
    _defineProperty(this, "renderSpinner", () => /*#__PURE__*/React.createElement(Flex, {
      direction: "column",
      alignItems: "center",
      justifyContent: "center",
      xcss: spinnerWrapperStyles
    }, /*#__PURE__*/React.createElement(Spinner, {
      appearance: "invert",
      size: "large"
    })));
    _defineProperty(this, "pause", () => {
      if (this.actions) {
        this.actions.pause();
      }
    });
    _defineProperty(this, "play", () => {
      const {
        onFirstPlay
      } = this.props;
      if (this.actions) {
        this.actions.play();
      }
      simultaneousPlayManager.pauseOthers(this);
      if (!this.wasPlayedOnce && onFirstPlay) {
        this.fireFirstPlayedTrackEvent();
        this.wasPlayedOnce = true;
        onFirstPlay();
      }
    });
    _defineProperty(this, "getMediaButtonClickHandler", (action, buttonType) => () => {
      action();
      this.createAndFireUIEvent('mediaButtonClick', buttonType);
    });
    _defineProperty(this, "getKeyboardShortcutHandler", (action, shortcutType) => () => {
      const {
        showControls
      } = this.props;
      action();
      if (showControls) {
        showControls();
      }
      this.createAndFireUIEvent('shortcutPress', shortcutType);
    });
    _defineProperty(this, "onViewed", videoState => {
      const {
        createAnalyticsEvent,
        fileId,
        isAutoPlay,
        isHDAvailable,
        isHDActive,
        type
      } = this.props;
      const {
        isFullScreenEnabled,
        playerSize,
        playbackSpeed
      } = this.state;
      const {
        status,
        currentTime
      } = videoState;
      if (status === 'playing' && (currentTime < this.lastCurrentTime || currentTime >= this.lastCurrentTime + VIEWED_TRACKING_SECS)) {
        fireAnalyticsEvent(createPlayedTrackEvent(type, {
          ...videoState,
          isAutoPlay,
          isHDAvailable,
          isHDActive,
          isFullScreenEnabled,
          playerSize,
          playbackSpeed
        }, fileId), createAnalyticsEvent);
        this.lastCurrentTime = currentTime;
      }
    });
    _defineProperty(this, "resetPendingPlayPauseToggleTimer", () => {
      if (this.clickToTogglePlayTimeoutId !== undefined) {
        clearTimeout(this.clickToTogglePlayTimeoutId);
      }
    });
    _defineProperty(this, "doubleClickToFullscreen", () => {
      this.resetPendingPlayPauseToggleTimer();
      this.toggleFullscreen();
      // TODO Add an event similar to "playPauseBlanketClick" but for fullscreen trigger
    });
    _defineProperty(this, "togglePlayByBlanketClick", action => {
      this.resetPendingPlayPauseToggleTimer();
      this.clickToTogglePlayTimeoutId = setTimeout(() => {
        action();
        this.createAndFireUIEvent('playPauseBlanketClick');
      }, 200);
    });
    _defineProperty(this, "startPlayByBlanketClick", () => {
      this.togglePlayByBlanketClick(this.play);
    });
    _defineProperty(this, "pausePlayByBlanketClick", () => {
      this.togglePlayByBlanketClick(this.pause);
    });
    _defineProperty(this, "startPlayByButtonClick", this.getMediaButtonClickHandler(this.play, 'playButton'));
    _defineProperty(this, "pausePlayByButtonClick", this.getMediaButtonClickHandler(this.pause, 'pauseButton'));
  }
  componentDidMount() {
    const {
      type,
      fileId,
      isAutoPlay,
      isHDAvailable,
      isHDActive,
      onFirstPlay,
      createAnalyticsEvent
    } = this.props;
    const {
      isFullScreenEnabled,
      playerSize,
      playbackSpeed
    } = this.state;
    fireAnalyticsEvent(createCustomMediaPlayerScreenEvent(type, {
      isAutoPlay,
      isHDAvailable,
      isHDActive,
      isFullScreenEnabled,
      playerSize,
      playbackSpeed
    }, fileId), createAnalyticsEvent);
    if (this.videoWrapperRef.current) {
      this.videoWrapperRef.current.addEventListener('fullscreenchange', this.onFullScreenChange);
    }
    simultaneousPlayManager.subscribe(this);
    if (isAutoPlay) {
      simultaneousPlayManager.pauseOthers(this);
      if (onFirstPlay) {
        this.fireFirstPlayedTrackEvent();
        this.wasPlayedOnce = true;
        onFirstPlay();
      }
    }
  }
  componentWillUnmount() {
    if (this.videoWrapperRef.current) {
      this.videoWrapperRef.current.removeEventListener('fullscreenchange', this.onFullScreenChange);
    }
    if (this.state.isFullScreenEnabled) {
      var _this$props$onFullscr2, _this$props2;
      (_this$props$onFullscr2 = (_this$props2 = this.props).onFullscreenChange) === null || _this$props$onFullscr2 === void 0 ? void 0 : _this$props$onFullscr2.call(_this$props2, false);
    }
    simultaneousPlayManager.unsubscribe(this);
  }
  setActions(actions) {
    // Actions are being sent constantly while the video is playing,
    // though play and pause functions are always the same objects
    if (!this.actions) {
      this.actions = actions;
    }
  }
  createAndFireUIEvent(eventType, actionSubjectId) {
    const {
      type,
      fileId,
      isHDActive,
      isHDAvailable,
      isAutoPlay,
      createAnalyticsEvent
    } = this.props;
    const {
      isFullScreenEnabled,
      playerSize,
      playbackSpeed
    } = this.state;
    const playbackState = {
      ...this.videoState,
      isAutoPlay,
      isHDAvailable,
      isHDActive,
      isFullScreenEnabled,
      playerSize,
      playbackSpeed
    };
    let analyticsEvent;
    switch (eventType) {
      case 'mediaButtonClick':
        analyticsEvent = createMediaButtonClickedEvent(type, playbackState, actionSubjectId, fileId);
        break;
      case 'shortcutPress':
        analyticsEvent = createMediaShortcutPressedEvent(type, playbackState, actionSubjectId, fileId);
        break;
      case 'playPauseBlanketClick':
        analyticsEvent = createPlayPauseBlanketClickedEvent(type, playbackState, fileId);
        break;
      case 'timeRangeNavigate':
      case 'volumeRangeNavigate':
        analyticsEvent = createTimeRangeNavigatedEvent(type, playbackState, actionSubjectId, fileId);
        break;
      case 'playbackSpeedChange':
        analyticsEvent = createPlaybackSpeedChangedEvent(type, playbackState, fileId);
        break;
      default:
        analyticsEvent = {
          eventType: 'ui',
          action: 'default',
          actionSubject: 'customMediaPlayer',
          attributes: {
            type
          }
        };
    }
    fireAnalyticsEvent(analyticsEvent, createAnalyticsEvent);
  }
  render() {
    const {
      type,
      src,
      isAutoPlay,
      onCanPlay,
      onError,
      poster,
      videoControlsWrapperRef
    } = this.props;
    return /*#__PURE__*/React.createElement(Box, {
      xcss: customVideoWrapperStyles,
      ref: this.videoWrapperRef,
      testId: "custom-media-player"
    }, /*#__PURE__*/React.createElement(MediaPlayer, {
      sourceType: type,
      src: src,
      autoPlay: isAutoPlay,
      onCanPlay: onCanPlay,
      defaultTime: this.timeSaver.defaultTime,
      onTimeChange: this.onCurrentTimeChange,
      onError: onError,
      poster: poster
    }, (video, videoState, actions) => {
      this.onViewed(videoState);
      this.setActions(actions);
      //Video State(either prop or variable) is ReadOnly
      this.videoState = videoState;
      const {
        status,
        currentTime,
        buffered,
        duration,
        isLoading
      } = videoState;
      const {
        playerSize
      } = this.state;
      const isPlaying = status === 'playing';
      const isLargePlayer = playerSize === 'large';
      const isMediumPlayer = playerSize === 'medium';
      const defaultSkipAmount = 10;
      const skipBackward = (skipAmount = defaultSkipAmount) => {
        const newTime = videoState.currentTime - skipAmount;
        actions.navigate(Math.max(newTime, 0));
      };
      const skipForward = (skipAmount = defaultSkipAmount) => {
        const newTime = videoState.currentTime + skipAmount;
        actions.navigate(Math.min(newTime, videoState.duration));
      };
      const shortcuts = this.renderShortcuts({
        togglePlayPauseAction: isPlaying ? this.pause : this.play,
        toggleMute: actions.toggleMute,
        skipBackward,
        skipForward
      });
      return /*#__PURE__*/React.createElement(Flex, {
        direction: "column",
        xcss: videoWrapperStyles
      }, /*#__PURE__*/React.createElement(WidthObserver, {
        setWidth: this.onResize
      }), shortcuts, isLoading && this.renderSpinner(), /*#__PURE__*/React.createElement(PlayPauseBlanket, {
        onDoubleClick: this.doubleClickToFullscreen,
        onClick: isPlaying ? this.pausePlayByBlanketClick : this.startPlayByBlanketClick,
        "data-testid": "play-pause-blanket"
      }, video), /*#__PURE__*/React.createElement(ControlsWrapper, {
        ref: videoControlsWrapperRef
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        ,
        className: getControlsWrapperClassName(this.wasPlayedOnce)
      }, /*#__PURE__*/React.createElement(Box, {
        xcss: timeWrapperStyles
      }, /*#__PURE__*/React.createElement(TimeRange, {
        currentTime: currentTime,
        bufferedTime: buffered,
        duration: duration,
        onChange: actions.navigate,
        onChanged: this.onTimeChanged,
        disableThumbTooltip: true,
        skipBackward: skipBackward,
        skipForward: skipForward,
        isAlwaysActive: false
      })), /*#__PURE__*/React.createElement(Flex, {
        alignItems: "center",
        justifyContent: "space-between",
        xcss: timebarWrapperStyles
      }, /*#__PURE__*/React.createElement(LeftControls, null, this.renderPlayPauseButton(isPlaying), isLargePlayer && this.renderSkipBackwardButton(skipBackward), isLargePlayer && this.renderSkipForwardButton(skipForward), this.renderVolume(videoState, actions, isLargePlayer)), /*#__PURE__*/React.createElement(RightControls, null, (isMediumPlayer || isLargePlayer) && this.renderCurrentTime(videoState), isLargePlayer && !fg('platform_media_disable_video_640p_artifact_usage') && this.renderHDButton(), isLargePlayer && this.renderSpeedControls(), this.renderFullScreenButton(), isLargePlayer && this.renderDownloadButton()))));
    }));
  }
}