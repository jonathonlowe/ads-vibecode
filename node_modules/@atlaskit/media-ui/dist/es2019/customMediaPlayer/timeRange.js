import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { Component } from 'react';
import { CurrentTimeTooltip as EmotionCurrentTimeTooltip, TimeRangeWrapper as EmotionTimeRangeWrapper } from './styled-emotion';
import { CurrentTimeTooltip as CompiledCurrentTimeTooltip, TimeRangeWrapper as CompiledTimeRangeWrapper } from './styled-compiled';
import { formatDuration, secondsToTime } from '../formatDuration';
import { injectIntl } from 'react-intl-next';
import { messages } from '../messages';
import { fg } from '@atlaskit/platform-feature-flags';
import { BufferedTime, CurrentTimeLine, CurrentTimeLineThumb, TimeLine } from './styled';
export class TimeRangeBase extends Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "thumbElement", /*#__PURE__*/React.createRef());
    _defineProperty(this, "wrapperElement", /*#__PURE__*/React.createRef());
    _defineProperty(this, "wrapperElementWidth", 0);
    _defineProperty(this, "state", {
      isDragging: false,
      timeLineThumbIsHover: false,
      timeLineThumbIsFocus: false,
      dragStartClientX: 0
    });
    _defineProperty(this, "setWrapperWidth", () => {
      if (!this.wrapperElement.current) {
        return;
      }
      this.wrapperElementWidth = this.wrapperElement.current.getBoundingClientRect().width;
    });
    _defineProperty(this, "onMouseMove", e => {
      const {
        isDragging,
        dragStartClientX
      } = this.state;
      if (!isDragging) {
        return;
      }
      e.stopPropagation();
      const {
        onChange,
        duration,
        currentTime
      } = this.props;
      const {
        clientX
      } = e;
      let absolutePosition = clientX - dragStartClientX;
      const isOutsideToRight = absolutePosition > this.wrapperElementWidth;
      const isOutsideToLeft = absolutePosition < 0;

      // Next to conditions take care of situation where user moves mouse very quickly out to the side
      // left or right. It's very easy to leave thumb not at the end/beginning of a timeline.
      // This will guarantee that in this case thumb will move to appropriate extreme.
      if (isOutsideToRight) {
        absolutePosition = this.wrapperElementWidth;
      }
      if (isOutsideToLeft) {
        absolutePosition = 0;
      }
      const newTimeWithBoundaries = absolutePosition * duration / this.wrapperElementWidth;
      if (currentTime !== newTimeWithBoundaries) {
        // If value hasn't changed we don't want to call "change"
        onChange(newTimeWithBoundaries);
      }
    });
    _defineProperty(this, "onMouseUp", () => {
      const {
        onChanged
      } = this.props;
      // As soon as user finished dragging, we should clean up events.
      document.removeEventListener('mouseup', this.onMouseUp);
      document.removeEventListener('mousemove', this.onMouseMove);
      if (onChanged) {
        onChanged();
      }
      this.setState({
        isDragging: false
      });
    });
    _defineProperty(this, "onThumbMouseDown", e => {
      e.preventDefault();

      // We need to recalculate every time, because width can change (thanks, editor ;-)
      this.setWrapperWidth();

      // We are implementing drag and drop here. There is no reason to start listening for mouseUp or move
      // before that. Also if we start listening for mouseup before that we could pick up someone else's event
      // For example editors resizing of a inline video player.
      document.addEventListener('mouseup', this.onMouseUp);
      document.addEventListener('mousemove', this.onMouseMove);
      const {
        duration,
        onChange
      } = this.props;
      const event = e.nativeEvent;
      const x = event.offsetX;
      const currentTime = x * duration / this.wrapperElementWidth;
      this.setState({
        isDragging: true,
        dragStartClientX: event.clientX - x
      });

      // As soon as user clicks timeline we want to move thumb over to that place.
      onChange(currentTime);
    });
    _defineProperty(this, "onTimeLineThumbKeydown", event => {
      if (!this.props.skipBackward || !this.props.skipForward) {
        return;
      }
      if (event.key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
        if (event.shiftKey) {
          this.props.skipForward(10);
        } else {
          this.props.skipForward(1);
        }
      }
      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        event.stopPropagation();
        if (event.shiftKey) {
          this.props.skipBackward(10);
        } else {
          this.props.skipBackward(1);
        }
      }
    });
    this.numberFormatterHours = new Intl.NumberFormat(this.props.intl.locale, {
      style: 'unit',
      unit: 'hour'
    });
    this.numberFormatterMinutes = new Intl.NumberFormat(this.props.intl.locale, {
      style: 'unit',
      unit: 'minute'
    });
    this.numberFormatterSeconds = new Intl.NumberFormat(this.props.intl.locale, {
      style: 'unit',
      unit: 'second'
    });
  }
  componentDidMount() {
    window.addEventListener('resize', this.setWrapperWidth);
  }
  componentDidUpdate(prevProps) {
    if (this.props.intl.locale !== prevProps.intl.locale) {
      this.numberFormatterHours = new Intl.NumberFormat(this.props.intl.locale, {
        style: 'unit',
        unit: 'hour'
      });
      this.numberFormatterMinutes = new Intl.NumberFormat(this.props.intl.locale, {
        style: 'unit',
        unit: 'minute'
      });
      this.numberFormatterSeconds = new Intl.NumberFormat(this.props.intl.locale, {
        style: 'unit',
        unit: 'second'
      });
    }
  }
  componentWillUnmount() {
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('mouseup', this.onMouseUp);
    window.removeEventListener('resize', this.setWrapperWidth);
  }
  render() {
    const {
      isDragging,
      timeLineThumbIsHover,
      timeLineThumbIsFocus
    } = this.state;
    const {
      currentTime,
      duration,
      bufferedTime,
      disableThumbTooltip,
      isAlwaysActive,
      intl
    } = this.props;
    const currentPosition = currentTime * 100 / duration;
    const bufferedTimePercentage = bufferedTime * 100 / duration;
    const {
      seconds: currentTimeSeconds,
      minutes: currentTimeMinutes,
      hours: currentTimeHours
    } = secondsToTime(currentTime);
    const {
      seconds: videoTotalSeconds,
      minutes: videoTotalMinutes,
      hours: videoTotalHours
    } = secondsToTime(duration);
    const timelineThumbText = intl.formatMessage(messages.video_seeker_assistive_text_time_value, {
      currentTimeHours: currentTimeHours ? this.numberFormatterHours.format(currentTimeHours) : '',
      currentTimeMinutes: this.numberFormatterMinutes.format(currentTimeMinutes),
      currentTimeSeconds: this.numberFormatterSeconds.format(currentTimeSeconds),
      videoTotalHours: videoTotalHours ? this.numberFormatterHours.format(videoTotalHours) : '',
      videoTotalMinutes: this.numberFormatterMinutes.format(videoTotalMinutes),
      videoTotalSeconds: this.numberFormatterSeconds.format(videoTotalSeconds)
    });
    const currentTimeTooltip = fg('platform_media_compiled') ? /*#__PURE__*/React.createElement(CompiledCurrentTimeTooltip, {
      draggable: false,
      isDragging: isDragging,
      timeLineThumbIsHover: timeLineThumbIsHover,
      timeLineThumbIsFocus: timeLineThumbIsFocus
    }, formatDuration(currentTime)) : /*#__PURE__*/React.createElement(EmotionCurrentTimeTooltip, {
      draggable: false,
      isDragging: isDragging
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: "current-time-tooltip"
    }, formatDuration(currentTime));
    const timeline = /*#__PURE__*/React.createElement(TimeLine, {
      ref: this.wrapperElement
    }, /*#__PURE__*/React.createElement(BufferedTime, {
      style: {
        width: `${bufferedTimePercentage}%`
      },
      "data-testid": "buffered-time"
    }), /*#__PURE__*/React.createElement(CurrentTimeLine, {
      style: {
        width: `${currentPosition}%`
      },
      "data-testid": "current-timeline"
    }, /*#__PURE__*/React.createElement(CurrentTimeLineThumb, {
      role: "slider",
      ref: this.thumbElement,
      onKeyDown: this.onTimeLineThumbKeydown,
      tabIndex: 0,
      "aria-orientation": "horizontal",
      "aria-label": intl.formatMessage(messages.video_seeker_label_assistive_text),
      "aria-valuemin": 0,
      "aria-valuemax": Math.floor(duration),
      "aria-valuenow": Math.floor(currentTime),
      "aria-valuetext": timelineThumbText,
      onMouseOver: () => this.setState({
        timeLineThumbIsHover: true
      }),
      onMouseOut: () => this.setState({
        timeLineThumbIsHover: false
      }),
      onFocus: () => this.setState({
        timeLineThumbIsFocus: true
      }),
      onBlur: () => this.setState({
        timeLineThumbIsFocus: false
      })
    }, disableThumbTooltip ? null : currentTimeTooltip)));
    return fg('platform_media_compiled') ? /*#__PURE__*/React.createElement(CompiledTimeRangeWrapper, {
      onMouseDown: this.onThumbMouseDown,
      "data-testid": "time-range-wrapper"
    }, timeline) : /*#__PURE__*/React.createElement(EmotionTimeRangeWrapper, {
      showAsActive: isAlwaysActive,
      onMouseDown: this.onThumbMouseDown,
      "data-testid": "time-range-wrapper"
    }, timeline);
  }
}
_defineProperty(TimeRangeBase, "defaultProps", {
  disableThumbTooltip: false,
  isAlwaysActive: false
});
export const TimeRange = injectIntl(TimeRangeBase);