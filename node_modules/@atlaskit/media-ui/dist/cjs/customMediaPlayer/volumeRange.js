"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _styledEmotion = require("./styled-emotion");
var _styledCompiled = require("./styled-compiled");
var _range = _interopRequireDefault(require("@atlaskit/range"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var increaseVolumeKeys = new Set(['ArrowRight', 'ArrowUp']);
var decreaseVolumeKeys = new Set(['ArrowLeft', 'ArrowDown']);
var VolumeRange = function VolumeRange(props) {
  var _props$isAlwaysActive = props.isAlwaysActive,
    isAlwaysActive = _props$isAlwaysActive === void 0 ? false : _props$isAlwaysActive,
    onChange = props.onChange,
    currentVolume = props.currentVolume,
    onChanged = props.onChanged,
    ariaLabel = props.ariaLabel;
  var wrapperElement = (0, _react.useRef)(null);
  var mouseEventsSharedData = (0, _react.useRef)({
    dragStartClientX: 0,
    isDragging: false
  });
  var _useState = (0, _react.useState)(0),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    wrapperElementWidth = _useState2[0],
    _setWrapperElementWidth = _useState2[1];
  var wrapperElementWidthRef = _react.default.useRef(wrapperElementWidth);
  var setWrapperElementWidth = function setWrapperElementWidth(width) {
    wrapperElementWidthRef.current = width;
  };
  var setWrapperWidth = (0, _react.useCallback)(function () {
    if (!wrapperElement.current) {
      return;
    }
    setWrapperElementWidth(wrapperElement.current.getBoundingClientRect().width);
  }, []);
  (0, _react.useEffect)(function () {
    window.addEventListener('resize', setWrapperWidth);
    return function () {
      window.removeEventListener('resize', setWrapperWidth);
    };
  }, [setWrapperWidth]);
  var onMouseMove = function onMouseMove(e) {
    if (!mouseEventsSharedData.current.isDragging) {
      return;
    }
    e.stopPropagation();
    var onChange = props.onChange,
      currentVolume = props.currentVolume;
    var clientX = e.clientX;
    var absolutePosition = clientX - mouseEventsSharedData.current.dragStartClientX;
    var isOutsideToRight = absolutePosition > wrapperElementWidthRef.current;
    var isOutsideToLeft = absolutePosition < 0;

    // Next to conditions take care of situation where user moves mouse very quickly out to the side
    // left or right. It's very easy to leave thumb not at the end/beginning of a volume line.
    // This will guarantee that in this case thumb will move to appropriate extreme.
    if (isOutsideToRight) {
      absolutePosition = wrapperElementWidthRef.current;
    }
    if (isOutsideToLeft) {
      absolutePosition = 0;
    }
    var newVolumeWithBoundaries = absolutePosition / wrapperElementWidthRef.current;
    if (currentVolume !== newVolumeWithBoundaries) {
      // If value hasn't changed we don't want to call "change"
      onChange(newVolumeWithBoundaries);
    }
  };
  var _onMouseUp = function onMouseUp() {
    // As soon as user finished dragging, we should clean up events.
    document.removeEventListener('mouseup', _onMouseUp);
    document.removeEventListener('mousemove', onMouseMove);
    if (onChanged) {
      onChanged();
    }
    mouseEventsSharedData.current.isDragging = false;
  };
  var onThumbMouseDown = function onThumbMouseDown(e) {
    e.preventDefault();

    // We need to recalculate every time, because width can change (thanks, editor ;-)
    setWrapperWidth();

    // We are implementing drag and drop here. There is no reason to start listening for mouseUp or move
    // before that. Also if we start listening for mouseup before that we could pick up someone else's event
    // For example editors resizing of a inline video player.
    document.addEventListener('mouseup', _onMouseUp);
    document.addEventListener('mousemove', onMouseMove);
    var event = e.nativeEvent;
    var x = event.offsetX;
    var currentVolume = x / wrapperElementWidthRef.current;
    currentVolume = currentVolume > 0 ? currentVolume : 0;
    mouseEventsSharedData.current = {
      dragStartClientX: event.clientX - x,
      isDragging: true
    };
    // As soon as user clicks timeline we want to move thumb over to that place.
    onChange(currentVolume);
  };
  var onThumbKeyDown = function onThumbKeyDown(e) {
    var eventKey = e.key;
    var isShiftPressed = e.shiftKey;
    if (increaseVolumeKeys.has(eventKey) || decreaseVolumeKeys.has(eventKey)) {
      // preventDefault call is needed to keep the volume regulator focused(visible) in FireFox (Editor mode)
      e.preventDefault();
      var newVolume = currentVolume;
      if (increaseVolumeKeys.has(eventKey)) {
        newVolume += isShiftPressed ? 0.1 : 0.01;
      } else if (decreaseVolumeKeys.has(eventKey)) {
        newVolume -= isShiftPressed ? 0.1 : 0.01;
      }
      newVolume = newVolume > 1 ? 1 : newVolume;
      newVolume = newVolume < 0 ? 0 : newVolume;
      onChange(+newVolume.toPrecision(2));
      if (onChanged) {
        onChanged();
      }
    }
  };
  var onInputChange = function onInputChange(newVolume) {
    if (newVolume) {
      onChange(newVolume / 100);
      if (onChanged) {
        onChanged();
      }
    }
  };
  var currentPosition = currentVolume * 100;
  return (0, _platformFeatureFlags.fg)('platform_media_compiled') ? /*#__PURE__*/_react.default.createElement(_styledCompiled.TimeRangeWrapper, {
    onMouseDown: onThumbMouseDown,
    onKeyDown: onThumbKeyDown,
    ref: wrapperElement
  }, /*#__PURE__*/_react.default.createElement(_range.default, {
    tabIndex: 0,
    step: 1,
    min: 0,
    max: 100,
    value: currentPosition,
    onChange: onInputChange,
    "aria-label": ariaLabel
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
    ,
    style: {
      width: '100%',
      cursor: 'pointer',
      height: '14px'
    }
  })) : /*#__PURE__*/_react.default.createElement(_styledEmotion.TimeRangeWrapper, {
    showAsActive: isAlwaysActive,
    onMouseDown: onThumbMouseDown,
    onKeyDown: onThumbKeyDown,
    ref: wrapperElement
  }, /*#__PURE__*/_react.default.createElement(_range.default, {
    tabIndex: 0,
    step: 1,
    min: 0,
    max: 100,
    value: currentPosition,
    onChange: onInputChange,
    "aria-label": ariaLabel
  }));
};
var _default = exports.default = VolumeRange;