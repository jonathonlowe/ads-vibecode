"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ExifOrientation", {
  enumerable: true,
  get: function get() {
    return _types.ExifOrientation;
  }
});
Object.defineProperty(exports, "getCssFromImageOrientation", {
  enumerable: true,
  get: function get() {
    return _imageOrientationUtil.getCssFromImageOrientation;
  }
});
exports.getImageInfo = getImageInfo;
exports.getMetaTagNumericValue = getMetaTagNumericValue;
exports.getOrientation = getOrientation;
exports.getScaleFactor = getScaleFactor;
exports.getScaleFactorFromFile = getScaleFactorFromFile;
Object.defineProperty(exports, "isRotated", {
  enumerable: true,
  get: function get() {
    return _imageOrientationUtil.isRotated;
  }
});
exports.readImageMetaData = readImageMetaData;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _types = require("./types");
var _metatags = require("./metatags");
var _util = require("../util");
var _imageOrientationUtil = require("./imageOrientationUtil");
var Orientation = _types.SupportedImageMetaTag.Orientation,
  XResolution = _types.SupportedImageMetaTag.XResolution;

// http://bonfx.com/why-is-the-web-72-dpi-and-print-300-dpi/
var DPI_WEB_BASELINE = 72;
function getImageInfo(_x) {
  return _getImageInfo.apply(this, arguments);
}
function _getImageInfo() {
  _getImageInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(fileInfo) {
    var metadata, width, height, tags, scaleFactor;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return readImageMetaData(fileInfo);
        case 2:
          metadata = _context.sent;
          if (metadata) {
            _context.next = 5;
            break;
          }
          return _context.abrupt("return", null);
        case 5:
          width = metadata.width, height = metadata.height, tags = metadata.tags;
          scaleFactor = getScaleFactor(fileInfo.file, tags);
          return _context.abrupt("return", {
            scaleFactor: scaleFactor,
            width: width,
            height: height
          });
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getImageInfo.apply(this, arguments);
}
function getScaleFactor(file, tags) {
  var scaleFactorFromFilename = getScaleFactorFromFile(file);
  if (scaleFactorFromFilename !== null) {
    return scaleFactorFromFilename;
  } else if (tags) {
    /**
     * Scale Factor is actually a 2D thing, but in practice X & Y are same in 99% cases.
     * So we are only relying on X axis.
     */
    if (typeof tags['PixelPerUnitX'] === 'number') {
      // 1 inch = 0.0254 meters
      return Math.round(tags['PixelPerUnitX'] * 0.0254) / DPI_WEB_BASELINE;
    } else {
      return getMetaTagNumericValue(tags, XResolution, DPI_WEB_BASELINE) / DPI_WEB_BASELINE;
    }
  } else {
    return 1;
  }
}
var getOrientationFromTags = function getOrientationFromTags(tags) {
  if (tags && tags[Orientation]) {
    var tagValue = tags[Orientation];
    if (tagValue) {
      var numericValue = parseInt(tagValue, 10);
      if (isNaN(numericValue)) {
        return _types.ExifOrientation[tagValue];
      }
      return numericValue;
    }
  }
  return 1;
};
function getOrientation(_x2) {
  return _getOrientation.apply(this, arguments);
}
function _getOrientation() {
  _getOrientation = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(file) {
    var tags;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return (0, _metatags.readImageMetaTags)(file);
        case 2:
          tags = _context2.sent;
          return _context2.abrupt("return", getOrientationFromTags(tags));
        case 4:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getOrientation.apply(this, arguments);
}
function getMetaTagNumericValue(tags, key, defaultValue) {
  try {
    var num = parseFloat("".concat(tags[key]));
    if (!isNaN(num)) {
      return num;
    }
  } catch (e) {
    //
  }
  return defaultValue;
}
function getScaleFactorFromFile(file) {
  try {
    // filenames with scale ratio in name take precedence - eg. filename@2x.png
    var match = file.name.trim().match(/@([0-9\.]+)x\.[a-z]{3}$/);
    if (match) {
      return parseFloat(match[1]);
    }
  } catch (e) {
    // parse problem, return null
  }
  return null;
}
function readImageMetaData(_x3) {
  return _readImageMetaData.apply(this, arguments);
}
function _readImageMetaData() {
  _readImageMetaData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(fileInfo) {
    var file, src, type, width, height, tags, data, img, _readImageNaturalOrie, _width, _height;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          file = fileInfo.file, src = fileInfo.src;
          type = file.type;
          width = 0;
          height = 0;
          _context3.next = 6;
          return (0, _metatags.readImageMetaTags)(file);
        case 6:
          tags = _context3.sent;
          // since we're reading metadata anyway, try to get dimensions from there...
          if (tags && tags.PixelXDimension) {
            width = getMetaTagNumericValue(tags, 'PixelXDimension', 0);
          }
          if (tags && tags.PixelXDimension) {
            height = getMetaTagNumericValue(tags, 'PixelYDimension', 0);
          }
          data = {
            type: type,
            width: width,
            height: height,
            naturalWidth: width,
            naturalHeight: height,
            tags: tags
          };
          /*
           * The PixelXDimension and PixelYDimension of image tags can mean something different than just width and height, especially when images are compressed or for other reasons.
           * https://imagemagick.org/discourse-server/viewtopic.php?t=27037
           * We've also received JAC tickets reporting incorrect dimensions because of this
           * https://jira.atlassian.com/browse/CONFCLOUD-78275
           * The best way to get accurate dimensions is by loading images into the HTML, which reflects the actual dimensions the browser will render
           */
          _context3.prev = 10;
          _context3.next = 13;
          return (0, _util.loadImage)(src);
        case 13:
          img = _context3.sent;
          _readImageNaturalOrie = (0, _util.readImageNaturalOrientationFromDOM)(img), _width = _readImageNaturalOrie.width, _height = _readImageNaturalOrie.height;
          data.width = _width;
          data.height = _height;
          data.naturalWidth = img.naturalWidth;
          data.naturalHeight = img.naturalHeight;
          _context3.next = 24;
          break;
        case 21:
          _context3.prev = 21;
          _context3.t0 = _context3["catch"](10);
          return _context3.abrupt("return", null);
        case 24:
          return _context3.abrupt("return", data);
        case 25:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[10, 21]]);
  }));
  return _readImageMetaData.apply(this, arguments);
}