"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePNGChunks = parsePNGChunks;
exports.readPNGXMPMetaData = readPNGXMPMetaData;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _util = require("../util");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != (0, _typeof2.default)(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var pngChunksExtract;
function readPNGXMPMetaData(_x) {
  return _readPNGXMPMetaData.apply(this, arguments);
}
function _readPNGXMPMetaData() {
  _readPNGXMPMetaData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(file) {
    var module, buffer, chunks;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (pngChunksExtract) {
            _context.next = 5;
            break;
          }
          _context.next = 3;
          return Promise.resolve().then(function () {
            return _interopRequireWildcard(require('png-chunks-extract'));
          });
        case 3:
          module = _context.sent;
          pngChunksExtract = module.default || module;
        case 5:
          _context.next = 7;
          return (0, _util.fileToArrayBuffer)(file);
        case 7:
          buffer = _context.sent;
          chunks = pngChunksExtract(buffer);
          _context.next = 11;
          return parsePNGChunks(chunks);
        case 11:
          return _context.abrupt("return", _context.sent);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _readPNGXMPMetaData.apply(this, arguments);
}
function parsePNGChunks(_x2) {
  return _parsePNGChunks.apply(this, arguments);
}
function _parsePNGChunks() {
  _parsePNGChunks = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(chunks) {
    var iTXt, pHYs, i, chunk, dv, unitSpecifier, PixelPerUnitX, PixelPerUnitY;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          iTXt = '';
          pHYs = {};
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Summary-of-standard-chunks
           * Order of every chunk is not guaranteed.
           * And both iTXt and pHYs are Ancillary chunks.
           */
          i = 0;
        case 3:
          if (!(i < chunks.length)) {
            _context2.next = 12;
            break;
          }
          chunk = chunks[i]; // Must be last
          if (!(chunk.name === 'IEND')) {
            _context2.next = 7;
            break;
          }
          return _context2.abrupt("break", 12);
        case 7:
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Anc-text
           * iTXt contains the useful XMP/XML string data of meta tags
           */
          if (chunk.name === 'iTXt') {
            iTXt = String.fromCharCode.apply(null, Array.from(chunk.data));
          }
          /**
           * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.pHYs
           * Pixels per unit, X axis: 4 bytes (unsigned integer)
           * Pixels per unit, Y axis: 4 bytes (unsigned integer)
           * Unit specifier:          1 byte  (0: unit is unknown 1: unit is the meter)
           */
          if (chunk.name === 'pHYs') {
            dv = new DataView(chunk.data.buffer);
            unitSpecifier = dv.getUint8(8); // meter
            if (unitSpecifier === 1) {
              PixelPerUnitX = dv.getUint32(0);
              PixelPerUnitY = dv.getUint32(4);
              pHYs = {
                PixelPerUnitX: PixelPerUnitX,
                PixelPerUnitY: PixelPerUnitY
              };
            }
          }
        case 9:
          ++i;
          _context2.next = 3;
          break;
        case 12:
          return _context2.abrupt("return", {
            iTXt: iTXt,
            pHYs: pHYs
          });
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _parsePNGChunks.apply(this, arguments);
}