import React, { useEffect, useRef } from 'react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import { fg } from '@atlaskit/platform-feature-flags';
import { createPlugin, dispatchShouldHideDecorations, key } from './pm-plugins/main';
import { GlobalStylesWrapper } from './ui/global-styles';
export var selectionMarkerPlugin = function selectionMarkerPlugin(_ref) {
  var config = _ref.config,
    api = _ref.api;
  return {
    name: 'selectionMarker',
    pmPlugins: function pmPlugins() {
      return [{
        name: 'selectionMarkerPmPlugin',
        plugin: function plugin() {
          return createPlugin(api);
        }
      }];
    },
    getSharedState: function getSharedState(editorState) {
      var _key$getState$forceHi, _key$getState, _key$getState2;
      if (!editorState) {
        return undefined;
      }
      return {
        isForcedHidden: (_key$getState$forceHi = (_key$getState = key.getState(editorState)) === null || _key$getState === void 0 ? void 0 : _key$getState.forceHide) !== null && _key$getState$forceHi !== void 0 ? _key$getState$forceHi : false,
        isMarkerActive: !((_key$getState2 = key.getState(editorState)) !== null && _key$getState2 !== void 0 && _key$getState2.shouldHideDecorations)
      };
    },
    actions: {
      // For now this is a very simple locking mechanism that only allows one
      // plugin to hide / release at a time.
      hideDecoration: function hideDecoration() {
        var _api$selectionMarker, _api$core;
        if (api !== null && api !== void 0 && (_api$selectionMarker = api.selectionMarker) !== null && _api$selectionMarker !== void 0 && (_api$selectionMarker = _api$selectionMarker.sharedState.currentState()) !== null && _api$selectionMarker !== void 0 && _api$selectionMarker.isForcedHidden) {
          return undefined;
        }
        var success = api === null || api === void 0 || (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(function (_ref2) {
          var tr = _ref2.tr;
          return tr.setMeta(key, {
            forceHide: true
          });
        });
        if (!success) {
          return undefined;
        }
        return cleanupHiddenDecoration(api);
      },
      queueHideDecoration: function queueHideDecoration(setCleanup) {
        var result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
        if (result === undefined) {
          var _api$selectionMarker2;
          var cleanup = api === null || api === void 0 || (_api$selectionMarker2 = api.selectionMarker) === null || _api$selectionMarker2 === void 0 ? void 0 : _api$selectionMarker2.sharedState.onChange(function (_ref3) {
            var nextSharedState = _ref3.nextSharedState;
            if ((nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isForcedHidden) === false && (nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isMarkerActive) === false) {
              var _result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
              setCleanup(_result);
              cleanup === null || cleanup === void 0 || cleanup();
            }
          });
          return cleanup;
        }
        setCleanup(result);
        return function () {};
      }
    },
    usePluginHook: function usePluginHook(_ref4) {
      var editorView = _ref4.editorView;
      var editorHasNotBeenFocused = useRef(true);
      useEffect(function () {
        // relatch when editorView changes (pretty good signal for reinit)
        editorHasNotBeenFocused.current = true;
      }, [editorView]);
      var _useSharedPluginState = useSharedPluginState(api, ['focus', 'typeAhead', 'editorDisabled', 'selectionMarker']),
        focusState = _useSharedPluginState.focusState,
        typeAheadState = _useSharedPluginState.typeAheadState,
        editorDisabledState = _useSharedPluginState.editorDisabledState;
      var isForcedHidden = useSharedPluginStateSelector(api, 'selectionMarker.isForcedHidden');
      useEffect(function () {
        if (fg('platform_editor_no_cursor_on_live_doc_init')) {
          var _ref5, _typeAheadState$isOpe, _editorDisabledState$;
          // On editor init we should use this latch to keep the marker hidden until
          // editor has received focus. This means editor will be initially hidden until
          // the first focus occurs, and after first focus the normal above rules will
          // apply
          if ((focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) === true) {
            editorHasNotBeenFocused.current = false;
          }

          /**
           * There are a number of conditions we should not show the marker,
           * - Editor has not been focused: to keep the marker hidden until first focus if config is set
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          var shouldHide = (_ref5 = (config === null || config === void 0 ? void 0 : config.hideCursorOnInit) && editorHasNotBeenFocused.current || (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe !== void 0 ? _typeAheadState$isOpe : false) || isForcedHidden || ((_editorDisabledState$ = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$ !== void 0 ? _editorDisabledState$ : false)) !== null && _ref5 !== void 0 ? _ref5 : true;
          requestAnimationFrame(function () {
            return dispatchShouldHideDecorations(editorView, shouldHide);
          });
        } else {
          var _ref6, _typeAheadState$isOpe2, _editorDisabledState$2;
          /**
           * There are a number of conditions we should not show the marker,
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          var _shouldHide = (_ref6 = (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe2 = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe2 !== void 0 ? _typeAheadState$isOpe2 : false) || isForcedHidden || ((_editorDisabledState$2 = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$2 !== void 0 ? _editorDisabledState$2 : false)) !== null && _ref6 !== void 0 ? _ref6 : true;
          requestAnimationFrame(function () {
            return dispatchShouldHideDecorations(editorView, _shouldHide);
          });
        }
      }, [editorView, focusState, typeAheadState, isForcedHidden, editorDisabledState]);
    },
    contentComponent: function contentComponent() {
      return /*#__PURE__*/React.createElement(GlobalStylesWrapper, null);
    }
  };
};
function cleanupHiddenDecoration(api) {
  var hasRun = false;
  return function () {
    var _api$selectionMarker3;
    if (!hasRun && api !== null && api !== void 0 && (_api$selectionMarker3 = api.selectionMarker) !== null && _api$selectionMarker3 !== void 0 && (_api$selectionMarker3 = _api$selectionMarker3.sharedState.currentState()) !== null && _api$selectionMarker3 !== void 0 && _api$selectionMarker3.isForcedHidden) {
      var _api$core2;
      hasRun = true;
      return api === null || api === void 0 || (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions.execute(function (_ref7) {
        var tr = _ref7.tr;
        return tr.setMeta(key, {
          forceHide: false
        });
      });
    }
  };
}