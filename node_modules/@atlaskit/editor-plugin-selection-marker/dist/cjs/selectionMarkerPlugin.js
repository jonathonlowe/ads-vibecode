"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectionMarkerPlugin = void 0;
var _react = _interopRequireWildcard(require("react"));
var _hooks = require("@atlaskit/editor-common/hooks");
var _useSharedPluginStateSelector = require("@atlaskit/editor-common/use-shared-plugin-state-selector");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _main = require("./pm-plugins/main");
var _globalStyles = require("./ui/global-styles");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var selectionMarkerPlugin = exports.selectionMarkerPlugin = function selectionMarkerPlugin(_ref) {
  var config = _ref.config,
    api = _ref.api;
  return {
    name: 'selectionMarker',
    pmPlugins: function pmPlugins() {
      return [{
        name: 'selectionMarkerPmPlugin',
        plugin: function plugin() {
          return (0, _main.createPlugin)(api);
        }
      }];
    },
    getSharedState: function getSharedState(editorState) {
      var _key$getState$forceHi, _key$getState, _key$getState2;
      if (!editorState) {
        return undefined;
      }
      return {
        isForcedHidden: (_key$getState$forceHi = (_key$getState = _main.key.getState(editorState)) === null || _key$getState === void 0 ? void 0 : _key$getState.forceHide) !== null && _key$getState$forceHi !== void 0 ? _key$getState$forceHi : false,
        isMarkerActive: !((_key$getState2 = _main.key.getState(editorState)) !== null && _key$getState2 !== void 0 && _key$getState2.shouldHideDecorations)
      };
    },
    actions: {
      // For now this is a very simple locking mechanism that only allows one
      // plugin to hide / release at a time.
      hideDecoration: function hideDecoration() {
        var _api$selectionMarker, _api$core;
        if (api !== null && api !== void 0 && (_api$selectionMarker = api.selectionMarker) !== null && _api$selectionMarker !== void 0 && (_api$selectionMarker = _api$selectionMarker.sharedState.currentState()) !== null && _api$selectionMarker !== void 0 && _api$selectionMarker.isForcedHidden) {
          return undefined;
        }
        var success = api === null || api === void 0 || (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(function (_ref2) {
          var tr = _ref2.tr;
          return tr.setMeta(_main.key, {
            forceHide: true
          });
        });
        if (!success) {
          return undefined;
        }
        return cleanupHiddenDecoration(api);
      },
      queueHideDecoration: function queueHideDecoration(setCleanup) {
        var result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
        if (result === undefined) {
          var _api$selectionMarker2;
          var cleanup = api === null || api === void 0 || (_api$selectionMarker2 = api.selectionMarker) === null || _api$selectionMarker2 === void 0 ? void 0 : _api$selectionMarker2.sharedState.onChange(function (_ref3) {
            var nextSharedState = _ref3.nextSharedState;
            if ((nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isForcedHidden) === false && (nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isMarkerActive) === false) {
              var _result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
              setCleanup(_result);
              cleanup === null || cleanup === void 0 || cleanup();
            }
          });
          return cleanup;
        }
        setCleanup(result);
        return function () {};
      }
    },
    usePluginHook: function usePluginHook(_ref4) {
      var editorView = _ref4.editorView;
      var editorHasNotBeenFocused = (0, _react.useRef)(true);
      (0, _react.useEffect)(function () {
        // relatch when editorView changes (pretty good signal for reinit)
        editorHasNotBeenFocused.current = true;
      }, [editorView]);
      var _useSharedPluginState = (0, _hooks.useSharedPluginState)(api, ['focus', 'typeAhead', 'editorDisabled', 'selectionMarker']),
        focusState = _useSharedPluginState.focusState,
        typeAheadState = _useSharedPluginState.typeAheadState,
        editorDisabledState = _useSharedPluginState.editorDisabledState;
      var isForcedHidden = (0, _useSharedPluginStateSelector.useSharedPluginStateSelector)(api, 'selectionMarker.isForcedHidden');
      (0, _react.useEffect)(function () {
        if ((0, _platformFeatureFlags.fg)('platform_editor_no_cursor_on_live_doc_init')) {
          var _ref5, _typeAheadState$isOpe, _editorDisabledState$;
          // On editor init we should use this latch to keep the marker hidden until
          // editor has received focus. This means editor will be initially hidden until
          // the first focus occurs, and after first focus the normal above rules will
          // apply
          if ((focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) === true) {
            editorHasNotBeenFocused.current = false;
          }

          /**
           * There are a number of conditions we should not show the marker,
           * - Editor has not been focused: to keep the marker hidden until first focus if config is set
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          var shouldHide = (_ref5 = (config === null || config === void 0 ? void 0 : config.hideCursorOnInit) && editorHasNotBeenFocused.current || (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe !== void 0 ? _typeAheadState$isOpe : false) || isForcedHidden || ((_editorDisabledState$ = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$ !== void 0 ? _editorDisabledState$ : false)) !== null && _ref5 !== void 0 ? _ref5 : true;
          requestAnimationFrame(function () {
            return (0, _main.dispatchShouldHideDecorations)(editorView, shouldHide);
          });
        } else {
          var _ref6, _typeAheadState$isOpe2, _editorDisabledState$2;
          /**
           * There are a number of conditions we should not show the marker,
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          var _shouldHide = (_ref6 = (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe2 = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe2 !== void 0 ? _typeAheadState$isOpe2 : false) || isForcedHidden || ((_editorDisabledState$2 = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$2 !== void 0 ? _editorDisabledState$2 : false)) !== null && _ref6 !== void 0 ? _ref6 : true;
          requestAnimationFrame(function () {
            return (0, _main.dispatchShouldHideDecorations)(editorView, _shouldHide);
          });
        }
      }, [editorView, focusState, typeAheadState, isForcedHidden, editorDisabledState]);
    },
    contentComponent: function contentComponent() {
      return /*#__PURE__*/_react.default.createElement(_globalStyles.GlobalStylesWrapper, null);
    }
  };
};
function cleanupHiddenDecoration(api) {
  var hasRun = false;
  return function () {
    var _api$selectionMarker3;
    if (!hasRun && api !== null && api !== void 0 && (_api$selectionMarker3 = api.selectionMarker) !== null && _api$selectionMarker3 !== void 0 && (_api$selectionMarker3 = _api$selectionMarker3.sharedState.currentState()) !== null && _api$selectionMarker3 !== void 0 && _api$selectionMarker3.isForcedHidden) {
      var _api$core2;
      hasRun = true;
      return api === null || api === void 0 || (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions.execute(function (_ref7) {
        var tr = _ref7.tr;
        return tr.setMeta(_main.key, {
          forceHide: false
        });
      });
    }
  };
}