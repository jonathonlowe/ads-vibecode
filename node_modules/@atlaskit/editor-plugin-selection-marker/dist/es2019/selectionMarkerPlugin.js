import React, { useEffect, useRef } from 'react';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { useSharedPluginStateSelector } from '@atlaskit/editor-common/use-shared-plugin-state-selector';
import { fg } from '@atlaskit/platform-feature-flags';
import { createPlugin, dispatchShouldHideDecorations, key } from './pm-plugins/main';
import { GlobalStylesWrapper } from './ui/global-styles';
export const selectionMarkerPlugin = ({
  config,
  api
}) => {
  return {
    name: 'selectionMarker',
    pmPlugins() {
      return [{
        name: 'selectionMarkerPmPlugin',
        plugin: () => createPlugin(api)
      }];
    },
    getSharedState(editorState) {
      var _key$getState$forceHi, _key$getState, _key$getState2;
      if (!editorState) {
        return undefined;
      }
      return {
        isForcedHidden: (_key$getState$forceHi = (_key$getState = key.getState(editorState)) === null || _key$getState === void 0 ? void 0 : _key$getState.forceHide) !== null && _key$getState$forceHi !== void 0 ? _key$getState$forceHi : false,
        isMarkerActive: !((_key$getState2 = key.getState(editorState)) !== null && _key$getState2 !== void 0 && _key$getState2.shouldHideDecorations)
      };
    },
    actions: {
      // For now this is a very simple locking mechanism that only allows one
      // plugin to hide / release at a time.
      hideDecoration: () => {
        var _api$selectionMarker, _api$selectionMarker$, _api$core;
        if (api !== null && api !== void 0 && (_api$selectionMarker = api.selectionMarker) !== null && _api$selectionMarker !== void 0 && (_api$selectionMarker$ = _api$selectionMarker.sharedState.currentState()) !== null && _api$selectionMarker$ !== void 0 && _api$selectionMarker$.isForcedHidden) {
          return undefined;
        }
        const success = api === null || api === void 0 ? void 0 : (_api$core = api.core) === null || _api$core === void 0 ? void 0 : _api$core.actions.execute(({
          tr
        }) => tr.setMeta(key, {
          forceHide: true
        }));
        if (!success) {
          return undefined;
        }
        return cleanupHiddenDecoration(api);
      },
      queueHideDecoration: setCleanup => {
        const result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
        if (result === undefined) {
          var _api$selectionMarker2;
          const cleanup = api === null || api === void 0 ? void 0 : (_api$selectionMarker2 = api.selectionMarker) === null || _api$selectionMarker2 === void 0 ? void 0 : _api$selectionMarker2.sharedState.onChange(({
            nextSharedState
          }) => {
            if ((nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isForcedHidden) === false && (nextSharedState === null || nextSharedState === void 0 ? void 0 : nextSharedState.isMarkerActive) === false) {
              const result = api === null || api === void 0 ? void 0 : api.selectionMarker.actions.hideDecoration();
              setCleanup(result);
              cleanup === null || cleanup === void 0 ? void 0 : cleanup();
            }
          });
          return cleanup;
        }
        setCleanup(result);
        return () => {};
      }
    },
    usePluginHook({
      editorView
    }) {
      const editorHasNotBeenFocused = useRef(true);
      useEffect(() => {
        // relatch when editorView changes (pretty good signal for reinit)
        editorHasNotBeenFocused.current = true;
      }, [editorView]);
      const {
        focusState,
        typeAheadState,
        editorDisabledState
      } = useSharedPluginState(api, ['focus', 'typeAhead', 'editorDisabled', 'selectionMarker']);
      const isForcedHidden = useSharedPluginStateSelector(api, 'selectionMarker.isForcedHidden');
      useEffect(() => {
        if (fg('platform_editor_no_cursor_on_live_doc_init')) {
          var _ref, _typeAheadState$isOpe, _editorDisabledState$;
          // On editor init we should use this latch to keep the marker hidden until
          // editor has received focus. This means editor will be initially hidden until
          // the first focus occurs, and after first focus the normal above rules will
          // apply
          if ((focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) === true) {
            editorHasNotBeenFocused.current = false;
          }

          /**
           * There are a number of conditions we should not show the marker,
           * - Editor has not been focused: to keep the marker hidden until first focus if config is set
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          const shouldHide = (_ref = (config === null || config === void 0 ? void 0 : config.hideCursorOnInit) && editorHasNotBeenFocused.current || (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe !== void 0 ? _typeAheadState$isOpe : false) || isForcedHidden || ((_editorDisabledState$ = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$ !== void 0 ? _editorDisabledState$ : false)) !== null && _ref !== void 0 ? _ref : true;
          requestAnimationFrame(() => dispatchShouldHideDecorations(editorView, shouldHide));
        } else {
          var _ref2, _typeAheadState$isOpe2, _editorDisabledState$2;
          /**
           * There are a number of conditions we should not show the marker,
           * - Focus: to ensure it doesn't interrupt the normal cursor
           * - Typeahead Open: To ensure it doesn't show when we're typing in the typeahead
           * - Disabled: So that it behaves similar to the renderer in live pages/disabled
           * - Via the API: If another plugin has requested it to be hidden (force hidden).
           */
          const shouldHide = (_ref2 = (focusState === null || focusState === void 0 ? void 0 : focusState.hasFocus) || ((_typeAheadState$isOpe2 = typeAheadState === null || typeAheadState === void 0 ? void 0 : typeAheadState.isOpen) !== null && _typeAheadState$isOpe2 !== void 0 ? _typeAheadState$isOpe2 : false) || isForcedHidden || ((_editorDisabledState$2 = editorDisabledState === null || editorDisabledState === void 0 ? void 0 : editorDisabledState.editorDisabled) !== null && _editorDisabledState$2 !== void 0 ? _editorDisabledState$2 : false)) !== null && _ref2 !== void 0 ? _ref2 : true;
          requestAnimationFrame(() => dispatchShouldHideDecorations(editorView, shouldHide));
        }
      }, [editorView, focusState, typeAheadState, isForcedHidden, editorDisabledState]);
    },
    contentComponent() {
      return /*#__PURE__*/React.createElement(GlobalStylesWrapper, null);
    }
  };
};
function cleanupHiddenDecoration(api) {
  let hasRun = false;
  return () => {
    var _api$selectionMarker3, _api$selectionMarker4;
    if (!hasRun && api !== null && api !== void 0 && (_api$selectionMarker3 = api.selectionMarker) !== null && _api$selectionMarker3 !== void 0 && (_api$selectionMarker4 = _api$selectionMarker3.sharedState.currentState()) !== null && _api$selectionMarker4 !== void 0 && _api$selectionMarker4.isForcedHidden) {
      var _api$core2;
      hasRun = true;
      return api === null || api === void 0 ? void 0 : (_api$core2 = api.core) === null || _api$core2 === void 0 ? void 0 : _api$core2.actions.execute(({
        tr
      }) => tr.setMeta(key, {
        forceHide: false
      }));
    }
  };
}