import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
/**
 * Everything in this file is to smooth out the migration of the new date picker
 * (https://product-fabric.atlassian.net/browse/DSP-20682). When that ticket is
 * complete, all of these functions will ilkely be merged back into the date
 * picker. Please do not pre-optimize and put these back into the date picker
 * unless you are working on the DTP Refresh and you have a good reason to do
 * so, thank you!
 *
 * All variables within the `di` objects are dependency injections. They should
 * be read from within the component at the end of the day. But because we are
 * extracting them, we have to inject them in every place manually. When we
 * re-introduce them to the components, we can likely remove the `di` variables
 * and instead use internal variables.
 *
 * If component _only_ has injected variables, it is fully internal and was
 * broken out to be it's own function.
 */

import { format, lastDayOfMonth, parseISO } from 'date-fns';
import { convertTokens } from './parse-tokens';
import { defaultDateFormat, padToTwo, placeholderDatetime } from './index';
export var isDateDisabled = function isDateDisabled(date, di) {
  var disabled = di.disabled;
  return disabled.indexOf(date) > -1;
};
export var getParsedISO = function getParsedISO(di) {
  var iso = di.iso;
  var _iso$split = iso.split('-'),
    _iso$split2 = _slicedToArray(_iso$split, 3),
    year = _iso$split2[0],
    month = _iso$split2[1],
    date = _iso$split2[2];
  var newIso = iso;
  var parsedDate = parseInt(date, 10);
  var parsedMonth = parseInt(month, 10);
  var parsedYear = parseInt(year, 10);
  var lastDayInMonth = lastDayOfMonth(new Date(parsedYear, parsedMonth - 1) // This needs to be -1, because the Date constructor expects an index of the given month
  ).getDate();
  if (lastDayInMonth < parsedDate) {
    newIso = "".concat(parsedYear, "-").concat(padToTwo(parsedMonth), "-").concat(padToTwo(lastDayInMonth));
  } else {
    newIso = "".concat(parsedYear, "-").concat(padToTwo(parsedMonth), "-").concat(padToTwo(parsedDate));
  }
  return newIso;
};

/**
 * There are two props that can change how the date is parsed.
 * The priority of props used is:
 *   1. `parseInputValue`
 *   2. `locale`
 */
export var parseDate = function parseDate(date, di) {
  var parseInputValue = di.parseInputValue,
    dateFormat = di.dateFormat,
    l10n = di.l10n;
  if (parseInputValue) {
    return parseInputValue(date, dateFormat || defaultDateFormat);
  }
  return l10n.parseDate(date);
};

/**
 * There are multiple props that can change how the date is formatted.
 * The priority of props used is:
 *   1. `formatDisplayLabel`
 *   2. `dateFormat`
 *   3. `locale`
 */
export var formatDate = function formatDate(value, di) {
  var formatDisplayLabel = di.formatDisplayLabel,
    dateFormat = di.dateFormat,
    l10n = di.l10n;
  if (formatDisplayLabel) {
    return formatDisplayLabel(value, dateFormat || defaultDateFormat);
  }
  var date = parseISO(value);
  return dateFormat ? format(date, convertTokens(dateFormat)) : l10n.formatDate(date);
};
export var getPlaceholder = function getPlaceholder(di) {
  var placeholder = di.placeholder,
    l10n = di.l10n;
  return placeholder || l10n.formatDate(placeholderDatetime);
};