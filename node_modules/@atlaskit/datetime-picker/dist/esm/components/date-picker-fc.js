/* date-picker-fc.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["appearance", "autoFocus", "clearControlLabel", "hideIcon", "openCalendarLabel", "defaultIsOpen", "defaultValue", "disabled", "disabledDateFilter", "icon", "id", "innerProps", "inputLabel", "inputLabelId", "isDisabled", "isInvalid", "isRequired", "label", "name", "onBlur", "onChange", "onFocus", "selectProps", "shouldShowCalendarButton", "spacing", "locale", "value", "isOpen", "maxDate", "minDate", "weekStartDay", "formatDisplayLabel", "testId", "aria-describedby", "placeholder", "nextMonthLabel", "previousMonthLabel"];
import "./date-picker-fc.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { forwardRef, useCallback, useEffect, useReducer, useRef, useState } from 'react';
import { isValid, parseISO } from 'date-fns';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import { IconButton } from '@atlaskit/button/new';
import { cx } from '@atlaskit/css';
import { useId } from '@atlaskit/ds-lib/use-id';
import CalendarIcon from '@atlaskit/icon/core/migration/calendar';
import { createLocalizationProvider } from '@atlaskit/locale';
import { fg } from '@atlaskit/platform-feature-flags';
import { Box } from '@atlaskit/primitives/compiled';
import Select, { mergeStyles } from '@atlaskit/select';
import { EmptyComponent } from '../internal';
import { formatDate, getParsedISO, getPlaceholder, isDateDisabled, parseDate } from '../internal/date-picker-migration';
import { IndicatorsContainer as _IndicatorsContainer } from '../internal/indicators-container';
import { Menu } from '../internal/menu';
import { getSafeCalendarValue, getShortISOString } from '../internal/parse-date';
import { makeSingleValue } from '../internal/single-value';
var packageName = "@atlaskit/datetime-picker";
var packageVersion = "17.0.1";
var styles = {
  pickerContainerStyle: "_kqswh2mm",
  dropdownIndicatorStyles: "_1ul91k8s _1tke1k8s _1e0c1txw _4cvr1h6o _1bah1h6o",
  iconContainerStyles: "_v564vrg3 _1e0c1txw _4t3i1osq _kqswstnw _4cvr1h6o _i0dl1kw7 _syaz131l _152tze3t _rjxpze3t _30l31gjq",
  iconSpacingWithClearButtonStyles: "_12l2xy5q",
  iconSpacingWithoutClearButtonStyles: "_12l21b66"
};
var analyticsAttributes = {
  componentName: 'datePicker',
  packageName: packageName,
  packageVersion: packageVersion
};

/**
 * __Date picker__
 *
 * A date picker allows the user to select a particular date.
 *
 * - [Examples](https://atlassian.design/components/datetime-picker/date-picker/examples)
 * - [Code](https://atlassian.design/components/datetime-picker/date-picker/code)
 * - [Usage](https://atlassian.design/components/datetime-picker/date-picker/usage)
 */
var DatePicker = /*#__PURE__*/forwardRef(function (props, forwardedRef) {
  var containerRef = useRef(null);
  var calendarRef = useRef(null);
  var calendarButtonRef = useRef(null);
  var _props$appearance = props.appearance,
    appearance = _props$appearance === void 0 ? 'default' : _props$appearance,
    _props$autoFocus = props.autoFocus,
    autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
    _props$clearControlLa = props.clearControlLabel,
    clearControlLabel = _props$clearControlLa === void 0 ? 'Clear' : _props$clearControlLa,
    _props$hideIcon = props.hideIcon,
    hideIcon = _props$hideIcon === void 0 ? false : _props$hideIcon,
    _props$openCalendarLa = props.openCalendarLabel,
    openCalendarLabel = _props$openCalendarLa === void 0 ? 'Open calendar' : _props$openCalendarLa,
    _props$defaultIsOpen = props.defaultIsOpen,
    defaultIsOpen = _props$defaultIsOpen === void 0 ? false : _props$defaultIsOpen,
    _props$defaultValue = props.defaultValue,
    defaultValue = _props$defaultValue === void 0 ? '' : _props$defaultValue,
    _props$disabled = props.disabled,
    disabled = _props$disabled === void 0 ? [] : _props$disabled,
    _props$disabledDateFi = props.disabledDateFilter,
    disabledDateFilter = _props$disabledDateFi === void 0 ? function (_) {
      return false;
    } : _props$disabledDateFi,
    _props$icon = props.icon,
    Icon = _props$icon === void 0 ? CalendarIcon : _props$icon,
    _props$id = props.id,
    id = _props$id === void 0 ? '' : _props$id,
    _props$innerProps = props.innerProps,
    innerProps = _props$innerProps === void 0 ? {} : _props$innerProps,
    _props$inputLabel = props.inputLabel,
    inputLabel = _props$inputLabel === void 0 ? 'Date picker' : _props$inputLabel,
    inputLabelId = props.inputLabelId,
    _props$isDisabled = props.isDisabled,
    isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,
    _props$isInvalid = props.isInvalid,
    isInvalid = _props$isInvalid === void 0 ? false : _props$isInvalid,
    _props$isRequired = props.isRequired,
    isRequired = _props$isRequired === void 0 ? false : _props$isRequired,
    _props$label = props.label,
    label = _props$label === void 0 ? '' : _props$label,
    _props$name = props.name,
    name = _props$name === void 0 ? '' : _props$name,
    _props$onBlur = props.onBlur,
    onBlur = _props$onBlur === void 0 ? function (_event) {} : _props$onBlur,
    _props$onChange = props.onChange,
    onChangeProp = _props$onChange === void 0 ? function (_value) {} : _props$onChange,
    _props$onFocus = props.onFocus,
    onFocus = _props$onFocus === void 0 ? function (_event) {} : _props$onFocus,
    _props$selectProps = props.selectProps,
    selectProps = _props$selectProps === void 0 ? {} : _props$selectProps,
    shouldShowCalendarButton = props.shouldShowCalendarButton,
    _props$spacing = props.spacing,
    spacing = _props$spacing === void 0 ? 'default' : _props$spacing,
    _props$locale = props.locale,
    propLocale = _props$locale === void 0 ? 'en-US' : _props$locale,
    propValue = props.value,
    isOpenProp = props.isOpen,
    maxDate = props.maxDate,
    minDate = props.minDate,
    weekStartDay = props.weekStartDay,
    formatDisplayLabel = props.formatDisplayLabel,
    testId = props.testId,
    ariaDescribedBy = props['aria-describedby'],
    placeholder = props.placeholder,
    nextMonthLabel = props.nextMonthLabel,
    previousMonthLabel = props.previousMonthLabel,
    rest = _objectWithoutProperties(props, _excluded);
  var _useState = useState(defaultIsOpen),
    _useState2 = _slicedToArray(_useState, 2),
    isOpen = _useState2[0],
    setIsOpen = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    _ = _useState4[0],
    setIsFocused = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    clearingFromIcon = _useState6[0],
    setClearingFromIcon = _useState6[1];
  var _useState7 = useState(selectProps.inputValue),
    _useState8 = _slicedToArray(_useState7, 2),
    selectInputValue = _useState8[0],
    setSelectInputValue = _useState8[1];
  var _useState9 = useState(propValue || defaultValue),
    _useState10 = _slicedToArray(_useState9, 2),
    value = _useState10[0],
    setValue = _useState10[1];
  var _useState11 = useState(propValue || defaultValue || getShortISOString(new Date())),
    _useState12 = _slicedToArray(_useState11, 2),
    calendarValue = _useState12[0],
    setCalendarValue = _useState12[1];
  var _useState13 = useState(createLocalizationProvider(propLocale)),
    _useState14 = _slicedToArray(_useState13, 2),
    l10n = _useState14[0],
    setL10n = _useState14[1];
  var _useState15 = useState(propLocale),
    _useState16 = _slicedToArray(_useState15, 2),
    locale = _useState16[0],
    setLocale = _useState16[1];
  var _useState17 = useState(false),
    _useState18 = _slicedToArray(_useState17, 2),
    shouldSetFocusOnCurrentDay = _useState18[0],
    setShouldSetFocusOnCurrentDay = _useState18[1];
  var _useState19 = useState(false),
    _useState20 = _slicedToArray(_useState19, 2),
    isKeyDown = _useState20[0],
    setIsKeyDown = _useState20[1];
  var _useState21 = useState(false),
    _useState22 = _slicedToArray(_useState21, 2),
    wasOpenedFromCalendarButton = _useState22[0],
    setWasOpenedFromCalendarButton = _useState22[1];

  // Hack to force update: https://legacy.reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate
  var _useReducer = useReducer(function (x) {
      return !x;
    }, true),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    forceUpdate = _useReducer2[1];
  var onChangePropWithAnalytics = usePlatformLeafEventHandler(_objectSpread({
    fn: onChangeProp,
    action: 'selectedDate',
    actionSubject: 'datePicker'
  }, analyticsAttributes));
  if (propLocale !== locale) {
    setL10n(createLocalizationProvider(propLocale));
    setLocale(propLocale);
  }
  useEffect(function () {
    // We don't want the focus to move if this is a click event
    if (!isKeyDown) {
      return;
    }
    if (isOpen && wasOpenedFromCalendarButton) {
      var _calendarRef$current;
      setIsKeyDown(false);
      // Focus on the first button within the calendar
      calendarRef === null || calendarRef === void 0 || (_calendarRef$current = calendarRef.current) === null || _calendarRef$current === void 0 || (_calendarRef$current = _calendarRef$current.querySelector('button')) === null || _calendarRef$current === void 0 || _calendarRef$current.focus();
    }
  }, [isKeyDown, calendarRef, isOpen, wasOpenedFromCalendarButton]);
  var getValue = function getValue() {
    return propValue !== null && propValue !== void 0 ? propValue : value;
  };
  var getIsOpen = function getIsOpen() {
    return isOpenProp !== null && isOpenProp !== void 0 ? isOpenProp : isOpen;
  };
  var onCalendarChange = function onCalendarChange(_ref) {
    var iso = _ref.iso;
    setCalendarValue(getParsedISO({
      iso: iso
    }));
  };
  var onCalendarSelect = function onCalendarSelect(_ref2) {
    var iso = _ref2.iso;
    setSelectInputValue('');
    setIsOpen(false);
    setCalendarValue(iso);
    setValue(iso);
    setWasOpenedFromCalendarButton(false);
    onChangePropWithAnalytics(iso);

    // Yes, this is not ideal. The alternative is to be able to place a ref
    // on the inner input of Select itself, which would require a lot of
    // extra stuff in the Select component for only this one thing. While
    // this would be more "React-y", it doesn't seem to pose any other
    // benefits. Performance-wise, we are only searching within the
    // container, so it's quick.
    if (wasOpenedFromCalendarButton) {
      var _calendarButtonRef$cu;
      (_calendarButtonRef$cu = calendarButtonRef.current) === null || _calendarButtonRef$cu === void 0 || _calendarButtonRef$cu.focus();
    } else {
      var _containerRef$current;
      var innerCombobox = containerRef === null || containerRef === void 0 || (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector('[role="combobox"]');
      innerCombobox === null || innerCombobox === void 0 || innerCombobox.focus();
    }
    setIsOpen(false);
  };
  var onInputClick = function onInputClick() {
    if (!isDisabled && !getIsOpen()) {
      setIsOpen(true);
      setWasOpenedFromCalendarButton(false);
    }
  };
  var onContainerBlur = function onContainerBlur(event) {
    var _containerRef$current2;
    var newlyFocusedElement = event.relatedTarget;
    if (!(containerRef !== null && containerRef !== void 0 && (_containerRef$current2 = containerRef.current) !== null && _containerRef$current2 !== void 0 && _containerRef$current2.contains(newlyFocusedElement))) {
      setIsOpen(false);
      setShouldSetFocusOnCurrentDay(false);
      setWasOpenedFromCalendarButton(false);
      onBlur(event);
    }
  };
  var onContainerFocus = function onContainerFocus() {
    setShouldSetFocusOnCurrentDay(false);
  };
  var onSelectBlur = function onSelectBlur(event) {
    var _containerRef$current3;
    var newlyFocusedElement = event.relatedTarget;
    if (clearingFromIcon) {
      // Don't close menu if blurring after the user has clicked clear
      setClearingFromIcon(false);
    } else if (!(containerRef !== null && containerRef !== void 0 && (_containerRef$current3 = containerRef.current) !== null && _containerRef$current3 !== void 0 && _containerRef$current3.contains(newlyFocusedElement))) {
      // Don't close menu if focus is staying within the date picker's
      // container. Makes keyboard accessibility of calendar possible
      setIsOpen(false);
      setIsFocused(false);
      setWasOpenedFromCalendarButton(false);
    }
  };
  var onSelectFocus = function onSelectFocus(event) {
    var value = getValue();
    if (clearingFromIcon) {
      // Don't open menu if focussing after the user has clicked clear
      setClearingFromIcon(false);
    } else {
      // Don't open when focused into via keyboard if the calendar button is present
      setIsOpen(!shouldShowCalendarButton);
      setCalendarValue(value);
      setIsFocused(true);
      setWasOpenedFromCalendarButton(false);
    }
    onFocus(event);
  };
  var onTextInput = function onTextInput(event) {
    var inputValue = event.target.value;
    if (inputValue) {
      var parsed = parseDate(inputValue, {
        parseInputValue: rest === null || rest === void 0 ? void 0 : rest.parseInputValue,
        dateFormat: rest === null || rest === void 0 ? void 0 : rest.dateFormat,
        l10n: l10n
      });
      // Only try to set the date if we have month & day
      if (parsed && isValid(parsed)) {
        // We format the parsed date to YYYY-MM-DD here because
        // this is the format expected by the @atlaskit/calendar component
        setCalendarValue(getShortISOString(parsed));
      }
    }
    setIsOpen(true);
    setWasOpenedFromCalendarButton(false);
  };
  var onInputKeyDown = function onInputKeyDown(event) {
    var value = getValue();
    var keyPressed = event.key.toLowerCase();

    // If the input is focused and the calendar is not visible, handle space and enter clicks
    if (!isOpen && (keyPressed === 'enter' || keyPressed === ' ')) {
      setIsOpen(true);
      setWasOpenedFromCalendarButton(false);
    }
    switch (keyPressed) {
      case 'escape':
        // Yes, this is not ideal. The alternative is to be able to place a ref
        // on the inner input of Select itself, which would require a lot of
        // extra stuff in the Select component for only this one thing. While
        // this would be more "React-y", it doesn't seem to pose any other
        // benefits. Performance-wise, we are only searching within the
        // container, so it's quick.
        if (wasOpenedFromCalendarButton) {
          var _calendarButtonRef$cu2;
          (_calendarButtonRef$cu2 = calendarButtonRef.current) === null || _calendarButtonRef$cu2 === void 0 || _calendarButtonRef$cu2.focus();
        } else {
          var _containerRef$current4;
          var innerCombobox = containerRef === null || containerRef === void 0 || (_containerRef$current4 = containerRef.current) === null || _containerRef$current4 === void 0 ? void 0 : _containerRef$current4.querySelector('[role="combobox"]');
          innerCombobox === null || innerCombobox === void 0 || innerCombobox.focus();
        }
        setIsOpen(false);
        setShouldSetFocusOnCurrentDay(false);
        setWasOpenedFromCalendarButton(false);
        break;
      case 'backspace':
      case 'delete':
        {
          var inputCount = 0;
          if (value && event.target instanceof HTMLInputElement && event.target.value.length <= inputCount) {
            // If being cleared from keyboard, don't change behaviour
            setClearingFromIcon(false);
            setValue('');
          }
          break;
        }
      case 'enter':
        if (!isOpen) {
          return;
        }
        // Prevent form submission when a date is selected
        // using enter. See https://product-fabric.atlassian.net/browse/DSP-2501
        // for more details.
        event.preventDefault();
        if (!isDateDisabled(calendarValue, {
          disabled: disabled
        })) {
          // Get a safe `calendarValue` in case the value exceeds the maximum
          // allowed by ISO 8601
          var safeCalendarValue = getSafeCalendarValue(calendarValue);
          var valueChanged = safeCalendarValue !== value;
          setSelectInputValue('');
          setIsOpen(false);
          setValue(safeCalendarValue);
          setCalendarValue(safeCalendarValue);
          setWasOpenedFromCalendarButton(wasOpenedFromCalendarButton);
          if (valueChanged) {
            onChangePropWithAnalytics(safeCalendarValue);
          }
        }
        break;
      case 'arrowdown':
      case 'arrowup':
        if (!shouldSetFocusOnCurrentDay) {
          setIsOpen(true);
          setShouldSetFocusOnCurrentDay(true);
        }
        break;
      default:
        break;
    }
  };
  var onCalendarButtonKeyDown = function onCalendarButtonKeyDown(e) {
    // Don't allow an arrow up or down to open the menu, since the input key
    // down handler is actually on the parent.
    if (e.type === 'keydown' && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
      e.stopPropagation();
    }
    // We want to stop this from triggering other keydown events, particularly
    // for space and enter presses. Otherwise, it opens and then closes
    // immediately.
    if (e.type === 'keydown' && (e.key === ' ' || e.key === 'Enter')) {
      e.stopPropagation();
      setIsKeyDown(true);
      setWasOpenedFromCalendarButton(true);
    }
  };

  // This event handler is triggered from both keydown and click. It's weird.
  var onCalendarButtonClick = function onCalendarButtonClick(e) {
    setIsOpen(!isOpen);
    setWasOpenedFromCalendarButton(true);
    e.stopPropagation();
  };
  var onClear = function onClear() {
    setValue('');
    setCalendarValue(defaultValue || getShortISOString(new Date()));
    if (!hideIcon) {
      setClearingFromIcon(true);
    }
    onChangePropWithAnalytics('');
  };

  // `unknown` is used because `value` is unused so it does not matter.
  var onSelectChange = function onSelectChange(_value, action) {
    // Used for native clear event in React Select
    // Triggered when clicking ClearIndicator or backspace with no value
    if (action.action === 'clear') {
      onClear();
    }
  };
  var handleSelectInputChange = function handleSelectInputChange(selectInputValue, actionMeta) {
    if (selectProps.onInputChange) {
      selectProps.onInputChange(selectInputValue, actionMeta);
    }
    setSelectInputValue(selectInputValue);
  };
  var getContainerRef = useCallback(function (ref) {
    var oldRef = containerRef.current;
    containerRef.current = ref;

    // Cause a re-render if we're getting the container ref for the first time
    // as the layered menu requires it for dimension calculation
    if (oldRef == null && ref != null) {
      forceUpdate();
    }
  }, [containerRef]);
  var getterValue = getValue();
  var actualSelectInputValue;
  actualSelectInputValue = selectInputValue;
  var menuIsOpen = getIsOpen() && !isDisabled;
  var showClearIndicator = Boolean((getterValue || selectInputValue) && !hideIcon);
  var clearIndicator = Icon;

  // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
  if (fg('platform-visual-refresh-icons')) {
    clearIndicator = function clearIndicator(props) {
      return /*#__PURE__*/React.createElement(Box, {
        xcss: styles.dropdownIndicatorStyles
      }, /*#__PURE__*/React.createElement(Icon, props));
    };
  }
  var dropDownIcon = appearance === 'subtle' || hideIcon || showClearIndicator ? null : clearIndicator;
  var SingleValue = makeSingleValue({
    lang: propLocale
  });
  var selectComponents = _objectSpread(_objectSpread(_objectSpread({}, selectProps.components), {}, {
    DropdownIndicator: shouldShowCalendarButton ? EmptyComponent : dropDownIcon
  }, shouldShowCalendarButton ? {
    IndicatorsContainer: function IndicatorsContainer(props) {
      return /*#__PURE__*/React.createElement(_IndicatorsContainer, _extends({}, props, {
        showClearIndicator: showClearIndicator
      }));
    }
  } : {}), {}, {
    Menu: Menu,
    SingleValue: SingleValue
  }, !showClearIndicator && {
    ClearIndicator: EmptyComponent
  });
  var _selectProps$styles = selectProps.styles,
    selectStyles = _selectProps$styles === void 0 ? {} : _selectProps$styles;
  var disabledStyle = isDisabled ? {
    pointerEvents: 'none',
    color: "var(--ds-icon-disabled, inherit)"
  } : {};
  var calendarProps = {
    calendarContainerRef: containerRef.current,
    calendarDisabled: disabled,
    calendarDisabledDateFilter: disabledDateFilter,
    calendarMaxDate: maxDate,
    calendarMinDate: minDate,
    calendarRef: calendarRef,
    calendarValue: getterValue && getShortISOString(parseISO(getterValue)),
    calendarView: calendarValue,
    onCalendarChange: onCalendarChange,
    onCalendarSelect: onCalendarSelect,
    calendarLocale: locale,
    calendarWeekStartDay: weekStartDay,
    shouldSetFocusOnCurrentDay: shouldSetFocusOnCurrentDay,
    /**
     * This overrides the inner wrapper the Calendar.
     * @private Please use this with extreme caution, this API may be changed in the future.
     */
    menuInnerWrapper: props === null || props === void 0 ? void 0 : props.menuInnerWrapper
  };

  // @ts-ignore -- Argument of type 'StylesConfig<OptionType, false, GroupBase<OptionType>>' is not assignable to parameter of type 'StylesConfig<OptionType, boolean, GroupBase<OptionType>>'.
  var mergedStyles = mergeStyles(selectStyles, {
    control: function control(base) {
      return _objectSpread(_objectSpread({}, base), disabledStyle);
    },
    indicatorsContainer: function indicatorsContainer(base) {
      return _objectSpread(_objectSpread({}, base), {}, {
        paddingLeft: "var(--ds-space-025, 2px)",
        // ICON_PADDING = 2
        paddingRight: "var(--ds-space-075, 6px)" // 8 - ICON_PADDING = 6
      });
    }
  });
  var initialValue = getterValue ? {
    label: formatDate(getterValue, {
      formatDisplayLabel: formatDisplayLabel,
      dateFormat: rest === null || rest === void 0 ? void 0 : rest.dateFormat,
      l10n: l10n
    }),
    value: getterValue
  } : null;

  // `label` takes precedence of the `inputLabel`
  var fullopenCalendarLabel = label || inputLabel ? "".concat(label || inputLabel, ", ").concat(openCalendarLabel) : openCalendarLabel;
  var openCalendarLabelId = "open-calendar-label--".concat(useId());
  return /*#__PURE__*/React.createElement("div", _extends({}, innerProps, {
    "data-testid": testId && "".concat(testId, "--container"),
    onBlur: onContainerBlur,
    onFocus: onContainerFocus,
    onClick: onInputClick,
    onInput: onTextInput,
    onKeyDown: onInputKeyDown,
    ref: getContainerRef
    // Since the onclick, onfocus are passed down, adding role="presentation" prevents typecheck errors.
    ,
    role: "presentation",
    className: ax([styles.pickerContainerStyle])
  }), /*#__PURE__*/React.createElement("input", {
    name: name,
    type: "hidden",
    value: getterValue,
    "data-testid": testId && "".concat(testId, "--input")
  }), /*#__PURE__*/React.createElement(Select, _extends({
    appearance: appearance,
    "aria-describedby": ariaDescribedBy,
    label: label || undefined
    // eslint-disable-next-line jsx-a11y/no-autofocus
    ,
    autoFocus: autoFocus,
    clearControlLabel: clearControlLabel,
    closeMenuOnSelect: true,
    enableAnimation: false,
    inputId: id,
    inputValue: actualSelectInputValue,
    isDisabled: isDisabled,
    isRequired: isRequired,
    menuIsOpen: menuIsOpen,
    onBlur: onSelectBlur,
    onChange: onSelectChange,
    onFocus: onSelectFocus,
    onInputChange: handleSelectInputChange,
    placeholder: getPlaceholder({
      placeholder: placeholder,
      l10n: l10n
    })
    // eslint-disable-next-line @atlaskit/design-system/no-unsafe-style-overrides
    // @ts-ignore -- Type 'OptionType' is not assignable to type '{ label: string; value: string; }'
    ,
    styles: mergedStyles,
    value: initialValue
  }, selectProps, {
    // For some reason, this and the below `styles` type error _only_ show
    // up when you alter some of the properties in the `selectComponents`
    // object. These errors are still present, and I suspect have always
    // been present, without changing the unrelated code. Ignoring as the
    // component still works as expected despite this error. And also
    // because the select refresh team may solve it later.
    components: selectComponents
    // These are below the spread because I don't know what is in
    // selectProps or not and what wil be overwritten
    ,
    isClearable: true,
    isInvalid: isInvalid,
    spacing: spacing,
    testId: testId
    // These aren't part of `Select`'s API, but we're using them here.
    // @ts-ignore --  Property 'calendarContainerRef' does not exist on type 'IntrinsicAttributes & LibraryManagedAttributes<(<Option extends unknown = OptionType, IsMulti extends boolean = false>(props: AtlaskitSelectProps<Option, IsMulti> & { ...; }) => Element), AtlaskitSelectProps<...> & { ...; }>'.
    ,
    calendarContainerRef: calendarProps.calendarContainerRef,
    calendarDisabled: calendarProps.calendarDisabled,
    calendarDisabledDateFilter: calendarProps.calendarDisabledDateFilter,
    calendarLocale: calendarProps.calendarLocale,
    calendarMaxDate: calendarProps.calendarMaxDate,
    calendarMinDate: calendarProps.calendarMinDate,
    calendarRef: calendarProps.calendarRef,
    calendarValue: calendarProps.calendarValue,
    calendarView: calendarProps.calendarView,
    calendarWeekStartDay: calendarProps.calendarWeekStartDay,
    nextMonthLabel: nextMonthLabel,
    onCalendarChange: calendarProps.onCalendarChange,
    onCalendarSelect: calendarProps.onCalendarSelect,
    previousMonthLabel: previousMonthLabel,
    shouldSetFocusOnCurrentDay: calendarProps.shouldSetFocusOnCurrentDay,
    menuInnerWrapper: calendarProps.menuInnerWrapper
  })), shouldShowCalendarButton && !isDisabled ? /*#__PURE__*/React.createElement(Box, {
    xcss: cx(styles.iconContainerStyles, value && !hideIcon ? styles.iconSpacingWithClearButtonStyles : styles.iconSpacingWithoutClearButtonStyles)
  }, /*#__PURE__*/React.createElement(IconButton, {
    appearance: "subtle",
    label: !inputLabelId ? fullopenCalendarLabel : openCalendarLabel,
    "aria-labelledby": inputLabelId ? "".concat(inputLabelId, " ").concat(openCalendarLabelId) : undefined,
    id: openCalendarLabelId,
    icon: function icon(iconProps) {
      return /*#__PURE__*/React.createElement(CalendarIcon, _extends({}, iconProps, {
        color: "var(--ds-icon, #44546F)"
      }));
    },
    onClick: onCalendarButtonClick,
    onKeyDown: onCalendarButtonKeyDown,
    ref: calendarButtonRef,
    testId: testId && "".concat(testId, "--open-calendar-button")
  })) : null);
});
export default DatePicker;