/* date-picker-class.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "./date-picker-class.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import { Component, createRef } from 'react';
import { isValid, parseISO } from 'date-fns';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import { IconButton } from '@atlaskit/button/new';
import { cx } from '@atlaskit/css';
import { IdProvider } from '@atlaskit/ds-lib/use-id';
import CalendarIcon from '@atlaskit/icon/core/migration/calendar';
import { createLocalizationProvider } from '@atlaskit/locale';
import { fg } from '@atlaskit/platform-feature-flags';
import { Box } from '@atlaskit/primitives/compiled';
import Select, { mergeStyles } from '@atlaskit/select';
import { EmptyComponent } from '../internal';
import { formatDate, getParsedISO, getPlaceholder, isDateDisabled, parseDate } from '../internal/date-picker-migration';
import { IndicatorsContainer as _IndicatorsContainer } from '../internal/indicators-container';
import { Menu } from '../internal/menu';
import { getSafeCalendarValue, getShortISOString } from '../internal/parse-date';
import { makeSingleValue } from '../internal/single-value';
var packageName = "@atlaskit/datetime-picker";
var packageVersion = "17.0.1";
var datePickerDefaultProps = {
  defaultIsOpen: false,
  defaultValue: '',
  disabled: [],
  disabledDateFilter: function disabledDateFilter(_) {
    return false;
  },
  locale: 'en-US',
  // These disables are here for proper typing when used as defaults. They
  // should *not* use the `noop` function.
  /* eslint-disable @repo/internal/react/use-noop */
  onBlur: function onBlur(_event) {},
  onChange: function onChange(_value) {},
  onFocus: function onFocus(_event) {}
  /* eslint-enable @repo/internal/react/use-noop */
  // Not including a default prop for value as it will
  // Make the component a controlled component
};
var styles = {
  pickerContainerStyles: "_kqswh2mm",
  iconContainerStyles: "_v564vrg3 _1e0c1txw _4t3i1osq _kqswstnw _4cvr1h6o _i0dl1kw7 _syaz131l _152tze3t _rjxpze3t _30l31gjq",
  iconSpacingWithClearButtonStyles: "_12l2xy5q",
  iconSpacingWithoutClearButtonStyles: "_12l21b66",
  dropdownIndicatorStyles: "_1ul91k8s _1tke1k8s _1e0c1txw _4cvr1h6o _1bah1h6o"
};

// eslint-disable-next-line @repo/internal/react/no-class-components
var DatePickerComponent = /*#__PURE__*/function (_Component) {
  function DatePickerComponent(props) {
    var _this$props$selectPro2;
    var _this;
    _classCallCheck(this, DatePickerComponent);
    _this = _callSuper(this, DatePickerComponent, [props]);
    _defineProperty(_this, "containerRef", null);
    _defineProperty(_this, "calendarRef", /*#__PURE__*/createRef());
    _defineProperty(_this, "calendarButtonRef", /*#__PURE__*/createRef());
    // All state needs to be accessed via this function so that the state is mapped from props
    // correctly to allow controlled/uncontrolled usage.
    _defineProperty(_this, "getValue", function () {
      var _this$props$value;
      return (_this$props$value = _this.props.value) !== null && _this$props$value !== void 0 ? _this$props$value : _this.state.value;
    });
    _defineProperty(_this, "getIsOpen", function () {
      var _this$props$isOpen;
      return (_this$props$isOpen = _this.props.isOpen) !== null && _this$props$isOpen !== void 0 ? _this$props$isOpen : _this.state.isOpen;
    });
    _defineProperty(_this, "onCalendarChange", function (_ref) {
      var iso = _ref.iso;
      _this.setState({
        calendarValue: getParsedISO({
          iso: iso
        })
      });
    });
    _defineProperty(_this, "onCalendarSelect", function (_ref2) {
      var iso = _ref2.iso;
      _this.setState({
        selectInputValue: '',
        isOpen: false,
        calendarValue: iso,
        value: iso,
        wasOpenedFromCalendarButton: false
      });
      _this.props.onChange(iso);

      // Yes, this is not ideal. The alternative is to be able to place a ref
      // on the inner input of Select itself, which would require a lot of
      // extra stuff in the Select component for only this one thing. While
      // this would be more "React-y", it doesn't seem to pose any other
      // benefits. Performance-wise, we are only searching within the
      // container, so it's quick.
      if (_this.state.wasOpenedFromCalendarButton) {
        var _this$calendarButtonR;
        (_this$calendarButtonR = _this.calendarButtonRef.current) === null || _this$calendarButtonR === void 0 || _this$calendarButtonR.focus();
      } else {
        var _this$containerRef;
        var innerCombobox = (_this$containerRef = _this.containerRef) === null || _this$containerRef === void 0 ? void 0 : _this$containerRef.querySelector('[role="combobox"]');
        innerCombobox === null || innerCombobox === void 0 || innerCombobox.focus();
      }
      _this.setState({
        isOpen: false
      });
    });
    _defineProperty(_this, "onInputClick", function () {
      if (!_this.props.isDisabled && !_this.getIsOpen()) {
        _this.setState({
          isOpen: true,
          wasOpenedFromCalendarButton: false
        });
      }
    });
    _defineProperty(_this, "onContainerBlur", function (event) {
      var _this$containerRef2;
      var newlyFocusedElement = event.relatedTarget;
      if (!((_this$containerRef2 = _this.containerRef) !== null && _this$containerRef2 !== void 0 && _this$containerRef2.contains(newlyFocusedElement))) {
        _this.setState({
          isOpen: false,
          shouldSetFocusOnCurrentDay: false,
          wasOpenedFromCalendarButton: false
        });
        _this.props.onBlur(event);
      }
    });
    _defineProperty(_this, "onContainerFocus", function () {
      _this.setState({
        shouldSetFocusOnCurrentDay: false
      });
    });
    _defineProperty(_this, "onSelectBlur", function (event) {
      var _this$containerRef3;
      var newlyFocusedElement = event.relatedTarget;
      if (_this.state.clearingFromIcon) {
        // Don't close menu if blurring after the user has clicked clear
        _this.setState({
          clearingFromIcon: false
        });
      } else if (!((_this$containerRef3 = _this.containerRef) !== null && _this$containerRef3 !== void 0 && _this$containerRef3.contains(newlyFocusedElement))) {
        // Don't close menu if focus is staying within the date picker's
        // container. Makes keyboard accessibility of calendar possible
        _this.setState({
          isOpen: false,
          isFocused: false,
          wasOpenedFromCalendarButton: false
        });
      }
    });
    _defineProperty(_this, "onSelectFocus", function (event) {
      var clearingFromIcon = _this.state.clearingFromIcon;
      var value = _this.getValue();
      if (clearingFromIcon) {
        // Don't open menu if focussing after the user has clicked clear
        _this.setState({
          clearingFromIcon: false
        });
      } else {
        _this.setState({
          // Don't open when focused into via keyboard if the calendar button is present
          isOpen: !_this.props.shouldShowCalendarButton,
          calendarValue: value,
          isFocused: true,
          wasOpenedFromCalendarButton: false
        });
      }
      _this.props.onFocus(event);
    });
    _defineProperty(_this, "onTextInput", function (event) {
      var inputValue = event.target.value;
      if (inputValue) {
        var parsed = parseDate(inputValue, {
          parseInputValue: _this.props.parseInputValue,
          dateFormat: _this.props.dateFormat,
          l10n: _this.state.l10n
        });
        // Only try to set the date if we have month & day
        if (parsed && isValid(parsed)) {
          // We format the parsed date to YYYY-MM-DD here because
          // this is the format expected by the @atlaskit/calendar component
          _this.setState({
            calendarValue: getShortISOString(parsed)
          });
        }
      }
      _this.setState({
        isOpen: true,
        wasOpenedFromCalendarButton: false
      });
    });
    _defineProperty(_this, "onInputKeyDown", function (event) {
      var calendarValue = _this.state.calendarValue;
      var value = _this.getValue();
      var keyPressed = event.key.toLowerCase();

      // If the input is focused and the calendar is not visible, handle space and enter clicks
      if (!_this.state.isOpen && (keyPressed === 'enter' || keyPressed === ' ')) {
        _this.setState({
          isOpen: true,
          wasOpenedFromCalendarButton: false
        });
      }
      switch (keyPressed) {
        case 'escape':
          // Yes, this is not ideal. The alternative is to be able to place a ref
          // on the inner input of Select itself, which would require a lot of
          // extra stuff in the Select component for only this one thing. While
          // this would be more "React-y", it doesn't seem to pose any other
          // benefits. Performance-wise, we are only searching within the
          // container, so it's quick.
          if (_this.state.wasOpenedFromCalendarButton) {
            var _this$calendarButtonR2;
            (_this$calendarButtonR2 = _this.calendarButtonRef.current) === null || _this$calendarButtonR2 === void 0 || _this$calendarButtonR2.focus();
          } else {
            var _this$containerRef4;
            var innerCombobox = (_this$containerRef4 = _this.containerRef) === null || _this$containerRef4 === void 0 ? void 0 : _this$containerRef4.querySelector('[role="combobox"]');
            innerCombobox === null || innerCombobox === void 0 || innerCombobox.focus();
          }
          _this.setState({
            isOpen: false,
            shouldSetFocusOnCurrentDay: false,
            wasOpenedFromCalendarButton: false
          });
          break;
        case 'backspace':
        case 'delete':
          {
            var inputCount = 0;
            if (value && event.target instanceof HTMLInputElement && event.target.value.length <= inputCount) {
              // If being cleared from keyboard, don't change behaviour
              _this.setState({
                clearingFromIcon: false,
                value: ''
              });
            }
            break;
          }
        case 'enter':
          if (!_this.state.isOpen) {
            return;
          }
          // Prevent form submission when a date is selected
          // using enter. See https://product-fabric.atlassian.net/browse/DSP-2501
          // for more details.
          event.preventDefault();
          if (!isDateDisabled(calendarValue, {
            disabled: _this.props.disabled
          })) {
            // Get a safe `calendarValue` in case the value exceeds the maximum
            // allowed by ISO 8601
            var safeCalendarValue = getSafeCalendarValue(calendarValue);
            var valueChanged = safeCalendarValue !== value;
            _this.setState({
              selectInputValue: '',
              isOpen: false,
              value: safeCalendarValue,
              calendarValue: safeCalendarValue,
              wasOpenedFromCalendarButton: false
            });
            if (valueChanged) {
              _this.props.onChange(safeCalendarValue);
            }
          }
          break;
        case 'arrowdown':
        case 'arrowup':
          if (!_this.state.shouldSetFocusOnCurrentDay) {
            _this.setState({
              isOpen: true,
              shouldSetFocusOnCurrentDay: true
            });
          }
          break;
        default:
          break;
      }
    });
    _defineProperty(_this, "onCalendarButtonKeyDown", function (e) {
      // Don't allow an arrow up or down to open the menu, since the input key
      // down handler is actually on the parent.
      if (e.type === 'keydown' && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
        e.stopPropagation();
      }
      // We want to stop this from triggering other keydown events, particularly
      // for space and enter presses. Otherwise, it opens and then closes
      // immediately.
      if (e.type === 'keydown' && (e.key === ' ' || e.key === 'Enter')) {
        e.stopPropagation();
        _this.setState({
          isKeyDown: true,
          wasOpenedFromCalendarButton: true
        });
      }
    });
    // This event handler is triggered from both keydown and click. It's weird.
    _defineProperty(_this, "onCalendarButtonClick", function (e) {
      _this.setState({
        isOpen: !_this.state.isOpen,
        wasOpenedFromCalendarButton: true
      }, function () {
        var _this$calendarRef;
        // We don't want the focus to move if this is a click event
        if (!_this.state.isKeyDown) {
          return;
        }
        _this.setState({
          isKeyDown: false
        });

        // Focus on the first button within the calendar
        (_this$calendarRef = _this.calendarRef) === null || _this$calendarRef === void 0 || (_this$calendarRef = _this$calendarRef.current) === null || _this$calendarRef === void 0 || (_this$calendarRef = _this$calendarRef.querySelector('button')) === null || _this$calendarRef === void 0 || _this$calendarRef.focus();
      });
      e.stopPropagation();
    });
    _defineProperty(_this, "onClear", function () {
      var changedState = {
        value: '',
        calendarValue: _this.props.defaultValue || getShortISOString(new Date())
      };
      if (!_this.props.hideIcon) {
        changedState = _objectSpread(_objectSpread({}, changedState), {}, {
          clearingFromIcon: true
        });
      }
      _this.setState(changedState);
      _this.props.onChange('');
    });
    // `unknown` is used because `value` is unused so it does not matter.
    _defineProperty(_this, "onSelectChange", function (_value, action) {
      // Used for native clear event in React Select
      // Triggered when clicking ClearIndicator or backspace with no value
      if (action.action === 'clear') {
        _this.onClear();
      }
    });
    _defineProperty(_this, "handleSelectInputChange", function (selectInputValue, actionMeta) {
      var _this$props$selectPro;
      var onInputChange = (_this$props$selectPro = _this.props.selectProps) === null || _this$props$selectPro === void 0 ? void 0 : _this$props$selectPro.onInputChange;
      if (onInputChange) {
        onInputChange(selectInputValue, actionMeta);
      }
      _this.setState({
        selectInputValue: selectInputValue
      });
    });
    _defineProperty(_this, "getContainerRef", function (ref) {
      var oldRef = _this.containerRef;
      _this.containerRef = ref;
      // Cause a re-render if we're getting the container ref for the first time
      // as the layered menu requires it for dimension calculation
      if (oldRef == null && ref != null) {
        _this.forceUpdate();
      }
    });
    _this.state = {
      isKeyDown: false,
      isOpen: _this.props.defaultIsOpen,
      isFocused: false,
      clearingFromIcon: false,
      selectInputValue: ((_this$props$selectPro2 = _this.props.selectProps) === null || _this$props$selectPro2 === void 0 ? void 0 : _this$props$selectPro2.inputValue) || '',
      value: _this.props.value || _this.props.defaultValue,
      calendarValue: _this.props.value || _this.props.defaultValue || getShortISOString(new Date()),
      l10n: createLocalizationProvider(_this.props.locale),
      locale: _this.props.locale,
      shouldSetFocusOnCurrentDay: false,
      wasOpenedFromCalendarButton: false
    };
    return _this;
  }
  _inherits(DatePickerComponent, _Component);
  return _createClass(DatePickerComponent, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props,
        _this$props$appearanc = _this$props.appearance,
        appearance = _this$props$appearanc === void 0 ? 'default' : _this$props$appearanc,
        ariaDescribedBy = _this$props['aria-describedby'],
        _this$props$autoFocus = _this$props.autoFocus,
        autoFocus = _this$props$autoFocus === void 0 ? false : _this$props$autoFocus,
        _this$props$clearCont = _this$props.clearControlLabel,
        clearControlLabel = _this$props$clearCont === void 0 ? 'Clear' : _this$props$clearCont,
        _this$props$hideIcon = _this$props.hideIcon,
        hideIcon = _this$props$hideIcon === void 0 ? false : _this$props$hideIcon,
        _this$props$openCalen = _this$props.openCalendarLabel,
        openCalendarLabel = _this$props$openCalen === void 0 ? 'Open calendar' : _this$props$openCalen,
        disabled = _this$props.disabled,
        disabledDateFilter = _this$props.disabledDateFilter,
        _this$props$icon = _this$props.icon,
        Icon = _this$props$icon === void 0 ? CalendarIcon : _this$props$icon,
        _this$props$id = _this$props.id,
        id = _this$props$id === void 0 ? '' : _this$props$id,
        _this$props$innerProp = _this$props.innerProps,
        innerProps = _this$props$innerProp === void 0 ? {} : _this$props$innerProp,
        _this$props$inputLabe = _this$props.inputLabel,
        inputLabel = _this$props$inputLabe === void 0 ? 'Date picker' : _this$props$inputLabe,
        inputLabelId = _this$props.inputLabelId,
        _this$props$isDisable = _this$props.isDisabled,
        isDisabled = _this$props$isDisable === void 0 ? false : _this$props$isDisable,
        _this$props$isInvalid = _this$props.isInvalid,
        isInvalid = _this$props$isInvalid === void 0 ? false : _this$props$isInvalid,
        _this$props$isRequire = _this$props.isRequired,
        isRequired = _this$props$isRequire === void 0 ? false : _this$props$isRequire,
        _this$props$label = _this$props.label,
        label = _this$props$label === void 0 ? '' : _this$props$label,
        locale = _this$props.locale,
        maxDate = _this$props.maxDate,
        minDate = _this$props.minDate,
        _this$props$name = _this$props.name,
        name = _this$props$name === void 0 ? '' : _this$props$name,
        nextMonthLabel = _this$props.nextMonthLabel,
        previousMonthLabel = _this$props.previousMonthLabel,
        _this$props$selectPro3 = _this$props.selectProps,
        selectProps = _this$props$selectPro3 === void 0 ? {} : _this$props$selectPro3,
        shouldShowCalendarButton = _this$props.shouldShowCalendarButton,
        _this$props$spacing = _this$props.spacing,
        spacing = _this$props$spacing === void 0 ? 'default' : _this$props$spacing,
        testId = _this$props.testId,
        weekStartDay = _this$props.weekStartDay;
      var _this$state = this.state,
        calendarValue = _this$state.calendarValue,
        selectInputValue = _this$state.selectInputValue;
      var value = this.getValue();
      var actualSelectInputValue;
      actualSelectInputValue = selectInputValue;
      var menuIsOpen = this.getIsOpen() && !isDisabled;
      var showClearIndicator = Boolean((value || selectInputValue) && !hideIcon);
      var clearIndicator = Icon;

      // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
      if (fg('platform-visual-refresh-icons')) {
        clearIndicator = function clearIndicator(props) {
          return /*#__PURE__*/React.createElement(Box, {
            xcss: styles.dropdownIndicatorStyles
          }, /*#__PURE__*/React.createElement(Icon, props));
        };
      }
      var dropDownIcon = appearance === 'subtle' || hideIcon || showClearIndicator ? null : clearIndicator;
      var SingleValue = makeSingleValue({
        lang: this.props.locale
      });
      var selectComponents = _objectSpread(_objectSpread(_objectSpread({
        DropdownIndicator: shouldShowCalendarButton ? EmptyComponent : dropDownIcon
      }, shouldShowCalendarButton ? {
        IndicatorsContainer: function IndicatorsContainer(props) {
          return /*#__PURE__*/React.createElement(_IndicatorsContainer, _extends({}, props, {
            showClearIndicator: showClearIndicator
          }));
        }
      } : {}), {}, {
        Menu: Menu,
        SingleValue: SingleValue
      }, !showClearIndicator && {
        ClearIndicator: EmptyComponent
      }), selectProps.components);
      var _selectProps$styles = selectProps.styles,
        selectStyles = _selectProps$styles === void 0 ? {} : _selectProps$styles;
      var disabledStyle = isDisabled ? {
        pointerEvents: 'none',
        color: "var(--ds-icon-disabled, inherit)"
      } : {};
      var calendarProps = {
        calendarContainerRef: this.containerRef,
        calendarDisabled: disabled,
        calendarDisabledDateFilter: disabledDateFilter,
        calendarMaxDate: maxDate,
        calendarMinDate: minDate,
        calendarRef: this.calendarRef,
        calendarValue: value && getShortISOString(parseISO(value)),
        calendarView: calendarValue,
        onCalendarChange: this.onCalendarChange,
        onCalendarSelect: this.onCalendarSelect,
        calendarLocale: locale,
        calendarWeekStartDay: weekStartDay,
        shouldSetFocusOnCurrentDay: this.state.shouldSetFocusOnCurrentDay,
        menuInnerWrapper: this.props.menuInnerWrapper
      };

      // @ts-ignore -- Argument of type 'StylesConfig<OptionType, false, GroupBase<OptionType>>' is not assignable to parameter of type 'StylesConfig<OptionType, boolean, GroupBase<OptionType>>'.
      var mergedStyles = mergeStyles(selectStyles, {
        control: function control(base) {
          return _objectSpread(_objectSpread({}, base), disabledStyle);
        },
        indicatorsContainer: function indicatorsContainer(base) {
          return _objectSpread(_objectSpread({}, base), {}, {
            paddingLeft: "var(--ds-space-025, 2px)",
            // ICON_PADDING = 2
            paddingRight: "var(--ds-space-075, 6px)" // 8 - ICON_PADDING = 6
          });
        }
      });
      var initialValue = value ? {
        label: formatDate(value, {
          formatDisplayLabel: this.props.formatDisplayLabel,
          dateFormat: this.props.dateFormat,
          l10n: this.state.l10n
        }),
        value: value
      } : null;

      // `label` takes precedence of the `inputLabel`
      var fullopenCalendarLabel = label || inputLabel ? "".concat(label || inputLabel, ", ").concat(openCalendarLabel) : openCalendarLabel;
      return /*#__PURE__*/React.createElement("div", _extends({}, innerProps, {
        // Since the onclick, onfocus are passed down, adding role="presentation" prevents typecheck errors.
        role: "presentation",
        onBlur: this.onContainerBlur,
        onFocus: this.onContainerFocus,
        onClick: this.onInputClick,
        onInput: this.onTextInput,
        onKeyDown: this.onInputKeyDown,
        ref: this.getContainerRef,
        "data-testid": testId && "".concat(testId, "--container"),
        className: ax([styles.pickerContainerStyles])
      }), /*#__PURE__*/React.createElement("input", {
        name: name,
        type: "hidden",
        value: value,
        "data-testid": testId && "".concat(testId, "--input")
      }), /*#__PURE__*/React.createElement(Select, _extends({
        appearance: this.props.appearance,
        "aria-describedby": ariaDescribedBy,
        label: label || undefined
        // eslint-disable-next-line jsx-a11y/no-autofocus
        ,
        autoFocus: autoFocus,
        clearControlLabel: clearControlLabel,
        closeMenuOnSelect: true,
        enableAnimation: false,
        inputId: id,
        inputValue: actualSelectInputValue,
        isDisabled: isDisabled,
        isRequired: isRequired,
        menuIsOpen: menuIsOpen,
        onBlur: this.onSelectBlur,
        onChange: this.onSelectChange,
        onFocus: this.onSelectFocus,
        onInputChange: this.handleSelectInputChange,
        placeholder: getPlaceholder({
          placeholder: this.props.placeholder,
          l10n: this.state.l10n
        })
        // @ts-ignore -- Argument of type 'StylesConfig<OptionType, false, GroupBase<OptionType>>' is not assignable to parameter of type 'StylesConfig<OptionType, boolean, GroupBase<OptionType>>'
        ,
        styles: mergedStyles,
        value: initialValue
      }, selectProps, {
        // For some reason, this and the below `styles` type error _only_ show
        // up when you alter some of the properties in the `selectComponents`
        // object. These errors are still present, and I suspect have always
        // been present, without changing the unrelated code. Ignoring as the
        // component still works as expected despite this error. And also
        // because the select refresh team may solve it later.
        components: selectComponents
        // These are below the spread because I don't know what is in
        // selectProps or not and what wil be overwritten
        ,
        isClearable: true,
        isInvalid: isInvalid,
        spacing: spacing,
        testId: testId
        // These aren't part of `Select`'s API, but we're using them here.
        // @ts-ignore --  Property 'calendarContainerRef' does not exist on type 'IntrinsicAttributes & LibraryManagedAttributes<(<Option extends unknown = OptionType, IsMulti extends boolean = false>(props: AtlaskitSelectProps<Option, IsMulti> & { ...; }) => Element), AtlaskitSelectProps<...> & { ...; }>'.
        ,
        calendarContainerRef: calendarProps.calendarContainerRef,
        calendarDisabled: calendarProps.calendarDisabled,
        calendarDisabledDateFilter: calendarProps.calendarDisabledDateFilter,
        calendarLocale: calendarProps.calendarLocale,
        calendarMaxDate: calendarProps.calendarMaxDate,
        calendarMinDate: calendarProps.calendarMinDate,
        calendarRef: calendarProps.calendarRef,
        calendarValue: calendarProps.calendarValue,
        calendarView: calendarProps.calendarView,
        calendarWeekStartDay: calendarProps.calendarWeekStartDay,
        nextMonthLabel: nextMonthLabel,
        onCalendarChange: calendarProps.onCalendarChange,
        onCalendarSelect: calendarProps.onCalendarSelect,
        previousMonthLabel: previousMonthLabel,
        shouldSetFocusOnCurrentDay: calendarProps.shouldSetFocusOnCurrentDay,
        menuInnerWrapper: calendarProps.menuInnerWrapper
      })), shouldShowCalendarButton && !isDisabled ? /*#__PURE__*/React.createElement(IdProvider, {
        prefix: "open-calendar-label--"
      }, function (_ref3) {
        var openCalendarLabelId = _ref3.id;
        return /*#__PURE__*/React.createElement(Box, {
          xcss: cx(styles.iconContainerStyles, value && !hideIcon ? styles.iconSpacingWithClearButtonStyles : styles.iconSpacingWithoutClearButtonStyles)
        }, /*#__PURE__*/React.createElement(IconButton, {
          appearance: "subtle",
          label: !inputLabelId ? fullopenCalendarLabel : openCalendarLabel,
          "aria-labelledby": inputLabelId ? "".concat(inputLabelId, " ").concat(openCalendarLabelId) : undefined,
          id: openCalendarLabelId,
          icon: function icon(iconProps) {
            return /*#__PURE__*/React.createElement(CalendarIcon, _extends({}, iconProps, {
              color: "var(--ds-icon, #44546F)"
            }));
          },
          onClick: _this2.onCalendarButtonClick,
          onKeyDown: _this2.onCalendarButtonKeyDown,
          ref: _this2.calendarButtonRef,
          testId: testId && "".concat(testId, "--open-calendar-button")
        }));
      }) : null);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.locale !== prevState.locale) {
        return {
          l10n: createLocalizationProvider(nextProps.locale),
          locale: nextProps.locale
        };
      } else {
        return null;
      }
    }
  }]);
}(Component);
_defineProperty(DatePickerComponent, "defaultProps", datePickerDefaultProps);
export { DatePickerComponent as DatePickerWithoutAnalytics };

/**
 * __Date picker__
 *
 * A date picker allows the user to select a particular date.
 *
 * - [Examples](https://atlassian.design/components/datetime-picker/date-picker/examples)
 * - [Code](https://atlassian.design/components/datetime-picker/date-picker/code)
 * - [Usage](https://atlassian.design/components/datetime-picker/date-picker/usage)
 */
var DatePicker = withAnalyticsContext({
  componentName: 'datePicker',
  packageName: packageName,
  packageVersion: packageVersion
})(withAnalyticsEvents({
  onChange: createAndFireEvent('atlaskit')({
    action: 'selectedDate',
    actionSubject: 'datePicker',
    attributes: {
      componentName: 'datePicker',
      packageName: packageName,
      packageVersion: packageVersion
    }
  })
})(DatePickerComponent));
export default DatePicker;