"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseDate = exports.isDateDisabled = exports.getPlaceholder = exports.getParsedISO = exports.formatDate = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _dateFns = require("date-fns");
var _parseTokens = require("./parse-tokens");
var _index = require("./index");
/**
 * Everything in this file is to smooth out the migration of the new date picker
 * (https://product-fabric.atlassian.net/browse/DSP-20682). When that ticket is
 * complete, all of these functions will ilkely be merged back into the date
 * picker. Please do not pre-optimize and put these back into the date picker
 * unless you are working on the DTP Refresh and you have a good reason to do
 * so, thank you!
 *
 * All variables within the `di` objects are dependency injections. They should
 * be read from within the component at the end of the day. But because we are
 * extracting them, we have to inject them in every place manually. When we
 * re-introduce them to the components, we can likely remove the `di` variables
 * and instead use internal variables.
 *
 * If component _only_ has injected variables, it is fully internal and was
 * broken out to be it's own function.
 */

var isDateDisabled = exports.isDateDisabled = function isDateDisabled(date, di) {
  var disabled = di.disabled;
  return disabled.indexOf(date) > -1;
};
var getParsedISO = exports.getParsedISO = function getParsedISO(di) {
  var iso = di.iso;
  var _iso$split = iso.split('-'),
    _iso$split2 = (0, _slicedToArray2.default)(_iso$split, 3),
    year = _iso$split2[0],
    month = _iso$split2[1],
    date = _iso$split2[2];
  var newIso = iso;
  var parsedDate = parseInt(date, 10);
  var parsedMonth = parseInt(month, 10);
  var parsedYear = parseInt(year, 10);
  var lastDayInMonth = (0, _dateFns.lastDayOfMonth)(new Date(parsedYear, parsedMonth - 1) // This needs to be -1, because the Date constructor expects an index of the given month
  ).getDate();
  if (lastDayInMonth < parsedDate) {
    newIso = "".concat(parsedYear, "-").concat((0, _index.padToTwo)(parsedMonth), "-").concat((0, _index.padToTwo)(lastDayInMonth));
  } else {
    newIso = "".concat(parsedYear, "-").concat((0, _index.padToTwo)(parsedMonth), "-").concat((0, _index.padToTwo)(parsedDate));
  }
  return newIso;
};

/**
 * There are two props that can change how the date is parsed.
 * The priority of props used is:
 *   1. `parseInputValue`
 *   2. `locale`
 */
var parseDate = exports.parseDate = function parseDate(date, di) {
  var parseInputValue = di.parseInputValue,
    dateFormat = di.dateFormat,
    l10n = di.l10n;
  if (parseInputValue) {
    return parseInputValue(date, dateFormat || _index.defaultDateFormat);
  }
  return l10n.parseDate(date);
};

/**
 * There are multiple props that can change how the date is formatted.
 * The priority of props used is:
 *   1. `formatDisplayLabel`
 *   2. `dateFormat`
 *   3. `locale`
 */
var formatDate = exports.formatDate = function formatDate(value, di) {
  var formatDisplayLabel = di.formatDisplayLabel,
    dateFormat = di.dateFormat,
    l10n = di.l10n;
  if (formatDisplayLabel) {
    return formatDisplayLabel(value, dateFormat || _index.defaultDateFormat);
  }
  var date = (0, _dateFns.parseISO)(value);
  return dateFormat ? (0, _dateFns.format)(date, (0, _parseTokens.convertTokens)(dateFormat)) : l10n.formatDate(date);
};
var getPlaceholder = exports.getPlaceholder = function getPlaceholder(di) {
  var placeholder = di.placeholder,
    l10n = di.l10n;
  return placeholder || l10n.formatDate(_index.placeholderDatetime);
};