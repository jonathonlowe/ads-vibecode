import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useEffect, useState } from 'react';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { useCurrentValueRef } from '../utils/useCurrentValueRef';
import { usePrevious } from '../utils/usePrevious';
import { MediaSVGError } from './errors';
// We need to convert the blob into Base64 for security reasons: https://asecurityteam.atlassian.net/browse/VULN-1495952
// Make sure to update the test helper mockFileReader if this is changed
function blobToBase64(blob) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.onloadend = function () {
      return resolve(
      // reader.readAsDataURL makes reader.result a string
      // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL
      reader.result);
    };
    reader.onerror = function (e) {
      return reject(new MediaSVGError('blob-to-datauri', e instanceof Error ? e : undefined));
    };
    reader.readAsDataURL(blob);
  });
}
var getLocalSvg = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(preview) {
    var _yield$preview, value;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return preview;
        case 2:
          _yield$preview = _context.sent;
          value = _yield$preview.value;
          if (!(typeof value === 'string')) {
            _context.next = 6;
            break;
          }
          return _context.abrupt("return", value);
        case 6:
          return _context.abrupt("return", blobToBase64(value));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getLocalSvg(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getRemoteSvg = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2, mediaClient) {
    var id, collectionName, blob;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          id = _ref2.id, collectionName = _ref2.collectionName;
          _context2.next = 3;
          return mediaClient.mediaStore.getFileBinary(id, collectionName).catch(function (e) {
            throw new MediaSVGError('binary-fetch', e instanceof Error ? e : undefined);
          });
        case 3:
          blob = _context2.sent;
          _context2.next = 6;
          return blobToBase64(blob);
        case 6:
          return _context2.abrupt("return", _context2.sent);
        case 7:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getRemoteSvg(_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
export var useResolveSvg = function useResolveSvg(identifier, onError) {
  var mediaClient = useMediaClient();
  var id = identifier.id,
    collectionName = identifier.collectionName;
  var _ref4 = usePrevious(identifier) || identifier,
    prevId = _ref4.id;
  var _useFileState = useFileState(id, {
      collectionName: collectionName
    }),
    fileState = _useFileState.fileState;
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    svgUrl = _useState2[0],
    setSvgUrl = _useState2[1];
  var _useState3 = useState(undefined),
    _useState4 = _slicedToArray(_useState3, 2),
    source = _useState4[0],
    setSource = _useState4[1];
  var onErrorRef = useCurrentValueRef(onError);
  useEffect(function () {
    if (id !== prevId) {
      setSvgUrl(undefined);
    }
  }, [id, prevId]);
  useEffect(function () {
    if (svgUrl || !fileState || fileState.status === 'error' || (fileState === null || fileState === void 0 ? void 0 : fileState.mimeType) !== 'image/svg+xml') {
      return;
    }
    var preview = fileState.preview;
    if (preview) {
      getLocalSvg(preview).then(function (content) {
        setSvgUrl(content);
        setSource('local');
      }).catch(onErrorRef.current);
    } else {
      getRemoteSvg(identifier, mediaClient).then(function (content) {
        setSvgUrl(content);
        setSource('remote');
      }).catch(onErrorRef.current);
    }
  }, [identifier, fileState, mediaClient, onErrorRef, svgUrl]);
  return {
    svgUrl: svgUrl,
    source: source
  };
};