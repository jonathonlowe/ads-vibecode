"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.resolveCallbacks = resolveCallbacks;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _adfSchema = require("@atlaskit/adf-schema");
var _keymaps = require("@atlaskit/editor-common/keymaps");
var _commands = require("@atlaskit/editor-prosemirror/commands");
var _history = require("@atlaskit/editor-prosemirror/history");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _setKeyboardHeight = require("./editor-commands/set-keyboard-height");
var _disableSpellChecking = _interopRequireDefault(require("./pm-plugins/disable-spell-checking"));
var _filterSteps = _interopRequireDefault(require("./pm-plugins/filter-steps"));
var _frozenEditor = _interopRequireDefault(require("./pm-plugins/frozen-editor"));
var _inlineCursorTarget = _interopRequireDefault(require("./pm-plugins/inline-cursor-target"));
var _lazyNodeViewDecoration = require("./pm-plugins/lazy-node-view-decoration");
var _newlinePreserveMarks = _interopRequireDefault(require("./pm-plugins/newline-preserve-marks"));
var _plugin = _interopRequireDefault(require("./pm-plugins/scroll-gutter/plugin"));
var _getKeyboardHeight = require("./pm-plugins/scroll-gutter/util/get-keyboard-height");
var _inputTrackingConfig = require("./pm-plugins/utils/inputTrackingConfig");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function resolveCallbacks(from, to, tr, callbacks) {
  var doc = tr.doc;
  doc.nodesBetween(from, to, function (node, pos) {
    callbacks.forEach(function (cb) {
      return cb({
        tr: tr,
        node: node,
        pos: pos,
        from: from,
        to: to
      });
    });
  });
}
var SMART_TO_ASCII = {
  '…': '...',
  '→': '->',
  '←': '<-',
  '–': '--',
  '“': '"',
  '”': '"',
  '‘': "'",
  '’': "'"
};

// eslint-disable-next-line require-unicode-regexp
var FIND_SMART_CHAR = new RegExp("[".concat(Object.keys(SMART_TO_ASCII).join(''), "]"), 'g');
var basePlugin = function basePlugin(_ref) {
  var _api$featureFlags, _api$base;
  var options = _ref.config,
    api = _ref.api;
  var featureFlags = (api === null || api === void 0 || (_api$featureFlags = api.featureFlags) === null || _api$featureFlags === void 0 ? void 0 : _api$featureFlags.sharedState.currentState()) || {};
  var callbacks = [];
  api === null || api === void 0 || (_api$base = api.base) === null || _api$base === void 0 || _api$base.actions.registerMarks(function (_ref2) {
    var tr = _ref2.tr,
      node = _ref2.node,
      pos = _ref2.pos,
      from = _ref2.from,
      to = _ref2.to;
    var doc = tr.doc;
    var schema = doc.type.schema;
    var textNodeType = schema.nodes.text;
    if (node.type === textNodeType && node.text) {
      // Find a valid start and end position because the text may be partially selected.
      var startPositionInSelection = Math.max(pos, from);
      var endPositionInSelection = Math.min(pos + node.nodeSize, to);
      var textForReplacing = doc.textBetween(startPositionInSelection, endPositionInSelection);
      var newText = textForReplacing.replace(FIND_SMART_CHAR, function (match) {
        var _SMART_TO_ASCII$match;
        return (_SMART_TO_ASCII$match = SMART_TO_ASCII[match]) !== null && _SMART_TO_ASCII$match !== void 0 ? _SMART_TO_ASCII$match : match;
      });
      var currentStartPos = tr.mapping.map(startPositionInSelection);
      var currentEndPos = tr.mapping.map(endPositionInSelection);
      tr.replaceWith(currentStartPos, currentEndPos, schema.text(newText, node.marks));
    }
  });
  return {
    name: 'base',
    getSharedState: function getSharedState(editorState) {
      return {
        keyboardHeight: (0, _getKeyboardHeight.getKeyboardHeight)(editorState)
      };
    },
    actions: {
      setKeyboardHeight: _setKeyboardHeight.setKeyboardHeight,
      resolveMarks: function resolveMarks(from, to, tr) {
        return resolveCallbacks(from, to, tr, callbacks);
      },
      registerMarks: function registerMarks(callback) {
        callbacks.push(callback);
      }
    },
    pmPlugins: function pmPlugins() {
      var plugins = [{
        name: 'filterStepsPlugin',
        plugin: function plugin(_ref3) {
          var dispatchAnalyticsEvent = _ref3.dispatchAnalyticsEvent;
          return (0, _filterSteps.default)(dispatchAnalyticsEvent);
        }
      }];
      if ((0, _experiments.editorExperiment)('platform_editor_exp_lazy_node_views', true, {
        exposure: true
      })) {
        plugins.push({
          name: 'lazyNodeViewDecorationsPlugin',
          plugin: function plugin() {
            return (0, _lazyNodeViewDecoration.createLazyNodeViewDecorationPlugin)();
          }
        });
      }

      // In Chrome, when the selection is placed between adjacent nodes which are not contenteditatble
      // the cursor appears at the right most point of the parent container.
      //
      // In Firefox, when the selection is placed between adjacent nodes which are not contenteditatble
      // no cursor is presented to users.
      //
      // In Safari, when the selection is placed between adjacent nodes which are not contenteditatble
      // it is not possible to navigate with arrow keys.
      //
      // This plugin works around the issues by inserting decorations between
      // inline nodes which are set as contenteditable, and have a zero width space.
      plugins.push({
        name: 'inlineCursorTargetPlugin',
        plugin: function plugin() {
          return options && options.allowInlineCursorTarget ? (0, _inlineCursorTarget.default)() : undefined;
        }
      });
      plugins.push({
        name: 'newlinePreserveMarksPlugin',
        plugin: _newlinePreserveMarks.default
      }, {
        name: 'frozenEditor',
        plugin: function plugin(_ref4) {
          var dispatchAnalyticsEvent = _ref4.dispatchAnalyticsEvent;
          return (0, _frozenEditor.default)(api === null || api === void 0 ? void 0 : api.contextIdentifier)(dispatchAnalyticsEvent, _inputTrackingConfig.inputTracking, undefined);
        }
      }, {
        name: 'history',
        plugin: function plugin() {
          return (0, _history.history)();
        }
      },
      // should be last :(
      {
        name: 'codeBlockIndent',
        plugin: function plugin() {
          return (0, _keymaps.keymap)(_objectSpread(_objectSpread({}, _commands.baseKeymap), {}, {
            'Mod-[': function Mod() {
              return true;
            },
            'Mod-]': function Mod() {
              return true;
            }
          }));
        }
      });
      if (options && options.allowScrollGutter) {
        plugins.push({
          name: 'scrollGutterPlugin',
          plugin: function plugin() {
            return (0, _plugin.default)(options.allowScrollGutter);
          }
        });
      }
      plugins.push({
        name: 'disableSpellcheckingPlugin',
        plugin: function plugin() {
          return (0, _disableSpellChecking.default)(featureFlags);
        }
      });
      return plugins;
    },
    nodes: function nodes() {
      return [{
        name: 'doc',
        node: _adfSchema.doc
      }, {
        name: 'paragraph',
        node: _adfSchema.paragraph
      }, {
        name: 'text',
        node: _adfSchema.text
      }];
    }
  };
};
var _default = exports.default = basePlugin;