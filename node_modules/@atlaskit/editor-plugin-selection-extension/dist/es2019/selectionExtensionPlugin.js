import React from 'react';
import { selectionExtensionMessages } from '@atlaskit/editor-common/messages';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { createPlugin, selectionExtensionPluginKey } from './pm-plugins/main';
import { SelectionExtensionComponentWrapper } from './ui/extension/SelectionExtensionComponentWrapper';
import { getBoundingBoxFromSelection } from './ui/getBoundingBoxFromSelection';
export const selectionExtensionPlugin = ({
  api,
  config
}) => {
  const editorViewRef = {
    current: null
  };
  return {
    name: 'selectionExtension',
    getSharedState(editorState) {
      if (!editorState) {
        return null;
      }
      return selectionExtensionPluginKey.getState(editorState) || null;
    },
    commands: {
      setActiveExtension: extension => ({
        tr
      }) => {
        return tr.setMeta(selectionExtensionPluginKey, {
          type: 'set-active-extension',
          extension
        });
      },
      clearActiveExtension: () => ({
        tr
      }) => {
        return tr.setMeta(selectionExtensionPluginKey, {
          type: 'clear-active-extension'
        });
      }
    },
    contentComponent: ({
      editorView
    }) => {
      var _api$analytics;
      return /*#__PURE__*/React.createElement(SelectionExtensionComponentWrapper, {
        editorView: editorView,
        api: api,
        editorAnalyticsAPI: api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions
      });
    },
    pluginsOptions: {
      selectionToolbar: (state, intl) => {
        var _api$editorViewMode, _api$editorViewMode$s;
        if (!config) {
          return;
        }
        const {
          pageModes,
          extensions
        } = config;

        /**
         * Extensions Config Validation
         *
         * Check whether plugin contains any selection extensions
         */
        if (!(extensions !== null && extensions !== void 0 && extensions.firstParty) && !(extensions !== null && extensions !== void 0 && extensions.external)) {
          return;
        }

        /**
         * Content Mode Validation
         *
         * Check if pageModes is provided and matches against current content mode
         *
         * TODO: This will eventially transition from mode to contentMode
         */
        const editorContentMode = api === null || api === void 0 ? void 0 : (_api$editorViewMode = api.editorViewMode) === null || _api$editorViewMode === void 0 ? void 0 : (_api$editorViewMode$s = _api$editorViewMode.sharedState.currentState()) === null || _api$editorViewMode$s === void 0 ? void 0 : _api$editorViewMode$s.mode;
        if (pageModes) {
          // Early Exit: consumer has set pageModes but editorContentMode is undefined
          if (!editorContentMode) {
            return;
          }

          // Simplify traversion of pageModes which can be string or array of strings
          const showOnModesCollection = Array.isArray(pageModes) ? pageModes : [pageModes];

          // Early Exit: consumer has set pageModes but current editorContentMode is not in the collection
          if (!showOnModesCollection.includes(editorContentMode)) {
            return;
          }
        }

        /**
         * Active Extension
         *
         * Check if there is an active extension and hide the selection extension dropdown
         */
        const selectionExtensionState = selectionExtensionPluginKey.getState(state);
        if (selectionExtensionState !== null && selectionExtensionState !== void 0 && selectionExtensionState.activeExtension) {
          return;
        }
        const getSelection = view => {
          const {
            selection: currentSelection
          } = state;
          const {
            from,
            to
          } = currentSelection;
          const text = state.doc.textBetween(from, to, '\n');
          const coords = getBoundingBoxFromSelection(view, from, to);
          return {
            text,
            from,
            to,
            coords
          };
        };
        const handleOnExtensionClick = view => extension => {
          const selection = getSelection(view);
          if (extension.component) {
            api === null || api === void 0 ? void 0 : api.core.actions.execute(api === null || api === void 0 ? void 0 : api.selectionExtension.commands.setActiveExtension({
              extension,
              selection
            }));
          }
          if (extension.onClick) {
            extension.onClick({
              selection
            });
          }
        };
        const convertExtensionToDropdownMenuItem = (extension, rank) => {
          var _extension$isDisabled;
          return {
            title: extension.name,
            icon: extension.icon ? /*#__PURE__*/React.createElement(extension.icon, {
              label: ''
            }) : undefined,
            disabled: extension === null || extension === void 0 ? void 0 : (_extension$isDisabled = extension.isDisabled) === null || _extension$isDisabled === void 0 ? void 0 : _extension$isDisabled.call(extension, {
              selection: editorViewRef.current ? getSelection(editorViewRef.current) : undefined
            }),
            rank,
            onClick: () => {
              editorViewRef.current && handleOnExtensionClick(editorViewRef.current)(extension);
              return true;
            }
          };
        };
        const getFirstPartyExtensions = extensions => {
          return extensions.map(ext => convertExtensionToDropdownMenuItem(ext, 30));
        };

        /**
         * Add a heading to the external extensions
         */
        const getExternalExtensions = extensions => {
          let externalExtensions = [];
          if (extensions !== null && extensions !== void 0 && extensions.length) {
            externalExtensions = extensions.map((ext, index) => convertExtensionToDropdownMenuItem(ext));
            const externalExtensionsHeading = {
              type: 'overflow-dropdown-heading',
              title: intl.formatMessage(selectionExtensionMessages.externalExtensionsHeading)
            };
            externalExtensions.unshift(externalExtensionsHeading);
          }
          return externalExtensions;
        };
        const groupedExtensionsArray = [...getFirstPartyExtensions(extensions.firstParty || []), ...getExternalExtensions(extensions.external || [])];
        const overflowMenu = {
          type: 'overflow-dropdown',
          dropdownWidth: 240,
          supportsViewMode: true,
          options: groupedExtensionsArray
        };
        return {
          isToolbarAbove: true,
          items: [{
            type: 'separator',
            fullHeight: true,
            supportsViewMode: true
          }, overflowMenu],
          rank: -6
        };
      }
    },
    pmPlugins: () => [{
      name: 'selectionExtension',
      plugin: () => createPlugin()
    }, {
      name: 'selectionExtensionGetEditorViewReferencePlugin',
      plugin: () => {
        return new SafePlugin({
          view: editorView => {
            editorViewRef.current = editorView;
            return {
              destroy: () => {
                editorViewRef.current = null;
              }
            };
          }
        });
      }
    }]
  };
};