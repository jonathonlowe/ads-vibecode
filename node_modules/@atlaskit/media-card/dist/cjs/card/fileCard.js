"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileCard = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _analyticsNext = require("@atlaskit/analytics-next");
var _mediaClient = require("@atlaskit/media-client");
var _mediaClientReact = require("@atlaskit/media-client-react");
var _mediaCommon = require("@atlaskit/media-common");
var _mediaViewer = require("@atlaskit/media-viewer");
var _react = _interopRequireWildcard(require("react"));
var _useCallbackRef = require("use-callback-ref");
var _errors = require("../errors");
var _types = require("../types");
var _generateUniqueId = require("../utils/generateUniqueId");
var _getDataURIDimension = require("../utils/getDataURIDimension");
var _getMediaCardCursor = require("../utils/getMediaCardCursor");
var _metadata = require("../utils/metadata");
var _ufoExperiences = require("../utils/ufoExperiences");
var _useCurrentValueRef = require("../utils/useCurrentValueRef");
var _usePrevious = require("../utils/usePrevious");
var _viewportDetector = require("../utils/viewportDetector");
var _cardDimensions = require("../utils/cardDimensions");
var _cardAnalytics = require("./cardAnalytics");
var _cardView = require("./cardView");
var _inlinePlayerLazy = require("./inlinePlayerLazy");
var _mediaFilePreview = require("@atlaskit/media-file-preview");
var _actions = require("./actions");
var _performance = require("./performance");
var _dateOverrideContext = require("../dateOverrideContext");
var _reactIntlNext = require("react-intl-next");
var _abuseModal = require("@atlaskit/media-ui/abuseModal");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _experienceTraceIdContext = require("@atlaskit/react-ufo/experience-trace-id-context");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var traceContextRetriever = function traceContextRetriever() {
  var trace = (0, _experienceTraceIdContext.getActiveTrace)();
  if (trace && (0, _platformFeatureFlags.fg)('platform-filecard-ufo-trace')) {
    return {
      traceId: trace === null || trace === void 0 ? void 0 : trace.traceId,
      spanId: trace === null || trace === void 0 ? void 0 : trace.spanId
    };
  } else {
    return {
      traceId: (0, _mediaCommon.getRandomHex)(8)
    };
  }
};
var FileCard = exports.FileCard = function FileCard(_ref) {
  var _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'auto' : _ref$appearance,
    _ref$resizeMode = _ref.resizeMode,
    resizeMode = _ref$resizeMode === void 0 ? 'crop' : _ref$resizeMode,
    _ref$isLazy = _ref.isLazy,
    isLazy = _ref$isLazy === void 0 ? true : _ref$isLazy,
    _ref$disableOverlay = _ref.disableOverlay,
    disableOverlay = _ref$disableOverlay === void 0 ? false : _ref$disableOverlay,
    _ref$featureFlags = _ref.featureFlags,
    featureFlags = _ref$featureFlags === void 0 ? {} : _ref$featureFlags,
    identifier = _ref.identifier,
    ssr = _ref.ssr,
    dimensions = _ref.dimensions,
    originalDimensions = _ref.originalDimensions,
    contextId = _ref.contextId,
    alt = _ref.alt,
    actions = _ref.actions,
    shouldEnableDownloadButton = _ref.shouldEnableDownloadButton,
    useInlinePlayer = _ref.useInlinePlayer,
    shouldOpenMediaViewer = _ref.shouldOpenMediaViewer,
    onFullscreenChange = _ref.onFullscreenChange,
    selectable = _ref.selectable,
    selected = _ref.selected,
    testId = _ref.testId,
    titleBoxBgColor = _ref.titleBoxBgColor,
    titleBoxIcon = _ref.titleBoxIcon,
    shouldHideTooltip = _ref.shouldHideTooltip,
    mediaViewerItems = _ref.mediaViewerItems,
    onClick = _ref.onClick,
    onMouseEnter = _ref.onMouseEnter,
    videoControlsWrapperRef = _ref.videoControlsWrapperRef,
    viewerOptions = _ref.viewerOptions,
    includeHashForDuplicateFiles = _ref.includeHashForDuplicateFiles;
  var _useIntl = (0, _reactIntlNext.useIntl)(),
    formatMessage = _useIntl.formatMessage;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    isAbuseModalOpen = _useState2[0],
    setIsAbuseModalOpen = _useState2[1];
  var _useAnalyticsEvents = (0, _analyticsNext.useAnalyticsEvents)(),
    createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
  //----------------------------------------------------------------//
  //------------ State, Refs & Initial Values ----------------------//
  //----------------------------------------------------------------//

  var mediaClient = (0, _mediaClientReact.useMediaClient)();
  var _useState3 = (0, _react.useState)(null),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    cardElement = _useState4[0],
    setCardElement = _useState4[1];
  var cardDimensions = dimensions || (0, _cardDimensions.getDefaultCardDimensions)(appearance);

  // Calculate the preview dimensions if card dimensions are "percentage" based
  var previewDimensions = (0, _react.useMemo)(function () {
    return (
      // resolving dimensions is eventually an expensive operation if the dimensions are a percentage
      // thus needs to be memoized
      (0, _getDataURIDimension.resolveCardPreviewDimensions)({
        dimensions: cardDimensions,
        element: cardElement
      })
    );
  }, [cardDimensions, cardElement]);
  var _useState5 = (0, _react.useState)(!isLazy),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    isCardVisible = _useState6[0],
    setIsCardVisible = _useState6[1];
  var _useFileState = (0, _mediaClientReact.useFileState)(identifier.id, {
      skipRemote: !isCardVisible,
      collectionName: identifier.collectionName,
      occurrenceKey: identifier.occurrenceKey,
      includeHashForDuplicateFiles: includeHashForDuplicateFiles
    }),
    fileState = _useFileState.fileState;
  var prevFileState = (0, _usePrevious.usePrevious)(fileState && (0, _mediaClient.isErrorFileState)(fileState) ? undefined : fileState);
  var fileStateValue = (0, _react.useMemo)(function () {
    if (fileState && !(0, _mediaClient.isErrorFileState)(fileState)) {
      return fileState;
    }
    return prevFileState;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fileState]);
  var dateOverrides = (0, _react.useContext)(_dateOverrideContext.DateOverrideContext);
  var overridenDate = dateOverrides === null || dateOverrides === void 0 ? void 0 : dateOverrides[identifier.id];

  //----------------------------------------------------------------//
  //------------ State, Refs & Initial Values ----------------------//
  //----------------------------------------------------------------//

  var internalOccurrenceKey = (0, _react.useMemo)(function () {
    return (0, _generateUniqueId.generateUniqueId)();
  }, []);
  var timeElapsedTillCommenced = (0, _react.useMemo)(function () {
    return (0, _performance.performanceNow)();
  }, []);
  var fileStateFlagsRef = (0, _react.useRef)({
    wasStatusUploading: false,
    wasStatusProcessing: false
  });
  var mediaViewerButtonRef = (0, _react.useRef)(null);

  // Generate unique traceId for file
  var traceContext = (0, _react.useMemo)(traceContextRetriever, []);
  var _useState7 = (0, _react.useState)('loading'),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    status = _useState8[0],
    setStatus = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    isPlayingFile = _useState10[0],
    setIsPlayingFile = _useState10[1];
  var _useState11 = (0, _react.useState)(false),
    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
    shouldAutoplay = _useState12[0],
    setShouldAutoplay = _useState12[1];
  var _useState13 = (0, _react.useState)(false),
    _useState14 = (0, _slicedToArray2.default)(_useState13, 2),
    previewDidRender = _useState14[0],
    setPreviewDidRender = _useState14[1];
  var mediaBlobUrlAttrs = (0, _react.useMemo)(function () {
    var id = identifier.id,
      collection = identifier.collectionName;
    var _getFileDetails = (0, _metadata.getFileDetails)(identifier, fileStateValue),
      mimeType = _getFileDetails.mimeType,
      name = _getFileDetails.name,
      size = _getFileDetails.size;
    return contextId ? _objectSpread(_objectSpread({
      id: id,
      collection: collection,
      contextId: contextId,
      mimeType: mimeType,
      name: name,
      size: size
    }, originalDimensions || previewDimensions), {}, {
      alt: alt
    }) : undefined;
  }, [alt, previewDimensions, contextId, fileStateValue, identifier, originalDimensions]);
  var _useFilePreview = (0, _mediaFilePreview.useFilePreview)({
      mediaBlobUrlAttrs: mediaBlobUrlAttrs,
      resizeMode: (0, _mediaClient.imageResizeModeToFileImageMode)(resizeMode),
      identifier: identifier,
      ssr: ssr,
      dimensions: previewDimensions,
      traceContext: traceContext,
      skipRemote: !isCardVisible,
      source: 'mediaCard'
    }),
    preview = _useFilePreview.preview,
    previewStatus = _useFilePreview.status,
    previewError = _useFilePreview.error,
    nonCriticalError = _useFilePreview.nonCriticalError,
    ssrReliability = _useFilePreview.ssrReliability,
    onImageErrorBase = _useFilePreview.onImageError,
    onImageLoadBase = _useFilePreview.onImageLoad,
    getSsrScriptProps = _useFilePreview.getSsrScriptProps,
    copyNodeRef = _useFilePreview.copyNodeRef;
  var shouldSendPerformanceEventRef = (0, _react.useRef)((0, _ufoExperiences.shouldPerformanceBeSampled)());
  var _useState15 = (0, _react.useState)(),
    _useState16 = (0, _slicedToArray2.default)(_useState15, 2),
    error = _useState16[0],
    setError = _useState16[1];

  // CXP-2723 TODO: TEMPORARY VARIABLES
  var finalError = error || (previewError && previewError.primaryReason !== 'failed-processing' && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.mimeType) !== 'image/svg+xml' ? previewError : undefined);
  var finalStatus = finalError ? 'error' : status === 'failed-processing' && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.mimeType) === 'image/svg+xml' ? 'loading-preview' : status;
  var _useState17 = (0, _react.useState)(null),
    _useState18 = (0, _slicedToArray2.default)(_useState17, 2),
    mediaViewerSelectedItem = _useState18[0],
    setMediaViewerSelectedItem = _useState18[1];
  var uploadProgressRef = (0, _react.useRef)();
  var metadata = (0, _react.useMemo)(function () {
    var getProcessingStatusFromFileState = function getProcessingStatusFromFileState(status) {
      switch (status) {
        case 'processed':
          return 'succeeded';
        case 'processing':
          return 'running';
        case 'failed-processing':
          return 'failed';
      }
    };
    if (fileStateValue) {
      return {
        id: fileStateValue.id,
        name: fileStateValue.name,
        size: fileStateValue.size,
        mimeType: fileStateValue.mimeType,
        createdAt: fileStateValue.createdAt,
        mediaType: fileStateValue.mediaType,
        processingStatus: getProcessingStatusFromFileState(fileStateValue.status)
      };
    } else {
      return {
        id: identifier.id
      };
    }
  }, [fileStateValue, identifier.id]);
  var fileAttributes = (0, _react.useMemo)(function () {
    return {
      fileMediatype: metadata.mediaType,
      fileMimetype: metadata.mimeType,
      fileId: metadata.id,
      fileSize: metadata.size,
      fileStatus: fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status
    };
  }, [fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status, metadata.id, metadata.mediaType, metadata.mimeType, metadata.size]);
  var downloadFn = (0, _react.useCallback)( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var _error;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return mediaClient.file.downloadBinary(identifier.id, metadata.name, identifier.collectionName, traceContext);
        case 3:
          (0, _cardAnalytics.fireDownloadSucceededEvent)(createAnalyticsEvent, fileAttributes, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
          _context.next = 10;
          break;
        case 6:
          _context.prev = 6;
          _context.t0 = _context["catch"](0);
          _error = new _errors.MediaCardError('download', _context.t0);
          (0, _cardAnalytics.fireDownloadFailedEvent)(createAnalyticsEvent, fileAttributes, _error, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 6]]);
  })), [createAnalyticsEvent, fileAttributes, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext, identifier.collectionName, identifier.id, mediaClient.file, metadata.name, traceContext]);
  var computedActions = (0, _react.useMemo)(function () {
    if (finalStatus === 'failed-processing' || shouldEnableDownloadButton) {
      var handler = /*#__PURE__*/function () {
        var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!(fileStateValue !== null && fileStateValue !== void 0 && fileStateValue.abuseClassification)) {
                  _context2.next = 4;
                  break;
                }
                setIsAbuseModalOpen(true);
                _context2.next = 6;
                break;
              case 4:
                _context2.next = 6;
                return downloadFn();
              case 6:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function handler() {
          return _ref3.apply(this, arguments);
        };
      }();
      var downloadAction = (0, _actions.createDownloadAction)({
        handler: handler,
        isDisabled: mediaClient.config.enforceDataSecurityPolicy
      }, formatMessage);
      return [downloadAction].concat((0, _toConsumableArray2.default)(actions !== null && actions !== void 0 ? actions : []));
    } else {
      return actions;
    }
  }, [actions, mediaClient.config.enforceDataSecurityPolicy, shouldEnableDownloadButton, finalStatus, formatMessage, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.abuseClassification, downloadFn]);

  //----------------------------------------------------------------//
  //---------------------- Analytics  ------------------------------//
  //----------------------------------------------------------------//

  var fireOperationalEventRef = (0, _useCurrentValueRef.useCurrentValueRef)(function () {
    var timeElapsedTillEvent = (0, _performance.performanceNow)();
    var durationSinceCommenced = timeElapsedTillEvent - timeElapsedTillCommenced;
    var performanceAttributes = {
      overall: {
        durationSincePageStart: timeElapsedTillEvent,
        durationSinceCommenced: durationSinceCommenced
      }
    };
    createAnalyticsEvent && (0, _cardAnalytics.fireOperationalEvent)(createAnalyticsEvent, finalStatus, fileAttributes, performanceAttributes, ssrReliability, finalError, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
    shouldSendPerformanceEventRef.current && (0, _ufoExperiences.completeUfoExperience)(internalOccurrenceKey, finalStatus, fileAttributes, fileStateFlagsRef.current, ssrReliability, finalError);
  });
  var fireNonCriticalErrorEventRef = (0, _useCurrentValueRef.useCurrentValueRef)(function (error) {
    createAnalyticsEvent && (0, _cardAnalytics.fireNonCriticalErrorEvent)(createAnalyticsEvent, finalStatus, fileAttributes, ssrReliability, error, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
  });
  (0, _react.useEffect)(function () {
    if (nonCriticalError) {
      fireNonCriticalErrorEventRef.current(nonCriticalError);
    }
  }, [nonCriticalError, fireNonCriticalErrorEventRef]);
  var startUfoExperienceRef = (0, _useCurrentValueRef.useCurrentValueRef)(function () {
    if (shouldSendPerformanceEventRef.current) {
      (0, _ufoExperiences.startUfoExperience)(internalOccurrenceKey);
    }
  });
  var fireAbortedEventRef = (0, _useCurrentValueRef.useCurrentValueRef)(function () {
    // UFO won't abort if it's already in a final state (succeeded, failed, aborted, etc)
    if (shouldSendPerformanceEventRef.current) {
      (0, _ufoExperiences.abortUfoExperience)(internalOccurrenceKey, {
        fileAttributes: fileAttributes,
        fileStateFlags: fileStateFlagsRef === null || fileStateFlagsRef === void 0 ? void 0 : fileStateFlagsRef.current,
        ssrReliability: ssrReliability
      });
    }
  });

  //----------------------------------------------------------------//
  //--------------------- Focus on Close Viewer  -------------------//
  //----------------------------------------------------------------//

  var wasViewerPreviouslyOpen = (0, _usePrevious.usePrevious)(mediaViewerSelectedItem);
  (0, _react.useEffect)(function () {
    if (wasViewerPreviouslyOpen && !mediaViewerSelectedItem) {
      var _mediaViewerButtonRef;
      (_mediaViewerButtonRef = mediaViewerButtonRef.current) === null || _mediaViewerButtonRef === void 0 || _mediaViewerButtonRef.focus();
    }
  }, [wasViewerPreviouslyOpen, mediaViewerSelectedItem]);

  //----------------------------------------------------------------//
  //---------------------- Callbacks & Handlers  -------------------//
  //----------------------------------------------------------------//

  var onSvgError = function onSvgError(error) {
    setError(error);
    setStatus('error');
  };
  var onImageError = function onImageError(newCardPreview) {
    if (metadata.mimeType === 'image/svg+xml') {
      return;
    }
    onImageErrorBase(newCardPreview);
  };
  var onSvgLoad = function onSvgLoad() {
    setPreviewDidRender(true);
  };
  var onImageLoad = function onImageLoad(newCardPreview) {
    if (metadata.mimeType === 'image/svg+xml') {
      return;
    }
    onImageLoadBase(newCardPreview);
    setPreviewDidRender(true);
  };
  var onCardClick = function onCardClick(event, analyticsEvent) {
    if (onClick) {
      var cardEvent = {
        event: event,
        mediaItemDetails: metadata
      };
      onClick(cardEvent, analyticsEvent);
    }
  };
  var onCardViewClick = function onCardViewClick(event, analyticsEvent) {
    onCardClick(event, analyticsEvent);
    if (!metadata) {
      return;
    }
    var isVideo = metadata.mediaType === 'video';
    var isBrowserSupported = metadata.mimeType && (0, _mediaCommon.isMimeTypeSupportedByBrowser)(metadata.mimeType);

    // TODO: this should be handled by Inline Player
    var isPlayable = !!fileState && (fileState.status === 'processed' || isBrowserSupported && ['processing', 'uploading'].includes(fileState.status));
    if (useInlinePlayer && isVideo && isPlayable && finalStatus !== 'error') {
      setIsPlayingFile(true);
      setShouldAutoplay(true);
    } else if (shouldOpenMediaViewer) {
      setMediaViewerSelectedItem({
        id: identifier.id,
        mediaItemType: 'file',
        collectionName: identifier.collectionName,
        occurrenceKey: identifier.occurrenceKey
      });
    }
  };

  //----------------------------------------------------------------//
  //----------------- update status flags --------------------------//
  //----------------------------------------------------------------//

  (0, _react.useEffect)(function () {
    if ((fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) === 'processing') {
      fileStateFlagsRef.current.wasStatusProcessing = true;
    } else if ((fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) === 'uploading') {
      fileStateFlagsRef.current.wasStatusUploading = true;
    }
  }, [fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status]);

  //----------------------------------------------------------------//
  //---------------- fetch and resolve card preview ----------------//
  //----------------------------------------------------------------//

  var prevStatus = (0, _usePrevious.usePrevious)(finalStatus);
  var prevIsCardVisible = (0, _usePrevious.usePrevious)(isCardVisible);
  (0, _react.useEffect)(function () {
    if (prevStatus !== undefined && finalStatus !== prevStatus) {
      fireOperationalEventRef.current();
    }
  }, [fireOperationalEventRef, prevStatus, finalStatus]);
  (0, _react.useEffect)(function () {
    var turnedVisible = !prevIsCardVisible && isCardVisible;
    if (turnedVisible) {
      startUfoExperienceRef.current();
    }
  }, [startUfoExperienceRef, isCardVisible, prevIsCardVisible]);

  //----------------------------------------------------------------//
  //----------------- set isPlayingFile state ----------------------//
  //----------------------------------------------------------------//

  (0, _react.useEffect)(function () {
    var isVideo = fileAttributes.fileMediatype === 'video';
    var _getFileDetails2 = (0, _metadata.getFileDetails)(identifier, fileStateValue),
      mimeType = _getFileDetails2.mimeType;
    var isVideoPlayable = mimeType && (0, _mediaCommon.isVideoMimeTypeSupportedByBrowser)(mimeType) || fileStateValue && (0, _mediaClient.isProcessedFileState)(fileStateValue);
    if (
    /**
     * We need to check that the card is visible before switching to inline player
     * in order to avoid race conditions of the ViewportDector being unmounted before
     * it is able to set isCardVisible to true.
     */
    isCardVisible && isVideo && !isPlayingFile && disableOverlay && useInlinePlayer && isVideoPlayable && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) !== 'failed-processing' && finalStatus !== 'error') {
      setIsPlayingFile(true);
    }
  }, [isCardVisible, disableOverlay, fileAttributes.fileMediatype, fileStateValue, identifier, isPlayingFile, finalStatus, useInlinePlayer]);

  //----------------------------------------------------------------//
  //----------------- abort UFO experience -------------------------//
  //----------------------------------------------------------------//

  (0, _react.useEffect)(function () {
    return function () {
      // eslint-disable-next-line react-hooks/exhaustive-deps
      fireAbortedEventRef.current();
    };
  }, [fireAbortedEventRef]);

  //----------------------------------------------------------------//
  // Update Status
  //----------------------------------------------------------------//

  var updateFileStateRef = (0, _useCurrentValueRef.useCurrentValueRef)(function () {
    // This effect has race condition with Complete effect. We share the same check to ovid status overrides

    // do not update the card status if the status is final
    if (['complete', 'error', 'failed-processing'].includes(finalStatus)) {
      return;
    }
    if (previewDidRender &&
    // We should't complete if status is uploading
    ['loading-preview', 'processing'].includes(finalStatus)) {
      setStatus('complete');
      // TODO MEX-788: add test for "do not remove the card preview when unsubscribing".
    } else if (fileState) {
      if (fileState.status !== 'error') {
        var newStatus;
        switch (fileState.status) {
          case 'uploading':
          case 'failed-processing':
          case 'processing':
            newStatus = fileState.status;
            break;
          case 'processed':
            // Set complete if processing is done and there is no preview
            if (!preview && previewStatus === 'complete') {
              newStatus = 'complete';
              break;
            }
            newStatus = 'loading-preview';
            break;
          default:
            newStatus = 'loading';
        }
        var newProgress = newStatus === 'uploading' && fileState.status === 'uploading' ? fileState.progress : 1;
        setStatus(newStatus);
        uploadProgressRef.current = newProgress;
      } else {
        var e = (0, _mediaClient.toCommonMediaClientError)(fileState);
        var errorReason = finalStatus === 'uploading' ? 'upload' : 'metadata-fetch';
        setError(new _errors.MediaCardError(errorReason, e));
        setStatus('error');
      }
    }
  });
  var mergedRef = (0, _useCallbackRef.useMergeRefs)([setCardElement, copyNodeRef]);
  (0, _react.useEffect)(function () {
    updateFileStateRef.current();
  }, [fileState, preview, previewStatus, updateFileStateRef, previewDidRender, finalStatus]);

  //----------------------------------------------------------------//
  // Shared Card View & SVG View resources
  //----------------------------------------------------------------//

  var mediaCardCursor = (0, _getMediaCardCursor.getMediaCardCursor)(!!useInlinePlayer, !!shouldOpenMediaViewer, finalStatus === 'error' || finalStatus === 'failed-processing', !!preview, metadata.mediaType);
  var onImageMouseEnter = function onImageMouseEnter(event) {
    onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
      event: event,
      mediaItemDetails: metadata
    });
  };

  //----------------------------------------------------------------//
  //---------------------- Render Card Function --------------------//
  //----------------------------------------------------------------//

  var renderCard = function renderCard() {
    var withCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var cardStatusOverride = arguments.length > 1 ? arguments[1] : undefined;
    var izLazyOverride = arguments.length > 2 ? arguments[2] : undefined;
    var mediaItemType = identifier.mediaItemType;
    var isLazyWithOverride = izLazyOverride === undefined ? isLazy : izLazyOverride;

    // We should natively lazy load an SSR preview when card is not visible,
    // otherwise we'll fire the metadata fetch from outside the viewport
    // Side note: We should not lazy load if the cardPreview is available from local cache,
    // in order to avoid flickers during re-mount of the component
    // CXP-2723 TODO: Create test cases for the above scenarios
    var nativeLazyLoad = isLazyWithOverride && !isCardVisible && preview && (0, _types.isSSRPreview)(preview);
    // Force Media Image to always display img for SSR
    var forceSyncDisplay = !!ssr;
    var card = /*#__PURE__*/_react.default.createElement(_cardView.CardView, {
      identifier: identifier,
      status: cardStatusOverride || finalStatus,
      error: finalError,
      mediaItemType: mediaItemType,
      metadata: metadata,
      cardPreview: preview,
      alt: alt,
      resizeMode: resizeMode,
      dimensions: cardDimensions,
      actions: computedActions,
      selectable: selectable,
      selected: selected,
      shouldOpenMediaViewer: shouldOpenMediaViewer,
      openMediaViewerButtonRef: mediaViewerButtonRef,
      onClick: withCallbacks ? onCardViewClick : undefined,
      onMouseEnter: withCallbacks ? onImageMouseEnter : undefined,
      disableOverlay: disableOverlay,
      progress: uploadProgressRef.current,
      onDisplayImage: withCallbacks ? function () {
        var payloadPart = {
          fileId: identifier.id,
          isUserCollection: identifier.collectionName === _mediaClient.RECENTS_COLLECTION
        };
        _mediaClient.globalMediaEventEmitter.emit('media-viewed', _objectSpread({
          viewingLevel: 'minimal'
        }, payloadPart));
      } : undefined,
      innerRef: mergedRef,
      testId: testId,
      titleBoxBgColor: titleBoxBgColor,
      titleBoxIcon: titleBoxIcon,
      onImageError: withCallbacks ? onImageError : undefined,
      onImageLoad: withCallbacks ? onImageLoad : undefined,
      onSvgError: onSvgError,
      onSvgLoad: onSvgLoad,
      nativeLazyLoad: nativeLazyLoad,
      forceSyncDisplay: forceSyncDisplay,
      mediaCardCursor: mediaCardCursor,
      shouldHideTooltip: shouldHideTooltip,
      overriddenCreationDate: overridenDate
    });
    return isLazyWithOverride ? /*#__PURE__*/_react.default.createElement(_viewportDetector.ViewportDetector, {
      cardEl: cardElement,
      onVisible: function onVisible() {
        setIsCardVisible(true);
      }
    }, card) : card;
  };

  //----------------------------------------------------------------//
  //-------------------------- RENDER ------------------------------//
  //----------------------------------------------------------------//

  var inlinePlayerFallback = isPlayingFile ? renderCard(false, 'loading', false) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null);
  var collectionName = identifier.collectionName || '';
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, !!(fileStateValue !== null && fileStateValue !== void 0 && fileStateValue.abuseClassification) && /*#__PURE__*/_react.default.createElement(_abuseModal.AbuseModal, {
    isOpen: isAbuseModalOpen,
    onConfirm: downloadFn,
    onClose: function onClose() {
      return setIsAbuseModalOpen(false);
    }
  }), isPlayingFile ? /*#__PURE__*/_react.default.createElement(_react.Suspense, {
    fallback: inlinePlayerFallback
  }, /*#__PURE__*/_react.default.createElement(_inlinePlayerLazy.InlinePlayerLazy, {
    dimensions: cardDimensions,
    originalDimensions: originalDimensions,
    identifier: identifier,
    autoplay: !!shouldAutoplay,
    onFullscreenChange: onFullscreenChange,
    onError: function onError(e) {
      setError(new _errors.MediaCardError('error-file-state', e));
      setStatus('error');
      setIsPlayingFile(false);
    },
    onClick: onCardClick,
    selected: selected,
    ref: setCardElement,
    testId: testId,
    cardPreview: preview,
    videoControlsWrapperRef: videoControlsWrapperRef
  })) : renderCard(), mediaViewerSelectedItem ? /*#__PURE__*/_react.default.createElement(_mediaViewer.MediaViewer, {
    collectionName: collectionName,
    items: mediaViewerItems || [],
    mediaClientConfig: mediaClient.config,
    selectedItem: mediaViewerSelectedItem,
    onClose: function onClose() {
      setMediaViewerSelectedItem(null);
    },
    contextId: contextId,
    featureFlags: featureFlags,
    viewerOptions: viewerOptions
  }) : null, getSsrScriptProps && /*#__PURE__*/_react.default.createElement("script", getSsrScriptProps()));
};