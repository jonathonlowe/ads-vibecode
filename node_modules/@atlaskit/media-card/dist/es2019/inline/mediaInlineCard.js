import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { FileFetcherError, toCommonMediaClientError } from '@atlaskit/media-client';
import { MediaInlineCardErroredView, MediaInlineCardLoadedView, MediaInlineCardLoadingView, messages } from '@atlaskit/media-ui';
import { formatDate } from '@atlaskit/media-ui/formatDate';
import { MimeTypeIcon } from '@atlaskit/media-ui/mime-type-icon';
import { MediaViewer } from '@atlaskit/media-viewer';
import Tooltip from '@atlaskit/tooltip';
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';
import { createIntl, injectIntl, IntlProvider } from 'react-intl-next';
import { MediaCardError } from '../errors';
import { fireMediaCardEvent } from '../utils/analytics';
import { getErrorStatusPayload, getFailedProcessingStatusPayload, getSucceededStatusPayload } from './mediaInlineCardAnalytics';
import { useCopyIntent } from '@atlaskit/media-client-react';
// UI component which renders an inline link in the appropiate state based on a media file
export const MediaInlineCardInternal = ({
  mediaClient,
  identifier,
  shouldOpenMediaViewer,
  shouldDisplayToolTip,
  isSelected,
  onClick,
  mediaViewerItems,
  intl,
  viewerOptions
}) => {
  const [fileState, setFileState] = useState();
  const [subscribeError, setSubscribeError] = useState();
  const [isSucceededEventSent, setIsSucceededEventSent] = useState(false);
  const [isFailedEventSent, setIsFailedEventSent] = useState(false);
  const [isMediaViewerVisible, setMediaViewerVisible] = useState(false);
  const {
    createAnalyticsEvent
  } = useAnalyticsEvents();
  const fireFailedOperationalEvent = (error = new MediaCardError('missing-error-data'), failReason) => {
    const payload = failReason ? getFailedProcessingStatusPayload(identifier.id, fileState) : getErrorStatusPayload(identifier.id, error, fileState);
    setIsFailedEventSent(true);
    fireMediaCardEvent(payload, createAnalyticsEvent);
  };
  const fireSucceededOperationalEvent = () => {
    const payload = getSucceededStatusPayload(fileState);
    setIsSucceededEventSent(true);
    fireMediaCardEvent(payload, createAnalyticsEvent);
  };
  const {
    copyNodeRef
  } = useCopyIntent(identifier.id, {
    collectionName: identifier.collectionName
  });
  const onMediaInlineCardClick = event => {
    if (onClick) {
      const inlineCardEvent = {
        event,
        mediaItemDetails: identifier
      };
      onClick(inlineCardEvent);
    }
    if (shouldOpenMediaViewer) {
      setMediaViewerVisible(true);
    }
  };
  const onMediaViewerClose = () => setMediaViewerVisible(false);
  const renderMediaViewer = () => {
    if (isMediaViewerVisible) {
      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(MediaViewer, {
        collectionName: identifier.collectionName || '',
        items: mediaViewerItems || [],
        mediaClientConfig: mediaClient.mediaClientConfig,
        selectedItem: identifier,
        onClose: onMediaViewerClose,
        viewerOptions: viewerOptions
      }), document.body);
    }
    return null;
  };
  const renderContent = children => {
    return intl ? children : /*#__PURE__*/React.createElement(IntlProvider, {
      locale: "en"
    }, children);
  };
  const defaultIntl = createIntl({
    locale: 'en'
  });
  useEffect(() => {
    const subscription = mediaClient.file.getFileState(identifier.id, {
      collectionName: identifier.collectionName
    }).subscribe({
      next: fileState => {
        setFileState(fileState);
        setSubscribeError(undefined);
      },
      error: e => {
        setSubscribeError(e);
      }
    });
    return () => {
      subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
    };
  }, [identifier.collectionName, identifier.id, mediaClient.file]);
  if (subscribeError) {
    const errorMessage = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading' ? messages.failed_to_upload : messages.couldnt_load_file;
    const errorReason = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading' ? 'upload' : 'metadata-fetch';
    !isFailedEventSent && fireFailedOperationalEvent(new MediaCardError(errorReason, subscribeError));
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(errorMessage),
      isSelected: isSelected
    });
  }
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error') {
    const error = new MediaCardError('error-file-state', toCommonMediaClientError(fileState));
    !isFailedEventSent && fireFailedOperationalEvent(error);
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.couldnt_load_file),
      isSelected: isSelected
    });
  }

  // Empty file handling
  if (fileState && !fileState.name) {
    const error = new MediaCardError('metadata-fetch', new FileFetcherError('emptyFileName', {
      id: fileState.id
    }));
    !isFailedEventSent && fireFailedOperationalEvent(error);
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.couldnt_load_file),
      isSelected: isSelected
    });
  }
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading') {
    return /*#__PURE__*/React.createElement(MediaInlineCardLoadingView, {
      innerRef: copyNodeRef,
      message: fileState.name,
      isSelected: isSelected
    });
  }
  if (!fileState) {
    return /*#__PURE__*/React.createElement(MediaInlineCardLoadingView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.loading_file),
      isSelected: isSelected
    });
  }

  // Failed to process should still display the loaded view and enable Media Client to download
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'failed-processing') {
    !isFailedEventSent && fireFailedOperationalEvent(undefined, 'failed-processing');
  }
  const {
    mediaType,
    name,
    mimeType
  } = fileState;
  const linkIcon = /*#__PURE__*/React.createElement(MimeTypeIcon, {
    testId: 'media-inline-card-file-type-icon',
    size: "small",
    mediaType: mediaType,
    mimeType: mimeType,
    name: name
  });
  const mediaViewer = renderMediaViewer();
  let formattedDate;
  if (fileState.createdAt) {
    const {
      locale = 'en'
    } = intl || {
      locale: 'en'
    };
    formattedDate = formatDate(fileState.createdAt, locale);
  }
  if (fileState.status === 'processed' && !isSucceededEventSent) {
    fireSucceededOperationalEvent();
  }
  if (shouldDisplayToolTip === undefined || shouldDisplayToolTip === true) {
    return renderContent( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Tooltip, {
      position: "bottom",
      content: formattedDate,
      tag: "span"
    }, /*#__PURE__*/React.createElement(MediaInlineCardLoadedView, {
      innerRef: copyNodeRef,
      icon: linkIcon,
      title: name,
      onClick: onMediaInlineCardClick,
      isSelected: isSelected
    })), mediaViewer));
  } else {
    return renderContent( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MediaInlineCardLoadedView, {
      innerRef: copyNodeRef,
      icon: linkIcon,
      title: name,
      onClick: onMediaInlineCardClick,
      isSelected: isSelected
    }), mediaViewer));
  }
};
export const MediaInlineCard = injectIntl(MediaInlineCardInternal, {
  enforceContext: false
});