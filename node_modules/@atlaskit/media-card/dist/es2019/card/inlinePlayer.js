import _extends from "@babel/runtime/helpers/extends";
import React, { useRef, useState, useEffect } from 'react';
import { globalMediaEventEmitter } from '@atlaskit/media-client';
import { CustomMediaPlayer, InactivityDetector } from '@atlaskit/media-ui';
import { defaultImageCardDimensions } from '../utils';
import { CardLoading } from '../utils/lightCards/cardLoading';
import { ProgressBar } from './ui/progressBar/progressBar';
import { InlinePlayerWrapper } from './inlinePlayerWrapper';
import { useBreakpoint } from './useBreakpoint';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
export const getPreferredVideoArtifact = fileState => {
  if (fileState.status === 'processed' || fileState.status === 'processing') {
    const {
      artifacts
    } = fileState;
    if (!artifacts) {
      return undefined;
    }
    return artifacts['video_1280.mp4'] ? 'video_1280.mp4' : artifacts['video_640.mp4'] ? 'video_640.mp4' : undefined;
  }
  return undefined;
};
export const InlinePlayerBase = ({
  identifier,
  onError,
  onClick,
  dimensions = defaultImageCardDimensions,
  originalDimensions,
  selected,
  testId,
  forwardRef,
  autoplay,
  cardPreview,
  onFullscreenChange,
  videoControlsWrapperRef
}) => {
  // === States ===
  const [fileSrc, setFileSrc] = useState();
  const [isUploading, setIsUploading] = useState();
  const [progress, setProgress] = useState();

  // === Refs and Local Variables ===
  const divRef = useRef(null);
  const onErrorRef = useRef(onError);
  onErrorRef.current = onError;
  const {
    id,
    collectionName,
    occurrenceKey
  } = identifier;
  const breakpoint = useBreakpoint(dimensions === null || dimensions === void 0 ? void 0 : dimensions.width, divRef);
  const mediaClient = useMediaClient();
  const {
    fileState
  } = useFileState(id, {
    collectionName,
    occurrenceKey
  });
  useEffect(() => {
    const subscribeFileState = async fileState => {
      if (fileState.status === 'uploading') {
        setIsUploading(true);
        setProgress(fileState.progress);
      } else {
        setIsUploading(false);
      }

      // We reuse the existing fileSrc to prevent re renders, therefore we only perform fileSrc updates when there isn't any
      if (fileSrc) {
        return;
      }
      if (fileState.status !== 'error' && fileState.preview) {
        const {
          value
        } = await fileState.preview;
        if (value instanceof Blob && value.type.indexOf('video/') === 0) {
          const newFileSrc = URL.createObjectURL(value);
          setFileSrc(newFileSrc);
          return;
        }
      }
      if (fileState.status === 'processed' || fileState.status === 'processing') {
        const artifactName = getPreferredVideoArtifact(fileState);
        const {
          artifacts
        } = fileState;
        if (!artifactName || !artifacts) {
          // Tries to use the binary artifact to provide something to play while the video is still processing
          try {
            const newFileSrc = await mediaClient.file.getFileBinaryURL(id, collectionName);
            setFileSrc(newFileSrc);
          } catch (error) {
            if (onErrorRef.current && error instanceof Error) {
              onErrorRef.current(error);
            }
          }
          return;
        }
        try {
          const newFileSrc = await mediaClient.file.getArtifactURL(artifacts, artifactName, collectionName);
          setFileSrc(newFileSrc);
        } catch (error) {
          if (onErrorRef.current && error instanceof Error) {
            onErrorRef.current(error);
          }
        }
      }
    };
    if (fileState) {
      subscribeFileState(fileState);
    }
  }, [fileState, collectionName, fileSrc, id, mediaClient]);
  useEffect(() => {
    return () => {
      fileSrc && URL.revokeObjectURL(fileSrc);
    };
  }, [fileSrc]);

  // === Render ===
  return fileSrc ? /*#__PURE__*/React.createElement(InlinePlayerWrapper, {
    testId: testId || 'media-card-inline-player',
    "data-vc": "media-card-inline-player",
    selected: {
      selected
    },
    onClick: onClick,
    innerRef: forwardRef || undefined,
    dimensions: dimensions
  }, /*#__PURE__*/React.createElement(InactivityDetector, null, checkMouseMovement => /*#__PURE__*/React.createElement(CustomMediaPlayer, {
    type: "video",
    src: fileSrc,
    onFullscreenChange: onFullscreenChange,
    fileId: id,
    isAutoPlay: autoplay,
    isHDAvailable: false,
    onDownloadClick: () => {
      mediaClient.file.downloadBinary(id, undefined, collectionName);
    },
    onFirstPlay: () => {
      globalMediaEventEmitter.emit('media-viewed', {
        fileId: id,
        viewingLevel: 'full'
      });
    },
    lastWatchTimeConfig: {
      contentId: id
    },
    originalDimensions: originalDimensions,
    showControls: checkMouseMovement,
    poster: cardPreview === null || cardPreview === void 0 ? void 0 : cardPreview.dataURI,
    videoControlsWrapperRef: videoControlsWrapperRef
  })), isUploading && /*#__PURE__*/React.createElement(ProgressBar, {
    progress: progress,
    breakpoint: breakpoint,
    positionBottom: true,
    showOnTop: true
  })) : /*#__PURE__*/React.createElement(CardLoading, {
    testId: testId,
    dimensions: dimensions,
    interactionName: "inline-player-loading"
  });
};
const InlinePlayerForwardRef = /*#__PURE__*/React.forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement(InlinePlayerBase, _extends({}, props, {
    forwardRef: ref
  }));
});
export const InlinePlayer = InlinePlayerForwardRef;