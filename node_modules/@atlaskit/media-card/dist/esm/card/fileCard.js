import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { globalMediaEventEmitter, RECENTS_COLLECTION, imageResizeModeToFileImageMode, isProcessedFileState, isErrorFileState, toCommonMediaClientError } from '@atlaskit/media-client';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { getRandomHex, isMimeTypeSupportedByBrowser, isVideoMimeTypeSupportedByBrowser } from '@atlaskit/media-common';
import { MediaViewer } from '@atlaskit/media-viewer';
import React, { Suspense, useEffect, useMemo, useRef, useState, useCallback } from 'react';
import { useMergeRefs } from 'use-callback-ref';
import { MediaCardError } from '../errors';
import { isSSRPreview } from '../types';
import { generateUniqueId } from '../utils/generateUniqueId';
import { resolveCardPreviewDimensions } from '../utils/getDataURIDimension';
import { getMediaCardCursor } from '../utils/getMediaCardCursor';
import { getFileDetails } from '../utils/metadata';
import { abortUfoExperience, completeUfoExperience, shouldPerformanceBeSampled, startUfoExperience } from '../utils/ufoExperiences';
import { useCurrentValueRef } from '../utils/useCurrentValueRef';
import { usePrevious } from '../utils/usePrevious';
import { ViewportDetector } from '../utils/viewportDetector';
import { getDefaultCardDimensions } from '../utils/cardDimensions';
import { fireNonCriticalErrorEvent, fireOperationalEvent, fireDownloadSucceededEvent, fireDownloadFailedEvent } from './cardAnalytics';
import { CardView } from './cardView';
import { InlinePlayerLazy } from './inlinePlayerLazy';
import { useFilePreview } from '@atlaskit/media-file-preview';
import { createDownloadAction } from './actions';
import { performanceNow } from './performance';
import { useContext } from 'react';
import { DateOverrideContext } from '../dateOverrideContext';
import { useIntl } from 'react-intl-next';
import { AbuseModal } from '@atlaskit/media-ui/abuseModal';
import { fg } from '@atlaskit/platform-feature-flags';
import { getActiveTrace } from '@atlaskit/react-ufo/experience-trace-id-context';
var traceContextRetriever = function traceContextRetriever() {
  var trace = getActiveTrace();
  if (trace && fg('platform-filecard-ufo-trace')) {
    return {
      traceId: trace === null || trace === void 0 ? void 0 : trace.traceId,
      spanId: trace === null || trace === void 0 ? void 0 : trace.spanId
    };
  } else {
    return {
      traceId: getRandomHex(8)
    };
  }
};
export var FileCard = function FileCard(_ref) {
  var _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'auto' : _ref$appearance,
    _ref$resizeMode = _ref.resizeMode,
    resizeMode = _ref$resizeMode === void 0 ? 'crop' : _ref$resizeMode,
    _ref$isLazy = _ref.isLazy,
    isLazy = _ref$isLazy === void 0 ? true : _ref$isLazy,
    _ref$disableOverlay = _ref.disableOverlay,
    disableOverlay = _ref$disableOverlay === void 0 ? false : _ref$disableOverlay,
    _ref$featureFlags = _ref.featureFlags,
    featureFlags = _ref$featureFlags === void 0 ? {} : _ref$featureFlags,
    identifier = _ref.identifier,
    ssr = _ref.ssr,
    dimensions = _ref.dimensions,
    originalDimensions = _ref.originalDimensions,
    contextId = _ref.contextId,
    alt = _ref.alt,
    actions = _ref.actions,
    shouldEnableDownloadButton = _ref.shouldEnableDownloadButton,
    useInlinePlayer = _ref.useInlinePlayer,
    shouldOpenMediaViewer = _ref.shouldOpenMediaViewer,
    onFullscreenChange = _ref.onFullscreenChange,
    selectable = _ref.selectable,
    selected = _ref.selected,
    testId = _ref.testId,
    titleBoxBgColor = _ref.titleBoxBgColor,
    titleBoxIcon = _ref.titleBoxIcon,
    shouldHideTooltip = _ref.shouldHideTooltip,
    mediaViewerItems = _ref.mediaViewerItems,
    onClick = _ref.onClick,
    onMouseEnter = _ref.onMouseEnter,
    videoControlsWrapperRef = _ref.videoControlsWrapperRef,
    viewerOptions = _ref.viewerOptions,
    includeHashForDuplicateFiles = _ref.includeHashForDuplicateFiles;
  var _useIntl = useIntl(),
    formatMessage = _useIntl.formatMessage;
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isAbuseModalOpen = _useState2[0],
    setIsAbuseModalOpen = _useState2[1];
  var _useAnalyticsEvents = useAnalyticsEvents(),
    createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
  //----------------------------------------------------------------//
  //------------ State, Refs & Initial Values ----------------------//
  //----------------------------------------------------------------//

  var mediaClient = useMediaClient();
  var _useState3 = useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    cardElement = _useState4[0],
    setCardElement = _useState4[1];
  var cardDimensions = dimensions || getDefaultCardDimensions(appearance);

  // Calculate the preview dimensions if card dimensions are "percentage" based
  var previewDimensions = useMemo(function () {
    return (
      // resolving dimensions is eventually an expensive operation if the dimensions are a percentage
      // thus needs to be memoized
      resolveCardPreviewDimensions({
        dimensions: cardDimensions,
        element: cardElement
      })
    );
  }, [cardDimensions, cardElement]);
  var _useState5 = useState(!isLazy),
    _useState6 = _slicedToArray(_useState5, 2),
    isCardVisible = _useState6[0],
    setIsCardVisible = _useState6[1];
  var _useFileState = useFileState(identifier.id, {
      skipRemote: !isCardVisible,
      collectionName: identifier.collectionName,
      occurrenceKey: identifier.occurrenceKey,
      includeHashForDuplicateFiles: includeHashForDuplicateFiles
    }),
    fileState = _useFileState.fileState;
  var prevFileState = usePrevious(fileState && isErrorFileState(fileState) ? undefined : fileState);
  var fileStateValue = useMemo(function () {
    if (fileState && !isErrorFileState(fileState)) {
      return fileState;
    }
    return prevFileState;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fileState]);
  var dateOverrides = useContext(DateOverrideContext);
  var overridenDate = dateOverrides === null || dateOverrides === void 0 ? void 0 : dateOverrides[identifier.id];

  //----------------------------------------------------------------//
  //------------ State, Refs & Initial Values ----------------------//
  //----------------------------------------------------------------//

  var internalOccurrenceKey = useMemo(function () {
    return generateUniqueId();
  }, []);
  var timeElapsedTillCommenced = useMemo(function () {
    return performanceNow();
  }, []);
  var fileStateFlagsRef = useRef({
    wasStatusUploading: false,
    wasStatusProcessing: false
  });
  var mediaViewerButtonRef = useRef(null);

  // Generate unique traceId for file
  var traceContext = useMemo(traceContextRetriever, []);
  var _useState7 = useState('loading'),
    _useState8 = _slicedToArray(_useState7, 2),
    status = _useState8[0],
    setStatus = _useState8[1];
  var _useState9 = useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    isPlayingFile = _useState10[0],
    setIsPlayingFile = _useState10[1];
  var _useState11 = useState(false),
    _useState12 = _slicedToArray(_useState11, 2),
    shouldAutoplay = _useState12[0],
    setShouldAutoplay = _useState12[1];
  var _useState13 = useState(false),
    _useState14 = _slicedToArray(_useState13, 2),
    previewDidRender = _useState14[0],
    setPreviewDidRender = _useState14[1];
  var mediaBlobUrlAttrs = useMemo(function () {
    var id = identifier.id,
      collection = identifier.collectionName;
    var _getFileDetails = getFileDetails(identifier, fileStateValue),
      mimeType = _getFileDetails.mimeType,
      name = _getFileDetails.name,
      size = _getFileDetails.size;
    return contextId ? _objectSpread(_objectSpread({
      id: id,
      collection: collection,
      contextId: contextId,
      mimeType: mimeType,
      name: name,
      size: size
    }, originalDimensions || previewDimensions), {}, {
      alt: alt
    }) : undefined;
  }, [alt, previewDimensions, contextId, fileStateValue, identifier, originalDimensions]);
  var _useFilePreview = useFilePreview({
      mediaBlobUrlAttrs: mediaBlobUrlAttrs,
      resizeMode: imageResizeModeToFileImageMode(resizeMode),
      identifier: identifier,
      ssr: ssr,
      dimensions: previewDimensions,
      traceContext: traceContext,
      skipRemote: !isCardVisible,
      source: 'mediaCard'
    }),
    preview = _useFilePreview.preview,
    previewStatus = _useFilePreview.status,
    previewError = _useFilePreview.error,
    nonCriticalError = _useFilePreview.nonCriticalError,
    ssrReliability = _useFilePreview.ssrReliability,
    onImageErrorBase = _useFilePreview.onImageError,
    onImageLoadBase = _useFilePreview.onImageLoad,
    getSsrScriptProps = _useFilePreview.getSsrScriptProps,
    copyNodeRef = _useFilePreview.copyNodeRef;
  var shouldSendPerformanceEventRef = useRef(shouldPerformanceBeSampled());
  var _useState15 = useState(),
    _useState16 = _slicedToArray(_useState15, 2),
    error = _useState16[0],
    setError = _useState16[1];

  // CXP-2723 TODO: TEMPORARY VARIABLES
  var finalError = error || (previewError && previewError.primaryReason !== 'failed-processing' && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.mimeType) !== 'image/svg+xml' ? previewError : undefined);
  var finalStatus = finalError ? 'error' : status === 'failed-processing' && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.mimeType) === 'image/svg+xml' ? 'loading-preview' : status;
  var _useState17 = useState(null),
    _useState18 = _slicedToArray(_useState17, 2),
    mediaViewerSelectedItem = _useState18[0],
    setMediaViewerSelectedItem = _useState18[1];
  var uploadProgressRef = useRef();
  var metadata = useMemo(function () {
    var getProcessingStatusFromFileState = function getProcessingStatusFromFileState(status) {
      switch (status) {
        case 'processed':
          return 'succeeded';
        case 'processing':
          return 'running';
        case 'failed-processing':
          return 'failed';
      }
    };
    if (fileStateValue) {
      return {
        id: fileStateValue.id,
        name: fileStateValue.name,
        size: fileStateValue.size,
        mimeType: fileStateValue.mimeType,
        createdAt: fileStateValue.createdAt,
        mediaType: fileStateValue.mediaType,
        processingStatus: getProcessingStatusFromFileState(fileStateValue.status)
      };
    } else {
      return {
        id: identifier.id
      };
    }
  }, [fileStateValue, identifier.id]);
  var fileAttributes = useMemo(function () {
    return {
      fileMediatype: metadata.mediaType,
      fileMimetype: metadata.mimeType,
      fileId: metadata.id,
      fileSize: metadata.size,
      fileStatus: fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status
    };
  }, [fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status, metadata.id, metadata.mediaType, metadata.mimeType, metadata.size]);
  var downloadFn = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _error;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return mediaClient.file.downloadBinary(identifier.id, metadata.name, identifier.collectionName, traceContext);
        case 3:
          fireDownloadSucceededEvent(createAnalyticsEvent, fileAttributes, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
          _context.next = 10;
          break;
        case 6:
          _context.prev = 6;
          _context.t0 = _context["catch"](0);
          _error = new MediaCardError('download', _context.t0);
          fireDownloadFailedEvent(createAnalyticsEvent, fileAttributes, _error, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 6]]);
  })), [createAnalyticsEvent, fileAttributes, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext, identifier.collectionName, identifier.id, mediaClient.file, metadata.name, traceContext]);
  var computedActions = useMemo(function () {
    if (finalStatus === 'failed-processing' || shouldEnableDownloadButton) {
      var handler = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!(fileStateValue !== null && fileStateValue !== void 0 && fileStateValue.abuseClassification)) {
                  _context2.next = 4;
                  break;
                }
                setIsAbuseModalOpen(true);
                _context2.next = 6;
                break;
              case 4:
                _context2.next = 6;
                return downloadFn();
              case 6:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function handler() {
          return _ref3.apply(this, arguments);
        };
      }();
      var downloadAction = createDownloadAction({
        handler: handler,
        isDisabled: mediaClient.config.enforceDataSecurityPolicy
      }, formatMessage);
      return [downloadAction].concat(_toConsumableArray(actions !== null && actions !== void 0 ? actions : []));
    } else {
      return actions;
    }
  }, [actions, mediaClient.config.enforceDataSecurityPolicy, shouldEnableDownloadButton, finalStatus, formatMessage, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.abuseClassification, downloadFn]);

  //----------------------------------------------------------------//
  //---------------------- Analytics  ------------------------------//
  //----------------------------------------------------------------//

  var fireOperationalEventRef = useCurrentValueRef(function () {
    var timeElapsedTillEvent = performanceNow();
    var durationSinceCommenced = timeElapsedTillEvent - timeElapsedTillCommenced;
    var performanceAttributes = {
      overall: {
        durationSincePageStart: timeElapsedTillEvent,
        durationSinceCommenced: durationSinceCommenced
      }
    };
    createAnalyticsEvent && fireOperationalEvent(createAnalyticsEvent, finalStatus, fileAttributes, performanceAttributes, ssrReliability, finalError, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
    shouldSendPerformanceEventRef.current && completeUfoExperience(internalOccurrenceKey, finalStatus, fileAttributes, fileStateFlagsRef.current, ssrReliability, finalError);
  });
  var fireNonCriticalErrorEventRef = useCurrentValueRef(function (error) {
    createAnalyticsEvent && fireNonCriticalErrorEvent(createAnalyticsEvent, finalStatus, fileAttributes, ssrReliability, error, traceContext, fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.metadataTraceContext);
  });
  useEffect(function () {
    if (nonCriticalError) {
      fireNonCriticalErrorEventRef.current(nonCriticalError);
    }
  }, [nonCriticalError, fireNonCriticalErrorEventRef]);
  var startUfoExperienceRef = useCurrentValueRef(function () {
    if (shouldSendPerformanceEventRef.current) {
      startUfoExperience(internalOccurrenceKey);
    }
  });
  var fireAbortedEventRef = useCurrentValueRef(function () {
    // UFO won't abort if it's already in a final state (succeeded, failed, aborted, etc)
    if (shouldSendPerformanceEventRef.current) {
      abortUfoExperience(internalOccurrenceKey, {
        fileAttributes: fileAttributes,
        fileStateFlags: fileStateFlagsRef === null || fileStateFlagsRef === void 0 ? void 0 : fileStateFlagsRef.current,
        ssrReliability: ssrReliability
      });
    }
  });

  //----------------------------------------------------------------//
  //--------------------- Focus on Close Viewer  -------------------//
  //----------------------------------------------------------------//

  var wasViewerPreviouslyOpen = usePrevious(mediaViewerSelectedItem);
  useEffect(function () {
    if (wasViewerPreviouslyOpen && !mediaViewerSelectedItem) {
      var _mediaViewerButtonRef;
      (_mediaViewerButtonRef = mediaViewerButtonRef.current) === null || _mediaViewerButtonRef === void 0 || _mediaViewerButtonRef.focus();
    }
  }, [wasViewerPreviouslyOpen, mediaViewerSelectedItem]);

  //----------------------------------------------------------------//
  //---------------------- Callbacks & Handlers  -------------------//
  //----------------------------------------------------------------//

  var onSvgError = function onSvgError(error) {
    setError(error);
    setStatus('error');
  };
  var onImageError = function onImageError(newCardPreview) {
    if (metadata.mimeType === 'image/svg+xml') {
      return;
    }
    onImageErrorBase(newCardPreview);
  };
  var onSvgLoad = function onSvgLoad() {
    setPreviewDidRender(true);
  };
  var onImageLoad = function onImageLoad(newCardPreview) {
    if (metadata.mimeType === 'image/svg+xml') {
      return;
    }
    onImageLoadBase(newCardPreview);
    setPreviewDidRender(true);
  };
  var onCardClick = function onCardClick(event, analyticsEvent) {
    if (onClick) {
      var cardEvent = {
        event: event,
        mediaItemDetails: metadata
      };
      onClick(cardEvent, analyticsEvent);
    }
  };
  var onCardViewClick = function onCardViewClick(event, analyticsEvent) {
    onCardClick(event, analyticsEvent);
    if (!metadata) {
      return;
    }
    var isVideo = metadata.mediaType === 'video';
    var isBrowserSupported = metadata.mimeType && isMimeTypeSupportedByBrowser(metadata.mimeType);

    // TODO: this should be handled by Inline Player
    var isPlayable = !!fileState && (fileState.status === 'processed' || isBrowserSupported && ['processing', 'uploading'].includes(fileState.status));
    if (useInlinePlayer && isVideo && isPlayable && finalStatus !== 'error') {
      setIsPlayingFile(true);
      setShouldAutoplay(true);
    } else if (shouldOpenMediaViewer) {
      setMediaViewerSelectedItem({
        id: identifier.id,
        mediaItemType: 'file',
        collectionName: identifier.collectionName,
        occurrenceKey: identifier.occurrenceKey
      });
    }
  };

  //----------------------------------------------------------------//
  //----------------- update status flags --------------------------//
  //----------------------------------------------------------------//

  useEffect(function () {
    if ((fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) === 'processing') {
      fileStateFlagsRef.current.wasStatusProcessing = true;
    } else if ((fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) === 'uploading') {
      fileStateFlagsRef.current.wasStatusUploading = true;
    }
  }, [fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status]);

  //----------------------------------------------------------------//
  //---------------- fetch and resolve card preview ----------------//
  //----------------------------------------------------------------//

  var prevStatus = usePrevious(finalStatus);
  var prevIsCardVisible = usePrevious(isCardVisible);
  useEffect(function () {
    if (prevStatus !== undefined && finalStatus !== prevStatus) {
      fireOperationalEventRef.current();
    }
  }, [fireOperationalEventRef, prevStatus, finalStatus]);
  useEffect(function () {
    var turnedVisible = !prevIsCardVisible && isCardVisible;
    if (turnedVisible) {
      startUfoExperienceRef.current();
    }
  }, [startUfoExperienceRef, isCardVisible, prevIsCardVisible]);

  //----------------------------------------------------------------//
  //----------------- set isPlayingFile state ----------------------//
  //----------------------------------------------------------------//

  useEffect(function () {
    var isVideo = fileAttributes.fileMediatype === 'video';
    var _getFileDetails2 = getFileDetails(identifier, fileStateValue),
      mimeType = _getFileDetails2.mimeType;
    var isVideoPlayable = mimeType && isVideoMimeTypeSupportedByBrowser(mimeType) || fileStateValue && isProcessedFileState(fileStateValue);
    if (
    /**
     * We need to check that the card is visible before switching to inline player
     * in order to avoid race conditions of the ViewportDector being unmounted before
     * it is able to set isCardVisible to true.
     */
    isCardVisible && isVideo && !isPlayingFile && disableOverlay && useInlinePlayer && isVideoPlayable && (fileStateValue === null || fileStateValue === void 0 ? void 0 : fileStateValue.status) !== 'failed-processing' && finalStatus !== 'error') {
      setIsPlayingFile(true);
    }
  }, [isCardVisible, disableOverlay, fileAttributes.fileMediatype, fileStateValue, identifier, isPlayingFile, finalStatus, useInlinePlayer]);

  //----------------------------------------------------------------//
  //----------------- abort UFO experience -------------------------//
  //----------------------------------------------------------------//

  useEffect(function () {
    return function () {
      // eslint-disable-next-line react-hooks/exhaustive-deps
      fireAbortedEventRef.current();
    };
  }, [fireAbortedEventRef]);

  //----------------------------------------------------------------//
  // Update Status
  //----------------------------------------------------------------//

  var updateFileStateRef = useCurrentValueRef(function () {
    // This effect has race condition with Complete effect. We share the same check to ovid status overrides

    // do not update the card status if the status is final
    if (['complete', 'error', 'failed-processing'].includes(finalStatus)) {
      return;
    }
    if (previewDidRender &&
    // We should't complete if status is uploading
    ['loading-preview', 'processing'].includes(finalStatus)) {
      setStatus('complete');
      // TODO MEX-788: add test for "do not remove the card preview when unsubscribing".
    } else if (fileState) {
      if (fileState.status !== 'error') {
        var newStatus;
        switch (fileState.status) {
          case 'uploading':
          case 'failed-processing':
          case 'processing':
            newStatus = fileState.status;
            break;
          case 'processed':
            // Set complete if processing is done and there is no preview
            if (!preview && previewStatus === 'complete') {
              newStatus = 'complete';
              break;
            }
            newStatus = 'loading-preview';
            break;
          default:
            newStatus = 'loading';
        }
        var newProgress = newStatus === 'uploading' && fileState.status === 'uploading' ? fileState.progress : 1;
        setStatus(newStatus);
        uploadProgressRef.current = newProgress;
      } else {
        var e = toCommonMediaClientError(fileState);
        var errorReason = finalStatus === 'uploading' ? 'upload' : 'metadata-fetch';
        setError(new MediaCardError(errorReason, e));
        setStatus('error');
      }
    }
  });
  var mergedRef = useMergeRefs([setCardElement, copyNodeRef]);
  useEffect(function () {
    updateFileStateRef.current();
  }, [fileState, preview, previewStatus, updateFileStateRef, previewDidRender, finalStatus]);

  //----------------------------------------------------------------//
  // Shared Card View & SVG View resources
  //----------------------------------------------------------------//

  var mediaCardCursor = getMediaCardCursor(!!useInlinePlayer, !!shouldOpenMediaViewer, finalStatus === 'error' || finalStatus === 'failed-processing', !!preview, metadata.mediaType);
  var onImageMouseEnter = function onImageMouseEnter(event) {
    onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
      event: event,
      mediaItemDetails: metadata
    });
  };

  //----------------------------------------------------------------//
  //---------------------- Render Card Function --------------------//
  //----------------------------------------------------------------//

  var renderCard = function renderCard() {
    var withCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var cardStatusOverride = arguments.length > 1 ? arguments[1] : undefined;
    var izLazyOverride = arguments.length > 2 ? arguments[2] : undefined;
    var mediaItemType = identifier.mediaItemType;
    var isLazyWithOverride = izLazyOverride === undefined ? isLazy : izLazyOverride;

    // We should natively lazy load an SSR preview when card is not visible,
    // otherwise we'll fire the metadata fetch from outside the viewport
    // Side note: We should not lazy load if the cardPreview is available from local cache,
    // in order to avoid flickers during re-mount of the component
    // CXP-2723 TODO: Create test cases for the above scenarios
    var nativeLazyLoad = isLazyWithOverride && !isCardVisible && preview && isSSRPreview(preview);
    // Force Media Image to always display img for SSR
    var forceSyncDisplay = !!ssr;
    var card = /*#__PURE__*/React.createElement(CardView, {
      identifier: identifier,
      status: cardStatusOverride || finalStatus,
      error: finalError,
      mediaItemType: mediaItemType,
      metadata: metadata,
      cardPreview: preview,
      alt: alt,
      resizeMode: resizeMode,
      dimensions: cardDimensions,
      actions: computedActions,
      selectable: selectable,
      selected: selected,
      shouldOpenMediaViewer: shouldOpenMediaViewer,
      openMediaViewerButtonRef: mediaViewerButtonRef,
      onClick: withCallbacks ? onCardViewClick : undefined,
      onMouseEnter: withCallbacks ? onImageMouseEnter : undefined,
      disableOverlay: disableOverlay,
      progress: uploadProgressRef.current,
      onDisplayImage: withCallbacks ? function () {
        var payloadPart = {
          fileId: identifier.id,
          isUserCollection: identifier.collectionName === RECENTS_COLLECTION
        };
        globalMediaEventEmitter.emit('media-viewed', _objectSpread({
          viewingLevel: 'minimal'
        }, payloadPart));
      } : undefined,
      innerRef: mergedRef,
      testId: testId,
      titleBoxBgColor: titleBoxBgColor,
      titleBoxIcon: titleBoxIcon,
      onImageError: withCallbacks ? onImageError : undefined,
      onImageLoad: withCallbacks ? onImageLoad : undefined,
      onSvgError: onSvgError,
      onSvgLoad: onSvgLoad,
      nativeLazyLoad: nativeLazyLoad,
      forceSyncDisplay: forceSyncDisplay,
      mediaCardCursor: mediaCardCursor,
      shouldHideTooltip: shouldHideTooltip,
      overriddenCreationDate: overridenDate
    });
    return isLazyWithOverride ? /*#__PURE__*/React.createElement(ViewportDetector, {
      cardEl: cardElement,
      onVisible: function onVisible() {
        setIsCardVisible(true);
      }
    }, card) : card;
  };

  //----------------------------------------------------------------//
  //-------------------------- RENDER ------------------------------//
  //----------------------------------------------------------------//

  var inlinePlayerFallback = isPlayingFile ? renderCard(false, 'loading', false) : /*#__PURE__*/React.createElement(React.Fragment, null);
  var collectionName = identifier.collectionName || '';
  return /*#__PURE__*/React.createElement(React.Fragment, null, !!(fileStateValue !== null && fileStateValue !== void 0 && fileStateValue.abuseClassification) && /*#__PURE__*/React.createElement(AbuseModal, {
    isOpen: isAbuseModalOpen,
    onConfirm: downloadFn,
    onClose: function onClose() {
      return setIsAbuseModalOpen(false);
    }
  }), isPlayingFile ? /*#__PURE__*/React.createElement(Suspense, {
    fallback: inlinePlayerFallback
  }, /*#__PURE__*/React.createElement(InlinePlayerLazy, {
    dimensions: cardDimensions,
    originalDimensions: originalDimensions,
    identifier: identifier,
    autoplay: !!shouldAutoplay,
    onFullscreenChange: onFullscreenChange,
    onError: function onError(e) {
      setError(new MediaCardError('error-file-state', e));
      setStatus('error');
      setIsPlayingFile(false);
    },
    onClick: onCardClick,
    selected: selected,
    ref: setCardElement,
    testId: testId,
    cardPreview: preview,
    videoControlsWrapperRef: videoControlsWrapperRef
  })) : renderCard(), mediaViewerSelectedItem ? /*#__PURE__*/React.createElement(MediaViewer, {
    collectionName: collectionName,
    items: mediaViewerItems || [],
    mediaClientConfig: mediaClient.config,
    selectedItem: mediaViewerSelectedItem,
    onClose: function onClose() {
      setMediaViewerSelectedItem(null);
    },
    contextId: contextId,
    featureFlags: featureFlags,
    viewerOptions: viewerOptions
  }) : null, getSsrScriptProps && /*#__PURE__*/React.createElement("script", getSsrScriptProps()));
};