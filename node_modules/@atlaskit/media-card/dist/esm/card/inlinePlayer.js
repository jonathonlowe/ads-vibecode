import _extends from "@babel/runtime/helpers/extends";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useRef, useState, useEffect } from 'react';
import { globalMediaEventEmitter } from '@atlaskit/media-client';
import { CustomMediaPlayer, InactivityDetector } from '@atlaskit/media-ui';
import { defaultImageCardDimensions } from '../utils';
import { CardLoading } from '../utils/lightCards/cardLoading';
import { ProgressBar } from './ui/progressBar/progressBar';
import { InlinePlayerWrapper } from './inlinePlayerWrapper';
import { useBreakpoint } from './useBreakpoint';
import { useFileState, useMediaClient } from '@atlaskit/media-client-react';
export var getPreferredVideoArtifact = function getPreferredVideoArtifact(fileState) {
  if (fileState.status === 'processed' || fileState.status === 'processing') {
    var artifacts = fileState.artifacts;
    if (!artifacts) {
      return undefined;
    }
    return artifacts['video_1280.mp4'] ? 'video_1280.mp4' : artifacts['video_640.mp4'] ? 'video_640.mp4' : undefined;
  }
  return undefined;
};
export var InlinePlayerBase = function InlinePlayerBase(_ref) {
  var identifier = _ref.identifier,
    onError = _ref.onError,
    onClick = _ref.onClick,
    _ref$dimensions = _ref.dimensions,
    dimensions = _ref$dimensions === void 0 ? defaultImageCardDimensions : _ref$dimensions,
    originalDimensions = _ref.originalDimensions,
    selected = _ref.selected,
    testId = _ref.testId,
    forwardRef = _ref.forwardRef,
    autoplay = _ref.autoplay,
    cardPreview = _ref.cardPreview,
    onFullscreenChange = _ref.onFullscreenChange,
    videoControlsWrapperRef = _ref.videoControlsWrapperRef;
  // === States ===
  var _useState = useState(),
    _useState2 = _slicedToArray(_useState, 2),
    fileSrc = _useState2[0],
    setFileSrc = _useState2[1];
  var _useState3 = useState(),
    _useState4 = _slicedToArray(_useState3, 2),
    isUploading = _useState4[0],
    setIsUploading = _useState4[1];
  var _useState5 = useState(),
    _useState6 = _slicedToArray(_useState5, 2),
    progress = _useState6[0],
    setProgress = _useState6[1];

  // === Refs and Local Variables ===
  var divRef = useRef(null);
  var onErrorRef = useRef(onError);
  onErrorRef.current = onError;
  var id = identifier.id,
    collectionName = identifier.collectionName,
    occurrenceKey = identifier.occurrenceKey;
  var breakpoint = useBreakpoint(dimensions === null || dimensions === void 0 ? void 0 : dimensions.width, divRef);
  var mediaClient = useMediaClient();
  var _useFileState = useFileState(id, {
      collectionName: collectionName,
      occurrenceKey: occurrenceKey
    }),
    fileState = _useFileState.fileState;
  useEffect(function () {
    var subscribeFileState = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileState) {
        var _yield$fileState$prev, value, newFileSrc, artifactName, artifacts, _newFileSrc, _newFileSrc2;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (fileState.status === 'uploading') {
                setIsUploading(true);
                setProgress(fileState.progress);
              } else {
                setIsUploading(false);
              }

              // We reuse the existing fileSrc to prevent re renders, therefore we only perform fileSrc updates when there isn't any
              if (!fileSrc) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return");
            case 3:
              if (!(fileState.status !== 'error' && fileState.preview)) {
                _context.next = 12;
                break;
              }
              _context.next = 6;
              return fileState.preview;
            case 6:
              _yield$fileState$prev = _context.sent;
              value = _yield$fileState$prev.value;
              if (!(value instanceof Blob && value.type.indexOf('video/') === 0)) {
                _context.next = 12;
                break;
              }
              newFileSrc = URL.createObjectURL(value);
              setFileSrc(newFileSrc);
              return _context.abrupt("return");
            case 12:
              if (!(fileState.status === 'processed' || fileState.status === 'processing')) {
                _context.next = 37;
                break;
              }
              artifactName = getPreferredVideoArtifact(fileState);
              artifacts = fileState.artifacts;
              if (!(!artifactName || !artifacts)) {
                _context.next = 27;
                break;
              }
              _context.prev = 16;
              _context.next = 19;
              return mediaClient.file.getFileBinaryURL(id, collectionName);
            case 19:
              _newFileSrc = _context.sent;
              setFileSrc(_newFileSrc);
              _context.next = 26;
              break;
            case 23:
              _context.prev = 23;
              _context.t0 = _context["catch"](16);
              if (onErrorRef.current && _context.t0 instanceof Error) {
                onErrorRef.current(_context.t0);
              }
            case 26:
              return _context.abrupt("return");
            case 27:
              _context.prev = 27;
              _context.next = 30;
              return mediaClient.file.getArtifactURL(artifacts, artifactName, collectionName);
            case 30:
              _newFileSrc2 = _context.sent;
              setFileSrc(_newFileSrc2);
              _context.next = 37;
              break;
            case 34:
              _context.prev = 34;
              _context.t1 = _context["catch"](27);
              if (onErrorRef.current && _context.t1 instanceof Error) {
                onErrorRef.current(_context.t1);
              }
            case 37:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[16, 23], [27, 34]]);
      }));
      return function subscribeFileState(_x) {
        return _ref2.apply(this, arguments);
      };
    }();
    if (fileState) {
      subscribeFileState(fileState);
    }
  }, [fileState, collectionName, fileSrc, id, mediaClient]);
  useEffect(function () {
    return function () {
      fileSrc && URL.revokeObjectURL(fileSrc);
    };
  }, [fileSrc]);

  // === Render ===
  return fileSrc ? /*#__PURE__*/React.createElement(InlinePlayerWrapper, {
    testId: testId || 'media-card-inline-player',
    "data-vc": "media-card-inline-player",
    selected: {
      selected: selected
    },
    onClick: onClick,
    innerRef: forwardRef || undefined,
    dimensions: dimensions
  }, /*#__PURE__*/React.createElement(InactivityDetector, null, function (checkMouseMovement) {
    return /*#__PURE__*/React.createElement(CustomMediaPlayer, {
      type: "video",
      src: fileSrc,
      onFullscreenChange: onFullscreenChange,
      fileId: id,
      isAutoPlay: autoplay,
      isHDAvailable: false,
      onDownloadClick: function onDownloadClick() {
        mediaClient.file.downloadBinary(id, undefined, collectionName);
      },
      onFirstPlay: function onFirstPlay() {
        globalMediaEventEmitter.emit('media-viewed', {
          fileId: id,
          viewingLevel: 'full'
        });
      },
      lastWatchTimeConfig: {
        contentId: id
      },
      originalDimensions: originalDimensions,
      showControls: checkMouseMovement,
      poster: cardPreview === null || cardPreview === void 0 ? void 0 : cardPreview.dataURI,
      videoControlsWrapperRef: videoControlsWrapperRef
    });
  }), isUploading && /*#__PURE__*/React.createElement(ProgressBar, {
    progress: progress,
    breakpoint: breakpoint,
    positionBottom: true,
    showOnTop: true
  })) : /*#__PURE__*/React.createElement(CardLoading, {
    testId: testId,
    dimensions: dimensions,
    interactionName: "inline-player-loading"
  });
};
var InlinePlayerForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return /*#__PURE__*/React.createElement(InlinePlayerBase, _extends({}, props, {
    forwardRef: ref
  }));
});
export var InlinePlayer = InlinePlayerForwardRef;