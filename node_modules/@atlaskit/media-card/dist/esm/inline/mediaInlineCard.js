import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { FileFetcherError, toCommonMediaClientError } from '@atlaskit/media-client';
import { MediaInlineCardErroredView, MediaInlineCardLoadedView, MediaInlineCardLoadingView, messages } from '@atlaskit/media-ui';
import { formatDate } from '@atlaskit/media-ui/formatDate';
import { MimeTypeIcon } from '@atlaskit/media-ui/mime-type-icon';
import { MediaViewer } from '@atlaskit/media-viewer';
import Tooltip from '@atlaskit/tooltip';
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';
import { createIntl, injectIntl, IntlProvider } from 'react-intl-next';
import { MediaCardError } from '../errors';
import { fireMediaCardEvent } from '../utils/analytics';
import { getErrorStatusPayload, getFailedProcessingStatusPayload, getSucceededStatusPayload } from './mediaInlineCardAnalytics';
import { useCopyIntent } from '@atlaskit/media-client-react';
// UI component which renders an inline link in the appropiate state based on a media file
export var MediaInlineCardInternal = function MediaInlineCardInternal(_ref) {
  var mediaClient = _ref.mediaClient,
    identifier = _ref.identifier,
    shouldOpenMediaViewer = _ref.shouldOpenMediaViewer,
    shouldDisplayToolTip = _ref.shouldDisplayToolTip,
    isSelected = _ref.isSelected,
    onClick = _ref.onClick,
    mediaViewerItems = _ref.mediaViewerItems,
    intl = _ref.intl,
    viewerOptions = _ref.viewerOptions;
  var _useState = useState(),
    _useState2 = _slicedToArray(_useState, 2),
    fileState = _useState2[0],
    setFileState = _useState2[1];
  var _useState3 = useState(),
    _useState4 = _slicedToArray(_useState3, 2),
    subscribeError = _useState4[0],
    setSubscribeError = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isSucceededEventSent = _useState6[0],
    setIsSucceededEventSent = _useState6[1];
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    isFailedEventSent = _useState8[0],
    setIsFailedEventSent = _useState8[1];
  var _useState9 = useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    isMediaViewerVisible = _useState10[0],
    setMediaViewerVisible = _useState10[1];
  var _useAnalyticsEvents = useAnalyticsEvents(),
    createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
  var fireFailedOperationalEvent = function fireFailedOperationalEvent() {
    var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new MediaCardError('missing-error-data');
    var failReason = arguments.length > 1 ? arguments[1] : undefined;
    var payload = failReason ? getFailedProcessingStatusPayload(identifier.id, fileState) : getErrorStatusPayload(identifier.id, error, fileState);
    setIsFailedEventSent(true);
    fireMediaCardEvent(payload, createAnalyticsEvent);
  };
  var fireSucceededOperationalEvent = function fireSucceededOperationalEvent() {
    var payload = getSucceededStatusPayload(fileState);
    setIsSucceededEventSent(true);
    fireMediaCardEvent(payload, createAnalyticsEvent);
  };
  var _useCopyIntent = useCopyIntent(identifier.id, {
      collectionName: identifier.collectionName
    }),
    copyNodeRef = _useCopyIntent.copyNodeRef;
  var onMediaInlineCardClick = function onMediaInlineCardClick(event) {
    if (onClick) {
      var inlineCardEvent = {
        event: event,
        mediaItemDetails: identifier
      };
      onClick(inlineCardEvent);
    }
    if (shouldOpenMediaViewer) {
      setMediaViewerVisible(true);
    }
  };
  var onMediaViewerClose = function onMediaViewerClose() {
    return setMediaViewerVisible(false);
  };
  var renderMediaViewer = function renderMediaViewer() {
    if (isMediaViewerVisible) {
      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(MediaViewer, {
        collectionName: identifier.collectionName || '',
        items: mediaViewerItems || [],
        mediaClientConfig: mediaClient.mediaClientConfig,
        selectedItem: identifier,
        onClose: onMediaViewerClose,
        viewerOptions: viewerOptions
      }), document.body);
    }
    return null;
  };
  var renderContent = function renderContent(children) {
    return intl ? children : /*#__PURE__*/React.createElement(IntlProvider, {
      locale: "en"
    }, children);
  };
  var defaultIntl = createIntl({
    locale: 'en'
  });
  useEffect(function () {
    var subscription = mediaClient.file.getFileState(identifier.id, {
      collectionName: identifier.collectionName
    }).subscribe({
      next: function next(fileState) {
        setFileState(fileState);
        setSubscribeError(undefined);
      },
      error: function error(e) {
        setSubscribeError(e);
      }
    });
    return function () {
      subscription === null || subscription === void 0 || subscription.unsubscribe();
    };
  }, [identifier.collectionName, identifier.id, mediaClient.file]);
  if (subscribeError) {
    var errorMessage = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading' ? messages.failed_to_upload : messages.couldnt_load_file;
    var errorReason = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading' ? 'upload' : 'metadata-fetch';
    !isFailedEventSent && fireFailedOperationalEvent(new MediaCardError(errorReason, subscribeError));
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(errorMessage),
      isSelected: isSelected
    });
  }
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error') {
    var error = new MediaCardError('error-file-state', toCommonMediaClientError(fileState));
    !isFailedEventSent && fireFailedOperationalEvent(error);
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.couldnt_load_file),
      isSelected: isSelected
    });
  }

  // Empty file handling
  if (fileState && !fileState.name) {
    var _error = new MediaCardError('metadata-fetch', new FileFetcherError('emptyFileName', {
      id: fileState.id
    }));
    !isFailedEventSent && fireFailedOperationalEvent(_error);
    return /*#__PURE__*/React.createElement(MediaInlineCardErroredView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.couldnt_load_file),
      isSelected: isSelected
    });
  }
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'uploading') {
    return /*#__PURE__*/React.createElement(MediaInlineCardLoadingView, {
      innerRef: copyNodeRef,
      message: fileState.name,
      isSelected: isSelected
    });
  }
  if (!fileState) {
    return /*#__PURE__*/React.createElement(MediaInlineCardLoadingView, {
      innerRef: copyNodeRef,
      message: (intl || defaultIntl).formatMessage(messages.loading_file),
      isSelected: isSelected
    });
  }

  // Failed to process should still display the loaded view and enable Media Client to download
  if ((fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'failed-processing') {
    !isFailedEventSent && fireFailedOperationalEvent(undefined, 'failed-processing');
  }
  var mediaType = fileState.mediaType,
    name = fileState.name,
    mimeType = fileState.mimeType;
  var linkIcon = /*#__PURE__*/React.createElement(MimeTypeIcon, {
    testId: 'media-inline-card-file-type-icon',
    size: "small",
    mediaType: mediaType,
    mimeType: mimeType,
    name: name
  });
  var mediaViewer = renderMediaViewer();
  var formattedDate;
  if (fileState.createdAt) {
    var _ref2 = intl || {
        locale: 'en'
      },
      _ref2$locale = _ref2.locale,
      locale = _ref2$locale === void 0 ? 'en' : _ref2$locale;
    formattedDate = formatDate(fileState.createdAt, locale);
  }
  if (fileState.status === 'processed' && !isSucceededEventSent) {
    fireSucceededOperationalEvent();
  }
  if (shouldDisplayToolTip === undefined || shouldDisplayToolTip === true) {
    return renderContent( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Tooltip, {
      position: "bottom",
      content: formattedDate,
      tag: "span"
    }, /*#__PURE__*/React.createElement(MediaInlineCardLoadedView, {
      innerRef: copyNodeRef,
      icon: linkIcon,
      title: name,
      onClick: onMediaInlineCardClick,
      isSelected: isSelected
    })), mediaViewer));
  } else {
    return renderContent( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MediaInlineCardLoadedView, {
      innerRef: copyNodeRef,
      icon: linkIcon,
      title: name,
      onClick: onMediaInlineCardClick,
      isSelected: isSelected
    }), mediaViewer));
  }
};
export var MediaInlineCard = injectIntl(MediaInlineCardInternal, {
  enforceContext: false
});