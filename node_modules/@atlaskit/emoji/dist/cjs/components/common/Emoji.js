/* Emoji.tsx generated by @compiled/babel-plugin v0.36.1 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SpriteEmoji = exports.ImageEmoji = exports.EmojiNodeWrapper = exports.Emoji = void 0;
require("./Emoji.compiled.css");
var _runtime = require("@compiled/react/runtime");
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _colors = require("@atlaskit/theme/colors");
var _tooltip = _interopRequireDefault(require("@atlaskit/tooltip"));
var _EmojiUtils = require("../../api/EmojiUtils");
var _constants = require("../../util/constants");
var _typeHelpers = require("../../util/type-helpers");
var _types = require("../../types");
var _mouse = require("../../util/mouse");
var _DeleteButton = _interopRequireDefault(require("./DeleteButton"));
var _styles = require("./styles");
var _analytics = require("../../util/analytics");
var _browserSupport = _interopRequireDefault(require("../../util/browser-support"));
var _useInView3 = require("../../hooks/useInView");
var _ufoExperiences = require("../../util/analytics/ufoExperiences");
var _DeletableEmojiTooltipContent = require("./DeletableEmojiTooltipContent");
var _isSsr = require("../../util/is-ssr");
var _excluded = ["emoji", "fitToHeight", "selected", "selectOnHover", "className", "showTooltip", "showDelete", "shouldBeInteractive", "tabIndex", "onSelected", "onMouseMove", "onFocus", "onDelete", "onLoadError", "onLoadSuccess", "disableLazyLoad", "autoWidth", "children", "type", "editorEmoji"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var emojiSpriteContainer = null;
var emojiImageContainer = null;
var handleMouseDown = function handleMouseDown(props, event) {
  // Clicked emoji delete button
  if (event.target instanceof Element && event.target.getAttribute('aria-label') === _constants.deleteEmojiLabel) {
    return;
  }
  var emoji = props.emoji,
    onSelected = props.onSelected;
  if (onSelected && (0, _mouse.leftClick)(event)) {
    onSelected((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
};
var handleKeyDown = function handleKeyDown(props, event) {
  if (!_constants.EMOJI_KEYBOARD_KEYS_SUPPORTED.includes(event.key)) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  var emoji = props.emoji,
    onSelected = props.onSelected,
    showDelete = props.showDelete;
  if (onSelected && (event.key === _constants.KeyboardKeys.Enter || event.key === _constants.KeyboardKeys.Space)) {
    onSelected((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
  if (showDelete && event.key === _constants.KeyboardKeys.Backspace) {
    handleDelete(props, event);
  }
};
var handleMouseMove = function handleMouseMove(props, event) {
  var emoji = props.emoji,
    onMouseMove = props.onMouseMove;
  if (onMouseMove) {
    onMouseMove((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
};
var handleFocus = function handleFocus(props, event) {
  var emoji = props.emoji,
    onFocus = props.onFocus;
  if (onFocus) {
    onFocus((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
};
var handleDelete = function handleDelete(props, event) {
  var emoji = props.emoji,
    onDelete = props.onDelete;
  if (onDelete) {
    onDelete((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
};
var handleImageError = function handleImageError(props, event) {
  var emoji = props.emoji,
    onLoadError = props.onLoadError;

  // Hide error state (but keep space for it)
  if (event.target) {
    var target = event.target;
    target.style.visibility = 'hidden';
  }
  if (onLoadError) {
    onLoadError((0, _typeHelpers.toEmojiId)(emoji), emoji, event);
  }
};

// Pure functional components are used in favour of class based components, due to the performance!
// When rendering 1500+ emoji using class based components had a significant impact.
// TODO: add UFO tracking for sprite emoji
var SpriteEmoji = exports.SpriteEmoji = function SpriteEmoji(props) {
  var emoji = props.emoji,
    fitToHeight = props.fitToHeight,
    selected = props.selected,
    selectOnHover = props.selectOnHover,
    className = props.className;
  var representation = emoji.representation;
  var sprite = representation.sprite;
  var classes = "".concat(_styles.emojiNodeStyles, " ").concat(selected ? _styles.commonSelectedStyles : '', " ").concat(selectOnHover ? _styles.selectOnHoverStyles : '', " ").concat(className ? className : '');
  var sizing = {};
  if (fitToHeight) {
    sizing = {
      width: "".concat(fitToHeight, "px"),
      height: "".concat(fitToHeight, "px"),
      minHeight: "".concat(fitToHeight, "px"),
      minWidth: "".concat(fitToHeight, "px")
    };
  }
  var xPositionInPercent = 100 / (sprite.column - 1) * (representation.xIndex - 0);
  var yPositionInPercent = 100 / (sprite.row - 1) * (representation.yIndex - 0);
  var style = _objectSpread({
    backgroundImage: "url(".concat(sprite.url, ")"),
    backgroundPosition: "".concat(xPositionInPercent, "% ").concat(yPositionInPercent, "%"),
    backgroundSize: "".concat(sprite.column * 100, "% ").concat(sprite.row * 100, "%")
  }, sizing);
  return (
    /*#__PURE__*/
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    _react.default.createElement(EmojiNodeWrapper, (0, _extends2.default)({}, props, {
      type: "sprite",
      className: classes
    }), /*#__PURE__*/_react.default.createElement("span", {
      className: _styles.emojiSprite,
      style: style
    }))
  );
};

// Keep as pure functional component, see renderAsSprite.
var ImageEmoji = exports.ImageEmoji = function ImageEmoji(props) {
  var emoji = props.emoji,
    fitToHeight = props.fitToHeight,
    selected = props.selected,
    selectOnHover = props.selectOnHover,
    className = props.className,
    showDelete = props.showDelete,
    onLoadSuccess = props.onLoadSuccess,
    disableLazyLoad = props.disableLazyLoad,
    autoWidth = props.autoWidth;
  var _useInView = (0, _useInView3.useInView)({
      triggerOnce: true
    }),
    _useInView2 = (0, _slicedToArray2.default)(_useInView, 2),
    ref = _useInView2[0],
    inView = _useInView2[1];
  var ufoExp = (0, _analytics.sampledUfoRenderedEmoji)(emoji);
  var classes = "".concat(_styles.emojiMainStyle, " ").concat(_styles.emojiNodeStyles, " ").concat(selected ? _styles.commonSelectedStyles : '', " ").concat(selectOnHover ? _styles.selectOnHoverStyles : '', " ").concat(_styles.emojiImage, " ").concat(className ? className : '', " ").concat(showDelete ? _styles.deletableEmoji : '');
  var width;
  var height;
  var src;
  var representation = (0, _EmojiUtils.shouldUseAltRepresentation)(emoji, fitToHeight) ? emoji.altRepresentation : emoji.representation;
  if ((0, _typeHelpers.isImageRepresentation)(representation)) {
    src = representation.imagePath;
    width = representation.width;
    height = representation.height;
  } else if ((0, _typeHelpers.isMediaRepresentation)(representation)) {
    src = representation.mediaPath;
    width = representation.width;
    height = representation.height;
  }
  var sizing = {};
  if (fitToHeight && width && height) {
    // Presize image, to prevent reflow due to size changes after loading
    sizing = {
      // Size of <img> needs to be deterministic when rendered on server-side. Auto will cause width to be 0 before image is loaded.
      width: autoWidth && !(0, _isSsr.isSSR)() ? 'auto' : fitToHeight / height * width,
      height: fitToHeight
    };
  }
  var onError = (0, _react.useCallback)(function (event) {
    handleImageError(props, event);
  }, [props]);
  var onLoad = (0, _react.useCallback)(function () {
    var mountedMark = ufoExp.metrics.marks.find(function (mark) {
      return mark.name === _types.UfoEmojiTimings.MOUNTED_END;
    });
    // onload could trigger before onBeforeLoad when emojis in viewport at start, so we need to mark onload start manually.
    if (!(0, _ufoExperiences.hasUfoMarked)(ufoExp, _types.UfoEmojiTimings.ONLOAD_START)) {
      ufoExp.mark(_types.UfoEmojiTimings.ONLOAD_START, mountedMark === null || mountedMark === void 0 ? void 0 : mountedMark.time);
    }
    var loadedStartMark = ufoExp.metrics.marks.find(function (mark) {
      return mark.name === _types.UfoEmojiTimings.ONLOAD_START;
    });
    if (mountedMark && loadedStartMark) {
      ufoExp.addMetadata({
        lazyLoad: loadedStartMark.time > mountedMark.time
      });
    }
    // onload_start
    if (!(0, _ufoExperiences.hasUfoMarked)(ufoExp, _types.UfoEmojiTimings.ONLOAD_END)) {
      ufoExp.mark(_types.UfoEmojiTimings.ONLOAD_END);
    }
    ufoExp.success({
      metadata: {
        IBSupported: _browserSupport.default.supportsIntersectionObserver
      }
    });
    if (onLoadSuccess) {
      onLoadSuccess(emoji);
    }
  }, [emoji, onLoadSuccess, ufoExp]);
  var onBeforeLoad = (0, _react.useCallback)(function () {
    if (!(0, _ufoExperiences.hasUfoMarked)(ufoExp, _types.UfoEmojiTimings.ONLOAD_START)) {
      ufoExp.mark(_types.UfoEmojiTimings.ONLOAD_START);
    }
  }, [ufoExp]);
  var onMouseOver = (0, _react.useCallback)(function (e) {
    var _document$activeEleme;
    // only disable tooltip when not on focus
    if (!((_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.contains(e.target))) {
      e.stopPropagation();
    }
  }, []);

  // because of the lack of browser support of on before load natively, used IntersectionObserver helper hook to mimic the before load time mark for UFO.
  (0, _react.useEffect)(function () {
    if (inView) {
      onBeforeLoad();
    }
  }, [inView, onBeforeLoad]);
  var emojiNode = /*#__PURE__*/_react.default.createElement("img", (0, _extends2.default)({
    //@ts-ignore
    loading: disableLazyLoad ? 'eager' : 'lazy',
    src: src,
    key: src,
    alt: emoji.name || emoji.shortName,
    "data-emoji-short-name": emoji.shortName,
    "data-emoji-id": emoji.id,
    "data-emoji-text": emoji.fallback || emoji.shortName
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: "emoji"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: {
      visibility: 'visible'
    },
    onError: onError,
    onLoad: onLoad
  }, sizing, {
    "data-vc": "emoji"
  }));

  // show a tooltip for deletable emoji only on focus
  if (showDelete) {
    return /*#__PURE__*/_react.default.createElement(_tooltip.default, {
      content: /*#__PURE__*/_react.default.createElement(_DeletableEmojiTooltipContent.DeletableEmojiTooltipContent, null),
      position: "right-start",
      tag: "span"
    }, /*#__PURE__*/_react.default.createElement(EmojiNodeWrapper, (0, _extends2.default)({}, props, {
      "aria-labelledby": "screenreader-emoji-".concat(emoji.id),
      type: "image"
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: classes,
      ref: ref,
      showTooltip: false // avoid showing both tooltip and title
      ,
      onMouseOver: onMouseOver
    }), emojiNode, /*#__PURE__*/_react.default.createElement(_DeleteButton.default, {
      onClick: function onClick(event) {
        return handleDelete(props, event);
      }
    }), /*#__PURE__*/_react.default.createElement(_DeletableEmojiTooltipContent.DeletableEmojiTooltipContentForScreenReader, {
      emoji: emoji
    })));
  }
  return (
    /*#__PURE__*/
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    _react.default.createElement(EmojiNodeWrapper, (0, _extends2.default)({}, props, {
      type: "image",
      className: classes,
      ref: ref
    }), emojiNode)
  );
};
var EmojiNodeWrapper = exports.EmojiNodeWrapper = /*#__PURE__*/(0, _react.forwardRef)(function (props, ref) {
  var emoji = props.emoji,
    fitToHeight = props.fitToHeight,
    selected = props.selected,
    selectOnHover = props.selectOnHover,
    className = props.className,
    showTooltip = props.showTooltip,
    showDelete = props.showDelete,
    _props$shouldBeIntera = props.shouldBeInteractive,
    shouldBeInteractive = _props$shouldBeIntera === void 0 ? false : _props$shouldBeIntera,
    tabIndex = props.tabIndex,
    onSelected = props.onSelected,
    onMouseMove = props.onMouseMove,
    onFocus = props.onFocus,
    onDelete = props.onDelete,
    onLoadError = props.onLoadError,
    onLoadSuccess = props.onLoadSuccess,
    disableLazyLoad = props.disableLazyLoad,
    autoWidth = props.autoWidth,
    children = props.children,
    type = props.type,
    editorEmoji = props.editorEmoji,
    other = (0, _objectWithoutProperties2.default)(props, _excluded);
  var accessibilityProps;
  if (editorEmoji) {
    accessibilityProps = {
      role: undefined
    };
  } else if (shouldBeInteractive) {
    accessibilityProps = {
      role: 'button',
      'aria-label': emoji.shortName
    };
  } else {
    accessibilityProps = {
      role: 'img',
      'aria-label': emoji.shortName
    };
  }
  return /*#__PURE__*/_react.default.createElement("span", (0, _extends2.default)({}, accessibilityProps, {
    ref: ref,
    "data-testid": "".concat(type, "-emoji-").concat(emoji.shortName),
    "data-emoji-type": type,
    tabIndex: shouldBeInteractive ? tabIndex || 0 : undefined,
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    className: (0, _runtime.ax)([type === 'sprite' ? "_19pk1n1a _2hwxidpf _otyr1n1a _18u0idpf _1e0c1o8l _jr50g2xd _ylp71o8l _pkaxgktf _1hdcgktf _109tnkob _tn8j2tgk _3naf2tgk _nt751r31 _49pcglyw _1hvw1o36 _7ehi1r2v _491113zc" : "_2rkosqtm _19pk1n1a _2hwxidpf _otyr1n1a _18u0idpf _bfhk1j28 _1e0c1o8l _s7n4nkob _v4pn1ule _tn8j2tgk _3naf2tgk _160jewfl _1theewfl _1kogh2mm _qyp0ewfl _nt751r31 _49pcglyw _1hvw1o36 _7ehi1r2v _491113zc", className]),
    onKeyDown: function onKeyDown(event) {
      return handleKeyDown(props, event);
    },
    onMouseDown: function onMouseDown(event) {
      handleMouseDown(props, event);
    },
    onMouseEnter: function onMouseEnter(event) {
      handleMouseMove(props, event);
    },
    onFocus: function onFocus(event) {
      handleFocus(props, event);
    },
    title: showTooltip ? emoji.shortName : undefined // TODO: COLLAB-2351 - use @atlaskit/Tooltip in future for non-deletable emoji if enabled showTooltip
  }, other, {
    style: {
      "--_1y60f1n": (0, _runtime.ix)("var(--ds-background-neutral-subtle-hovered, ".concat(_colors.N30, ")")),
      "--_1rebzxw": (0, _runtime.ix)("0 0 0 2px ".concat("var(--ds-border-focused, ".concat(_colors.B100, ")")))
    }
  }), children);
});
var Emoji = exports.Emoji = function Emoji(props) {
  var emoji = props.emoji;
  // start emoji rendered experience, it may have already started earlier in ResourcedEmoji or CachingEmoji
  (0, _analytics.useSampledUFOComponentExperience)(_analytics.ufoExperiences['emoji-rendered'].getInstance(emoji.id || emoji.shortName), _constants.SAMPLING_RATE_EMOJI_RENDERED_EXP, {
    source: 'Emoji',
    emojiId: emoji.id
  });
  (0, _react.useEffect)(function () {
    var ufoExp = (0, _analytics.sampledUfoRenderedEmoji)(emoji);
    if (!(0, _ufoExperiences.hasUfoMarked)(ufoExp, 'fmp')) {
      ufoExp.markFMP();
    }
    if (!(0, _ufoExperiences.hasUfoMarked)(ufoExp, _types.UfoEmojiTimings.MOUNTED_END)) {
      ufoExp.mark(_types.UfoEmojiTimings.MOUNTED_END);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  // TODO: We always prefer render as image as having accessibility issues with sprite representation
  if ((0, _typeHelpers.isSpriteRepresentation)(emoji.representation)) {
    return /*#__PURE__*/_react.default.createElement(SpriteEmoji, props);
  }
  return /*#__PURE__*/_react.default.createElement(ImageEmoji, props);
};
var _default = exports.default = Emoji;