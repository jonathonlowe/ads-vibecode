"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RENDER_EMOJI_PICKER_LIST_TESTID = exports.EmojiPickerVirtualListInternalOld = exports.EmojiPickerVirtualListInternalNew = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _constants = require("../../util/constants");
var _categories = require("./categories");
var _CategoryTracker = _interopRequireDefault(require("./CategoryTracker"));
var _EmojiPickerSizes = require("./EmojiPickerSizes");
var _EmojiPickerVirtualItems = require("./EmojiPickerVirtualItems");
var _EmojiActions = _interopRequireDefault(require("../common/EmojiActions"));
var _utils = require("./utils");
var _VirtualList = require("./VirtualList");
var _EmojiPickerListContext = require("../../context/EmojiPickerListContext");
var _EmojiPickerTabPanel = _interopRequireDefault(require("./EmojiPickerTabPanel"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * Test id for wrapper Emoji Picker List div
 */
var RENDER_EMOJI_PICKER_LIST_TESTID = exports.RENDER_EMOJI_PICKER_LIST_TESTID = 'render-emoji-picker-list';
var categoryClassname = 'emoji-category';

/**
 * Emoji grouped by a category title ie. Frequent, Your Uploads, All Uploads
 */

var byOrder = function byOrder(orderableA, orderableB) {
  return (orderableA.order || 0) - (orderableB.order || 0);
};
var EmojiPickerVirtualListInternalOld = exports.EmojiPickerVirtualListInternalOld = /*#__PURE__*/function (_PureComponent) {
  function EmojiPickerVirtualListInternalOld(_props) {
    var _this;
    (0, _classCallCheck2.default)(this, EmojiPickerVirtualListInternalOld);
    _this = _callSuper(this, EmojiPickerVirtualListInternalOld, [_props]);
    (0, _defineProperty2.default)(_this, "virtualItems", []);
    (0, _defineProperty2.default)(_this, "categoryTracker", new _CategoryTracker.default());
    (0, _defineProperty2.default)(_this, "listRef", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(_this, "onEmojiActive", function (emojiId, emoji) {
      if (_this.props.onEmojiActive) {
        _this.props.onEmojiActive(emojiId, emoji);
      }
    });
    (0, _defineProperty2.default)(_this, "onSearch", function (value) {
      if (_this.props.onSearch) {
        _this.props.onSearch(value);
      }
    });
    (0, _defineProperty2.default)(_this, "findEmojiRowAndColumnById", function (emojiId) {
      var columnIndex = -1;
      // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
      var rowIndex = _this.virtualItems.findIndex(function (rowItem) {
        if (rowItem instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
          // find uploaded emoji in each emoji row
          columnIndex = rowItem.props.emojis.findIndex(function (emoji) {
            return emoji.id === emojiId;
          });
          return columnIndex !== -1;
        }
        return false;
      });
      return {
        rowIndex: rowIndex,
        columnIndex: columnIndex
      };
    });
    (0, _defineProperty2.default)(_this, "buildVirtualItemFromGroup", function (group) {
      var _this$props = _this.props,
        onEmojiSelected = _this$props.onEmojiSelected,
        onEmojiDelete = _this$props.onEmojiDelete;
      var items = [];
      items.push(new _EmojiPickerVirtualItems.CategoryHeadingItem({
        id: group.category,
        title: group.title,
        className: categoryClassname
      }));
      var remainingEmojis = group.emojis;
      while (remainingEmojis.length > 0) {
        var rowEmojis = remainingEmojis.slice(0, _EmojiPickerSizes.sizes.emojiPerRow);
        remainingEmojis = remainingEmojis.slice(_EmojiPickerSizes.sizes.emojiPerRow);
        items.push(new _EmojiPickerVirtualItems.EmojisRowItem({
          category: group.category,
          emojis: rowEmojis,
          title: group.title,
          showDelete: group.title === _constants.userCustomTitle,
          onSelected: onEmojiSelected,
          onDelete: onEmojiDelete,
          onMouseMove: _this.onEmojiActive,
          onFocus: _this.onEmojiActive
        }));
      }
      return items;
    });
    (0, _defineProperty2.default)(_this, "buildVirtualItems", function (props, _state) {
      var emojis = props.emojis,
        loading = props.loading,
        query = props.query;
      var items = [];
      var prevFirstCategory = _this.categoryTracker.getFirstCategory();
      _this.categoryTracker.reset();
      if (loading) {
        items.push(new _EmojiPickerVirtualItems.LoadingItem());
      } else {
        if (query) {
          var search = _categories.CategoryDescriptionMap.SEARCH;
          // Only a single "result" category
          items = [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(_this.buildVirtualItemFromGroup({
            category: _constants.searchCategory,
            title: search.name,
            emojis: emojis,
            order: search.order
          })));
        } else {
          // Group by category

          // Not searching show in categories.
          _this.allEmojiGroups.forEach(function (group) {
            // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
            // by not passing it to irrelevant groups
            _this.categoryTracker.add(group.emojis[0].category, items.length);
            items = [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(_this.buildVirtualItemFromGroup(group)));
            if (group.category === _constants.yourUploadsCategory) {
              _this.lastYourUploadsRow = items.length - 1;
            }
          });
        }
      }

      // make sure virtualItems is up-to-date before calling onRowsRendered
      _this.virtualItems = items;
      if (!loading && !query) {
        if (_this.categoryTracker.getFirstCategory() !== prevFirstCategory) {
          _this.onRowsRendered({
            startIndex: 0
          });
        }
      }
    });
    (0, _defineProperty2.default)(_this, "addToCategoryMap", function (categoryToGroupMap, emoji, category) {
      if (!categoryToGroupMap[category]) {
        var categoryDefinition = _categories.CategoryDescriptionMap[category];
        categoryToGroupMap[category] = {
          emojis: [],
          title: categoryDefinition.name,
          category: category,
          order: categoryDefinition.order
        };
      }
      categoryToGroupMap[category].emojis.push(emoji);
      return categoryToGroupMap;
    });
    (0, _defineProperty2.default)(_this, "groupByCategory", function (currentUser) {
      return function (categoryToGroupMap, emoji) {
        _this.addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
        // separate user emojis
        if (emoji.category === _constants.customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
          _this.addToCategoryMap(categoryToGroupMap, emoji, _constants.yourUploadsCategory);
        }
        return categoryToGroupMap;
      };
    });
    (0, _defineProperty2.default)(_this, "buildEmojiGroupedByCategory", function (emojis, currentUser) {
      var categoryToGroupMap = emojis.reduce(_this.groupByCategory(currentUser), {});
      _this.allEmojiGroups = Object.keys(categoryToGroupMap).map(function (key) {
        return categoryToGroupMap[key];
      }).map(function (group) {
        if (group.category !== _constants.frequentCategory) {
          group.emojis.sort(byOrder);
        }
        return group;
      }).sort(byOrder);
    });
    (0, _defineProperty2.default)(_this, "findCategoryToActivate", function (row) {
      var category = null;
      if (row instanceof _EmojiPickerVirtualItems.CategoryHeadingItem) {
        category = row.props.id;
      } else if (row instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
        category = row.props.category;
      }

      // your uploads is rendered, take it as upload category, so could be highlighted in category selector
      if (category === _constants.yourUploadsCategory) {
        return _constants.customCategory;
        // search results is rendered, return null so won't be highlighted for category selector
      } else if (category === _constants.searchCategory) {
        return null;
      }
      return category;
    });
    /**
     * onRowsRendered callback function
     *
     * Check the category of top of rendered row and inform category selector to change active category
     * Rove index of emoji picker list
     */
    (0, _defineProperty2.default)(_this, "onRowsRendered", function (indexes) {
      var startIndex = indexes.startIndex;
      var rowItem = _this.virtualItems[startIndex];
      var list = _this.listRef.current;

      // update tabIndex manually, startIndex is not 0 based here
      if (rowItem instanceof _EmojiPickerVirtualItems.CategoryHeadingItem) {
        // if top of row rendered is category heading, update tabIndex for the next emoji row
        list === null || list === void 0 || list.updateFocusIndex(startIndex + 1);
      } else if (rowItem instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
        // if top of row rendered is emoji row, update it's tabIndex.
        list === null || list === void 0 || list.updateFocusIndex(startIndex);
      }
      if (!_this.props.query) {
        // Calculate category in view - only relevant if categories shown, i.e. no query
        var currentCategory = _this.findCategoryToActivate(rowItem);
        if (currentCategory !== null && _this.props.activeCategoryId !== currentCategory) {
          if (_this.props.onCategoryActivated) {
            _this.props.onCategoryActivated(currentCategory);
          }
        }
      }
    });
    (0, _defineProperty2.default)(_this, "rowSize", function (index) {
      var _this$virtualItems$in;
      return ((_this$virtualItems$in = _this.virtualItems[index]) === null || _this$virtualItems$in === void 0 ? void 0 : _this$virtualItems$in.height) || _EmojiPickerSizes.sizes.categoryHeadingHeight;
    });
    (0, _defineProperty2.default)(_this, "renderRow", function (context) {
      return (0, _EmojiPickerVirtualItems.virtualItemRenderer)(_this.virtualItems, context);
    });
    /**
     * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
     * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
     * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
     */
    (0, _defineProperty2.default)(_this, "handleOnCloseDelete", function () {
      var list = _this.listRef.current;
      list === null || list === void 0 || list.updateFocusIndex(_this.lastYourUploadsRow);
      _this.props.onCloseDelete();
    });
    _this.lastYourUploadsRow = 0;
    _this.buildEmojiGroupedByCategory(_props.emojis, _props.currentUser);
    _this.buildVirtualItems(_props, _this.state);
    return _this;
  }
  (0, _inherits2.default)(EmojiPickerVirtualListInternalOld, _PureComponent);
  return (0, _createClass2.default)(EmojiPickerVirtualListInternalOld, [{
    key: "UNSAFE_componentWillUpdate",
    value: function UNSAFE_componentWillUpdate(nextProps, nextState) {
      if (this.props.emojis !== nextProps.emojis || this.props.selectedTone !== nextProps.selectedTone || this.props.loading !== nextProps.loading || this.props.query !== nextProps.query) {
        if (!nextProps.query) {
          // Only refresh if no query
          this.buildEmojiGroupedByCategory(nextProps.emojis, nextProps.currentUser);
        }
        this.buildVirtualItems(nextProps, nextState);
      }
    }
  }, {
    key: "reveal",
    value:
    /**
     * Scrolls to a category in the list view
     */
    function reveal(category) {
      var row = this.categoryTracker.getRow(category);
      this.scrollToRow(row);
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.scrollToRow(this.virtualItems.length);
    }
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      this.scrollToRow(0);
    }
  }, {
    key: "scrollToRow",
    value: function scrollToRow(index) {
      var _this$listRef$current;
      (_this$listRef$current = this.listRef.current) === null || _this$listRef$current === void 0 || _this$listRef$current.scrollToRow(index);
    }
  }, {
    key: "scrollToRecentlyUploaded",
    value: function scrollToRecentlyUploaded(uploadedEmoji) {
      // when search results is shown
      if (this.props.query) {
        var _this$findEmojiRowAnd = this.findEmojiRowAndColumnById(uploadedEmoji.id),
          rowIndex = _this$findEmojiRowAnd.rowIndex,
          columnIndex = _this$findEmojiRowAnd.columnIndex;
        if (rowIndex !== -1) {
          var _this$listRef$current2;
          (_this$listRef$current2 = this.listRef.current) === null || _this$listRef$current2 === void 0 || _this$listRef$current2.scrollToEmojiAndFocus(rowIndex, columnIndex);
        }
      } else {
        // when seeing all emojis
        var row = this.lastYourUploadsRow;
        if (row > 0) {
          var _this$listRef$current3;
          (_this$listRef$current3 = this.listRef.current) === null || _this$listRef$current3 === void 0 || _this$listRef$current3.scrollToRowAndFocusLastEmoji(this.lastYourUploadsRow);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        query = _this$props2.query,
        selectedTone = _this$props2.selectedTone,
        onToneSelected = _this$props2.onToneSelected,
        onToneSelectorCancelled = _this$props2.onToneSelectorCancelled,
        toneEmoji = _this$props2.toneEmoji,
        uploading = _this$props2.uploading,
        uploadEnabled = _this$props2.uploadEnabled,
        emojiToDelete = _this$props2.emojiToDelete,
        initialUploadName = _this$props2.initialUploadName,
        uploadErrorMessage = _this$props2.uploadErrorMessage,
        onUploadCancelled = _this$props2.onUploadCancelled,
        onUploadEmoji = _this$props2.onUploadEmoji,
        onDeleteEmoji = _this$props2.onDeleteEmoji,
        onFileChooserClicked = _this$props2.onFileChooserClicked,
        onOpenUpload = _this$props2.onOpenUpload,
        _this$props2$size = _this$props2.size,
        size = _this$props2$size === void 0 ? _constants.defaultEmojiPickerSize : _this$props2$size,
        emojis = _this$props2.emojis;
      var virtualListHeight = _EmojiPickerSizes.sizes.listHeight + (0, _utils.emojiPickerHeightOffset)(size);
      return /*#__PURE__*/_react.default.createElement(_EmojiPickerTabPanel.default, {
        showSearchResults: !!query
      }, /*#__PURE__*/_react.default.createElement(_EmojiActions.default, {
        selectedTone: selectedTone,
        onToneSelected: onToneSelected,
        onToneSelectorCancelled: onToneSelectorCancelled,
        toneEmoji: toneEmoji,
        uploading: uploading,
        uploadEnabled: uploadEnabled,
        emojiToDelete: emojiToDelete,
        initialUploadName: initialUploadName,
        uploadErrorMessage: uploadErrorMessage,
        onUploadCancelled: onUploadCancelled,
        onUploadEmoji: onUploadEmoji,
        onCloseDelete: this.handleOnCloseDelete,
        onDeleteEmoji: onDeleteEmoji,
        onFileChooserClicked: onFileChooserClicked,
        onOpenUpload: onOpenUpload,
        query: query,
        onChange: this.onSearch,
        resultsCount: emojis.length
      }), /*#__PURE__*/_react.default.createElement(_EmojiPickerListContext.EmojiPickerListContextProvider, {
        initialEmojisFocus: {
          rowIndex: 1,
          columnIndex: 0
        }
      }, /*#__PURE__*/_react.default.createElement(_VirtualList.VirtualList, {
        ref: this.listRef,
        height: virtualListHeight,
        overscanRowCount: 10,
        rowCount: this.virtualItems.length,
        rowHeight: this.rowSize,
        rowRenderer: this.renderRow,
        scrollToAlignment: "start",
        width: _EmojiPickerSizes.sizes.listWidth,
        onRowsRendered: this.onRowsRendered
      })));
    }
  }]);
}(_react.PureComponent);
(0, _defineProperty2.default)(EmojiPickerVirtualListInternalOld, "defaultProps", {
  onEmojiSelected: function onEmojiSelected() {},
  onEmojiActive: function onEmojiActive() {},
  onEmojiDelete: function onEmojiDelete() {},
  onCategoryActivated: function onCategoryActivated() {},
  onSearch: function onSearch() {},
  size: _constants.defaultEmojiPickerSize
});
var EmojiPickerVirtualListInternalNew = exports.EmojiPickerVirtualListInternalNew = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
  var emojis = props.emojis,
    currentUser = props.currentUser,
    _props$onEmojiSelecte = props.onEmojiSelected,
    onEmojiSelected = _props$onEmojiSelecte === void 0 ? function () {} : _props$onEmojiSelecte,
    _props$onEmojiActive = props.onEmojiActive,
    onEmojiActive = _props$onEmojiActive === void 0 ? function () {} : _props$onEmojiActive,
    _props$onEmojiDelete = props.onEmojiDelete,
    onEmojiDelete = _props$onEmojiDelete === void 0 ? function () {} : _props$onEmojiDelete,
    _props$onCategoryActi = props.onCategoryActivated,
    onCategoryActivated = _props$onCategoryActi === void 0 ? function () {} : _props$onCategoryActi,
    _props$onSearch = props.onSearch,
    onSearch = _props$onSearch === void 0 ? function () {} : _props$onSearch,
    _props$size = props.size,
    size = _props$size === void 0 ? _constants.defaultEmojiPickerSize : _props$size,
    query = props.query,
    loading = props.loading,
    selectedTone = props.selectedTone,
    onToneSelected = props.onToneSelected,
    onToneSelectorCancelled = props.onToneSelectorCancelled,
    toneEmoji = props.toneEmoji,
    uploading = props.uploading,
    uploadEnabled = props.uploadEnabled,
    emojiToDelete = props.emojiToDelete,
    initialUploadName = props.initialUploadName,
    uploadErrorMessage = props.uploadErrorMessage,
    onUploadCancelled = props.onUploadCancelled,
    onUploadEmoji = props.onUploadEmoji,
    onDeleteEmoji = props.onDeleteEmoji,
    onCloseDelete = props.onCloseDelete,
    onFileChooserClicked = props.onFileChooserClicked,
    onOpenUpload = props.onOpenUpload,
    activeCategoryId = props.activeCategoryId;
  var listRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)([]),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    allEmojiGroups = _useState2[0],
    setAllEmojiGroups = _useState2[1];
  var _useState3 = (0, _react.useState)([]),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    virtualItems = _useState4[0],
    setVirtualItems = _useState4[1];
  var _useState5 = (0, _react.useState)(0),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    lastYourUploadsRow = _useState6[0],
    setLastYourUploadsRow = _useState6[1];
  var categoryTracker = (0, _react.useMemo)(function () {
    return new _CategoryTracker.default();
  }, []);
  var _useState7 = (0, _react.useState)(false),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    categoriesChanged = _useState8[0],
    setCategoriesChanged = _useState8[1];
  var groupByCategory = (0, _react.useCallback)(function (currentUser) {
    return function (categoryToGroupMap, emoji) {
      addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
      // separate user emojis
      if (emoji.category === _constants.customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
        addToCategoryMap(categoryToGroupMap, emoji, _constants.yourUploadsCategory);
      }
      return categoryToGroupMap;
    };
  }, []);

  /**
   * onRowsRendered callback function
   *
   * Check the category of top of rendered row and inform category selector to change active category
   * Rove index of emoji picker list
   */
  var onRowsRendered = (0, _react.useCallback)(function (indexes) {
    var startIndex = indexes.startIndex;
    var rowItem = virtualItems[startIndex];
    var list = listRef.current;

    // update tabIndex manually, startIndex is not 0 based here
    if (rowItem instanceof _EmojiPickerVirtualItems.CategoryHeadingItem) {
      // if top of row rendered is category heading, update tabIndex for the next emoji row
      list === null || list === void 0 || list.updateFocusIndex(startIndex + 1);
    } else if (rowItem instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
      // if top of row rendered is emoji row, update it's tabIndex.
      list === null || list === void 0 || list.updateFocusIndex(startIndex);
    }
    if (!query) {
      // Calculate category in view - only relevant if categories shown, i.e. no query
      var currentCategory = findCategoryToActivate(rowItem);
      if (currentCategory !== null && activeCategoryId !== currentCategory) {
        if (onCategoryActivated) {
          onCategoryActivated(currentCategory);
        }
      }
    }
  }, [virtualItems, query, activeCategoryId, onCategoryActivated]);
  var buildEmojiGroupedByCategory = (0, _react.useCallback)(function (emojis, currentUser) {
    var categoryToGroupMap = emojis.reduce(groupByCategory(currentUser), {});
    setAllEmojiGroups(Object.keys(categoryToGroupMap).map(function (key) {
      return categoryToGroupMap[key];
    }).map(function (group) {
      if (group.category !== _constants.frequentCategory) {
        group.emojis.sort(byOrder);
      }
      return group;
    }).sort(byOrder));
  }, [groupByCategory]);
  var addToCategoryMap = function addToCategoryMap(categoryToGroupMap, emoji, category) {
    if (!categoryToGroupMap[category]) {
      var categoryDefinition = _categories.CategoryDescriptionMap[category];
      categoryToGroupMap[category] = {
        emojis: [],
        title: categoryDefinition.name,
        category: category,
        order: categoryDefinition.order
      };
    }
    categoryToGroupMap[category].emojis.push(emoji);
    return categoryToGroupMap;
  };
  var buildVirtualItemFromGroup = (0, _react.useCallback)(function (group) {
    var items = [];
    items.push(new _EmojiPickerVirtualItems.CategoryHeadingItem({
      id: group.category,
      title: group.title,
      className: categoryClassname
    }));
    var remainingEmojis = group.emojis;
    while (remainingEmojis.length > 0) {
      var rowEmojis = remainingEmojis.slice(0, _EmojiPickerSizes.sizes.emojiPerRow);
      remainingEmojis = remainingEmojis.slice(_EmojiPickerSizes.sizes.emojiPerRow);
      items.push(new _EmojiPickerVirtualItems.EmojisRowItem({
        category: group.category,
        emojis: rowEmojis,
        title: group.title,
        showDelete: group.title === _constants.userCustomTitle,
        onSelected: onEmojiSelected,
        onDelete: onEmojiDelete,
        onMouseMove: onEmojiActive,
        onFocus: onEmojiActive
      }));
    }
    return items;
  }, [onEmojiSelected, onEmojiDelete, onEmojiActive]);
  var buildVirtualItems = (0, _react.useCallback)(function () {
    var items = [];
    var prevFirstCategory = categoryTracker.getFirstCategory();
    categoryTracker.reset();
    if (loading) {
      items.push(new _EmojiPickerVirtualItems.LoadingItem());
    } else {
      if (query) {
        var search = _categories.CategoryDescriptionMap.SEARCH;
        // Only a single "result" category
        items = [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(buildVirtualItemFromGroup({
          category: _constants.searchCategory,
          title: search.name,
          emojis: emojis,
          order: search.order
        })));
      } else {
        // Group by category

        // Not searching show in categories.
        allEmojiGroups.forEach(function (group) {
          // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
          // by not passing it to irrelevant groups
          categoryTracker.add(group.emojis[0].category, items.length);
          items = [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(buildVirtualItemFromGroup(group)));
          if (group.category === _constants.yourUploadsCategory) {
            setLastYourUploadsRow(items.length - 1);
          }
        });
      }
    }

    // make sure virtualItems is up-to-date before calling onRowsRendered
    setVirtualItems(items);
    if (!loading && !query) {
      if (categoryTracker.getFirstCategory() !== prevFirstCategory) {
        setCategoriesChanged(true);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allEmojiGroups, loading, query, emojis]);
  var findCategoryToActivate = function findCategoryToActivate(row) {
    var category = null;
    if (row instanceof _EmojiPickerVirtualItems.CategoryHeadingItem) {
      category = row.props.id;
    } else if (row instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
      category = row.props.category;
    }
    // your uploads is rendered, take it as upload category, so could be highlighted in category selector
    if (category === _constants.yourUploadsCategory) {
      return _constants.customCategory;
      // search results is rendered, return null so won't be highlighted for category selector
    } else if (category === _constants.searchCategory) {
      return null;
    }
    return category;
  };
  var rowSize = function rowSize(index) {
    var _virtualItems$index;
    return ((_virtualItems$index = virtualItems[index]) === null || _virtualItems$index === void 0 ? void 0 : _virtualItems$index.height) || _EmojiPickerSizes.sizes.categoryHeadingHeight;
  };
  var renderRow = function renderRow(context) {
    return (0, _EmojiPickerVirtualItems.virtualItemRenderer)(virtualItems, context);
  };

  /**
   * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
   * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
   * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
   */
  var handleOnCloseDelete = function handleOnCloseDelete() {
    var list = listRef.current;
    list === null || list === void 0 || list.updateFocusIndex(lastYourUploadsRow);
    onCloseDelete();
  };
  var findEmojiRowAndColumnById = function findEmojiRowAndColumnById(emojiId) {
    var columnIndex = -1;
    // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
    var rowIndex = virtualItems.findIndex(function (rowItem) {
      if (rowItem instanceof _EmojiPickerVirtualItems.EmojisRowItem) {
        // find uploaded emoji in each emoji row
        columnIndex = rowItem.props.emojis.findIndex(function (emoji) {
          return emoji.id === emojiId;
        });
        return columnIndex !== -1;
      }
      return false;
    });
    return {
      rowIndex: rowIndex,
      columnIndex: columnIndex
    };
  };

  /**
   * Scrolls to a category in the list view
   */
  (0, _react.useImperativeHandle)(ref, function () {
    return {
      reveal: function reveal(category) {
        var row = categoryTracker.getRow(category);
        (0, _utils.scrollToRow)(listRef, row);
      },
      scrollToBottom: function scrollToBottom() {
        (0, _utils.scrollToRow)(listRef, virtualItems.length);
      },
      scrollToTop: function scrollToTop() {
        (0, _utils.scrollToRow)(listRef, 0);
      },
      scrollToRow: function scrollToRow(index) {
        (0, _utils.scrollToRow)(listRef, index);
      },
      scrollToRecentlyUploaded: function scrollToRecentlyUploaded(uploadedEmoji) {
        // when search results is shown
        if (query) {
          var _findEmojiRowAndColum = findEmojiRowAndColumnById(uploadedEmoji.id),
            rowIndex = _findEmojiRowAndColum.rowIndex,
            columnIndex = _findEmojiRowAndColum.columnIndex;
          if (rowIndex !== -1) {
            var _listRef$current;
            (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollToEmojiAndFocus(rowIndex, columnIndex);
          }
        } else {
          // when seeing all emojis
          var row = lastYourUploadsRow;
          if (row > 0) {
            var _listRef$current2;
            (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollToRowAndFocusLastEmoji(lastYourUploadsRow);
          }
        }
      }
    };
  });
  (0, _react.useEffect)(function () {
    if (!query) {
      buildEmojiGroupedByCategory(emojis, currentUser);
    }
  }, [emojis, selectedTone, loading, query, currentUser, buildEmojiGroupedByCategory]);
  (0, _react.useEffect)(function () {
    buildVirtualItems();
  }, [allEmojiGroups, buildVirtualItems]);
  (0, _react.useEffect)(function () {
    if (categoriesChanged) {
      onRowsRendered({
        startIndex: 0
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [virtualItems, categoriesChanged]);
  var virtualListHeight = (0, _react.useMemo)(function () {
    return _EmojiPickerSizes.sizes.listHeight + (0, _utils.emojiPickerHeightOffset)(size);
  }, [size]);
  return /*#__PURE__*/_react.default.createElement(_EmojiPickerTabPanel.default, {
    showSearchResults: !!query
  }, /*#__PURE__*/_react.default.createElement(_EmojiActions.default, {
    selectedTone: selectedTone,
    onToneSelected: onToneSelected,
    onToneSelectorCancelled: onToneSelectorCancelled,
    toneEmoji: toneEmoji,
    uploading: uploading,
    uploadEnabled: uploadEnabled,
    emojiToDelete: emojiToDelete,
    initialUploadName: initialUploadName,
    uploadErrorMessage: uploadErrorMessage,
    onUploadCancelled: onUploadCancelled,
    onUploadEmoji: onUploadEmoji,
    onCloseDelete: handleOnCloseDelete,
    onDeleteEmoji: onDeleteEmoji,
    onFileChooserClicked: onFileChooserClicked,
    onOpenUpload: onOpenUpload,
    query: query,
    onChange: onSearch,
    resultsCount: emojis.length
  }), /*#__PURE__*/_react.default.createElement(_EmojiPickerListContext.EmojiPickerListContextProvider, {
    initialEmojisFocus: {
      rowIndex: 1,
      columnIndex: 0
    }
  }, /*#__PURE__*/_react.default.createElement(_VirtualList.VirtualList, {
    ref: listRef,
    height: virtualListHeight,
    overscanRowCount: 10,
    rowCount: virtualItems.length,
    rowHeight: rowSize,
    rowRenderer: renderRow,
    scrollToAlignment: "start",
    width: _EmojiPickerSizes.sizes.listWidth,
    onRowsRendered: onRowsRendered
  })));
});