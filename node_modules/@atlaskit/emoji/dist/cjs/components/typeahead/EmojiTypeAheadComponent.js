"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = require("react-dom");
var _uuid = _interopRequireDefault(require("uuid"));
var _EmojiCommonProvider = require("../../context/EmojiCommonProvider");
var _types = require("../../types");
var _analytics = require("../../util/analytics");
var _constants = require("../../util/constants");
var _logger = _interopRequireDefault(require("../../util/logger"));
var _typeHelpers = require("../../util/type-helpers");
var _RecordSelectionDefault = require("../common/RecordSelectionDefault");
var _EmojiTypeAheadList = _interopRequireDefault(require("./EmojiTypeAheadList"));
var _styles = require("./styles");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var isFullShortName = function isFullShortName(query) {
  return query && query.length > 1 && query.charAt(0) === ':' && query.charAt(query.length - 1) === ':';
};
var uniqueExactShortNameMatchIndex = function uniqueExactShortNameMatchIndex(searchResult, query) {
  if (!query) {
    return undefined;
  }
  query = query.toLowerCase();
  var matchIndex;
  var index = 0;
  var _iterator = _createForOfIteratorHelper(searchResult.emojis),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var emoji = _step.value;
      if (query && emoji.shortName.toLowerCase() === query) {
        if (matchIndex === undefined) {
          matchIndex = index;
        } else {
          return;
        }
      }
      index++;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return matchIndex;
};
var EmojiTypeAheadComponent = exports.default = /*#__PURE__*/function (_PureComponent) {
  function EmojiTypeAheadComponent(props) {
    var _this;
    (0, _classCallCheck2.default)(this, EmojiTypeAheadComponent);
    _this = _callSuper(this, EmojiTypeAheadComponent, [props]);
    (0, _defineProperty2.default)(_this, "emojiListRef", null);
    (0, _defineProperty2.default)(_this, "openTime", 0);
    (0, _defineProperty2.default)(_this, "renderStartTime", 0);
    (0, _defineProperty2.default)(_this, "selectNext", function () {
      if (_this.emojiListRef) {
        _this.emojiListRef.selectNext();
      }
    });
    (0, _defineProperty2.default)(_this, "selectPrevious", function () {
      if (_this.emojiListRef) {
        _this.emojiListRef.selectPrevious();
      }
    });
    (0, _defineProperty2.default)(_this, "chooseCurrentSelection", function () {
      _this.pressed = true;
      if (_this.emojiListRef) {
        _this.emojiListRef.chooseCurrentSelection();
      }
    });
    (0, _defineProperty2.default)(_this, "count", function () {
      var emojis = _this.state.emojis;
      return emojis && emojis.length || 0;
    });
    (0, _defineProperty2.default)(_this, "getTone", function (tone) {
      return typeof tone === 'undefined' ? undefined : tone >= 0 && tone <= 5 ? ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'][tone] : undefined;
    });
    (0, _defineProperty2.default)(_this, "onSearchResult", function (result) {
      var emojis = result.emojis,
        query = result.query;
      var wasVisible = _this.state.visible;
      var visible = emojis.length > 0;
      _this.fireAnalyticsEvent((0, _analytics.typeaheadRenderedEvent)(Date.now() - _this.renderStartTime, query, emojis));
      (0, _logger.default)('emoji-typeahead.applyPropChanges', emojis.length, wasVisible, visible);

      // Synchronously flush state update, because there is some analytics in fireSelectionEvent
      // that relies on emojis being set to determine the position
      (0, _reactDom.flushSync)(function () {
        _this.setState({
          emojis: emojis,
          visible: visible,
          loading: false
        });
      });
      if (isFullShortName(query)) {
        var matchIndex = uniqueExactShortNameMatchIndex(result, query);
        if (matchIndex !== undefined) {
          var onSelect = (0, _RecordSelectionDefault.createRecordSelectionDefault)(_this.props.emojiProvider, _this.props.onSelection, function (analytic) {
            return _this.fireAnalyticsEvent(analytic(_types.SearchSourceTypes.TYPEAHEAD));
          });
          _this.fireSelectionEvent(result.emojis[matchIndex], true);
          onSelect((0, _typeHelpers.toEmojiId)(result.emojis[matchIndex]), result.emojis[matchIndex]);
        }
      }
      if (wasVisible !== visible) {
        if (visible) {
          if (_this.props.onOpen) {
            _this.props.onOpen();
          }
        } else {
          if (_this.props.onClose) {
            _this.props.onClose();
          }
        }
      }
    });
    (0, _defineProperty2.default)(_this, "onProviderChange", {
      result: _this.onSearchResult
    });
    (0, _defineProperty2.default)(_this, "onEmojiListRef", function (ref) {
      _this.emojiListRef = ref;
    });
    _this.state = {
      visible: true,
      emojis: [],
      loading: true
    };
    if (_this.props.onOpen) {
      _this.props.onOpen();
    }
    _this.openTime = Date.now();
    _this.renderStartTime = _this.openTime;
    _this.selectedTone = props.emojiProvider.getSelectedTone();
    _this.pressed = false;
    _this.sessionId = (0, _uuid.default)();
    _this.selected = false;
    return _this;
  }
  (0, _inherits2.default)(EmojiTypeAheadComponent, _PureComponent);
  return (0, _createClass2.default)(EmojiTypeAheadComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var emojiProvider = this.props.emojiProvider;
      emojiProvider.subscribe(this.onProviderChange);
      this.onSearch(this.props.query);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props = this.props,
        emojiProvider = _this$props.emojiProvider,
        query = _this$props.query;
      var emojis = this.state.emojis;
      emojiProvider.unsubscribe(this.onProviderChange);
      if (!this.selected) {
        this.fireAnalyticsEvent((0, _analytics.typeaheadCancelledEvent)(Date.now() - this.openTime, query, emojis));
      }
      _analytics.ufoExperiences['emoji-searched'].abort({
        metadata: {
          source: 'EmojiTypeAheadComponent',
          reason: 'unmount',
          query: query
        }
      });
      _analytics.ufoExperiences['emoji-selection-recorded'].abort({
        metadata: {
          source: 'EmojiTypeAheadComponent',
          reason: 'unmount',
          query: query
        }
      });
      this.sessionId = (0, _uuid.default)();
      this.selected = false;
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (!(0, _platformFeatureFlags.fg)('platform_editor_react18_elements_emoji') || !(0, _platformFeatureFlags.fg)('platform_editor_react18_elements_emoji_jira_bb')) {
        var prevEmojiProvider = this.props.emojiProvider;
        var nextEmojiProvider = nextProps.emojiProvider;
        if (prevEmojiProvider !== nextEmojiProvider) {
          prevEmojiProvider.unsubscribe(this.onProviderChange);
          nextEmojiProvider.subscribe(this.onProviderChange);
          this.onSearch(nextProps.query);
        } else if (this.props.query !== nextProps.query) {
          this.onSearch(nextProps.query);
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if ((0, _platformFeatureFlags.fg)('platform_editor_react18_elements_emoji') || (0, _platformFeatureFlags.fg)('platform_editor_react18_elements_emoji_jira_bb')) {
        if (prevProps !== this.props) {
          var prevEmojiProvider = prevProps.emojiProvider;
          var nextEmojiProvider = this.props.emojiProvider;
          if (prevEmojiProvider !== nextEmojiProvider) {
            prevEmojiProvider.unsubscribe(this.onProviderChange);
            nextEmojiProvider.subscribe(this.onProviderChange);
            this.onSearch(this.props.query);
          } else if (prevProps.query !== this.props.query) {
            this.onSearch(this.props.query);
          }
        }
      }
    }
  }, {
    key: "fireAnalyticsEvent",
    value: function fireAnalyticsEvent(payload) {
      if (!this.props.createAnalyticsEvent) {
        return;
      }
      payload.attributes.sessionId = this.sessionId;
      this.props.createAnalyticsEvent(payload).fire('fabric-elements');
    }
  }, {
    key: "onSearch",
    value: function onSearch(query) {
      var _this$props2 = this.props,
        emojiProvider = _this$props2.emojiProvider,
        listLimit = _this$props2.listLimit;
      var options = {
        limit: listLimit || _constants.defaultListLimit,
        skinTone: this.selectedTone
      };
      if (query && query.replace(':', '').length > 0) {
        options.sort = _types.SearchSort.Default;
      } else {
        // if empty query (i.e. typeahead triggered only) then only sort by usage
        options.sort = _types.SearchSort.UsageFrequency;
      }
      this.renderStartTime = Date.now();
      emojiProvider.filter(query, options);
    }
  }, {
    key: "fireSelectionEvent",
    value: function fireSelectionEvent(emoji, exactMatch) {
      var query = this.props.query;
      var emojis = this.state.emojis;
      this.selected = true;
      this.fireAnalyticsEvent((0, _analytics.typeaheadSelectedEvent)(exactMatch || this.pressed, Date.now() - this.openTime, emoji, emojis, query, exactMatch));
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props3 = this.props,
        emojiProvider = _this$props3.emojiProvider,
        onSelection = _this$props3.onSelection;
      var recordUsageOnSelection = (0, _RecordSelectionDefault.createRecordSelectionDefault)(emojiProvider, function (emojiId, emoji, event) {
        _this2.fireSelectionEvent(emoji);
        if (onSelection) {
          onSelection(emojiId, emoji, event);
        }
      }, function (analytic) {
        return _this2.fireAnalyticsEvent(analytic(_types.SearchSourceTypes.TYPEAHEAD));
      });
      var _this$state = this.state,
        visible = _this$state.visible,
        emojis = _this$state.emojis,
        loading = _this$state.loading;
      var style = {
        display: visible ? 'block' : 'none'
      };
      return /*#__PURE__*/_react.default.createElement(_EmojiCommonProvider.EmojiCommonProvider, {
        emojiProvider: this.props.emojiProvider
      }, /*#__PURE__*/_react.default.createElement("div", {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
        style: style
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        ,
        className: ['ak-emoji-typeahead', _styles.emojiTypeAhead].join(' ')
      }, /*#__PURE__*/_react.default.createElement(_EmojiTypeAheadList.default, {
        emojis: emojis,
        onEmojiSelected: recordUsageOnSelection,
        ref: this.onEmojiListRef,
        loading: loading
      })));
    }
  }]);
}(_react.PureComponent);
(0, _defineProperty2.default)(EmojiTypeAheadComponent, "defaultProps", {
  onSelection: function onSelection() {},
  onOpen: function onOpen() {},
  onClose: function onClose() {},
  listLimit: _constants.defaultListLimit
});