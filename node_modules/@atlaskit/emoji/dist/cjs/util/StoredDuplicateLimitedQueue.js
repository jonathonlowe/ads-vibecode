"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _DuplicateLimitedQueue = _interopRequireDefault(require("./DuplicateLimitedQueue"));
var _logger = _interopRequireDefault(require("./logger"));
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
/**
 * The options used to configure a newly constructed queue.
 */
/**
 * An extension to the DuplicateLimitedQueue that will initialise its contents from the
 * supplied Storage and will also update the storage for every new item enqueued.
 */
var StoredDuplicateLimitedQueue = exports.default = /*#__PURE__*/function (_DuplicateLimitedQueu) {
  function StoredDuplicateLimitedQueue(options) {
    var _this;
    (0, _classCallCheck2.default)(this, StoredDuplicateLimitedQueue);
    _this = _callSuper(this, StoredDuplicateLimitedQueue, [options]);
    _this.storage = options.storage;
    _this.prefixedStorageKey = "".concat(options.storagePrefix, ".").concat(StoredDuplicateLimitedQueue.storageKey);
    _this.load();
    return _this;
  }

  /**
   * Enqueue the supplied item and also persist the new contents of the queue to storage.
   *
   * @param item the item to be enqueued
   */
  (0, _inherits2.default)(StoredDuplicateLimitedQueue, _DuplicateLimitedQueu);
  return (0, _createClass2.default)(StoredDuplicateLimitedQueue, [{
    key: "enqueue",
    value: function enqueue(item) {
      _superPropGet(StoredDuplicateLimitedQueue, "enqueue", this, 3)([item]);
      this.save();
    }

    /**
     * Exposed for storybook/testing purposes only. Clear the contents of the queue, and localStorage.
     */
  }, {
    key: "clear",
    value: function clear() {
      _superPropGet(StoredDuplicateLimitedQueue, "clear", this, 3)([]);
      this.storage.removeItem(this.prefixedStorageKey);
    }

    /**
     * Initialise the queue contents from the configured Storage. If there is no data found in
     * storage then the queue will have no items added. Likewise, a failure to read or parse stored
     * data will be swallowed and no items are added to the queue.
     */
  }, {
    key: "load",
    value: function load() {
      var itemsJson = this.storage.getItem(this.prefixedStorageKey);
      if (itemsJson) {
        try {
          var items = JSON.parse(itemsJson);
          this.bulkEnqueue(items);
        } catch (e) {
          (0, _logger.default)("Error parsing the queue stored as ".concat(this.prefixedStorageKey, " key from storage"), e);
        }
      }
    }

    /**
     * Save the current items in the queue, overwriting any previously stored queue.
     * Any failure in saving will be silently ignored with the likely outcome that any previous
     * saved items will remain unchanged in storage.
     */
  }, {
    key: "save",
    value: function save() {
      var itemsJson = JSON.stringify(this.getItems());
      try {
        this.storage.setItem(this.prefixedStorageKey, itemsJson);
      } catch (e) {
        (0, _logger.default)("Error saving the queued items as ".concat(this.prefixedStorageKey), e);
      }
    }
  }]);
}(_DuplicateLimitedQueue.default);
(0, _defineProperty2.default)(StoredDuplicateLimitedQueue, "storageKey", 'lastUsed');