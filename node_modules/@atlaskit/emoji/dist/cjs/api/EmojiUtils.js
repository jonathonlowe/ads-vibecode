"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldUseAltRepresentation = exports.isMediaApiUrl = exports.getPixelRatio = exports.getAltRepresentation = exports.emojiRequest = exports.denormaliseSkinEmoji = exports.denormaliseServiceRepresentation = exports.denormaliseServiceAltRepresentation = exports.denormaliseEmojiServiceResponse = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _utilServiceSupport = require("@atlaskit/util-service-support");
var _typeHelpers = require("../util/type-helpers");
var _logger = _interopRequireDefault(require("../util/logger"));
var _excluded = ["getRatio"],
  _excluded2 = ["queryParams"],
  _excluded3 = ["representation", "altRepresentations"],
  _excluded4 = ["representation", "skinVariations", "altRepresentations"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var emojiRequest = exports.emojiRequest = function emojiRequest(provider, options) {
  var _provider$getRatio = provider.getRatio,
    getRatio = _provider$getRatio === void 0 ? getPixelRatio : _provider$getRatio,
    serviceConfig = (0, _objectWithoutProperties2.default)(provider, _excluded);
  var scaleQueryParams = calculateScale(getRatio);
  var _ref = options || {},
    _ref$queryParams = _ref.queryParams,
    queryParams = _ref$queryParams === void 0 ? {} : _ref$queryParams,
    otherOptions = (0, _objectWithoutProperties2.default)(_ref, _excluded2);
  var requestOptions = _objectSpread(_objectSpread({}, otherOptions), {}, {
    queryParams: _objectSpread(_objectSpread(_objectSpread({}, scaleQueryParams), queryParams), {}, {
      preferredRepresentation: 'IMAGE'
    })
  });
  return _utilServiceSupport.utils.requestService(serviceConfig, requestOptions);
};
var calculateScale = function calculateScale(getRatio) {
  // Retina display
  if (getRatio() > 1) {
    return {
      scale: 'XHDPI',
      altScale: 'XXXHDPI'
    };
  }
  // Default set used for desktop
  return {
    altScale: 'XHDPI'
  };
};
var getPixelRatio = exports.getPixelRatio = function getPixelRatio() {
  if (typeof window === 'undefined') {
    return 0;
  }
  return window.devicePixelRatio;
};
var getAltRepresentation = exports.getAltRepresentation = function getAltRepresentation(reps) {
  // Invalid reps handled outside function - logic may change depending what the service returns
  return reps[calculateScale(getPixelRatio).altScale];
};
var isMediaApiUrl = exports.isMediaApiUrl = function isMediaApiUrl(url, meta) {
  return !!(meta && meta.mediaApiToken && url.indexOf(meta.mediaApiToken.url) === 0);
};
var denormaliseServiceRepresentation = exports.denormaliseServiceRepresentation = function denormaliseServiceRepresentation(representation, meta) {
  if ((0, _typeHelpers.isSpriteServiceRepresentation)(representation) && meta && meta.spriteSheets) {
    var _ref2 = representation,
      height = _ref2.height,
      width = _ref2.width,
      x = _ref2.x,
      y = _ref2.y,
      xIndex = _ref2.xIndex,
      yIndex = _ref2.yIndex,
      spriteRef = _ref2.spriteRef;
    var spriteSheet = meta.spriteSheets[spriteRef];
    if (spriteSheet) {
      return {
        sprite: spriteSheet,
        height: height,
        width: width,
        x: x,
        y: y,
        xIndex: xIndex,
        yIndex: yIndex
      };
    }
  } else if ((0, _typeHelpers.isImageRepresentation)(representation)) {
    var _height = representation.height,
      _width = representation.width,
      imagePath = representation.imagePath;
    if (isMediaApiUrl(imagePath, meta)) {
      return (0, _typeHelpers.convertImageToMediaRepresentation)(representation);
    }
    return {
      height: _height,
      width: _width,
      imagePath: imagePath
    };
  }
  (0, _logger.default)('failed conversion for representation', representation, meta);
  return undefined;
};
var denormaliseServiceAltRepresentation = exports.denormaliseServiceAltRepresentation = function denormaliseServiceAltRepresentation(altReps, meta) {
  return !altReps || Object.keys(altReps).length === 0 ? undefined : denormaliseServiceRepresentation(getAltRepresentation(altReps), meta);
};
var denormaliseSkinEmoji = exports.denormaliseSkinEmoji = function denormaliseSkinEmoji(emoji, meta) {
  if (!emoji.skinVariations) {
    return [];
  }
  var skinEmoji = emoji.skinVariations;
  var baseId = emoji.id;
  return skinEmoji.map(function (skin) {
    var representation = skin.representation,
      altRepresentations = skin.altRepresentations,
      other = (0, _objectWithoutProperties2.default)(skin, _excluded3);
    return _objectSpread({
      baseId: baseId,
      representation: denormaliseServiceRepresentation(representation, meta),
      altRepresentation: denormaliseServiceAltRepresentation(altRepresentations, meta)
    }, other);
  });
};

/**
 * Denormalised an emoji response (emojis + sprite references) into an array of
 * emoji with local sprite definitions.
 */
var denormaliseEmojiServiceResponse = exports.denormaliseEmojiServiceResponse = function denormaliseEmojiServiceResponse(emojiData) {
  var emojis = emojiData.emojis.map(function (emoji) {
    var newRepresentation = denormaliseServiceRepresentation(emoji.representation, emojiData.meta);
    var altRepresentation = denormaliseServiceAltRepresentation(emoji.altRepresentations, emojiData.meta);
    var newSkinVariations = denormaliseSkinEmoji(emoji, emojiData.meta);

    // create trimmedServiceDesc which is emoji with no representations or skinVariations
    var representation = emoji.representation,
      skinVariations = emoji.skinVariations,
      altRepresentations = emoji.altRepresentations,
      trimmedServiceDesc = (0, _objectWithoutProperties2.default)(emoji, _excluded4);
    var response = _objectSpread(_objectSpread({}, trimmedServiceDesc), {}, {
      representation: newRepresentation,
      skinVariations: newSkinVariations
    });
    return (0, _typeHelpers.buildEmojiDescriptionWithAltRepresentation)(response, altRepresentation);
  });
  var mediaApiToken = emojiData.meta && emojiData.meta.mediaApiToken;
  return {
    emojis: emojis,
    mediaApiToken: mediaApiToken
  };
};
var getHeight = function getHeight(fitToHeight) {
  return getPixelRatio() > 1 ? fitToHeight * 2 : fitToHeight;
};
var shouldUseAltRepresentation = exports.shouldUseAltRepresentation = function shouldUseAltRepresentation(emoji, fitToHeight) {
  return !!(fitToHeight && emoji.altRepresentation && getHeight(fitToHeight) > emoji.representation.height);
};