"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MemoryCacheStrategy = exports.BrowserCacheStrategy = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeHelpers = require("../../util/type-helpers");
var _MediaImageLoader = _interopRequireDefault(require("./MediaImageLoader"));
var _logger = _interopRequireDefault(require("../../util/logger"));
var _lru_map = require("lru_map");
var getRequiredRepresentation = function getRequiredRepresentation(emoji, useAlt) {
  return useAlt ? emoji.altRepresentation : emoji.representation;
};
var isUnsupportedBrowser = function isUnsupportedBrowser() {
  var isIE = /*@cc_on!@*/false || !!document.documentMode; // Internet Explorer 6-11
  var isEdge = !isIE && !!window.StyleMedia; // Edge 20+

  return isIE || isEdge;
};
/**
 * For browsers that support caching for resources
 * regardless of originally supplied headers (basically everything but Firefox).
 */
var BrowserCacheStrategy = exports.BrowserCacheStrategy = /*#__PURE__*/function () {
  function BrowserCacheStrategy(mediaImageLoader) {
    (0, _classCallCheck2.default)(this, BrowserCacheStrategy);
    (0, _defineProperty2.default)(this, "cachedImageUrls", new Set());
    (0, _logger.default)('BrowserCacheStrategy');
    this.mediaImageLoader = mediaImageLoader;
  }
  return (0, _createClass2.default)(BrowserCacheStrategy, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var _this = this;
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!(0, _typeHelpers.isMediaRepresentation)(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      if (this.cachedImageUrls.has(mediaPath)) {
        // Already cached
        return emoji;
      }
      return this.mediaImageLoader.loadMediaImage(mediaPath).then(function () {
        // Media is loaded, can use original URL now, so just return original emoji
        _this.cachedImageUrls.add(mediaPath);
        return emoji;
      }).catch(function () {
        return undefined;
      });
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering() {
      return true;
    }
  }], [{
    key: "supported",
    value: function supported(mediaPath, mediaImageLoader) {
      // IE/Edge uses memory cache strategy else images can fail to load
      // from a clean cache/if they are downloaded from the service
      // TODO: fix as a part of FS-1592
      if (isUnsupportedBrowser()) {
        return Promise.resolve(false);
      }
      return mediaImageLoader.loadMediaImage(mediaPath).then(function () {
        return (
          // Image should be cached in browser, if supported it should be accessible from the cache by an <img/>
          // Try to load without via image to confirm this support (this fails in Firefox)
          new Promise(function (resolve) {
            var img = new Image();
            img.addEventListener('load', function () {
              resolve(true);
            });
            img.addEventListener('error', function () {
              resolve(false);
            });
            img.src = mediaPath;
          })
        );
      }).catch(function () {
        return false;
      });
    }
  }]);
}();
var maxImageCached = 1000;
// Don't cache images large than this - dataUrl size in characters
var maxImageSize = 10000;

/**
 * For browsers that do no cache images without equivalent headers (e.g. Firefox).
 *
 * Images are cached in memory in a LRU cache. Images considered too large,
 * are not cached, but retrieved each time.
 *
 * Images are still cached by the browser, but loading in asynchronous with
 * small delay noticable to the end user.
 */
var MemoryCacheStrategy = exports.MemoryCacheStrategy = /*#__PURE__*/function () {
  function MemoryCacheStrategy(mediaImageLoader) {
    (0, _classCallCheck2.default)(this, MemoryCacheStrategy);
    (0, _logger.default)('MemoryCacheStrategy');
    this.mediaImageLoader = mediaImageLoader;
    this.dataURLCache = new _lru_map.LRUMap(maxImageCached);
  }
  return (0, _createClass2.default)(MemoryCacheStrategy, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var _this2 = this;
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!(0, _typeHelpers.isMediaRepresentation)(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      var dataURL = this.dataURLCache.get(mediaPath);
      if (dataURL) {
        // Already cached
        return (0, _typeHelpers.convertMediaToImageEmoji)(emoji, dataURL, useAlt);
      }

      // Not cached, load
      return this.mediaImageLoader.loadMediaImage(mediaPath).then(function (dataURL) {
        var loadedEmoji = (0, _typeHelpers.convertMediaToImageEmoji)(emoji, dataURL, useAlt);
        if (dataURL.length <= maxImageSize) {
          // Only cache if not large than max size
          _this2.dataURLCache.set(mediaPath, dataURL);
        } else {
          (0, _logger.default)('No caching as image is too large', dataURL.length, dataURL.slice(0, 15), emoji.shortName);
        }
        return loadedEmoji;
      }).catch(function () {
        return undefined;
      });
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering() {
      return false;
    }
  }]);
}();
/**
 * Provides a cache for Media Emoji.
 *
 * Emoji are returned immediately if cached and ready to use by the browser.
 *
 * Otherwise, they are loaded and returned via a promise.
 */
var MediaEmojiCache = exports.default = /*#__PURE__*/function () {
  function MediaEmojiCache(tokenManager) {
    (0, _classCallCheck2.default)(this, MediaEmojiCache);
    (0, _defineProperty2.default)(this, "waitingInitUrls", []);
    (0, _logger.default)('MediaEmojiCache');
    this.mediaImageLoader = new _MediaImageLoader.default(tokenManager);
  }
  return (0, _createClass2.default)(MediaEmojiCache, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!(0, _typeHelpers.isMediaRepresentation)(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      var emojiCache = this.getCache(mediaPath);
      if ((0, _typeHelpers.isPromise)(emojiCache)) {
        // Promise based
        return emojiCache.then(function (cache) {
          return cache.loadEmoji(emoji, useAlt);
        }).catch(function () {
          return undefined;
        });
      }
      return emojiCache.loadEmoji(emoji, useAlt);
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering(url) {
      var emojiCache = this.getCache(url);
      if ((0, _typeHelpers.isPromise)(emojiCache)) {
        // Promise based
        return emojiCache.then(function (cache) {
          return cache.optimisticRendering();
        }).catch(function () {
          return false;
        });
      }
      return emojiCache.optimisticRendering();
    }
  }, {
    key: "getCache",
    value: function getCache(url) {
      var _this3 = this;
      if (this.cache) {
        return this.cache;
      }
      this.waitingInitUrls.push(url);
      if (!this.cacheLoading) {
        this.cacheLoading = this.initCache().then(function (cache) {
          _this3.cache = cache;
          _this3.cacheLoading = undefined;
          return cache;
        }).catch(function (err) {
          _this3.cacheLoading = undefined;
          throw err;
        });
      }
      return this.cacheLoading;
    }
  }, {
    key: "initCache",
    value: function initCache() {
      var _this4 = this;
      var url = this.waitingInitUrls.pop();
      if (!url) {
        return Promise.reject('Unable to initialise cache based on provided url(s)');
      }
      return BrowserCacheStrategy.supported(url, this.mediaImageLoader).then(function (supported) {
        _this4.waitingInitUrls = []; // clear
        _this4.cacheLoading = undefined;
        if (supported) {
          return new BrowserCacheStrategy(_this4.mediaImageLoader);
        }
        return new MemoryCacheStrategy(_this4.mediaImageLoader);
      }).catch(function () {
        return _this4.initCache();
      });
    }
  }]);
}();