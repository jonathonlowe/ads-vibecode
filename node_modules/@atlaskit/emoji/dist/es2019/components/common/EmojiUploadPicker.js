/* EmojiUploadPicker.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./EmojiUploadPicker.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { useEffect, useLayoutEffect, useState, useRef, memo, useCallback } from 'react';
import { N300 } from '@atlaskit/theme/colors';
import { FormattedMessage, injectIntl } from 'react-intl-next';
import TextField from '@atlaskit/textfield';
import CrossIcon from '@atlaskit/icon/core/migration/close--cross';
import AkButton from '@atlaskit/button/standard-button';
import { Text } from '@atlaskit/primitives/compiled';
import FocusLock from 'react-focus-lock';
import * as ImageUtil from '../../util/image';
import debug from '../../util/logger';
import { messages } from '../i18n';
import EmojiErrorMessage from './EmojiErrorMessage';
import EmojiUploadPreview from './EmojiUploadPreview';
import FileChooser from './FileChooser';
import { UploadStatus } from './internal-types';
const closeEmojiUploadButton = null;
const emojiUpload = null;
const emojiUploadTop = null;
const headingH5 = null;
const uploadChooseFileEmojiName = null;
const uploadChooseFileMessage = null;
const uploadChooseFileRow = null;
export const uploadEmojiNameInputTestId = 'upload-emoji-name-input';
export const uploadEmojiComponentTestId = 'upload-emoji-component';
export const cancelEmojiUploadPickerTestId = 'cancel-emoji-upload-picker';
const disallowedReplacementsMap = new Map([[':', ''], ['!', ''], ['@', ''], ['#', ''], ['%', ''], ['^', ''], ['&', ''], ['*', ''], ['(', ''], [')', ''], [' ', '_']]);
const sanitizeName = name => {
  // prevent / replace certain characters, allow others
  disallowedReplacementsMap.forEach((replaceWith, exclude) => {
    name = name.split(exclude).join(replaceWith);
  });
  return name;
};
const maxNameLength = 50;
const toEmojiName = uploadName => {
  const name = uploadName.split('_').join(' ');
  return `${name.substr(0, 1).toLocaleUpperCase()}${name.substr(1)}`;
};
const ChooseEmojiFile = /*#__PURE__*/memo(props => {
  const {
    name = '',
    onChooseFile,
    onClick,
    onNameChange,
    onUploadCancelled,
    errorMessage,
    intl
  } = props;
  const {
    formatMessage
  } = intl;
  const disableChooser = !name;
  const fileChooserButtonDescriptionId = 'choose.emoji.file.button.screen.reader.description.id';
  const inputRef = useRef(null);
  const onKeyDownHandler = useCallback(event => {
    if (event.key === 'Escape') {
      onUploadCancelled();
    }
  }, [onUploadCancelled]);
  useLayoutEffect(() => {
    requestAnimationFrame(() => {
      var _inputRef$current;
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
    });
  }, []);
  const cancelLabel = formatMessage(messages.cancelLabel);
  const emojiPlaceholder = formatMessage(messages.emojiPlaceholder);
  const emojiNameAriaLabel = formatMessage(messages.emojiNameAriaLabel);
  const emojiChooseFileTitle = formatMessage(messages.emojiChooseFileTitle);
  return /*#__PURE__*/React.createElement("div", {
    "data-testid": uploadEmojiComponentTestId,
    className: ax(["_ca0q19bv _u5f319bv _n3td19bv _19bv19bv _4t3icae7 _1e0c1txw _2lx21bp4 _1bah1b1v"])
  }, /*#__PURE__*/React.createElement("div", {
    className: ax(["_11c8dcr7 _n3td1v6z _1e0c1txw _1bah1yb4 _4cvresu3"])
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "new-emoji-name-input",
    className: ax(["_1w901n3s", "_fqoxdcr7 _12r21pd9"])
  }, /*#__PURE__*/React.createElement(FormattedMessage, messages.addCustomEmojiLabel)), /*#__PURE__*/React.createElement("div", {
    className: ax(["_1e0c1txw"])
  }, /*#__PURE__*/React.createElement(AkButton, {
    onClick: onUploadCancelled,
    "aria-label": cancelLabel,
    appearance: "subtle",
    spacing: "none",
    shouldFitContainer: true,
    testId: cancelEmojiUploadPickerTestId
  }, /*#__PURE__*/React.createElement(CrossIcon, {
    color: "currentColor",
    LEGACY_size: "small",
    label: cancelLabel
  })))), /*#__PURE__*/React.createElement("div", {
    className: ax(["_1e0c1txw _1bah1yb4 _n3td1v6z"])
  }, /*#__PURE__*/React.createElement("span", {
    className: ax(["_16jlkb7n _1o9zkb7n _i0dl1wug _2hwx14y2 _1rwq1j28 _scffidpf _xmji1r31 _gxxuglyw _34ir1o36 _coc6glyw _9bj2glyw"])
  }, /*#__PURE__*/React.createElement(TextField, {
    placeholder: emojiPlaceholder,
    "aria-label": emojiNameAriaLabel,
    maxLength: maxNameLength,
    onChange: onNameChange,
    onKeyDown: onKeyDownHandler,
    value: name,
    isCompact: true,
    autoFocus: true,
    testId: uploadEmojiNameInputTestId,
    ref: inputRef,
    id: "new-emoji-name-input",
    "aria-required": true
  })), /*#__PURE__*/React.createElement(Text, null, /*#__PURE__*/React.createElement(FormattedMessage, messages.emojiChooseFileScreenReaderDescription, () => /*#__PURE__*/React.createElement(FileChooser, {
    label: emojiChooseFileTitle,
    onChange: onChooseFile,
    onClick: onClick,
    accept: "image/png,image/jpeg,image/gif",
    ariaDescribedBy: fileChooserButtonDescriptionId,
    isDisabled: disableChooser
  })))), /*#__PURE__*/React.createElement("div", {
    id: fileChooserButtonDescriptionId
  }, !errorMessage ? /*#__PURE__*/React.createElement(Text, {
    as: "p",
    size: "small"
  }, /*#__PURE__*/React.createElement(FormattedMessage, messages.emojiImageRequirements)) : /*#__PURE__*/React.createElement(EmojiErrorMessage, {
    errorStyle: "chooseFile",
    message: errorMessage
  })));
});
const EmojiUploadPicker = props => {
  var _document$activeEleme;
  const {
    errorMessage,
    initialUploadName,
    onUploadEmoji,
    onFileChooserClicked,
    onUploadCancelled,
    intl
  } = props;
  const [uploadStatus, setUploadStatus] = useState(errorMessage ? UploadStatus.Error : UploadStatus.Waiting);
  const [chooseEmojiErrorMessage, setChooseEmojiErrorMessage] = useState();
  const [name, setName] = useState(initialUploadName && sanitizeName(initialUploadName));
  const [filename, setFilename] = useState();
  const [previewImage, setPreviewImage] = useState();
  // document is undefined during ssr rendering and throws an error
  const lastFocusedElementId = useRef(typeof document !== 'undefined' ? (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.id : '');
  useEffect(() => {
    if (errorMessage) {
      setUploadStatus(UploadStatus.Error);
      return;
    } else {
      if (uploadStatus === UploadStatus.Error) {
        setUploadStatus(UploadStatus.Waiting);
      }
    }
  }, [errorMessage, uploadStatus]);
  useEffect(() => {
    if (initialUploadName) {
      setName(sanitizeName(initialUploadName));
    }
  }, [initialUploadName]);
  const clearUploadPicker = useCallback(() => {
    setName(undefined);
    setPreviewImage(undefined);
    setUploadStatus(UploadStatus.Waiting);
  }, []);
  const onNameChange = useCallback(event => {
    let newName = sanitizeName(event.target.value);
    if (name !== newName) {
      setName(newName);
    }
  }, [name]);
  const onAddEmoji = useCallback(() => {
    if (uploadStatus === UploadStatus.Uploading) {
      return;
    }
    if (filename && name && previewImage) {
      const notifyUpload = size => {
        const {
          width,
          height
        } = size;
        setUploadStatus(UploadStatus.Uploading);
        onUploadEmoji({
          name: toEmojiName(name),
          shortName: `:${name}:`,
          filename,
          dataURL: previewImage,
          width,
          height
        }, uploadStatus === UploadStatus.Error, clearUploadPicker);
      };
      ImageUtil.getNaturalImageSize(previewImage).then(size => {
        notifyUpload(size);
      }).catch(error => {
        debug('getNaturalImageSize error', error);
        // Just set arbitrary size, worse case is it may render
        // in wrong aspect ratio in some circumstances.
        notifyUpload({
          width: 32,
          height: 32
        });
      });
    }
  }, [clearUploadPicker, filename, name, onUploadEmoji, previewImage, uploadStatus]);
  const cancelChooseFile = useCallback(() => {
    setPreviewImage(undefined);
  }, []);
  const errorOnUpload = useCallback(event => {
    debug('File load error: ', event);
    setChooseEmojiErrorMessage( /*#__PURE__*/React.createElement(FormattedMessage, messages.emojiUploadFailed));
    cancelChooseFile();
  }, [cancelChooseFile]);
  const onFileLoad = useCallback(file => async f => {
    try {
      setFilename(file.name);
      await ImageUtil.parseImage(f.target.result);
      setPreviewImage(f.target.result);
    } catch {
      setChooseEmojiErrorMessage( /*#__PURE__*/React.createElement(FormattedMessage, messages.emojiInvalidImage));
      cancelChooseFile();
    }
  }, [cancelChooseFile]);
  const onChooseFile = useCallback(event => {
    const files = event.target.files;
    if (files.length) {
      const reader = new FileReader();
      const file = files[0];
      if (ImageUtil.hasFileExceededSize(file)) {
        setChooseEmojiErrorMessage( /*#__PURE__*/React.createElement(FormattedMessage, messages.emojiImageTooBig));
        cancelChooseFile();
        return;
      }
      reader.addEventListener('load', onFileLoad(file));
      reader.addEventListener('abort', errorOnUpload);
      reader.addEventListener('error', errorOnUpload);
      reader.readAsDataURL(file);
    } else {
      cancelChooseFile();
    }
  }, [cancelChooseFile, errorOnUpload, onFileLoad]);
  const cancelUpload = useCallback(() => {
    clearUploadPicker();
    onUploadCancelled();

    // using setTimeout here to allow the UI to update before setting focus
    setTimeout(lastFocus => {
      if (lastFocus) {
        var _document$getElementB;
        (_document$getElementB = document.getElementById(lastFocus)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.focus();
      }
    }, 0, lastFocusedElementId.current);
  }, [clearUploadPicker, onUploadCancelled]);
  const onChooseFileClicked = () => {
    onFileChooserClicked && onFileChooserClicked();
  };
  return /*#__PURE__*/React.createElement(FocusLock, {
    noFocusGuards: true
  }, name && previewImage ? /*#__PURE__*/React.createElement(EmojiUploadPreview, {
    errorMessage: errorMessage,
    name: name,
    onAddEmoji: onAddEmoji,
    onUploadCancelled: cancelUpload,
    previewImage: previewImage,
    uploadStatus: uploadStatus
  }) : /*#__PURE__*/React.createElement(ChooseEmojiFile, {
    name: name,
    onChooseFile: onChooseFile,
    onClick: onChooseFileClicked,
    onNameChange: onNameChange,
    onUploadCancelled: cancelUpload,
    errorMessage: chooseEmojiErrorMessage,
    intl: intl
  }));
};
const EmojiUploadPickerComponent = injectIntl( /*#__PURE__*/memo(EmojiUploadPicker));
export default EmojiUploadPickerComponent;