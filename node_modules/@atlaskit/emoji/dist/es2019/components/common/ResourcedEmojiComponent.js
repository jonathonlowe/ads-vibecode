import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { defaultEmojiHeight } from '../../util/constants';
import { isImageRepresentation, isMediaRepresentation, isPromise } from '../../util/type-helpers';
import { UfoEmojiTimings } from '../../types';
import Emoji from './Emoji';
import EmojiPlaceholder from './EmojiPlaceholder';
import { sampledUfoRenderedEmoji } from '../../util/analytics';
import { EmojiCommonProvider } from '../../context/EmojiCommonProvider';
import { hasUfoMarked } from '../../util/analytics/ufoExperiences';
var ResourcedEmojiComponentRenderStatesEnum = /*#__PURE__*/function (ResourcedEmojiComponentRenderStatesEnum) {
  ResourcedEmojiComponentRenderStatesEnum["INITIAL"] = "INITIAL";
  ResourcedEmojiComponentRenderStatesEnum["FALLBACK"] = "FALLBACK";
  ResourcedEmojiComponentRenderStatesEnum["EMOJI"] = "EMOJI";
  return ResourcedEmojiComponentRenderStatesEnum;
}(ResourcedEmojiComponentRenderStatesEnum || {});
export const ResourcedEmojiComponent = props => {
  const {
    emojiProvider,
    emojiId,
    showTooltip = false,
    customFallback = undefined,
    fitToHeight = defaultEmojiHeight,
    optimistic = false,
    optimisticImageURL = undefined,
    editorEmoji,
    onEmojiLoadSuccess,
    onEmojiLoadFail
  } = props;
  const {
    shortName,
    id,
    fallback
  } = emojiId;
  const [emoji, setEmoji] = useState();
  const [loaded, setLoaded] = useState(false);
  const [imageLoadError, setImageLoadError] = useState(false);
  const [resolvedEmojiProvider, setResolvedEmojiProvider] = useState();
  const fetchOrGetEmoji = useCallback(async (_emojiProvider, emojiId, optimisticFetch = false) => {
    if (!_emojiProvider.fetchByEmojiId) {
      setEmoji(undefined);
      const reason = 'missing fetchByEmojiId interface';
      onEmojiLoadFail && onEmojiLoadFail(emojiId.id, reason);
      sampledUfoRenderedEmoji(emojiId).failure({
        metadata: {
          reason,
          source: 'ResourcedEmojiComponent'
        }
      });
    }
    const foundEmoji = _emojiProvider.fetchByEmojiId(emojiId, optimisticFetch);
    sampledUfoRenderedEmoji(emojiId).mark(UfoEmojiTimings.METADATA_START);
    if (isPromise(foundEmoji)) {
      setLoaded(false);
      foundEmoji.then(emoji => {
        setEmoji(emoji);
        if (!emoji) {
          const reason = 'failed to find';
          onEmojiLoadFail && onEmojiLoadFail(emojiId.id, reason);
          // emoji is undefined
          sampledUfoRenderedEmoji(emojiId).failure({
            metadata: {
              reason,
              source: 'ResourcedEmojiComponent',
              data: {
                emoji: {
                  id: emojiId.id,
                  shortName: emojiId.shortName
                }
              }
            }
          });
        }
      }).catch(() => {
        setEmoji(undefined);
        const reason = 'failed to load';
        onEmojiLoadFail && onEmojiLoadFail(emojiId.id, reason);
        sampledUfoRenderedEmoji(emojiId).failure({
          metadata: {
            reason,
            source: 'ResourcedEmojiComponent',
            data: {
              emoji: {
                id: emojiId.id,
                shortName: emojiId.shortName
              }
            }
          }
        });
      }).finally(() => {
        setLoaded(true);
        sampledUfoRenderedEmoji(emojiId).mark(UfoEmojiTimings.METADATA_END);
      });
    } else {
      setEmoji(foundEmoji);
      setLoaded(true);
      sampledUfoRenderedEmoji(emojiId).mark(UfoEmojiTimings.METADATA_END);
    }
  }, [onEmojiLoadFail]);
  useEffect(() => {
    if (!emojiId) {
      return;
    }
    if (!hasUfoMarked(sampledUfoRenderedEmoji(emojiId), UfoEmojiTimings.FMP_END)) {
      sampledUfoRenderedEmoji(emojiId).markFMP();
    }
  }, [emojiId]);
  useMemo(() => {
    if (!resolvedEmojiProvider || !emojiId) {
      return;
    }
    fetchOrGetEmoji(resolvedEmojiProvider, emojiId, optimistic);
  }, [resolvedEmojiProvider, emojiId, optimistic, fetchOrGetEmoji]);

  /**
   * Setting resolved emoji provider for optimistic rendering
   */
  useEffect(() => {
    Promise.resolve(emojiProvider).then(emojiProvider => {
      setResolvedEmojiProvider(emojiProvider);
    });
  }, [emojiProvider]);
  const emojiRenderState = useMemo(() => {
    if (!emoji && !loaded && !optimisticImageURL) {
      return ResourcedEmojiComponentRenderStatesEnum.INITIAL;
    } else if (!emoji && loaded || imageLoadError) {
      return ResourcedEmojiComponentRenderStatesEnum.FALLBACK;
    }
    return ResourcedEmojiComponentRenderStatesEnum.EMOJI;
  }, [emoji, loaded, optimisticImageURL, imageLoadError]);
  const optimisticEmojiDescription = useMemo(() => {
    if (optimisticImageURL) {
      if (emoji && (isImageRepresentation(emoji.representation) || isMediaRepresentation(emoji === null || emoji === void 0 ? void 0 : emoji.representation))) {
        const {
          width,
          height
        } = emoji.representation;
        return {
          ...emoji,
          representation: {
            width,
            height,
            imagePath: optimisticImageURL
          }
        };
      } else {
        return {
          id,
          shortName,
          fallback,
          type: '',
          category: '',
          representation: {
            height: fitToHeight || defaultEmojiHeight,
            width: fitToHeight || defaultEmojiHeight,
            imagePath: optimisticImageURL
          },
          searchable: true
        };
      }
    }
    return emoji;
  }, [emoji, optimisticImageURL, fallback, fitToHeight, id, shortName]);
  const handleOnLoadError = useCallback(emojiId => {
    setImageLoadError(true);
    const reason = 'load error';
    onEmojiLoadFail && onEmojiLoadFail(emojiId.id, reason);
    sampledUfoRenderedEmoji(emojiId).failure({
      metadata: {
        reason,
        source: 'ResourcedEmojiComponent',
        emojiId: emojiId.id
      }
    });
  }, [onEmojiLoadFail]);
  const handleOnLoadSuccess = useCallback(emojiId => {
    onEmojiLoadSuccess && onEmojiLoadSuccess(emojiId.id);
  }, [onEmojiLoadSuccess]);
  return /*#__PURE__*/React.createElement(EmojiCommonProvider, {
    emojiProvider: resolvedEmojiProvider
  }, /*#__PURE__*/React.createElement("span", {
    "data-emoji-id": id,
    "data-emoji-short-name": shortName,
    "data-emoji-text": fallback || shortName
  }, emojiRenderState === ResourcedEmojiComponentRenderStatesEnum.INITIAL && /*#__PURE__*/React.createElement(EmojiPlaceholder, {
    shortName: shortName,
    showTooltip: showTooltip,
    size: fitToHeight || defaultEmojiHeight,
    loading: true
  }), emojiRenderState === ResourcedEmojiComponentRenderStatesEnum.FALLBACK && /*#__PURE__*/React.createElement(React.Fragment, null, customFallback || fallback || shortName), emojiRenderState === ResourcedEmojiComponentRenderStatesEnum.EMOJI && optimisticEmojiDescription && /*#__PURE__*/React.createElement(Emoji, {
    emoji: optimisticEmojiDescription,
    onLoadError: handleOnLoadError,
    onLoadSuccess: handleOnLoadSuccess,
    showTooltip: showTooltip,
    fitToHeight: fitToHeight,
    autoWidth: !!emoji ? false : true,
    editorEmoji: editorEmoji
  })));
};
export default ResourcedEmojiComponent;