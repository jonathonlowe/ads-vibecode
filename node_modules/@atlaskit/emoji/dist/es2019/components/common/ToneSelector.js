/* ToneSelector.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./ToneSelector.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { memo, useEffect, useMemo, useRef } from 'react';
import { withAnalyticsEvents } from '@atlaskit/analytics-next';
import { createAndFireEventInElementsChannel, toneSelectedEvent, toneSelectorOpenedEvent } from '../../util/analytics';
import { setSkinToneAriaLabelText } from './setSkinToneAriaLabelText';
import EmojiRadioButton from './EmojiRadioButton';
import { useIntl } from 'react-intl-next';
import { messages } from '../i18n';
const hidden = null;
export const toneSelectorTestId = 'tone-selector';
const extractAllTones = emoji => {
  if (emoji.skinVariations) {
    return [emoji, ...emoji.skinVariations];
  }
  return [emoji];
};
export const ToneSelectorInternal = props => {
  const {
    createAnalyticsEvent,
    emoji,
    onToneSelected,
    onToneClose,
    selectedTone,
    isVisible
  } = props;
  const isMounted = useRef(false);
  const selectedToneRadioRef = useRef(null);
  const {
    formatMessage
  } = useIntl();
  const emojiToneCollection = useMemo(() => {
    var selectedToneIndex = -1;
    const toneColletion = extractAllTones(emoji).map((tone, index) => {
      const isSelected = index === selectedTone;
      if (isSelected) {
        selectedToneIndex = index;
      }
      return {
        ...tone,
        isSelected: isSelected,
        label: setSkinToneAriaLabelText(tone.name),
        toneIndex: index
      };
    });

    // push description of selected tone to the end of the array
    // so that it gets rendered last/rightmost
    toneColletion.push(toneColletion.splice(selectedToneIndex, 1)[0]);
    return toneColletion;
  }, [emoji, selectedTone]);
  useEffect(() => {
    if (isVisible) {
      var _selectedToneRadioRef;
      (_selectedToneRadioRef = selectedToneRadioRef.current) === null || _selectedToneRadioRef === void 0 ? void 0 : _selectedToneRadioRef.focus();
    }
  }, [isVisible, selectedToneRadioRef]);
  const fireAnalyticsEvent = event => {
    if (createAnalyticsEvent) {
      createAndFireEventInElementsChannel(event)(createAnalyticsEvent);
    }
  };
  const onToneSelectedHandler = toneValue => () => {
    if (selectedTone === toneValue && onToneClose) {
      onToneClose();
      return;
    }
    onToneSelected(toneValue);
    const toneList = ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'];
    fireAnalyticsEvent(toneSelectedEvent({
      skinToneModifier: toneList[toneValue]
    }));
  };
  if (!isMounted.current) {
    fireAnalyticsEvent(toneSelectorOpenedEvent({}));
  }
  isMounted.current = true;
  return /*#__PURE__*/React.createElement("div", {
    role: "radiogroup",
    "data-testid": toneSelectorTestId,
    id: "emoji-picker-tone-selector",
    "aria-label": formatMessage(messages.emojiSelectSkinToneListAriaLabelText),
    className: ax([!isVisible && "_tzy4idpf _3um015vq _1e0cglyw"])
  }, emojiToneCollection.map(tone => {
    return /*#__PURE__*/React.createElement(EmojiRadioButton, {
      ref: tone.isSelected ? selectedToneRadioRef : null,
      defaultChecked: tone.isSelected,
      ariaLabelText: tone.label,
      key: `${tone.id}`,
      emoji: tone,
      onSelected: onToneSelectedHandler(tone.toneIndex),
      selectOnHover: true
    });
  }));
};
const ToneSelector = withAnalyticsEvents()(ToneSelectorInternal);
export default /*#__PURE__*/memo(ToneSelector);