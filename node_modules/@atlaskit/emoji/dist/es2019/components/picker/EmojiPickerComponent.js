/* EmojiPickerComponent.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./EmojiPickerComponent.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { useCallback, useEffect, useMemo, useRef, useState, createRef, memo } from 'react';
import { N40 } from '@atlaskit/theme/colors';
import { unstable_batchedUpdates as batchedUpdates } from 'react-dom';
import { FormattedMessage, useIntl } from 'react-intl-next';
import { getEmojiVariation } from '../../api/EmojiRepository';
import { supportsUploadFeature } from '../../api/EmojiResource';
import { KeyboardKeys, customCategory, defaultEmojiPickerSize, frequentCategory } from '../../util/constants';
import { containsEmojiId, isPromise /*, isEmojiIdEqual, isEmojiLoaded*/, isEmojiDescription } from '../../util/type-helpers';
import { SearchSort, SearchSourceTypes } from '../../types';
import { getToneEmoji } from '../../util/filters';
import { uploadEmoji } from '../common/UploadEmoji';
import { createRecordSelectionDefault } from '../common/RecordSelectionDefault';
import CategorySelector from './CategorySelector';
import EmojiPickerFooter from './EmojiPickerFooter';
import { EmojiPickerVirtualListInternalOld as EmojiPickerListOld, EmojiPickerVirtualListInternalNew as EmojiPickerListNew } from './EmojiPickerList';
import { createAndFireEventInElementsChannel, categoryClickedEvent, closedPickerEvent, deleteBeginEvent, deleteCancelEvent, deleteConfirmEvent, openedPickerEvent, pickerClickedEvent, pickerSearchedEvent, selectedFileEvent, uploadBeginButton, uploadCancelButton, uploadConfirmButton, toneSelectorClosedEvent, ufoExperiences } from '../../util/analytics';
import { useEmoji } from '../../hooks/useEmoji';
import { useIsMounted } from '../../hooks/useIsMounted';
import { messages } from '../i18n';
import { fg } from '@atlaskit/platform-feature-flags';
const emojiPickerBoxShadow = "var(--ds-shadow-overlay, 0 3px 6px rgba(0, 0, 0, 0.2))";
const emojiPickerHeight = 295;
const emojiPickerHeightWithPreview = 349; // emojiPickerHeight + emojiPickerPreviewHeight;
const emojiPickerWidth = 350;
const emojiPickerMinHeight = 260;
const heightOffset = 80;
const emojiPicker = null;
const withPreviewHeight = {
  small: "_4t3ivixp _1tkegx0z",
  medium: "_4t3i2300 _1tke5x59",
  large: "_4t3ixt2k _1tke1pna"
};
const withoutPreviewHeight = {
  small: "_4t3iaq3k _1tkegx0z",
  medium: "_4t3iixjv _1tke5x59",
  large: "_4t3i1ckg _1tke1pna"
};
const FREQUENTLY_USED_MAX = 16;
const EmojiPickerComponent = ({
  onSelection,
  onPickerRef,
  hideToneSelector,
  createAnalyticsEvent,
  size = defaultEmojiPickerSize
}) => {
  const {
    formatMessage
  } = useIntl();
  const {
    emojiProvider,
    isUploadSupported
  } = useEmoji();
  const [filteredEmojis, setFilteredEmojis] = useState([]);
  const [searchEmojis, setSearchEmojis] = useState([]);
  const [frequentlyUsedEmojis, setFrequentlyUsedEmojis] = useState([]);
  const [query, setQuery] = useState('');
  const [dynamicCategories, setDynamicCategories] = useState([]);
  const [selectedTone, setSelectedTone] = useState(!hideToneSelector ? emojiProvider.getSelectedTone() : undefined);
  const [loading, setLoading] = useState(true);
  const [uploading, setUploading] = useState(false);
  const [selectedEmoji, setSelectedEmoji] = useState();
  const [activeCategory, setActiveCategory] = useState(null);
  const [disableCategories, setDisableCategories] = useState(false);
  const [uploadErrorMessage, setUploadErrorMessage] = useState();
  const [emojiToDelete, setEmojiToDelete] = useState();
  const [toneEmoji, setToneEmoji] = useState();
  const emojiPickerList = useMemo(() => fg('platform_editor_react18_elements_emoji') || fg('platform_editor_react18_elements_emoji_jira_bb') ? /*#__PURE__*/createRef() : /*#__PURE__*/createRef(), []);
  const openTime = useRef(0);
  const isMounting = useRef(true);
  const previousEmojiProvider = useRef(emojiProvider);
  const currentUser = useMemo(() => {
    return emojiProvider.getCurrentUser();
  }, [emojiProvider]);
  const isMounted = useIsMounted();
  const fireAnalytics = useCallback(analyticsEvent => {
    if (createAnalyticsEvent) {
      createAndFireEventInElementsChannel(analyticsEvent)(createAnalyticsEvent);
    }
  }, [createAnalyticsEvent]);
  const onEmojiActive = useCallback((emojiId, emoji) => {
    if (!selectedEmoji || selectedEmoji.id !== (emojiId === null || emojiId === void 0 ? void 0 : emojiId.id)) {
      setSelectedEmoji(emoji);
    }
  }, [selectedEmoji]);
  const onCategoryActivated = useCallback(category => {
    if (activeCategory !== category) {
      setActiveCategory(category);
    }
  }, [activeCategory]);
  const calculateElapsedTime = () => {
    return Date.now() - openTime.current;
  };
  const onDynamicCategoryChange = useCallback(categories => {
    setDynamicCategories(categories);
  }, []);
  const onUploadCancelled = useCallback(() => {
    batchedUpdates(() => {
      setUploading(false);
      setUploadErrorMessage(undefined);
    });
    fireAnalytics(uploadCancelButton());
  }, [fireAnalytics]);
  const getDynamicCategories = useCallback(() => {
    if (!emojiProvider.calculateDynamicCategories) {
      return Promise.resolve([]);
    }
    return emojiProvider.calculateDynamicCategories();
  }, [emojiProvider]);

  /**
   * Calculate and set the new state of the component in response to the list of emoji changing for some reason (a search has returned
   * or the frequently used emoji have updated.)
   */
  const setStateAfterEmojiChange = useCallback(({
    searchQuery,
    emojiToRender,
    searchEmoji,
    frequentEmoji
  }) => {
    // Only enable categories for full emoji list (non-search)
    const disableCategories = !!searchQuery;
    if (!disableCategories && emojiToRender && emojiToRender.length !== filteredEmojis.length) {
      getDynamicCategories().then(categories => {
        onDynamicCategoryChange(categories);
      });
    }
    if (emojiToRender && !containsEmojiId(emojiToRender, selectedEmoji)) {
      batchedUpdates(() => {
        setSelectedEmoji(undefined);
      });
    }
    batchedUpdates(() => {
      if (emojiToRender) {
        setFilteredEmojis(emojiToRender);
      }
      if (searchEmoji) {
        setSearchEmojis(searchEmoji);
      }
      if (frequentEmoji) {
        setFrequentlyUsedEmojis(frequentEmoji);
      }
      setLoading(false);
      setDisableCategories(disableCategories);
    });
  }, [filteredEmojis.length, getDynamicCategories, onDynamicCategoryChange, selectedEmoji]);
  const onFrequentEmojiResult = useCallback(frequentEmoji => {
    // change the category of each of the featured emoji
    const recategorised = frequentEmoji.map(emoji => {
      const clone = JSON.parse(JSON.stringify(emoji));
      clone.category = frequentCategory;
      return clone;
    });
    setStateAfterEmojiChange({
      frequentEmoji: recategorised
    });
  }, [setStateAfterEmojiChange]);
  const onSearchResult = useCallback(searchResults => {
    const frequentlyUsedEmoji = frequentlyUsedEmojis || [];
    const searchQuery = searchResults.query || '';

    /**
     * If there is no user search in the EmojiPicker then it should display all emoji received from the EmojiRepository and should
     * also include a special category of most frequently used emoji (if there are any). This method decides if we are in this 'no search'
     * state and appends the frequent emoji if necessary.
     */
    let emojiToRender;
    if (!frequentlyUsedEmoji.length || query) {
      emojiToRender = searchResults.emojis;
    } else {
      emojiToRender = [...searchResults.emojis, ...frequentlyUsedEmoji];
    }
    setStateAfterEmojiChange({
      searchQuery,
      emojiToRender,
      searchEmoji: searchResults.emojis
    });
    fireAnalytics(pickerSearchedEvent({
      queryLength: searchQuery.length,
      numMatches: searchResults.emojis.length
    }));
  }, [frequentlyUsedEmojis, query, setStateAfterEmojiChange, fireAnalytics]);
  const onProviderChange = useMemo(() => {
    return {
      result: onSearchResult
    };
  }, [onSearchResult]);

  /**
   * Updates the emoji displayed by the picker. If there is no query specified then we expect to retrieve all emoji for display,
   * by category, in the picker. This differs from when there is a query in which case we expect to receive a sorted result matching
   * the search.
   */
  const updateEmojis = useCallback((query, options) => {
    // if the query is empty then we want the emoji to be in service defined order, unless specified otherwise
    // and we want emoji for the 'frequently used' category to be refreshed as well.
    if (!query) {
      if (!options) {
        options = {};
      }
      if (!options.sort) {
        options.sort = SearchSort.None;
      }

      // take a copy of search options so that the frequently used can be limited to 16 without affecting the full emoji query
      const frequentOptions = {
        ...options,
        sort: SearchSort.None,
        limit: FREQUENTLY_USED_MAX
      };
      emojiProvider.getFrequentlyUsed(frequentOptions).then(onFrequentEmojiResult);
    }
    emojiProvider.filter(query, options);
  }, [emojiProvider, onFrequentEmojiResult]);
  const onToneSelected = useCallback(toneValue => {
    emojiProvider.setSelectedTone(toneValue);
    updateEmojis(query, {
      skinTone: toneValue
    });
    setSelectedTone(toneValue);
  }, [emojiProvider, query, updateEmojis]);
  const onToneSelectorCancelled = useCallback(() => {
    fireAnalytics(toneSelectorClosedEvent());
  }, [fireAnalytics]);
  const onSelectWrapper = useCallback((emojiId, emoji, event) => {
    if (onSelection) {
      onSelection(emojiId, emoji, event);
      fireAnalytics(pickerClickedEvent({
        duration: calculateElapsedTime(),
        emojiId: (emojiId === null || emojiId === void 0 ? void 0 : emojiId.id) || '',
        category: emoji && emoji.category || '',
        type: emoji && emoji.type || '',
        queryLength: query && query.length || 0
      }));
    }
  }, [fireAnalytics, onSelection, query]);
  const onCategorySelected = useCallback(categoryId => {
    if (!categoryId) {
      return;
    }
    emojiProvider.findInCategory(categoryId).then(emojisInCategory => {
      if (!disableCategories) {
        let newSelectedEmoji;
        if (emojisInCategory && emojisInCategory.length > 0) {
          newSelectedEmoji = getEmojiVariation(emojisInCategory[0], {
            skinTone: selectedTone
          });
        }
        if (emojiPickerList.current) {
          emojiPickerList.current.reveal(categoryId);
        }
        batchedUpdates(() => {
          setActiveCategory(categoryId);
          setSelectedEmoji(newSelectedEmoji);
        });
        fireAnalytics(categoryClickedEvent({
          category: categoryId
        }));
      }
    });
  }, [disableCategories, emojiPickerList, emojiProvider, fireAnalytics, selectedTone]);
  const recordUsageOnSelection = useMemo(() => createRecordSelectionDefault(emojiProvider, onSelectWrapper, analytic => fireAnalytics(analytic(SearchSourceTypes.PICKER))), [emojiProvider, fireAnalytics, onSelectWrapper]);
  const formattedErrorMessage = useMemo(() => uploadErrorMessage ? /*#__PURE__*/React.createElement(FormattedMessage, uploadErrorMessage) : null, [uploadErrorMessage]);
  const onFileChooserClicked = useCallback(() => {
    fireAnalytics(selectedFileEvent());
  }, [fireAnalytics]);
  const scrollToTopOfList = useCallback(() => {
    var _emojiPickerList$curr;
    (_emojiPickerList$curr = emojiPickerList.current) === null || _emojiPickerList$curr === void 0 ? void 0 : _emojiPickerList$curr.scrollToTop();
  }, [emojiPickerList]);
  const onSearch = useCallback(searchQuery => {
    const options = {
      skinTone: selectedTone,
      source: SearchSourceTypes.PICKER
    };
    if (searchQuery !== query) {
      setQuery(searchQuery);
    }
    updateEmojis(searchQuery, options);
    if (filteredEmojis.length > 0) {
      // scroll to top when search, which is search results section
      scrollToTopOfList();
    }
  }, [query, filteredEmojis, selectedTone, updateEmojis, scrollToTopOfList]);
  const onOpenUpload = useCallback(() => {
    // Prime upload token so it's ready when the user adds
    if (supportsUploadFeature(emojiProvider)) {
      emojiProvider.prepareForUpload();
    }
    batchedUpdates(() => {
      setUploadErrorMessage(undefined);
      setUploading(true);
    });
    fireAnalytics(uploadBeginButton());
  }, [emojiProvider, fireAnalytics]);
  const scrollToUploadedEmoji = useCallback(emojiDescription => {
    if (emojiPickerList.current) {
      // Wait a tick to ensure repaint and updated height for picker list
      window.setTimeout(() => {
        var _emojiPickerList$curr2;
        (_emojiPickerList$curr2 = emojiPickerList.current) === null || _emojiPickerList$curr2 === void 0 ? void 0 : _emojiPickerList$curr2.scrollToRecentlyUploaded(emojiDescription);
      }, 0);
    }
  }, [emojiPickerList]);
  const onUploadEmoji = useCallback((upload, retry) => {
    fireAnalytics(uploadConfirmButton({
      retry
    }));
    const errorSetter = message => {
      setUploadErrorMessage(message);
    };
    const onSuccess = emojiDescription => {
      batchedUpdates(() => {
        setActiveCategory(customCategory);
        setSelectedEmoji(emojiDescription);
        setUploading(false);
      });
      scrollToUploadedEmoji(emojiDescription);
    };
    uploadEmoji(upload, emojiProvider, errorSetter, onSuccess, fireAnalytics, retry);
  }, [emojiProvider, fireAnalytics, scrollToUploadedEmoji]);
  const onTriggerDelete = useCallback((_emojiId, emoji) => {
    if (_emojiId) {
      fireAnalytics(deleteBeginEvent({
        emojiId: _emojiId.id
      }));
      setEmojiToDelete(emoji);
    }
  }, [fireAnalytics]);
  const onCloseDelete = useCallback(() => {
    fireAnalytics(deleteCancelEvent({
      emojiId: emojiToDelete && emojiToDelete.id
    }));
    setEmojiToDelete(undefined);
  }, [emojiToDelete, fireAnalytics]);
  const onDeleteEmoji = useCallback(emoji => {
    fireAnalytics(deleteConfirmEvent({
      emojiId: emojiToDelete && emojiToDelete.id
    }));
    return emojiProvider.deleteSiteEmoji(emoji).then(success => {
      if (success) {
        updateEmojis(query, {
          skinTone: selectedTone
        });
      }
      return success;
    });
  }, [emojiProvider, emojiToDelete, fireAnalytics, query, selectedTone, updateEmojis]);
  const onComponentDidMount = useCallback(() => {
    emojiProvider.subscribe(onProviderChange);
    onSearch(query);
    if (!hideToneSelector) {
      const toneEmoji = getToneEmoji(emojiProvider);
      if (isPromise(toneEmoji)) {
        toneEmoji.then(emoji => setToneEmoji(emoji));
      } else if (toneEmoji === undefined || isEmojiDescription(toneEmoji)) {
        setToneEmoji(toneEmoji);
      }
    }
  }, [emojiProvider, hideToneSelector, onProviderChange, onSearch, query]);
  if (isMounting.current) {
    // componentWillMount equivalent
    ufoExperiences['emoji-picker-opened'].success();
    openTime.current = Date.now();
    fireAnalytics(openedPickerEvent());
    isMounting.current = false;
  }

  // stop all key propagation to other event listeners
  const suppressKeyPress = e => {
    e.stopPropagation();
    // We prevent default for enter keypresses
    // since products like Bitbucket might have parent forms
    // that listen for keydown events to trigger form submission
    // https://product-fabric.atlassian.net/browse/ED-19532
    if (e.key === KeyboardKeys.Enter) {
      e.preventDefault();
    }
  };
  useEffect(() => {
    // componentDidMount logic
    if (!isMounted) {
      onComponentDidMount();
    }
  }, [onComponentDidMount, isMounted]);
  useEffect(() => {
    previousEmojiProvider.current.unsubscribe(onProviderChange);
    previousEmojiProvider.current = emojiProvider;
    emojiProvider.subscribe(onProviderChange);
    return () => {
      emojiProvider.unsubscribe(onProviderChange);
    };
  }, [emojiProvider, onProviderChange]);
  useEffect(() => {
    if (!frequentlyUsedEmojis.length || query) {
      setFilteredEmojis(searchEmojis);
    } else {
      setFilteredEmojis([...searchEmojis, ...frequentlyUsedEmojis]);
    }
  }, [frequentlyUsedEmojis, query, searchEmojis]);
  useEffect(() => {
    // Fire analytics on component unmount
    return () => {
      fireAnalytics(closedPickerEvent({
        duration: calculateElapsedTime()
      }));
      ufoExperiences['emoji-picker-opened'].abort({
        metadata: {
          source: 'EmojiPickerComponent',
          reason: 'unmount'
        }
      });
      ufoExperiences['emoji-searched'].abort({
        metadata: {
          source: 'EmojiPickerComponent',
          reason: 'unmount'
        }
      });
    };
  }, [fireAnalytics]);
  useEffect(() => {
    // Unsubscribe emojiProvider on component unmount
    return () => {
      emojiProvider.unsubscribe(onProviderChange);
    };
  }, [emojiProvider, onProviderChange]);
  const showPreview = selectedEmoji && !uploading;
  return /*#__PURE__*/React.createElement("div", {
    ref: onPickerRef,
    "data-emoji-picker-container": true,
    role: "dialog",
    "aria-label": formatMessage(messages.emojiPickerTitle),
    "aria-modal": true,
    onKeyPress: suppressKeyPress,
    onKeyUp: suppressKeyPress,
    onKeyDown: suppressKeyPress,
    className: ax(["_19itcyqh _2rkosqtm _1e0c1txw _2lx21bp4 _1bah1yb4 _bfhk1bhr _16qsp2xt _4t3iaq3k _1bsb1edt _1ul91edt _c71l1y6z", showPreview && withPreviewHeight[size], !showPreview && withoutPreviewHeight[size]])
  }, /*#__PURE__*/React.createElement(CategorySelector, {
    activeCategoryId: activeCategory,
    dynamicCategories: dynamicCategories,
    disableCategories: disableCategories,
    onCategorySelected: onCategorySelected
  }), fg('platform_editor_react18_elements_emoji') || fg('platform_editor_react18_elements_emoji_jira_bb') ? /*#__PURE__*/React.createElement(EmojiPickerListNew, {
    emojis: filteredEmojis,
    currentUser: currentUser,
    onEmojiSelected: recordUsageOnSelection,
    onEmojiActive: onEmojiActive,
    onEmojiDelete: onTriggerDelete,
    onCategoryActivated: onCategoryActivated,
    onSearch: onSearch,
    query: query,
    selectedTone: selectedTone,
    loading: loading,
    ref: emojiPickerList,
    initialUploadName: query,
    onToneSelected: onToneSelected,
    onToneSelectorCancelled: onToneSelectorCancelled,
    toneEmoji: toneEmoji,
    uploading: uploading,
    emojiToDelete: emojiToDelete,
    uploadErrorMessage: formattedErrorMessage,
    uploadEnabled: isUploadSupported && !uploading,
    onUploadEmoji: onUploadEmoji,
    onUploadCancelled: onUploadCancelled,
    onDeleteEmoji: onDeleteEmoji,
    onCloseDelete: onCloseDelete,
    onFileChooserClicked: onFileChooserClicked,
    onOpenUpload: onOpenUpload,
    size: size,
    activeCategoryId: activeCategory
  }) : /*#__PURE__*/React.createElement(EmojiPickerListOld, {
    emojis: filteredEmojis,
    currentUser: currentUser,
    onEmojiSelected: recordUsageOnSelection,
    onEmojiActive: onEmojiActive,
    onEmojiDelete: onTriggerDelete,
    onCategoryActivated: onCategoryActivated,
    onSearch: onSearch,
    query: query,
    selectedTone: selectedTone,
    loading: loading,
    ref: emojiPickerList,
    initialUploadName: query,
    onToneSelected: onToneSelected,
    onToneSelectorCancelled: onToneSelectorCancelled,
    toneEmoji: toneEmoji,
    uploading: uploading,
    emojiToDelete: emojiToDelete,
    uploadErrorMessage: formattedErrorMessage,
    uploadEnabled: isUploadSupported && !uploading,
    onUploadEmoji: onUploadEmoji,
    onUploadCancelled: onUploadCancelled,
    onDeleteEmoji: onDeleteEmoji,
    onCloseDelete: onCloseDelete,
    onFileChooserClicked: onFileChooserClicked,
    onOpenUpload: onOpenUpload,
    size: size,
    activeCategoryId: activeCategory
  }), showPreview && /*#__PURE__*/React.createElement(EmojiPickerFooter, {
    selectedEmoji: selectedEmoji
  }));
};
export default /*#__PURE__*/memo(EmojiPickerComponent);