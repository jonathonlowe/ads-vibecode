/* VirtualList.tsx generated by @compiled/babel-plugin v0.36.1 */
import "./VirtualList.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
import React, { useCallback, useImperativeHandle } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import { useEmojiPickerListContext } from '../../hooks/useEmojiPickerListContext';
import { EMOJIPICKERLIST_KEYBOARD_KEYS_SUPPORTED, EMOJI_LIST_COLUMNS, EMOJI_LIST_PAGE_COUNT, KeyboardNavigationDirection, KeyboardKeys } from '../../util/constants';
const virtualList = null;
const virtualRowStyle = null;
export const virtualListScrollContainerTestId = 'virtual-list-scroll-container';
export const VirtualList = /*#__PURE__*/React.forwardRef((props, ref) => {
  const parentRef = React.useRef(null);
  const virtualistItemsRef = React.useRef(null);
  const {
    rowRenderer,
    onRowsRendered,
    scrollToAlignment,
    width,
    height,
    rowCount
  } = props;
  const {
    currentEmojisFocus,
    setEmojisFocus
  } = useEmojiPickerListContext();
  const getVirtualizerOptions = () => {
    const {
      rowCount,
      rowHeight,
      overscanRowCount
    } = props;
    return {
      count: rowCount,
      getScrollElement: () => parentRef.current,
      estimateSize: rowHeight,
      overscan: overscanRowCount,
      onChange: () => {
        const startIndex = getFirstVisibleListElementIndex();
        onRowsRendered({
          startIndex
        });
      },
      scrollPaddingStart: 28,
      scrollPaddingEnd: 28
    };
  };
  const rowVirtualizer = useVirtualizer(getVirtualizerOptions());
  const isElementVisible = element => {
    const parent = parentRef.current;
    const elementRect = element.getBoundingClientRect();
    const parentRect = parent.getBoundingClientRect();
    const elemTop = elementRect.top;
    const elemBottom = elementRect.bottom;
    const parentTop = parentRect.top;
    const parentBottom = parentRect.bottom;

    // Only completely visible elements return true:
    const isVisible = elemTop >= parentTop && elemBottom <= parentBottom;
    return isVisible;
  };
  const getFirstVisibleListElementIndex = useCallback(() => {
    var _parentRef$current, _parentRef$current$fi;
    const virtualList = rowVirtualizer.getVirtualItems();
    const renderedElements = (_parentRef$current = parentRef.current) === null || _parentRef$current === void 0 ? void 0 : (_parentRef$current$fi = _parentRef$current.firstChild) === null || _parentRef$current$fi === void 0 ? void 0 : _parentRef$current$fi.childNodes;
    if (virtualList.length === 0 || !renderedElements || renderedElements.length === 0) {
      return 0;
    }
    // Convert NodeListOf<ChildNodes> to ChildNodes[]
    const renderedElementsToArray = Array.from(renderedElements);
    const firstVisibleIndex = renderedElementsToArray.findIndex(elem => isElementVisible(elem));
    if (firstVisibleIndex !== -1) {
      var _virtualList$firstVis;
      return ((_virtualList$firstVis = virtualList[firstVisibleIndex]) === null || _virtualList$firstVis === void 0 ? void 0 : _virtualList$firstVis.index) || 0;
    }
    return 0;
  }, [rowVirtualizer]);

  /**
   * Recurisive function to find next available emoji and it's focus indexes in the grid
   *
   * current focus element is at rowIndex.columnIndex
   * if found element then return the element and focus indexes
   * otherwise change row/column till find the element
   * if can't find the element till reach the edge of grid, we keep current focus states
   *
   * @param rowIndex search from row index (0 based)
   * @param columnIndex search from column index (0 based)
   * @param direction search direction
   */
  const findNextEmoji = useCallback((rowIndex, columnIndex, direction) => {
    var _virtualistItemsRef$c;
    const emojiToFocus = (_virtualistItemsRef$c = virtualistItemsRef.current) === null || _virtualistItemsRef$c === void 0 ? void 0 : _virtualistItemsRef$c.querySelector(`[data-focus-index="${rowIndex}-${columnIndex}"]`);
    const lastRowIndex = rowCount - 1;
    const lastColumnIndex = EMOJI_LIST_COLUMNS - 1;
    if (emojiToFocus) {
      return {
        element: emojiToFocus,
        rowIndex,
        columnIndex
      };
    }
    switch (direction) {
      case KeyboardNavigationDirection.Down:
        if (rowIndex >= lastRowIndex) {
          return null;
        }
        // find emoji in same column but lower row
        return findNextEmoji(rowIndex + 1, columnIndex, KeyboardNavigationDirection.Down);
      case KeyboardNavigationDirection.Up:
        if (rowIndex <= 0) {
          return null;
        }
        // find emoji in same column but upper row
        return findNextEmoji(rowIndex - 1, columnIndex, KeyboardNavigationDirection.Up);
      case KeyboardNavigationDirection.Left:
        if (rowIndex <= 0) {
          return null;
        }
        if (columnIndex < 0) {
          // find emoji in upper row
          return findNextEmoji(rowIndex - 1, lastColumnIndex, KeyboardNavigationDirection.Left);
        }
        // find emoji on left in the current row
        return findNextEmoji(rowIndex, columnIndex - 1, KeyboardNavigationDirection.Left);
      case KeyboardNavigationDirection.Right:
        if (rowIndex >= lastRowIndex) {
          return null;
        }
        // if no emoji on right, we try first emoji in next row
        return findNextEmoji(rowIndex + 1, 0, KeyboardNavigationDirection.Right);
      default:
        return null;
    }
  }, [rowCount]);

  /**
   * Find the valid emoji to scroll and focus
   */
  const scrollToRowAndFocusEmoji = useCallback(emojiToFocus => {
    if (emojiToFocus) {
      var _emojiToFocus$element;
      rowVirtualizer.scrollToIndex(emojiToFocus.rowIndex);
      (_emojiToFocus$element = emojiToFocus.element) === null || _emojiToFocus$element === void 0 ? void 0 : _emojiToFocus$element.focus({
        preventScroll: true
      });
      setEmojisFocus({
        rowIndex: emojiToFocus.rowIndex,
        columnIndex: emojiToFocus.columnIndex
      });
    }
  }, [rowVirtualizer, setEmojisFocus]);
  const focusEmoji = useCallback((rIndex, cIndex, direction, waitForScrollFinish = false) => {
    if (waitForScrollFinish) {
      // scroll to target rowIndex first to ensure the row is rendered in list.
      // used in page up/down, ctrl+Home, ctrl+End
      rowVirtualizer.scrollToIndex(rIndex);
      setTimeout(() => {
        const emojiToFocus = findNextEmoji(rIndex, cIndex, direction);
        scrollToRowAndFocusEmoji(emojiToFocus);
      }, 100); // 100ms is virtual list scrolling time
    } else {
      const emojiToFocus = findNextEmoji(rIndex, cIndex, direction);
      scrollToRowAndFocusEmoji(emojiToFocus);
    }
  }, [scrollToRowAndFocusEmoji, findNextEmoji, rowVirtualizer]);

  // following the guide from https://www.w3.org/WAI/ARIA/apg/patterns/grid/
  const handleKeyDown = e => {
    if (!EMOJIPICKERLIST_KEYBOARD_KEYS_SUPPORTED.includes(e.key)) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const lastRowIndex = rowCount - 1;
    const lastColumnIndex = EMOJI_LIST_COLUMNS - 1;

    // focus first emoji on first row
    if (e.key === KeyboardKeys.Home && e.ctrlKey) {
      focusEmoji(1, 0, KeyboardNavigationDirection.Up, true);
      return;
    } else if (e.key === KeyboardKeys.End && e.ctrlKey) {
      // focus last available emoji on last row
      focusEmoji(lastRowIndex, lastColumnIndex, KeyboardNavigationDirection.Left, true);
      return;
    }
    switch (e.key) {
      // navigate to the right column
      case KeyboardKeys.ArrowRight:
        focusEmoji(currentEmojisFocus.rowIndex, currentEmojisFocus.columnIndex + 1, KeyboardNavigationDirection.Right);
        break;
      // navigate to the left column
      case KeyboardKeys.ArrowLeft:
        focusEmoji(currentEmojisFocus.rowIndex, currentEmojisFocus.columnIndex - 1, KeyboardNavigationDirection.Left);
        break;
      // navigate to the down row
      case KeyboardKeys.ArrowDown:
        focusEmoji(currentEmojisFocus.rowIndex === lastRowIndex ? lastRowIndex : currentEmojisFocus.rowIndex + 1, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Down);
        break;
      // navigate to the row after {EMOJI_LIST_PAGE_COUNT} rows
      case KeyboardKeys.PageDown:
        focusEmoji(currentEmojisFocus.rowIndex + EMOJI_LIST_PAGE_COUNT, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Down, true);
        break;
      // navigate to the up row
      case KeyboardKeys.ArrowUp:
        focusEmoji(currentEmojisFocus.rowIndex <= 1 ? 1 : currentEmojisFocus.rowIndex - 1, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Up);
        break;
      // navigate to the row before {EMOJI_LIST_PAGE_COUNT} rows
      case KeyboardKeys.PageUp:
        focusEmoji(currentEmojisFocus.rowIndex - EMOJI_LIST_PAGE_COUNT, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Up, true);
        break;
      // navigate to the first cell of current row
      case KeyboardKeys.Home:
        focusEmoji(currentEmojisFocus.rowIndex, 0, KeyboardNavigationDirection.Left);
        break;
      // navigate to the last cell of current row
      case KeyboardKeys.End:
        focusEmoji(currentEmojisFocus.rowIndex, lastColumnIndex, KeyboardNavigationDirection.Left);
        break;
    }
  };

  // Exposing a custom ref handle to the parent component EmojiPickerList to trigger scrollToRow via the listRef
  // https://beta.reactjs.org/reference/react/useImperativeHandle
  useImperativeHandle(ref, () => {
    return {
      scrollToRow(index) {
        if (index !== undefined) {
          rowVirtualizer.setOptions({
            ...rowVirtualizer.options,
            scrollPaddingStart: 0
          });
          rowVirtualizer.scrollToIndex(index, {
            align: scrollToAlignment
          });
        }
      },
      scrollToRowAndFocusLastEmoji(index) {
        if (index !== undefined) {
          focusEmoji(index, EMOJI_LIST_COLUMNS, KeyboardNavigationDirection.Left, true);
        }
      },
      scrollToEmojiAndFocus(rowIndex, columnIndex) {
        focusEmoji(rowIndex, columnIndex, KeyboardNavigationDirection.Left, true);
      },
      updateFocusIndex(rowIndex, columnIndex = 0) {
        var _virtualistItemsRef$c2;
        // row could be removed from virtual list after scrolling, we'll update emoji cell tabIndex after losing focus
        if (!((_virtualistItemsRef$c2 = virtualistItemsRef.current) !== null && _virtualistItemsRef$c2 !== void 0 && _virtualistItemsRef$c2.contains(document.activeElement))) {
          setEmojisFocus({
            rowIndex,
            columnIndex
          });
        }
      }
    };
  }, [setEmojisFocus, focusEmoji, rowVirtualizer, scrollToAlignment]);
  return /*#__PURE__*/React.createElement("div", {
    ref: parentRef,
    style: {
      height: `${height}px`,
      width: `${width}px`
    },
    "data-testid": virtualListScrollContainerTestId,
    "aria-labelledby": "emoji-picker-table-description",
    role: "grid",
    className: ax(["_1reo15vq _18m91wug _n3tdu2gc _nt751r31 _49pcglyw _1hvw1o36"])
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: `${rowVirtualizer.getTotalSize()}px`,
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      width: '100%',
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      position: 'relative'
    },
    ref: virtualistItemsRef,
    onKeyDown: handleKeyDown,
    role: "presentation"
  }, rowVirtualizer.getVirtualItems().map((virtualRow, index) => /*#__PURE__*/React.createElement("div", {
    key: virtualRow.key,
    style: {
      height: `${virtualRow.size}px`,
      transform: `translateY(${virtualRow.start}px)`
    },
    role: "row",
    "aria-rowindex": index + 1,
    className: ax(["_kqswstnw _154iidpf _1ltvidpf _1bsb1osq"])
  }, rowRenderer(virtualRow)))));
});