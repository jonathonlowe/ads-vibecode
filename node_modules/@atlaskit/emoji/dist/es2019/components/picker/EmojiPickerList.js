import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { createRef, PureComponent, useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';
import { customCategory, defaultEmojiPickerSize, frequentCategory, searchCategory, userCustomTitle, yourUploadsCategory } from '../../util/constants';
import { CategoryDescriptionMap } from './categories';
import CategoryTracker from './CategoryTracker';
import { sizes } from './EmojiPickerSizes';
import { CategoryHeadingItem, EmojisRowItem, LoadingItem, virtualItemRenderer } from './EmojiPickerVirtualItems';
import EmojiActions from '../common/EmojiActions';
import { emojiPickerHeightOffset, scrollToRow } from './utils';
import { VirtualList } from './VirtualList';
import { EmojiPickerListContextProvider } from '../../context/EmojiPickerListContext';
import EmojiPickerTabPanel from './EmojiPickerTabPanel';

/**
 * Test id for wrapper Emoji Picker List div
 */
export const RENDER_EMOJI_PICKER_LIST_TESTID = 'render-emoji-picker-list';
const categoryClassname = 'emoji-category';

/**
 * Emoji grouped by a category title ie. Frequent, Your Uploads, All Uploads
 */

const byOrder = (orderableA, orderableB) => (orderableA.order || 0) - (orderableB.order || 0);
export class EmojiPickerVirtualListInternalOld extends PureComponent {
  constructor(_props) {
    super(_props);
    _defineProperty(this, "virtualItems", []);
    _defineProperty(this, "categoryTracker", new CategoryTracker());
    _defineProperty(this, "listRef", /*#__PURE__*/createRef());
    _defineProperty(this, "onEmojiActive", (emojiId, emoji) => {
      if (this.props.onEmojiActive) {
        this.props.onEmojiActive(emojiId, emoji);
      }
    });
    _defineProperty(this, "onSearch", value => {
      if (this.props.onSearch) {
        this.props.onSearch(value);
      }
    });
    _defineProperty(this, "findEmojiRowAndColumnById", emojiId => {
      let columnIndex = -1;
      // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
      let rowIndex = this.virtualItems.findIndex(rowItem => {
        if (rowItem instanceof EmojisRowItem) {
          // find uploaded emoji in each emoji row
          columnIndex = rowItem.props.emojis.findIndex(emoji => emoji.id === emojiId);
          return columnIndex !== -1;
        }
        return false;
      });
      return {
        rowIndex,
        columnIndex
      };
    });
    _defineProperty(this, "buildVirtualItemFromGroup", group => {
      const {
        onEmojiSelected,
        onEmojiDelete
      } = this.props;
      const items = [];
      items.push(new CategoryHeadingItem({
        id: group.category,
        title: group.title,
        className: categoryClassname
      }));
      let remainingEmojis = group.emojis;
      while (remainingEmojis.length > 0) {
        const rowEmojis = remainingEmojis.slice(0, sizes.emojiPerRow);
        remainingEmojis = remainingEmojis.slice(sizes.emojiPerRow);
        items.push(new EmojisRowItem({
          category: group.category,
          emojis: rowEmojis,
          title: group.title,
          showDelete: group.title === userCustomTitle,
          onSelected: onEmojiSelected,
          onDelete: onEmojiDelete,
          onMouseMove: this.onEmojiActive,
          onFocus: this.onEmojiActive
        }));
      }
      return items;
    });
    _defineProperty(this, "buildVirtualItems", (props, _state) => {
      const {
        emojis,
        loading,
        query
      } = props;
      let items = [];
      const prevFirstCategory = this.categoryTracker.getFirstCategory();
      this.categoryTracker.reset();
      if (loading) {
        items.push(new LoadingItem());
      } else {
        if (query) {
          const search = CategoryDescriptionMap.SEARCH;
          // Only a single "result" category
          items = [...items, ...this.buildVirtualItemFromGroup({
            category: searchCategory,
            title: search.name,
            emojis,
            order: search.order
          })];
        } else {
          // Group by category

          // Not searching show in categories.
          this.allEmojiGroups.forEach(group => {
            // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
            // by not passing it to irrelevant groups
            this.categoryTracker.add(group.emojis[0].category, items.length);
            items = [...items, ...this.buildVirtualItemFromGroup(group)];
            if (group.category === yourUploadsCategory) {
              this.lastYourUploadsRow = items.length - 1;
            }
          });
        }
      }

      // make sure virtualItems is up-to-date before calling onRowsRendered
      this.virtualItems = items;
      if (!loading && !query) {
        if (this.categoryTracker.getFirstCategory() !== prevFirstCategory) {
          this.onRowsRendered({
            startIndex: 0
          });
        }
      }
    });
    _defineProperty(this, "addToCategoryMap", (categoryToGroupMap, emoji, category) => {
      if (!categoryToGroupMap[category]) {
        const categoryDefinition = CategoryDescriptionMap[category];
        categoryToGroupMap[category] = {
          emojis: [],
          title: categoryDefinition.name,
          category,
          order: categoryDefinition.order
        };
      }
      categoryToGroupMap[category].emojis.push(emoji);
      return categoryToGroupMap;
    });
    _defineProperty(this, "groupByCategory", currentUser => (categoryToGroupMap, emoji) => {
      this.addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
      // separate user emojis
      if (emoji.category === customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
        this.addToCategoryMap(categoryToGroupMap, emoji, yourUploadsCategory);
      }
      return categoryToGroupMap;
    });
    _defineProperty(this, "buildEmojiGroupedByCategory", (emojis, currentUser) => {
      const categoryToGroupMap = emojis.reduce(this.groupByCategory(currentUser), {});
      this.allEmojiGroups = Object.keys(categoryToGroupMap).map(key => categoryToGroupMap[key]).map(group => {
        if (group.category !== frequentCategory) {
          group.emojis.sort(byOrder);
        }
        return group;
      }).sort(byOrder);
    });
    _defineProperty(this, "findCategoryToActivate", row => {
      let category = null;
      if (row instanceof CategoryHeadingItem) {
        category = row.props.id;
      } else if (row instanceof EmojisRowItem) {
        category = row.props.category;
      }

      // your uploads is rendered, take it as upload category, so could be highlighted in category selector
      if (category === yourUploadsCategory) {
        return customCategory;
        // search results is rendered, return null so won't be highlighted for category selector
      } else if (category === searchCategory) {
        return null;
      }
      return category;
    });
    /**
     * onRowsRendered callback function
     *
     * Check the category of top of rendered row and inform category selector to change active category
     * Rove index of emoji picker list
     */
    _defineProperty(this, "onRowsRendered", indexes => {
      const {
        startIndex
      } = indexes;
      const rowItem = this.virtualItems[startIndex];
      const list = this.listRef.current;

      // update tabIndex manually, startIndex is not 0 based here
      if (rowItem instanceof CategoryHeadingItem) {
        // if top of row rendered is category heading, update tabIndex for the next emoji row
        list === null || list === void 0 ? void 0 : list.updateFocusIndex(startIndex + 1);
      } else if (rowItem instanceof EmojisRowItem) {
        // if top of row rendered is emoji row, update it's tabIndex.
        list === null || list === void 0 ? void 0 : list.updateFocusIndex(startIndex);
      }
      if (!this.props.query) {
        // Calculate category in view - only relevant if categories shown, i.e. no query
        const currentCategory = this.findCategoryToActivate(rowItem);
        if (currentCategory !== null && this.props.activeCategoryId !== currentCategory) {
          if (this.props.onCategoryActivated) {
            this.props.onCategoryActivated(currentCategory);
          }
        }
      }
    });
    _defineProperty(this, "rowSize", index => {
      var _this$virtualItems$in;
      return ((_this$virtualItems$in = this.virtualItems[index]) === null || _this$virtualItems$in === void 0 ? void 0 : _this$virtualItems$in.height) || sizes.categoryHeadingHeight;
    });
    _defineProperty(this, "renderRow", context => {
      return virtualItemRenderer(this.virtualItems, context);
    });
    /**
     * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
     * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
     * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
     */
    _defineProperty(this, "handleOnCloseDelete", () => {
      const list = this.listRef.current;
      list === null || list === void 0 ? void 0 : list.updateFocusIndex(this.lastYourUploadsRow);
      this.props.onCloseDelete();
    });
    this.lastYourUploadsRow = 0;
    this.buildEmojiGroupedByCategory(_props.emojis, _props.currentUser);
    this.buildVirtualItems(_props, this.state);
  }
  UNSAFE_componentWillUpdate(nextProps, nextState) {
    if (this.props.emojis !== nextProps.emojis || this.props.selectedTone !== nextProps.selectedTone || this.props.loading !== nextProps.loading || this.props.query !== nextProps.query) {
      if (!nextProps.query) {
        // Only refresh if no query
        this.buildEmojiGroupedByCategory(nextProps.emojis, nextProps.currentUser);
      }
      this.buildVirtualItems(nextProps, nextState);
    }
  }
  /**
   * Scrolls to a category in the list view
   */
  reveal(category) {
    const row = this.categoryTracker.getRow(category);
    this.scrollToRow(row);
  }
  scrollToBottom() {
    this.scrollToRow(this.virtualItems.length);
  }
  scrollToTop() {
    this.scrollToRow(0);
  }
  scrollToRow(index) {
    var _this$listRef$current;
    (_this$listRef$current = this.listRef.current) === null || _this$listRef$current === void 0 ? void 0 : _this$listRef$current.scrollToRow(index);
  }
  scrollToRecentlyUploaded(uploadedEmoji) {
    // when search results is shown
    if (this.props.query) {
      const {
        rowIndex,
        columnIndex
      } = this.findEmojiRowAndColumnById(uploadedEmoji.id);
      if (rowIndex !== -1) {
        var _this$listRef$current2;
        (_this$listRef$current2 = this.listRef.current) === null || _this$listRef$current2 === void 0 ? void 0 : _this$listRef$current2.scrollToEmojiAndFocus(rowIndex, columnIndex);
      }
    } else {
      // when seeing all emojis
      const row = this.lastYourUploadsRow;
      if (row > 0) {
        var _this$listRef$current3;
        (_this$listRef$current3 = this.listRef.current) === null || _this$listRef$current3 === void 0 ? void 0 : _this$listRef$current3.scrollToRowAndFocusLastEmoji(this.lastYourUploadsRow);
      }
    }
  }
  render() {
    const {
      query,
      selectedTone,
      onToneSelected,
      onToneSelectorCancelled,
      toneEmoji,
      uploading,
      uploadEnabled,
      emojiToDelete,
      initialUploadName,
      uploadErrorMessage,
      onUploadCancelled,
      onUploadEmoji,
      onDeleteEmoji,
      onFileChooserClicked,
      onOpenUpload,
      size = defaultEmojiPickerSize,
      emojis
    } = this.props;
    const virtualListHeight = sizes.listHeight + emojiPickerHeightOffset(size);
    return /*#__PURE__*/React.createElement(EmojiPickerTabPanel, {
      showSearchResults: !!query
    }, /*#__PURE__*/React.createElement(EmojiActions, {
      selectedTone: selectedTone,
      onToneSelected: onToneSelected,
      onToneSelectorCancelled: onToneSelectorCancelled,
      toneEmoji: toneEmoji,
      uploading: uploading,
      uploadEnabled: uploadEnabled,
      emojiToDelete: emojiToDelete,
      initialUploadName: initialUploadName,
      uploadErrorMessage: uploadErrorMessage,
      onUploadCancelled: onUploadCancelled,
      onUploadEmoji: onUploadEmoji,
      onCloseDelete: this.handleOnCloseDelete,
      onDeleteEmoji: onDeleteEmoji,
      onFileChooserClicked: onFileChooserClicked,
      onOpenUpload: onOpenUpload,
      query: query,
      onChange: this.onSearch,
      resultsCount: emojis.length
    }), /*#__PURE__*/React.createElement(EmojiPickerListContextProvider, {
      initialEmojisFocus: {
        rowIndex: 1,
        columnIndex: 0
      }
    }, /*#__PURE__*/React.createElement(VirtualList, {
      ref: this.listRef,
      height: virtualListHeight,
      overscanRowCount: 10,
      rowCount: this.virtualItems.length,
      rowHeight: this.rowSize,
      rowRenderer: this.renderRow,
      scrollToAlignment: "start",
      width: sizes.listWidth,
      onRowsRendered: this.onRowsRendered
    })));
  }
}
_defineProperty(EmojiPickerVirtualListInternalOld, "defaultProps", {
  onEmojiSelected: () => {},
  onEmojiActive: () => {},
  onEmojiDelete: () => {},
  onCategoryActivated: () => {},
  onSearch: () => {},
  size: defaultEmojiPickerSize
});
export const EmojiPickerVirtualListInternalNew = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    emojis,
    currentUser,
    onEmojiSelected = () => {},
    onEmojiActive = () => {},
    onEmojiDelete = () => {},
    onCategoryActivated = () => {},
    onSearch = () => {},
    size = defaultEmojiPickerSize,
    query,
    loading,
    selectedTone,
    onToneSelected,
    onToneSelectorCancelled,
    toneEmoji,
    uploading,
    uploadEnabled,
    emojiToDelete,
    initialUploadName,
    uploadErrorMessage,
    onUploadCancelled,
    onUploadEmoji,
    onDeleteEmoji,
    onCloseDelete,
    onFileChooserClicked,
    onOpenUpload,
    activeCategoryId
  } = props;
  const listRef = useRef(null);
  const [allEmojiGroups, setAllEmojiGroups] = useState([]);
  const [virtualItems, setVirtualItems] = useState([]);
  const [lastYourUploadsRow, setLastYourUploadsRow] = useState(0);
  const categoryTracker = useMemo(() => new CategoryTracker(), []);
  const [categoriesChanged, setCategoriesChanged] = useState(false);
  const groupByCategory = useCallback(currentUser => (categoryToGroupMap, emoji) => {
    addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
    // separate user emojis
    if (emoji.category === customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
      addToCategoryMap(categoryToGroupMap, emoji, yourUploadsCategory);
    }
    return categoryToGroupMap;
  }, []);

  /**
   * onRowsRendered callback function
   *
   * Check the category of top of rendered row and inform category selector to change active category
   * Rove index of emoji picker list
   */
  const onRowsRendered = useCallback(indexes => {
    const {
      startIndex
    } = indexes;
    const rowItem = virtualItems[startIndex];
    const list = listRef.current;

    // update tabIndex manually, startIndex is not 0 based here
    if (rowItem instanceof CategoryHeadingItem) {
      // if top of row rendered is category heading, update tabIndex for the next emoji row
      list === null || list === void 0 ? void 0 : list.updateFocusIndex(startIndex + 1);
    } else if (rowItem instanceof EmojisRowItem) {
      // if top of row rendered is emoji row, update it's tabIndex.
      list === null || list === void 0 ? void 0 : list.updateFocusIndex(startIndex);
    }
    if (!query) {
      // Calculate category in view - only relevant if categories shown, i.e. no query
      const currentCategory = findCategoryToActivate(rowItem);
      if (currentCategory !== null && activeCategoryId !== currentCategory) {
        if (onCategoryActivated) {
          onCategoryActivated(currentCategory);
        }
      }
    }
  }, [virtualItems, query, activeCategoryId, onCategoryActivated]);
  const buildEmojiGroupedByCategory = useCallback((emojis, currentUser) => {
    const categoryToGroupMap = emojis.reduce(groupByCategory(currentUser), {});
    setAllEmojiGroups(Object.keys(categoryToGroupMap).map(key => categoryToGroupMap[key]).map(group => {
      if (group.category !== frequentCategory) {
        group.emojis.sort(byOrder);
      }
      return group;
    }).sort(byOrder));
  }, [groupByCategory]);
  const addToCategoryMap = (categoryToGroupMap, emoji, category) => {
    if (!categoryToGroupMap[category]) {
      const categoryDefinition = CategoryDescriptionMap[category];
      categoryToGroupMap[category] = {
        emojis: [],
        title: categoryDefinition.name,
        category,
        order: categoryDefinition.order
      };
    }
    categoryToGroupMap[category].emojis.push(emoji);
    return categoryToGroupMap;
  };
  const buildVirtualItemFromGroup = useCallback(group => {
    const items = [];
    items.push(new CategoryHeadingItem({
      id: group.category,
      title: group.title,
      className: categoryClassname
    }));
    let remainingEmojis = group.emojis;
    while (remainingEmojis.length > 0) {
      const rowEmojis = remainingEmojis.slice(0, sizes.emojiPerRow);
      remainingEmojis = remainingEmojis.slice(sizes.emojiPerRow);
      items.push(new EmojisRowItem({
        category: group.category,
        emojis: rowEmojis,
        title: group.title,
        showDelete: group.title === userCustomTitle,
        onSelected: onEmojiSelected,
        onDelete: onEmojiDelete,
        onMouseMove: onEmojiActive,
        onFocus: onEmojiActive
      }));
    }
    return items;
  }, [onEmojiSelected, onEmojiDelete, onEmojiActive]);
  const buildVirtualItems = useCallback(() => {
    let items = [];
    const prevFirstCategory = categoryTracker.getFirstCategory();
    categoryTracker.reset();
    if (loading) {
      items.push(new LoadingItem());
    } else {
      if (query) {
        const search = CategoryDescriptionMap.SEARCH;
        // Only a single "result" category
        items = [...items, ...buildVirtualItemFromGroup({
          category: searchCategory,
          title: search.name,
          emojis,
          order: search.order
        })];
      } else {
        // Group by category

        // Not searching show in categories.
        allEmojiGroups.forEach(group => {
          // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
          // by not passing it to irrelevant groups
          categoryTracker.add(group.emojis[0].category, items.length);
          items = [...items, ...buildVirtualItemFromGroup(group)];
          if (group.category === yourUploadsCategory) {
            setLastYourUploadsRow(items.length - 1);
          }
        });
      }
    }

    // make sure virtualItems is up-to-date before calling onRowsRendered
    setVirtualItems(items);
    if (!loading && !query) {
      if (categoryTracker.getFirstCategory() !== prevFirstCategory) {
        setCategoriesChanged(true);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allEmojiGroups, loading, query, emojis]);
  const findCategoryToActivate = row => {
    let category = null;
    if (row instanceof CategoryHeadingItem) {
      category = row.props.id;
    } else if (row instanceof EmojisRowItem) {
      category = row.props.category;
    }
    // your uploads is rendered, take it as upload category, so could be highlighted in category selector
    if (category === yourUploadsCategory) {
      return customCategory;
      // search results is rendered, return null so won't be highlighted for category selector
    } else if (category === searchCategory) {
      return null;
    }
    return category;
  };
  const rowSize = index => {
    var _virtualItems$index;
    return ((_virtualItems$index = virtualItems[index]) === null || _virtualItems$index === void 0 ? void 0 : _virtualItems$index.height) || sizes.categoryHeadingHeight;
  };
  const renderRow = context => {
    return virtualItemRenderer(virtualItems, context);
  };

  /**
   * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
   * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
   * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
   */
  const handleOnCloseDelete = () => {
    const list = listRef.current;
    list === null || list === void 0 ? void 0 : list.updateFocusIndex(lastYourUploadsRow);
    onCloseDelete();
  };
  const findEmojiRowAndColumnById = emojiId => {
    let columnIndex = -1;
    // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
    let rowIndex = virtualItems.findIndex(rowItem => {
      if (rowItem instanceof EmojisRowItem) {
        // find uploaded emoji in each emoji row
        columnIndex = rowItem.props.emojis.findIndex(emoji => emoji.id === emojiId);
        return columnIndex !== -1;
      }
      return false;
    });
    return {
      rowIndex,
      columnIndex
    };
  };

  /**
   * Scrolls to a category in the list view
   */
  useImperativeHandle(ref, () => {
    return {
      reveal(category) {
        const row = categoryTracker.getRow(category);
        scrollToRow(listRef, row);
      },
      scrollToBottom() {
        scrollToRow(listRef, virtualItems.length);
      },
      scrollToTop() {
        scrollToRow(listRef, 0);
      },
      scrollToRow(index) {
        scrollToRow(listRef, index);
      },
      scrollToRecentlyUploaded(uploadedEmoji) {
        // when search results is shown
        if (query) {
          const {
            rowIndex,
            columnIndex
          } = findEmojiRowAndColumnById(uploadedEmoji.id);
          if (rowIndex !== -1) {
            var _listRef$current;
            (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollToEmojiAndFocus(rowIndex, columnIndex);
          }
        } else {
          // when seeing all emojis
          const row = lastYourUploadsRow;
          if (row > 0) {
            var _listRef$current2;
            (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : _listRef$current2.scrollToRowAndFocusLastEmoji(lastYourUploadsRow);
          }
        }
      }
    };
  });
  useEffect(() => {
    if (!query) {
      buildEmojiGroupedByCategory(emojis, currentUser);
    }
  }, [emojis, selectedTone, loading, query, currentUser, buildEmojiGroupedByCategory]);
  useEffect(() => {
    buildVirtualItems();
  }, [allEmojiGroups, buildVirtualItems]);
  useEffect(() => {
    if (categoriesChanged) {
      onRowsRendered({
        startIndex: 0
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [virtualItems, categoriesChanged]);
  const virtualListHeight = useMemo(() => sizes.listHeight + emojiPickerHeightOffset(size), [size]);
  return /*#__PURE__*/React.createElement(EmojiPickerTabPanel, {
    showSearchResults: !!query
  }, /*#__PURE__*/React.createElement(EmojiActions, {
    selectedTone: selectedTone,
    onToneSelected: onToneSelected,
    onToneSelectorCancelled: onToneSelectorCancelled,
    toneEmoji: toneEmoji,
    uploading: uploading,
    uploadEnabled: uploadEnabled,
    emojiToDelete: emojiToDelete,
    initialUploadName: initialUploadName,
    uploadErrorMessage: uploadErrorMessage,
    onUploadCancelled: onUploadCancelled,
    onUploadEmoji: onUploadEmoji,
    onCloseDelete: handleOnCloseDelete,
    onDeleteEmoji: onDeleteEmoji,
    onFileChooserClicked: onFileChooserClicked,
    onOpenUpload: onOpenUpload,
    query: query,
    onChange: onSearch,
    resultsCount: emojis.length
  }), /*#__PURE__*/React.createElement(EmojiPickerListContextProvider, {
    initialEmojisFocus: {
      rowIndex: 1,
      columnIndex: 0
    }
  }, /*#__PURE__*/React.createElement(VirtualList, {
    ref: listRef,
    height: virtualListHeight,
    overscanRowCount: 10,
    rowCount: virtualItems.length,
    rowHeight: rowSize,
    rowRenderer: renderRow,
    scrollToAlignment: "start",
    width: sizes.listWidth,
    onRowsRendered: onRowsRendered
  })));
});