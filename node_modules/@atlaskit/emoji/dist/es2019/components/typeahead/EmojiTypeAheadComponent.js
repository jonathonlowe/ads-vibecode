import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { PureComponent } from 'react';
import { flushSync } from 'react-dom';
import uuid from 'uuid';
import { EmojiCommonProvider } from '../../context/EmojiCommonProvider';
import { SearchSort, SearchSourceTypes } from '../../types';
import { typeaheadCancelledEvent, typeaheadRenderedEvent, typeaheadSelectedEvent, ufoExperiences } from '../../util/analytics';
import { defaultListLimit } from '../../util/constants';
import debug from '../../util/logger';
import { toEmojiId } from '../../util/type-helpers';
import { createRecordSelectionDefault } from '../common/RecordSelectionDefault';
import EmojiList from './EmojiTypeAheadList';
import { emojiTypeAhead } from './styles';
import { fg } from '@atlaskit/platform-feature-flags';
const isFullShortName = query => query && query.length > 1 && query.charAt(0) === ':' && query.charAt(query.length - 1) === ':';
const uniqueExactShortNameMatchIndex = (searchResult, query) => {
  if (!query) {
    return undefined;
  }
  query = query.toLowerCase();
  let matchIndex;
  let index = 0;
  for (const emoji of searchResult.emojis) {
    if (query && emoji.shortName.toLowerCase() === query) {
      if (matchIndex === undefined) {
        matchIndex = index;
      } else {
        return;
      }
    }
    index++;
  }
  return matchIndex;
};
export default class EmojiTypeAheadComponent extends PureComponent {
  constructor(props) {
    super(props);
    _defineProperty(this, "emojiListRef", null);
    _defineProperty(this, "openTime", 0);
    _defineProperty(this, "renderStartTime", 0);
    _defineProperty(this, "selectNext", () => {
      if (this.emojiListRef) {
        this.emojiListRef.selectNext();
      }
    });
    _defineProperty(this, "selectPrevious", () => {
      if (this.emojiListRef) {
        this.emojiListRef.selectPrevious();
      }
    });
    _defineProperty(this, "chooseCurrentSelection", () => {
      this.pressed = true;
      if (this.emojiListRef) {
        this.emojiListRef.chooseCurrentSelection();
      }
    });
    _defineProperty(this, "count", () => {
      const {
        emojis
      } = this.state;
      return emojis && emojis.length || 0;
    });
    _defineProperty(this, "getTone", tone => {
      return typeof tone === 'undefined' ? undefined : tone >= 0 && tone <= 5 ? ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'][tone] : undefined;
    });
    _defineProperty(this, "onSearchResult", result => {
      const {
        emojis,
        query
      } = result;
      const wasVisible = this.state.visible;
      const visible = emojis.length > 0;
      this.fireAnalyticsEvent(typeaheadRenderedEvent(Date.now() - this.renderStartTime, query, emojis));
      debug('emoji-typeahead.applyPropChanges', emojis.length, wasVisible, visible);

      // Synchronously flush state update, because there is some analytics in fireSelectionEvent
      // that relies on emojis being set to determine the position
      flushSync(() => {
        this.setState({
          emojis: emojis,
          visible,
          loading: false
        });
      });
      if (isFullShortName(query)) {
        const matchIndex = uniqueExactShortNameMatchIndex(result, query);
        if (matchIndex !== undefined) {
          const onSelect = createRecordSelectionDefault(this.props.emojiProvider, this.props.onSelection, analytic => this.fireAnalyticsEvent(analytic(SearchSourceTypes.TYPEAHEAD)));
          this.fireSelectionEvent(result.emojis[matchIndex], true);
          onSelect(toEmojiId(result.emojis[matchIndex]), result.emojis[matchIndex]);
        }
      }
      if (wasVisible !== visible) {
        if (visible) {
          if (this.props.onOpen) {
            this.props.onOpen();
          }
        } else {
          if (this.props.onClose) {
            this.props.onClose();
          }
        }
      }
    });
    _defineProperty(this, "onProviderChange", {
      result: this.onSearchResult
    });
    _defineProperty(this, "onEmojiListRef", ref => {
      this.emojiListRef = ref;
    });
    this.state = {
      visible: true,
      emojis: [],
      loading: true
    };
    if (this.props.onOpen) {
      this.props.onOpen();
    }
    this.openTime = Date.now();
    this.renderStartTime = this.openTime;
    this.selectedTone = props.emojiProvider.getSelectedTone();
    this.pressed = false;
    this.sessionId = uuid();
    this.selected = false;
  }
  componentDidMount() {
    const {
      emojiProvider
    } = this.props;
    emojiProvider.subscribe(this.onProviderChange);
    this.onSearch(this.props.query);
  }
  componentWillUnmount() {
    const {
      emojiProvider,
      query
    } = this.props;
    const {
      emojis
    } = this.state;
    emojiProvider.unsubscribe(this.onProviderChange);
    if (!this.selected) {
      this.fireAnalyticsEvent(typeaheadCancelledEvent(Date.now() - this.openTime, query, emojis));
    }
    ufoExperiences['emoji-searched'].abort({
      metadata: {
        source: 'EmojiTypeAheadComponent',
        reason: 'unmount',
        query
      }
    });
    ufoExperiences['emoji-selection-recorded'].abort({
      metadata: {
        source: 'EmojiTypeAheadComponent',
        reason: 'unmount',
        query
      }
    });
    this.sessionId = uuid();
    this.selected = false;
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!fg('platform_editor_react18_elements_emoji') || !fg('platform_editor_react18_elements_emoji_jira_bb')) {
      const prevEmojiProvider = this.props.emojiProvider;
      const nextEmojiProvider = nextProps.emojiProvider;
      if (prevEmojiProvider !== nextEmojiProvider) {
        prevEmojiProvider.unsubscribe(this.onProviderChange);
        nextEmojiProvider.subscribe(this.onProviderChange);
        this.onSearch(nextProps.query);
      } else if (this.props.query !== nextProps.query) {
        this.onSearch(nextProps.query);
      }
    }
  }
  componentDidUpdate(prevProps) {
    if (fg('platform_editor_react18_elements_emoji') || fg('platform_editor_react18_elements_emoji_jira_bb')) {
      if (prevProps !== this.props) {
        const prevEmojiProvider = prevProps.emojiProvider;
        const nextEmojiProvider = this.props.emojiProvider;
        if (prevEmojiProvider !== nextEmojiProvider) {
          prevEmojiProvider.unsubscribe(this.onProviderChange);
          nextEmojiProvider.subscribe(this.onProviderChange);
          this.onSearch(this.props.query);
        } else if (prevProps.query !== this.props.query) {
          this.onSearch(this.props.query);
        }
      }
    }
  }
  fireAnalyticsEvent(payload) {
    if (!this.props.createAnalyticsEvent) {
      return;
    }
    payload.attributes.sessionId = this.sessionId;
    this.props.createAnalyticsEvent(payload).fire('fabric-elements');
  }
  onSearch(query) {
    const {
      emojiProvider,
      listLimit
    } = this.props;
    const options = {
      limit: listLimit || defaultListLimit,
      skinTone: this.selectedTone
    };
    if (query && query.replace(':', '').length > 0) {
      options.sort = SearchSort.Default;
    } else {
      // if empty query (i.e. typeahead triggered only) then only sort by usage
      options.sort = SearchSort.UsageFrequency;
    }
    this.renderStartTime = Date.now();
    emojiProvider.filter(query, options);
  }
  fireSelectionEvent(emoji, exactMatch) {
    const {
      query
    } = this.props;
    const {
      emojis
    } = this.state;
    this.selected = true;
    this.fireAnalyticsEvent(typeaheadSelectedEvent(exactMatch || this.pressed, Date.now() - this.openTime, emoji, emojis, query, exactMatch));
  }
  render() {
    const {
      emojiProvider,
      onSelection
    } = this.props;
    const recordUsageOnSelection = createRecordSelectionDefault(emojiProvider, (emojiId, emoji, event) => {
      this.fireSelectionEvent(emoji);
      if (onSelection) {
        onSelection(emojiId, emoji, event);
      }
    }, analytic => this.fireAnalyticsEvent(analytic(SearchSourceTypes.TYPEAHEAD)));
    const {
      visible,
      emojis,
      loading
    } = this.state;
    const style = {
      display: visible ? 'block' : 'none'
    };
    return /*#__PURE__*/React.createElement(EmojiCommonProvider, {
      emojiProvider: this.props.emojiProvider
    }, /*#__PURE__*/React.createElement("div", {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      style: style
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: ['ak-emoji-typeahead', emojiTypeAhead].join(' ')
    }, /*#__PURE__*/React.createElement(EmojiList, {
      emojis: emojis,
      onEmojiSelected: recordUsageOnSelection,
      ref: this.onEmojiListRef,
      loading: loading
    })));
  }
}
_defineProperty(EmojiTypeAheadComponent, "defaultProps", {
  onSelection: () => {},
  onOpen: () => {},
  onClose: () => {},
  listLimit: defaultListLimit
});