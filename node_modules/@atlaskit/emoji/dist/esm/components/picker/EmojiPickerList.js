import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React, { createRef, PureComponent, useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';
import { customCategory, defaultEmojiPickerSize, frequentCategory, searchCategory, userCustomTitle, yourUploadsCategory } from '../../util/constants';
import { CategoryDescriptionMap } from './categories';
import CategoryTracker from './CategoryTracker';
import { sizes } from './EmojiPickerSizes';
import { CategoryHeadingItem, EmojisRowItem, LoadingItem, virtualItemRenderer } from './EmojiPickerVirtualItems';
import EmojiActions from '../common/EmojiActions';
import { emojiPickerHeightOffset, scrollToRow as _scrollToRow } from './utils';
import { VirtualList } from './VirtualList';
import { EmojiPickerListContextProvider } from '../../context/EmojiPickerListContext';
import EmojiPickerTabPanel from './EmojiPickerTabPanel';

/**
 * Test id for wrapper Emoji Picker List div
 */
export var RENDER_EMOJI_PICKER_LIST_TESTID = 'render-emoji-picker-list';
var categoryClassname = 'emoji-category';

/**
 * Emoji grouped by a category title ie. Frequent, Your Uploads, All Uploads
 */

var byOrder = function byOrder(orderableA, orderableB) {
  return (orderableA.order || 0) - (orderableB.order || 0);
};
export var EmojiPickerVirtualListInternalOld = /*#__PURE__*/function (_PureComponent) {
  function EmojiPickerVirtualListInternalOld(_props) {
    var _this;
    _classCallCheck(this, EmojiPickerVirtualListInternalOld);
    _this = _callSuper(this, EmojiPickerVirtualListInternalOld, [_props]);
    _defineProperty(_this, "virtualItems", []);
    _defineProperty(_this, "categoryTracker", new CategoryTracker());
    _defineProperty(_this, "listRef", /*#__PURE__*/createRef());
    _defineProperty(_this, "onEmojiActive", function (emojiId, emoji) {
      if (_this.props.onEmojiActive) {
        _this.props.onEmojiActive(emojiId, emoji);
      }
    });
    _defineProperty(_this, "onSearch", function (value) {
      if (_this.props.onSearch) {
        _this.props.onSearch(value);
      }
    });
    _defineProperty(_this, "findEmojiRowAndColumnById", function (emojiId) {
      var columnIndex = -1;
      // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
      var rowIndex = _this.virtualItems.findIndex(function (rowItem) {
        if (rowItem instanceof EmojisRowItem) {
          // find uploaded emoji in each emoji row
          columnIndex = rowItem.props.emojis.findIndex(function (emoji) {
            return emoji.id === emojiId;
          });
          return columnIndex !== -1;
        }
        return false;
      });
      return {
        rowIndex: rowIndex,
        columnIndex: columnIndex
      };
    });
    _defineProperty(_this, "buildVirtualItemFromGroup", function (group) {
      var _this$props = _this.props,
        onEmojiSelected = _this$props.onEmojiSelected,
        onEmojiDelete = _this$props.onEmojiDelete;
      var items = [];
      items.push(new CategoryHeadingItem({
        id: group.category,
        title: group.title,
        className: categoryClassname
      }));
      var remainingEmojis = group.emojis;
      while (remainingEmojis.length > 0) {
        var rowEmojis = remainingEmojis.slice(0, sizes.emojiPerRow);
        remainingEmojis = remainingEmojis.slice(sizes.emojiPerRow);
        items.push(new EmojisRowItem({
          category: group.category,
          emojis: rowEmojis,
          title: group.title,
          showDelete: group.title === userCustomTitle,
          onSelected: onEmojiSelected,
          onDelete: onEmojiDelete,
          onMouseMove: _this.onEmojiActive,
          onFocus: _this.onEmojiActive
        }));
      }
      return items;
    });
    _defineProperty(_this, "buildVirtualItems", function (props, _state) {
      var emojis = props.emojis,
        loading = props.loading,
        query = props.query;
      var items = [];
      var prevFirstCategory = _this.categoryTracker.getFirstCategory();
      _this.categoryTracker.reset();
      if (loading) {
        items.push(new LoadingItem());
      } else {
        if (query) {
          var search = CategoryDescriptionMap.SEARCH;
          // Only a single "result" category
          items = [].concat(_toConsumableArray(items), _toConsumableArray(_this.buildVirtualItemFromGroup({
            category: searchCategory,
            title: search.name,
            emojis: emojis,
            order: search.order
          })));
        } else {
          // Group by category

          // Not searching show in categories.
          _this.allEmojiGroups.forEach(function (group) {
            // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
            // by not passing it to irrelevant groups
            _this.categoryTracker.add(group.emojis[0].category, items.length);
            items = [].concat(_toConsumableArray(items), _toConsumableArray(_this.buildVirtualItemFromGroup(group)));
            if (group.category === yourUploadsCategory) {
              _this.lastYourUploadsRow = items.length - 1;
            }
          });
        }
      }

      // make sure virtualItems is up-to-date before calling onRowsRendered
      _this.virtualItems = items;
      if (!loading && !query) {
        if (_this.categoryTracker.getFirstCategory() !== prevFirstCategory) {
          _this.onRowsRendered({
            startIndex: 0
          });
        }
      }
    });
    _defineProperty(_this, "addToCategoryMap", function (categoryToGroupMap, emoji, category) {
      if (!categoryToGroupMap[category]) {
        var categoryDefinition = CategoryDescriptionMap[category];
        categoryToGroupMap[category] = {
          emojis: [],
          title: categoryDefinition.name,
          category: category,
          order: categoryDefinition.order
        };
      }
      categoryToGroupMap[category].emojis.push(emoji);
      return categoryToGroupMap;
    });
    _defineProperty(_this, "groupByCategory", function (currentUser) {
      return function (categoryToGroupMap, emoji) {
        _this.addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
        // separate user emojis
        if (emoji.category === customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
          _this.addToCategoryMap(categoryToGroupMap, emoji, yourUploadsCategory);
        }
        return categoryToGroupMap;
      };
    });
    _defineProperty(_this, "buildEmojiGroupedByCategory", function (emojis, currentUser) {
      var categoryToGroupMap = emojis.reduce(_this.groupByCategory(currentUser), {});
      _this.allEmojiGroups = Object.keys(categoryToGroupMap).map(function (key) {
        return categoryToGroupMap[key];
      }).map(function (group) {
        if (group.category !== frequentCategory) {
          group.emojis.sort(byOrder);
        }
        return group;
      }).sort(byOrder);
    });
    _defineProperty(_this, "findCategoryToActivate", function (row) {
      var category = null;
      if (row instanceof CategoryHeadingItem) {
        category = row.props.id;
      } else if (row instanceof EmojisRowItem) {
        category = row.props.category;
      }

      // your uploads is rendered, take it as upload category, so could be highlighted in category selector
      if (category === yourUploadsCategory) {
        return customCategory;
        // search results is rendered, return null so won't be highlighted for category selector
      } else if (category === searchCategory) {
        return null;
      }
      return category;
    });
    /**
     * onRowsRendered callback function
     *
     * Check the category of top of rendered row and inform category selector to change active category
     * Rove index of emoji picker list
     */
    _defineProperty(_this, "onRowsRendered", function (indexes) {
      var startIndex = indexes.startIndex;
      var rowItem = _this.virtualItems[startIndex];
      var list = _this.listRef.current;

      // update tabIndex manually, startIndex is not 0 based here
      if (rowItem instanceof CategoryHeadingItem) {
        // if top of row rendered is category heading, update tabIndex for the next emoji row
        list === null || list === void 0 || list.updateFocusIndex(startIndex + 1);
      } else if (rowItem instanceof EmojisRowItem) {
        // if top of row rendered is emoji row, update it's tabIndex.
        list === null || list === void 0 || list.updateFocusIndex(startIndex);
      }
      if (!_this.props.query) {
        // Calculate category in view - only relevant if categories shown, i.e. no query
        var currentCategory = _this.findCategoryToActivate(rowItem);
        if (currentCategory !== null && _this.props.activeCategoryId !== currentCategory) {
          if (_this.props.onCategoryActivated) {
            _this.props.onCategoryActivated(currentCategory);
          }
        }
      }
    });
    _defineProperty(_this, "rowSize", function (index) {
      var _this$virtualItems$in;
      return ((_this$virtualItems$in = _this.virtualItems[index]) === null || _this$virtualItems$in === void 0 ? void 0 : _this$virtualItems$in.height) || sizes.categoryHeadingHeight;
    });
    _defineProperty(_this, "renderRow", function (context) {
      return virtualItemRenderer(_this.virtualItems, context);
    });
    /**
     * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
     * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
     * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
     */
    _defineProperty(_this, "handleOnCloseDelete", function () {
      var list = _this.listRef.current;
      list === null || list === void 0 || list.updateFocusIndex(_this.lastYourUploadsRow);
      _this.props.onCloseDelete();
    });
    _this.lastYourUploadsRow = 0;
    _this.buildEmojiGroupedByCategory(_props.emojis, _props.currentUser);
    _this.buildVirtualItems(_props, _this.state);
    return _this;
  }
  _inherits(EmojiPickerVirtualListInternalOld, _PureComponent);
  return _createClass(EmojiPickerVirtualListInternalOld, [{
    key: "UNSAFE_componentWillUpdate",
    value: function UNSAFE_componentWillUpdate(nextProps, nextState) {
      if (this.props.emojis !== nextProps.emojis || this.props.selectedTone !== nextProps.selectedTone || this.props.loading !== nextProps.loading || this.props.query !== nextProps.query) {
        if (!nextProps.query) {
          // Only refresh if no query
          this.buildEmojiGroupedByCategory(nextProps.emojis, nextProps.currentUser);
        }
        this.buildVirtualItems(nextProps, nextState);
      }
    }
  }, {
    key: "reveal",
    value:
    /**
     * Scrolls to a category in the list view
     */
    function reveal(category) {
      var row = this.categoryTracker.getRow(category);
      this.scrollToRow(row);
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.scrollToRow(this.virtualItems.length);
    }
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      this.scrollToRow(0);
    }
  }, {
    key: "scrollToRow",
    value: function scrollToRow(index) {
      var _this$listRef$current;
      (_this$listRef$current = this.listRef.current) === null || _this$listRef$current === void 0 || _this$listRef$current.scrollToRow(index);
    }
  }, {
    key: "scrollToRecentlyUploaded",
    value: function scrollToRecentlyUploaded(uploadedEmoji) {
      // when search results is shown
      if (this.props.query) {
        var _this$findEmojiRowAnd = this.findEmojiRowAndColumnById(uploadedEmoji.id),
          rowIndex = _this$findEmojiRowAnd.rowIndex,
          columnIndex = _this$findEmojiRowAnd.columnIndex;
        if (rowIndex !== -1) {
          var _this$listRef$current2;
          (_this$listRef$current2 = this.listRef.current) === null || _this$listRef$current2 === void 0 || _this$listRef$current2.scrollToEmojiAndFocus(rowIndex, columnIndex);
        }
      } else {
        // when seeing all emojis
        var row = this.lastYourUploadsRow;
        if (row > 0) {
          var _this$listRef$current3;
          (_this$listRef$current3 = this.listRef.current) === null || _this$listRef$current3 === void 0 || _this$listRef$current3.scrollToRowAndFocusLastEmoji(this.lastYourUploadsRow);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        query = _this$props2.query,
        selectedTone = _this$props2.selectedTone,
        onToneSelected = _this$props2.onToneSelected,
        onToneSelectorCancelled = _this$props2.onToneSelectorCancelled,
        toneEmoji = _this$props2.toneEmoji,
        uploading = _this$props2.uploading,
        uploadEnabled = _this$props2.uploadEnabled,
        emojiToDelete = _this$props2.emojiToDelete,
        initialUploadName = _this$props2.initialUploadName,
        uploadErrorMessage = _this$props2.uploadErrorMessage,
        onUploadCancelled = _this$props2.onUploadCancelled,
        onUploadEmoji = _this$props2.onUploadEmoji,
        onDeleteEmoji = _this$props2.onDeleteEmoji,
        onFileChooserClicked = _this$props2.onFileChooserClicked,
        onOpenUpload = _this$props2.onOpenUpload,
        _this$props2$size = _this$props2.size,
        size = _this$props2$size === void 0 ? defaultEmojiPickerSize : _this$props2$size,
        emojis = _this$props2.emojis;
      var virtualListHeight = sizes.listHeight + emojiPickerHeightOffset(size);
      return /*#__PURE__*/React.createElement(EmojiPickerTabPanel, {
        showSearchResults: !!query
      }, /*#__PURE__*/React.createElement(EmojiActions, {
        selectedTone: selectedTone,
        onToneSelected: onToneSelected,
        onToneSelectorCancelled: onToneSelectorCancelled,
        toneEmoji: toneEmoji,
        uploading: uploading,
        uploadEnabled: uploadEnabled,
        emojiToDelete: emojiToDelete,
        initialUploadName: initialUploadName,
        uploadErrorMessage: uploadErrorMessage,
        onUploadCancelled: onUploadCancelled,
        onUploadEmoji: onUploadEmoji,
        onCloseDelete: this.handleOnCloseDelete,
        onDeleteEmoji: onDeleteEmoji,
        onFileChooserClicked: onFileChooserClicked,
        onOpenUpload: onOpenUpload,
        query: query,
        onChange: this.onSearch,
        resultsCount: emojis.length
      }), /*#__PURE__*/React.createElement(EmojiPickerListContextProvider, {
        initialEmojisFocus: {
          rowIndex: 1,
          columnIndex: 0
        }
      }, /*#__PURE__*/React.createElement(VirtualList, {
        ref: this.listRef,
        height: virtualListHeight,
        overscanRowCount: 10,
        rowCount: this.virtualItems.length,
        rowHeight: this.rowSize,
        rowRenderer: this.renderRow,
        scrollToAlignment: "start",
        width: sizes.listWidth,
        onRowsRendered: this.onRowsRendered
      })));
    }
  }]);
}(PureComponent);
_defineProperty(EmojiPickerVirtualListInternalOld, "defaultProps", {
  onEmojiSelected: function onEmojiSelected() {},
  onEmojiActive: function onEmojiActive() {},
  onEmojiDelete: function onEmojiDelete() {},
  onCategoryActivated: function onCategoryActivated() {},
  onSearch: function onSearch() {},
  size: defaultEmojiPickerSize
});
export var EmojiPickerVirtualListInternalNew = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var emojis = props.emojis,
    currentUser = props.currentUser,
    _props$onEmojiSelecte = props.onEmojiSelected,
    onEmojiSelected = _props$onEmojiSelecte === void 0 ? function () {} : _props$onEmojiSelecte,
    _props$onEmojiActive = props.onEmojiActive,
    onEmojiActive = _props$onEmojiActive === void 0 ? function () {} : _props$onEmojiActive,
    _props$onEmojiDelete = props.onEmojiDelete,
    onEmojiDelete = _props$onEmojiDelete === void 0 ? function () {} : _props$onEmojiDelete,
    _props$onCategoryActi = props.onCategoryActivated,
    onCategoryActivated = _props$onCategoryActi === void 0 ? function () {} : _props$onCategoryActi,
    _props$onSearch = props.onSearch,
    onSearch = _props$onSearch === void 0 ? function () {} : _props$onSearch,
    _props$size = props.size,
    size = _props$size === void 0 ? defaultEmojiPickerSize : _props$size,
    query = props.query,
    loading = props.loading,
    selectedTone = props.selectedTone,
    onToneSelected = props.onToneSelected,
    onToneSelectorCancelled = props.onToneSelectorCancelled,
    toneEmoji = props.toneEmoji,
    uploading = props.uploading,
    uploadEnabled = props.uploadEnabled,
    emojiToDelete = props.emojiToDelete,
    initialUploadName = props.initialUploadName,
    uploadErrorMessage = props.uploadErrorMessage,
    onUploadCancelled = props.onUploadCancelled,
    onUploadEmoji = props.onUploadEmoji,
    onDeleteEmoji = props.onDeleteEmoji,
    onCloseDelete = props.onCloseDelete,
    onFileChooserClicked = props.onFileChooserClicked,
    onOpenUpload = props.onOpenUpload,
    activeCategoryId = props.activeCategoryId;
  var listRef = useRef(null);
  var _useState = useState([]),
    _useState2 = _slicedToArray(_useState, 2),
    allEmojiGroups = _useState2[0],
    setAllEmojiGroups = _useState2[1];
  var _useState3 = useState([]),
    _useState4 = _slicedToArray(_useState3, 2),
    virtualItems = _useState4[0],
    setVirtualItems = _useState4[1];
  var _useState5 = useState(0),
    _useState6 = _slicedToArray(_useState5, 2),
    lastYourUploadsRow = _useState6[0],
    setLastYourUploadsRow = _useState6[1];
  var categoryTracker = useMemo(function () {
    return new CategoryTracker();
  }, []);
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    categoriesChanged = _useState8[0],
    setCategoriesChanged = _useState8[1];
  var groupByCategory = useCallback(function (currentUser) {
    return function (categoryToGroupMap, emoji) {
      addToCategoryMap(categoryToGroupMap, emoji, emoji.category);
      // separate user emojis
      if (emoji.category === customCategory && currentUser && emoji.creatorUserId === currentUser.id) {
        addToCategoryMap(categoryToGroupMap, emoji, yourUploadsCategory);
      }
      return categoryToGroupMap;
    };
  }, []);

  /**
   * onRowsRendered callback function
   *
   * Check the category of top of rendered row and inform category selector to change active category
   * Rove index of emoji picker list
   */
  var onRowsRendered = useCallback(function (indexes) {
    var startIndex = indexes.startIndex;
    var rowItem = virtualItems[startIndex];
    var list = listRef.current;

    // update tabIndex manually, startIndex is not 0 based here
    if (rowItem instanceof CategoryHeadingItem) {
      // if top of row rendered is category heading, update tabIndex for the next emoji row
      list === null || list === void 0 || list.updateFocusIndex(startIndex + 1);
    } else if (rowItem instanceof EmojisRowItem) {
      // if top of row rendered is emoji row, update it's tabIndex.
      list === null || list === void 0 || list.updateFocusIndex(startIndex);
    }
    if (!query) {
      // Calculate category in view - only relevant if categories shown, i.e. no query
      var currentCategory = findCategoryToActivate(rowItem);
      if (currentCategory !== null && activeCategoryId !== currentCategory) {
        if (onCategoryActivated) {
          onCategoryActivated(currentCategory);
        }
      }
    }
  }, [virtualItems, query, activeCategoryId, onCategoryActivated]);
  var buildEmojiGroupedByCategory = useCallback(function (emojis, currentUser) {
    var categoryToGroupMap = emojis.reduce(groupByCategory(currentUser), {});
    setAllEmojiGroups(Object.keys(categoryToGroupMap).map(function (key) {
      return categoryToGroupMap[key];
    }).map(function (group) {
      if (group.category !== frequentCategory) {
        group.emojis.sort(byOrder);
      }
      return group;
    }).sort(byOrder));
  }, [groupByCategory]);
  var addToCategoryMap = function addToCategoryMap(categoryToGroupMap, emoji, category) {
    if (!categoryToGroupMap[category]) {
      var categoryDefinition = CategoryDescriptionMap[category];
      categoryToGroupMap[category] = {
        emojis: [],
        title: categoryDefinition.name,
        category: category,
        order: categoryDefinition.order
      };
    }
    categoryToGroupMap[category].emojis.push(emoji);
    return categoryToGroupMap;
  };
  var buildVirtualItemFromGroup = useCallback(function (group) {
    var items = [];
    items.push(new CategoryHeadingItem({
      id: group.category,
      title: group.title,
      className: categoryClassname
    }));
    var remainingEmojis = group.emojis;
    while (remainingEmojis.length > 0) {
      var rowEmojis = remainingEmojis.slice(0, sizes.emojiPerRow);
      remainingEmojis = remainingEmojis.slice(sizes.emojiPerRow);
      items.push(new EmojisRowItem({
        category: group.category,
        emojis: rowEmojis,
        title: group.title,
        showDelete: group.title === userCustomTitle,
        onSelected: onEmojiSelected,
        onDelete: onEmojiDelete,
        onMouseMove: onEmojiActive,
        onFocus: onEmojiActive
      }));
    }
    return items;
  }, [onEmojiSelected, onEmojiDelete, onEmojiActive]);
  var buildVirtualItems = useCallback(function () {
    var items = [];
    var prevFirstCategory = categoryTracker.getFirstCategory();
    categoryTracker.reset();
    if (loading) {
      items.push(new LoadingItem());
    } else {
      if (query) {
        var search = CategoryDescriptionMap.SEARCH;
        // Only a single "result" category
        items = [].concat(_toConsumableArray(items), _toConsumableArray(buildVirtualItemFromGroup({
          category: searchCategory,
          title: search.name,
          emojis: emojis,
          order: search.order
        })));
      } else {
        // Group by category

        // Not searching show in categories.
        allEmojiGroups.forEach(function (group) {
          // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
          // by not passing it to irrelevant groups
          categoryTracker.add(group.emojis[0].category, items.length);
          items = [].concat(_toConsumableArray(items), _toConsumableArray(buildVirtualItemFromGroup(group)));
          if (group.category === yourUploadsCategory) {
            setLastYourUploadsRow(items.length - 1);
          }
        });
      }
    }

    // make sure virtualItems is up-to-date before calling onRowsRendered
    setVirtualItems(items);
    if (!loading && !query) {
      if (categoryTracker.getFirstCategory() !== prevFirstCategory) {
        setCategoriesChanged(true);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allEmojiGroups, loading, query, emojis]);
  var findCategoryToActivate = function findCategoryToActivate(row) {
    var category = null;
    if (row instanceof CategoryHeadingItem) {
      category = row.props.id;
    } else if (row instanceof EmojisRowItem) {
      category = row.props.category;
    }
    // your uploads is rendered, take it as upload category, so could be highlighted in category selector
    if (category === yourUploadsCategory) {
      return customCategory;
      // search results is rendered, return null so won't be highlighted for category selector
    } else if (category === searchCategory) {
      return null;
    }
    return category;
  };
  var rowSize = function rowSize(index) {
    var _virtualItems$index;
    return ((_virtualItems$index = virtualItems[index]) === null || _virtualItems$index === void 0 ? void 0 : _virtualItems$index.height) || sizes.categoryHeadingHeight;
  };
  var renderRow = function renderRow(context) {
    return virtualItemRenderer(virtualItems, context);
  };

  /**
   * After deleting emoji, we'll update the focus index to the first emoji of last row of your uploads, so when user navigate back focus will still work
   * if last emoji in your uploads is deleted, the updated focus index will be outdated, as there will be no your uploads section
   * however, it'll trigger onChange from VirtualList, which will update focus index automatically for us
   */
  var handleOnCloseDelete = function handleOnCloseDelete() {
    var list = listRef.current;
    list === null || list === void 0 || list.updateFocusIndex(lastYourUploadsRow);
    onCloseDelete();
  };
  var findEmojiRowAndColumnById = function findEmojiRowAndColumnById(emojiId) {
    var columnIndex = -1;
    // for most of cases, it'd be in first emoji row, so should be quite fast to find in real world
    var rowIndex = virtualItems.findIndex(function (rowItem) {
      if (rowItem instanceof EmojisRowItem) {
        // find uploaded emoji in each emoji row
        columnIndex = rowItem.props.emojis.findIndex(function (emoji) {
          return emoji.id === emojiId;
        });
        return columnIndex !== -1;
      }
      return false;
    });
    return {
      rowIndex: rowIndex,
      columnIndex: columnIndex
    };
  };

  /**
   * Scrolls to a category in the list view
   */
  useImperativeHandle(ref, function () {
    return {
      reveal: function reveal(category) {
        var row = categoryTracker.getRow(category);
        _scrollToRow(listRef, row);
      },
      scrollToBottom: function scrollToBottom() {
        _scrollToRow(listRef, virtualItems.length);
      },
      scrollToTop: function scrollToTop() {
        _scrollToRow(listRef, 0);
      },
      scrollToRow: function scrollToRow(index) {
        _scrollToRow(listRef, index);
      },
      scrollToRecentlyUploaded: function scrollToRecentlyUploaded(uploadedEmoji) {
        // when search results is shown
        if (query) {
          var _findEmojiRowAndColum = findEmojiRowAndColumnById(uploadedEmoji.id),
            rowIndex = _findEmojiRowAndColum.rowIndex,
            columnIndex = _findEmojiRowAndColum.columnIndex;
          if (rowIndex !== -1) {
            var _listRef$current;
            (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollToEmojiAndFocus(rowIndex, columnIndex);
          }
        } else {
          // when seeing all emojis
          var row = lastYourUploadsRow;
          if (row > 0) {
            var _listRef$current2;
            (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollToRowAndFocusLastEmoji(lastYourUploadsRow);
          }
        }
      }
    };
  });
  useEffect(function () {
    if (!query) {
      buildEmojiGroupedByCategory(emojis, currentUser);
    }
  }, [emojis, selectedTone, loading, query, currentUser, buildEmojiGroupedByCategory]);
  useEffect(function () {
    buildVirtualItems();
  }, [allEmojiGroups, buildVirtualItems]);
  useEffect(function () {
    if (categoriesChanged) {
      onRowsRendered({
        startIndex: 0
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [virtualItems, categoriesChanged]);
  var virtualListHeight = useMemo(function () {
    return sizes.listHeight + emojiPickerHeightOffset(size);
  }, [size]);
  return /*#__PURE__*/React.createElement(EmojiPickerTabPanel, {
    showSearchResults: !!query
  }, /*#__PURE__*/React.createElement(EmojiActions, {
    selectedTone: selectedTone,
    onToneSelected: onToneSelected,
    onToneSelectorCancelled: onToneSelectorCancelled,
    toneEmoji: toneEmoji,
    uploading: uploading,
    uploadEnabled: uploadEnabled,
    emojiToDelete: emojiToDelete,
    initialUploadName: initialUploadName,
    uploadErrorMessage: uploadErrorMessage,
    onUploadCancelled: onUploadCancelled,
    onUploadEmoji: onUploadEmoji,
    onCloseDelete: handleOnCloseDelete,
    onDeleteEmoji: onDeleteEmoji,
    onFileChooserClicked: onFileChooserClicked,
    onOpenUpload: onOpenUpload,
    query: query,
    onChange: onSearch,
    resultsCount: emojis.length
  }), /*#__PURE__*/React.createElement(EmojiPickerListContextProvider, {
    initialEmojisFocus: {
      rowIndex: 1,
      columnIndex: 0
    }
  }, /*#__PURE__*/React.createElement(VirtualList, {
    ref: listRef,
    height: virtualListHeight,
    overscanRowCount: 10,
    rowCount: virtualItems.length,
    rowHeight: rowSize,
    rowRenderer: renderRow,
    scrollToAlignment: "start",
    width: sizes.listWidth,
    onRowsRendered: onRowsRendered
  })));
});