/* VirtualList.tsx generated by @compiled/babel-plugin v0.36.1 */
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "./VirtualList.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React, { useCallback, useImperativeHandle } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import { useEmojiPickerListContext } from '../../hooks/useEmojiPickerListContext';
import { EMOJIPICKERLIST_KEYBOARD_KEYS_SUPPORTED, EMOJI_LIST_COLUMNS, EMOJI_LIST_PAGE_COUNT, KeyboardNavigationDirection, KeyboardKeys } from '../../util/constants';
var virtualList = null;
var virtualRowStyle = null;
export var virtualListScrollContainerTestId = 'virtual-list-scroll-container';
export var VirtualList = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var parentRef = React.useRef(null);
  var virtualistItemsRef = React.useRef(null);
  var rowRenderer = props.rowRenderer,
    onRowsRendered = props.onRowsRendered,
    scrollToAlignment = props.scrollToAlignment,
    width = props.width,
    height = props.height,
    rowCount = props.rowCount;
  var _useEmojiPickerListCo = useEmojiPickerListContext(),
    currentEmojisFocus = _useEmojiPickerListCo.currentEmojisFocus,
    setEmojisFocus = _useEmojiPickerListCo.setEmojisFocus;
  var getVirtualizerOptions = function getVirtualizerOptions() {
    var rowCount = props.rowCount,
      rowHeight = props.rowHeight,
      overscanRowCount = props.overscanRowCount;
    return {
      count: rowCount,
      getScrollElement: function getScrollElement() {
        return parentRef.current;
      },
      estimateSize: rowHeight,
      overscan: overscanRowCount,
      onChange: function onChange() {
        var startIndex = getFirstVisibleListElementIndex();
        onRowsRendered({
          startIndex: startIndex
        });
      },
      scrollPaddingStart: 28,
      scrollPaddingEnd: 28
    };
  };
  var rowVirtualizer = useVirtualizer(getVirtualizerOptions());
  var isElementVisible = function isElementVisible(element) {
    var parent = parentRef.current;
    var elementRect = element.getBoundingClientRect();
    var parentRect = parent.getBoundingClientRect();
    var elemTop = elementRect.top;
    var elemBottom = elementRect.bottom;
    var parentTop = parentRect.top;
    var parentBottom = parentRect.bottom;

    // Only completely visible elements return true:
    var isVisible = elemTop >= parentTop && elemBottom <= parentBottom;
    return isVisible;
  };
  var getFirstVisibleListElementIndex = useCallback(function () {
    var _parentRef$current;
    var virtualList = rowVirtualizer.getVirtualItems();
    var renderedElements = (_parentRef$current = parentRef.current) === null || _parentRef$current === void 0 || (_parentRef$current = _parentRef$current.firstChild) === null || _parentRef$current === void 0 ? void 0 : _parentRef$current.childNodes;
    if (virtualList.length === 0 || !renderedElements || renderedElements.length === 0) {
      return 0;
    }
    // Convert NodeListOf<ChildNodes> to ChildNodes[]
    var renderedElementsToArray = Array.from(renderedElements);
    var firstVisibleIndex = renderedElementsToArray.findIndex(function (elem) {
      return isElementVisible(elem);
    });
    if (firstVisibleIndex !== -1) {
      var _virtualList$firstVis;
      return ((_virtualList$firstVis = virtualList[firstVisibleIndex]) === null || _virtualList$firstVis === void 0 ? void 0 : _virtualList$firstVis.index) || 0;
    }
    return 0;
  }, [rowVirtualizer]);

  /**
   * Recurisive function to find next available emoji and it's focus indexes in the grid
   *
   * current focus element is at rowIndex.columnIndex
   * if found element then return the element and focus indexes
   * otherwise change row/column till find the element
   * if can't find the element till reach the edge of grid, we keep current focus states
   *
   * @param rowIndex search from row index (0 based)
   * @param columnIndex search from column index (0 based)
   * @param direction search direction
   */
  var findNextEmoji = useCallback(function (rowIndex, columnIndex, direction) {
    var _virtualistItemsRef$c;
    var emojiToFocus = (_virtualistItemsRef$c = virtualistItemsRef.current) === null || _virtualistItemsRef$c === void 0 ? void 0 : _virtualistItemsRef$c.querySelector("[data-focus-index=\"".concat(rowIndex, "-").concat(columnIndex, "\"]"));
    var lastRowIndex = rowCount - 1;
    var lastColumnIndex = EMOJI_LIST_COLUMNS - 1;
    if (emojiToFocus) {
      return {
        element: emojiToFocus,
        rowIndex: rowIndex,
        columnIndex: columnIndex
      };
    }
    switch (direction) {
      case KeyboardNavigationDirection.Down:
        if (rowIndex >= lastRowIndex) {
          return null;
        }
        // find emoji in same column but lower row
        return findNextEmoji(rowIndex + 1, columnIndex, KeyboardNavigationDirection.Down);
      case KeyboardNavigationDirection.Up:
        if (rowIndex <= 0) {
          return null;
        }
        // find emoji in same column but upper row
        return findNextEmoji(rowIndex - 1, columnIndex, KeyboardNavigationDirection.Up);
      case KeyboardNavigationDirection.Left:
        if (rowIndex <= 0) {
          return null;
        }
        if (columnIndex < 0) {
          // find emoji in upper row
          return findNextEmoji(rowIndex - 1, lastColumnIndex, KeyboardNavigationDirection.Left);
        }
        // find emoji on left in the current row
        return findNextEmoji(rowIndex, columnIndex - 1, KeyboardNavigationDirection.Left);
      case KeyboardNavigationDirection.Right:
        if (rowIndex >= lastRowIndex) {
          return null;
        }
        // if no emoji on right, we try first emoji in next row
        return findNextEmoji(rowIndex + 1, 0, KeyboardNavigationDirection.Right);
      default:
        return null;
    }
  }, [rowCount]);

  /**
   * Find the valid emoji to scroll and focus
   */
  var scrollToRowAndFocusEmoji = useCallback(function (emojiToFocus) {
    if (emojiToFocus) {
      var _emojiToFocus$element;
      rowVirtualizer.scrollToIndex(emojiToFocus.rowIndex);
      (_emojiToFocus$element = emojiToFocus.element) === null || _emojiToFocus$element === void 0 || _emojiToFocus$element.focus({
        preventScroll: true
      });
      setEmojisFocus({
        rowIndex: emojiToFocus.rowIndex,
        columnIndex: emojiToFocus.columnIndex
      });
    }
  }, [rowVirtualizer, setEmojisFocus]);
  var focusEmoji = useCallback(function (rIndex, cIndex, direction) {
    var waitForScrollFinish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (waitForScrollFinish) {
      // scroll to target rowIndex first to ensure the row is rendered in list.
      // used in page up/down, ctrl+Home, ctrl+End
      rowVirtualizer.scrollToIndex(rIndex);
      setTimeout(function () {
        var emojiToFocus = findNextEmoji(rIndex, cIndex, direction);
        scrollToRowAndFocusEmoji(emojiToFocus);
      }, 100); // 100ms is virtual list scrolling time
    } else {
      var emojiToFocus = findNextEmoji(rIndex, cIndex, direction);
      scrollToRowAndFocusEmoji(emojiToFocus);
    }
  }, [scrollToRowAndFocusEmoji, findNextEmoji, rowVirtualizer]);

  // following the guide from https://www.w3.org/WAI/ARIA/apg/patterns/grid/
  var handleKeyDown = function handleKeyDown(e) {
    if (!EMOJIPICKERLIST_KEYBOARD_KEYS_SUPPORTED.includes(e.key)) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    var lastRowIndex = rowCount - 1;
    var lastColumnIndex = EMOJI_LIST_COLUMNS - 1;

    // focus first emoji on first row
    if (e.key === KeyboardKeys.Home && e.ctrlKey) {
      focusEmoji(1, 0, KeyboardNavigationDirection.Up, true);
      return;
    } else if (e.key === KeyboardKeys.End && e.ctrlKey) {
      // focus last available emoji on last row
      focusEmoji(lastRowIndex, lastColumnIndex, KeyboardNavigationDirection.Left, true);
      return;
    }
    switch (e.key) {
      // navigate to the right column
      case KeyboardKeys.ArrowRight:
        focusEmoji(currentEmojisFocus.rowIndex, currentEmojisFocus.columnIndex + 1, KeyboardNavigationDirection.Right);
        break;
      // navigate to the left column
      case KeyboardKeys.ArrowLeft:
        focusEmoji(currentEmojisFocus.rowIndex, currentEmojisFocus.columnIndex - 1, KeyboardNavigationDirection.Left);
        break;
      // navigate to the down row
      case KeyboardKeys.ArrowDown:
        focusEmoji(currentEmojisFocus.rowIndex === lastRowIndex ? lastRowIndex : currentEmojisFocus.rowIndex + 1, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Down);
        break;
      // navigate to the row after {EMOJI_LIST_PAGE_COUNT} rows
      case KeyboardKeys.PageDown:
        focusEmoji(currentEmojisFocus.rowIndex + EMOJI_LIST_PAGE_COUNT, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Down, true);
        break;
      // navigate to the up row
      case KeyboardKeys.ArrowUp:
        focusEmoji(currentEmojisFocus.rowIndex <= 1 ? 1 : currentEmojisFocus.rowIndex - 1, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Up);
        break;
      // navigate to the row before {EMOJI_LIST_PAGE_COUNT} rows
      case KeyboardKeys.PageUp:
        focusEmoji(currentEmojisFocus.rowIndex - EMOJI_LIST_PAGE_COUNT, currentEmojisFocus.columnIndex, KeyboardNavigationDirection.Up, true);
        break;
      // navigate to the first cell of current row
      case KeyboardKeys.Home:
        focusEmoji(currentEmojisFocus.rowIndex, 0, KeyboardNavigationDirection.Left);
        break;
      // navigate to the last cell of current row
      case KeyboardKeys.End:
        focusEmoji(currentEmojisFocus.rowIndex, lastColumnIndex, KeyboardNavigationDirection.Left);
        break;
    }
  };

  // Exposing a custom ref handle to the parent component EmojiPickerList to trigger scrollToRow via the listRef
  // https://beta.reactjs.org/reference/react/useImperativeHandle
  useImperativeHandle(ref, function () {
    return {
      scrollToRow: function scrollToRow(index) {
        if (index !== undefined) {
          rowVirtualizer.setOptions(_objectSpread(_objectSpread({}, rowVirtualizer.options), {}, {
            scrollPaddingStart: 0
          }));
          rowVirtualizer.scrollToIndex(index, {
            align: scrollToAlignment
          });
        }
      },
      scrollToRowAndFocusLastEmoji: function scrollToRowAndFocusLastEmoji(index) {
        if (index !== undefined) {
          focusEmoji(index, EMOJI_LIST_COLUMNS, KeyboardNavigationDirection.Left, true);
        }
      },
      scrollToEmojiAndFocus: function scrollToEmojiAndFocus(rowIndex, columnIndex) {
        focusEmoji(rowIndex, columnIndex, KeyboardNavigationDirection.Left, true);
      },
      updateFocusIndex: function updateFocusIndex(rowIndex) {
        var _virtualistItemsRef$c2;
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // row could be removed from virtual list after scrolling, we'll update emoji cell tabIndex after losing focus
        if (!((_virtualistItemsRef$c2 = virtualistItemsRef.current) !== null && _virtualistItemsRef$c2 !== void 0 && _virtualistItemsRef$c2.contains(document.activeElement))) {
          setEmojisFocus({
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
        }
      }
    };
  }, [setEmojisFocus, focusEmoji, rowVirtualizer, scrollToAlignment]);
  return /*#__PURE__*/React.createElement("div", {
    ref: parentRef,
    style: {
      height: "".concat(height, "px"),
      width: "".concat(width, "px")
    },
    "data-testid": virtualListScrollContainerTestId,
    "aria-labelledby": "emoji-picker-table-description",
    role: "grid",
    className: ax(["_1reo15vq _18m91wug _n3tdu2gc _nt751r31 _49pcglyw _1hvw1o36"])
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: "".concat(rowVirtualizer.getTotalSize(), "px"),
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      width: '100%',
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      position: 'relative'
    },
    ref: virtualistItemsRef,
    onKeyDown: handleKeyDown,
    role: "presentation"
  }, rowVirtualizer.getVirtualItems().map(function (virtualRow, index) {
    return /*#__PURE__*/React.createElement("div", {
      key: virtualRow.key,
      style: {
        height: "".concat(virtualRow.size, "px"),
        transform: "translateY(".concat(virtualRow.start, "px)")
      },
      role: "row",
      "aria-rowindex": index + 1,
      className: ax(["_kqswstnw _154iidpf _1ltvidpf _1bsb1osq"])
    }, rowRenderer(virtualRow));
  })));
});