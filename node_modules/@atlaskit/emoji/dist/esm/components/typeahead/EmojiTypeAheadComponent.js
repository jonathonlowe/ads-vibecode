import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import React from 'react';
import { PureComponent } from 'react';
import { flushSync } from 'react-dom';
import uuid from 'uuid';
import { EmojiCommonProvider } from '../../context/EmojiCommonProvider';
import { SearchSort, SearchSourceTypes } from '../../types';
import { typeaheadCancelledEvent, typeaheadRenderedEvent, typeaheadSelectedEvent, ufoExperiences } from '../../util/analytics';
import { defaultListLimit } from '../../util/constants';
import debug from '../../util/logger';
import { toEmojiId } from '../../util/type-helpers';
import { createRecordSelectionDefault } from '../common/RecordSelectionDefault';
import EmojiList from './EmojiTypeAheadList';
import { emojiTypeAhead } from './styles';
import { fg } from '@atlaskit/platform-feature-flags';
var isFullShortName = function isFullShortName(query) {
  return query && query.length > 1 && query.charAt(0) === ':' && query.charAt(query.length - 1) === ':';
};
var uniqueExactShortNameMatchIndex = function uniqueExactShortNameMatchIndex(searchResult, query) {
  if (!query) {
    return undefined;
  }
  query = query.toLowerCase();
  var matchIndex;
  var index = 0;
  var _iterator = _createForOfIteratorHelper(searchResult.emojis),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var emoji = _step.value;
      if (query && emoji.shortName.toLowerCase() === query) {
        if (matchIndex === undefined) {
          matchIndex = index;
        } else {
          return;
        }
      }
      index++;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return matchIndex;
};
var EmojiTypeAheadComponent = /*#__PURE__*/function (_PureComponent) {
  function EmojiTypeAheadComponent(props) {
    var _this;
    _classCallCheck(this, EmojiTypeAheadComponent);
    _this = _callSuper(this, EmojiTypeAheadComponent, [props]);
    _defineProperty(_this, "emojiListRef", null);
    _defineProperty(_this, "openTime", 0);
    _defineProperty(_this, "renderStartTime", 0);
    _defineProperty(_this, "selectNext", function () {
      if (_this.emojiListRef) {
        _this.emojiListRef.selectNext();
      }
    });
    _defineProperty(_this, "selectPrevious", function () {
      if (_this.emojiListRef) {
        _this.emojiListRef.selectPrevious();
      }
    });
    _defineProperty(_this, "chooseCurrentSelection", function () {
      _this.pressed = true;
      if (_this.emojiListRef) {
        _this.emojiListRef.chooseCurrentSelection();
      }
    });
    _defineProperty(_this, "count", function () {
      var emojis = _this.state.emojis;
      return emojis && emojis.length || 0;
    });
    _defineProperty(_this, "getTone", function (tone) {
      return typeof tone === 'undefined' ? undefined : tone >= 0 && tone <= 5 ? ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'][tone] : undefined;
    });
    _defineProperty(_this, "onSearchResult", function (result) {
      var emojis = result.emojis,
        query = result.query;
      var wasVisible = _this.state.visible;
      var visible = emojis.length > 0;
      _this.fireAnalyticsEvent(typeaheadRenderedEvent(Date.now() - _this.renderStartTime, query, emojis));
      debug('emoji-typeahead.applyPropChanges', emojis.length, wasVisible, visible);

      // Synchronously flush state update, because there is some analytics in fireSelectionEvent
      // that relies on emojis being set to determine the position
      flushSync(function () {
        _this.setState({
          emojis: emojis,
          visible: visible,
          loading: false
        });
      });
      if (isFullShortName(query)) {
        var matchIndex = uniqueExactShortNameMatchIndex(result, query);
        if (matchIndex !== undefined) {
          var onSelect = createRecordSelectionDefault(_this.props.emojiProvider, _this.props.onSelection, function (analytic) {
            return _this.fireAnalyticsEvent(analytic(SearchSourceTypes.TYPEAHEAD));
          });
          _this.fireSelectionEvent(result.emojis[matchIndex], true);
          onSelect(toEmojiId(result.emojis[matchIndex]), result.emojis[matchIndex]);
        }
      }
      if (wasVisible !== visible) {
        if (visible) {
          if (_this.props.onOpen) {
            _this.props.onOpen();
          }
        } else {
          if (_this.props.onClose) {
            _this.props.onClose();
          }
        }
      }
    });
    _defineProperty(_this, "onProviderChange", {
      result: _this.onSearchResult
    });
    _defineProperty(_this, "onEmojiListRef", function (ref) {
      _this.emojiListRef = ref;
    });
    _this.state = {
      visible: true,
      emojis: [],
      loading: true
    };
    if (_this.props.onOpen) {
      _this.props.onOpen();
    }
    _this.openTime = Date.now();
    _this.renderStartTime = _this.openTime;
    _this.selectedTone = props.emojiProvider.getSelectedTone();
    _this.pressed = false;
    _this.sessionId = uuid();
    _this.selected = false;
    return _this;
  }
  _inherits(EmojiTypeAheadComponent, _PureComponent);
  return _createClass(EmojiTypeAheadComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var emojiProvider = this.props.emojiProvider;
      emojiProvider.subscribe(this.onProviderChange);
      this.onSearch(this.props.query);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props = this.props,
        emojiProvider = _this$props.emojiProvider,
        query = _this$props.query;
      var emojis = this.state.emojis;
      emojiProvider.unsubscribe(this.onProviderChange);
      if (!this.selected) {
        this.fireAnalyticsEvent(typeaheadCancelledEvent(Date.now() - this.openTime, query, emojis));
      }
      ufoExperiences['emoji-searched'].abort({
        metadata: {
          source: 'EmojiTypeAheadComponent',
          reason: 'unmount',
          query: query
        }
      });
      ufoExperiences['emoji-selection-recorded'].abort({
        metadata: {
          source: 'EmojiTypeAheadComponent',
          reason: 'unmount',
          query: query
        }
      });
      this.sessionId = uuid();
      this.selected = false;
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (!fg('platform_editor_react18_elements_emoji') || !fg('platform_editor_react18_elements_emoji_jira_bb')) {
        var prevEmojiProvider = this.props.emojiProvider;
        var nextEmojiProvider = nextProps.emojiProvider;
        if (prevEmojiProvider !== nextEmojiProvider) {
          prevEmojiProvider.unsubscribe(this.onProviderChange);
          nextEmojiProvider.subscribe(this.onProviderChange);
          this.onSearch(nextProps.query);
        } else if (this.props.query !== nextProps.query) {
          this.onSearch(nextProps.query);
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (fg('platform_editor_react18_elements_emoji') || fg('platform_editor_react18_elements_emoji_jira_bb')) {
        if (prevProps !== this.props) {
          var prevEmojiProvider = prevProps.emojiProvider;
          var nextEmojiProvider = this.props.emojiProvider;
          if (prevEmojiProvider !== nextEmojiProvider) {
            prevEmojiProvider.unsubscribe(this.onProviderChange);
            nextEmojiProvider.subscribe(this.onProviderChange);
            this.onSearch(this.props.query);
          } else if (prevProps.query !== this.props.query) {
            this.onSearch(this.props.query);
          }
        }
      }
    }
  }, {
    key: "fireAnalyticsEvent",
    value: function fireAnalyticsEvent(payload) {
      if (!this.props.createAnalyticsEvent) {
        return;
      }
      payload.attributes.sessionId = this.sessionId;
      this.props.createAnalyticsEvent(payload).fire('fabric-elements');
    }
  }, {
    key: "onSearch",
    value: function onSearch(query) {
      var _this$props2 = this.props,
        emojiProvider = _this$props2.emojiProvider,
        listLimit = _this$props2.listLimit;
      var options = {
        limit: listLimit || defaultListLimit,
        skinTone: this.selectedTone
      };
      if (query && query.replace(':', '').length > 0) {
        options.sort = SearchSort.Default;
      } else {
        // if empty query (i.e. typeahead triggered only) then only sort by usage
        options.sort = SearchSort.UsageFrequency;
      }
      this.renderStartTime = Date.now();
      emojiProvider.filter(query, options);
    }
  }, {
    key: "fireSelectionEvent",
    value: function fireSelectionEvent(emoji, exactMatch) {
      var query = this.props.query;
      var emojis = this.state.emojis;
      this.selected = true;
      this.fireAnalyticsEvent(typeaheadSelectedEvent(exactMatch || this.pressed, Date.now() - this.openTime, emoji, emojis, query, exactMatch));
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props3 = this.props,
        emojiProvider = _this$props3.emojiProvider,
        onSelection = _this$props3.onSelection;
      var recordUsageOnSelection = createRecordSelectionDefault(emojiProvider, function (emojiId, emoji, event) {
        _this2.fireSelectionEvent(emoji);
        if (onSelection) {
          onSelection(emojiId, emoji, event);
        }
      }, function (analytic) {
        return _this2.fireAnalyticsEvent(analytic(SearchSourceTypes.TYPEAHEAD));
      });
      var _this$state = this.state,
        visible = _this$state.visible,
        emojis = _this$state.emojis,
        loading = _this$state.loading;
      var style = {
        display: visible ? 'block' : 'none'
      };
      return /*#__PURE__*/React.createElement(EmojiCommonProvider, {
        emojiProvider: this.props.emojiProvider
      }, /*#__PURE__*/React.createElement("div", {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
        style: style
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        ,
        className: ['ak-emoji-typeahead', emojiTypeAhead].join(' ')
      }, /*#__PURE__*/React.createElement(EmojiList, {
        emojis: emojis,
        onEmojiSelected: recordUsageOnSelection,
        ref: this.onEmojiListRef,
        loading: loading
      })));
    }
  }]);
}(PureComponent);
_defineProperty(EmojiTypeAheadComponent, "defaultProps", {
  onSelection: function onSelection() {},
  onOpen: function onOpen() {},
  onClose: function onClose() {},
  listLimit: defaultListLimit
});
export { EmojiTypeAheadComponent as default };