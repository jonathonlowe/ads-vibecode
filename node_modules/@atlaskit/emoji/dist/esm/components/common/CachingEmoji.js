import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["emoji", "placeholderSize"],
  _excluded2 = ["emoji"],
  _excluded3 = ["emoji", "placeholderSize", "showTooltip", "fitToHeight", "children"];
import React, { memo, useEffect, useState } from 'react';
import { isMediaEmoji } from '../../util/type-helpers';
import { UfoEmojiTimings } from '../../types';
import debug from '../../util/logger';
import Emoji from './Emoji';
import EmojiPlaceholder from './EmojiPlaceholder';
import EmojiFallback from './EmojiFallback';
import { UfoErrorBoundary } from './UfoErrorBoundary';
import { sampledUfoRenderedEmoji, ufoExperiences, useSampledUFOComponentExperience } from '../../util/analytics';
import { SAMPLING_RATE_EMOJI_RENDERED_EXP } from '../../util/constants';
import { hasUfoMarked } from '../../util/analytics/ufoExperiences';
import { useEmoji } from '../../hooks/useEmoji';
import { useCallback } from 'react';
import { extractErrorInfo } from '../../util/analytics/analytics';
/**
 * Renders an emoji from a cached image, if required.
 */
export var CachingEmoji = function CachingEmoji(props) {
  // Optimisation to only render CachingMediaEmoji if necessary
  // slight performance hit, which accumulates for a large number of emoji.
  var emoji = props.emoji,
    placeholderSize = props.placeholderSize,
    restProps = _objectWithoutProperties(props, _excluded);
  // start emoji rendered experience, it may have already started earlier in `ResourcedEmoji`.
  useSampledUFOComponentExperience(ufoExperiences['emoji-rendered'].getInstance(emoji.id || emoji.shortName), SAMPLING_RATE_EMOJI_RENDERED_EXP, {
    source: 'CachingEmoji',
    emojiId: emoji.id
  });
  useEffect(function () {
    if (!hasUfoMarked(sampledUfoRenderedEmoji(emoji), 'fmp')) {
      sampledUfoRenderedEmoji(emoji).markFMP();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  var emojiNode = function emojiNode() {
    if (isMediaEmoji(emoji)) {
      return /*#__PURE__*/React.createElement(CachingMediaEmoji, _extends({
        emoji: emoji,
        placeholderSize: placeholderSize
      }, restProps));
    }
    return /*#__PURE__*/React.createElement(StandardEmoji, _extends({
      emoji: emoji
    }, restProps));
  };
  return /*#__PURE__*/React.createElement(UfoErrorBoundary, {
    experiences: [ufoExperiences['emoji-rendered'].getInstance(props.emoji.id || props.emoji.shortName)]
  }, emojiNode());
};
var StandardEmoji = function StandardEmoji(props) {
  var emoji = props.emoji,
    restProps = _objectWithoutProperties(props, _excluded2);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    imageLoadError = _useState2[0],
    setImageLoadError = _useState2[1];
  var handleLoadError = function handleLoadError(_emojiId) {
    setImageLoadError(true);
  };
  if (imageLoadError) {
    return /*#__PURE__*/React.createElement(EmojiFallback, _extends({
      emoji: emoji
    }, restProps));
  }
  return /*#__PURE__*/React.createElement(Emoji, _extends({
    emoji: emoji,
    onLoadError: handleLoadError
  }, restProps));
};

/**
 * Rendering a media emoji image from a cache for media emoji, with different
 * rendering paths depending on caching strategy.
 */
export var CachingMediaEmoji = function CachingMediaEmoji(props) {
  var emoji = props.emoji,
    placeholderSize = props.placeholderSize,
    showTooltip = props.showTooltip,
    fitToHeight = props.fitToHeight,
    children = props.children,
    restProps = _objectWithoutProperties(props, _excluded3);
  var shortName = emoji.shortName,
    representation = emoji.representation;
  var _useState3 = useState(),
    _useState4 = _slicedToArray(_useState3, 2),
    cachedEmoji = _useState4[0],
    setCachedEmoji = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    inValidImage = _useState6[0],
    setInvalidImage = _useState6[1];
  var _useEmoji = useEmoji(),
    emojiProvider = _useEmoji.emojiProvider;
  var loadEmoji = useCallback(function (emojiProvider) {
    debug('Loading image via media cache', emoji.shortName);
    sampledUfoRenderedEmoji(emoji).mark(UfoEmojiTimings.MEDIA_START);
    emojiProvider.getMediaEmojiDescriptionURLWithInlineToken(emoji).then(function (cachedEmoji) {
      setCachedEmoji(cachedEmoji);
      setInvalidImage(false);
      sampledUfoRenderedEmoji(emoji).mark(UfoEmojiTimings.MEDIA_END);
    }).catch(function (error) {
      setCachedEmoji(undefined);
      setInvalidImage(true);
      sampledUfoRenderedEmoji(emoji).failure({
        metadata: {
          error: extractErrorInfo(error),
          reason: 'failed to load media emoji',
          source: 'CachingMediaEmoji',
          emojiId: emoji.id
        }
      });
    });
  }, [emoji]);
  useEffect(function () {
    if (emojiProvider) {
      loadEmoji(emojiProvider);
    }
  }, [emojiProvider, loadEmoji]);
  var handleLoadError = function handleLoadError(_emojiId) {
    sampledUfoRenderedEmoji(_emojiId).failure({
      metadata: {
        reason: 'load error',
        source: 'CachingMediaEmoji',
        emojiId: _emojiId.id
      }
    });
    setInvalidImage(true);
  };
  if (cachedEmoji && !inValidImage) {
    return /*#__PURE__*/React.createElement(Emoji, _extends({}, restProps, {
      showTooltip: showTooltip,
      fitToHeight: fitToHeight,
      emoji: cachedEmoji,
      onLoadError: handleLoadError
    }));
  }
  return /*#__PURE__*/React.createElement(EmojiPlaceholder, {
    size: fitToHeight || placeholderSize,
    shortName: shortName,
    showTooltip: showTooltip,
    representation: representation
  });
};
export default /*#__PURE__*/memo(CachingEmoji);