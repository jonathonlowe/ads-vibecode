import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import DuplicateLimitedQueue from './DuplicateLimitedQueue';
import debug from './logger';

/**
 * The options used to configure a newly constructed queue.
 */
/**
 * An extension to the DuplicateLimitedQueue that will initialise its contents from the
 * supplied Storage and will also update the storage for every new item enqueued.
 */
var StoredDuplicateLimitedQueue = /*#__PURE__*/function (_DuplicateLimitedQueu) {
  function StoredDuplicateLimitedQueue(options) {
    var _this;
    _classCallCheck(this, StoredDuplicateLimitedQueue);
    _this = _callSuper(this, StoredDuplicateLimitedQueue, [options]);
    _this.storage = options.storage;
    _this.prefixedStorageKey = "".concat(options.storagePrefix, ".").concat(StoredDuplicateLimitedQueue.storageKey);
    _this.load();
    return _this;
  }

  /**
   * Enqueue the supplied item and also persist the new contents of the queue to storage.
   *
   * @param item the item to be enqueued
   */
  _inherits(StoredDuplicateLimitedQueue, _DuplicateLimitedQueu);
  return _createClass(StoredDuplicateLimitedQueue, [{
    key: "enqueue",
    value: function enqueue(item) {
      _superPropGet(StoredDuplicateLimitedQueue, "enqueue", this, 3)([item]);
      this.save();
    }

    /**
     * Exposed for storybook/testing purposes only. Clear the contents of the queue, and localStorage.
     */
  }, {
    key: "clear",
    value: function clear() {
      _superPropGet(StoredDuplicateLimitedQueue, "clear", this, 3)([]);
      this.storage.removeItem(this.prefixedStorageKey);
    }

    /**
     * Initialise the queue contents from the configured Storage. If there is no data found in
     * storage then the queue will have no items added. Likewise, a failure to read or parse stored
     * data will be swallowed and no items are added to the queue.
     */
  }, {
    key: "load",
    value: function load() {
      var itemsJson = this.storage.getItem(this.prefixedStorageKey);
      if (itemsJson) {
        try {
          var items = JSON.parse(itemsJson);
          this.bulkEnqueue(items);
        } catch (e) {
          debug("Error parsing the queue stored as ".concat(this.prefixedStorageKey, " key from storage"), e);
        }
      }
    }

    /**
     * Save the current items in the queue, overwriting any previously stored queue.
     * Any failure in saving will be silently ignored with the likely outcome that any previous
     * saved items will remain unchanged in storage.
     */
  }, {
    key: "save",
    value: function save() {
      var itemsJson = JSON.stringify(this.getItems());
      try {
        this.storage.setItem(this.prefixedStorageKey, itemsJson);
      } catch (e) {
        debug("Error saving the queued items as ".concat(this.prefixedStorageKey), e);
      }
    }
  }]);
}(DuplicateLimitedQueue);
_defineProperty(StoredDuplicateLimitedQueue, "storageKey", 'lastUsed');
export { StoredDuplicateLimitedQueue as default };