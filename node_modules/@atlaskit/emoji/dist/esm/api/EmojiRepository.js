import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { Search, UnorderedSearchIndex } from 'js-search';
import { defaultCategories, frequentCategory } from '../util/constants';
import { getCategoryId, isEmojiDescriptionWithVariations } from '../util/type-helpers';
import { SearchSort } from '../types';
import { tokenizerRegex } from './EmojiRepositoryRegex';
import { createSearchEmojiComparator, createUsageOnlyEmojiComparator } from './internal/Comparators';
import { UsageFrequencyTracker } from './internal/UsageFrequencyTracker';
import { fg } from '@atlaskit/platform-feature-flags';
// FS-1097 - duplicated in mentions - extract at some point into a shared library
var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer() {
    _classCallCheck(this, Tokenizer);
  }
  return _createClass(Tokenizer, [{
    key: "tokenize",
    value: function tokenize(text) {
      return this.tokenizeAsTokens(text).map(function (token) {
        return token.token;
      });
    }
  }, {
    key: "tokenizeAsTokens",
    value: function tokenizeAsTokens(text) {
      var match;
      var tokens = [];
      tokenizerRegex.lastIndex = 0;
      while ((match = tokenizerRegex.exec(text)) !== null) {
        if (match[0]) {
          tokens.push({
            token: match[0],
            start: match.index
          });
        }
      }
      return tokens;
    }
  }]);
}();
var _addAllVariants = function addAllVariants(emoji, fnKey, map) {
  var key = fnKey(emoji);
  if (!map.has(key)) {
    map.set(key, []);
  }
  var emojisForKey = map.get(key);
  // Unnecessary, but typescript thinks it is. :/
  if (emojisForKey) {
    emojisForKey.push(emoji);
  }
  if (isEmojiDescriptionWithVariations(emoji)) {
    // map variations too
    var variations = emoji.skinVariations;
    if (variations) {
      variations.forEach(function (variation) {
        return _addAllVariants(variation, fnKey, map);
      });
    }
  }
};
var findByKey = function findByKey(map, key) {
  var emojis = map.get(key);
  if (emojis && emojis.length) {
    // Priority is always to source from the last emoji set (last overrides first)
    return emojis[emojis.length - 1];
  }
  return undefined;
};
var splitQuery = function splitQuery() {
  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var isColonQuery = query.indexOf(':') === 0;
  if (isColonQuery) {
    return {
      nameQuery: query.slice(1),
      asciiQuery: query
    };
  }
  return {
    nameQuery: query,
    asciiQuery: ''
  };
};
export var getEmojiVariation = function getEmojiVariation(emoji, options) {
  if (isEmojiDescriptionWithVariations(emoji) && options) {
    var skinTone = options.skinTone;
    if (skinTone && emoji.skinVariations && emoji.skinVariations.length) {
      var skinToneEmoji = emoji.skinVariations[skinTone - 1]; // skinTone start at 1
      if (skinToneEmoji) {
        return skinToneEmoji;
      }
    }
  }
  return emoji;
};
var findEmojiIndex = function findEmojiIndex(emojis, toFind) {
  var findId = toFind.id;
  var match = -1;
  emojis.forEach(function (emoji, index) {
    // Match if ID is defined and are equal
    // Or both have no id and shortnames match
    if (emoji.id && emoji.id === findId || !emoji.id && !findId && emoji.shortName === toFind.shortName) {
      match = index;
      return;
    }
  });
  return match;
};
var EmojiRepository = /*#__PURE__*/function () {
  // protected to allow subclasses to access (for testing and storybooks).

  function EmojiRepository(emojis, usageTracker) {
    _classCallCheck(this, EmojiRepository);
    _defineProperty(this, "fullSearchReady", false);
    this.emojis = emojis;
    this.initMembers(usageTracker);
  }

  /**
   * Returns all available (and searchable) emoji in some default order.
   */
  return _createClass(EmojiRepository, [{
    key: "all",
    value: function all() {
      var options = {
        sort: SearchSort.None
      };
      return this.search('', options);
    }

    /**
     * Text search of emoji shortName and name field for suitable matches.
     *
     * Returns an array of all (searchable) emoji if query is empty or null, otherwise returns matching emoji.
     *
     * You can change how the results are sorted by specifying a custom EmojiComparator in the SearchOptions. If
     * you don't want any sorting you can also disable via the SearchOptions (this might be a useful optimisation).
     * If no sort is specified in SearchOptions then a default sorting it applied based on the query.
     */
  }, {
    key: "search",
    value: function search(query, options) {
      var filteredEmoji = [];
      var _splitQuery = splitQuery(query),
        nameQuery = _splitQuery.nameQuery,
        asciiQuery = _splitQuery.asciiQuery;
      if (nameQuery) {
        filteredEmoji = this.getSearchIndex().search(nameQuery);
        if (asciiQuery) {
          filteredEmoji = this.withAsciiMatch(asciiQuery, filteredEmoji);
        }
      } else {
        filteredEmoji = this.getAllSearchableEmojis();
      }
      filteredEmoji = this.applySearchOptions(filteredEmoji, query, options);
      return {
        emojis: filteredEmoji,
        query: query
      };
    }

    /**
     * Returns all emoji with matching shortName
     */
  }, {
    key: "findAllMatchingShortName",
    value: function findAllMatchingShortName(shortName) {
      return this.shortNameMap.get(shortName) || [];
    }

    /**
     * Returns the first matching emoji matching the shortName, or null if none found.
     */
  }, {
    key: "findByShortName",
    value: function findByShortName(shortName) {
      return findByKey(this.shortNameMap, shortName);
    }

    /**
     * Returns the first matching emoji matching the id, or null if none found.
     */
  }, {
    key: "findById",
    value: function findById(id) {
      return findByKey(this.idMap, id);
    }
  }, {
    key: "findByAsciiRepresentation",
    value: function findByAsciiRepresentation(asciiEmoji) {
      return this.asciiMap.get(asciiEmoji);
    }
  }, {
    key: "findInCategory",
    value: function findInCategory(categoryId) {
      if (categoryId === frequentCategory) {
        return this.getFrequentlyUsed();
      } else {
        return this.all().emojis.filter(function (emoji) {
          return emoji.category === categoryId;
        });
      }
    }
  }, {
    key: "addUnknownEmoji",
    value: function addUnknownEmoji(emoji) {
      this.emojis = [].concat(_toConsumableArray(this.emojis), [emoji]);
      this.getSearchIndex().addDocuments([emoji]);
      this.addToMaps(emoji);
      this.addToDynamicCategories(emoji);
    }
  }, {
    key: "getAsciiMap",
    value: function getAsciiMap() {
      return this.asciiMap;
    }

    /**
     * Return the most frequently used emoji, ordered from most frequent to least frequent. Return an empty array if
     * there are none.
     *
     * @param options optional settings to be applied to the set of frequently used emoji
     */
  }, {
    key: "getFrequentlyUsed",
    value: function getFrequentlyUsed(options) {
      var _this = this;
      var emojiIds = this.usageTracker.getOrder();
      var emojiResult = emojiIds.map(function (id) {
        return _this.findById(id);
      }).filter(function (e) {
        return e !== undefined;
      });
      if (options) {
        emojiResult = this.applySearchOptions(emojiResult, '', options);
      }
      return emojiResult;
    }
  }, {
    key: "getDynamicCategoryList",
    value: function getDynamicCategoryList() {
      return this.dynamicCategoryList.slice();
    }

    /**
     * Call this on emoji usage to allow the EmojiRepository to track the usage of emoji (which could be useful
     * in sorting, etc).
     *
     * @param emoji the emoji that was just used
     */
  }, {
    key: "used",
    value: function used(emoji) {
      var _this2 = this;
      this.usageTracker.recordUsage(emoji);

      // If this is the first usage ensure that we update the dynamic categories.
      // This is done in a 'timeout' since the usageTracker call previously also happens in a timeout. This ensures that
      // the frequent category will not appear until the usage has been tracked (avoiding the possibility of an empty
      // frequent category being shown in the picker).
      if (this.dynamicCategoryList.indexOf(frequentCategory) === -1) {
        if (typeof window === 'undefined') {
          return;
        }
        window.setTimeout(function () {
          _this2.dynamicCategoryList.push(frequentCategory);
        });
      }
    }
  }, {
    key: "delete",
    value: function _delete(emoji) {
      var deletedIndex = findEmojiIndex(this.emojis, emoji);
      if (deletedIndex !== -1) {
        // Remove the deleted emojis from the internal list
        this.emojis.splice(deletedIndex, 1);
        // Reconstruct repository member variables
        this.initMembers(this.usageTracker);
      }
    }
  }, {
    key: "withAsciiMatch",
    value: function withAsciiMatch(ascii, emojis) {
      var result = emojis;
      var asciiEmoji = this.findByAsciiRepresentation(ascii);
      if (asciiEmoji) {
        // Ensures that the same emoji isn't already in the list
        // If it is, we give precedence to the ascii match
        result = emojis.filter(function (e) {
          return e.id !== asciiEmoji.id;
        });
        result = [asciiEmoji].concat(_toConsumableArray(result));
      }
      return result;
    }
  }, {
    key: "applySearchOptions",
    value: function applySearchOptions(emojis, query, options) {
      if (!options) {
        options = {};
      }
      if (options.sort === undefined) {
        options.sort = SearchSort.Default;
      }
      var comparator;
      if (options.sort === SearchSort.Default) {
        comparator = createSearchEmojiComparator(query, this.usageTracker.getOrder());
      } else if (options.sort === SearchSort.UsageFrequency) {
        comparator = createUsageOnlyEmojiComparator(this.usageTracker.getOrder());
      }
      if (comparator) {
        comparator.compare = comparator.compare.bind(comparator); // TODO bind at a better place
        emojis = emojis.sort(comparator.compare);
      }
      if (options.limit && options.limit > 0) {
        emojis = emojis.slice(0, options.limit);
      }
      if (options.skinTone) {
        return emojis.map(function (emoji) {
          return getEmojiVariation(emoji, options);
        });
      }
      return emojis;
    }
  }, {
    key: "initMembers",
    value: function initMembers(usageTracker) {
      this.usageTracker = usageTracker || new UsageFrequencyTracker();
      this.initRepositoryMetadata();
      if (!fg('platform_index_emoji_just_in_time')) {
        this.initSearchIndex();
      }
    }

    /**
     * Optimisation to initialise all map member variables in single loop over emojis
     */
  }, {
    key: "initRepositoryMetadata",
    value: function initRepositoryMetadata() {
      var _this3 = this;
      this.shortNameMap = new Map();
      this.idMap = new Map();
      this.asciiMap = new Map();
      var categorySet = new Set();
      this.emojis.forEach(function (emoji) {
        categorySet.add(emoji.category);
        _this3.addToMaps(emoji);
      });
      if (this.usageTracker.getOrder().length) {
        categorySet.add(frequentCategory);
      }
      this.dynamicCategoryList = Array.from(categorySet).filter(function (category) {
        return defaultCategories.indexOf(category) === -1;
      });
    }
  }, {
    key: "initSearchIndex",
    value: function initSearchIndex() {
      this.fullSearch = new Search('id');
      this.fullSearch.tokenizer = new Tokenizer();
      this.fullSearch.searchIndex = new UnorderedSearchIndex();
      this.fullSearch.addIndex('name');
      this.fullSearch.addIndex('shortName');
      this.fullSearch.addDocuments(this.getAllSearchableEmojis());
      this.fullSearchReady = true;
    }
  }, {
    key: "getSearchIndex",
    value: function getSearchIndex() {
      if (!this.fullSearchReady) {
        this.initSearchIndex();
      }
      return this.fullSearch;
    }
  }, {
    key: "getAllSearchableEmojis",
    value: function getAllSearchableEmojis() {
      return this.emojis.filter(function (emojiDescription) {
        return emojiDescription.searchable;
      });
    }
  }, {
    key: "addToMaps",
    value: function addToMaps(emoji) {
      var _this4 = this;
      // Give default value and assign higher weight to Atlassian emojis for logical order when sorting
      if (typeof emoji.order === 'undefined' || emoji.order === -1) {
        emoji.order = EmojiRepository.defaultEmojiWeight;
      }
      if (typeof emoji.id === 'undefined') {
        emoji.id = EmojiRepository.defaultEmojiWeight.toString();
      }
      _addAllVariants(emoji, function (e) {
        return e.shortName;
      }, this.shortNameMap);
      _addAllVariants(emoji, function (e) {
        return e.id;
      }, this.idMap);
      if (emoji.ascii) {
        emoji.ascii.forEach(function (a) {
          return _this4.asciiMap.set(a, emoji);
        });
      }
    }
  }, {
    key: "addToDynamicCategories",
    value: function addToDynamicCategories(emoji) {
      var category = getCategoryId(emoji);
      if (defaultCategories.indexOf(category) === -1 && this.dynamicCategoryList.indexOf(category) === -1) {
        this.dynamicCategoryList.push(category);
      }
    }
  }]);
}();
_defineProperty(EmojiRepository, "defaultEmojiWeight", 1000000);
export { EmojiRepository as default };