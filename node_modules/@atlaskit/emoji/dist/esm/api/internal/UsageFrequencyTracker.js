import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { isEmojiVariationDescription } from '../../util/type-helpers';
import { localStoragePrefix } from '../../util/constants';
import DuplicateLimitedQueue from '../../util/DuplicateLimitedQueue';
import StoredDuplicateLimitedQueue from '../../util/StoredDuplicateLimitedQueue';
import storageAvailable from '../../util/storage-available';

/**
 * Keeps track of the last 150 emoji usages, although limiting the maximum count for a single emoji to 25 to
 * ensure we don't end up with only a single emoji being recorded. Usage is persisted to local storage for
 * consistency between 'sessions'.
 *
 * Skin tone variations for an emoji will be 'collapsed' so they are tracked as their base emoji. Gender
 * variations are not collapsed in this way and will be tracked per gender. This decision reflects the UI of
 * the EmojiPicker component.
 */
export var UsageFrequencyTracker = /*#__PURE__*/function () {
  function UsageFrequencyTracker() {
    var useStorageIfPossible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    _classCallCheck(this, UsageFrequencyTracker);
    var options = UsageFrequencyTracker.queueOptions;
    if (useStorageIfPossible && options.storage) {
      var queueOptions = _objectSpread(_objectSpread({}, options), {}, {
        storage: options.storage
      });
      this.queue = new StoredDuplicateLimitedQueue(queueOptions);
    } else {
      this.queue = new DuplicateLimitedQueue(options);
    }
    this.gateway = new Gateway(10);
  }

  /**
   * Record the fact that the supplied emoji was used. You should note that usage is updated asynchronously so you can not
   * count on getOrder() reflecting this usage immediately.
   *
   * @param emoji the emoji who's usage is to be recorded. If the emoji has no id then no usage will be recorded
   */
  return _createClass(UsageFrequencyTracker, [{
    key: "recordUsage",
    value: function recordUsage(emoji) {
      var _this = this;
      var emojiId = emoji.id;
      if (emojiId) {
        if (isEmojiVariationDescription(emoji)) {
          emojiId = emoji.baseId;
        }
        this.gateway.submit(function () {
          if (emojiId) {
            _this.queue.enqueue(emojiId);
          }
        });
      }
    }

    /**
     * Returns an array of emoji id (without skin tone variations) sorted by most used to least used. If there
     * are no usages then an empty array will be returned.
     */
  }, {
    key: "getOrder",
    value: function getOrder() {
      return this.queue.getItemsOrderedByDuplicateCount();
    }

    /**
     * Exposed for testing only. Clear any recorded usage.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.queue.clear();
    }
  }]);
}();
_defineProperty(UsageFrequencyTracker, "queueOptions", {
  storage: storageAvailable('localStorage') ? window.localStorage : undefined,
  storagePrefix: localStoragePrefix,
  maxDuplicates: 25,
  minUniqueItems: 5
});
export var Gateway = /*#__PURE__*/function () {
  function Gateway(maximumPermitted) {
    _classCallCheck(this, Gateway);
    if (maximumPermitted < 1) {
      throw new RangeError('The maximumPermitted parameter must be 1 or more.');
    }
    this.maximumPermitted = maximumPermitted;
    this.count = 0;
  }

  /**
   * Run the supplied function if the count of already submitted work allows it. Drop the work
   * if it's not allowed to run.
   *
   * Will return true if the function has been submitted or false if it was not submitted.
   */
  return _createClass(Gateway, [{
    key: "submit",
    value: function submit(f) {
      var _this2 = this;
      if (this.count >= this.maximumPermitted) {
        return false;
      }
      this.count++;
      var wrappedFunc = function wrappedFunc() {
        try {
          f();
        } finally {
          _this2.completed();
        }
      };
      if (typeof window !== 'undefined') {
        window.setTimeout(wrappedFunc);
      }
      return true;
    }
  }, {
    key: "completed",
    value: function completed() {
      this.count--;
    }
  }]);
}();