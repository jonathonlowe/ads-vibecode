import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _construct from "@babel/runtime/helpers/construct";
import { MAX_ORDINAL } from '../../util/constants';
import { isEmojiVariationDescription } from '../../util/type-helpers';
/**
 * Create the default sort comparator to be used for the user queries against emoji
 *
 * @param query the query used in the search to be sorted. Any colons will be stripped from the query and it will be
 * converted to lowercase.
 * @param orderedIds the id of emoji ordered by how frequently they are used
 */
export function createSearchEmojiComparator(query, orderedIds) {
  var textQuery = query ? query.replace(/:/g, '').toLowerCase().trim() : undefined;
  var comparators = [];
  if (query) {
    comparators.push(new AsciiMatchComparator(query));
  }

  // Add the comparators to the 'chain'. The order of adding each comparator is important to the sort that is applied by the
  // ChainedEmojiComparator. (Which is why you may see the same 'if' a few times.)

  if (textQuery) {
    comparators.push(new ExactShortNameMatchComparator(textQuery));
  }
  if (orderedIds && orderedIds.length) {
    comparators.push(new UsageFrequencyComparator(orderedIds));
  }
  if (textQuery) {
    comparators.push(new QueryStringPositionMatchComparator(textQuery, 'shortName'), new QueryStringPositionMatchComparator(textQuery, 'name'));
  }
  comparators.push(OrderComparator.Instance, AlphabeticalShortnameComparator.Instance);
  var comparator = _construct(ChainedEmojiComparator, comparators);
  comparator.compare = comparator.compare.bind(comparator);
  return comparator;
}
export function createUsageOnlyEmojiComparator(orderedIds) {
  var comparator = new ChainedEmojiComparator(new UsageFrequencyComparator(orderedIds), new EmojiTypeComparator(), OrderComparator.Instance);
  comparator.compare = comparator.compare.bind(comparator);
  return comparator;
}

/**
 * Returns a number representing the result of comparing e1 and e2.
 * Compatible with Array.sort, which is to say -
 *   - less than 0 if e1 should come first
 *   - 0 if they are equal; e1 and e2 will be unchanged in position relative to each other
 *   - greater than 0 if e2 should come first.
 */

/**
 * A combinator comparator that applies an ordered chained of sub-comparators. The first comparator that
 * returns a non-zero value stops the chain and causes that value to be returned. If a comparator returns a
 * zero then the next one in the chain is tried.
 *
 * If no comparators in the chain return a non-zero value then zero will be returned.
 */
export var ChainedEmojiComparator = /*#__PURE__*/function () {
  function ChainedEmojiComparator() {
    _classCallCheck(this, ChainedEmojiComparator);
    for (var _len = arguments.length, comparators = new Array(_len), _key = 0; _key < _len; _key++) {
      comparators[_key] = arguments[_key];
    }
    this.chain = comparators;
  }
  return _createClass(ChainedEmojiComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      for (var i = 0; i < this.chain.length; i++) {
        var result = this.chain[i].compare(e1, e2);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    }
  }]);
}();

/**
 * Orders two emoji such that if one of them has an ascii representation that exactly matches the query then it will
 * be ordered first.
 */
export var AsciiMatchComparator = /*#__PURE__*/function () {
  function AsciiMatchComparator(query) {
    _classCallCheck(this, AsciiMatchComparator);
    this.query = query;
  }
  return _createClass(AsciiMatchComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      var e1HasAscii = e1.ascii && e1.ascii.indexOf(this.query) !== -1;
      var e2HasAscii = e2.ascii && e2.ascii.indexOf(this.query) !== -1;
      if (e1HasAscii && !e2HasAscii) {
        return -1;
      } else if (!e1HasAscii && e2HasAscii) {
        return 1;
      }
      return 0;
    }
  }]);
}();

/**
 * Orders two emoji such that the one who's shortname matches the query exactly comes first. If there are matching
 * shortnames then the type of emoji is taken into account with SITE emoji coming first.
 */
export var ExactShortNameMatchComparator = /*#__PURE__*/function () {
  function ExactShortNameMatchComparator(query) {
    _classCallCheck(this, ExactShortNameMatchComparator);
    this.colonQuery = ":".concat(query, ":");
    this.typeComparator = new EmojiTypeComparator(true);
  }
  return _createClass(ExactShortNameMatchComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      if (e1.shortName === this.colonQuery && e2.shortName === this.colonQuery) {
        return this.typeComparator.compare(e1, e2);
      } else if (e1.shortName === this.colonQuery) {
        return -1;
      } else if (e2.shortName === this.colonQuery) {
        return 1;
      }
      return 0;
    }
  }]);
}();

/**
 * Orders two emoji based on their type, with the types being STANDARD, ATLASSIAN and SITE (in that order).
 * If the comparator is configured to 'reverse' then the order will be SITE, ATLASSIAN, STANDARD.
 *
 * Regardless of the reverse setting, an unknown type will always come last.
 */
export var EmojiTypeComparator = /*#__PURE__*/function () {
  function EmojiTypeComparator(reverse) {
    _classCallCheck(this, EmojiTypeComparator);
    if (reverse) {
      this.typeToNumber = new Map([['SITE', 0], ['ATLASSIAN', 1], ['STANDARD', 2]]);
    } else {
      this.typeToNumber = new Map([['STANDARD', 0], ['ATLASSIAN', 1], ['SITE', 2]]);
    }
  }
  return _createClass(EmojiTypeComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      return this.emojiTypeToOrdinal(e1) - this.emojiTypeToOrdinal(e2);
    }
  }, {
    key: "emojiTypeToOrdinal",
    value: function emojiTypeToOrdinal(emoji) {
      var ordinal = this.typeToNumber.get(emoji.type);
      if (ordinal === undefined) {
        ordinal = 10;
      }
      return ordinal;
    }
  }]);
}();

/**
 * Order two emoji such as the one which is more frequently used comes first. If neither have any usage
 * information then leave their order unchanged.
 */
export var UsageFrequencyComparator = /*#__PURE__*/function () {
  // A Map of emoji base Id to their order in a least of most frequently used

  function UsageFrequencyComparator(orderedIds) {
    var _this = this;
    _classCallCheck(this, UsageFrequencyComparator);
    this.positionLookup = new Map();
    // Make ordering start from 1 to avoid having zero in the map (which is falsey)
    orderedIds.map(function (id, index) {
      return _this.positionLookup.set(id, index + 1);
    });
  }
  return _createClass(UsageFrequencyComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      if (!e1.id || !e2.id) {
        return 0; // this shouldn't occur. Leave position unchanged if there is any missing id.
      }
      var i1 = this.getPositionInOrder(e1);
      var i2 = this.getPositionInOrder(e2);
      return i1 - i2;
    }

    /**
     * Get the ordinal representing the position of this emoji.
     *
     * @param id the id of the emoji
     */
  }, {
    key: "getPositionInOrder",
    value: function getPositionInOrder(emoji) {
      var id = emoji.id ? emoji.id : '0';
      if (isEmojiVariationDescription(emoji)) {
        id = emoji.baseId;
      }
      var position = this.positionLookup.get(id);
      if (position) {
        return position;
      } else {
        return MAX_ORDINAL;
      }
    }
  }]);
}();
/**
 * A comparator that will sort higher an emoji which matches the query string earliest in the indicated
 * property.
 */
export var QueryStringPositionMatchComparator = /*#__PURE__*/function () {
  /**
   * @param query the query to match
   * @param propertyToCompare the property of EmojiDescription to check for query within
   */
  function QueryStringPositionMatchComparator(query, propertyToCompare) {
    _classCallCheck(this, QueryStringPositionMatchComparator);
    this.query = query;
    if (!propertyToCompare) {
      throw new Error('propertyToCompare is required');
    }
    this.propertyName = propertyToCompare;
  }
  return _createClass(QueryStringPositionMatchComparator, [{
    key: "getScore",
    value: function getScore(emoji) {
      // It is fine to do override the null check here because we are checking
      // it on the constructor.
      var propertyValue = emoji[this.propertyName];
      var score = propertyValue ? propertyValue.indexOf(this.query) : MAX_ORDINAL;
      return score === -1 ? MAX_ORDINAL : score;
    }
  }, {
    key: "compare",
    value: function compare(e1, e2) {
      return this.getScore(e1) - this.getScore(e2);
    }
  }]);
}();
export var OrderComparator = /*#__PURE__*/function () {
  function OrderComparator() {
    _classCallCheck(this, OrderComparator);
  }
  return _createClass(OrderComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      var o1 = e1.order ? e1.order : MAX_ORDINAL;
      var o2 = e2.order ? e2.order : MAX_ORDINAL;
      return o1 - o2;
    }
  }], [{
    key: "Instance",
    get: function get() {
      return this.INSTANCE || (this.INSTANCE = new this());
    }
  }]);
}();
export var AlphabeticalShortnameComparator = /*#__PURE__*/function () {
  function AlphabeticalShortnameComparator() {
    _classCallCheck(this, AlphabeticalShortnameComparator);
  }
  return _createClass(AlphabeticalShortnameComparator, [{
    key: "compare",
    value: function compare(e1, e2) {
      return e1.shortName.localeCompare(e2.shortName);
    }
  }], [{
    key: "Instance",
    get: function get() {
      return this.INSTANCE || (this.INSTANCE = new this());
    }
  }]);
}();