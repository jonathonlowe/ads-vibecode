import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { convertMediaToImageEmoji, isMediaRepresentation, isPromise } from '../../util/type-helpers';
import MediaImageLoader from './MediaImageLoader';
import debug from '../../util/logger';
import { LRUMap } from 'lru_map';
var getRequiredRepresentation = function getRequiredRepresentation(emoji, useAlt) {
  return useAlt ? emoji.altRepresentation : emoji.representation;
};
var isUnsupportedBrowser = function isUnsupportedBrowser() {
  var isIE = /*@cc_on!@*/false || !!document.documentMode; // Internet Explorer 6-11
  var isEdge = !isIE && !!window.StyleMedia; // Edge 20+

  return isIE || isEdge;
};
/**
 * For browsers that support caching for resources
 * regardless of originally supplied headers (basically everything but Firefox).
 */
export var BrowserCacheStrategy = /*#__PURE__*/function () {
  function BrowserCacheStrategy(mediaImageLoader) {
    _classCallCheck(this, BrowserCacheStrategy);
    _defineProperty(this, "cachedImageUrls", new Set());
    debug('BrowserCacheStrategy');
    this.mediaImageLoader = mediaImageLoader;
  }
  return _createClass(BrowserCacheStrategy, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var _this = this;
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!isMediaRepresentation(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      if (this.cachedImageUrls.has(mediaPath)) {
        // Already cached
        return emoji;
      }
      return this.mediaImageLoader.loadMediaImage(mediaPath).then(function () {
        // Media is loaded, can use original URL now, so just return original emoji
        _this.cachedImageUrls.add(mediaPath);
        return emoji;
      }).catch(function () {
        return undefined;
      });
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering() {
      return true;
    }
  }], [{
    key: "supported",
    value: function supported(mediaPath, mediaImageLoader) {
      // IE/Edge uses memory cache strategy else images can fail to load
      // from a clean cache/if they are downloaded from the service
      // TODO: fix as a part of FS-1592
      if (isUnsupportedBrowser()) {
        return Promise.resolve(false);
      }
      return mediaImageLoader.loadMediaImage(mediaPath).then(function () {
        return (
          // Image should be cached in browser, if supported it should be accessible from the cache by an <img/>
          // Try to load without via image to confirm this support (this fails in Firefox)
          new Promise(function (resolve) {
            var img = new Image();
            img.addEventListener('load', function () {
              resolve(true);
            });
            img.addEventListener('error', function () {
              resolve(false);
            });
            img.src = mediaPath;
          })
        );
      }).catch(function () {
        return false;
      });
    }
  }]);
}();
var maxImageCached = 1000;
// Don't cache images large than this - dataUrl size in characters
var maxImageSize = 10000;

/**
 * For browsers that do no cache images without equivalent headers (e.g. Firefox).
 *
 * Images are cached in memory in a LRU cache. Images considered too large,
 * are not cached, but retrieved each time.
 *
 * Images are still cached by the browser, but loading in asynchronous with
 * small delay noticable to the end user.
 */
export var MemoryCacheStrategy = /*#__PURE__*/function () {
  function MemoryCacheStrategy(mediaImageLoader) {
    _classCallCheck(this, MemoryCacheStrategy);
    debug('MemoryCacheStrategy');
    this.mediaImageLoader = mediaImageLoader;
    this.dataURLCache = new LRUMap(maxImageCached);
  }
  return _createClass(MemoryCacheStrategy, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var _this2 = this;
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!isMediaRepresentation(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      var dataURL = this.dataURLCache.get(mediaPath);
      if (dataURL) {
        // Already cached
        return convertMediaToImageEmoji(emoji, dataURL, useAlt);
      }

      // Not cached, load
      return this.mediaImageLoader.loadMediaImage(mediaPath).then(function (dataURL) {
        var loadedEmoji = convertMediaToImageEmoji(emoji, dataURL, useAlt);
        if (dataURL.length <= maxImageSize) {
          // Only cache if not large than max size
          _this2.dataURLCache.set(mediaPath, dataURL);
        } else {
          debug('No caching as image is too large', dataURL.length, dataURL.slice(0, 15), emoji.shortName);
        }
        return loadedEmoji;
      }).catch(function () {
        return undefined;
      });
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering() {
      return false;
    }
  }]);
}();

/**
 * Provides a cache for Media Emoji.
 *
 * Emoji are returned immediately if cached and ready to use by the browser.
 *
 * Otherwise, they are loaded and returned via a promise.
 */
var MediaEmojiCache = /*#__PURE__*/function () {
  function MediaEmojiCache(tokenManager) {
    _classCallCheck(this, MediaEmojiCache);
    _defineProperty(this, "waitingInitUrls", []);
    debug('MediaEmojiCache');
    this.mediaImageLoader = new MediaImageLoader(tokenManager);
  }
  return _createClass(MediaEmojiCache, [{
    key: "loadEmoji",
    value: function loadEmoji(emoji, useAlt) {
      var representation = getRequiredRepresentation(emoji, useAlt);
      if (!isMediaRepresentation(representation)) {
        return emoji;
      }
      var mediaPath = representation.mediaPath;
      var emojiCache = this.getCache(mediaPath);
      if (isPromise(emojiCache)) {
        // Promise based
        return emojiCache.then(function (cache) {
          return cache.loadEmoji(emoji, useAlt);
        }).catch(function () {
          return undefined;
        });
      }
      return emojiCache.loadEmoji(emoji, useAlt);
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering(url) {
      var emojiCache = this.getCache(url);
      if (isPromise(emojiCache)) {
        // Promise based
        return emojiCache.then(function (cache) {
          return cache.optimisticRendering();
        }).catch(function () {
          return false;
        });
      }
      return emojiCache.optimisticRendering();
    }
  }, {
    key: "getCache",
    value: function getCache(url) {
      var _this3 = this;
      if (this.cache) {
        return this.cache;
      }
      this.waitingInitUrls.push(url);
      if (!this.cacheLoading) {
        this.cacheLoading = this.initCache().then(function (cache) {
          _this3.cache = cache;
          _this3.cacheLoading = undefined;
          return cache;
        }).catch(function (err) {
          _this3.cacheLoading = undefined;
          throw err;
        });
      }
      return this.cacheLoading;
    }
  }, {
    key: "initCache",
    value: function initCache() {
      var _this4 = this;
      var url = this.waitingInitUrls.pop();
      if (!url) {
        return Promise.reject('Unable to initialise cache based on provided url(s)');
      }
      return BrowserCacheStrategy.supported(url, this.mediaImageLoader).then(function (supported) {
        _this4.waitingInitUrls = []; // clear
        _this4.cacheLoading = undefined;
        if (supported) {
          return new BrowserCacheStrategy(_this4.mediaImageLoader);
        }
        return new MemoryCacheStrategy(_this4.mediaImageLoader);
      }).catch(function () {
        return _this4.initCache();
      });
    }
  }]);
}();
export { MediaEmojiCache as default };