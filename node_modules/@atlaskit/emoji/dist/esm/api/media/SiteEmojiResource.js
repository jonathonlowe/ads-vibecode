import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["altRepresentations"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { utils as serviceUtils } from '@atlaskit/util-service-support';
import { getMediaClient } from '@atlaskit/media-client-react';
import { buildEmojiDescriptionWithAltRepresentation, isMediaRepresentation, isMediaEmoji, convertImageToMediaRepresentation, isLoadedMediaEmoji } from '../../util/type-helpers';
import MediaEmojiCache from './MediaEmojiCache';
import { denormaliseEmojiServiceResponse, emojiRequest, getAltRepresentation } from '../EmojiUtils';
import TokenManager from './TokenManager';
import debug from '../../util/logger';
// Assume media is 95% of total upload time.
export var mediaProportionOfProgress = 95 / 100;
var SiteEmojiResource = /*#__PURE__*/function () {
  // @ts-ignore: I am not being read from, should I be deleted???

  function SiteEmojiResource(siteServiceConfig, mediaApiToken) {
    var _this = this;
    _classCallCheck(this, SiteEmojiResource);
    _defineProperty(this, "postToEmojiService", function (upload, fileId) {
      var shortName = upload.shortName,
        name = upload.name;
      var width = upload.width,
        height = upload.height;
      var requestInit = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          shortName: shortName,
          name: name,
          width: width,
          height: height,
          fileId: fileId
        })
      };
      return serviceUtils.requestService(_this.siteServiceConfig, {
        requestInit: requestInit
      }).then(function (response) {
        var emojis = response.emojis;
        if (emojis.length) {
          var _emojis$ = emojis[0],
            altRepresentations = _emojis$.altRepresentations,
            emoji = _objectWithoutProperties(_emojis$, _excluded);
          var _response = _objectSpread(_objectSpread({}, emoji), {}, {
            representation: convertImageToMediaRepresentation(emoji.representation)
          });
          var altRepresentation = getAltRepresentation(altRepresentations || {});
          var imgAltRepresentation = altRepresentation ? convertImageToMediaRepresentation(altRepresentation) : undefined;
          return buildEmojiDescriptionWithAltRepresentation(_response, imgAltRepresentation);
        }
        throw new Error('No emoji returns from upload. Upload failed.');
      });
    });
    this.siteServiceConfig = siteServiceConfig;
    this.mediaApiToken = mediaApiToken;
    this.tokenManager = new TokenManager(siteServiceConfig);
    this.tokenManager.addToken('read', mediaApiToken);
    this.mediaEmojiCache = new MediaEmojiCache(this.tokenManager);
  }

  /**
   * Will generate an emoji media path that is inclusive of client and token within the query parameter for media representation and altRepresentation
   */
  return _createClass(SiteEmojiResource, [{
    key: "generateTokenisedMediaURLS",
    value: (function () {
      var _generateTokenisedMediaURLS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(representation, altRepresentation) {
        var readToken;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (isMediaRepresentation(representation)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", {
                representation: representation,
                altRepresentation: altRepresentation
              });
            case 2:
              _context.prev = 2;
              _context.next = 5;
              return this.tokenManager.getToken('read');
            case 5:
              readToken = _context.sent;
              return _context.abrupt("return", Object.entries({
                representation: representation,
                altRepresentation: altRepresentation
              }).reduce(function (acc, _ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                  key = _ref2[0],
                  value = _ref2[1];
                if (value && isMediaRepresentation(value)) {
                  var path = new URL(value.mediaPath);
                  var params = path.searchParams;
                  if (params.get('token') !== readToken.jwt) {
                    params.set('token', readToken.jwt);
                  }
                  if (params.get('client') !== readToken.clientId) {
                    params.set('client', readToken.clientId);
                  }
                  acc[key] = _objectSpread(_objectSpread({}, value), {}, {
                    mediaPath: path.toString()
                  });
                }
                return acc;
              }, {
                representation: representation,
                altRepresentation: altRepresentation
              }));
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              return _context.abrupt("return", {
                representation: representation,
                altRepresentation: altRepresentation
              });
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 9]]);
      }));
      function generateTokenisedMediaURLS(_x, _x2) {
        return _generateTokenisedMediaURLS.apply(this, arguments);
      }
      return generateTokenisedMediaURLS;
    }()
    /**
     * Will load media emoji, returning a new EmojiDescription if, for example,
     * the URL has changed.
     */
    )
  }, {
    key: "loadMediaEmoji",
    value: function loadMediaEmoji(emoji, useAlt) {
      if (!isMediaEmoji(emoji)) {
        throw new Error('Only supported for media emoji');
      }
      return this.mediaEmojiCache.loadEmoji(emoji, useAlt);
    }
  }, {
    key: "optimisticRendering",
    value: function optimisticRendering(emoji, useAlt) {
      var representation = useAlt ? emoji.altRepresentation : emoji.representation;
      if (!isMediaRepresentation(representation)) {
        throw new Error('Only supported for media emoji');
      }
      var mediaPath = representation.mediaPath;
      return this.mediaEmojiCache.optimisticRendering(mediaPath);
    }
  }, {
    key: "uploadEmoji",
    value: function uploadEmoji(upload) {
      var _this2 = this;
      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;
      var startTime = Date.now();
      return this.tokenManager.getToken('upload', retry).then(function (uploadToken) {
        var tokenLoadTime = Date.now() - startTime;
        debug('upload token load time', tokenLoadTime);
        return new Promise(function (resolve, reject) {
          var url = uploadToken.url,
            clientId = uploadToken.clientId,
            collectionName = uploadToken.collectionName;
          var mediaClient = getMediaClient({
            authProvider: function authProvider() {
              return Promise.resolve({
                clientId: clientId,
                token: uploadToken.jwt,
                baseUrl: url
              });
            },
            useSha256ForUploads: true
          });
          var subscription = mediaClient.file.upload({
            content: upload.dataURL,
            name: upload.filename,
            collection: collectionName
          }).subscribe({
            next: function next(state) {
              if (state.status === 'uploading' && progressCallback) {
                progressCallback({
                  percent: state.progress * mediaProportionOfProgress
                });
              } else if (state.status === 'processing' || state.status === 'processed') {
                subscription.unsubscribe();
                var totalUploadTime = Date.now() - startTime;
                var mediaUploadTime = totalUploadTime - tokenLoadTime;
                debug('total upload / media upload times', totalUploadTime, mediaUploadTime);
                _this2.postToEmojiService(upload, state.id).then(function (emoji) {
                  resolve(emoji);
                }).catch(function (httpError) {
                  reject(httpError.reason || httpError);
                });
              }
            },
            error: function error(_error) {
              reject(_error);
            }
          });
        });
      });
    }

    /**
     * Check if the MediaEmojiResource has been able to initialise an uploadToken. Retrieving an upload token
     * is asynchronous so the Promise will need to resolve before the state is known. If the token retrieval
     * completes with failure then the Promise will resolve to false.
     */
  }, {
    key: "hasUploadToken",
    value: function hasUploadToken() {
      var tokenPromise = this.tokenManager.getToken('upload');
      return tokenPromise.then(function (token) {
        return token !== undefined;
      }, function () {
        return false;
      });
    }
  }, {
    key: "prepareForUpload",
    value: function prepareForUpload() {
      // make sure a token is loaded from the emoji service if we don't have one
      // as future request to uploadEmoji will use this, this to preload it, as it
      // usually takes 1-2 seconds to generate
      this.tokenManager.getToken('upload');
    }
  }, {
    key: "findEmoji",
    value: function findEmoji(emojiId) {
      if (!emojiId.id) {
        return Promise.reject(false);
      }
      var path = "../".concat(encodeURIComponent(emojiId.id));
      return emojiRequest(this.siteServiceConfig, {
        path: path
      }).then(function (serviceResponse) {
        var response = denormaliseEmojiServiceResponse(serviceResponse);
        return response.emojis[0];
      }).catch(function (error) {
        debug('failed to load emoji', emojiId, error);
        return undefined;
      });
    }

    /**
     * Calls to site-scoped EmojiResource to delete emoji
     * @param emoji media emoji to delete
     * @returns Promise.resolve() if success and Promise.reject() for failure
     */
  }, {
    key: "deleteEmoji",
    value: function deleteEmoji(emoji) {
      if (!isMediaEmoji(emoji) && !isLoadedMediaEmoji(emoji)) {
        return Promise.reject(false);
      }
      if (!emoji.id) {
        return Promise.reject(false);
      }
      var path = "".concat(encodeURIComponent(emoji.id));
      var requestInit = {
        method: 'DELETE'
      };
      return serviceUtils.requestService(this.siteServiceConfig, {
        path: path,
        requestInit: requestInit
      })
      // Successful delete on Promise.resolve
      .then(function () {
        return true;
      })
      // Unsuccessful delete on Promise.reject
      .catch(function () {
        return false;
      });
    }
  }]);
}();
export { SiteEmojiResource as default };