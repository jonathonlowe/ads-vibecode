import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { imageAcceptHeader } from '../../util/image';
var defaultConcurrentDownloadLimit = 16;
var backoffMaxDelayInMillis = 600;
var defaultMaxRetriesOnNotFound = 2;
var MediaImageLoader = /*#__PURE__*/function () {
  function MediaImageLoader(tokenManager, options) {
    _classCallCheck(this, MediaImageLoader);
    _defineProperty(this, "mediaImageQueue", []);
    _defineProperty(this, "activeProcessing", 0);
    _defineProperty(this, "pendingRequests", new Map());
    this.concurrentDownloadLimit = options && options.concurrentDownloadLimit || defaultConcurrentDownloadLimit;
    this.tokenManager = tokenManager;
  }
  return _createClass(MediaImageLoader, [{
    key: "loadMediaImage",
    value: function loadMediaImage(url) {
      var _this = this;
      var maybePending = this.pendingRequests.get(url);
      if (maybePending !== undefined) {
        return maybePending;
      }
      var pending = new Promise(function (resolve, reject) {
        _this.mediaImageQueue.push({
          url: url,
          resolve: resolve,
          reject: reject
        });
        _this.processFromQueue();
      }).then(function (result) {
        _this.pendingRequests.delete(url);
        return result;
      }).catch(function (error) {
        _this.pendingRequests.delete(url);
        throw error;
      });
      this.pendingRequests.set(url, pending);
      return pending;
    }
  }, {
    key: "getQueueSize",
    value: function getQueueSize() {
      return this.mediaImageQueue.length;
    }
  }, {
    key: "getActiveDownloads",
    value: function getActiveDownloads() {
      return this.activeProcessing;
    }
  }, {
    key: "processFromQueue",
    value: function processFromQueue() {
      var _this2 = this;
      var _loop = function _loop() {
        _this2.activeProcessing++;
        var item = _this2.mediaImageQueue.shift();
        var url = item.url,
          resolve = item.resolve,
          reject = item.reject;
        _this2.tokenManager.getToken('read', false).then(function (token) {
          _this2.requestMediaEmoji(url, token, true).then(function (dataURL) {
            resolve(dataURL);
            _this2.completedItem();
          }).catch(function (error) {
            reject(error);
            _this2.completedItem();
          });
        }).catch(function (error) {
          // Failed to load, just resolve to original emoji
          reject(error);
          _this2.completedItem();
        });
      };
      while (this.activeProcessing < this.concurrentDownloadLimit && this.mediaImageQueue.length > 0) {
        _loop();
      }
    }
  }, {
    key: "completedItem",
    value: function completedItem() {
      this.activeProcessing--;
      this.processFromQueue();
    }
  }, {
    key: "delay",
    value: function delay(durationInMillis) {
      return new Promise(function (resolve) {
        return setTimeout(resolve, durationInMillis);
      });
    }
  }, {
    key: "requestMediaEmoji",
    value: function requestMediaEmoji(url, token, retryOnAuthError) {
      var _this3 = this;
      var retriesOnNotFound = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultMaxRetriesOnNotFound;
      return imageAcceptHeader().then(function (acceptHeader) {
        // Media REST API: https://media-api-internal.atlassian.io/api.html#file__fileId__image_get
        var options = {
          headers: {
            Authorization: "Bearer ".concat(token.jwt),
            'X-Client-Id': token.clientId,
            Accept: acceptHeader
          }
        };
        return fetch(url, options).then(function (response) {
          // retry if 404
          if (response.status === 404 && retriesOnNotFound > 0) {
            return _this3.delay(backoffMaxDelayInMillis / retriesOnNotFound) // backoff strategy
            .then(function () {
              return _this3.requestMediaEmoji(url, token, false, retriesOnNotFound - 1);
            });
          } else if (response.status === 403 && retryOnAuthError) {
            // retry once if 403
            return _this3.tokenManager.getToken('read', true).then(function (newToken) {
              return _this3.requestMediaEmoji(url, newToken, false);
            });
          } else if (response.ok) {
            return response.blob().then(function (blob) {
              return _this3.readBlob(blob);
            });
          }
          throw new Error("Unable to load media image. Status=".concat(response.status, " ").concat(response.statusText));
        });
      });
    }
  }, {
    key: "readBlob",
    value: function readBlob(blob) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();

        // TODO: [ts30] Add proper handling for null and ArrayBuffer
        reader.addEventListener('load', function () {
          return resolve(reader.result);
        });
        reader.addEventListener('error', function () {
          return reject(reader.error);
        });
        reader.readAsDataURL(blob);
      });
    }
  }]);
}();
export { MediaImageLoader as default };