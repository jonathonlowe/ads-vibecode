import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _get from "@babel/runtime/helpers/get";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
import { AbstractResource, utils as serviceUtils } from '@atlaskit/util-service-support';
import { SAMPLING_RATE_EMOJI_RESOURCE_FETCHED_EXP, selectedToneStorageKey } from '../util/constants';
import debug from '../util/logger';
import { isMediaEmoji, isPromise, toEmojiId } from '../util/type-helpers';
import storageAvailable from '../util/storage-available';
import { ProviderTypes } from '../types';
import EmojiLoader from './EmojiLoader';
import EmojiRepository from './EmojiRepository';
import SiteEmojiResource from './media/SiteEmojiResource';
import { sampledUfoEmojiResourceFetched, ufoExperiences } from '../util/analytics/ufoExperiences';
import { promiseWithTimeout } from '../util/timed-promise';

// Re-exporting to not cause a breaking change
// Re-exporting to not cause a breaking change

/**
 * Checks if the emojiProvider can support uploading at a feature level.
 *
 * Follow this up with an isUploadSupported() check to see if the provider is actually
 * configured to support uploads.
 * https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates
 */
export var supportsUploadFeature = function supportsUploadFeature(emojiProvider) {
  var emojiUploadProvider = emojiProvider;
  return !!emojiUploadProvider.isUploadSupported && !!emojiUploadProvider.uploadCustomEmoji && !!emojiUploadProvider.prepareForUpload;
};
export var EmojiResource = /*#__PURE__*/function (_ref) {
  function EmojiResource(config) {
    var _this;
    _classCallCheck(this, EmojiResource);
    _this = _callSuper(this, EmojiResource);
    _defineProperty(_this, "activeLoaders", 0);
    _defineProperty(_this, "initialLoaders", 0);
    _defineProperty(_this, "retries", new Map());
    _defineProperty(_this, "isInitialised", false);
    _defineProperty(_this, "fetchOnDemand", false);
    _defineProperty(_this, "getOptimisticImageURL", function (emojiId) {
      if (_this.emojiProviderConfig.optimisticImageApi) {
        return _this.emojiProviderConfig.optimisticImageApi.getUrl(emojiId);
      }
      return;
    });
    _defineProperty(_this, "isRepositoryAvailable", function (repository) {
      return !!repository;
    });
    _defineProperty(_this, "isLoaded", function () {
      return _this.initialLoaders !== 0 && _this.activeLoaders === 0;
    });
    _this.emojiProviderConfig = config;
    _this.recordConfig = config.recordConfig;
    _this.currentUser = config.currentUser;
    if (storageAvailable('localStorage')) {
      _this.selectedTone = _this.loadStoredTone();
    }
    if (config.providers.length === 0) {
      throw new Error('No providers specified');
    }
    _this.fetchOnDemand = !!config.options && !!config.options.onlyFetchOnDemand;
    _this.initialLoaders = _this.emojiProviderConfig.providers.length;
    _this.activeLoaders = _this.emojiProviderConfig.providers.length;
    _this.emojiResponses = [];
    return _this;
  }

  /**
   * Get the emoji provider from Emoji Resource
   * @returns Promise<EmojiProvider>
   */
  _inherits(EmojiResource, _ref);
  return _createClass(EmojiResource, [{
    key: "getEmojiProvider",
    value: (function () {
      var _getEmojiProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var options,
          _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {
                fetchAtStart: !this.fetchOnDemand
              };
              if (!options.fetchAtStart) {
                _context.next = 11;
                break;
              }
              _context.prev = 2;
              _context.next = 5;
              return this.fetchEmojiProvider();
            case 5:
              _context.next = 11;
              break;
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](2);
              debug(_context.t0);
              return _context.abrupt("return", Promise.resolve(this));
            case 11:
              return _context.abrupt("return", Promise.resolve(this));
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 7]]);
      }));
      function getEmojiProvider() {
        return _getEmojiProvider.apply(this, arguments);
      }
      return getEmojiProvider;
    }())
  }, {
    key: "fetchIndividualProvider",
    value: function () {
      var _fetchIndividualProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(provider, index) {
        var providerType, loader, emojiResponse;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              providerType = this.getProviderType(provider);
              _context2.prev = 1;
              sampledUfoEmojiResourceFetched(providerType).start({
                samplingRate: SAMPLING_RATE_EMOJI_RESOURCE_FETCHED_EXP
              });
              sampledUfoEmojiResourceFetched(providerType).addMetadata({
                type: providerType
              });
              loader = new EmojiLoader(provider); // fetch emoji from provider url and denormalise
              _context2.next = 7;
              return loader.loadEmoji();
            case 7:
              emojiResponse = _context2.sent;
              sampledUfoEmojiResourceFetched(providerType).success();
              // setup emoji repository
              this.emojiResponses[index] = emojiResponse;
              this.initEmojiRepository(this.emojiResponses);
              _context2.next = 13;
              return this.initSiteEmojiResource(emojiResponse, provider);
            case 13:
              this.activeLoaders--;
              this.performRetries();
              this.refreshLastFilter();
              _context2.next = 25;
              break;
            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](1);
              this.activeLoaders--;
              this.notifyError(_context2.t0);
              sampledUfoEmojiResourceFetched(providerType).failure({
                metadata: {
                  reason: _context2.t0,
                  source: 'EmojiProvider',
                  providerUrl: provider.url
                }
              });
              debug("failed to fetch emoji provider for ".concat(provider.url), _context2.t0);
              throw new Error("failed to fetch emoji from ".concat(provider.url));
            case 25:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 18]]);
      }));
      function fetchIndividualProvider(_x, _x2) {
        return _fetchIndividualProvider.apply(this, arguments);
      }
      return fetchIndividualProvider;
    }()
  }, {
    key: "fetchEmojiProvider",
    value: function () {
      var _fetchEmojiProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;
        var force,
          _args3 = arguments;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              force = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;
              if (!(force || !this.isRepositoryAvailable(this.emojiRepository) && !this.isInitialised)) {
                _context3.next = 6;
                break;
              }
              this.isInitialised = true;
              this.emojiResponses = [];
              // fetch emoji providers
              _context3.next = 6;
              return Promise.all(this.emojiProviderConfig.providers.map(function (provider, index) {
                return _this2.fetchIndividualProvider(provider, index);
              }));
            case 6:
              return _context3.abrupt("return", Promise.resolve(this.emojiRepository));
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetchEmojiProvider() {
        return _fetchEmojiProvider.apply(this, arguments);
      }
      return fetchEmojiProvider;
    }()
  }, {
    key: "onlyFetchOnDemand",
    value: function onlyFetchOnDemand() {
      return this.fetchOnDemand;
    }
  }, {
    key: "fetchByEmojiId",
    value: function () {
      var _fetchByEmojiId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(emojiId, optimistic) {
        var _emoji, provider, loader, loadEmoji, _emoji2, emoji;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository))) {
                _context4.next = 8;
                break;
              }
              _context4.next = 3;
              return this.findByEmojiId(emojiId);
            case 3:
              _emoji = _context4.sent;
              if (!_emoji) {
                _context4.next = 8;
                break;
              }
              _context4.next = 7;
              return this.getMediaEmojiDescriptionURLWithInlineToken(_emoji);
            case 7:
              return _context4.abrupt("return", _context4.sent);
            case 8:
              if (!(this.emojiProviderConfig.singleEmojiApi && optimistic)) {
                _context4.next = 31;
                break;
              }
              // if config has singleEmojiApi then fetch single emoji
              provider = {
                url: this.emojiProviderConfig.singleEmojiApi.getUrl(emojiId),
                securityProvider: this.emojiProviderConfig.singleEmojiApi.securityProvider
              };
              loader = new EmojiLoader(provider);
              _context4.prev = 11;
              _context4.next = 14;
              return loader.loadEmoji();
            case 14:
              loadEmoji = _context4.sent;
              if (loadEmoji.emojis[0]) {
                _context4.next = 17;
                break;
              }
              return _context4.abrupt("return");
            case 17:
              if (this.isRepositoryAvailable(this.siteEmojiResource)) {
                _context4.next = 20;
                break;
              }
              _context4.next = 20;
              return this.initSiteEmojiResource(loadEmoji, provider);
            case 20:
              return _context4.abrupt("return", this.getMediaEmojiDescriptionURLWithInlineToken(loadEmoji.emojis[0]));
            case 23:
              _context4.prev = 23;
              _context4.t0 = _context4["catch"](11);
              _context4.next = 27;
              return this.findByEmojiId(emojiId);
            case 27:
              _emoji2 = _context4.sent;
              if (_emoji2) {
                _context4.next = 30;
                break;
              }
              return _context4.abrupt("return");
            case 30:
              return _context4.abrupt("return", this.getMediaEmojiDescriptionURLWithInlineToken(_emoji2));
            case 31:
              _context4.next = 33;
              return this.findByEmojiId(emojiId);
            case 33:
              emoji = _context4.sent;
              if (emoji) {
                _context4.next = 36;
                break;
              }
              return _context4.abrupt("return");
            case 36:
              return _context4.abrupt("return", this.getMediaEmojiDescriptionURLWithInlineToken(emoji));
            case 37:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[11, 23]]);
      }));
      function fetchByEmojiId(_x3, _x4) {
        return _fetchByEmojiId.apply(this, arguments);
      }
      return fetchByEmojiId;
    }()
  }, {
    key: "getProviderType",
    value: function getProviderType(provider) {
      if (provider.url.includes('/site')) {
        return ProviderTypes.SITE;
      } else if (provider.url.includes('/standard')) {
        return ProviderTypes.STANDARD;
      } else if (provider.url.includes('/atlassian')) {
        return ProviderTypes.ATLASSIAN;
      }
      return ProviderTypes.UNKNOWN;
    }
  }, {
    key: "initEmojiRepository",
    value: function initEmojiRepository(emojiResponses) {
      var emojis = [];
      emojiResponses.forEach(function (emojiResponse) {
        emojis = emojis.concat(emojiResponse.emojis);
      });
      this.emojiRepository = new EmojiRepository(emojis);
    }
  }, {
    key: "initSiteEmojiResource",
    value: function initSiteEmojiResource(emojiResponse, provider) {
      if (!this.isRepositoryAvailable(this.siteEmojiResource) && emojiResponse.mediaApiToken) {
        this.siteEmojiResource = new SiteEmojiResource(provider, emojiResponse.mediaApiToken);

        // Prime cache type + optimistic rendering by checking first Emoji.
        // If this is fails, it won't be primed until a good emoji is loaded later.
        var emojis = emojiResponse.emojis;
        if (emojis.length) {
          var done = this.siteEmojiResource.optimisticRendering(emojis[0]);
          if (isPromise(done)) {
            return done.then(function () {
              debug('Primed siteEmojiResource');
            }).catch(function () {
              debug('Failed to prime siteEmojiResource');
            });
          } else {
            debug('Already primed siteEmojiResource');
          }
        } else {
          debug('No emoji to prime siteEmojiResource with');
        }
      }
      return Promise.resolve();
    }
  }, {
    key: "performRetries",
    value: function performRetries() {
      var currentRetries = this.retries;
      this.retries = new Map();
      currentRetries.forEach(function (resolveReject, retry) {
        var result = retry();
        if (isPromise(result)) {
          result.then(function (response) {
            resolveReject.resolve(response);
          }).catch(function (reason) {
            resolveReject.reject(reason);
          });
        } else {
          resolveReject.resolve(result);
        }
      });
    }
  }, {
    key: "loadStoredTone",
    value: function loadStoredTone() {
      if (typeof window === 'undefined') {
        return undefined;
      }
      var storedToneString = window.localStorage.getItem(selectedToneStorageKey);
      if (storedToneString) {
        var storedTone = parseInt(storedToneString, 10);
        return !isNaN(storedTone) ? storedTone : undefined;
      }
      return undefined;
    }
  }, {
    key: "refreshLastFilter",
    value: function refreshLastFilter() {
      if (typeof this.lastQuery !== 'undefined') {
        var _this$lastQuery = this.lastQuery,
          query = _this$lastQuery.query,
          options = _this$lastQuery.options;
        this.filter(query, options);
      }
    }
  }, {
    key: "retryIfLoading",
    value: function retryIfLoading(retry, defaultResponse) {
      var _this3 = this;
      if (!this.isLoaded()) {
        return new Promise(function (resolve, reject) {
          _this3.retries.set(retry, {
            resolve: resolve,
            reject: reject
          });
        });
      }
      return Promise.resolve(defaultResponse);
    }
  }, {
    key: "notifyResult",
    value: function notifyResult(result) {
      if (this.lastQuery && result.query === this.lastQuery.query) {
        _superPropGet(EmojiResource, "notifyResult", this, 3)([result]);
      }
    }

    /**
     *  Returns the EmojiDescription with a valid media path that includes query token and client attributes to access the emoji media inline.
     */
  }, {
    key: "getMediaEmojiDescriptionURLWithInlineToken",
    value: (function () {
      var _getMediaEmojiDescriptionURLWithInlineToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(emoji) {
        var _yield$this$siteEmoji, representation, altRepresentation;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.isRepositoryAvailable(this.siteEmojiResource)) {
                _context5.next = 7;
                break;
              }
              _context5.next = 3;
              return this.siteEmojiResource.generateTokenisedMediaURLS(emoji.representation, emoji.altRepresentation);
            case 3:
              _yield$this$siteEmoji = _context5.sent;
              representation = _yield$this$siteEmoji.representation;
              altRepresentation = _yield$this$siteEmoji.altRepresentation;
              return _context5.abrupt("return", _objectSpread(_objectSpread({}, emoji), {}, {
                representation: representation,
                altRepresentation: altRepresentation
              }));
            case 7:
              return _context5.abrupt("return", emoji);
            case 8:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getMediaEmojiDescriptionURLWithInlineToken(_x5) {
        return _getMediaEmojiDescriptionURLWithInlineToken.apply(this, arguments);
      }
      return getMediaEmojiDescriptionURLWithInlineToken;
    }())
  }, {
    key: "loadMediaEmoji",
    value: function loadMediaEmoji(emoji, useAlt) {
      if (!this.isRepositoryAvailable(this.siteEmojiResource) || !isMediaEmoji(emoji)) {
        return emoji;
      }
      return this.siteEmojiResource.loadMediaEmoji(emoji, useAlt);
    }
  }, {
    key: "optimisticMediaRendering",
    value: function optimisticMediaRendering(emoji, useAlt) {
      if (!isMediaEmoji(emoji)) {
        return true;
      }
      if (!this.isRepositoryAvailable(this.siteEmojiResource)) {
        // Shouldn't have a media emoji without a siteEmojiResouce, but anyway ;)
        return false;
      }
      var optimistic = this.siteEmojiResource.optimisticRendering(emoji, useAlt);
      if (isPromise(optimistic)) {
        // Not sure yet, so lets say no for now (this should normally be primed in most/all cases)
        return false;
      }
      return optimistic;
    }
  }, {
    key: "filter",
    value: function filter(query, options) {
      ufoExperiences['emoji-searched'].start();
      ufoExperiences['emoji-searched'].addMetadata({
        queryLength: (query === null || query === void 0 ? void 0 : query.length) || 0
      });
      this.lastQuery = {
        query: query,
        options: options
      };
      if (this.isRepositoryAvailable(this.emojiRepository)) {
        var searchResults = this.emojiRepository.search(query, options);
        this.notifyResult(searchResults);
        ufoExperiences['emoji-searched'].success({
          metadata: {
            emojisLength: searchResults.emojis.length,
            source: (options === null || options === void 0 ? void 0 : options.source) || 'typeahead'
          }
        });
      } else {
        // not ready
        this.notifyNotReady();
      }
    }
  }, {
    key: "findByShortName",
    value: function findByShortName(shortName) {
      var _this4 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        // Wait for all emoji to load before looking by shortName (to ensure correct priority)
        return this.emojiRepository.findByShortName(shortName);
      }
      return this.retryIfLoading(function () {
        return _this4.findByShortName(shortName);
      }, undefined);
    }
  }, {
    key: "findByEmojiId",
    value: function findByEmojiId(emojiId) {
      var _this5 = this;
      var id = emojiId.id,
        shortName = emojiId.shortName;
      if (this.isRepositoryAvailable(this.emojiRepository)) {
        if (id) {
          var emoji = this.emojiRepository.findById(id);
          if (emoji) {
            return emoji;
          }
          if (this.isLoaded()) {
            // all loaded but not found by id, try server to see if
            // this is a newly uploaded emoji
            if (this.isRepositoryAvailable(this.siteEmojiResource)) {
              return this.siteEmojiResource.findEmoji(emojiId).then(function (emoji) {
                if (!emoji) {
                  // if not, fallback to searching by shortName to
                  // at least render an alternative
                  return _this5.findByShortName(shortName);
                }
                _this5.addUnknownEmoji(emoji);
                return emoji;
              });
            }

            // if not, fallback to searching by shortName to
            // at least render an alternative
            return this.findByShortName(shortName);
          }
        } else {
          // no id fallback to shortName
          return this.findByShortName(shortName);
        }
      }
      return this.retryIfLoading(function () {
        return _this5.findByEmojiId(emojiId);
      }, undefined);
    }
  }, {
    key: "findById",
    value: function findById(id) {
      var _this6 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        return this.emojiRepository.findById(id);
      }
      return this.retryIfLoading(function () {
        return _this6.findById(id);
      }, undefined);
    }
  }, {
    key: "findInCategory",
    value: function findInCategory(categoryId) {
      var _this7 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        return Promise.resolve(this.emojiRepository.findInCategory(categoryId));
      }
      return this.retryIfLoading(function () {
        return _this7.findInCategory(categoryId);
      }, []);
    }
  }, {
    key: "getAsciiMap",
    value: function getAsciiMap() {
      var _this8 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        return Promise.resolve(this.emojiRepository.getAsciiMap());
      }
      return this.retryIfLoading(function () {
        return _this8.getAsciiMap();
      }, new Map());
    }
  }, {
    key: "getFrequentlyUsed",
    value: function getFrequentlyUsed(options) {
      var _this9 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        return Promise.resolve(this.emojiRepository.getFrequentlyUsed(options));
      }
      return this.retryIfLoading(function () {
        return _this9.getFrequentlyUsed(options);
      }, []);
    }

    /**
     * Record the selection of an emoji to a remote service if 'recordConfig' has been supplied.
     * Regardless of the recordConfig, emoji selections will always be recorded on the EmojiRepository
     * for the purposes of tracking the frequency of use.
     *
     * @param emoji The full description of the emoji to record usage for.
     */
  }, {
    key: "recordSelection",
    value: function recordSelection(emoji) {
      var recordConfig = this.recordConfig;
      if (this.isRepositoryAvailable(this.emojiRepository)) {
        this.emojiRepository.used(emoji);
      }
      if (recordConfig) {
        var queryParams = {
          emojiId: toEmojiId(emoji)
        };
        var requestInit = {
          method: 'POST'
        };
        return serviceUtils.requestService(recordConfig, {
          queryParams: queryParams,
          requestInit: requestInit
        });
      }
      return Promise.resolve();
    }
  }, {
    key: "deleteSiteEmoji",
    value: function deleteSiteEmoji(emoji) {
      var _this10 = this;
      if (this.isRepositoryAvailable(this.siteEmojiResource) && emoji.id) {
        return this.siteEmojiResource.deleteEmoji(emoji).then(function (success) {
          if (success && _this10.isRepositoryAvailable(_this10.emojiRepository)) {
            _this10.emojiRepository.delete(emoji);
            return true;
          }
          return false;
        }).catch(function (err) {
          // eslint-disable-next-line no-console
          console.error('failed to delete site emoji', err);
          return false;
        });
      }
      return this.retryIfLoading(function () {
        return _this10.deleteSiteEmoji(emoji);
      }, false);
    }
  }, {
    key: "getSelectedTone",
    value: function getSelectedTone() {
      return this.selectedTone;
    }
  }, {
    key: "setSelectedTone",
    value: function setSelectedTone(tone) {
      this.selectedTone = tone;
      if (typeof window === 'undefined') {
        return;
      }
      if (storageAvailable('localStorage')) {
        try {
          window.localStorage.setItem(selectedToneStorageKey, tone ? tone.toString() : '');
        } catch (e) {
          // eslint-disable-next-line no-console
          console.error('failed to store selected emoji skin tone', e);
        }
      }
    }
  }, {
    key: "calculateDynamicCategories",
    value: function calculateDynamicCategories() {
      var _this11 = this;
      if (this.isLoaded() && this.isRepositoryAvailable(this.emojiRepository)) {
        return Promise.resolve(this.emojiRepository.getDynamicCategoryList());
      }
      return this.retryIfLoading(function () {
        return _this11.calculateDynamicCategories();
      }, []);
    }
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return this.currentUser;
    }
  }, {
    key: "addUnknownEmoji",
    value: function addUnknownEmoji(emoji) {
      if (this.isRepositoryAvailable(this.emojiRepository)) {
        this.emojiRepository.addUnknownEmoji(emoji);
      }
    }
  }]);
}(AbstractResource);
var UploadingEmojiResource = /*#__PURE__*/function (_EmojiResource2) {
  function UploadingEmojiResource(config) {
    var _this12;
    _classCallCheck(this, UploadingEmojiResource);
    _this12 = _callSuper(this, UploadingEmojiResource, [config]);
    _this12.allowUpload = !!config.allowUpload;
    return _this12;
  }
  _inherits(UploadingEmojiResource, _EmojiResource2);
  return _createClass(UploadingEmojiResource, [{
    key: "isUploadSupported",
    value: function isUploadSupported() {
      var _this13 = this;
      if (!this.allowUpload) {
        return Promise.resolve(false);
      }
      if (this.isRepositoryAvailable(this.siteEmojiResource)) {
        return this.siteEmojiResource.hasUploadToken();
      }
      return this.retryIfLoading(function () {
        return _this13.isUploadSupported();
      }, false);
    }
  }, {
    key: "uploadCustomEmoji",
    value: function uploadCustomEmoji(upload) {
      var _this14 = this;
      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12000;
      return this.isUploadSupported().then(function (supported) {
        if (!supported || !_this14.isRepositoryAvailable(_this14.siteEmojiResource)) {
          return Promise.reject('No media api support is configured');
        }
        var uploadPromise = _this14.siteEmojiResource.uploadEmoji(upload, retry).then(function (emoji) {
          // Use file preview blob URL to temporarily fix the graybox issue after uploading,
          // Because the media service takes time to process the image.
          // Ideally should improve CachingMediaImage by using mediaClient or mediaImage,
          // But that requires more efforts in FE & BE.
          // TODO: revist this when pick up COLLAB-2294
          emoji.representation.imagePath = upload.dataURL;
          _this14.addUnknownEmoji(emoji);
          _this14.refreshLastFilter();
          return emoji;
        });
        return promiseWithTimeout(uploadPromise, timeout, 'uploadCustomEmoji timed out');
      });
    }
  }, {
    key: "prepareForUpload",
    value: function prepareForUpload() {
      var _this15 = this;
      if (this.isRepositoryAvailable(this.siteEmojiResource)) {
        this.siteEmojiResource.prepareForUpload();
      }
      return this.retryIfLoading(function () {
        return _this15.prepareForUpload();
      }, undefined);
    }
  }]);
}(EmojiResource);
export { UploadingEmojiResource as default };