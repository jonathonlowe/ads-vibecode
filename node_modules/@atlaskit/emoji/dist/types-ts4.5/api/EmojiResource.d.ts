import { AbstractResource, type OnProviderChange, type ServiceConfig } from '@atlaskit/util-service-support';
import type { CategoryId } from '../components/picker/categories';
import { type EmojiDescription, type EmojiId, type EmojiProvider, type EmojiResponse, type EmojiSearchResult, type EmojiUpload, type OptionalEmojiDescription, type OptionalEmojiDescriptionWithVariations, type OptionalUser, type SearchOptions, type ToneSelection, type UploadingEmojiProvider, type User } from '../types';
import EmojiRepository from './EmojiRepository';
import SiteEmojiResource from './media/SiteEmojiResource';
import type { OptimisticImageApiLoaderConfig, Options, SingleEmojiApiLoaderConfig, EmojiLoadSuccessCallback, EmojiLoadFailCallback } from './EmojiUtils';
interface GetEmojiProviderOptions {
    /**
     * Whether fetch emoji provider at start
     * @defaultValue true
     */
    fetchAtStart?: boolean;
}
export type { EmojiProvider, UploadingEmojiProvider } from '../types';
export interface EmojiResourceConfig {
    /**
     * The service configuration for remotely recording emoji selections.
     * A post will be performed to this URL with the EmojiId as the body.
     */
    recordConfig?: ServiceConfig;
    /**
     * This defines the different providers. Later providers will override earlier
     * providers when performing shortName based look up.
     */
    providers: ServiceConfig[];
    /**
     * Additional configuration:
     * * On-demand Fetching - Useful for when a product may prefer manually controlling when providers are fetched
     */
    options?: Options;
    /**
     * Must be set to true to enable upload support in the emoji components.
     *
     * Can be used for the restriction of the upload UI based on permissions, or feature flags.
     *
     * Note this also requires that other conditions are met (for example, one of the providers
     * must support upload for the UploadingEmojiResource implementation of UploadingEmojiProvider).
     */
    allowUpload?: boolean;
    /**
     * Logged user in the Product.
     */
    currentUser?: User;
    /**
     * This is specifically used for fetching a meta information of a single emoji.
     * Useful for when rendering a single or a subset of emojis on a page that does not require the
     * whole provider list to be downloaded.
     */
    singleEmojiApi?: SingleEmojiApiLoaderConfig;
    /**
     * Renders an image while the provider is being downloaded to reduce the time
     * the user is being presented with a placeholder
     */
    optimisticImageApi?: OptimisticImageApiLoaderConfig;
    /**
     * A callback triggered on emoji load success
     */
    onEmojiLoadSuccess?: EmojiLoadSuccessCallback;
    /**
     * A callback triggered on emoji load failure
     */
    onEmojiLoadFail?: EmojiLoadFailCallback;
}
export interface OnEmojiProviderChange extends OnProviderChange<EmojiSearchResult, any, void> {
}
export interface Retry<T> {
    (): Promise<T> | T;
}
export interface ResolveReject<T> {
    resolve(result: T): void;
    reject(reason?: any): void;
}
/**
 * Checks if the emojiProvider can support uploading at a feature level.
 *
 * Follow this up with an isUploadSupported() check to see if the provider is actually
 * configured to support uploads.
 * https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates
 */
export declare const supportsUploadFeature: (emojiProvider: EmojiProvider) => emojiProvider is UploadingEmojiProvider;
export interface LastQuery {
    query?: string;
    options?: SearchOptions;
}
export declare class EmojiResource extends AbstractResource<string, EmojiSearchResult, any, undefined, SearchOptions> implements EmojiProvider {
    protected recordConfig?: ServiceConfig;
    protected emojiRepository?: EmojiRepository;
    protected lastQuery?: LastQuery;
    protected activeLoaders: number;
    protected initialLoaders: number;
    protected retries: Map<Retry<any>, ResolveReject<any>>;
    protected siteEmojiResource?: SiteEmojiResource;
    protected selectedTone: ToneSelection;
    protected currentUser?: User;
    protected isInitialised: boolean;
    protected fetchOnDemand: boolean;
    protected emojiResponses: EmojiResponse[];
    emojiProviderConfig: EmojiResourceConfig;
    constructor(config: EmojiResourceConfig);
    /**
     * Get the emoji provider from Emoji Resource
     * @returns Promise<EmojiProvider>
     */
    getEmojiProvider(options?: GetEmojiProviderOptions): Promise<EmojiProvider>;
    private fetchIndividualProvider;
    fetchEmojiProvider(force?: boolean): Promise<EmojiRepository | undefined>;
    onlyFetchOnDemand(): boolean;
    fetchByEmojiId(emojiId: EmojiId, optimistic: boolean): Promise<OptionalEmojiDescriptionWithVariations>;
    private getProviderType;
    protected initEmojiRepository(emojiResponses: EmojiResponse[]): void;
    protected initSiteEmojiResource(emojiResponse: EmojiResponse, provider: ServiceConfig): Promise<void>;
    private performRetries;
    getOptimisticImageURL: (emojiId: EmojiId) => string | undefined;
    protected isRepositoryAvailable: <T>(repository?: T) => repository is T;
    private isLoaded;
    private loadStoredTone;
    protected refreshLastFilter(): void;
    protected retryIfLoading<T>(retry: Retry<T>, defaultResponse: T): Promise<T>;
    protected notifyResult(result: EmojiSearchResult): void;
    /**
     *  Returns the EmojiDescription with a valid media path that includes query token and client attributes to access the emoji media inline.
     */
    getMediaEmojiDescriptionURLWithInlineToken(emoji: EmojiDescription): Promise<EmojiDescription>;
    loadMediaEmoji(emoji: EmojiDescription, useAlt?: boolean): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
    optimisticMediaRendering(emoji: EmojiDescription, useAlt?: boolean): boolean;
    filter(query?: string, options?: SearchOptions): void;
    findByShortName(shortName: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
    findByEmojiId(emojiId: EmojiId): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
    findById(id: string): OptionalEmojiDescription | Promise<OptionalEmojiDescription>;
    findInCategory(categoryId: CategoryId): Promise<EmojiDescription[]>;
    getAsciiMap(): Promise<Map<string, EmojiDescription>>;
    getFrequentlyUsed(options?: SearchOptions): Promise<EmojiDescription[]>;
    /**
     * Record the selection of an emoji to a remote service if 'recordConfig' has been supplied.
     * Regardless of the recordConfig, emoji selections will always be recorded on the EmojiRepository
     * for the purposes of tracking the frequency of use.
     *
     * @param emoji The full description of the emoji to record usage for.
     */
    recordSelection(emoji: EmojiDescription): Promise<any>;
    deleteSiteEmoji(emoji: EmojiDescription): Promise<boolean>;
    getSelectedTone(): ToneSelection;
    setSelectedTone(tone: ToneSelection): void;
    calculateDynamicCategories(): Promise<CategoryId[]>;
    getCurrentUser(): OptionalUser;
    protected addUnknownEmoji(emoji: EmojiDescription): void;
}
export default class UploadingEmojiResource extends EmojiResource implements UploadingEmojiProvider {
    protected allowUpload: boolean;
    constructor(config: EmojiResourceConfig);
    isUploadSupported(): Promise<boolean>;
    uploadCustomEmoji(upload: EmojiUpload, retry?: boolean, timeout?: number): Promise<EmojiDescription>;
    prepareForUpload(): Promise<void>;
}
