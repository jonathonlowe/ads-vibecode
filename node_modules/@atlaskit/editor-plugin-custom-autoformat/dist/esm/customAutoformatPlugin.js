import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { keydownHandler } from '@atlaskit/editor-prosemirror/keymap';
import { buildHandler, completeReplacements } from './pm-plugins/doc';
import { triggerInputRule } from './pm-plugins/input-rules';
import reducers from './pm-plugins/reducers';
import { autoformatAction, getPluginState, pluginKey } from './pm-plugins/utils';
export var createPMPlugin = function createPMPlugin(_ref, options, api) {
  var providerFactory = _ref.providerFactory;
  var rules = [];
  return new SafePlugin({
    state: {
      init: function init() {
        return {
          resolving: [],
          matches: [],
          autoformattingProvider: undefined
        };
      },
      apply: function apply(tr, prevPluginState) {
        if (!prevPluginState) {
          return prevPluginState;
        }

        // remap positions
        var remappedPluginState = _objectSpread(_objectSpread({}, prevPluginState), {}, {
          resolving: prevPluginState.resolving.map(function (candidate) {
            return _objectSpread(_objectSpread({}, candidate), {}, {
              start: tr.mapping.map(candidate.start),
              end: tr.mapping.map(candidate.end, -1)
            });
          })
        });
        var meta = tr.getMeta(pluginKey);
        if (!meta) {
          return remappedPluginState;
        }
        return reducers(remappedPluginState, meta);
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        triggerInputRule(view, rules, from, to, text);
        return false;
      },
      handleKeyDown: keydownHandler({
        Enter: function Enter(_state, _dispatch, view) {
          if (view) {
            triggerInputRule(view, rules, view.state.selection.from, view.state.selection.to, '');
          }
          return false;
        }
      })
    },
    view: function view() {
      var handleProvider = function handleProvider(name, provider) {
        if (name !== 'autoformattingProvider' || !provider) {
          return;
        }
        provider.then( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(autoformattingProvider) {
            var ruleset;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return autoformattingProvider.getRules();
                case 2:
                  ruleset = _context.sent;
                  Object.keys(ruleset).forEach(function (rule) {
                    var inputRule = {
                      /**
                       * On Shift + Enter, after the first word an Object Replacement Character (/ufffc) is added.
                       * We still want to match strings that start with an Object Replacement Character.
                       */
                      // Ignored via go/ees005
                      // eslint-disable-next-line require-unicode-regexp
                      matchTyping: new RegExp("(\\s+|^|\\ufffc)" + rule + '(\\s|,|\\.)$'),
                      // Ignored via go/ees005
                      // eslint-disable-next-line require-unicode-regexp
                      matchEnter: new RegExp('(\\s+|^)' + rule + '()$'),
                      handler: buildHandler(rule, ruleset[rule])
                    };
                    rules.push(inputRule);
                  });
                case 4:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref2.apply(this, arguments);
          };
        }());
      };
      if (options !== null && options !== void 0 && options.autoformattingProvider) {
        handleProvider('autoformattingProvider', options.autoformattingProvider);
      }
      return {
        update: function update(view) {
          var currentState = getPluginState(view.state);
          if (!currentState) {
            return;
          }

          // make replacements in document for finished autoformats
          if (currentState.matches) {
            completeReplacements(view, currentState);
          }
        }
      };
    },
    key: pluginKey
  });
};
var _setProvider = function setProvider(provider) {
  return function (tr) {
    return autoformatAction(tr, {
      action: 'setProvider',
      provider: provider
    });
  };
};
export { _setProvider as setProvider };
export var customAutoformatPlugin = function customAutoformatPlugin(_ref3) {
  var api = _ref3.api,
    options = _ref3.config;
  var previousProvider;
  if (options !== null && options !== void 0 && options.autoformattingProvider) {
    options.autoformattingProvider.then(function (provider) {
      api === null || api === void 0 || api.core.actions.execute(function (_ref4) {
        var tr = _ref4.tr;
        return _setProvider(provider)(tr);
      });
    });
  }
  return {
    name: 'customAutoformat',
    pmPlugins: function pmPlugins() {
      return [{
        name: 'customAutoformat',
        plugin: function plugin(pmPluginFactoryParams) {
          return createPMPlugin(pmPluginFactoryParams, options, api);
        }
      }];
    },
    getSharedState: function getSharedState(editorState) {
      var _getPluginState;
      if (!editorState) {
        return;
      }
      var _ref5 = (_getPluginState = getPluginState(editorState)) !== null && _getPluginState !== void 0 ? _getPluginState : {},
        autoformattingProvider = _ref5.autoformattingProvider;
      return {
        autoformattingProvider: autoformattingProvider
      };
    },
    actions: {
      setProvider: function () {
        var _setProvider2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(providerPromise) {
          var _api$core$actions$exe;
          var provider;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return providerPromise;
              case 2:
                provider = _context2.sent;
                if (!(previousProvider === provider || (options === null || options === void 0 ? void 0 : options.autoformattingProvider) === providerPromise)) {
                  _context2.next = 5;
                  break;
                }
                return _context2.abrupt("return", false);
              case 5:
                previousProvider = provider;
                return _context2.abrupt("return", (_api$core$actions$exe = api === null || api === void 0 ? void 0 : api.core.actions.execute(function (_ref6) {
                  var tr = _ref6.tr;
                  return _setProvider(provider)(tr);
                })) !== null && _api$core$actions$exe !== void 0 ? _api$core$actions$exe : false);
              case 7:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function setProvider(_x2) {
          return _setProvider2.apply(this, arguments);
        }
        return setProvider;
      }()
    }
  };
};