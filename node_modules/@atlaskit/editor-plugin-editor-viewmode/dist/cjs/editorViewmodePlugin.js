"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editorViewModeWithGracefulEditPlugin = exports.editorViewModePlugin = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _state = require("@atlaskit/editor-prosemirror/state");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var viewModePluginKey = new _state.PluginKey('editorViewMode');
var createPlugin = function createPlugin(_ref) {
  var initialMode = _ref.initialMode;
  return new _safePlugin.SafePlugin({
    key: viewModePluginKey,
    state: {
      init: function init() {
        return {
          mode: initialMode !== null && initialMode !== void 0 ? initialMode : 'edit'
        };
      },
      apply: function apply(tr, pluginState) {
        var meta = tr.getMeta(viewModePluginKey);
        if (meta) {
          return meta;
        }
        return pluginState;
      }
    },
    props: {
      // If we set to undefined it respects the previous value.
      // Prosemirror doesn't have this typed correctly for this type of behaviour
      // We will fast-follow to consolidate the logic with `editor-disabled` so we don't
      // need this workaround.
      // @ts-expect-error
      editable: function editable(state) {
        var _viewModePluginKey$ge;
        var mode = (_viewModePluginKey$ge = viewModePluginKey.getState(state)) === null || _viewModePluginKey$ge === void 0 ? void 0 : _viewModePluginKey$ge.mode;
        return mode === 'view' ? false : undefined;
      }
    }
  });
};
function getInitialViewModePluginState(pluginConfig) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    isEmptyDoc = _ref2.isEmptyDoc;
  switch (pluginConfig.initialContentMode) {
    case 'live-view-only':
      return {
        contentMode: 'live-view-only',
        mode: 'view',
        isConsumption: true,
        _showTopToolbar: false
      };
    case 'live-view':
      return {
        contentMode: 'live-view',
        mode: 'view',
        isConsumption: true,
        _showTopToolbar: false
      };
    case 'live-edit':
      // note: when first setting up the plugin state -- we don't know if the document is empty or not
      // so when the document is empty -- the plugin will jump from isConsumption 'true' to 'false' (as part of the editor load).
      return {
        contentMode: 'live-edit',
        mode: isEmptyDoc ? 'edit' : (0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') ? 'edit' : (0, _experiments.editorExperiment)('live_pages_graceful_edit', 'initially-hide-toolbar') ? 'edit' : 'view',
        isConsumption: isEmptyDoc ? false : (0, _experiments.editorExperiment)('live_pages_graceful_edit', 'initially-hide-toolbar') ? false : true,
        _showTopToolbar: (0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') ? true : false
      };
    case 'edit':
      return {
        contentMode: 'edit',
        mode: 'edit',
        isConsumption: false,
        _showTopToolbar: true
      };
    case undefined:
      return {
        contentMode: 'edit',
        mode: 'edit',
        isConsumption: false,
        _showTopToolbar: true
      };
  }
}
var gracefulEditCreatePMPlugin = function gracefulEditCreatePMPlugin(_ref3) {
  var config = _ref3.config,
    api = _ref3.api;
  var timer;
  var lastClickExistingSelection = false;
  var viewModeIntentToEdit = (0, _experiments.unstable_editorExperimentParam)('live_pages_graceful_edit', 'view-mode-intent-to-edit', {
    defaultValue: false,
    typeGuard: function typeGuard(value) {
      return typeof value === 'boolean';
    }
  });
  return new _safePlugin.SafePlugin({
    key: viewModePluginKey,
    state: {
      init: function init(_, editorState) {
        var isEmptyDoc = true;
        if (editorState.doc.textContent.trim() !== '') {
          isEmptyDoc = false;
        }
        if (isEmptyDoc) {
          // Only iterate through the doc if we haven't already established that it's not empty through the simple textContent check
          // This is to avoid unnecessary iterations for large docs
          editorState.doc.descendants(function (node, pos) {
            if (!isEmptyDoc) {
              // if we've already established that the doc is not empty, we can stop iterating
              return false;
            }
            if (node.isLeaf && !node.isText) {
              // any non text leaf node (ie. date, media, extension, ...) is considered non-empty
              isEmptyDoc = false;
            }
            if (node.isText && node.textContent.trim() !== '') {
              // if there is any non-whitespace text, the doc is considered non-empty
              isEmptyDoc = false;
            }
          });
        }
        var initialPluginState = getInitialViewModePluginState(config, {
          // an empty doc has a nodeSize of 4 (the doc and empty paragraph start and end tokens)
          isEmptyDoc: isEmptyDoc
        });
        return initialPluginState;
      },
      apply: function apply(tr, pluginState) {
        if (config.initialContentMode === 'live-view-only') {
          // when in live-view-only mode, we don't allow the editor to change to edit mode
          return pluginState;
        }
        var action = tr.getMeta(viewModePluginKey);
        if (action) {
          switch (action.type) {
            case 'intent-to-edit':
              {
                if (pluginState.contentMode === 'live-view' && !viewModeIntentToEdit) {
                  // if we are in live-view and the view-mode-intent-to-edit is disabled,
                  // we don't do anything with an intent to edit
                  return pluginState;
                }
                if (pluginState.isConsumption === false) {
                  // if we are already in edit mode, we don't need to do anything
                  return pluginState;
                }

                // Set the editor to edit mode and mark the intent to edit as received
                return {
                  contentMode: pluginState.contentMode.startsWith('live-') ? 'live-edit' : 'edit',
                  mode: 'edit',
                  isConsumption: false
                };
              }
            case 'switch-content-mode':
              {
                if (action.contentMode === pluginState.contentMode) {
                  // if the content mode is the same, we don't need to do anything
                  return pluginState;
                }
                switch (action.contentMode) {
                  case 'live-edit':
                    {
                      // When switching to live-edit, we set it to edit mode, and consider it an intent to edit
                      return {
                        contentMode: 'live-edit',
                        mode: 'edit',
                        isConsumption: false
                      };
                    }
                  case 'live-view':
                    {
                      // When switching to live-view, we set it to view mode (but don't change the intent to edit state)
                      return {
                        contentMode: 'live-view',
                        mode: 'view',
                        isConsumption: true
                      };
                    }
                }
              }
            // eslint-disable-next-line no-fallthrough
            default:
              return pluginState;
          }
        }
        return pluginState;
      }
    },
    props: {
      // If we set to undefined it respects the previous value.
      // Prosemirror doesn't have this typed correctly for this type of behaviour
      // We will fast-follow to consolidate the logic with `editor-disabled` so we don't
      // need this workaround.
      // @ts-expect-error
      editable: function editable(state) {
        var _viewModePluginKey$ge2;
        var mode = (_viewModePluginKey$ge2 = viewModePluginKey.getState(state)) === null || _viewModePluginKey$ge2 === void 0 ? void 0 : _viewModePluginKey$ge2.mode;
        return mode === 'view' ? false : undefined;
      },
      handleDOMEvents: {
        mousedown: function mousedown(view, event) {
          var _window$getSelection;
          var existingSelectionText = (_window$getSelection = window.getSelection()) === null || _window$getSelection === void 0 ? void 0 : _window$getSelection.toString();
          if (existingSelectionText !== '') {
            lastClickExistingSelection = true;
          } else {
            lastClickExistingSelection = false;
          }
        }
      },
      handleClick: function handleClick(view, pos, event) {
        var _api$core2;
        var viewModeState = viewModePluginKey.getState(view.state);

        // If this is not available -- there are runtime issues expected -- and there is no safe way to handle this
        if (!viewModeState) {
          throw new Error('editorViewModePlugin: plugin state not found');
        }
        if (viewModeState.contentMode === 'live-view' && !viewModeIntentToEdit) {
          // if we are in live-view and the view-mode-intent-to-edit is disabled,
          // we don't do anything with an intent to edit
          return;
        }
        if (viewModeState.isConsumption === false) {
          // if we are already in edit mode, we don't need to do anything
          return;
        }
        var intentToEdit = checkIntentToEdit(view, pos, event);
        if (!intentToEdit) {
          return;
        }
        if (lastClickExistingSelection) {
          // When there is an existing selection, we don't want to trigger an intent to edit
          return;
        }
        var delayMs = !(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'text-click-no-delay') && (0, _experiments.unstable_editorExperimentParam)('live_pages_graceful_edit', 'delay', {
          defaultValue: 200,
          typeGuard: function typeGuard(value) {
            return typeof value === 'number';
          }
        });
        if (delayMs) {
          if (timer) {
            clearTimeout(timer);
            timer = undefined;
          }
          timer = setTimeout(function () {
            var _api$core;
            api === null || api === void 0 || (_api$core = api.core) === null || _api$core === void 0 || _api$core.actions.execute(api === null || api === void 0 ? void 0 : api.editorViewMode.commands.updateContentMode({
              type: 'intent-to-edit'
            }));
            view.focus();
          }, delayMs);
          return false;
        }
        api === null || api === void 0 || (_api$core2 = api.core) === null || _api$core2 === void 0 || _api$core2.actions.execute(api === null || api === void 0 ? void 0 : api.editorViewMode.commands.updateContentMode({
          type: 'intent-to-edit'
        }));
        view.focus();
        return false;
      },
      handleDoubleClick: function handleDoubleClick() {
        if (timer) {
          clearTimeout(timer);
          timer = undefined;
        }
      }
    }
  });
};
function checkIntentToEdit(view, pos, event) {
  var viewModeIntentMode = (0, _experiments.unstable_editorExperimentParam)('live_pages_graceful_edit', 'intent-mode', {
    defaultValue: 'text',
    typeGuard: function typeGuard(value) {
      return typeof value === 'string' && ['text', 'nodes'].includes(value);
    }
  });
  if (!(event.target instanceof HTMLElement)) {
    // if the target is not an HTMLElement, we can't determine the intent to edit
    return false;
  }
  var hasPointerCursor = window.getComputedStyle(event.target).cursor === 'pointer';
  if (hasPointerCursor) {
    return false;
  }
  var clickTargetBasedOnPos = view.state.doc.nodeAt(pos);
  if (clickTargetBasedOnPos && clickTargetBasedOnPos.type.isText) {
    // clicks on text nodes are always an intent to edit

    if (event.target instanceof HTMLElement && event.target.closest('.inlineNodeView')) {
      // Clicks on the edges of inline nodes result in unexpected positions being detected
      // by prosemirror (where prosemirror calls handleClick with the position following the inline node).
      return false;
    }
    return true;
  }
  if (viewModeIntentMode === 'text') {
    return false;
  }
  var clickPosition = view.posAtDOM(event.target, 0, -1);
  var resolvedPos = view.state.doc.resolve(clickPosition);
  var clickTargetBasedOnTarget = resolvedPos.node(resolvedPos.depth);
  if (!clickTargetBasedOnTarget) {
    return false;
  }
  if (!clickTargetBasedOnTarget.isAtom) {
    // clicks on non atom nodes are considered as an intent to edit
    return true;
  }
  return false;
}
var gracefulEditTopToolbarCreatePMPlugin = function gracefulEditTopToolbarCreatePMPlugin(config) {
  return new _safePlugin.SafePlugin({
    key: viewModePluginKey,
    state: {
      init: function init(_, editorState) {
        var initialPluginState = getInitialViewModePluginState(config, {
          // an empty doc has a nodeSize of 4 (the doc and empty paragraph start and end tokens)
          isEmptyDoc: editorState.doc.nodeSize === 4
        });
        return initialPluginState;
      },
      apply: function apply(tr, pluginState) {
        if (config.initialContentMode === 'live-view-only') {
          // when in live-view-only mode, we don't allow the editor to change to edit mode
          return pluginState;
        }
        var action = tr.getMeta(viewModePluginKey);
        if (action) {
          switch (action.type) {
            case 'intent-to-edit':
              {
                if (pluginState._showTopToolbar === false) {
                  return _objectSpread(_objectSpread({}, pluginState), {}, {
                    _showTopToolbar: true
                  });
                }
                return pluginState;
              }
            case 'switch-content-mode':
              {
                if (action.contentMode === pluginState.contentMode) {
                  // if the content mode is the same, we don't need to do anything
                  return pluginState;
                }
                switch (action.contentMode) {
                  case 'live-edit':
                    {
                      // When switching to live-edit, we set it to edit mode, and consider it an intent to edit
                      return {
                        contentMode: 'live-edit',
                        mode: 'edit',
                        isConsumption: false,
                        _showTopToolbar: true
                      };
                    }
                  case 'live-view':
                    {
                      // When switching to live-view, we set it to view mode (but don't change the intent to edit state)
                      return {
                        contentMode: 'live-view',
                        mode: 'view',
                        isConsumption: true,
                        _showTopToolbar: false
                      };
                    }
                }
              }
            // eslint-disable-next-line no-fallthrough
            default:
              return pluginState;
          }
        }
        return pluginState;
      }
    },
    props: {
      // If we set to undefined it respects the previous value.
      // Prosemirror doesn't have this typed correctly for this type of behaviour
      // We will fast-follow to consolidate the logic with `editor-disabled` so we don't
      // need this workaround.
      // @ts-expect-error
      editable: function editable(state) {
        var _viewModePluginKey$ge3;
        var mode = (_viewModePluginKey$ge3 = viewModePluginKey.getState(state)) === null || _viewModePluginKey$ge3 === void 0 ? void 0 : _viewModePluginKey$ge3.mode;
        return mode === 'view' ? false : undefined;
      },
      handleClick: function handleClick(view, pos, event) {
        var viewModeState = viewModePluginKey.getState(view.state);

        // If this is not available -- there are runtime issues expected -- and there is no safe way to handle this
        if (!viewModeState) {
          throw new Error('editorViewModePlugin: plugin state not found');
        }
        if (viewModeState._showTopToolbar === true) {
          // if we are already in _showTopToolbar mode, we don't need to do anything
          return;
        }
        var clickTarget = view.state.doc.nodeAt(pos);
        if (!clickTarget || !clickTarget.type.isText) {
          // We only treat clicking on inline nodes as an intent to edit
          return;
        }
        if (event.target instanceof HTMLElement && event.target.closest('.inlineNodeView')) {
          // Clicks on the edges of inline nodes result in unexpected positions being detected
          // by prosemirror (where prosemirror calls handleClick with the position following the inline node).
          return;
        }
        var tr = view.state.tr;
        tr.setMeta(viewModePluginKey, {
          type: 'intent-to-edit'
        });
        view.dispatch(tr);
      }
    }
  });
};
var editorViewModeWithGracefulEditPlugin = exports.editorViewModeWithGracefulEditPlugin = function editorViewModeWithGracefulEditPlugin(_ref4) {
  var config = _ref4.config,
    api = _ref4.api;
  if (!config) {
    config = {
      initialContentMode: 'edit'
    };
  }
  return {
    name: 'editorViewMode',
    getSharedState: function getSharedState(editorState) {
      if (!editorState) {
        var initialState = getInitialViewModePluginState(config);
        return initialState;
      }
      var pluginState = viewModePluginKey.getState(editorState);
      if (!pluginState) {
        // If this is not available -- there are runtime issues expected -- and there is no safe way to handle this
        throw new Error('editorViewModePlugin: plugin state not found');
      }

      // This is a subset of the prosemirror plugin state.
      return {
        mode: pluginState.mode,
        contentMode: pluginState.contentMode,
        isConsumption: pluginState.isConsumption,
        _showTopToolbar: pluginState._showTopToolbar
      };
    },
    commands: {
      updateContentMode: function updateContentMode(action) {
        return function (_ref5) {
          var tr = _ref5.tr;
          return tr.setMeta(viewModePluginKey, action);
        };
      },
      updateViewMode: function updateViewMode(mode) {
        return function (_ref6) {
          var tr = _ref6.tr;
          return tr.setMeta(viewModePluginKey, {
            type: 'switch-content-mode',
            contentMode: "live-".concat(mode)
          });
        };
      }
    },
    pmPlugins: function pmPlugins() {
      return [{
        name: 'editorViewMode',
        plugin: function plugin() {
          if ((0, _experiments.editorExperiment)('live_pages_graceful_edit', 'initially-hide-toolbar')) {
            return gracefulEditTopToolbarCreatePMPlugin(config);
          }
          return gracefulEditCreatePMPlugin({
            config: config,
            api: api
          });
        }
      }];
    }
  };
};

/**
 * View Mode plugin to be added to an `EditorPresetBuilder` and used with `ComposableEditor`
 * from `@atlaskit/editor-core`.
 */
var editorViewModePlugin = exports.editorViewModePlugin = function editorViewModePlugin(_ref7) {
  var options = _ref7.config,
    api = _ref7.api;
  if (!(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control', {
    exposure: true
  })) {
    return editorViewModeWithGracefulEditPlugin({
      config: options,
      api: api
    });
  }
  return {
    name: 'editorViewMode',
    getSharedState: function getSharedState(editorState) {
      var _viewModePluginKey$ge4, _viewModePluginKey$ge5;
      if (!editorState) {
        return {
          mode: (options === null || options === void 0 ? void 0 : options.mode) === 'view' ? 'view' : 'edit'
        }; // Skipping type safety for the deprecated mode property
      }
      return {
        mode: (_viewModePluginKey$ge4 = (_viewModePluginKey$ge5 = viewModePluginKey.getState(editorState)) === null || _viewModePluginKey$ge5 === void 0 ? void 0 : _viewModePluginKey$ge5.mode) !== null && _viewModePluginKey$ge4 !== void 0 ? _viewModePluginKey$ge4 : 'edit'
      }; // Skipping type safety for the deprecated mode property
    },
    commands: {
      updateContentMode: function updateContentMode(action) {
        return function (_ref8) {
          var tr = _ref8.tr;
          // if the feature gate is not on -- this is a no op
          return null;
        };
      },
      updateViewMode: function updateViewMode(mode) {
        return function (_ref9) {
          var tr = _ref9.tr;
          return tr.setMeta(viewModePluginKey, {
            mode: mode
          });
        };
      }
    },
    pmPlugins: function pmPlugins() {
      return [{
        name: 'editorViewMode',
        plugin: function plugin() {
          return createPlugin({
            initialMode: options === null || options === void 0 ? void 0 : options.mode
          });
        }
      }];
    }
  };
};