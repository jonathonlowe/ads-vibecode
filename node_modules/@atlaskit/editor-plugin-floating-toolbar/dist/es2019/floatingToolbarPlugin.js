import React from 'react';
import camelCase from 'lodash/camelCase';
import { ACTION, ACTION_SUBJECT, CONTENT_COMPONENT, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { ErrorBoundary } from '@atlaskit/editor-common/error-boundary';
import { useSharedPluginState } from '@atlaskit/editor-common/hooks';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { Popup } from '@atlaskit/editor-common/ui';
import { AllSelection, PluginKey } from '@atlaskit/editor-prosemirror/state';
import { findDomRefAtPos, findSelectedNodeOfType } from '@atlaskit/editor-prosemirror/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { editorExperiment, unstable_editorExperimentParam } from '@atlaskit/tmp-editor-statsig/experiments';
import { copyNode } from './pm-plugins/commands';
import forceFocusPlugin, { forceFocusSelector } from './pm-plugins/force-focus';
import { hideConfirmDialog } from './pm-plugins/toolbar-data/commands';
import { createPlugin as floatingToolbarDataPluginFactory } from './pm-plugins/toolbar-data/plugin';
import { pluginKey as dataPluginKey } from './pm-plugins/toolbar-data/plugin-key';
import { findNode } from './pm-plugins/utils';
import { ConfirmationModal } from './ui/ConfirmationModal';
import { ExpandButton } from './ui/ExpandButton';
import { ToolbarLoader } from './ui/ToolbarLoader';
import { consolidateOverflowDropdownItems } from './ui/utils';

// TODO: AFP-2532 - Fix automatic suppressions below
export const getRelevantConfig = (selection, configs) => {
  // node selections always take precedence, see if
  let configPair;
  configs.find(config => {
    const node = findSelectedNodeOfType(config.nodeType)(selection);
    if (node) {
      configPair = {
        node: node.node,
        pos: node.pos,
        config
      };
    }
    return !!node;
  });
  if (configPair) {
    return configPair;
  }

  // create mapping of node type name to configs
  const configByNodeType = {};
  configs.forEach(config => {
    if (Array.isArray(config.nodeType)) {
      config.nodeType.forEach(nodeType => {
        configByNodeType[nodeType.name] = config;
      });
    } else {
      configByNodeType[config.nodeType.name] = config;
    }
  });

  // search up the tree from selection
  const {
    $from
  } = selection;
  for (let i = $from.depth; i > 0; i--) {
    const node = $from.node(i);
    const matchedConfig = configByNodeType[node.type.name];
    if (matchedConfig) {
      return {
        config: matchedConfig,
        node: node,
        pos: $from.pos
      };
    }
  }

  // if it is AllSelection (can be result of Cmd+A) - use first node
  if (selection instanceof AllSelection) {
    const docNode = $from.node(0);
    let matchedConfig = null;
    const firstChild = findNode(docNode, node => {
      matchedConfig = configByNodeType[node.type.name];
      return !!matchedConfig;
    });
    if (firstChild && matchedConfig) {
      return {
        config: matchedConfig,
        node: firstChild,
        pos: $from.pos
      };
    }
  }
  return;
};
const getDomRefFromSelection = (view, dispatchAnalyticsEvent) => {
  try {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    return findDomRefAtPos(view.state.selection.from, view.domAtPos.bind(view));
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn(error);
    if (dispatchAnalyticsEvent) {
      const payload = {
        action: ACTION.ERRORED,
        actionSubject: ACTION_SUBJECT.CONTENT_COMPONENT,
        eventType: EVENT_TYPE.OPERATIONAL,
        attributes: {
          component: CONTENT_COMPONENT.FLOATING_TOOLBAR,
          selection: view.state.selection.toJSON(),
          position: view.state.selection.from,
          docSize: view.state.doc.nodeSize,
          error: error.toString(),
          // @ts-expect-error - Object literal may only specify known properties, 'errorStack' does not exist in type
          // This error was introduced after upgrading to TypeScript 5
          errorStack: error.stack || undefined
        }
      };
      dispatchAnalyticsEvent(payload);
    }
  }
};
function filterUndefined(x) {
  return !!x;
}
export const floatingToolbarPlugin = ({
  api
}) => {
  return {
    name: 'floatingToolbar',
    pmPlugins(floatingToolbarHandlers = []) {
      const plugins = [{
        // Should be after all toolbar plugins
        name: 'floatingToolbar',
        plugin: ({
          providerFactory,
          getIntl
        }) => floatingToolbarPluginFactory({
          floatingToolbarHandlers,
          providerFactory,
          getIntl
        })
      }, {
        name: 'floatingToolbarData',
        plugin: ({
          dispatch
        }) => floatingToolbarDataPluginFactory(dispatch)
      }, {
        name: 'forceFocus',
        plugin: () => forceFocusPlugin()
      }];
      return plugins;
    },
    actions: {
      forceFocusSelector
    },
    commands: {
      copyNode: nodeType => copyNode(nodeType)
    },
    getSharedState(editorState) {
      var _api$interaction, _api$interaction$shar;
      if (!editorState) {
        return undefined;
      }
      const hasHadInteraction = api === null || api === void 0 ? void 0 : (_api$interaction = api.interaction) === null || _api$interaction === void 0 ? void 0 : (_api$interaction$shar = _api$interaction.sharedState.currentState()) === null || _api$interaction$shar === void 0 ? void 0 : _api$interaction$shar.hasHadInteraction;
      let configWithNodeInfo;
      if (fg('platform_editor_no_selection_until_interaction')) {
        var _pluginKey$getState$g, _pluginKey$getState, _pluginKey$getState$g2;
        configWithNodeInfo = hasHadInteraction !== false ? (_pluginKey$getState$g = (_pluginKey$getState = pluginKey.getState(editorState)) === null || _pluginKey$getState === void 0 ? void 0 : (_pluginKey$getState$g2 = _pluginKey$getState.getConfigWithNodeInfo) === null || _pluginKey$getState$g2 === void 0 ? void 0 : _pluginKey$getState$g2.call(_pluginKey$getState, editorState)) !== null && _pluginKey$getState$g !== void 0 ? _pluginKey$getState$g : undefined : undefined;
      } else {
        var _pluginKey$getState$g3, _pluginKey$getState2, _pluginKey$getState2$;
        configWithNodeInfo = (_pluginKey$getState$g3 = (_pluginKey$getState2 = pluginKey.getState(editorState)) === null || _pluginKey$getState2 === void 0 ? void 0 : (_pluginKey$getState2$ = _pluginKey$getState2.getConfigWithNodeInfo) === null || _pluginKey$getState2$ === void 0 ? void 0 : _pluginKey$getState2$.call(_pluginKey$getState2, editorState)) !== null && _pluginKey$getState$g3 !== void 0 ? _pluginKey$getState$g3 : undefined;
      }
      return {
        configWithNodeInfo,
        floatingToolbarData: dataPluginKey.getState(editorState)
      };
    },
    contentComponent({
      popupsMountPoint,
      popupsBoundariesElement,
      popupsScrollableElement,
      editorView,
      providerFactory,
      dispatchAnalyticsEvent
    }) {
      return /*#__PURE__*/React.createElement(ContentComponent, {
        editorView: editorView,
        pluginInjectionApi: api,
        popupsMountPoint: popupsMountPoint,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsScrollableElement: popupsScrollableElement,
        providerFactory: providerFactory,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent
      });
    }
  };
};
export function ContentComponent({
  pluginInjectionApi,
  editorView,
  popupsMountPoint,
  popupsBoundariesElement,
  popupsScrollableElement,
  providerFactory,
  dispatchAnalyticsEvent
}) {
  var _configWithNodeInfo$c, _configWithNodeInfo$c2, _items, _pluginInjectionApi$c, _pluginInjectionApi$d;
  const {
    floatingToolbarState,
    editorDisabledState,
    editorViewModeState,
    userIntentState,
    // @ts-expect-error - excluded from FloatingToolbarPlugin dependencies to avoid circular dependency
    blockControlsState
  } = useSharedPluginState(pluginInjectionApi, ['floatingToolbar', 'editorDisabled', 'editorViewMode', 'userIntent',
  // @ts-expect-error - excluded from FloatingToolbarPlugin dependencies to avoid circular dependency
  'blockControls']);
  const {
    configWithNodeInfo,
    floatingToolbarData
  } = floatingToolbarState !== null && floatingToolbarState !== void 0 ? floatingToolbarState : {};
  if (!configWithNodeInfo || !configWithNodeInfo.config || typeof ((_configWithNodeInfo$c = configWithNodeInfo.config) === null || _configWithNodeInfo$c === void 0 ? void 0 : _configWithNodeInfo$c.visible) !== 'undefined' && !((_configWithNodeInfo$c2 = configWithNodeInfo.config) !== null && _configWithNodeInfo$c2 !== void 0 && _configWithNodeInfo$c2.visible)) {
    return null;
  }
  if (fg('platform_editor_user_intent_plugin')) {
    if ((userIntentState === null || userIntentState === void 0 ? void 0 : userIntentState.currentUserIntent) === 'dragging') {
      return null;
    }

    // TODO: ED-27539 - This feature is unreleased and rendering logic needs to be move userIntentState which is not ready yet
    // if (blockControlsState?.isMenuOpen && editorExperiment('platform_editor_controls', 'variant1')) {
    // 	return null;
    // }
  } else {
    if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isDragging) {
      return null;
    }
    if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isMenuOpen && editorExperiment('platform_editor_controls', 'variant1')) {
      return null;
    }
  }
  const {
    config,
    node
  } = configWithNodeInfo;
  let {
    items
  } = config;
  const {
    groupLabel
  } = config;
  const {
    title,
    getDomRef = getDomRefFromSelection,
    align = 'center',
    className = '',
    height,
    width,
    zIndex,
    offset = [0, 12],
    forcePlacement,
    preventPopupOverflow,
    onPositionCalculated,
    absoluteOffset = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    focusTrap,
    mediaAssistiveMessage = '',
    stick = true
  } = config;
  const targetRef = getDomRef(editorView, dispatchAnalyticsEvent);
  const isEditorDisabled = editorDisabledState && editorDisabledState.editorDisabled;
  const isInViewMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  if (!targetRef || isEditorDisabled && !isInViewMode) {
    return null;
  }

  // TODO: MODES-3950 - Update this view mode specific logic once we refactor view mode.
  //       We should inverse the responsibility here: A blacklist for toolbar items in view mode, rather than this white list.
  //       Also consider moving this logic to the more specific toolbar plugins (media and selection).
  const iterableItems = Array.isArray(items) ? items : (_items = items) === null || _items === void 0 ? void 0 : _items(node);
  if (isInViewMode) {
    // Typescript note: Not all toolbar item types have the `supportsViewMode` prop.
    const toolbarItemViewModeProp = 'supportsViewMode';
    items = iterableItems.filter(item => toolbarItemViewModeProp in item && !!item[toolbarItemViewModeProp]);
  }
  if (editorExperiment('platform_editor_controls', 'variant1')) {
    var _items2;
    // Consolidate floating toolbar items
    const toolbarItemsArray = Array.isArray(items) ? items : (_items2 = items) === null || _items2 === void 0 ? void 0 : _items2(node);
    const overflowDropdownItems = toolbarItemsArray.filter(item => item.type === 'overflow-dropdown');
    if (overflowDropdownItems.length > 1) {
      const consolidatedOverflowDropdown = consolidateOverflowDropdownItems(overflowDropdownItems);
      const otherItems = toolbarItemsArray.filter(item => item.type !== 'overflow-dropdown');
      if (otherItems.length > 0) {
        // remove the last separators
        while (((_otherItems$at = otherItems.at(-1)) === null || _otherItems$at === void 0 ? void 0 : _otherItems$at.type) === 'separator') {
          var _otherItems$at;
          otherItems.pop();
        }
      }
      items = [...otherItems, {
        type: 'separator',
        fullHeight: true,
        supportsViewMode: true
      }, consolidatedOverflowDropdown];
    }
  }
  let customPositionCalculation;
  const toolbarItems = pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$c = pluginInjectionApi.copyButton) === null || _pluginInjectionApi$c === void 0 ? void 0 : _pluginInjectionApi$c.actions.processCopyButtonItems(editorView.state)(Array.isArray(items) ? items : items(node), pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$d = pluginInjectionApi.decorations) === null || _pluginInjectionApi$d === void 0 ? void 0 : _pluginInjectionApi$d.actions.hoverDecoration);
  const viewModeToolbarEntry = unstable_editorExperimentParam('live_pages_graceful_edit', 'toolbar-entry', {
    defaultValue: 'none',
    typeGuard: value => typeof value === 'string' && ['text', 'nodes'].includes(value)
  });
  if (!editorExperiment('live_pages_graceful_edit', 'control') && viewModeToolbarEntry !== 'none') {
    if ((editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.contentMode) === 'live-edit' && editorViewModeState !== null && editorViewModeState !== void 0 && editorViewModeState.isConsumption) {
      const hasOtherToolbarItems = toolbarItems && toolbarItems.length !== 0;
      const shouldAddToolbarItems = viewModeToolbarEntry === 'expand-existing-only' ? hasOtherToolbarItems : true;
      if (shouldAddToolbarItems) {
        if (toolbarItems && toolbarItems.length > 0) {
          toolbarItems.unshift({
            type: 'separator'
          });
        }
        toolbarItems === null || toolbarItems === void 0 ? void 0 : toolbarItems.unshift({
          type: 'button',
          title: 'Edit',
          onClick: () => {
            var _pluginInjectionApi$c2, _pluginInjectionApi$c3, _pluginInjectionApi$e;
            pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$c2 = pluginInjectionApi.core) === null || _pluginInjectionApi$c2 === void 0 ? void 0 : (_pluginInjectionApi$c3 = _pluginInjectionApi$c2.actions) === null || _pluginInjectionApi$c3 === void 0 ? void 0 : _pluginInjectionApi$c3.execute(pluginInjectionApi === null || pluginInjectionApi === void 0 ? void 0 : (_pluginInjectionApi$e = pluginInjectionApi.editorViewMode) === null || _pluginInjectionApi$e === void 0 ? void 0 : _pluginInjectionApi$e.commands.updateContentMode({
              type: 'intent-to-edit'
            }));
            return false;
          },
          icon: () => /*#__PURE__*/React.createElement(ExpandButton, null)
        });
      }
    }
  }
  if (onPositionCalculated) {
    customPositionCalculation = nextPos => {
      return onPositionCalculated(editorView, nextPos);
    };
  }
  const dispatchCommand = fn => fn && fn(editorView.state, editorView.dispatch, editorView);

  // Confirm dialog
  const {
    confirmDialogForItem
  } = floatingToolbarData || {};
  const confirmButtonItem = confirmDialogForItem ?
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  toolbarItems[confirmDialogForItem] : undefined;
  const scrollable = config.scrollable;
  const confirmDialogOptions = typeof (confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog) === 'function' ? confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog() : confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog;
  return /*#__PURE__*/React.createElement(ErrorBoundary, {
    component: ACTION_SUBJECT.FLOATING_TOOLBAR_PLUGIN,
    componentId: camelCase(title),
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    fallbackComponent: null
  }, /*#__PURE__*/React.createElement(Popup, {
    ariaLabel: title,
    offset: offset,
    target: targetRef,
    alignY: "bottom",
    forcePlacement: forcePlacement,
    fitHeight: height,
    fitWidth: width,
    absoluteOffset: absoluteOffset,
    alignX: align,
    stick: stick,
    zIndex: zIndex,
    mountTo: popupsMountPoint,
    boundariesElement: popupsBoundariesElement,
    scrollableElement: popupsScrollableElement,
    onPositionCalculated: customPositionCalculation
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: scrollable ? {
      maxWidth: '100%'
    } : {},
    focusTrap: focusTrap,
    preventOverflow: preventPopupOverflow
  }, /*#__PURE__*/React.createElement(WithProviders, {
    providerFactory: providerFactory,
    providers: ['extensionProvider'],
    renderNode: providers => {
      return /*#__PURE__*/React.createElement(ToolbarLoader, {
        target: targetRef
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ,
        items: toolbarItems,
        groupLabel: groupLabel,
        node: node,
        dispatchCommand: dispatchCommand,
        editorView: editorView
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        ,
        className: className,
        focusEditor: () => editorView.focus(),
        providerFactory: providerFactory,
        popupsMountPoint: popupsMountPoint,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsScrollableElement: popupsScrollableElement,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent,
        extensionsProvider: providers.extensionProvider,
        scrollable: scrollable,
        api: pluginInjectionApi,
        mediaAssistiveMessage: mediaAssistiveMessage
      });
    }
  })), /*#__PURE__*/React.createElement(ConfirmationModal, {
    testId: "ak-floating-toolbar-confirmation-modal",
    options: confirmDialogOptions,
    onConfirm: (isChecked = false) => {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (!!confirmDialogOptions.onConfirm) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        dispatchCommand(confirmDialogOptions.onConfirm(isChecked));
      } else {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        dispatchCommand(confirmButtonItem.onClick);
      }
    },
    onClose: () => {
      dispatchCommand(hideConfirmDialog());
      // Need to set focus to Editor here,
      // As when the Confirmation dialog pop up, and user interacts with the dialog, Editor loses focus.
      // So when Confirmation dialog is closed, Editor does not have the focus, then cursor goes to the position 1 of the doc,
      // instead of the cursor position before the dialog pop up.
      if (!editorView.hasFocus()) {
        editorView.focus();
      }
    }
  }));
}

/**
 *
 * ProseMirror Plugin
 *
 */
// We throttle update of this plugin with RAF.
// So from other plugins you will always get the previous state.
export const pluginKey = new PluginKey('floatingToolbarPluginKey');

/**
 * Clean up floating toolbar configs from undesired properties.
 */
function sanitizeFloatingToolbarConfig(config) {
  // Cleanup from non existing node types
  if (Array.isArray(config.nodeType)) {
    return {
      ...config,
      nodeType: config.nodeType.filter(filterUndefined)
    };
  }
  return config;
}
export function floatingToolbarPluginFactory(options) {
  const {
    floatingToolbarHandlers,
    providerFactory,
    getIntl
  } = options;
  const intl = getIntl();
  const getConfigWithNodeInfo = editorState => {
    let activeConfigs = [];
    for (let index = 0; index < floatingToolbarHandlers.length; index++) {
      const handler = floatingToolbarHandlers[index];
      const config = handler(editorState, intl, providerFactory, activeConfigs);
      if (config) {
        if (config.__suppressAllToolbars && editorExperiment('platform_editor_controls', 'variant1') && fg('platform_editor_controls_patch_4')) {
          activeConfigs = undefined;
          break;
        }
        activeConfigs.push(sanitizeFloatingToolbarConfig(config));
      }
    }
    const relevantConfig = activeConfigs && getRelevantConfig(editorState.selection, activeConfigs);
    return relevantConfig;
  };
  const apply = () => {
    const newPluginState = {
      getConfigWithNodeInfo
    };
    return newPluginState;
  };
  return new SafePlugin({
    key: pluginKey,
    state: {
      init: () => {
        // Use this point to preload the UI
        ToolbarLoader.preload();
        return {
          getConfigWithNodeInfo
        };
      },
      apply
    }
  });
}