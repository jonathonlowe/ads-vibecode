import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useEffect, useState } from 'react';
import Loadable from 'react-loadable';
import ButtonGroup from '@atlaskit/button/button-group';
import { getContextualToolbarItemsFromModule } from '@atlaskit/editor-common/extensions';
import { isSelectionTableNestedInTable } from '@atlaskit/editor-common/nesting';
import { FloatingToolbarButton as Button, FloatingToolbarSeparator as Separator } from '@atlaskit/editor-common/ui';
import { nodeToJSON } from '@atlaskit/editor-common/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import Dropdown from './Dropdown';
var noop = function noop() {
  return null;
};
var isDefaultExport = function isDefaultExport(mod) {
  return mod.hasOwnProperty('default');
};
var resolveExtensionIcon = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(getIcon) {
    var maybeIcon;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (getIcon) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return", noop);
        case 2:
          _context.next = 4;
          return getIcon();
        case 4:
          maybeIcon = _context.sent;
          return _context.abrupt("return", isDefaultExport(maybeIcon) ? maybeIcon.default : maybeIcon);
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveExtensionIcon(_x) {
    return _ref.apply(this, arguments);
  };
}();
var ExtensionButton = function ExtensionButton(props) {
  var item = props.item,
    node = props.node,
    extensionApi = props.extensionApi;
  var ButtonIcon = React.useMemo(function () {
    return item.icon ? Loadable({
      // Ignored via go/ees005
      // eslint-disable-next-line require-await
      loader: function () {
        var _loader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", resolveExtensionIcon(item.icon));
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function loader() {
          return _loader.apply(this, arguments);
        }
        return loader;
      }(),
      loading: noop
    }) : undefined;
  }, [item.icon]);
  var onClick = function onClick() {
    if (typeof item.action !== 'function') {
      throw new Error("'action' of context toolbar item '".concat(item.key, "' is not a function"));
    }
    var targetNodeAdf = nodeToJSON(node);
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    item.action(targetNodeAdf, extensionApi);
  };
  var getAriaLabel = function getAriaLabel() {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.tooltip === 'string') {
      return item.tooltip;
    }
    if (item.label) {
      return item.label;
    }
    return '';
  };
  return /*#__PURE__*/React.createElement(Button, {
    title: item.label,
    ariaLabel: getAriaLabel(),
    icon: ButtonIcon ? /*#__PURE__*/React.createElement(ButtonIcon, {
      label: item.label || ''
    }) : undefined,
    onClick: onClick,
    tooltipContent: item.tooltip,
    tooltipStyle: item.tooltipStyle,
    disabled: item.disabled
  }, item.label);
};
export var ExtensionsPlaceholder = function ExtensionsPlaceholder(props) {
  var node = props.node,
    editorView = props.editorView,
    extensionProvider = props.extensionProvider,
    separator = props.separator,
    applyChangeToContextPanel = props.applyChangeToContextPanel,
    extensionApi = props.extensionApi,
    scrollable = props.scrollable,
    setDisableScroll = props.setDisableScroll,
    dispatchCommand = props.dispatchCommand,
    popupsMountPoint = props.popupsMountPoint,
    popupsBoundariesElement = props.popupsBoundariesElement,
    popupsScrollableElement = props.popupsScrollableElement,
    alignDropdownWithToolbar = props.alignDropdownWithToolbar;
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var _useState = useState([]),
    _useState2 = _slicedToArray(_useState, 2),
    extensions = _useState2[0],
    setExtensions = _useState2[1];
  useEffect(function () {
    getExtensions();
    function getExtensions() {
      return _getExtensions.apply(this, arguments);
    } // leaving dependencies array empty so that this effect runs just once on component mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
    function _getExtensions() {
      _getExtensions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var provider;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return extensionProvider;
            case 2:
              provider = _context3.sent;
              if (!provider) {
                _context3.next = 9;
                break;
              }
              _context3.t0 = setExtensions;
              _context3.next = 7;
              return provider.getExtensions();
            case 7:
              _context3.t1 = _context3.sent;
              (0, _context3.t0)(_context3.t1);
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return _getExtensions.apply(this, arguments);
    }
  }, []);
  var nodeAdf = React.useMemo(function () {
    return nodeToJSON(node);
  }, [node]);
  var extensionItems = React.useMemo(function () {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return getContextualToolbarItemsFromModule(extensions, nodeAdf, extensionApi);
  }, [extensions, nodeAdf, extensionApi]);
  if (!extensionItems.length) {
    return null;
  }

  // ButtonGroup wraps each child with another layer
  // but count fragment as 1 child, so here we create the children manually.
  var children = [];
  if (separator && ['start', 'both'].includes(separator)) {
    children.push( /*#__PURE__*/React.createElement(Separator, null));
  }
  var isNestedTable = fg('platform_editor_use_nested_table_pm_nodes') && isSelectionTableNestedInTable(editorView.state);

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extensionItems.forEach(function (item, index) {
    // disable the referentiality and charts extensions for nested tables
    if (isNestedTable && ['referentiality:connections', 'chart:insert-chart'].includes(item.key)) {
      item.disabled = true;
    }
    if (fg('forge-ui-macro-autoconvert')) {
      if ('type' in item && item.type === 'dropdown') {
        children.push( /*#__PURE__*/React.createElement(Dropdown, {
          key: item.id,
          title: item.title,
          icon: item.icon,
          dispatchCommand: dispatchCommand || function () {},
          options: item.options,
          disabled: item.disabled,
          tooltip: item.tooltip,
          hideExpandIcon: item.hideExpandIcon,
          mountPoint: popupsMountPoint,
          boundariesElement: popupsBoundariesElement,
          scrollableElement: popupsScrollableElement,
          dropdownWidth: item.dropdownWidth,
          showSelected: item.showSelected,
          buttonTestId: item.testId,
          editorView: editorView,
          setDisableParentScroll: scrollable ? setDisableScroll : undefined,
          dropdownListId: (item === null || item === void 0 ? void 0 : item.id) && "".concat(item.id, "-dropdownList"),
          alignDropdownWithToolbar: alignDropdownWithToolbar,
          onToggle: item.onToggle,
          footer: item.footer,
          onMount: item.onMount,
          onClick: item.onClick,
          pulse: item.pulse
        }));
      } else {
        children.push( /*#__PURE__*/React.createElement(ExtensionButton, {
          node: node,
          item: item,
          editorView: editorView,
          applyChangeToContextPanel: applyChangeToContextPanel,
          extensionApi: extensionApi
        }));
      }
    } else {
      children.push( /*#__PURE__*/React.createElement(ExtensionButton, {
        node: node,
        item: item,
        editorView: editorView,
        applyChangeToContextPanel: applyChangeToContextPanel,
        extensionApi: extensionApi
      }));
    }
    if (index < extensionItems.length - 1) {
      children.push( /*#__PURE__*/React.createElement(Separator, null));
    }
  });
  if (separator && ['end', 'both'].includes(separator)) {
    children.push( /*#__PURE__*/React.createElement(Separator, null));
  }

  // eslint-disable-next-line react/no-children-prop
  return /*#__PURE__*/React.createElement(ButtonGroup, {
    children: children
  });
};