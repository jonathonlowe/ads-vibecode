"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmojiPickerButton = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _react2 = require("@emotion/react");
var _new = require("@atlaskit/button/new");
var _hooks = require("@atlaskit/editor-common/hooks");
var _ui = require("@atlaskit/editor-common/ui");
var _uiReact = require("@atlaskit/editor-common/ui-react");
var _emoji = require("@atlaskit/emoji");
var _emojiAdd = _interopRequireDefault(require("@atlaskit/icon/core/emoji-add"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _tooltip = _interopRequireDefault(require("@atlaskit/tooltip"));
var _EditorEmojiAddIcon = _interopRequireDefault(require("./EditorEmojiAddIcon"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766

// eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage
var emojiPickerButtonWrapper = (0, _react2.css)({
  position: 'relative',
  // helps adjusts position of popup
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  button: {
    top: '-1px',
    // adjust position of emoji icon when using the IconButtom component
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-selectors
    '&:not([disabled])::after': {
      border: 'none' // remove blue border when picker has been selected
    }
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  svg: {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
    path: {
      // adjust size of emoji icon when using the IconButtom component, otherwise it's too small
      transformOrigin: '50% 50%',
      transform: 'scale(1.14)'
    }
  }
});

// eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage
var emojiPickerButtonWrapperVisualRefresh = (0, _react2.css)({
  position: 'relative',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors
  button: {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-selectors
    '&:not([disabled])::after': {
      border: 'none' // remove blue border when picker has been selected
    }
  }
});
var EmojiPickerWithProvider = function EmojiPickerWithProvider(props) {
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(props.pluginInjectionApi, ['emoji']),
    emojiState = _useSharedPluginState.emojiState;
  var setOutsideClickTargetRef = (0, _react.useContext)(_uiReact.OutsideClickTargetRefContext);
  var emojiProvider = emojiState !== null && emojiState !== void 0 && emojiState.emojiProvider ? Promise.resolve(emojiState === null || emojiState === void 0 ? void 0 : emojiState.emojiProvider) : undefined;
  if (!emojiProvider) {
    return null;
  }
  return (0, _react2.jsx)(_emoji.EmojiPicker, {
    emojiProvider: emojiProvider,
    onSelection: props.updateEmoji,
    onPickerRef: setOutsideClickTargetRef
  });
};
var EmojiPickerWithListener = (0, _uiReact.withReactEditorViewOuterListeners)(EmojiPickerWithProvider);
var EmojiPickerButton = exports.EmojiPickerButton = function EmojiPickerButton(props) {
  var buttonRef = _react.default.useRef(null);
  var _React$useState = _react.default.useState(false),
    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
    isPopupOpen = _React$useState2[0],
    setIsPopupOpen = _React$useState2[1];
  _react.default.useEffect(function () {
    if (props.setDisableParentScroll) {
      props.setDisableParentScroll(isPopupOpen);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isPopupOpen]);
  var togglePopup = (0, _react.useCallback)(function () {
    setIsPopupOpen(!isPopupOpen);
  }, [setIsPopupOpen, isPopupOpen]);
  var updateEmoji = function updateEmoji(emoji) {
    setIsPopupOpen(false);
    props.onChange && props.onChange(emoji);
    requestAnimationFrame(function () {
      var _props$editorView;
      (_props$editorView = props.editorView) === null || _props$editorView === void 0 || _props$editorView.focus();
    });
  };
  var isDetachedElement = (0, _react.useCallback)(function (el) {
    return !document.body.contains(el);
  }, []);
  var handleEmojiClickOutside = (0, _react.useCallback)(function (e) {
    // Ignore click events for detached elements.
    // Workaround for CETI-240 - where two onClicks fire - one when the upload button is
    // still in the document, and one once it's detached. Does not always occur, and
    // may be a side effect of a react render optimisation
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    if (e && e.target && !isDetachedElement(e.target)) {
      togglePopup();
    }
  }, [isDetachedElement, togglePopup]);
  var handleEmojiPressEscape = (0, _react.useCallback)(function () {
    var _buttonRef$current;
    setIsPopupOpen(false);
    (_buttonRef$current = buttonRef.current) === null || _buttonRef$current === void 0 || _buttonRef$current.focus();
  }, [setIsPopupOpen, buttonRef]);
  var renderPopup = function renderPopup() {
    if (!buttonRef.current || !isPopupOpen) {
      return;
    }
    return (0, _react2.jsx)(_ui.Popup, {
      target: buttonRef.current
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      ,
      mountTo: props.setDisableParentScroll ? props.mountPoint : buttonRef.current.parentElement,
      fitHeight: 350,
      fitWidth: 350,
      offset: [0, 10]
      // Confluence inline comment editor has z-index: 500
      // if the toolbar is scrollable, this will be mounted in the root editor
      // we need an index of > 500 to display over it
      ,
      zIndex: props.setDisableParentScroll ? 600 : undefined,
      focusTrap: true
    }, (0, _react2.jsx)(EmojiPickerWithListener, {
      handleEscapeKeydown: handleEmojiPressEscape,
      handleClickOutside: handleEmojiClickOutside,
      pluginInjectionApi: props.pluginInjectionApi,
      updateEmoji: updateEmoji
    }));
  };
  var title = props.title || '';
  return (0, _react2.jsx)("div", {
    css:
    // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
    (0, _platformFeatureFlags.fg)('platform-visual-refresh-icons') ? emojiPickerButtonWrapperVisualRefresh : emojiPickerButtonWrapper
  }, (0, _react2.jsx)(_tooltip.default, {
    content: title,
    position: "top"
  }, (0, _react2.jsx)(_new.IconButton, {
    appearance: "subtle",
    key: props.idx,
    onClick: togglePopup,
    ref: buttonRef,
    isSelected: props.isSelected,
    label: title,
    spacing: "compact",
    icon: function icon() {
      return (0, _react2.jsx)(_emojiAdd.default, {
        color: "currentColor",
        LEGACY_fallbackIcon: _EditorEmojiAddIcon.default,
        label: "emoji-picker-button",
        spacing: "spacious"
      });
    }
  })), renderPopup());
};