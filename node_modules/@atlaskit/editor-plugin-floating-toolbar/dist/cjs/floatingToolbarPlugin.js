"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContentComponent = ContentComponent;
exports.floatingToolbarPlugin = void 0;
exports.floatingToolbarPluginFactory = floatingToolbarPluginFactory;
exports.pluginKey = exports.getRelevantConfig = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = _interopRequireDefault(require("react"));
var _camelCase = _interopRequireDefault(require("lodash/camelCase"));
var _analytics = require("@atlaskit/editor-common/analytics");
var _errorBoundary = require("@atlaskit/editor-common/error-boundary");
var _hooks = require("@atlaskit/editor-common/hooks");
var _providerFactory = require("@atlaskit/editor-common/provider-factory");
var _safePlugin = require("@atlaskit/editor-common/safe-plugin");
var _ui = require("@atlaskit/editor-common/ui");
var _state = require("@atlaskit/editor-prosemirror/state");
var _utils = require("@atlaskit/editor-prosemirror/utils");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _commands = require("./pm-plugins/commands");
var _forceFocus = _interopRequireWildcard(require("./pm-plugins/force-focus"));
var _commands2 = require("./pm-plugins/toolbar-data/commands");
var _plugin = require("./pm-plugins/toolbar-data/plugin");
var _pluginKey = require("./pm-plugins/toolbar-data/plugin-key");
var _utils2 = require("./pm-plugins/utils");
var _ConfirmationModal = require("./ui/ConfirmationModal");
var _ExpandButton = require("./ui/ExpandButton");
var _ToolbarLoader = require("./ui/ToolbarLoader");
var _utils3 = require("./ui/utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// TODO: AFP-2532 - Fix automatic suppressions below
var getRelevantConfig = exports.getRelevantConfig = function getRelevantConfig(selection, configs) {
  // node selections always take precedence, see if
  var configPair;
  configs.find(function (config) {
    var node = (0, _utils.findSelectedNodeOfType)(config.nodeType)(selection);
    if (node) {
      configPair = {
        node: node.node,
        pos: node.pos,
        config: config
      };
    }
    return !!node;
  });
  if (configPair) {
    return configPair;
  }

  // create mapping of node type name to configs
  var configByNodeType = {};
  configs.forEach(function (config) {
    if (Array.isArray(config.nodeType)) {
      config.nodeType.forEach(function (nodeType) {
        configByNodeType[nodeType.name] = config;
      });
    } else {
      configByNodeType[config.nodeType.name] = config;
    }
  });

  // search up the tree from selection
  var $from = selection.$from;
  for (var i = $from.depth; i > 0; i--) {
    var node = $from.node(i);
    var matchedConfig = configByNodeType[node.type.name];
    if (matchedConfig) {
      return {
        config: matchedConfig,
        node: node,
        pos: $from.pos
      };
    }
  }

  // if it is AllSelection (can be result of Cmd+A) - use first node
  if (selection instanceof _state.AllSelection) {
    var docNode = $from.node(0);
    var _matchedConfig = null;
    var firstChild = (0, _utils2.findNode)(docNode, function (node) {
      _matchedConfig = configByNodeType[node.type.name];
      return !!_matchedConfig;
    });
    if (firstChild && _matchedConfig) {
      return {
        config: _matchedConfig,
        node: firstChild,
        pos: $from.pos
      };
    }
  }
  return;
};
var getDomRefFromSelection = function getDomRefFromSelection(view, dispatchAnalyticsEvent) {
  try {
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    return (0, _utils.findDomRefAtPos)(view.state.selection.from, view.domAtPos.bind(view));
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn(error);
    if (dispatchAnalyticsEvent) {
      var payload = {
        action: _analytics.ACTION.ERRORED,
        actionSubject: _analytics.ACTION_SUBJECT.CONTENT_COMPONENT,
        eventType: _analytics.EVENT_TYPE.OPERATIONAL,
        attributes: {
          component: _analytics.CONTENT_COMPONENT.FLOATING_TOOLBAR,
          selection: view.state.selection.toJSON(),
          position: view.state.selection.from,
          docSize: view.state.doc.nodeSize,
          error: error.toString(),
          // @ts-expect-error - Object literal may only specify known properties, 'errorStack' does not exist in type
          // This error was introduced after upgrading to TypeScript 5
          errorStack: error.stack || undefined
        }
      };
      dispatchAnalyticsEvent(payload);
    }
  }
};
function filterUndefined(x) {
  return !!x;
}
var floatingToolbarPlugin = exports.floatingToolbarPlugin = function floatingToolbarPlugin(_ref) {
  var api = _ref.api;
  return {
    name: 'floatingToolbar',
    pmPlugins: function pmPlugins() {
      var floatingToolbarHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var plugins = [{
        // Should be after all toolbar plugins
        name: 'floatingToolbar',
        plugin: function plugin(_ref2) {
          var providerFactory = _ref2.providerFactory,
            getIntl = _ref2.getIntl;
          return floatingToolbarPluginFactory({
            floatingToolbarHandlers: floatingToolbarHandlers,
            providerFactory: providerFactory,
            getIntl: getIntl
          });
        }
      }, {
        name: 'floatingToolbarData',
        plugin: function plugin(_ref3) {
          var dispatch = _ref3.dispatch;
          return (0, _plugin.createPlugin)(dispatch);
        }
      }, {
        name: 'forceFocus',
        plugin: function plugin() {
          return (0, _forceFocus.default)();
        }
      }];
      return plugins;
    },
    actions: {
      forceFocusSelector: _forceFocus.forceFocusSelector
    },
    commands: {
      copyNode: function copyNode(nodeType) {
        return (0, _commands.copyNode)(nodeType);
      }
    },
    getSharedState: function getSharedState(editorState) {
      var _api$interaction;
      if (!editorState) {
        return undefined;
      }
      var hasHadInteraction = api === null || api === void 0 || (_api$interaction = api.interaction) === null || _api$interaction === void 0 || (_api$interaction = _api$interaction.sharedState.currentState()) === null || _api$interaction === void 0 ? void 0 : _api$interaction.hasHadInteraction;
      var configWithNodeInfo;
      if ((0, _platformFeatureFlags.fg)('platform_editor_no_selection_until_interaction')) {
        var _pluginKey$getState$g, _pluginKey$getState, _pluginKey$getState$g2;
        configWithNodeInfo = hasHadInteraction !== false ? (_pluginKey$getState$g = (_pluginKey$getState = pluginKey.getState(editorState)) === null || _pluginKey$getState === void 0 || (_pluginKey$getState$g2 = _pluginKey$getState.getConfigWithNodeInfo) === null || _pluginKey$getState$g2 === void 0 ? void 0 : _pluginKey$getState$g2.call(_pluginKey$getState, editorState)) !== null && _pluginKey$getState$g !== void 0 ? _pluginKey$getState$g : undefined : undefined;
      } else {
        var _pluginKey$getState$g3, _pluginKey$getState2, _pluginKey$getState2$;
        configWithNodeInfo = (_pluginKey$getState$g3 = (_pluginKey$getState2 = pluginKey.getState(editorState)) === null || _pluginKey$getState2 === void 0 || (_pluginKey$getState2$ = _pluginKey$getState2.getConfigWithNodeInfo) === null || _pluginKey$getState2$ === void 0 ? void 0 : _pluginKey$getState2$.call(_pluginKey$getState2, editorState)) !== null && _pluginKey$getState$g3 !== void 0 ? _pluginKey$getState$g3 : undefined;
      }
      return {
        configWithNodeInfo: configWithNodeInfo,
        floatingToolbarData: _pluginKey.pluginKey.getState(editorState)
      };
    },
    contentComponent: function contentComponent(_ref4) {
      var popupsMountPoint = _ref4.popupsMountPoint,
        popupsBoundariesElement = _ref4.popupsBoundariesElement,
        popupsScrollableElement = _ref4.popupsScrollableElement,
        editorView = _ref4.editorView,
        providerFactory = _ref4.providerFactory,
        dispatchAnalyticsEvent = _ref4.dispatchAnalyticsEvent;
      return /*#__PURE__*/_react.default.createElement(ContentComponent, {
        editorView: editorView,
        pluginInjectionApi: api,
        popupsMountPoint: popupsMountPoint,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsScrollableElement: popupsScrollableElement,
        providerFactory: providerFactory,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent
      });
    }
  };
};
function ContentComponent(_ref5) {
  var _configWithNodeInfo$c, _configWithNodeInfo$c2, _items, _pluginInjectionApi$c, _pluginInjectionApi$d;
  var pluginInjectionApi = _ref5.pluginInjectionApi,
    editorView = _ref5.editorView,
    popupsMountPoint = _ref5.popupsMountPoint,
    popupsBoundariesElement = _ref5.popupsBoundariesElement,
    popupsScrollableElement = _ref5.popupsScrollableElement,
    providerFactory = _ref5.providerFactory,
    dispatchAnalyticsEvent = _ref5.dispatchAnalyticsEvent;
  var _useSharedPluginState = (0, _hooks.useSharedPluginState)(pluginInjectionApi, ['floatingToolbar', 'editorDisabled', 'editorViewMode', 'userIntent',
    // @ts-expect-error - excluded from FloatingToolbarPlugin dependencies to avoid circular dependency
    'blockControls']),
    floatingToolbarState = _useSharedPluginState.floatingToolbarState,
    editorDisabledState = _useSharedPluginState.editorDisabledState,
    editorViewModeState = _useSharedPluginState.editorViewModeState,
    userIntentState = _useSharedPluginState.userIntentState,
    blockControlsState = _useSharedPluginState.blockControlsState;
  var _ref6 = floatingToolbarState !== null && floatingToolbarState !== void 0 ? floatingToolbarState : {},
    configWithNodeInfo = _ref6.configWithNodeInfo,
    floatingToolbarData = _ref6.floatingToolbarData;
  if (!configWithNodeInfo || !configWithNodeInfo.config || typeof ((_configWithNodeInfo$c = configWithNodeInfo.config) === null || _configWithNodeInfo$c === void 0 ? void 0 : _configWithNodeInfo$c.visible) !== 'undefined' && !((_configWithNodeInfo$c2 = configWithNodeInfo.config) !== null && _configWithNodeInfo$c2 !== void 0 && _configWithNodeInfo$c2.visible)) {
    return null;
  }
  if ((0, _platformFeatureFlags.fg)('platform_editor_user_intent_plugin')) {
    if ((userIntentState === null || userIntentState === void 0 ? void 0 : userIntentState.currentUserIntent) === 'dragging') {
      return null;
    }

    // TODO: ED-27539 - This feature is unreleased and rendering logic needs to be move userIntentState which is not ready yet
    // if (blockControlsState?.isMenuOpen && editorExperiment('platform_editor_controls', 'variant1')) {
    // 	return null;
    // }
  } else {
    if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isDragging) {
      return null;
    }
    if (blockControlsState !== null && blockControlsState !== void 0 && blockControlsState.isMenuOpen && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
      return null;
    }
  }
  var config = configWithNodeInfo.config,
    node = configWithNodeInfo.node;
  var items = config.items;
  var groupLabel = config.groupLabel;
  var title = config.title,
    _config$getDomRef = config.getDomRef,
    getDomRef = _config$getDomRef === void 0 ? getDomRefFromSelection : _config$getDomRef,
    _config$align = config.align,
    align = _config$align === void 0 ? 'center' : _config$align,
    _config$className = config.className,
    className = _config$className === void 0 ? '' : _config$className,
    height = config.height,
    width = config.width,
    zIndex = config.zIndex,
    _config$offset = config.offset,
    offset = _config$offset === void 0 ? [0, 12] : _config$offset,
    forcePlacement = config.forcePlacement,
    preventPopupOverflow = config.preventPopupOverflow,
    onPositionCalculated = config.onPositionCalculated,
    _config$absoluteOffse = config.absoluteOffset,
    absoluteOffset = _config$absoluteOffse === void 0 ? {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    } : _config$absoluteOffse,
    focusTrap = config.focusTrap,
    _config$mediaAssistiv = config.mediaAssistiveMessage,
    mediaAssistiveMessage = _config$mediaAssistiv === void 0 ? '' : _config$mediaAssistiv,
    _config$stick = config.stick,
    stick = _config$stick === void 0 ? true : _config$stick;
  var targetRef = getDomRef(editorView, dispatchAnalyticsEvent);
  var isEditorDisabled = editorDisabledState && editorDisabledState.editorDisabled;
  var isInViewMode = (editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.mode) === 'view';
  if (!targetRef || isEditorDisabled && !isInViewMode) {
    return null;
  }

  // TODO: MODES-3950 - Update this view mode specific logic once we refactor view mode.
  //       We should inverse the responsibility here: A blacklist for toolbar items in view mode, rather than this white list.
  //       Also consider moving this logic to the more specific toolbar plugins (media and selection).
  var iterableItems = Array.isArray(items) ? items : (_items = items) === null || _items === void 0 ? void 0 : _items(node);
  if (isInViewMode) {
    // Typescript note: Not all toolbar item types have the `supportsViewMode` prop.
    var toolbarItemViewModeProp = 'supportsViewMode';
    items = iterableItems.filter(function (item) {
      return toolbarItemViewModeProp in item && !!item[toolbarItemViewModeProp];
    });
  }
  if ((0, _experiments.editorExperiment)('platform_editor_controls', 'variant1')) {
    var _items2;
    // Consolidate floating toolbar items
    var toolbarItemsArray = Array.isArray(items) ? items : (_items2 = items) === null || _items2 === void 0 ? void 0 : _items2(node);
    var overflowDropdownItems = toolbarItemsArray.filter(function (item) {
      return item.type === 'overflow-dropdown';
    });
    if (overflowDropdownItems.length > 1) {
      var consolidatedOverflowDropdown = (0, _utils3.consolidateOverflowDropdownItems)(overflowDropdownItems);
      var otherItems = toolbarItemsArray.filter(function (item) {
        return item.type !== 'overflow-dropdown';
      });
      if (otherItems.length > 0) {
        // remove the last separators
        while (((_otherItems$at = otherItems.at(-1)) === null || _otherItems$at === void 0 ? void 0 : _otherItems$at.type) === 'separator') {
          var _otherItems$at;
          otherItems.pop();
        }
      }
      items = [].concat((0, _toConsumableArray2.default)(otherItems), [{
        type: 'separator',
        fullHeight: true,
        supportsViewMode: true
      }, consolidatedOverflowDropdown]);
    }
  }
  var customPositionCalculation;
  var toolbarItems = pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$c = pluginInjectionApi.copyButton) === null || _pluginInjectionApi$c === void 0 ? void 0 : _pluginInjectionApi$c.actions.processCopyButtonItems(editorView.state)(Array.isArray(items) ? items : items(node), pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$d = pluginInjectionApi.decorations) === null || _pluginInjectionApi$d === void 0 ? void 0 : _pluginInjectionApi$d.actions.hoverDecoration);
  var viewModeToolbarEntry = (0, _experiments.unstable_editorExperimentParam)('live_pages_graceful_edit', 'toolbar-entry', {
    defaultValue: 'none',
    typeGuard: function typeGuard(value) {
      return typeof value === 'string' && ['text', 'nodes'].includes(value);
    }
  });
  if (!(0, _experiments.editorExperiment)('live_pages_graceful_edit', 'control') && viewModeToolbarEntry !== 'none') {
    if ((editorViewModeState === null || editorViewModeState === void 0 ? void 0 : editorViewModeState.contentMode) === 'live-edit' && editorViewModeState !== null && editorViewModeState !== void 0 && editorViewModeState.isConsumption) {
      var hasOtherToolbarItems = toolbarItems && toolbarItems.length !== 0;
      var shouldAddToolbarItems = viewModeToolbarEntry === 'expand-existing-only' ? hasOtherToolbarItems : true;
      if (shouldAddToolbarItems) {
        if (toolbarItems && toolbarItems.length > 0) {
          toolbarItems.unshift({
            type: 'separator'
          });
        }
        toolbarItems === null || toolbarItems === void 0 || toolbarItems.unshift({
          type: 'button',
          title: 'Edit',
          onClick: function onClick() {
            var _pluginInjectionApi$c2, _pluginInjectionApi$e;
            pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$c2 = pluginInjectionApi.core) === null || _pluginInjectionApi$c2 === void 0 || (_pluginInjectionApi$c2 = _pluginInjectionApi$c2.actions) === null || _pluginInjectionApi$c2 === void 0 || _pluginInjectionApi$c2.execute(pluginInjectionApi === null || pluginInjectionApi === void 0 || (_pluginInjectionApi$e = pluginInjectionApi.editorViewMode) === null || _pluginInjectionApi$e === void 0 ? void 0 : _pluginInjectionApi$e.commands.updateContentMode({
              type: 'intent-to-edit'
            }));
            return false;
          },
          icon: function icon() {
            return /*#__PURE__*/_react.default.createElement(_ExpandButton.ExpandButton, null);
          }
        });
      }
    }
  }
  if (onPositionCalculated) {
    customPositionCalculation = function customPositionCalculation(nextPos) {
      return onPositionCalculated(editorView, nextPos);
    };
  }
  var dispatchCommand = function dispatchCommand(fn) {
    return fn && fn(editorView.state, editorView.dispatch, editorView);
  };

  // Confirm dialog
  var _ref7 = floatingToolbarData || {},
    confirmDialogForItem = _ref7.confirmDialogForItem;
  var confirmButtonItem = confirmDialogForItem ?
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  toolbarItems[confirmDialogForItem] : undefined;
  var scrollable = config.scrollable;
  var confirmDialogOptions = typeof (confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog) === 'function' ? confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog() : confirmButtonItem === null || confirmButtonItem === void 0 ? void 0 : confirmButtonItem.confirmDialog;
  return /*#__PURE__*/_react.default.createElement(_errorBoundary.ErrorBoundary, {
    component: _analytics.ACTION_SUBJECT.FLOATING_TOOLBAR_PLUGIN,
    componentId: (0, _camelCase.default)(title),
    dispatchAnalyticsEvent: dispatchAnalyticsEvent,
    fallbackComponent: null
  }, /*#__PURE__*/_react.default.createElement(_ui.Popup, {
    ariaLabel: title,
    offset: offset,
    target: targetRef,
    alignY: "bottom",
    forcePlacement: forcePlacement,
    fitHeight: height,
    fitWidth: width,
    absoluteOffset: absoluteOffset,
    alignX: align,
    stick: stick,
    zIndex: zIndex,
    mountTo: popupsMountPoint,
    boundariesElement: popupsBoundariesElement,
    scrollableElement: popupsScrollableElement,
    onPositionCalculated: customPositionCalculation
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: scrollable ? {
      maxWidth: '100%'
    } : {},
    focusTrap: focusTrap,
    preventOverflow: preventPopupOverflow
  }, /*#__PURE__*/_react.default.createElement(_providerFactory.WithProviders, {
    providerFactory: providerFactory,
    providers: ['extensionProvider'],
    renderNode: function renderNode(providers) {
      return /*#__PURE__*/_react.default.createElement(_ToolbarLoader.ToolbarLoader, {
        target: targetRef
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ,
        items: toolbarItems,
        groupLabel: groupLabel,
        node: node,
        dispatchCommand: dispatchCommand,
        editorView: editorView
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        ,
        className: className,
        focusEditor: function focusEditor() {
          return editorView.focus();
        },
        providerFactory: providerFactory,
        popupsMountPoint: popupsMountPoint,
        popupsBoundariesElement: popupsBoundariesElement,
        popupsScrollableElement: popupsScrollableElement,
        dispatchAnalyticsEvent: dispatchAnalyticsEvent,
        extensionsProvider: providers.extensionProvider,
        scrollable: scrollable,
        api: pluginInjectionApi,
        mediaAssistiveMessage: mediaAssistiveMessage
      });
    }
  })), /*#__PURE__*/_react.default.createElement(_ConfirmationModal.ConfirmationModal, {
    testId: "ak-floating-toolbar-confirmation-modal",
    options: confirmDialogOptions,
    onConfirm: function onConfirm() {
      var isChecked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (!!confirmDialogOptions.onConfirm) {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        dispatchCommand(confirmDialogOptions.onConfirm(isChecked));
      } else {
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        dispatchCommand(confirmButtonItem.onClick);
      }
    },
    onClose: function onClose() {
      dispatchCommand((0, _commands2.hideConfirmDialog)());
      // Need to set focus to Editor here,
      // As when the Confirmation dialog pop up, and user interacts with the dialog, Editor loses focus.
      // So when Confirmation dialog is closed, Editor does not have the focus, then cursor goes to the position 1 of the doc,
      // instead of the cursor position before the dialog pop up.
      if (!editorView.hasFocus()) {
        editorView.focus();
      }
    }
  }));
}

/**
 *
 * ProseMirror Plugin
 *
 */
// We throttle update of this plugin with RAF.
// So from other plugins you will always get the previous state.
var pluginKey = exports.pluginKey = new _state.PluginKey('floatingToolbarPluginKey');

/**
 * Clean up floating toolbar configs from undesired properties.
 */
function sanitizeFloatingToolbarConfig(config) {
  // Cleanup from non existing node types
  if (Array.isArray(config.nodeType)) {
    return _objectSpread(_objectSpread({}, config), {}, {
      nodeType: config.nodeType.filter(filterUndefined)
    });
  }
  return config;
}
function floatingToolbarPluginFactory(options) {
  var floatingToolbarHandlers = options.floatingToolbarHandlers,
    providerFactory = options.providerFactory,
    getIntl = options.getIntl;
  var intl = getIntl();
  var getConfigWithNodeInfo = function getConfigWithNodeInfo(editorState) {
    var activeConfigs = [];
    for (var index = 0; index < floatingToolbarHandlers.length; index++) {
      var handler = floatingToolbarHandlers[index];
      var config = handler(editorState, intl, providerFactory, activeConfigs);
      if (config) {
        if (config.__suppressAllToolbars && (0, _experiments.editorExperiment)('platform_editor_controls', 'variant1') && (0, _platformFeatureFlags.fg)('platform_editor_controls_patch_4')) {
          activeConfigs = undefined;
          break;
        }
        activeConfigs.push(sanitizeFloatingToolbarConfig(config));
      }
    }
    var relevantConfig = activeConfigs && getRelevantConfig(editorState.selection, activeConfigs);
    return relevantConfig;
  };
  var apply = function apply() {
    var newPluginState = {
      getConfigWithNodeInfo: getConfigWithNodeInfo
    };
    return newPluginState;
  };
  return new _safePlugin.SafePlugin({
    key: pluginKey,
    state: {
      init: function init() {
        // Use this point to preload the UI
        _ToolbarLoader.ToolbarLoader.preload();
        return {
          getConfigWithNodeInfo: getConfigWithNodeInfo
        };
      },
      apply: apply
    }
  });
}