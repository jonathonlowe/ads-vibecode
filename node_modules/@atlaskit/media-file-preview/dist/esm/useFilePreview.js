import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { isImageRepresentationReady, toCommonMediaClientError } from '@atlaskit/media-client';
import { useCopyIntent, useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { isMimeTypeSupportedByBrowser } from '@atlaskit/media-common';
import { createFailedSSRObject, extractErrorInfo } from './analytics';
import { ensureMediaFilePreviewError, ImageLoadError, MediaFilePreviewError } from './errors';
import { getAndCacheLocalPreview, getAndCacheRemotePreview, getSSRPreview, isLocalPreview, isRemotePreview, isSSRClientPreview, isSSRDataPreview, isSSRPreview, isSupportedLocalPreview, mediaFilePreviewCache } from './getPreview';
import { generateScriptProps, getSSRData } from './globalScope';
import { createRequestDimensions, isBigger, useCurrentValueRef } from './helpers';
export var useFilePreview = function useFilePreview(_ref) {
  var _ref$resizeMode = _ref.resizeMode,
    resizeMode = _ref$resizeMode === void 0 ? 'crop' : _ref$resizeMode,
    identifier = _ref.identifier,
    ssr = _ref.ssr,
    dimensions = _ref.dimensions,
    traceContext = _ref.traceContext,
    skipRemote = _ref.skipRemote,
    mediaBlobUrlAttrs = _ref.mediaBlobUrlAttrs,
    _ref$allowAnimated = _ref.allowAnimated,
    allowAnimated = _ref$allowAnimated === void 0 ? true : _ref$allowAnimated,
    upscale = _ref.upscale,
    maxAge = _ref.maxAge,
    source = _ref.source;
  var mediaClient = useMediaClient();
  var _useState = useState('loading'),
    _useState2 = _slicedToArray(_useState, 2),
    status = _useState2[0],
    setStatus = _useState2[1];
  var _useState3 = useState(),
    _useState4 = _slicedToArray(_useState3, 2),
    error = _useState4[0],
    setError = _useState4[1];
  var _useState5 = useState(),
    _useState6 = _slicedToArray(_useState5, 2),
    nonCriticalError = _useState6[0],
    setNonCriticalError = _useState6[1];
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    isBannedLocalPreview = _useState8[0],
    setIsBannedLocalPreview = _useState8[1];
  var _useState9 = useState('not-resolved'),
    _useState10 = _slicedToArray(_useState9, 2),
    upfrontPreviewStatus = _useState10[0],
    setUpfrontPreviewStatus = _useState10[1];
  var ssrReliabilityRef = useRef({
    server: {
      status: 'unknown'
    },
    client: {
      status: 'unknown'
    }
  });
  var requestDimensions = useMemo(function () {
    return dimensions ? createRequestDimensions(dimensions) : undefined;
  }, [dimensions]);
  var requestDimensionsRef = useCurrentValueRef(requestDimensions);
  var imageURLParams = _objectSpread(_objectSpread({
    collection: identifier.collectionName,
    mode: resizeMode
  }, requestDimensions), {}, {
    allowAnimated: allowAnimated,
    upscale: upscale,
    'max-age': maxAge
  });
  imageURLParams = _objectSpread(_objectSpread({}, imageURLParams), {}, {
    source: source
  });
  var previewInitializer = function previewInitializer() {
    var preview = mediaFilePreviewCache.get(identifier.id, resizeMode);
    if (preview) {
      return preview;
    }
    if (ssr) {
      var ssrData = getSSRData(identifier);
      if (ssrData !== null && ssrData !== void 0 && ssrData.error) {
        ssrReliabilityRef.current.server = _objectSpread({
          status: 'fail'
        }, ssrData.error);
      }
      if (!(ssrData !== null && ssrData !== void 0 && ssrData.dataURI)) {
        try {
          return getSSRPreview(ssr, mediaClient, identifier.id, imageURLParams, mediaBlobUrlAttrs);
        } catch (e) {
          ssrReliabilityRef.current[ssr] = _objectSpread({
            status: 'fail'
          }, extractErrorInfo(e, traceContext));
        }
      } else {
        var _dimensions = ssrData.dimensions,
          dataURI = ssrData.dataURI;
        return {
          dataURI: dataURI,
          dimensions: _dimensions,
          source: 'ssr-data'
        };
      }
    }
  };
  var _useState11 = useState(previewInitializer),
    _useState12 = _slicedToArray(_useState11, 2),
    preview = _useState12[0],
    setPreview = _useState12[1];

  //----------------------------------------------------------------
  // FILE STATE
  //----------------------------------------------------------------

  var _useFileState = useFileState(identifier.id, {
      skipRemote: skipRemote,
      collectionName: identifier.collectionName,
      occurrenceKey: identifier.occurrenceKey
    }),
    fileState = _useFileState.fileState;

  // Derived from File State
  var isBackendPreviewReady = !!fileState && isImageRepresentationReady(fileState);
  var fileStateErrorMessage = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' ? fileState.message : undefined;
  var _ref2 = fileState && (fileState === null || fileState === void 0 ? void 0 : fileState.status) !== 'error' ? fileState : {},
    _ref2$preview = _ref2.preview,
    localBinary = _ref2$preview === void 0 ? undefined : _ref2$preview,
    _ref2$mediaType = _ref2.mediaType,
    mediaType = _ref2$mediaType === void 0 ? undefined : _ref2$mediaType,
    _ref2$mimeType = _ref2.mimeType,
    mimeType = _ref2$mimeType === void 0 ? undefined : _ref2$mimeType;

  //----------------------------------------------------------------
  // Update status
  //----------------------------------------------------------------

  // TOOD: make a full hook reset (remount) on New identifier or client
  useEffect(function () {
    setStatus('loading');
  }, [identifier]);
  useEffect(function () {
    if (status !== 'error') {
      if (preview || (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'processed' && !isBackendPreviewReady) {
        setStatus('complete');
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'failed-processing' && !isBackendPreviewReady) {
        setStatus('error');
        setError(new MediaFilePreviewError('failed-processing'));
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' && upfrontPreviewStatus === 'resolved') {
        setStatus('error');
        setError(new MediaFilePreviewError('metadata-fetch', toCommonMediaClientError(fileState)));
      } else {
        setStatus('loading');
      }
    }
  }, [preview, status, fileState, isBackendPreviewReady, fileStateErrorMessage, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Preview Fetch Helper
  //----------------------------------------------------------------
  var getAndCacheRemotePreviewRef = useCurrentValueRef(function () {
    return getAndCacheRemotePreview(mediaClient, identifier.id, requestDimensions || {}, imageURLParams, mediaBlobUrlAttrs, traceContext);
  });

  //----------------------------------------------------------------
  // Upfront Preview
  //----------------------------------------------------------------
  useEffect(function () {
    // Only fetch upfront (no file state) if there is no preview in the state already
    if (preview) {
      setUpfrontPreviewStatus('resolved');
    } else if (!preview && upfrontPreviewStatus === 'not-resolved' && !skipRemote) {
      // We block any possible future call to this method regardless of the outcome (success or fail)
      // If it fails, the normal preview fetch should occur after the file state is fetched anyways
      setUpfrontPreviewStatus('resolving');
      var fetchedDimensions = _objectSpread({}, requestDimensions);
      getAndCacheRemotePreviewRef.current().then(function (newPreview) {
        // If there are new and bigger dimensions in the props, and the upfront preview is still resolving,
        // the fetched preview is no longer valid, and thus, we dismiss it
        if (!isBigger(fetchedDimensions, requestDimensionsRef.current)) {
          setPreview(newPreview);
        }
      }).catch(function () {
        // NO need to log error. If this call fails, a refetch will happen after
      }).finally(function () {
        setUpfrontPreviewStatus('resolved');
      });
    }
  }, [getAndCacheRemotePreviewRef, preview, requestDimensions, requestDimensionsRef, skipRemote, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Cache, Local & Remote Preview
  //----------------------------------------------------------------

  var mediaBlobUrlAttrsRef = useCurrentValueRef(mediaBlobUrlAttrs);
  useEffect(function () {
    var cachedPreview = mediaFilePreviewCache.get(identifier.id, resizeMode);

    // Cached Preview ----------------------------------------------------------------
    if (!preview && cachedPreview && !isBigger(cachedPreview === null || cachedPreview === void 0 ? void 0 : cachedPreview.dimensions, requestDimensions)) {
      setPreview(cachedPreview);
    }
    // Local Preview ----------------------------------------------------------------
    else if (!preview && !isBannedLocalPreview && localBinary && isSupportedLocalPreview(mediaType) && isMimeTypeSupportedByBrowser(mimeType || '')) {
      // Local preview is available only if it's supported by browser and supported by Media Card (isSupportedLocalPreview)
      // For example, SVGs are mime type NOT supported by browser but media type supported by Media Card (image)
      // Then, local Preview NOT available

      getAndCacheLocalPreview(identifier.id, localBinary, requestDimensions || {}, resizeMode, mediaBlobUrlAttrsRef.current).then(setPreview).catch(function (e) {
        setIsBannedLocalPreview(true);
        // CXP-2723 TODO: We might have to wrap this error in MediaCardError
        setNonCriticalError(e);
      });
    }
    // Remote Preview ----------------------------------------------------------------
    else if (!error && !nonCriticalError && (!preview || isBigger(preview.dimensions, requestDimensions) ||
    // We always refetch SSR preview to be able to browser-cache a version without the token in the query parameters
    isSSRPreview(preview)) && !skipRemote && upfrontPreviewStatus === 'resolved' && isBackendPreviewReady) {
      getAndCacheRemotePreviewRef.current().then(setPreview).catch(function (e) {
        var wrappedError = ensureMediaFilePreviewError('preview-fetch', e);
        if (!preview) {
          setStatus('error');
          setError(wrappedError);
        } else {
          // If there is already a preview, we consider it a non-critical error
          setNonCriticalError(wrappedError);
        }
      });
    }
  }, [error, nonCriticalError, getAndCacheRemotePreviewRef, identifier.id, resizeMode, isBannedLocalPreview, mediaBlobUrlAttrsRef, preview, requestDimensions, skipRemote, isBackendPreviewReady, localBinary, mediaType, mimeType, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // RETURN
  //----------------------------------------------------------------

  var onImageError = useCallback(function (failedPreview) {
    if (!failedPreview) {
      return;
    }
    if (isSSRClientPreview(failedPreview)) {
      ssrReliabilityRef.current.client = createFailedSSRObject(failedPreview, traceContext);
    }

    // If the preview failed and it comes from server (global scope / ssrData), it means that we have reused it in client and the error counts for both: server & client.
    if (isSSRDataPreview(failedPreview)) {
      ssrReliabilityRef.current.server = createFailedSSRObject(failedPreview, traceContext);
      ssrReliabilityRef.current.client = createFailedSSRObject(failedPreview, traceContext);
    }

    // If the dataURI has been replaced, we can dismiss this error
    if (failedPreview.dataURI !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
    var isLocal = isLocalPreview(failedPreview);
    var isRemote = isRemotePreview(failedPreview);
    if (isLocal || isRemote) {
      var _error = new ImageLoadError(failedPreview === null || failedPreview === void 0 ? void 0 : failedPreview.source);
      mediaFilePreviewCache.remove(identifier.id, resizeMode);
      if (isLocal) {
        setIsBannedLocalPreview(true);
      }
      if (isRemote) {
        setStatus('error');
        setError(_error);
      }
      setPreview(undefined);
    }
  }, [identifier.id, preview === null || preview === void 0 ? void 0 : preview.dataURI, resizeMode, traceContext]);
  var onImageLoad = useCallback(function (newPreview) {
    if (newPreview) {
      if (isSSRClientPreview(newPreview) && ssrReliabilityRef.current.client.status === 'unknown') {
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }

      /*
          If the image loads successfully and it comes from server (global scope / ssrData), it means that we have reused it in client and the success counts for both: server & client.
        */

      if (isSSRDataPreview(newPreview) && ssrReliabilityRef.current.server.status === 'unknown') {
        ssrReliabilityRef.current.server = {
          status: 'success'
        };
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }
    }

    // If the dataURI has been replaced, we can dismiss this callback
    if ((newPreview === null || newPreview === void 0 ? void 0 : newPreview.dataURI) !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
  }, [preview === null || preview === void 0 ? void 0 : preview.dataURI]);

  // FOR SSR
  var getSsrScriptProps = ssr === 'server' ? function () {
    var _ssrReliabilityRef$cu;
    return generateScriptProps(identifier, preview === null || preview === void 0 ? void 0 : preview.dataURI, requestDimensions, ((_ssrReliabilityRef$cu = ssrReliabilityRef.current.server) === null || _ssrReliabilityRef$cu === void 0 ? void 0 : _ssrReliabilityRef$cu.status) === 'fail' ? ssrReliabilityRef.current.server : undefined);
  } : undefined;
  var _useCopyIntent = useCopyIntent(identifier.id, {
      collectionName: identifier.collectionName
    }),
    copyNodeRef = _useCopyIntent.copyNodeRef;

  // CXP-2723 TODO: should consider simplifying our analytics, and how
  // we might get rid of ssrReliabiltyRef from our hook
  return {
    preview: preview,
    status: status,
    error: error,
    nonCriticalError: nonCriticalError,
    ssrReliability: ssrReliabilityRef.current,
    onImageError: onImageError,
    onImageLoad: onImageLoad,
    getSsrScriptProps: getSsrScriptProps,
    copyNodeRef: copyNodeRef
  };
};