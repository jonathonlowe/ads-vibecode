import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { isImageRepresentationReady, toCommonMediaClientError } from '@atlaskit/media-client';
import { useCopyIntent, useFileState, useMediaClient } from '@atlaskit/media-client-react';
import { isMimeTypeSupportedByBrowser } from '@atlaskit/media-common';
import { createFailedSSRObject, extractErrorInfo } from './analytics';
import { ensureMediaFilePreviewError, ImageLoadError, MediaFilePreviewError } from './errors';
import { getAndCacheLocalPreview, getAndCacheRemotePreview, getSSRPreview, isLocalPreview, isRemotePreview, isSSRClientPreview, isSSRDataPreview, isSSRPreview, isSupportedLocalPreview, mediaFilePreviewCache } from './getPreview';
import { generateScriptProps, getSSRData } from './globalScope';
import { createRequestDimensions, isBigger, useCurrentValueRef } from './helpers';
export const useFilePreview = ({
  resizeMode = 'crop',
  identifier,
  ssr,
  dimensions,
  traceContext,
  skipRemote,
  mediaBlobUrlAttrs,
  // TODO: mediaBlobUrlAttrs can be missing several values contained in the file details. The preview hook is not updating the params in the preview after the file details are available.
  allowAnimated = true,
  upscale,
  maxAge,
  source
}) => {
  const mediaClient = useMediaClient();
  const [status, setStatus] = useState('loading');
  const [error, setError] = useState();
  const [nonCriticalError, setNonCriticalError] = useState();
  const [isBannedLocalPreview, setIsBannedLocalPreview] = useState(false);
  const [upfrontPreviewStatus, setUpfrontPreviewStatus] = useState('not-resolved');
  const ssrReliabilityRef = useRef({
    server: {
      status: 'unknown'
    },
    client: {
      status: 'unknown'
    }
  });
  const requestDimensions = useMemo(() => dimensions ? createRequestDimensions(dimensions) : undefined, [dimensions]);
  const requestDimensionsRef = useCurrentValueRef(requestDimensions);
  let imageURLParams = {
    collection: identifier.collectionName,
    mode: resizeMode,
    ...requestDimensions,
    allowAnimated,
    upscale,
    'max-age': maxAge
  };
  imageURLParams = {
    ...imageURLParams,
    source
  };
  const previewInitializer = () => {
    const preview = mediaFilePreviewCache.get(identifier.id, resizeMode);
    if (preview) {
      return preview;
    }
    if (ssr) {
      const ssrData = getSSRData(identifier);
      if (ssrData !== null && ssrData !== void 0 && ssrData.error) {
        ssrReliabilityRef.current.server = {
          status: 'fail',
          ...ssrData.error
        };
      }
      if (!(ssrData !== null && ssrData !== void 0 && ssrData.dataURI)) {
        try {
          return getSSRPreview(ssr, mediaClient, identifier.id, imageURLParams, mediaBlobUrlAttrs);
        } catch (e) {
          ssrReliabilityRef.current[ssr] = {
            status: 'fail',
            ...extractErrorInfo(e, traceContext)
          };
        }
      } else {
        const {
          dimensions,
          dataURI
        } = ssrData;
        return {
          dataURI,
          dimensions,
          source: 'ssr-data'
        };
      }
    }
  };
  const [preview, setPreview] = useState(previewInitializer);

  //----------------------------------------------------------------
  // FILE STATE
  //----------------------------------------------------------------

  const {
    fileState
  } = useFileState(identifier.id, {
    skipRemote,
    collectionName: identifier.collectionName,
    occurrenceKey: identifier.occurrenceKey
  });

  // Derived from File State
  const isBackendPreviewReady = !!fileState && isImageRepresentationReady(fileState);
  const fileStateErrorMessage = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' ? fileState.message : undefined;
  const {
    preview: localBinary = undefined,
    mediaType = undefined,
    mimeType = undefined
  } = fileState && (fileState === null || fileState === void 0 ? void 0 : fileState.status) !== 'error' ? fileState : {};

  //----------------------------------------------------------------
  // Update status
  //----------------------------------------------------------------

  // TOOD: make a full hook reset (remount) on New identifier or client
  useEffect(() => {
    setStatus('loading');
  }, [identifier]);
  useEffect(() => {
    if (status !== 'error') {
      if (preview || (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'processed' && !isBackendPreviewReady) {
        setStatus('complete');
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'failed-processing' && !isBackendPreviewReady) {
        setStatus('error');
        setError(new MediaFilePreviewError('failed-processing'));
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' && upfrontPreviewStatus === 'resolved') {
        setStatus('error');
        setError(new MediaFilePreviewError('metadata-fetch', toCommonMediaClientError(fileState)));
      } else {
        setStatus('loading');
      }
    }
  }, [preview, status, fileState, isBackendPreviewReady, fileStateErrorMessage, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Preview Fetch Helper
  //----------------------------------------------------------------
  const getAndCacheRemotePreviewRef = useCurrentValueRef(() => {
    return getAndCacheRemotePreview(mediaClient, identifier.id, requestDimensions || {}, imageURLParams, mediaBlobUrlAttrs, traceContext);
  });

  //----------------------------------------------------------------
  // Upfront Preview
  //----------------------------------------------------------------
  useEffect(() => {
    // Only fetch upfront (no file state) if there is no preview in the state already
    if (preview) {
      setUpfrontPreviewStatus('resolved');
    } else if (!preview && upfrontPreviewStatus === 'not-resolved' && !skipRemote) {
      // We block any possible future call to this method regardless of the outcome (success or fail)
      // If it fails, the normal preview fetch should occur after the file state is fetched anyways
      setUpfrontPreviewStatus('resolving');
      const fetchedDimensions = {
        ...requestDimensions
      };
      getAndCacheRemotePreviewRef.current().then(newPreview => {
        // If there are new and bigger dimensions in the props, and the upfront preview is still resolving,
        // the fetched preview is no longer valid, and thus, we dismiss it
        if (!isBigger(fetchedDimensions, requestDimensionsRef.current)) {
          setPreview(newPreview);
        }
      }).catch(() => {
        // NO need to log error. If this call fails, a refetch will happen after
      }).finally(() => {
        setUpfrontPreviewStatus('resolved');
      });
    }
  }, [getAndCacheRemotePreviewRef, preview, requestDimensions, requestDimensionsRef, skipRemote, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Cache, Local & Remote Preview
  //----------------------------------------------------------------

  const mediaBlobUrlAttrsRef = useCurrentValueRef(mediaBlobUrlAttrs);
  useEffect(() => {
    const cachedPreview = mediaFilePreviewCache.get(identifier.id, resizeMode);

    // Cached Preview ----------------------------------------------------------------
    if (!preview && cachedPreview && !isBigger(cachedPreview === null || cachedPreview === void 0 ? void 0 : cachedPreview.dimensions, requestDimensions)) {
      setPreview(cachedPreview);
    }
    // Local Preview ----------------------------------------------------------------
    else if (!preview && !isBannedLocalPreview && localBinary && isSupportedLocalPreview(mediaType) && isMimeTypeSupportedByBrowser(mimeType || '')) {
      // Local preview is available only if it's supported by browser and supported by Media Card (isSupportedLocalPreview)
      // For example, SVGs are mime type NOT supported by browser but media type supported by Media Card (image)
      // Then, local Preview NOT available

      getAndCacheLocalPreview(identifier.id, localBinary, requestDimensions || {}, resizeMode, mediaBlobUrlAttrsRef.current).then(setPreview).catch(e => {
        setIsBannedLocalPreview(true);
        // CXP-2723 TODO: We might have to wrap this error in MediaCardError
        setNonCriticalError(e);
      });
    }
    // Remote Preview ----------------------------------------------------------------
    else if (!error && !nonCriticalError && (!preview || isBigger(preview.dimensions, requestDimensions) ||
    // We always refetch SSR preview to be able to browser-cache a version without the token in the query parameters
    isSSRPreview(preview)) && !skipRemote && upfrontPreviewStatus === 'resolved' && isBackendPreviewReady) {
      getAndCacheRemotePreviewRef.current().then(setPreview).catch(e => {
        const wrappedError = ensureMediaFilePreviewError('preview-fetch', e);
        if (!preview) {
          setStatus('error');
          setError(wrappedError);
        } else {
          // If there is already a preview, we consider it a non-critical error
          setNonCriticalError(wrappedError);
        }
      });
    }
  }, [error, nonCriticalError, getAndCacheRemotePreviewRef, identifier.id, resizeMode, isBannedLocalPreview, mediaBlobUrlAttrsRef, preview, requestDimensions, skipRemote, isBackendPreviewReady, localBinary, mediaType, mimeType, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // RETURN
  //----------------------------------------------------------------

  const onImageError = useCallback(failedPreview => {
    if (!failedPreview) {
      return;
    }
    if (isSSRClientPreview(failedPreview)) {
      ssrReliabilityRef.current.client = createFailedSSRObject(failedPreview, traceContext);
    }

    // If the preview failed and it comes from server (global scope / ssrData), it means that we have reused it in client and the error counts for both: server & client.
    if (isSSRDataPreview(failedPreview)) {
      ssrReliabilityRef.current.server = createFailedSSRObject(failedPreview, traceContext);
      ssrReliabilityRef.current.client = createFailedSSRObject(failedPreview, traceContext);
    }

    // If the dataURI has been replaced, we can dismiss this error
    if (failedPreview.dataURI !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
    const isLocal = isLocalPreview(failedPreview);
    const isRemote = isRemotePreview(failedPreview);
    if (isLocal || isRemote) {
      const error = new ImageLoadError(failedPreview === null || failedPreview === void 0 ? void 0 : failedPreview.source);
      mediaFilePreviewCache.remove(identifier.id, resizeMode);
      if (isLocal) {
        setIsBannedLocalPreview(true);
      }
      if (isRemote) {
        setStatus('error');
        setError(error);
      }
      setPreview(undefined);
    }
  }, [identifier.id, preview === null || preview === void 0 ? void 0 : preview.dataURI, resizeMode, traceContext]);
  const onImageLoad = useCallback(newPreview => {
    if (newPreview) {
      if (isSSRClientPreview(newPreview) && ssrReliabilityRef.current.client.status === 'unknown') {
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }

      /*
          If the image loads successfully and it comes from server (global scope / ssrData), it means that we have reused it in client and the success counts for both: server & client.
        */

      if (isSSRDataPreview(newPreview) && ssrReliabilityRef.current.server.status === 'unknown') {
        ssrReliabilityRef.current.server = {
          status: 'success'
        };
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }
    }

    // If the dataURI has been replaced, we can dismiss this callback
    if ((newPreview === null || newPreview === void 0 ? void 0 : newPreview.dataURI) !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
  }, [preview === null || preview === void 0 ? void 0 : preview.dataURI]);

  // FOR SSR
  const getSsrScriptProps = ssr === 'server' ? () => {
    var _ssrReliabilityRef$cu;
    return generateScriptProps(identifier, preview === null || preview === void 0 ? void 0 : preview.dataURI, requestDimensions, ((_ssrReliabilityRef$cu = ssrReliabilityRef.current.server) === null || _ssrReliabilityRef$cu === void 0 ? void 0 : _ssrReliabilityRef$cu.status) === 'fail' ? ssrReliabilityRef.current.server : undefined);
  } : undefined;
  const {
    copyNodeRef
  } = useCopyIntent(identifier.id, {
    collectionName: identifier.collectionName
  });

  // CXP-2723 TODO: should consider simplifying our analytics, and how
  // we might get rid of ssrReliabiltyRef from our hook
  return {
    preview,
    status,
    error,
    nonCriticalError,
    ssrReliability: ssrReliabilityRef.current,
    onImageError,
    onImageLoad,
    getSsrScriptProps,
    copyNodeRef
  };
};