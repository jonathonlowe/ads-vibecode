"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFilePreview = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _mediaClient = require("@atlaskit/media-client");
var _mediaClientReact = require("@atlaskit/media-client-react");
var _mediaCommon = require("@atlaskit/media-common");
var _analytics = require("./analytics");
var _errors = require("./errors");
var _getPreview = require("./getPreview");
var _globalScope = require("./globalScope");
var _helpers = require("./helpers");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var useFilePreview = exports.useFilePreview = function useFilePreview(_ref) {
  var _ref$resizeMode = _ref.resizeMode,
    resizeMode = _ref$resizeMode === void 0 ? 'crop' : _ref$resizeMode,
    identifier = _ref.identifier,
    ssr = _ref.ssr,
    dimensions = _ref.dimensions,
    traceContext = _ref.traceContext,
    skipRemote = _ref.skipRemote,
    mediaBlobUrlAttrs = _ref.mediaBlobUrlAttrs,
    _ref$allowAnimated = _ref.allowAnimated,
    allowAnimated = _ref$allowAnimated === void 0 ? true : _ref$allowAnimated,
    upscale = _ref.upscale,
    maxAge = _ref.maxAge,
    source = _ref.source;
  var mediaClient = (0, _mediaClientReact.useMediaClient)();
  var _useState = (0, _react.useState)('loading'),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    status = _useState2[0],
    setStatus = _useState2[1];
  var _useState3 = (0, _react.useState)(),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    error = _useState4[0],
    setError = _useState4[1];
  var _useState5 = (0, _react.useState)(),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    nonCriticalError = _useState6[0],
    setNonCriticalError = _useState6[1];
  var _useState7 = (0, _react.useState)(false),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    isBannedLocalPreview = _useState8[0],
    setIsBannedLocalPreview = _useState8[1];
  var _useState9 = (0, _react.useState)('not-resolved'),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    upfrontPreviewStatus = _useState10[0],
    setUpfrontPreviewStatus = _useState10[1];
  var ssrReliabilityRef = (0, _react.useRef)({
    server: {
      status: 'unknown'
    },
    client: {
      status: 'unknown'
    }
  });
  var requestDimensions = (0, _react.useMemo)(function () {
    return dimensions ? (0, _helpers.createRequestDimensions)(dimensions) : undefined;
  }, [dimensions]);
  var requestDimensionsRef = (0, _helpers.useCurrentValueRef)(requestDimensions);
  var imageURLParams = _objectSpread(_objectSpread({
    collection: identifier.collectionName,
    mode: resizeMode
  }, requestDimensions), {}, {
    allowAnimated: allowAnimated,
    upscale: upscale,
    'max-age': maxAge
  });
  imageURLParams = _objectSpread(_objectSpread({}, imageURLParams), {}, {
    source: source
  });
  var previewInitializer = function previewInitializer() {
    var preview = _getPreview.mediaFilePreviewCache.get(identifier.id, resizeMode);
    if (preview) {
      return preview;
    }
    if (ssr) {
      var ssrData = (0, _globalScope.getSSRData)(identifier);
      if (ssrData !== null && ssrData !== void 0 && ssrData.error) {
        ssrReliabilityRef.current.server = _objectSpread({
          status: 'fail'
        }, ssrData.error);
      }
      if (!(ssrData !== null && ssrData !== void 0 && ssrData.dataURI)) {
        try {
          return (0, _getPreview.getSSRPreview)(ssr, mediaClient, identifier.id, imageURLParams, mediaBlobUrlAttrs);
        } catch (e) {
          ssrReliabilityRef.current[ssr] = _objectSpread({
            status: 'fail'
          }, (0, _analytics.extractErrorInfo)(e, traceContext));
        }
      } else {
        var _dimensions = ssrData.dimensions,
          dataURI = ssrData.dataURI;
        return {
          dataURI: dataURI,
          dimensions: _dimensions,
          source: 'ssr-data'
        };
      }
    }
  };
  var _useState11 = (0, _react.useState)(previewInitializer),
    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
    preview = _useState12[0],
    setPreview = _useState12[1];

  //----------------------------------------------------------------
  // FILE STATE
  //----------------------------------------------------------------

  var _useFileState = (0, _mediaClientReact.useFileState)(identifier.id, {
      skipRemote: skipRemote,
      collectionName: identifier.collectionName,
      occurrenceKey: identifier.occurrenceKey
    }),
    fileState = _useFileState.fileState;

  // Derived from File State
  var isBackendPreviewReady = !!fileState && (0, _mediaClient.isImageRepresentationReady)(fileState);
  var fileStateErrorMessage = (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' ? fileState.message : undefined;
  var _ref2 = fileState && (fileState === null || fileState === void 0 ? void 0 : fileState.status) !== 'error' ? fileState : {},
    _ref2$preview = _ref2.preview,
    localBinary = _ref2$preview === void 0 ? undefined : _ref2$preview,
    _ref2$mediaType = _ref2.mediaType,
    mediaType = _ref2$mediaType === void 0 ? undefined : _ref2$mediaType,
    _ref2$mimeType = _ref2.mimeType,
    mimeType = _ref2$mimeType === void 0 ? undefined : _ref2$mimeType;

  //----------------------------------------------------------------
  // Update status
  //----------------------------------------------------------------

  // TOOD: make a full hook reset (remount) on New identifier or client
  (0, _react.useEffect)(function () {
    setStatus('loading');
  }, [identifier]);
  (0, _react.useEffect)(function () {
    if (status !== 'error') {
      if (preview || (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'processed' && !isBackendPreviewReady) {
        setStatus('complete');
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'failed-processing' && !isBackendPreviewReady) {
        setStatus('error');
        setError(new _errors.MediaFilePreviewError('failed-processing'));
      } else if (!preview && (fileState === null || fileState === void 0 ? void 0 : fileState.status) === 'error' && upfrontPreviewStatus === 'resolved') {
        setStatus('error');
        setError(new _errors.MediaFilePreviewError('metadata-fetch', (0, _mediaClient.toCommonMediaClientError)(fileState)));
      } else {
        setStatus('loading');
      }
    }
  }, [preview, status, fileState, isBackendPreviewReady, fileStateErrorMessage, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Preview Fetch Helper
  //----------------------------------------------------------------
  var getAndCacheRemotePreviewRef = (0, _helpers.useCurrentValueRef)(function () {
    return (0, _getPreview.getAndCacheRemotePreview)(mediaClient, identifier.id, requestDimensions || {}, imageURLParams, mediaBlobUrlAttrs, traceContext);
  });

  //----------------------------------------------------------------
  // Upfront Preview
  //----------------------------------------------------------------
  (0, _react.useEffect)(function () {
    // Only fetch upfront (no file state) if there is no preview in the state already
    if (preview) {
      setUpfrontPreviewStatus('resolved');
    } else if (!preview && upfrontPreviewStatus === 'not-resolved' && !skipRemote) {
      // We block any possible future call to this method regardless of the outcome (success or fail)
      // If it fails, the normal preview fetch should occur after the file state is fetched anyways
      setUpfrontPreviewStatus('resolving');
      var fetchedDimensions = _objectSpread({}, requestDimensions);
      getAndCacheRemotePreviewRef.current().then(function (newPreview) {
        // If there are new and bigger dimensions in the props, and the upfront preview is still resolving,
        // the fetched preview is no longer valid, and thus, we dismiss it
        if (!(0, _helpers.isBigger)(fetchedDimensions, requestDimensionsRef.current)) {
          setPreview(newPreview);
        }
      }).catch(function () {
        // NO need to log error. If this call fails, a refetch will happen after
      }).finally(function () {
        setUpfrontPreviewStatus('resolved');
      });
    }
  }, [getAndCacheRemotePreviewRef, preview, requestDimensions, requestDimensionsRef, skipRemote, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // Cache, Local & Remote Preview
  //----------------------------------------------------------------

  var mediaBlobUrlAttrsRef = (0, _helpers.useCurrentValueRef)(mediaBlobUrlAttrs);
  (0, _react.useEffect)(function () {
    var cachedPreview = _getPreview.mediaFilePreviewCache.get(identifier.id, resizeMode);

    // Cached Preview ----------------------------------------------------------------
    if (!preview && cachedPreview && !(0, _helpers.isBigger)(cachedPreview === null || cachedPreview === void 0 ? void 0 : cachedPreview.dimensions, requestDimensions)) {
      setPreview(cachedPreview);
    }
    // Local Preview ----------------------------------------------------------------
    else if (!preview && !isBannedLocalPreview && localBinary && (0, _getPreview.isSupportedLocalPreview)(mediaType) && (0, _mediaCommon.isMimeTypeSupportedByBrowser)(mimeType || '')) {
      // Local preview is available only if it's supported by browser and supported by Media Card (isSupportedLocalPreview)
      // For example, SVGs are mime type NOT supported by browser but media type supported by Media Card (image)
      // Then, local Preview NOT available

      (0, _getPreview.getAndCacheLocalPreview)(identifier.id, localBinary, requestDimensions || {}, resizeMode, mediaBlobUrlAttrsRef.current).then(setPreview).catch(function (e) {
        setIsBannedLocalPreview(true);
        // CXP-2723 TODO: We might have to wrap this error in MediaCardError
        setNonCriticalError(e);
      });
    }
    // Remote Preview ----------------------------------------------------------------
    else if (!error && !nonCriticalError && (!preview || (0, _helpers.isBigger)(preview.dimensions, requestDimensions) ||
    // We always refetch SSR preview to be able to browser-cache a version without the token in the query parameters
    (0, _getPreview.isSSRPreview)(preview)) && !skipRemote && upfrontPreviewStatus === 'resolved' && isBackendPreviewReady) {
      getAndCacheRemotePreviewRef.current().then(setPreview).catch(function (e) {
        var wrappedError = (0, _errors.ensureMediaFilePreviewError)('preview-fetch', e);
        if (!preview) {
          setStatus('error');
          setError(wrappedError);
        } else {
          // If there is already a preview, we consider it a non-critical error
          setNonCriticalError(wrappedError);
        }
      });
    }
  }, [error, nonCriticalError, getAndCacheRemotePreviewRef, identifier.id, resizeMode, isBannedLocalPreview, mediaBlobUrlAttrsRef, preview, requestDimensions, skipRemote, isBackendPreviewReady, localBinary, mediaType, mimeType, upfrontPreviewStatus]);

  //----------------------------------------------------------------
  // RETURN
  //----------------------------------------------------------------

  var onImageError = (0, _react.useCallback)(function (failedPreview) {
    if (!failedPreview) {
      return;
    }
    if ((0, _getPreview.isSSRClientPreview)(failedPreview)) {
      ssrReliabilityRef.current.client = (0, _analytics.createFailedSSRObject)(failedPreview, traceContext);
    }

    // If the preview failed and it comes from server (global scope / ssrData), it means that we have reused it in client and the error counts for both: server & client.
    if ((0, _getPreview.isSSRDataPreview)(failedPreview)) {
      ssrReliabilityRef.current.server = (0, _analytics.createFailedSSRObject)(failedPreview, traceContext);
      ssrReliabilityRef.current.client = (0, _analytics.createFailedSSRObject)(failedPreview, traceContext);
    }

    // If the dataURI has been replaced, we can dismiss this error
    if (failedPreview.dataURI !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
    var isLocal = (0, _getPreview.isLocalPreview)(failedPreview);
    var isRemote = (0, _getPreview.isRemotePreview)(failedPreview);
    if (isLocal || isRemote) {
      var _error = new _errors.ImageLoadError(failedPreview === null || failedPreview === void 0 ? void 0 : failedPreview.source);
      _getPreview.mediaFilePreviewCache.remove(identifier.id, resizeMode);
      if (isLocal) {
        setIsBannedLocalPreview(true);
      }
      if (isRemote) {
        setStatus('error');
        setError(_error);
      }
      setPreview(undefined);
    }
  }, [identifier.id, preview === null || preview === void 0 ? void 0 : preview.dataURI, resizeMode, traceContext]);
  var onImageLoad = (0, _react.useCallback)(function (newPreview) {
    if (newPreview) {
      if ((0, _getPreview.isSSRClientPreview)(newPreview) && ssrReliabilityRef.current.client.status === 'unknown') {
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }

      /*
          If the image loads successfully and it comes from server (global scope / ssrData), it means that we have reused it in client and the success counts for both: server & client.
        */

      if ((0, _getPreview.isSSRDataPreview)(newPreview) && ssrReliabilityRef.current.server.status === 'unknown') {
        ssrReliabilityRef.current.server = {
          status: 'success'
        };
        ssrReliabilityRef.current.client = {
          status: 'success'
        };
      }
    }

    // If the dataURI has been replaced, we can dismiss this callback
    if ((newPreview === null || newPreview === void 0 ? void 0 : newPreview.dataURI) !== (preview === null || preview === void 0 ? void 0 : preview.dataURI)) {
      return;
    }
  }, [preview === null || preview === void 0 ? void 0 : preview.dataURI]);

  // FOR SSR
  var getSsrScriptProps = ssr === 'server' ? function () {
    var _ssrReliabilityRef$cu;
    return (0, _globalScope.generateScriptProps)(identifier, preview === null || preview === void 0 ? void 0 : preview.dataURI, requestDimensions, ((_ssrReliabilityRef$cu = ssrReliabilityRef.current.server) === null || _ssrReliabilityRef$cu === void 0 ? void 0 : _ssrReliabilityRef$cu.status) === 'fail' ? ssrReliabilityRef.current.server : undefined);
  } : undefined;
  var _useCopyIntent = (0, _mediaClientReact.useCopyIntent)(identifier.id, {
      collectionName: identifier.collectionName
    }),
    copyNodeRef = _useCopyIntent.copyNodeRef;

  // CXP-2723 TODO: should consider simplifying our analytics, and how
  // we might get rid of ssrReliabiltyRef from our hook
  return {
    preview: preview,
    status: status,
    error: error,
    nonCriticalError: nonCriticalError,
    ssrReliability: ssrReliabilityRef.current,
    onImageError: onImageError,
    onImageLoad: onImageLoad,
    getSsrScriptProps: getSsrScriptProps,
    copyNodeRef: copyNodeRef
  };
};