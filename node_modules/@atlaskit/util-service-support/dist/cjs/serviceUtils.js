"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestService = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _experienceTraceIdContext = require("@atlaskit/react-ufo/experience-trace-id-context");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _featureFlagsAccessed = require("@atlaskit/react-ufo/feature-flags-accessed");
var _types = require("./types");
var _shared = require("./shared");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @returns Promise containing the json response
 */
var _requestService = exports.requestService = function requestService(serviceConfig, options) {
  var url = serviceConfig.url,
    securityProvider = serviceConfig.securityProvider,
    refreshedSecurityProvider = serviceConfig.refreshedSecurityProvider;
  var _ref = options || _shared.defaultRequestServiceOptions,
    path = _ref.path,
    queryParams = _ref.queryParams,
    requestInit = _ref.requestInit;
  var secOptions = securityProvider && securityProvider();
  var requestUrl = (0, _shared.buildUrl)(url, path, queryParams, secOptions);
  var headers = (0, _shared.buildHeaders)(secOptions, requestInit && requestInit.headers);
  var credentials = (0, _types.buildCredentials)(secOptions);
  var ignoreResponsePayload = (options === null || options === void 0 ? void 0 : options.ignoreResponsePayload) || false;

  // Get tracing headers from UFO
  var TRACING_HEADER_FOR_SERVICE_UTIL = 'platform_collab_provider_tracingheaders';
  var tracingHeaderEnabled = (0, _platformFeatureFlags.fg)('platform_collab_provider_tracingheaders');
  (0, _featureFlagsAccessed.addFeatureFlagAccessed)(TRACING_HEADER_FOR_SERVICE_UTIL, tracingHeaderEnabled);
  var tracingHeaders = {};
  if (tracingHeaderEnabled) {
    tracingHeaders = (0, _experienceTraceIdContext.getActiveTraceHttpRequestHeaders)(url);
  }
  var requestOptions = _objectSpread(_objectSpread({}, requestInit), {}, {
    // populate headers mainly for the collab provider however
    // other components which uses this util can get the header as well.
    // Those tracing headers shall not incur any issues as long as backends handle them properly
    headers: _objectSpread(_objectSpread({}, headers), tracingHeaders),
    credentials: credentials
  });
  return fetch(requestUrl, requestOptions).then(function (response) {
    if (response.status === 204) {
      return Promise.resolve();
    } else if (response.ok) {
      return ignoreResponsePayload ? Promise.resolve() : response.json();
    } else if (response.status === 401 && refreshedSecurityProvider) {
      // auth issue - try once
      return refreshedSecurityProvider().then(function (newSecOptions) {
        var retryServiceConfig = {
          url: url,
          securityProvider: function securityProvider() {
            return newSecOptions;
          }
        };
        return _requestService(retryServiceConfig, options);
      });
    }
    return Promise.reject({
      code: response.status,
      reason: response.statusText
    });
  });
};