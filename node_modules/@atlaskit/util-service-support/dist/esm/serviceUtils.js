import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { getActiveTraceHttpRequestHeaders } from '@atlaskit/react-ufo/experience-trace-id-context';
import { fg } from '@atlaskit/platform-feature-flags';
import { addFeatureFlagAccessed } from '@atlaskit/react-ufo/feature-flags-accessed';
import { buildCredentials } from './types';
import { defaultRequestServiceOptions, buildUrl, buildHeaders } from './shared';

/**
 * @returns Promise containing the json response
 */
var _requestService = function requestService(serviceConfig, options) {
  var url = serviceConfig.url,
    securityProvider = serviceConfig.securityProvider,
    refreshedSecurityProvider = serviceConfig.refreshedSecurityProvider;
  var _ref = options || defaultRequestServiceOptions,
    path = _ref.path,
    queryParams = _ref.queryParams,
    requestInit = _ref.requestInit;
  var secOptions = securityProvider && securityProvider();
  var requestUrl = buildUrl(url, path, queryParams, secOptions);
  var headers = buildHeaders(secOptions, requestInit && requestInit.headers);
  var credentials = buildCredentials(secOptions);
  var ignoreResponsePayload = (options === null || options === void 0 ? void 0 : options.ignoreResponsePayload) || false;

  // Get tracing headers from UFO
  var TRACING_HEADER_FOR_SERVICE_UTIL = 'platform_collab_provider_tracingheaders';
  var tracingHeaderEnabled = fg('platform_collab_provider_tracingheaders');
  addFeatureFlagAccessed(TRACING_HEADER_FOR_SERVICE_UTIL, tracingHeaderEnabled);
  var tracingHeaders = {};
  if (tracingHeaderEnabled) {
    tracingHeaders = getActiveTraceHttpRequestHeaders(url);
  }
  var requestOptions = _objectSpread(_objectSpread({}, requestInit), {}, {
    // populate headers mainly for the collab provider however
    // other components which uses this util can get the header as well.
    // Those tracing headers shall not incur any issues as long as backends handle them properly
    headers: _objectSpread(_objectSpread({}, headers), tracingHeaders),
    credentials: credentials
  });
  return fetch(requestUrl, requestOptions).then(function (response) {
    if (response.status === 204) {
      return Promise.resolve();
    } else if (response.ok) {
      return ignoreResponsePayload ? Promise.resolve() : response.json();
    } else if (response.status === 401 && refreshedSecurityProvider) {
      // auth issue - try once
      return refreshedSecurityProvider().then(function (newSecOptions) {
        var retryServiceConfig = {
          url: url,
          securityProvider: function securityProvider() {
            return newSecOptions;
          }
        };
        return _requestService(retryServiceConfig, options);
      });
    }
    return Promise.reject({
      code: response.status,
      reason: response.statusText
    });
  });
};
export { _requestService as requestService };