import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { changeImageAlignment, toggleBlockMark } from '@atlaskit/editor-common/commands';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { Selection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
/**
 * Iterates over the commands one after the other,
 * passes the tr through and dispatches the cumulated transaction
 */
function cascadeCommands(cmds) {
  return (state, dispatch) => {
    const {
      tr: baseTr
    } = state;
    let shouldDispatch = false;
    const onDispatchAction = tr => {
      const selectionJSON = tr.selection.toJSON();
      baseTr.setSelection(Selection.fromJSON(baseTr.doc, selectionJSON));
      tr.steps.forEach(st => {
        baseTr.step(st);
      });
      shouldDispatch = true;
    };
    cmds.forEach(cmd => cmd(state, onDispatchAction));
    if (dispatch && shouldDispatch) {
      dispatch(baseTr);
      return true;
    }
    return false;
  };
}
export const isAlignable = align => (state, dispatch) => {
  const {
    nodes: {
      paragraph,
      heading
    },
    marks: {
      alignment
    }
  } = state.schema;
  return toggleBlockMark(alignment, () => !align ? undefined : align === 'start' ? false : {
    align
  }, [paragraph, heading])(state, dispatch);
};
const changeBlockAlignmentWithAnalytics = (editorAnalyticsApi, align, inputMethod) => (state, dispatch) => {
  const {
    nodes: {
      paragraph,
      heading
    },
    marks: {
      alignment
    }
  } = state.schema;
  return withAnalytics(editorAnalyticsApi, {
    eventType: EVENT_TYPE.TRACK,
    actionSubject: ACTION_SUBJECT.ALIGNMENT,
    action: ACTION.UPDATED,
    actionSubjectId: ACTION_SUBJECT_ID.TEXT,
    attributes: {
      alignmentType: align,
      inputMethod
    }
  })(toggleBlockMark(alignment, () => !align ? undefined : align === 'start' ? false : {
    align
  }, [paragraph, heading]))(state, dispatch);
};
const changeImageAlignmentWithAnalytics = (editorAnalyticsApi, align, inputMethod) => (state, dispatch) => {
  return withAnalytics(editorAnalyticsApi, {
    eventType: EVENT_TYPE.TRACK,
    actionSubject: ACTION_SUBJECT.ALIGNMENT,
    action: ACTION.UPDATED,
    actionSubjectId: ACTION_SUBJECT_ID.MEDIA_SINGLE,
    attributes: {
      alignmentType: align,
      inputMethod
    }
  })(changeImageAlignment(align))(state, dispatch);
};
export const changeAlignment = (align, api, inputMethod) => (state, dispatch) => {
  var _api$analytics, _api$analytics2;
  const {
    nodes: {
      paragraph,
      heading
    },
    marks: {
      alignment
    }
  } = state.schema;
  return cascadeCommands(fg('platform_editor_add_alignment_tracking') ? [changeImageAlignmentWithAnalytics(api === null || api === void 0 ? void 0 : (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions, align, inputMethod), changeBlockAlignmentWithAnalytics(api === null || api === void 0 ? void 0 : (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, align, inputMethod)] : [changeImageAlignment(align), toggleBlockMark(alignment, () => !align ? undefined : align === 'start' ? false : {
    align
  }, [paragraph, heading])])(state, dispatch);
};