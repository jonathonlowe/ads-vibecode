import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { changeImageAlignment, toggleBlockMark } from '@atlaskit/editor-common/commands';
import { withAnalytics } from '@atlaskit/editor-common/editor-analytics';
import { Selection } from '@atlaskit/editor-prosemirror/state';
import { fg } from '@atlaskit/platform-feature-flags';
/**
 * Iterates over the commands one after the other,
 * passes the tr through and dispatches the cumulated transaction
 */
function cascadeCommands(cmds) {
  return function (state, dispatch) {
    var baseTr = state.tr;
    var shouldDispatch = false;
    var onDispatchAction = function onDispatchAction(tr) {
      var selectionJSON = tr.selection.toJSON();
      baseTr.setSelection(Selection.fromJSON(baseTr.doc, selectionJSON));
      tr.steps.forEach(function (st) {
        baseTr.step(st);
      });
      shouldDispatch = true;
    };
    cmds.forEach(function (cmd) {
      return cmd(state, onDispatchAction);
    });
    if (dispatch && shouldDispatch) {
      dispatch(baseTr);
      return true;
    }
    return false;
  };
}
export var isAlignable = function isAlignable(align) {
  return function (state, dispatch) {
    var _state$schema = state.schema,
      _state$schema$nodes = _state$schema.nodes,
      paragraph = _state$schema$nodes.paragraph,
      heading = _state$schema$nodes.heading,
      alignment = _state$schema.marks.alignment;
    return toggleBlockMark(alignment, function () {
      return !align ? undefined : align === 'start' ? false : {
        align: align
      };
    }, [paragraph, heading])(state, dispatch);
  };
};
var changeBlockAlignmentWithAnalytics = function changeBlockAlignmentWithAnalytics(editorAnalyticsApi, align, inputMethod) {
  return function (state, dispatch) {
    var _state$schema2 = state.schema,
      _state$schema2$nodes = _state$schema2.nodes,
      paragraph = _state$schema2$nodes.paragraph,
      heading = _state$schema2$nodes.heading,
      alignment = _state$schema2.marks.alignment;
    return withAnalytics(editorAnalyticsApi, {
      eventType: EVENT_TYPE.TRACK,
      actionSubject: ACTION_SUBJECT.ALIGNMENT,
      action: ACTION.UPDATED,
      actionSubjectId: ACTION_SUBJECT_ID.TEXT,
      attributes: {
        alignmentType: align,
        inputMethod: inputMethod
      }
    })(toggleBlockMark(alignment, function () {
      return !align ? undefined : align === 'start' ? false : {
        align: align
      };
    }, [paragraph, heading]))(state, dispatch);
  };
};
var changeImageAlignmentWithAnalytics = function changeImageAlignmentWithAnalytics(editorAnalyticsApi, align, inputMethod) {
  return function (state, dispatch) {
    return withAnalytics(editorAnalyticsApi, {
      eventType: EVENT_TYPE.TRACK,
      actionSubject: ACTION_SUBJECT.ALIGNMENT,
      action: ACTION.UPDATED,
      actionSubjectId: ACTION_SUBJECT_ID.MEDIA_SINGLE,
      attributes: {
        alignmentType: align,
        inputMethod: inputMethod
      }
    })(changeImageAlignment(align))(state, dispatch);
  };
};
export var changeAlignment = function changeAlignment(align, api, inputMethod) {
  return function (state, dispatch) {
    var _api$analytics, _api$analytics2;
    var _state$schema3 = state.schema,
      _state$schema3$nodes = _state$schema3.nodes,
      paragraph = _state$schema3$nodes.paragraph,
      heading = _state$schema3$nodes.heading,
      alignment = _state$schema3.marks.alignment;
    return cascadeCommands(fg('platform_editor_add_alignment_tracking') ? [changeImageAlignmentWithAnalytics(api === null || api === void 0 || (_api$analytics = api.analytics) === null || _api$analytics === void 0 ? void 0 : _api$analytics.actions, align, inputMethod), changeBlockAlignmentWithAnalytics(api === null || api === void 0 || (_api$analytics2 = api.analytics) === null || _api$analytics2 === void 0 ? void 0 : _api$analytics2.actions, align, inputMethod)] : [changeImageAlignment(align), toggleBlockMark(alignment, function () {
      return !align ? undefined : align === 'start' ? false : {
        align: align
      };
    }, [paragraph, heading])])(state, dispatch);
  };
};