import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useRef } from 'react';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import createEventPayload from '../../common/utils/analytics/analytics.codegen';
import { ANALYTICS_CHANNEL } from '../constants';
import { useLinkPickerAnalytics } from './index';
const isEventWithInputType = e => {
  return typeof e === 'object' && e !== null && 'inputType' in e;
};
const getChangeEventInputMethodType = event => {
  if (isEventWithInputType(event.nativeEvent) && typeof event.nativeEvent.inputType === 'string' && event.nativeEvent.inputType.includes('insertFromPaste')) {
    return 'paste';
  }
  return 'manual';
};

/**
 * Wraps an input field and connects it to the link picker analytics context to provide a baseline of analytics tracking
 * @param WrappedComponent The input field to be tracked
 * @param field The name of the field (ie matching actionSubjectId)
 * @param filterOnChangeEventAttrs Function to hook into and filter/customise the default attribute tracking logic
 * @returns HOC Input field with tracking
 */
export const withInputFieldTracking = (WrappedComponent, field, filterOnChangeEventAttrs = (_, attributes) => attributes
// TODO: Consider refactor to use template literal type if it makes these more usable / safe / dev friendly
// contentTypeFn: (value: string) => LinkPickerAnalyticsContextType[`${Field}FieldContent`],
) => {
  return props => {
    const {
      onBlur,
      onChange,
      onClear,
      onFocus
    } = props;
    const {
      trackAttribute,
      trackAttributes
    } = useLinkPickerAnalytics();
    const {
      createAnalyticsEvent
    } = useAnalyticsEvents();

    // Ref to track if the value of the field has changed between focus and blur
    const valueOnFocus = useRef(null);

    // Track the content and input method on every direct change to the input
    const handleOnChange = useCallback(event => {
      // TODO: See above re template literal, improve typesafety here
      // trackAttribute(`${field}FieldContent`, contentTypeFn(event.currentTarget.value));
      // trackAttribute(`${field}FieldContentInputMethod`, methodTypeFn(event));
      trackAttributes(filterOnChangeEventAttrs(event, {
        [`${field}FieldContent`]: Boolean(event.currentTarget.value) ? 'text_string' : null,
        [`${field}FieldContentInputMethod`]: getChangeEventInputMethodType(event)
      }));
      onChange === null || onChange === void 0 ? void 0 : onChange(event);
    }, [onChange, trackAttributes]);

    // Store the value of the field at the time the field is focused so we can know if it changes when the user's focus leaves
    const handleOnFocus = useCallback(event => {
      valueOnFocus.current = event.currentTarget.value;
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
    }, [onFocus]);

    // Fire updated events only when the user's focus leaves the field
    const handleOnBlur = useCallback(event => {
      // Only fire if the value has changed since the field was focused (we are only concerned with the net change to the field)
      if (event.currentTarget.value !== valueOnFocus.current) {
        createAnalyticsEvent(createEventPayload(`ui.textField.updated.${field}Field`, {})).fire(ANALYTICS_CHANNEL);
      }
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
    }, [onBlur, createAnalyticsEvent]);

    // Track the values as null when the text field is cleared
    const handleOnClear = useCallback((...args) => {
      trackAttribute(`${field}FieldContent`, null);
      trackAttribute(`${field}FieldContentInputMethod`, null);
      onClear === null || onClear === void 0 ? void 0 : onClear(...args);
    }, [onClear, trackAttribute]);
    return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, props, {
      onBlur: handleOnBlur,
      onChange: handleOnChange,
      onClear: handleOnClear,
      onFocus: handleOnFocus
    }));
  };
};