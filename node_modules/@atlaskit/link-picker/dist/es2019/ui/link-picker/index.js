/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import "./index.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { Fragment, memo, useCallback, useLayoutEffect, useMemo, useReducer } from 'react';
import { FormattedMessage, useIntl } from 'react-intl-next';
import uuid from 'uuid';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { HelperMessage } from '@atlaskit/form';
import { isSafeUrl, normalizeUrl } from '@atlaskit/linking-common/url';
import { browser } from '@atlaskit/linking-common/user-agent';
import { fg } from '@atlaskit/platform-feature-flags';
import { Box } from '@atlaskit/primitives/compiled';
import { N700 } from '@atlaskit/theme/colors';
import VisuallyHidden from '@atlaskit/visually-hidden';
import { useLinkPickerAnalytics, withInputFieldTracking, withLinkPickerAnalyticsContext } from '../../common/analytics';
import { ANALYTICS_CHANNEL } from '../../common/constants';
import createEventPayload from '../../common/utils/analytics/analytics.codegen';
import { handleNavKeyDown } from '../../common/utils/handleNavKeyDown';
import { usePlugins } from '../../services/use-plugins';
import { useSearchQuery } from '../../services/use-search-query';
import { Announcer } from './announcer';
import { FormFooter, testIds as formFooterTestIds } from './form-footer';
import { LinkPickerSubmitButton } from './form-footer/link-picker-submit-button';
import { formMessages, linkMessages, linkTextMessages, searchMessages } from './messages';
import { SearchResults, testIds as searchTestIds } from './search-results';
import { testIds as textFieldTestIds, TextInput } from './text-input';
import { TrackMount } from './track-mount';
import { getDataSource, getScreenReaderText } from './utils';
const styles = {
  fullWidthSubmitButton: "_19pkpxbi _1e0c1txw _2lx21bp4",
  linkDisplayHelperTextContainer: "_19pk1b66 _syaz1be1",
  linkDisplayHelperText: "_11c81o8v"
};
const baseRootContainerStyles = null;
// To be removed when platform-linking-visual-refresh-v1 is removed
const oldRootContainerStyles = null;
const formFooterMargin = null;
export const testIds = {
  linkPickerRoot: 'link-picker-root',
  linkPicker: 'link-picker',
  urlInputField: 'link-url',
  textInputField: 'link-text',
  linkHelperText: 'link-helper-text',
  ...searchTestIds,
  ...formFooterTestIds,
  ...textFieldTestIds
};
const initState = {
  url: '',
  displayText: '',
  activeIndex: -1,
  selectedIndex: -1,
  invalidUrl: false,
  activeTab: 0,
  preventHidingRecents: false
};
function reducer(state, payload) {
  if (payload.url && state.url !== payload.url) {
    return {
      ...state,
      invalidUrl: false,
      selectedIndex: isSafeUrl(payload.url) && payload.url.length ? -1 : state.selectedIndex,
      ...payload
    };
  }
  return {
    ...state,
    ...payload
  };
}

/**
 * Bind input fields to analytics tracking
 */
const getLinkFieldContent = value => {
  if (!Boolean(value)) {
    return null;
  }
  return isSafeUrl(value) ? 'url' : 'text_string';
};
const LinkInputField = withInputFieldTracking(TextInput, 'link', (event, attributes) => ({
  ...attributes,
  linkFieldContent: getLinkFieldContent(event.currentTarget.value)
}));
const DisplayTextInputField = withInputFieldTracking(TextInput, 'displayText');
export const LinkPicker = withLinkPickerAnalyticsContext( /*#__PURE__*/memo(({
  onSubmit,
  onCancel,
  onContentResize,
  plugins,
  isLoadingPlugins,
  url: initUrl,
  displayText: initDisplayText,
  hideDisplayText,
  featureFlags,
  customMessages,
  isSubmitting = false,
  adaptiveHeight = false,
  moveSubmitButton = false,
  inputRef
}) => {
  const {
    createAnalyticsEvent
  } = useAnalyticsEvents();
  const [state, dispatch] = useReducer(reducer, {
    ...initState,
    url: normalizeUrl(initUrl) || '',
    displayText: initDisplayText || ''
  });
  const {
    activeIndex,
    selectedIndex,
    url,
    displayText,
    invalidUrl,
    activeTab
  } = state;
  const intl = useIntl();
  const queryState = useSearchQuery(state);
  const {
    items,
    isLoading: isLoadingResults,
    isActivePlugin,
    activePlugin,
    tabs,
    error,
    retry,
    pluginAction
  } = usePlugins(queryState, activeTab, plugins);
  const isEditing = !!initUrl;
  const selectedItem = items === null || items === void 0 ? void 0 : items[selectedIndex];
  const isSelectedItem = (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.url) === url;
  const {
    trackAttribute,
    getAttributes
  } = useLinkPickerAnalytics();
  const submitMessageId = useMemo(() => uuid(), []);
  useLayoutEffect(() => {
    if (onContentResize) {
      onContentResize();
    }
  }, [onContentResize, items, isLoadingResults, isActivePlugin, tabs]);
  const handleChangeUrl = useCallback(e => {
    if (isSubmitting) {
      // Prevent changing url while submitting
      return;
    }

    /** Any on change event is triggered by manual input or paste, so source is null */
    trackAttribute('linkFieldContentInputSource', null);
    dispatch({
      url: e.currentTarget.value,
      // If the last action was changing tabs, make sure we're now allowing recents to be hidden
      preventHidingRecents: false
    });
  }, [dispatch, trackAttribute, isSubmitting]);
  const handleChangeText = useCallback(e => {
    dispatch({
      displayText: e.currentTarget.value
    });
  }, [dispatch]);
  const handleClear = useCallback(field => {
    dispatch({
      activeIndex: -1,
      selectedIndex: -1,
      [field]: ''
    });
  }, [dispatch]);
  const handleUrlClear = useCallback(() => {
    if (isSubmitting) {
      // Prevent clearing url while submitting
      return;
    }
    trackAttribute('linkFieldContentInputSource', null);
    handleClear('url');
  }, [trackAttribute, handleClear, isSubmitting]);
  const handleInsert = useCallback((url, title, inputType, data) => {
    const event = createAnalyticsEvent(createEventPayload('ui.form.submitted.linkPicker', {}));

    // Clone the event so that it can be emitted for consumer usage
    // This must happen BEFORE the original event is fired!
    const consumerEvent = event.clone();
    // Cloned event doesnt have the attributes that are added by
    // the analytics listener in the LinkPickerAnalyticsContext, add them here
    consumerEvent === null || consumerEvent === void 0 ? void 0 : consumerEvent.update({
      attributes: getAttributes()
    });
    // Dispatch the original event to our channel
    event.fire(ANALYTICS_CHANNEL);
    onSubmit({
      url,
      displayText: displayText || null,
      title: title || null,
      meta: {
        inputMethod: inputType
      },
      data,
      ...(inputType === 'manual' ? {
        rawUrl: state.url
      } : {})
    }, consumerEvent);
  }, [displayText, onSubmit, state.url, createAnalyticsEvent, getAttributes]);
  const handleSelected = useCallback(objectId => {
    if (isSubmitting) {
      // Prevent changing selection while submitting
      return;
    }
    const selectedItem = items === null || items === void 0 ? void 0 : items.find(item => item.objectId === objectId);
    if (selectedItem) {
      const {
        url,
        name
      } = selectedItem;
      /**
       * Manually track that the url has been updated using searchResult method
       */
      dispatchEvent(new Event('submit'));
      trackAttribute('linkFieldContent', getLinkFieldContent(url));
      trackAttribute('linkFieldContentInputMethod', 'searchResult');
      trackAttribute('linkFieldContentInputSource', getDataSource(selectedItem, activePlugin));
      handleInsert(url, name, 'typeAhead', {
        ...selectedItem
      });
    }
  }, [handleInsert, trackAttribute, items, activePlugin, isSubmitting]);
  const handleSubmit = useCallback(event => {
    event === null || event === void 0 ? void 0 : event.preventDefault();
    if (isSubmitting) {
      // Prevent submit while submitting
      return;
    }
    if (isSelectedItem && selectedItem) {
      return handleInsert(selectedItem.url, selectedItem.name, 'typeAhead');
    }
    const normalized = normalizeUrl(url);
    if (normalized) {
      return handleInsert(normalized, null, 'manual');
    }
    return dispatch({
      invalidUrl: true
    });
  }, [dispatch, handleInsert, isSelectedItem, selectedItem, url, isSubmitting]);
  const handleTabChange = useCallback(activeTab => {
    var _plugins$activeTab$ta, _plugins$activeTab;
    dispatch({
      // We don't want any selection to exist after changing tab, as the selection
      // wouldn't mean anything.
      activeIndex: -1,
      selectedIndex: -1,
      // We don't want recents to be hidden, even though we don't have a selection
      preventHidingRecents: true,
      invalidUrl: false,
      activeTab
    });
    trackAttribute('tab', (_plugins$activeTab$ta = plugins === null || plugins === void 0 ? void 0 : (_plugins$activeTab = plugins[activeTab]) === null || _plugins$activeTab === void 0 ? void 0 : _plugins$activeTab.tabKey) !== null && _plugins$activeTab$ta !== void 0 ? _plugins$activeTab$ta : null);
  }, [dispatch, plugins, trackAttribute]);
  const handleSearchListOnChange = id => {
    if (isSubmitting) {
      // Prevent changing item while submitting
      return;
    }
    const index = items === null || items === void 0 ? void 0 : items.findIndex(item => item.objectId === id);
    if (typeof index === 'number') {
      const item = items === null || items === void 0 ? void 0 : items[index];
      if (item) {
        /**
         * Manually track that the url has been updated using searchResult method
         */
        trackAttribute('linkFieldContent', getLinkFieldContent(item.url));
        trackAttribute('linkFieldContentInputMethod', 'searchResult');
        trackAttribute('linkFieldContentInputSource', getDataSource(item, activePlugin));
        dispatch({
          activeIndex: index,
          selectedIndex: index,
          url: item.url,
          invalidUrl: false
        });
      }
    }
  };
  const handleKeyDown = useCallback(event => {
    if (!(items !== null && items !== void 0 && items.length)) {
      return;
    }
    let updatedIndex = activeIndex;
    if (event.key === 'Enter') {
      event.preventDefault();
      if (selectedItem) {
        handleSelected(selectedItem.objectId);
      } else {
        // triggers validation error message
        handleSubmit();
      }
    } else {
      updatedIndex = handleNavKeyDown(event, items.length, activeIndex);
    }
    const item = items[updatedIndex];
    if (['Enter', 'ArrowDown', 'ArrowUp', 'Home', 'End'].includes(event.key) && item) {
      /**
       * Manually track that the url has been updated using searchResult method
       */
      trackAttribute('linkFieldContent', getLinkFieldContent(item.url));
      trackAttribute('linkFieldContentInputMethod', 'searchResult');
      trackAttribute('linkFieldContentInputSource', getDataSource(item, activePlugin));
      dispatch({
        activeIndex: updatedIndex,
        selectedIndex: updatedIndex,
        url: item.url,
        invalidUrl: false
      });
    }
  }, [items, activeIndex, selectedItem, handleSelected, handleSubmit, trackAttribute, activePlugin]);
  const messages = isActivePlugin ? searchMessages : linkMessages;
  const screenReaderDescriptionId = 'search-recent-links-field-description';
  const linkSearchListId = 'link-picker-search-list';
  const ariaActiveDescendant = selectedIndex > -1 ? `link-search-list-item-${selectedIndex}` : '';
  const a11yList = isActivePlugin || isLoadingPlugins ? {
    role: 'combobox',
    // When a combobox popup is not visible, the element with role combobox has aria-expanded set to false
    // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded#combobox
    'aria-expanded': !!(items !== null && items !== void 0 && items.length),
    'aria-autocomplete': 'list',
    'aria-controls': linkSearchListId,
    'aria-activedescendant': ariaActiveDescendant,
    'aria-describedby': screenReaderDescriptionId
  } : undefined;

  // Added workaround with a screen reader Announcer specifically for VoiceOver + Safari
  // as the Aria design pattern for combobox does not work in this case
  // for details: https://a11y-internal.atlassian.net/browse/AK-740
  const screenReaderText = browser().safari && getScreenReaderText(items !== null && items !== void 0 ? items : [], selectedIndex, intl);
  const customSubmitButtonLabel = customMessages !== null && customMessages !== void 0 && customMessages.submitButtonLabel ? customMessages.submitButtonLabel : undefined;
  return /*#__PURE__*/React.createElement("form", {
    "data-testid": testIds.linkPicker,
    // Use onSubmitCapture instead of onSubmit so that any possible parent form isn't submitted
    onSubmitCapture: handleSubmit,
    className: ax(["_19bv164s _u5f31pah _ca0q1k79 _n3td1t3k _vchhusvi _1e0ctcjq", !fg('platform-linking-visual-refresh-v1') && "_vwz44jg8"])
  }, /*#__PURE__*/React.createElement(TrackMount, null), isActivePlugin && /*#__PURE__*/React.createElement(Fragment, null, screenReaderText && /*#__PURE__*/React.createElement(Announcer, {
    ariaLive: "assertive",
    text: screenReaderText,
    ariaRelevant: "additions",
    delay: 250
  }), /*#__PURE__*/React.createElement(VisuallyHidden, {
    id: screenReaderDescriptionId
  }, customMessages !== null && customMessages !== void 0 && customMessages.linkAriaLabel ? /*#__PURE__*/React.createElement(FormattedMessage, customMessages.linkAriaLabel) : /*#__PURE__*/React.createElement(FormattedMessage, messages.linkAriaLabel))), /*#__PURE__*/React.createElement(LinkInputField, _extends({
    name: "url",
    autoComplete: "off",
    testId: testIds.urlInputField,
    label: customMessages !== null && customMessages !== void 0 && customMessages.linkLabel ? intl.formatMessage(customMessages.linkLabel) : intl.formatMessage(messages.linkLabel),
    placeholder: customMessages !== null && customMessages !== void 0 && customMessages.linkPlaceholder ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkPlaceholder) : intl.formatMessage(messages.linkPlaceholder),
    value: url,
    autoFocus: true,
    clearLabel: intl.formatMessage(formMessages.clearLink),
    error: invalidUrl ? intl.formatMessage(formMessages.linkInvalid) : null,
    spotlightTargetName: "link-picker-search-field-spotlight-target",
    "aria-readonly": isSubmitting
  }, a11yList, {
    onClear: handleUrlClear,
    onKeyDown: handleKeyDown,
    onChange: handleChangeUrl,
    inputRef: inputRef
  })), !hideDisplayText && /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(DisplayTextInputField, {
    autoComplete: "off",
    name: "displayText",
    testId: testIds.textInputField,
    value: displayText,
    label: customMessages !== null && customMessages !== void 0 && customMessages.linkTextLabel ? intl.formatMessage(customMessages.linkTextLabel) : intl.formatMessage(linkTextMessages.linkTextLabel),
    placeholder: customMessages !== null && customMessages !== void 0 && customMessages.linkTextPlaceholder ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkTextPlaceholder) : intl.formatMessage(linkTextMessages.linkTextPlaceholder),
    clearLabel: intl.formatMessage(linkTextMessages.clearLinkText),
    readOnly: isSubmitting,
    onClear: handleClear,
    onChange: handleChangeText
  }), fg('platform-linking-visual-refresh-link-picker') && /*#__PURE__*/React.createElement(HelperMessage, {
    testId: testIds.linkHelperText
  }, customMessages !== null && customMessages !== void 0 && customMessages.linkHelperTextLabel ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkHelperTextLabel) : intl.formatMessage(linkTextMessages.linkHelperTextLabel))), moveSubmitButton && /*#__PURE__*/React.createElement(Box, {
    xcss: styles.fullWidthSubmitButton
  }, /*#__PURE__*/React.createElement(LinkPickerSubmitButton, {
    isEditing: isEditing,
    isLoading: isLoadingResults || !!isLoadingPlugins,
    isSubmitting: isSubmitting,
    customSubmitButtonLabel: customSubmitButtonLabel,
    error: error,
    items: items,
    queryState: queryState,
    submitMessageId: submitMessageId,
    testId: testIds.insertButton,
    url: url
  })), !!queryState && (isLoadingPlugins || isActivePlugin) && /*#__PURE__*/React.createElement(SearchResults, {
    activeTab: activeTab,
    tabs: tabs,
    activePlugin: activePlugin,
    isLoadingResults: isLoadingResults,
    isLoadingPlugins: isLoadingPlugins,
    isSubmitting: isSubmitting,
    linkSearchListId: linkSearchListId,
    error: error,
    featureFlags: featureFlags,
    activeIndex: activeIndex,
    selectedIndex: selectedIndex,
    items: items,
    queryState: queryState,
    handleKeyDown: handleKeyDown,
    handleSelected: handleSelected,
    handleTabChange: handleTabChange,
    handleSearchListOnChange: handleSearchListOnChange,
    adaptiveHeight: adaptiveHeight,
    retry: retry
  }), /*#__PURE__*/React.createElement(FormFooter, {
    error: error,
    items: items
    /** If the results section appears to be loading, impact whether the submit button is disabled */,
    isLoading: isLoadingResults || !!isLoadingPlugins,
    isSubmitting: isSubmitting,
    queryState: queryState,
    url: url,
    isEditing: isEditing,
    onCancel: onCancel,
    action: pluginAction,
    customSubmitButtonLabel: customSubmitButtonLabel,
    submitMessageId: submitMessageId,
    hideSubmitButton: moveSubmitButton,
    className: ax([(!queryState || !(plugins !== null && plugins !== void 0 && plugins.length)) && "_19pkpxbi"])
  }));
}));