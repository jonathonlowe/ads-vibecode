import { useCallback, useEffect, useMemo, useState } from 'react';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { convertToError } from '@atlaskit/frontend-utilities/convert-to-error';
import { useLinkPickerAnalytics } from '../../common/analytics';
import { ANALYTICS_CHANNEL, RECENT_SEARCH_LIST_SIZE } from '../../common/constants';
import createEventPayload from '../../common/utils/analytics/analytics.codegen';
import { usePluginReducer } from './reducer';
import { CancellationError, resolvePluginUpdates } from './utils';
export function usePlugins(state, activeTab, plugins) {
  var _activePlugin$tabKey;
  const {
    createAnalyticsEvent
  } = useAnalyticsEvents();
  const [retries, setRetries] = useState(0);
  const [pluginState, dispatch] = usePluginReducer();
  const {
    trackAttribute
  } = useLinkPickerAnalytics();
  const activePlugin = plugins === null || plugins === void 0 ? void 0 : plugins[activeTab];
  trackAttribute('tab', (_activePlugin$tabKey = activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.tabKey) !== null && _activePlugin$tabKey !== void 0 ? _activePlugin$tabKey : null);

  // This useEffect block must be called before any other to ensure onActivation is fired at before resolve
  useEffect(() => {
    if (activePlugin && activePlugin.UNSAFE_onActivation) {
      activePlugin.UNSAFE_onActivation();
    }
  }, [activePlugin]);
  useEffect(() => {
    if (!activePlugin) {
      return;
    }
    if (!state) {
      dispatch({
        type: 'CLEAR'
      });
      return;
    }
    dispatch({
      type: 'LOADING'
    });
    const {
      next,
      cancel
    } = resolvePluginUpdates(activePlugin, state);
    const updateResults = async () => {
      try {
        let isLoading = true;
        while (isLoading) {
          const {
            value,
            done
          } = await next();
          isLoading = !done;
          dispatch({
            type: 'SUCCESS',
            payload: {
              items: limit(value.data),
              isLoading: !done
            }
          });
        }
      } catch (error) {
        if (!(error instanceof CancellationError)) {
          dispatch({
            type: 'ERROR',
            payload: error
          });
          createAnalyticsEvent(createEventPayload('operational.resultsResolve.failed', {
            error: convertToError(error).toString()
          })).fire(ANALYTICS_CHANNEL);
        }
      }
    };
    updateResults();
    return cancel;
  }, [activePlugin, state, retries, createAnalyticsEvent, dispatch]);
  const tabs = useMemo(() => {
    if (!plugins || plugins.length <= 1) {
      return [];
    }
    return plugins.filter(plugin => !!plugin.tabTitle).map(plugin => ({
      tabTitle: plugin.tabTitle
    }));
  }, [plugins]);
  const handleRetry = useCallback(() => {
    setRetries(prev => ++prev);
  }, []);
  const {
    items,
    isLoading,
    error
  } = pluginState;
  return {
    tabs,
    items,
    isLoading,
    activePlugin,
    isActivePlugin: !!activePlugin,
    error,
    retry: handleRetry,
    errorFallback: activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.errorFallback,
    pluginAction: activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.action
  };
}
function limit(items) {
  return items.slice(0, RECENT_SEARCH_LIST_SIZE);
}