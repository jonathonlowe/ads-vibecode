import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _createClass from "@babel/runtime/helpers/createClass";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _wrapNativeSuper from "@babel/runtime/helpers/wrapNativeSuper";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
export var CancellationError = /*#__PURE__*/function (_Error) {
  function CancellationError() {
    _classCallCheck(this, CancellationError);
    return _callSuper(this, CancellationError, arguments);
  }
  _inherits(CancellationError, _Error);
  return _createClass(CancellationError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
export var cancellable = function cancellable(promise) {
  var reject;
  return {
    promise: new Promise(function (resolve, _reject) {
      reject = _reject;
      promise.then(resolve, reject);
    }),
    cancel: function cancel() {
      reject(new CancellationError('Promise cancelled'));
    }
  };
};

/**
 * Wraps the resolve with a cancellation wrapper and makes promise + generator plugin resolves more compatible
 * Calling cancel for generator plugin prevents it from yielding any further updates
 */
export var resolvePluginUpdates = function resolvePluginUpdates(plugin, state) {
  var updates = plugin.resolve(state);

  // Promise plugin
  if (updates instanceof Promise) {
    var _cancellable = cancellable(updates),
      promise = _cancellable.promise,
      cancel = _cancellable.cancel;
    return {
      cancel: cancel,
      next: function () {
        var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return promise;
              case 2:
                _context.t0 = _context.sent;
                return _context.abrupt("return", {
                  value: _context.t0,
                  done: true
                });
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function next() {
          return _next.apply(this, arguments);
        }
        return next;
      }()
    };
  }

  // Generator plugin
  var cancellationCallbacks = [];
  var cancelled = false;
  return {
    cancel: function cancel() {
      cancelled = true;
      cancellationCallbacks.forEach(function (cb) {
        return cb();
      });
    },
    next: function next() {
      var _cancellable2 = cancellable(updates.next()),
        promise = _cancellable2.promise,
        cancel = _cancellable2.cancel;
      if (cancelled) {
        cancel();
      } else {
        cancellationCallbacks.push(cancel);
      }
      return promise;
    }
  };
};