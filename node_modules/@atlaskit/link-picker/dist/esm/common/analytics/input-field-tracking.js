import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _typeof from "@babel/runtime/helpers/typeof";
import React, { useCallback, useRef } from 'react';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import createEventPayload from '../../common/utils/analytics/analytics.codegen';
import { ANALYTICS_CHANNEL } from '../constants';
import { useLinkPickerAnalytics } from './index';
var isEventWithInputType = function isEventWithInputType(e) {
  return _typeof(e) === 'object' && e !== null && 'inputType' in e;
};
var getChangeEventInputMethodType = function getChangeEventInputMethodType(event) {
  if (isEventWithInputType(event.nativeEvent) && typeof event.nativeEvent.inputType === 'string' && event.nativeEvent.inputType.includes('insertFromPaste')) {
    return 'paste';
  }
  return 'manual';
};

/**
 * Wraps an input field and connects it to the link picker analytics context to provide a baseline of analytics tracking
 * @param WrappedComponent The input field to be tracked
 * @param field The name of the field (ie matching actionSubjectId)
 * @param filterOnChangeEventAttrs Function to hook into and filter/customise the default attribute tracking logic
 * @returns HOC Input field with tracking
 */
export var withInputFieldTracking = function withInputFieldTracking(WrappedComponent, field) {
  var filterOnChangeEventAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (_, attributes) {
    return attributes;
  };
  return function (props) {
    var onBlur = props.onBlur,
      onChange = props.onChange,
      onClear = props.onClear,
      onFocus = props.onFocus;
    var _useLinkPickerAnalyti = useLinkPickerAnalytics(),
      trackAttribute = _useLinkPickerAnalyti.trackAttribute,
      trackAttributes = _useLinkPickerAnalyti.trackAttributes;
    var _useAnalyticsEvents = useAnalyticsEvents(),
      createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;

    // Ref to track if the value of the field has changed between focus and blur
    var valueOnFocus = useRef(null);

    // Track the content and input method on every direct change to the input
    var handleOnChange = useCallback(function (event) {
      // TODO: See above re template literal, improve typesafety here
      // trackAttribute(`${field}FieldContent`, contentTypeFn(event.currentTarget.value));
      // trackAttribute(`${field}FieldContentInputMethod`, methodTypeFn(event));
      trackAttributes(filterOnChangeEventAttrs(event, _defineProperty(_defineProperty({}, "".concat(field, "FieldContent"), Boolean(event.currentTarget.value) ? 'text_string' : null), "".concat(field, "FieldContentInputMethod"), getChangeEventInputMethodType(event))));
      onChange === null || onChange === void 0 || onChange(event);
    }, [onChange, trackAttributes]);

    // Store the value of the field at the time the field is focused so we can know if it changes when the user's focus leaves
    var handleOnFocus = useCallback(function (event) {
      valueOnFocus.current = event.currentTarget.value;
      onFocus === null || onFocus === void 0 || onFocus(event);
    }, [onFocus]);

    // Fire updated events only when the user's focus leaves the field
    var handleOnBlur = useCallback(function (event) {
      // Only fire if the value has changed since the field was focused (we are only concerned with the net change to the field)
      if (event.currentTarget.value !== valueOnFocus.current) {
        createAnalyticsEvent(createEventPayload("ui.textField.updated.".concat(field, "Field"), {})).fire(ANALYTICS_CHANNEL);
      }
      onBlur === null || onBlur === void 0 || onBlur(event);
    }, [onBlur, createAnalyticsEvent]);

    // Track the values as null when the text field is cleared
    var handleOnClear = useCallback(function () {
      trackAttribute("".concat(field, "FieldContent"), null);
      trackAttribute("".concat(field, "FieldContentInputMethod"), null);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      onClear === null || onClear === void 0 || onClear.apply(void 0, args);
    }, [onClear, trackAttribute]);
    return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, props, {
      onBlur: handleOnBlur,
      onChange: handleOnChange,
      onClear: handleOnClear,
      onFocus: handleOnFocus
    }));
  };
};