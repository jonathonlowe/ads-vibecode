/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "./index.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { Fragment, memo, useCallback, useLayoutEffect, useMemo, useReducer } from 'react';
import { FormattedMessage, useIntl } from 'react-intl-next';
import uuid from 'uuid';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import { HelperMessage } from '@atlaskit/form';
import { isSafeUrl, normalizeUrl } from '@atlaskit/linking-common/url';
import { browser } from '@atlaskit/linking-common/user-agent';
import { fg } from '@atlaskit/platform-feature-flags';
import { Box } from '@atlaskit/primitives/compiled';
import { N700 } from '@atlaskit/theme/colors';
import VisuallyHidden from '@atlaskit/visually-hidden';
import { useLinkPickerAnalytics, withInputFieldTracking, withLinkPickerAnalyticsContext } from '../../common/analytics';
import { ANALYTICS_CHANNEL } from '../../common/constants';
import createEventPayload from '../../common/utils/analytics/analytics.codegen';
import { handleNavKeyDown } from '../../common/utils/handleNavKeyDown';
import { usePlugins } from '../../services/use-plugins';
import { useSearchQuery } from '../../services/use-search-query';
import { Announcer } from './announcer';
import { FormFooter, testIds as formFooterTestIds } from './form-footer';
import { LinkPickerSubmitButton } from './form-footer/link-picker-submit-button';
import { formMessages, linkMessages, linkTextMessages, searchMessages } from './messages';
import { SearchResults, testIds as searchTestIds } from './search-results';
import { testIds as textFieldTestIds, TextInput } from './text-input';
import { TrackMount } from './track-mount';
import { getDataSource, getScreenReaderText } from './utils';
var styles = {
  fullWidthSubmitButton: "_19pkpxbi _1e0c1txw _2lx21bp4",
  linkDisplayHelperTextContainer: "_19pk1b66 _syaz1be1",
  linkDisplayHelperText: "_11c81o8v"
};
var baseRootContainerStyles = null;
// To be removed when platform-linking-visual-refresh-v1 is removed
var oldRootContainerStyles = null;
var formFooterMargin = null;
export var testIds = _objectSpread(_objectSpread(_objectSpread({
  linkPickerRoot: 'link-picker-root',
  linkPicker: 'link-picker',
  urlInputField: 'link-url',
  textInputField: 'link-text',
  linkHelperText: 'link-helper-text'
}, searchTestIds), formFooterTestIds), textFieldTestIds);
var initState = {
  url: '',
  displayText: '',
  activeIndex: -1,
  selectedIndex: -1,
  invalidUrl: false,
  activeTab: 0,
  preventHidingRecents: false
};
function reducer(state, payload) {
  if (payload.url && state.url !== payload.url) {
    return _objectSpread(_objectSpread({}, state), {}, {
      invalidUrl: false,
      selectedIndex: isSafeUrl(payload.url) && payload.url.length ? -1 : state.selectedIndex
    }, payload);
  }
  return _objectSpread(_objectSpread({}, state), payload);
}

/**
 * Bind input fields to analytics tracking
 */
var getLinkFieldContent = function getLinkFieldContent(value) {
  if (!Boolean(value)) {
    return null;
  }
  return isSafeUrl(value) ? 'url' : 'text_string';
};
var LinkInputField = withInputFieldTracking(TextInput, 'link', function (event, attributes) {
  return _objectSpread(_objectSpread({}, attributes), {}, {
    linkFieldContent: getLinkFieldContent(event.currentTarget.value)
  });
});
var DisplayTextInputField = withInputFieldTracking(TextInput, 'displayText');
export var LinkPicker = withLinkPickerAnalyticsContext( /*#__PURE__*/memo(function (_ref) {
  var onSubmit = _ref.onSubmit,
    onCancel = _ref.onCancel,
    onContentResize = _ref.onContentResize,
    plugins = _ref.plugins,
    isLoadingPlugins = _ref.isLoadingPlugins,
    initUrl = _ref.url,
    initDisplayText = _ref.displayText,
    hideDisplayText = _ref.hideDisplayText,
    featureFlags = _ref.featureFlags,
    customMessages = _ref.customMessages,
    _ref$isSubmitting = _ref.isSubmitting,
    isSubmitting = _ref$isSubmitting === void 0 ? false : _ref$isSubmitting,
    _ref$adaptiveHeight = _ref.adaptiveHeight,
    adaptiveHeight = _ref$adaptiveHeight === void 0 ? false : _ref$adaptiveHeight,
    _ref$moveSubmitButton = _ref.moveSubmitButton,
    moveSubmitButton = _ref$moveSubmitButton === void 0 ? false : _ref$moveSubmitButton,
    inputRef = _ref.inputRef;
  var _useAnalyticsEvents = useAnalyticsEvents(),
    createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
  var _useReducer = useReducer(reducer, _objectSpread(_objectSpread({}, initState), {}, {
      url: normalizeUrl(initUrl) || '',
      displayText: initDisplayText || ''
    })),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    state = _useReducer2[0],
    dispatch = _useReducer2[1];
  var activeIndex = state.activeIndex,
    selectedIndex = state.selectedIndex,
    url = state.url,
    displayText = state.displayText,
    invalidUrl = state.invalidUrl,
    activeTab = state.activeTab;
  var intl = useIntl();
  var queryState = useSearchQuery(state);
  var _usePlugins = usePlugins(queryState, activeTab, plugins),
    items = _usePlugins.items,
    isLoadingResults = _usePlugins.isLoading,
    isActivePlugin = _usePlugins.isActivePlugin,
    activePlugin = _usePlugins.activePlugin,
    tabs = _usePlugins.tabs,
    error = _usePlugins.error,
    retry = _usePlugins.retry,
    pluginAction = _usePlugins.pluginAction;
  var isEditing = !!initUrl;
  var selectedItem = items === null || items === void 0 ? void 0 : items[selectedIndex];
  var isSelectedItem = (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.url) === url;
  var _useLinkPickerAnalyti = useLinkPickerAnalytics(),
    trackAttribute = _useLinkPickerAnalyti.trackAttribute,
    getAttributes = _useLinkPickerAnalyti.getAttributes;
  var submitMessageId = useMemo(function () {
    return uuid();
  }, []);
  useLayoutEffect(function () {
    if (onContentResize) {
      onContentResize();
    }
  }, [onContentResize, items, isLoadingResults, isActivePlugin, tabs]);
  var handleChangeUrl = useCallback(function (e) {
    if (isSubmitting) {
      // Prevent changing url while submitting
      return;
    }

    /** Any on change event is triggered by manual input or paste, so source is null */
    trackAttribute('linkFieldContentInputSource', null);
    dispatch({
      url: e.currentTarget.value,
      // If the last action was changing tabs, make sure we're now allowing recents to be hidden
      preventHidingRecents: false
    });
  }, [dispatch, trackAttribute, isSubmitting]);
  var handleChangeText = useCallback(function (e) {
    dispatch({
      displayText: e.currentTarget.value
    });
  }, [dispatch]);
  var handleClear = useCallback(function (field) {
    dispatch(_defineProperty({
      activeIndex: -1,
      selectedIndex: -1
    }, field, ''));
  }, [dispatch]);
  var handleUrlClear = useCallback(function () {
    if (isSubmitting) {
      // Prevent clearing url while submitting
      return;
    }
    trackAttribute('linkFieldContentInputSource', null);
    handleClear('url');
  }, [trackAttribute, handleClear, isSubmitting]);
  var handleInsert = useCallback(function (url, title, inputType, data) {
    var event = createAnalyticsEvent(createEventPayload('ui.form.submitted.linkPicker', {}));

    // Clone the event so that it can be emitted for consumer usage
    // This must happen BEFORE the original event is fired!
    var consumerEvent = event.clone();
    // Cloned event doesnt have the attributes that are added by
    // the analytics listener in the LinkPickerAnalyticsContext, add them here
    consumerEvent === null || consumerEvent === void 0 || consumerEvent.update({
      attributes: getAttributes()
    });
    // Dispatch the original event to our channel
    event.fire(ANALYTICS_CHANNEL);
    onSubmit(_objectSpread({
      url: url,
      displayText: displayText || null,
      title: title || null,
      meta: {
        inputMethod: inputType
      },
      data: data
    }, inputType === 'manual' ? {
      rawUrl: state.url
    } : {}), consumerEvent);
  }, [displayText, onSubmit, state.url, createAnalyticsEvent, getAttributes]);
  var handleSelected = useCallback(function (objectId) {
    if (isSubmitting) {
      // Prevent changing selection while submitting
      return;
    }
    var selectedItem = items === null || items === void 0 ? void 0 : items.find(function (item) {
      return item.objectId === objectId;
    });
    if (selectedItem) {
      var _url = selectedItem.url,
        name = selectedItem.name;
      /**
       * Manually track that the url has been updated using searchResult method
       */
      dispatchEvent(new Event('submit'));
      trackAttribute('linkFieldContent', getLinkFieldContent(_url));
      trackAttribute('linkFieldContentInputMethod', 'searchResult');
      trackAttribute('linkFieldContentInputSource', getDataSource(selectedItem, activePlugin));
      handleInsert(_url, name, 'typeAhead', _objectSpread({}, selectedItem));
    }
  }, [handleInsert, trackAttribute, items, activePlugin, isSubmitting]);
  var handleSubmit = useCallback(function (event) {
    event === null || event === void 0 || event.preventDefault();
    if (isSubmitting) {
      // Prevent submit while submitting
      return;
    }
    if (isSelectedItem && selectedItem) {
      return handleInsert(selectedItem.url, selectedItem.name, 'typeAhead');
    }
    var normalized = normalizeUrl(url);
    if (normalized) {
      return handleInsert(normalized, null, 'manual');
    }
    return dispatch({
      invalidUrl: true
    });
  }, [dispatch, handleInsert, isSelectedItem, selectedItem, url, isSubmitting]);
  var handleTabChange = useCallback(function (activeTab) {
    var _plugins$activeTab$ta, _plugins$activeTab;
    dispatch({
      // We don't want any selection to exist after changing tab, as the selection
      // wouldn't mean anything.
      activeIndex: -1,
      selectedIndex: -1,
      // We don't want recents to be hidden, even though we don't have a selection
      preventHidingRecents: true,
      invalidUrl: false,
      activeTab: activeTab
    });
    trackAttribute('tab', (_plugins$activeTab$ta = plugins === null || plugins === void 0 || (_plugins$activeTab = plugins[activeTab]) === null || _plugins$activeTab === void 0 ? void 0 : _plugins$activeTab.tabKey) !== null && _plugins$activeTab$ta !== void 0 ? _plugins$activeTab$ta : null);
  }, [dispatch, plugins, trackAttribute]);
  var handleSearchListOnChange = function handleSearchListOnChange(id) {
    if (isSubmitting) {
      // Prevent changing item while submitting
      return;
    }
    var index = items === null || items === void 0 ? void 0 : items.findIndex(function (item) {
      return item.objectId === id;
    });
    if (typeof index === 'number') {
      var item = items === null || items === void 0 ? void 0 : items[index];
      if (item) {
        /**
         * Manually track that the url has been updated using searchResult method
         */
        trackAttribute('linkFieldContent', getLinkFieldContent(item.url));
        trackAttribute('linkFieldContentInputMethod', 'searchResult');
        trackAttribute('linkFieldContentInputSource', getDataSource(item, activePlugin));
        dispatch({
          activeIndex: index,
          selectedIndex: index,
          url: item.url,
          invalidUrl: false
        });
      }
    }
  };
  var handleKeyDown = useCallback(function (event) {
    if (!(items !== null && items !== void 0 && items.length)) {
      return;
    }
    var updatedIndex = activeIndex;
    if (event.key === 'Enter') {
      event.preventDefault();
      if (selectedItem) {
        handleSelected(selectedItem.objectId);
      } else {
        // triggers validation error message
        handleSubmit();
      }
    } else {
      updatedIndex = handleNavKeyDown(event, items.length, activeIndex);
    }
    var item = items[updatedIndex];
    if (['Enter', 'ArrowDown', 'ArrowUp', 'Home', 'End'].includes(event.key) && item) {
      /**
       * Manually track that the url has been updated using searchResult method
       */
      trackAttribute('linkFieldContent', getLinkFieldContent(item.url));
      trackAttribute('linkFieldContentInputMethod', 'searchResult');
      trackAttribute('linkFieldContentInputSource', getDataSource(item, activePlugin));
      dispatch({
        activeIndex: updatedIndex,
        selectedIndex: updatedIndex,
        url: item.url,
        invalidUrl: false
      });
    }
  }, [items, activeIndex, selectedItem, handleSelected, handleSubmit, trackAttribute, activePlugin]);
  var messages = isActivePlugin ? searchMessages : linkMessages;
  var screenReaderDescriptionId = 'search-recent-links-field-description';
  var linkSearchListId = 'link-picker-search-list';
  var ariaActiveDescendant = selectedIndex > -1 ? "link-search-list-item-".concat(selectedIndex) : '';
  var a11yList = isActivePlugin || isLoadingPlugins ? {
    role: 'combobox',
    // When a combobox popup is not visible, the element with role combobox has aria-expanded set to false
    // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded#combobox
    'aria-expanded': !!(items !== null && items !== void 0 && items.length),
    'aria-autocomplete': 'list',
    'aria-controls': linkSearchListId,
    'aria-activedescendant': ariaActiveDescendant,
    'aria-describedby': screenReaderDescriptionId
  } : undefined;

  // Added workaround with a screen reader Announcer specifically for VoiceOver + Safari
  // as the Aria design pattern for combobox does not work in this case
  // for details: https://a11y-internal.atlassian.net/browse/AK-740
  var screenReaderText = browser().safari && getScreenReaderText(items !== null && items !== void 0 ? items : [], selectedIndex, intl);
  var customSubmitButtonLabel = customMessages !== null && customMessages !== void 0 && customMessages.submitButtonLabel ? customMessages.submitButtonLabel : undefined;
  return /*#__PURE__*/React.createElement("form", {
    "data-testid": testIds.linkPicker,
    // Use onSubmitCapture instead of onSubmit so that any possible parent form isn't submitted
    onSubmitCapture: handleSubmit,
    className: ax(["_19bv164s _u5f31pah _ca0q1k79 _n3td1t3k _vchhusvi _1e0ctcjq", !fg('platform-linking-visual-refresh-v1') && "_vwz44jg8"])
  }, /*#__PURE__*/React.createElement(TrackMount, null), isActivePlugin && /*#__PURE__*/React.createElement(Fragment, null, screenReaderText && /*#__PURE__*/React.createElement(Announcer, {
    ariaLive: "assertive",
    text: screenReaderText,
    ariaRelevant: "additions",
    delay: 250
  }), /*#__PURE__*/React.createElement(VisuallyHidden, {
    id: screenReaderDescriptionId
  }, customMessages !== null && customMessages !== void 0 && customMessages.linkAriaLabel ? /*#__PURE__*/React.createElement(FormattedMessage, customMessages.linkAriaLabel) : /*#__PURE__*/React.createElement(FormattedMessage, messages.linkAriaLabel))), /*#__PURE__*/React.createElement(LinkInputField, _extends({
    name: "url",
    autoComplete: "off",
    testId: testIds.urlInputField,
    label: customMessages !== null && customMessages !== void 0 && customMessages.linkLabel ? intl.formatMessage(customMessages.linkLabel) : intl.formatMessage(messages.linkLabel),
    placeholder: customMessages !== null && customMessages !== void 0 && customMessages.linkPlaceholder ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkPlaceholder) : intl.formatMessage(messages.linkPlaceholder),
    value: url,
    autoFocus: true,
    clearLabel: intl.formatMessage(formMessages.clearLink),
    error: invalidUrl ? intl.formatMessage(formMessages.linkInvalid) : null,
    spotlightTargetName: "link-picker-search-field-spotlight-target",
    "aria-readonly": isSubmitting
  }, a11yList, {
    onClear: handleUrlClear,
    onKeyDown: handleKeyDown,
    onChange: handleChangeUrl,
    inputRef: inputRef
  })), !hideDisplayText && /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(DisplayTextInputField, {
    autoComplete: "off",
    name: "displayText",
    testId: testIds.textInputField,
    value: displayText,
    label: customMessages !== null && customMessages !== void 0 && customMessages.linkTextLabel ? intl.formatMessage(customMessages.linkTextLabel) : intl.formatMessage(linkTextMessages.linkTextLabel),
    placeholder: customMessages !== null && customMessages !== void 0 && customMessages.linkTextPlaceholder ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkTextPlaceholder) : intl.formatMessage(linkTextMessages.linkTextPlaceholder),
    clearLabel: intl.formatMessage(linkTextMessages.clearLinkText),
    readOnly: isSubmitting,
    onClear: handleClear,
    onChange: handleChangeText
  }), fg('platform-linking-visual-refresh-link-picker') && /*#__PURE__*/React.createElement(HelperMessage, {
    testId: testIds.linkHelperText
  }, customMessages !== null && customMessages !== void 0 && customMessages.linkHelperTextLabel ? intl.formatMessage(customMessages === null || customMessages === void 0 ? void 0 : customMessages.linkHelperTextLabel) : intl.formatMessage(linkTextMessages.linkHelperTextLabel))), moveSubmitButton && /*#__PURE__*/React.createElement(Box, {
    xcss: styles.fullWidthSubmitButton
  }, /*#__PURE__*/React.createElement(LinkPickerSubmitButton, {
    isEditing: isEditing,
    isLoading: isLoadingResults || !!isLoadingPlugins,
    isSubmitting: isSubmitting,
    customSubmitButtonLabel: customSubmitButtonLabel,
    error: error,
    items: items,
    queryState: queryState,
    submitMessageId: submitMessageId,
    testId: testIds.insertButton,
    url: url
  })), !!queryState && (isLoadingPlugins || isActivePlugin) && /*#__PURE__*/React.createElement(SearchResults, {
    activeTab: activeTab,
    tabs: tabs,
    activePlugin: activePlugin,
    isLoadingResults: isLoadingResults,
    isLoadingPlugins: isLoadingPlugins,
    isSubmitting: isSubmitting,
    linkSearchListId: linkSearchListId,
    error: error,
    featureFlags: featureFlags,
    activeIndex: activeIndex,
    selectedIndex: selectedIndex,
    items: items,
    queryState: queryState,
    handleKeyDown: handleKeyDown,
    handleSelected: handleSelected,
    handleTabChange: handleTabChange,
    handleSearchListOnChange: handleSearchListOnChange,
    adaptiveHeight: adaptiveHeight,
    retry: retry
  }), /*#__PURE__*/React.createElement(FormFooter, {
    error: error,
    items: items
    /** If the results section appears to be loading, impact whether the submit button is disabled */,
    isLoading: isLoadingResults || !!isLoadingPlugins,
    isSubmitting: isSubmitting,
    queryState: queryState,
    url: url,
    isEditing: isEditing,
    onCancel: onCancel,
    action: pluginAction,
    customSubmitButtonLabel: customSubmitButtonLabel,
    submitMessageId: submitMessageId,
    hideSubmitButton: moveSubmitButton,
    className: ax([(!queryState || !(plugins !== null && plugins !== void 0 && plugins.length)) && "_19pkpxbi"])
  }));
}));