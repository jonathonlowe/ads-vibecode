"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePluginUpdates = exports.cancellable = exports.CancellationError = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var CancellationError = exports.CancellationError = /*#__PURE__*/function (_Error) {
  function CancellationError() {
    (0, _classCallCheck2.default)(this, CancellationError);
    return _callSuper(this, CancellationError, arguments);
  }
  (0, _inherits2.default)(CancellationError, _Error);
  return (0, _createClass2.default)(CancellationError);
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
var cancellable = exports.cancellable = function cancellable(promise) {
  var reject;
  return {
    promise: new Promise(function (resolve, _reject) {
      reject = _reject;
      promise.then(resolve, reject);
    }),
    cancel: function cancel() {
      reject(new CancellationError('Promise cancelled'));
    }
  };
};

/**
 * Wraps the resolve with a cancellation wrapper and makes promise + generator plugin resolves more compatible
 * Calling cancel for generator plugin prevents it from yielding any further updates
 */
var resolvePluginUpdates = exports.resolvePluginUpdates = function resolvePluginUpdates(plugin, state) {
  var updates = plugin.resolve(state);

  // Promise plugin
  if (updates instanceof Promise) {
    var _cancellable = cancellable(updates),
      promise = _cancellable.promise,
      cancel = _cancellable.cancel;
    return {
      cancel: cancel,
      next: function () {
        var _next = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return promise;
              case 2:
                _context.t0 = _context.sent;
                return _context.abrupt("return", {
                  value: _context.t0,
                  done: true
                });
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function next() {
          return _next.apply(this, arguments);
        }
        return next;
      }()
    };
  }

  // Generator plugin
  var cancellationCallbacks = [];
  var cancelled = false;
  return {
    cancel: function cancel() {
      cancelled = true;
      cancellationCallbacks.forEach(function (cb) {
        return cb();
      });
    },
    next: function next() {
      var _cancellable2 = cancellable(updates.next()),
        promise = _cancellable2.promise,
        cancel = _cancellable2.cancel;
      if (cancelled) {
        cancel();
      } else {
        cancellationCallbacks.push(cancel);
      }
      return promise;
    }
  };
};