"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withInputFieldTracking = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _react = _interopRequireWildcard(require("react"));
var _analyticsNext = require("@atlaskit/analytics-next");
var _analytics = _interopRequireDefault(require("../../common/utils/analytics/analytics.codegen"));
var _constants = require("../constants");
var _index = require("./index");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof3(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var isEventWithInputType = function isEventWithInputType(e) {
  return (0, _typeof2.default)(e) === 'object' && e !== null && 'inputType' in e;
};
var getChangeEventInputMethodType = function getChangeEventInputMethodType(event) {
  if (isEventWithInputType(event.nativeEvent) && typeof event.nativeEvent.inputType === 'string' && event.nativeEvent.inputType.includes('insertFromPaste')) {
    return 'paste';
  }
  return 'manual';
};

/**
 * Wraps an input field and connects it to the link picker analytics context to provide a baseline of analytics tracking
 * @param WrappedComponent The input field to be tracked
 * @param field The name of the field (ie matching actionSubjectId)
 * @param filterOnChangeEventAttrs Function to hook into and filter/customise the default attribute tracking logic
 * @returns HOC Input field with tracking
 */
var withInputFieldTracking = exports.withInputFieldTracking = function withInputFieldTracking(WrappedComponent, field) {
  var filterOnChangeEventAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (_, attributes) {
    return attributes;
  };
  return function (props) {
    var onBlur = props.onBlur,
      onChange = props.onChange,
      onClear = props.onClear,
      onFocus = props.onFocus;
    var _useLinkPickerAnalyti = (0, _index.useLinkPickerAnalytics)(),
      trackAttribute = _useLinkPickerAnalyti.trackAttribute,
      trackAttributes = _useLinkPickerAnalyti.trackAttributes;
    var _useAnalyticsEvents = (0, _analyticsNext.useAnalyticsEvents)(),
      createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;

    // Ref to track if the value of the field has changed between focus and blur
    var valueOnFocus = (0, _react.useRef)(null);

    // Track the content and input method on every direct change to the input
    var handleOnChange = (0, _react.useCallback)(function (event) {
      // TODO: See above re template literal, improve typesafety here
      // trackAttribute(`${field}FieldContent`, contentTypeFn(event.currentTarget.value));
      // trackAttribute(`${field}FieldContentInputMethod`, methodTypeFn(event));
      trackAttributes(filterOnChangeEventAttrs(event, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, "".concat(field, "FieldContent"), Boolean(event.currentTarget.value) ? 'text_string' : null), "".concat(field, "FieldContentInputMethod"), getChangeEventInputMethodType(event))));
      onChange === null || onChange === void 0 || onChange(event);
    }, [onChange, trackAttributes]);

    // Store the value of the field at the time the field is focused so we can know if it changes when the user's focus leaves
    var handleOnFocus = (0, _react.useCallback)(function (event) {
      valueOnFocus.current = event.currentTarget.value;
      onFocus === null || onFocus === void 0 || onFocus(event);
    }, [onFocus]);

    // Fire updated events only when the user's focus leaves the field
    var handleOnBlur = (0, _react.useCallback)(function (event) {
      // Only fire if the value has changed since the field was focused (we are only concerned with the net change to the field)
      if (event.currentTarget.value !== valueOnFocus.current) {
        createAnalyticsEvent((0, _analytics.default)("ui.textField.updated.".concat(field, "Field"), {})).fire(_constants.ANALYTICS_CHANNEL);
      }
      onBlur === null || onBlur === void 0 || onBlur(event);
    }, [onBlur, createAnalyticsEvent]);

    // Track the values as null when the text field is cleared
    var handleOnClear = (0, _react.useCallback)(function () {
      trackAttribute("".concat(field, "FieldContent"), null);
      trackAttribute("".concat(field, "FieldContentInputMethod"), null);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      onClear === null || onClear === void 0 || onClear.apply(void 0, args);
    }, [onClear, trackAttribute]);
    return /*#__PURE__*/_react.default.createElement(WrappedComponent, (0, _extends2.default)({}, props, {
      onBlur: handleOnBlur,
      onChange: handleOnChange,
      onClear: handleOnClear,
      onFocus: handleOnFocus
    }));
  };
};