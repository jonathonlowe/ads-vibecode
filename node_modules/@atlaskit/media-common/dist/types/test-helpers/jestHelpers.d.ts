/// <reference types="jest" />
export declare const asMock: (fn: Function) => jest.Mock;
export declare const asMockFunction: <T extends (...args: any[]) => any>(fn: T) => jest.MockedFunction<T>;
export declare const asMockReturnValue: <T extends (...args: any[]) => any>(fn: T, returnValue: ReturnType<T>) => jest.Mock<any, any, any>;
export declare const asMockFunctionReturnValue: <T extends (...args: any[]) => any>(fn: T, returnValue: ReturnType<T>) => jest.MockedFunction<T>;
export declare const asMockFunctionResolvedValue: <T extends (...args: any[]) => any>(fn: T, resolveValue: jest.ResolvedValue<ReturnType<T>>) => jest.MockedFunction<T>;
export declare const expectToEqual: <T>(actual: T, expected: T) => void;
export type ExpectFunctionToHaveBeenCalledWith = <T extends (...args: any[]) => any>(func: T, expectedArgs: Parameters<T>) => void;
export type ExpectConstructorToHaveBeenCalledWith = <T extends new (...args: any[]) => any>(func: T, expectedArgs: ConstructorParameters<T>) => void;
export declare const expectConstructorToHaveBeenCalledWith: ExpectConstructorToHaveBeenCalledWith;
export declare const expectFunctionToHaveBeenCalledWith: ExpectFunctionToHaveBeenCalledWith;
export type JestSpy<T extends (...args: any) => any> = jest.SpyInstance<ReturnType<T>, Parameters<T>>;
export type JestFunction<T extends (...args: any) => any> = jest.Mock<ReturnType<T>, Parameters<T>>;
