"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = void 0;
exports.getRandomHex = getRandomHex;
exports.pick = exports.omitBy = exports.matches = exports.isUndefined = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var isUndefined = exports.isUndefined = function isUndefined(value) {
  return value === undefined;
};
var pick = exports.pick = function pick(obj) {
  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (obj === undefined) {
    return {};
  }
  return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 1),
      k = _ref2[0];
    return keys.includes(k);
  }));
};
var omitBy = exports.omitBy = function omitBy(obj, predicate) {
  return Object.fromEntries(Object.entries(obj).filter(function (_ref3) {
    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
      v = _ref4[1];
    return !predicate(v);
  }));
};
var debounce = exports.debounce = function debounce(func, wait) {
  var timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return func.apply(void 0, args);
    }, wait);
  };
};
var matches = exports.matches = function matches(srcObj) {
  return function (obj) {
    var key;
    for (key in srcObj) {
      if (obj[key] === undefined || obj[key] !== srcObj[key]) {
        return false;
      }
    }
    return true;
  };
};
function getRandomHexValues(byte) {
  return (0, _toConsumableArray2.default)(Array(byte * 2)).map(function () {
    return Math.floor(Math.random() * 16).toString(16);
  }).join('');
}
function getRandomHex(byte) {
  var _window;
  var randomHex;
  if ((_window = window) !== null && _window !== void 0 && _window.crypto) {
    try {
      randomHex = Array.from(window.crypto.getRandomValues(new Uint8Array(byte))).map(function (b) {
        return b.toString(16).padStart(2, '0');
      }).join('');
    } catch (e) {
      randomHex = getRandomHexValues(byte);
    }
  } else {
    randomHex = getRandomHexValues(byte);
  }
  return randomHex;
}