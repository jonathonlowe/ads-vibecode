import { UserType } from '@atlaskit/user-picker';
import { config } from '../config';
import getHydratedUsersFromPrs from './users-client';
import hydrateTeamFromLegion from './teams-client';
import { UNKNOWN } from './constants';
const getHydratedUsersFromProducts = request => {
  const url = `${config.getUsersServiceUrl(request.productKey, request.baseUrl)}`;
  let params = new URLSearchParams();
  request.accountIds.map(id => params.append('accountId', id));
  params.append('maxResults', '2000');
  return fetch(`${url}?${params}`, {
    method: 'GET',
    credentials: 'include',
    headers: {
      'content-type': 'application/json'
    }
  }).then(response => {
    if (response.status === 200) {
      return response.json();
    }
    return Promise.reject({
      message: `error calling users service, statusCode=${response.status}, statusText=${response.statusText}`
    });
  }).then(request.productKey === 'jira' ? transformJiraUsers : transformConfluenceUsers);
};
const transformJiraUsers = userResponse => userResponse.values.map(transformJiraUser).filter(user => !!user).map(user => user);
const transformJiraUser = item => {
  if (!item) {
    return null;
  }
  return {
    id: item.accountId,
    type: UserType,
    avatarUrl: item.avatarUrls ? item.avatarUrls['16x16'] : '',
    name: item.displayName,
    email: item.emailAddress
  };
};
const transformConfluenceUsers = userResponse => userResponse.results.map(transformConfluenceUser).filter(user => !!user).map(user => user);
const transformConfluenceUser = item => {
  if (!item) {
    return null;
  }
  return {
    id: item.accountId,
    type: UserType,
    avatarUrl: item.profilePicture ? item.profilePicture.path : '',
    name: item.publicName,
    email: item.email
  };
};
const sortResults = (options, sortIds) => {
  const resultsMap = new Map(options.map(option => [option && option.id, option]));
  return sortIds.map(option => {
    const user = resultsMap.get(option.id);
    if (user) {
      return user;
    }
    return {
      id: option.id,
      type: option.type,
      name: UNKNOWN
    };
  });
};
const isOptionData = option => {
  return option.name !== undefined;
};
const hydrateTeamIds = async (baseUrl, values, siteId) => {
  if (values.length === 0) {
    return [];
  }
  const legionPromises = values.map(value => hydrateTeamFromLegion({
    baseUrl,
    id: value.id,
    siteId
  }));
  return await Promise.all(legionPromises);
};
const hydrateAccountIds = async (baseUrl, productKey, values) => {
  if (values.length === 0) {
    return [];
  }
  const accountIds = values.map(val => val.id);

  //if we are not jira or confluence then use PRS platform hydration
  return productKey === 'jira' || productKey === 'confluence' ? await getHydratedUsersFromProducts({
    baseUrl,
    productKey,
    accountIds
  }) : await getHydratedUsersFromPrs(baseUrl, accountIds);
};
async function hydrateDefaultValues(baseUrl, value, productKey, siteId) {
  //return if no value
  if (!value || Array.isArray(value) && value.length === 0) {
    return [];
  }
  const values = Array.isArray(value) ? value : [value];

  // return if all hydrated
  if (!values.some(val => !isOptionData(val))) {
    return value;
  }
  const [hydratedUsers, hydratedTeams] = await Promise.all([hydrateAccountIds(baseUrl, productKey, values.filter(val => !isOptionData(val) && val.type === 'user')), hydrateTeamIds(baseUrl, values.filter(val => !isOptionData(val) && val.type === 'team'), siteId)]);
  const hydratedOptions = values.filter(val => isOptionData(val)).map(val => val).concat(hydratedUsers).concat(hydratedTeams);
  return sortResults(hydratedOptions, values);
}
export default hydrateDefaultValues;