import { transformUsers } from './users-transformer';
import { config } from '../config';
const getUserRecommendations = (request, intl) => {
  var _request$context, _request$context$prod;
  const url = config.getRecommendationServiceUrl(request.baseUrl || '');
  return fetch(url, {
    method: 'POST',
    credentials: 'include',
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      context: request.context,
      includeUsers: request.includeUsers,
      includeGroups: request.includeGroups,
      includeTeams: request.includeTeams,
      includeNonLicensedUsers: request.includeNonLicensedUsers,
      maxNumberOfResults: request.maxNumberOfResults,
      performSearchQueryOnly: false,
      searchQuery: {
        cpusQueryHighlights: {
          query: '',
          field: ''
        },
        ...(((_request$context = request.context) === null || _request$context === void 0 ? void 0 : (_request$context$prod = _request$context.productAttributes) === null || _request$context$prod === void 0 ? void 0 : _request$context$prod.isEntitledConfluenceExternalCollaborator) && {
          productAccessPermissionIds: ['write', 'external-collaborator-write']
        }),
        customQuery: '',
        customerDirectoryId: '',
        filter: request.searchQueryFilter || '',
        minimumAccessLevel: 'APPLICATION',
        queryString: request.query,
        restrictTo: {
          userIds: [],
          groupIds: []
        },
        searchUserbase: false
      }
    })
  }).then(response => {
    if (response.status === 200) {
      return response.json();
    }
    return Promise.reject({
      message: `error calling smart service, statusCode=${response.status}, statusText=${response.statusText}`,
      statusCode: response.status
    });
  }).then(response => transformUsers(response, intl));
};
export default getUserRecommendations;