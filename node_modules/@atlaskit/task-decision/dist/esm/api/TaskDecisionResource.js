import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import uuid from 'uuid';
import { utils } from '@atlaskit/util-service-support';
import { convertServiceTaskToTask, convertServiceTaskStateToBaseItem, findIndex } from './TaskDecisionUtils';
import { PubSubSpecialEventType } from '../types';
import { objectKeyToString, toggleTaskState, toObjectKey } from '../type-helpers';
export var ACTION_CREATED_FPS_EVENT = 'avi:task-decision-service:created:action';
export var ACTION_EDITED_FPS_EVENT = 'avi:task-decision-service:edited:action';
export var ACTION_DELETED_FPS_EVENT = 'avi:task-decision-service:deleted:action';
export var ACTION_ARCHIVED_FPS_EVENT = 'avi:task-decision-service:archived:action';
export var ACTION_STATE_CHANGED_FPS_EVENT = 'avi:task-decision-service:stateChanged:action';
export var DECISION_CREATED_FPS_EVENT = 'avi:task-decision-service:created:decision';
export var DECISION_EDITED_FPS_EVENT = 'avi:task-decision-service:edited:decision';
export var DECISION_DELETED_FPS_EVENT = 'avi:task-decision-service:deleted:decision';
export var DECISION_ARCHIVED_FPS_EVENT = 'avi:task-decision-service:archived:decision';
export var DECISION_STATE_CHANGED_FPS_EVENT = 'avi:task-decision-service:stateChanged:decision';
export var ACTION_DECISION_FPS_EVENTS = 'avi:task-decision-service:*:*';
export var RecentUpdates = /*#__PURE__*/function () {
  function RecentUpdates(pubSubClient) {
    var _this = this;
    _classCallCheck(this, RecentUpdates);
    _defineProperty(this, "idsByContainer", new Map());
    _defineProperty(this, "listenersById", new Map());
    _defineProperty(this, "onPubSubEvent", function (_event, payload) {
      var objectAri = payload.objectAri;
      _this.notify({
        objectAri: objectAri
      });
    });
    this.pubSubClient = pubSubClient;
    this.subscribeToPubSubEvents();
  }
  return _createClass(RecentUpdates, [{
    key: "subscribe",
    value: function subscribe(objectAri, recentUpdatesListener) {
      var id = uuid();
      var containerIds = this.idsByContainer.get(objectAri);
      if (!containerIds) {
        containerIds = [];
        this.idsByContainer.set(objectAri, containerIds);
      }
      containerIds.push(id);
      this.listenersById.set(id, {
        listener: recentUpdatesListener,
        objectAri: objectAri
      });
      // Notify of id
      recentUpdatesListener.id(id);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(unsubscribeId) {
      var listenerDetail = this.listenersById.get(unsubscribeId);
      if (listenerDetail) {
        this.listenersById.delete(unsubscribeId);
        var objectAri = listenerDetail.objectAri;
        var idsToFilter = this.idsByContainer.get(objectAri);
        if (idsToFilter) {
          this.idsByContainer.set(objectAri, idsToFilter.filter(function (id) {
            return id !== unsubscribeId;
          }));
        }
      }
    }
  }, {
    key: "notify",
    value: function notify(recentUpdateContext) {
      var _this2 = this;
      var objectAri = recentUpdateContext.objectAri;
      var subscriberIds = this.idsByContainer.get(objectAri);
      if (subscriberIds) {
        subscriberIds.forEach(function (subscriberId) {
          var listenerDetail = _this2.listenersById.get(subscriberId);
          if (listenerDetail) {
            var listener = listenerDetail.listener;
            listener.recentUpdates(recentUpdateContext);
          }
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unsubscribeFromPubSubEvents();
    }
  }, {
    key: "subscribeToPubSubEvents",
    value: function subscribeToPubSubEvents() {
      if (this.pubSubClient) {
        this.pubSubClient.on(ACTION_DECISION_FPS_EVENTS, this.onPubSubEvent);
      }
    }
  }, {
    key: "unsubscribeFromPubSubEvents",
    value: function unsubscribeFromPubSubEvents() {
      if (this.pubSubClient) {
        this.pubSubClient.off(ACTION_DECISION_FPS_EVENTS, this.onPubSubEvent);
      }
    }
  }]);
}();
export var ItemStateManager = /*#__PURE__*/function () {
  function ItemStateManager(serviceConfig) {
    var _this3 = this;
    _classCallCheck(this, ItemStateManager);
    _defineProperty(this, "debouncedTaskStateQuery", null);
    _defineProperty(this, "debouncedTaskToggle", new Map());
    _defineProperty(this, "subscribers", new Map());
    _defineProperty(this, "trackedObjectKeys", new Map());
    _defineProperty(this, "cachedItems", new Map());
    _defineProperty(this, "batchedKeys", new Map());
    _defineProperty(this, "onTaskUpdatedEvent", function (_event, payload) {
      var objectAri = payload.objectAri,
        localId = payload.localId;
      var objectKey = {
        objectAri: objectAri,
        localId: localId
      };
      var cached = _this3.getCached(objectKey);
      if (!cached) {
        // ignore unknown task
        return;
      }
      var lastUpdateDate = new Date(payload.lastUpdateDate);
      if (lastUpdateDate > cached.lastUpdateDate) {
        _this3.updateCache(convertServiceTaskStateToBaseItem(payload));
        _this3.notifyUpdated(objectKey, payload.state);
        return;
      }
    });
    _defineProperty(this, "onReconnect", function () {
      _this3.refreshAllTasks();
    });
    this.serviceConfig = serviceConfig;
    this.subscribeToPubSubEvents();
  }
  return _createClass(ItemStateManager, [{
    key: "destroy",
    value: function destroy() {
      if (this.debouncedTaskStateQuery) {
        clearTimeout(this.debouncedTaskStateQuery);
      }
      this.debouncedTaskToggle.forEach(function (timeout) {
        clearTimeout(timeout);
      });
      this.unsubscribeFromPubSubEvents();
    }
  }, {
    key: "toggleTask",
    value: function toggleTask(objectKey, state) {
      var _this4 = this;
      var stringKey = objectKeyToString(objectKey);
      var timeout = this.debouncedTaskToggle.get(stringKey);
      if (timeout) {
        clearTimeout(timeout);
        this.debouncedTaskToggle.delete(stringKey);
      }

      // Update cache optimistically
      this.updateCache(_objectSpread(_objectSpread({}, objectKey), {}, {
        lastUpdateDate: new Date(),
        type: 'TASK',
        state: state
      }));

      // Optimistically notify subscribers that the task have been updated so that they can re-render accordingly
      this.notifyUpdated(objectKey, state);
      return new Promise(function (resolve, reject) {
        _this4.debouncedTaskToggle.set(stringKey, window.setTimeout(function () {
          var options = {
            path: 'tasks/state',
            requestInit: {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json; charset=UTF-8'
              },
              body: JSON.stringify(_objectSpread(_objectSpread({}, objectKey), {}, {
                state: state
              }))
            }
          };
          utils.requestService(_this4.serviceConfig, options).then(convertServiceTaskToTask).then(function (task) {
            _this4.updateCache(task);
            resolve(state);
            // Notify subscribers that the task have been updated so that they can re-render accordingly
            _this4.notifyUpdated(objectKey, state);
          }).catch(function () {
            // Undo optimistic change
            var previousState = toggleTaskState(state);
            _this4.updateCache(_objectSpread(_objectSpread({}, objectKey), {}, {
              lastUpdateDate: new Date(),
              type: 'TASK',
              state: previousState
            }));
            _this4.notifyUpdated(objectKey, previousState);
            reject();
          });
        }, 500));
      });
    }
  }, {
    key: "refreshAllTasks",
    value: function refreshAllTasks() {
      this.queueAllItems();
      this.scheduleGetTaskState();
    }
  }, {
    key: "subscribe",
    value: function subscribe(objectKey, handler, item) {
      var key = objectKeyToString(objectKey);
      var handlers = this.subscribers.get(key) || [];
      handlers.push(handler);
      this.subscribers.set(key, handlers);
      this.trackedObjectKeys.set(key, objectKey);
      var cached = this.getCached(objectKey);
      if (cached) {
        this.notifyUpdated(objectKey, cached.state);
        return;
      }
      if (this.serviceConfig.disableServiceHydration && item) {
        this.updateCache(item);
        return;
      }
      this.queueItem(objectKey);
      this.scheduleGetTaskState();
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(objectKey, handler) {
      var key = objectKeyToString(objectKey);
      var handlers = this.subscribers.get(key);
      if (!handlers) {
        return;
      }
      var index = findIndex(handlers, function (h) {
        return h === handler;
      });
      if (index !== -1) {
        handlers.splice(index, 1);
      }
      if (handlers.length === 0) {
        this.subscribers.delete(key);
        this.trackedObjectKeys.delete(key);
      } else {
        this.subscribers.set(key, handlers);
      }
    }
  }, {
    key: "getTaskState",
    value: function getTaskState(keys) {
      var options = {
        path: 'tasks/state',
        requestInit: {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json; charset=UTF-8'
          },
          body: JSON.stringify({
            taskKeys: keys
          })
        }
      };
      return utils.requestService(this.serviceConfig, options);
    }
  }, {
    key: "notifyUpdated",
    value: function notifyUpdated(objectKey, state) {
      var key = objectKeyToString(objectKey);
      var handlers = this.subscribers.get(key);
      if (!handlers) {
        return;
      }
      handlers.forEach(function (handler) {
        handler(state);
      });
    }
  }, {
    key: "updateCache",
    value: function updateCache(item) {
      var stringKey = objectKeyToString(toObjectKey(item));
      this.cachedItems.set(stringKey, item);
    }
  }, {
    key: "getCached",
    value: function getCached(objectKey) {
      return this.cachedItems.get(objectKeyToString(objectKey));
    }
  }, {
    key: "subscribeToPubSubEvents",
    value: function subscribeToPubSubEvents() {
      if (this.serviceConfig.pubSubClient) {
        this.serviceConfig.pubSubClient.on(ACTION_STATE_CHANGED_FPS_EVENT, this.onTaskUpdatedEvent);
        this.serviceConfig.pubSubClient.on(PubSubSpecialEventType.RECONNECT, this.onReconnect);
      }
    }
  }, {
    key: "unsubscribeFromPubSubEvents",
    value: function unsubscribeFromPubSubEvents() {
      if (this.serviceConfig.pubSubClient) {
        this.serviceConfig.pubSubClient.off(ACTION_STATE_CHANGED_FPS_EVENT, this.onTaskUpdatedEvent);
        this.serviceConfig.pubSubClient.off(PubSubSpecialEventType.RECONNECT, this.onReconnect);
      }
    }
  }, {
    key: "queueAllItems",
    value: function queueAllItems() {
      this.batchedKeys = new Map(this.trackedObjectKeys);
    }
  }, {
    key: "queueItem",
    value: function queueItem(objectKey) {
      var key = objectKeyToString(objectKey);
      if (this.batchedKeys.get(key)) {
        return;
      }
      this.batchedKeys.set(key, objectKey);
    }
  }, {
    key: "dequeueItem",
    value: function dequeueItem(objectKey) {
      var key = objectKeyToString(objectKey);
      this.batchedKeys.delete(key);
    }
  }, {
    key: "scheduleGetTaskState",
    value: function scheduleGetTaskState() {
      var _this5 = this;
      if (this.debouncedTaskStateQuery) {
        clearTimeout(this.debouncedTaskStateQuery);
      }
      this.debouncedTaskStateQuery = window.setTimeout(function () {
        _this5.getTaskState(Array.from(_this5.batchedKeys.values())).then(function (tasks) {
          tasks.forEach(function (task) {
            var objectAri = task.objectAri,
              localId = task.localId;
            var objectKey = {
              objectAri: objectAri,
              localId: localId
            };
            _this5.updateCache(convertServiceTaskStateToBaseItem(task));
            _this5.dequeueItem(objectKey);
            _this5.notifyUpdated(objectKey, task.state);
          });
        });
      }, 1);
    }
  }]);
}();
var TaskDecisionResource = /*#__PURE__*/function () {
  function TaskDecisionResource(serviceConfig) {
    _classCallCheck(this, TaskDecisionResource);
    this.recentUpdates = new RecentUpdates(serviceConfig.pubSubClient);
    this.itemStateManager = new ItemStateManager(serviceConfig);
  }
  return _createClass(TaskDecisionResource, [{
    key: "unsubscribeRecentUpdates",
    value: function unsubscribeRecentUpdates(id) {
      this.recentUpdates.unsubscribe(id);
    }
  }, {
    key: "notifyRecentUpdates",
    value: function notifyRecentUpdates(recentUpdateContext) {
      this.recentUpdates.notify(recentUpdateContext);
      this.itemStateManager.refreshAllTasks();
    }
  }, {
    key: "toggleTask",
    value: function toggleTask(objectKey, state) {
      return this.itemStateManager.toggleTask(objectKey, state);
    }
  }, {
    key: "subscribe",
    value: function subscribe(objectKey, handler, item) {
      this.itemStateManager.subscribe(objectKey, handler, item);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(objectKey, handler) {
      this.itemStateManager.unsubscribe(objectKey, handler);
    }

    /**
     * Usually only needed for testing to ensure no outstanding requests
     * are sent to a server (typically mocked).
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.recentUpdates.destroy();
      this.itemStateManager.destroy();
    }
  }]);
}();
export { TaskDecisionResource as default };