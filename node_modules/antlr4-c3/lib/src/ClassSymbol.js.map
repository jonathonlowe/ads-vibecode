{"version":3,"file":"ClassSymbol.js","sourceRoot":"","sources":["../../src/ClassSymbol.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAEH,mCAAwD;AAExD,+CAA4C;AAE5C,iDAA8C;AAC9C,iDAA8C;AAE9C,2BAA2B;AAC3B,MAAa,WAAY,SAAQ,2BAAY;IAYzC,YAAmB,IAAY,EAAE,GAAkB,EAAE,IAA0C;QAC3F,KAAK,CAAC,IAAI,CAAC,CAAC;QAZT,aAAQ,GAAG,KAAK,CAAC;QACjB,cAAS,GAAG,qBAAa,CAAC,UAAU,CAAC;QAYxC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IAC3B,CAAC;IAED,IAAW,SAAS,KAAa,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IACvD,IAAW,IAAI,KAAe,OAAO,gBAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;IAEtD;;;;OAIG;IACI,UAAU,CAAC,gBAAgB,GAAG,KAAK;QACtC,OAAO,IAAI,CAAC,gBAAgB,CAAC,2BAAY,CAAC,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACI,SAAS,CAAC,gBAAgB,GAAG,KAAK;QACrC,OAAO,IAAI,CAAC,gBAAgB,CAAC,yBAAW,CAAC,CAAC;IAC9C,CAAC;CACJ;AAtCD,kCAsCC","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2023, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\nimport { Type, ReferenceKind, TypeKind } from \"./types\";\n\nimport { FieldSymbol } from \"./FieldSymbol\";\nimport { InterfaceSymbol } from \"./InterfaceSymbol\";\nimport { MethodSymbol } from \"./MethodSymbol\";\nimport { ScopedSymbol } from \"./ScopedSymbol\";\n\n/** Classes and structs. */\nexport class ClassSymbol extends ScopedSymbol implements Type {\n    public isStruct = false;\n    public reference = ReferenceKind.Irrelevant;\n\n    /** Usually only one member, unless the language supports multiple inheritance (like C++). */\n    // eslint-disable-next-line no-use-before-define\n    public readonly extends: ClassSymbol[];\n\n    /** Typescript allows a class to implement a class, not only interfaces. */\n    // eslint-disable-next-line no-use-before-define\n    public readonly implements: Array<ClassSymbol | InterfaceSymbol>;\n\n    public constructor(name: string, ext: ClassSymbol[], impl: Array<ClassSymbol | InterfaceSymbol>) {\n        super(name);\n        this.extends = ext;\n        this.implements = impl;\n    }\n\n    public get baseTypes(): Type[] { return this.extends; }\n    public get kind(): TypeKind { return TypeKind.Class; }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): Promise<MethodSymbol[]> {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns all fields.\n     */\n    public getFields(includeInherited = false): Promise<FieldSymbol[]> {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n}\n"]}