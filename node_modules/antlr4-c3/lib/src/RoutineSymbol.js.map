{"version":3,"file":"RoutineSymbol.js","sourceRoot":"","sources":["../../src/RoutineSymbol.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAEH,uDAAoD;AACpD,iDAA8C;AAC9C,qDAAkD;AAGlD,4CAA4C;AAC5C,MAAa,aAAc,SAAQ,2BAAY;IAG3C,YAAmB,IAAY,EAAE,UAAiB;QAC9C,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IACjC,CAAC;IAEM,YAAY,CAAC,SAAS,GAAG,IAAI;QAChC,OAAO,IAAI,CAAC,gBAAgB,CAAC,+BAAc,CAAC,CAAC;IACjD,CAAC;IAEM,aAAa,CAAC,SAAS,GAAG,IAAI;QACjC,OAAO,IAAI,CAAC,gBAAgB,CAAC,iCAAe,CAAC,CAAC;IAClD,CAAC;CACJ;AAfD,sCAeC","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2023, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\nimport { ParameterSymbol } from \"./ParameterSymbol\";\nimport { ScopedSymbol } from \"./ScopedSymbol\";\nimport { VariableSymbol } from \"./VariableSymbol\";\nimport { Type } from \"./types\";\n\n/** A standalone function/procedure/rule. */\nexport class RoutineSymbol extends ScopedSymbol {\n    public returnType?: Type; // Can be null if result is void.\n\n    public constructor(name: string, returnType?: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    public getVariables(localOnly = true): Promise<VariableSymbol[]> {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    public getParameters(localOnly = true): Promise<ParameterSymbol[]> {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n}\n"]}