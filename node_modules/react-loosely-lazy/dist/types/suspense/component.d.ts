import React, { Component } from 'react';
import { Fallback, LazySuspenseContextType, LazySuspenseProps } from './types';
type LazySuspenseState = LazySuspenseContextType;
/**
 * This component implements a multi step system in order to be consumed on SSR
 * and still allow hydration and render a suspense boundary without having React
 * throw away the SSR content or complaining that the html code does not match.
 *
 * Most of the behaciour is implemented by communicating via context with the
 * lazy child. The lazy component is indeed responsible of collecting its own
 * SSR output and let this suspense alternative render it as fallback.
 *
 * To be clear, it does not render Suspense on the server: it only renders
 * a context provider in order to pass the fallback down to the child being
 * rendered if the lazy component is not there.
 *
 * Then on the client, during hydration, it renders the same provider with
 * two children: the first is the real Suspense component, that renders
 * the lazy child, catching any promise being thrown and wait; the second
 * is the hydration compliant component: it maintains SSR content until
 * the suspended promise is resolved.
 *
 * So during this step, if there is SSR content Suspense renders null and
 * the hydration fallback is rendered as sibling. If not, the lazy child
 * will signal to render the fallback prop, removing the hydration fallback.
 *
 * Once the suspended promise is resolved, Suspense will remove its own
 * fallback but will also tell LazySuspense to get rid of the hydration one.
 *
 */
export declare class LazySuspense extends Component<LazySuspenseProps, LazySuspenseState> {
    state: {
        fallback: NonNullable<React.ReactNode> | null;
        setFallback: (fallback: Fallback) => void;
    };
    private hydrationFallback;
    private mounted;
    constructor(props: LazySuspenseProps);
    componentDidMount(): void;
    private DynamicFallback;
    private renderFallback;
    private renderServer;
    private renderClient;
    render(): React.JSX.Element;
}
export {};
//# sourceMappingURL=component.d.ts.map