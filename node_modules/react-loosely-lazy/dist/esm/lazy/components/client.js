import React, { lazy, useContext, useMemo, useState } from 'react';
import { getConfig, MODE } from '../../config';
import { COLLECTED, PHASE } from '../../constants';
import { WaitContext } from '../../lazy-wait';
import { LazyPhaseContext } from '../../phase';
import { LazySuspenseContext } from '../../suspense';
import { PRIORITY } from '../constants';
import { createLoaderError } from '../errors';
import { PlaceholderFallbackRender } from '../placeholders/render';
import { PlaceholderFallbackHydrate } from '../placeholders/hydrate';
import { preloadAsset } from '../preload';
import { ProfilerContext } from '../../profiler';
import { useSubscription } from './utils';
export function createComponentClient({
  defer,
  deferred,
  dataLazyId,
  moduleId
}) {
  const {
    requestIdleCallback = setTimeout
  } = window;
  const ResolvedLazy = /*#__PURE__*/lazy(() => deferred.promise);
  return props => {
    // use a single piece of state to hold info about progress or eventually
    // throw an error. We do change it via direct mutation as re-renders
    // break Suspense in React 18, making it lose hydration state
    const [status, bubbleError] = useState(() => ({
      noWait: undefined,
      phase: defer === PHASE.AFTER_PAINT ? false : true,
      preloaded: defer === PHASE.AFTER_PAINT ? false : true,
      started: false
    }));
    const profiler = useContext(ProfilerContext).current;
    const load = () => {
      if (status.started || !status.phase || !status.noWait) {
        return;
      }
      status.started = true;
      let onResolve;
      if (profiler) {
        const eventInfo = {
          identifier: moduleId
        };
        onResolve = () => {
          profiler.onLoadComplete(eventInfo);
        };
        profiler.onLoadStart(eventInfo);
      }
      const result = deferred.start().catch(err => {
        // Throw the error within the component lifecycle
        // refer to https://github.com/facebook/react/issues/11409
        bubbleError(() => {
          throw createLoaderError(err);
        });
      });
      if (onResolve) {
        result.then(onResolve);
      }
    };

    // Subscribe to LazyWait context, triggering load when until is true
    useSubscription({
      context: WaitContext,
      load,
      onValue: v => status.noWait = v === 1
    });
    if (defer === PHASE.AFTER_PAINT) {
      // Subscribe to LazyPhase context, triggering load when own phase starts
      useSubscription({
        context: LazyPhaseContext,
        load,
        onValue: v => status.phase = v >= defer
      });

      // Schedule preloading as will be needed soon
      useMemo(() => {
        if (!status.preloaded) {
          status.preloaded = true;
          requestIdleCallback(() => {
            if (status.started) return;
            preloadAsset({
              loader: deferred.preload,
              moduleId,
              priority: PRIORITY.LOW
            });
          });
        }
      }, [status]);
    }
    const {
      setFallback
    } = useContext(LazySuspenseContext);
    useMemo(() => {
      // find SSR content (or fallbacks) wrapped in inputs based on lazyId
      const content = (COLLECTED.get(dataLazyId) || []).shift();
      if (!content) return;

      // override Suspense fallback with magic input wrappers
      const component = getConfig().mode === MODE.RENDER ? /*#__PURE__*/React.createElement(PlaceholderFallbackRender, {
        id: dataLazyId,
        content: content
      }) : /*#__PURE__*/React.createElement(PlaceholderFallbackHydrate, {
        id: dataLazyId,
        content: content
      });
      setFallback(component);
    }, [setFallback]);
    return /*#__PURE__*/React.createElement(ResolvedLazy, props);
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSZWFjdCIsImxhenkiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwiZ2V0Q29uZmlnIiwiTU9ERSIsIkNPTExFQ1RFRCIsIlBIQVNFIiwiV2FpdENvbnRleHQiLCJMYXp5UGhhc2VDb250ZXh0IiwiTGF6eVN1c3BlbnNlQ29udGV4dCIsIlBSSU9SSVRZIiwiY3JlYXRlTG9hZGVyRXJyb3IiLCJQbGFjZWhvbGRlckZhbGxiYWNrUmVuZGVyIiwiUGxhY2Vob2xkZXJGYWxsYmFja0h5ZHJhdGUiLCJwcmVsb2FkQXNzZXQiLCJQcm9maWxlckNvbnRleHQiLCJ1c2VTdWJzY3JpcHRpb24iLCJjcmVhdGVDb21wb25lbnRDbGllbnQiLCJkZWZlciIsImRlZmVycmVkIiwiZGF0YUxhenlJZCIsIm1vZHVsZUlkIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNldFRpbWVvdXQiLCJ3aW5kb3ciLCJSZXNvbHZlZExhenkiLCJwcm9taXNlIiwicHJvcHMiLCJzdGF0dXMiLCJidWJibGVFcnJvciIsIm5vV2FpdCIsInVuZGVmaW5lZCIsInBoYXNlIiwiQUZURVJfUEFJTlQiLCJwcmVsb2FkZWQiLCJzdGFydGVkIiwicHJvZmlsZXIiLCJjdXJyZW50IiwibG9hZCIsIm9uUmVzb2x2ZSIsImV2ZW50SW5mbyIsImlkZW50aWZpZXIiLCJvbkxvYWRDb21wbGV0ZSIsIm9uTG9hZFN0YXJ0IiwicmVzdWx0Iiwic3RhcnQiLCJjYXRjaCIsImVyciIsInRoZW4iLCJjb250ZXh0Iiwib25WYWx1ZSIsInYiLCJsb2FkZXIiLCJwcmVsb2FkIiwicHJpb3JpdHkiLCJMT1ciLCJzZXRGYWxsYmFjayIsImNvbnRlbnQiLCJnZXQiLCJzaGlmdCIsImNvbXBvbmVudCIsIm1vZGUiLCJSRU5ERVIiLCJjcmVhdGVFbGVtZW50IiwiaWQiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGF6eS9jb21wb25lbnRzL2NsaWVudC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGxhenksIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRQcm9wcywgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgZ2V0Q29uZmlnLCBNT0RFIH0gZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IENPTExFQ1RFRCwgUEhBU0UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgV2FpdENvbnRleHQgfSBmcm9tICcuLi8uLi9sYXp5LXdhaXQnO1xuaW1wb3J0IHsgTGF6eVBoYXNlQ29udGV4dCB9IGZyb20gJy4uLy4uL3BoYXNlJztcbmltcG9ydCB7IExhenlTdXNwZW5zZUNvbnRleHQgfSBmcm9tICcuLi8uLi9zdXNwZW5zZSc7XG5cbmltcG9ydCB7IFBSSU9SSVRZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnLi4vZGVmZXJyZWQnO1xuaW1wb3J0IHsgY3JlYXRlTG9hZGVyRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGxhY2Vob2xkZXJGYWxsYmFja1JlbmRlciB9IGZyb20gJy4uL3BsYWNlaG9sZGVycy9yZW5kZXInO1xuaW1wb3J0IHsgUGxhY2Vob2xkZXJGYWxsYmFja0h5ZHJhdGUgfSBmcm9tICcuLi9wbGFjZWhvbGRlcnMvaHlkcmF0ZSc7XG5pbXBvcnQgeyBwcmVsb2FkQXNzZXQgfSBmcm9tICcuLi9wcmVsb2FkJztcbmltcG9ydCB7IFByb2ZpbGVyQ29udGV4dCB9IGZyb20gJy4uLy4uL3Byb2ZpbGVyJztcblxuaW1wb3J0IHR5cGUgeyBTdGF0dXMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50Q2xpZW50PEMgZXh0ZW5kcyBDb21wb25lbnRUeXBlPGFueT4+KHtcbiAgZGVmZXIsXG4gIGRlZmVycmVkLFxuICBkYXRhTGF6eUlkLFxuICBtb2R1bGVJZCxcbn06IHtcbiAgZGVmZXI6IG51bWJlcjtcbiAgZGVmZXJyZWQ6IERlZmVycmVkPEM+O1xuICBkYXRhTGF6eUlkOiBzdHJpbmc7XG4gIG1vZHVsZUlkOiBzdHJpbmc7XG59KSB7XG4gIGNvbnN0IHsgcmVxdWVzdElkbGVDYWxsYmFjayA9IHNldFRpbWVvdXQgfSA9IHdpbmRvdztcbiAgY29uc3QgUmVzb2x2ZWRMYXp5ID0gbGF6eSgoKSA9PiBkZWZlcnJlZC5wcm9taXNlKTtcblxuICByZXR1cm4gKHByb3BzOiBDb21wb25lbnRQcm9wczxDPikgPT4ge1xuICAgIC8vIHVzZSBhIHNpbmdsZSBwaWVjZSBvZiBzdGF0ZSB0byBob2xkIGluZm8gYWJvdXQgcHJvZ3Jlc3Mgb3IgZXZlbnR1YWxseVxuICAgIC8vIHRocm93IGFuIGVycm9yLiBXZSBkbyBjaGFuZ2UgaXQgdmlhIGRpcmVjdCBtdXRhdGlvbiBhcyByZS1yZW5kZXJzXG4gICAgLy8gYnJlYWsgU3VzcGVuc2UgaW4gUmVhY3QgMTgsIG1ha2luZyBpdCBsb3NlIGh5ZHJhdGlvbiBzdGF0ZVxuICAgIGNvbnN0IFtzdGF0dXMsIGJ1YmJsZUVycm9yXSA9IHVzZVN0YXRlPFN0YXR1cz4oKCkgPT4gKHtcbiAgICAgIG5vV2FpdDogdW5kZWZpbmVkLFxuICAgICAgcGhhc2U6IGRlZmVyID09PSBQSEFTRS5BRlRFUl9QQUlOVCA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgIHByZWxvYWRlZDogZGVmZXIgPT09IFBIQVNFLkFGVEVSX1BBSU5UID8gZmFsc2UgOiB0cnVlLFxuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgfSkpO1xuXG4gICAgY29uc3QgcHJvZmlsZXIgPSB1c2VDb250ZXh0KFByb2ZpbGVyQ29udGV4dCkuY3VycmVudDtcblxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RhdHVzLnN0YXJ0ZWQgfHwgIXN0YXR1cy5waGFzZSB8fCAhc3RhdHVzLm5vV2FpdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIGxldCBvblJlc29sdmU7XG4gICAgICBpZiAocHJvZmlsZXIpIHtcbiAgICAgICAgY29uc3QgZXZlbnRJbmZvID0geyBpZGVudGlmaWVyOiBtb2R1bGVJZCB9O1xuICAgICAgICBvblJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgICAgcHJvZmlsZXIub25Mb2FkQ29tcGxldGUoZXZlbnRJbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvZmlsZXIub25Mb2FkU3RhcnQoZXZlbnRJbmZvKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gZGVmZXJyZWQuc3RhcnQoKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAvLyBUaHJvdyB0aGUgZXJyb3Igd2l0aGluIHRoZSBjb21wb25lbnQgbGlmZWN5Y2xlXG4gICAgICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE0MDlcbiAgICAgICAgYnViYmxlRXJyb3IoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUxvYWRlckVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChvblJlc29sdmUpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4ob25SZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIExhenlXYWl0IGNvbnRleHQsIHRyaWdnZXJpbmcgbG9hZCB3aGVuIHVudGlsIGlzIHRydWVcbiAgICB1c2VTdWJzY3JpcHRpb24oe1xuICAgICAgY29udGV4dDogV2FpdENvbnRleHQsXG4gICAgICBsb2FkLFxuICAgICAgb25WYWx1ZTogdiA9PiAoc3RhdHVzLm5vV2FpdCA9IHYgPT09IDEpLFxuICAgIH0pO1xuXG4gICAgaWYgKGRlZmVyID09PSBQSEFTRS5BRlRFUl9QQUlOVCkge1xuICAgICAgLy8gU3Vic2NyaWJlIHRvIExhenlQaGFzZSBjb250ZXh0LCB0cmlnZ2VyaW5nIGxvYWQgd2hlbiBvd24gcGhhc2Ugc3RhcnRzXG4gICAgICB1c2VTdWJzY3JpcHRpb24oe1xuICAgICAgICBjb250ZXh0OiBMYXp5UGhhc2VDb250ZXh0LFxuICAgICAgICBsb2FkLFxuICAgICAgICBvblZhbHVlOiB2ID0+IChzdGF0dXMucGhhc2UgPSB2ID49IGRlZmVyKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTY2hlZHVsZSBwcmVsb2FkaW5nIGFzIHdpbGwgYmUgbmVlZGVkIHNvb25cbiAgICAgIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXN0YXR1cy5wcmVsb2FkZWQpIHtcbiAgICAgICAgICBzdGF0dXMucHJlbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMuc3RhcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcHJlbG9hZEFzc2V0KHtcbiAgICAgICAgICAgICAgbG9hZGVyOiBkZWZlcnJlZC5wcmVsb2FkLFxuICAgICAgICAgICAgICBtb2R1bGVJZCxcbiAgICAgICAgICAgICAgcHJpb3JpdHk6IFBSSU9SSVRZLkxPVyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBzZXRGYWxsYmFjayB9ID0gdXNlQ29udGV4dChMYXp5U3VzcGVuc2VDb250ZXh0KTtcblxuICAgIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgLy8gZmluZCBTU1IgY29udGVudCAob3IgZmFsbGJhY2tzKSB3cmFwcGVkIGluIGlucHV0cyBiYXNlZCBvbiBsYXp5SWRcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAoQ09MTEVDVEVELmdldChkYXRhTGF6eUlkKSB8fCBbXSkuc2hpZnQoKTtcbiAgICAgIGlmICghY29udGVudCkgcmV0dXJuO1xuXG4gICAgICAvLyBvdmVycmlkZSBTdXNwZW5zZSBmYWxsYmFjayB3aXRoIG1hZ2ljIGlucHV0IHdyYXBwZXJzXG4gICAgICBjb25zdCBjb21wb25lbnQgPVxuICAgICAgICBnZXRDb25maWcoKS5tb2RlID09PSBNT0RFLlJFTkRFUiA/IChcbiAgICAgICAgICA8UGxhY2Vob2xkZXJGYWxsYmFja1JlbmRlciBpZD17ZGF0YUxhenlJZH0gY29udGVudD17Y29udGVudH0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8UGxhY2Vob2xkZXJGYWxsYmFja0h5ZHJhdGUgaWQ9e2RhdGFMYXp5SWR9IGNvbnRlbnQ9e2NvbnRlbnR9IC8+XG4gICAgICAgICk7XG4gICAgICBzZXRGYWxsYmFjayhjb21wb25lbnQpO1xuICAgIH0sIFtzZXRGYWxsYmFja10pO1xuXG4gICAgcmV0dXJuIDxSZXNvbHZlZExhenkgey4uLnByb3BzfSAvPjtcbiAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBT0EsS0FBSyxJQUFJQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLFFBQVEsT0FBTztBQUdsRSxTQUFTQyxTQUFTLEVBQUVDLElBQUksUUFBUSxjQUFjO0FBQzlDLFNBQVNDLFNBQVMsRUFBRUMsS0FBSyxRQUFRLGlCQUFpQjtBQUNsRCxTQUFTQyxXQUFXLFFBQVEsaUJBQWlCO0FBQzdDLFNBQVNDLGdCQUFnQixRQUFRLGFBQWE7QUFDOUMsU0FBU0MsbUJBQW1CLFFBQVEsZ0JBQWdCO0FBRXBELFNBQVNDLFFBQVEsUUFBUSxjQUFjO0FBRXZDLFNBQVNDLGlCQUFpQixRQUFRLFdBQVc7QUFDN0MsU0FBU0MseUJBQXlCLFFBQVEsd0JBQXdCO0FBQ2xFLFNBQVNDLDBCQUEwQixRQUFRLHlCQUF5QjtBQUNwRSxTQUFTQyxZQUFZLFFBQVEsWUFBWTtBQUN6QyxTQUFTQyxlQUFlLFFBQVEsZ0JBQWdCO0FBR2hELFNBQVNDLGVBQWUsUUFBUSxT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