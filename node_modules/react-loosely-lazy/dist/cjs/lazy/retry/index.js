"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retry = retry;
const calculateDelay = (context, policy) => {
  const {
    attempt
  } = context;
  const {
    delay,
    factor
  } = policy;
  const retryAttempt = attempt - 1;
  // Do not use a delay on the first retry, or when the configured delay is 0
  if (retryAttempt === 1 || delay === 0) {
    return 0;
  }

  // Linear factor, like: https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry#wait-and-retry-with-linear-back-off
  const add = factor * delay;
  return delay + add * (retryAttempt - 2);
};
const sleep = delay => new Promise(resolve => setTimeout(resolve, delay));
const getPolicy = configuration => {
  var _configuration$delay, _configuration$factor, _configuration$maxAtt;
  return {
    delay: Math.max(0, (_configuration$delay = configuration.delay) !== null && _configuration$delay !== void 0 ? _configuration$delay : 0),
    factor: Math.max(0, (_configuration$factor = configuration.factor) !== null && _configuration$factor !== void 0 ? _configuration$factor : 0),
    maxAttempts: Math.max(0, (_configuration$maxAtt = configuration.maxAttempts) !== null && _configuration$maxAtt !== void 0 ? _configuration$maxAtt : 0)
  };
};
function retry(retryable, policyConfiguration = {}) {
  const policy = getPolicy(policyConfiguration);
  const {
    maxAttempts
  } = policy;
  const context = {
    attempt: 1,
    attemptsRemaining: maxAttempts
  };
  const onError = async err => {
    if (context.attemptsRemaining === 0) {
      throw err;
    }
    context.attempt += 1;
    context.attemptsRemaining -= 1;
    const delay = calculateDelay(context, policy);
    if (delay) {
      await sleep(delay);
    }
    return retryable().catch(onError);
  };
  return retryable().catch(onError);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjYWxjdWxhdGVEZWxheSIsImNvbnRleHQiLCJwb2xpY3kiLCJhdHRlbXB0IiwiZGVsYXkiLCJmYWN0b3IiLCJyZXRyeUF0dGVtcHQiLCJhZGQiLCJzbGVlcCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldFBvbGljeSIsImNvbmZpZ3VyYXRpb24iLCJfY29uZmlndXJhdGlvbiRkZWxheSIsIl9jb25maWd1cmF0aW9uJGZhY3RvciIsIl9jb25maWd1cmF0aW9uJG1heEF0dCIsIk1hdGgiLCJtYXgiLCJtYXhBdHRlbXB0cyIsInJldHJ5IiwicmV0cnlhYmxlIiwicG9saWN5Q29uZmlndXJhdGlvbiIsImF0dGVtcHRzUmVtYWluaW5nIiwib25FcnJvciIsImVyciIsImNhdGNoIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xhenkvcmV0cnkvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIFJldHJ5UG9saWN5ID0ge1xuICBkZWxheTogbnVtYmVyO1xuICBmYWN0b3I6IG51bWJlcjtcbiAgbWF4QXR0ZW1wdHM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFJldHJ5UG9saWN5Q29uZmlndXJhdGlvbiA9IFBhcnRpYWw8UmV0cnlQb2xpY3k+O1xuXG50eXBlIEF0dGVtcHRDb250ZXh0ID0ge1xuICBhdHRlbXB0OiBudW1iZXI7XG4gIGF0dGVtcHRzUmVtYWluaW5nOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBSZXRyeWFibGU8VD4gPSAoKSA9PiBQcm9taXNlPFQ+O1xuXG5jb25zdCBjYWxjdWxhdGVEZWxheSA9IChjb250ZXh0OiBBdHRlbXB0Q29udGV4dCwgcG9saWN5OiBSZXRyeVBvbGljeSkgPT4ge1xuICBjb25zdCB7IGF0dGVtcHQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHsgZGVsYXksIGZhY3RvciB9ID0gcG9saWN5O1xuXG4gIGNvbnN0IHJldHJ5QXR0ZW1wdCA9IGF0dGVtcHQgLSAxO1xuICAvLyBEbyBub3QgdXNlIGEgZGVsYXkgb24gdGhlIGZpcnN0IHJldHJ5LCBvciB3aGVuIHRoZSBjb25maWd1cmVkIGRlbGF5IGlzIDBcbiAgaWYgKHJldHJ5QXR0ZW1wdCA9PT0gMSB8fCBkZWxheSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gTGluZWFyIGZhY3RvciwgbGlrZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbGx5LUNvbnRyaWIvUG9sbHkuQ29udHJpYi5XYWl0QW5kUmV0cnkjd2FpdC1hbmQtcmV0cnktd2l0aC1saW5lYXItYmFjay1vZmZcbiAgY29uc3QgYWRkID0gZmFjdG9yICogZGVsYXk7XG5cbiAgcmV0dXJuIGRlbGF5ICsgYWRkICogKHJldHJ5QXR0ZW1wdCAtIDIpO1xufTtcblxuY29uc3Qgc2xlZXAgPSAoZGVsYXk6IG51bWJlcikgPT5cbiAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG5cbmNvbnN0IGdldFBvbGljeSA9IChjb25maWd1cmF0aW9uOiBQYXJ0aWFsPFJldHJ5UG9saWN5Pik6IFJldHJ5UG9saWN5ID0+ICh7XG4gIGRlbGF5OiBNYXRoLm1heCgwLCBjb25maWd1cmF0aW9uLmRlbGF5ID8/IDApLFxuICBmYWN0b3I6IE1hdGgubWF4KDAsIGNvbmZpZ3VyYXRpb24uZmFjdG9yID8/IDApLFxuICBtYXhBdHRlbXB0czogTWF0aC5tYXgoMCwgY29uZmlndXJhdGlvbi5tYXhBdHRlbXB0cyA/PyAwKSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gcmV0cnk8VD4oXG4gIHJldHJ5YWJsZTogUmV0cnlhYmxlPFQ+LFxuICBwb2xpY3lDb25maWd1cmF0aW9uOiBSZXRyeVBvbGljeUNvbmZpZ3VyYXRpb24gPSB7fVxuKSB7XG4gIGNvbnN0IHBvbGljeSA9IGdldFBvbGljeShwb2xpY3lDb25maWd1cmF0aW9uKTtcblxuICBjb25zdCB7IG1heEF0dGVtcHRzIH0gPSBwb2xpY3k7XG4gIGNvbnN0IGNvbnRleHQ6IEF0dGVtcHRDb250ZXh0ID0ge1xuICAgIGF0dGVtcHQ6IDEsXG4gICAgYXR0ZW1wdHNSZW1haW5pbmc6IG1heEF0dGVtcHRzLFxuICB9O1xuXG4gIGNvbnN0IG9uRXJyb3IgPSBhc3luYyAoZXJyOiBFcnJvcik6IFByb21pc2U8VD4gPT4ge1xuICAgIGlmIChjb250ZXh0LmF0dGVtcHRzUmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgY29udGV4dC5hdHRlbXB0ICs9IDE7XG4gICAgY29udGV4dC5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xuXG4gICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVEZWxheShjb250ZXh0LCBwb2xpY3kpO1xuICAgIGlmIChkZWxheSkge1xuICAgICAgYXdhaXQgc2xlZXAoZGVsYXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRyeWFibGUoKS5jYXRjaChvbkVycm9yKTtcbiAgfTtcblxuICByZXR1cm4gcmV0cnlhYmxlKCkuY2F0Y2gob25FcnJvcik7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQWVBLE1BQU1BLGNBQWMsR0FBR0EsQ0FBQ0MsT0FBdUIsRUFBRUMsTUFBbUIsS0FBSztFQUN2RSxNQUFNO0lBQUVDO0VBQVEsQ0FBQyxHQUFHRixPQUFPO0VBQzNCLE1BQU07SUFBRUcsS0FBSztJQUFFQztFQUFPLENBQUMsR0FBR0gsTUFBTTtFQUVoQyxNQUFNSSxZQUFZLEdBQUdILE9BQU8sR0FBRyxDQUFDO0VBQ2hDO0VBQ0EsSUFBSUcsWUFBWSxLQUFLLENBQUMsSUFBSUYsS0FBSyxLQUFLLENBQUMsRUFBRTtJQUNyQyxPQUFPLENBQUM7RUFDVjs7RUFFQTtFQUNBLE1BQU1HLEdBQUcsR0FBR0YsTUFBTSxHQUFHRCxLQUFLO0VBRTFCLE9BQU9BLEtBQUssR0FBR0csR0FBRyxJQUFJRCxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxNQUFNRSxLQUFLLEdBQUlKLEtBQWEsSUFDMUIsSUFBSUssT0FBTyxDQUFDQyxPQUFPLElBQUlDLFVBQVUsQ0FBQ0QsT0FBTyxFQUFFTixLQUFLLENBQUMsQ0FBQztBQUVwRCxNQUFNUSxTQUFTLEdBQUlDLGFBQW1DO0VBQUEsSUFBQUMsb0JBQUEsRUFBQUMscUJBQUEsRUFBQUMscUJBQUE7RUFBQSxPQUFtQjtJQUN2RVosS0FBSyxFQUFFYSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEdBQUFKLG9CQUFBLEdBQUVELGFBQWEsQ0FBQ1QsS0FBSyxjQUFBVSxvQkFBQSxjQUFBQSxvQkFBQSxHQUFJLENBQUMsQ0FBQztJQUM1Q1QsTUFBTSxFQUFFWSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEdBQUFILHFCQUFBLEdBQUVGLGFBQWEsQ0FBQ1IsTUFBTSxjQUFBVSxxQkFBQSxjQUFBQSxxQkFBQSxHQUFJLENBQUMsQ0FBQztJQUM5Q0ksV0FBVyxFQUFFRixJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEdBQUFGLHFCQUFBLEdBQUVILGFBQWEsQ0FBQ00sV0FBVyxjQUFBSCxxQkFBQSxjQUFBQSxxQkFBQSxHQUFJLENBQUM7RUFDekQsQ0FBQztBQUFBLENBQUM7QUFFSyxTQUFTSSxLQUFLQSxDQUNuQkMsU0FBdUIsRUFDdkJDLG1CQUE2QyxHQUFHLENBQUMsQ0FBQyxFQUNsRDtFQUNBLE1BQU1wQixNQUFNLEdBQUdVLFNBQVMsQ0FBQ1UsbUJBQW1CLENBQUM7RUFFN0MsTUFBTTtJQUFFSDtFQUFZLENBQUMsR0FBR2pCLE1BQU07RUFDOUIsTUFBTUQsT0FBdUIsR0FBRztJQUM5QkUsT0FBTyxFQUFFLENBQUM7SUFDVm9CLGlCQUFpQixFQUFFSjtFQUNyQixDQUFDO0VBRUQsTUFBTUssT0FBTyxHQUFHLE1BQU9DLEdBQVUsSUFBaUI7SUFDaEQsSUFBSXhCLE9BQU8sQ0FBQ3NCLGlCQUFpQixLQUFLLENBQUMsRUFBRTtNQUNuQyxNQUFNRSxHQUFHO0lBQ1g7SUFFQXhCLE9BQU8sQ0FBQ0UsT0FBTyxJQUFJLENBQUM7SUFDcEJGLE9BQU8sQ0FBQ3NCLGlCQUFpQixJQUFJLENBQUM7SUFFOUIsTUFBTW5CLEtBQUssR0FBR0osY0FBYyxDQUFDQyxPQUFPLEVBQUVDLE1BQU0sQ0FBQztJQUM3QyxJQUFJRSxLQUFLLEVBQUU7TUFDVCxNQUFNSSxLQUFLLENBQUNKLEtBQUssQ0FBQztJQUNwQjtJQUVBLE9BQU9pQixTQUFTLENBQUMsQ0FBQyxDQUFDSyxLQUFLLENBQUNGLE9BQU8sQ0FBQztFQUNuQyxDQUFDO0VBRUQsT0FBT0gsU0FBUyxDQUFDLENBQUMsQ0FBQ0ssS0FBSyxDQUFDRixPQUFPLENBQUM7QUFDbkMiLCJpZ25vcmVMaXN0IjpbXX0=