type IsSupportedFunction = () => Promise<{
    supported: boolean;
    error: SDKUnsupportedReasons | undefined;
}>;
declare enum SDKUnsupportedReasons {
    IncompatibleBrowser = "incompatible-browser",
    ThirdPartyCookiesDisabled = "third-party-cookies-disabled",
    NoMediaStreamsSupport = "no-media-streams-support"
}
/**
 * Check if the client being initialized is compatible with loom features.
 * @returns Support information
 */
declare const isSupported: IsSupportedFunction;
//# sourceMappingURL=is-supported.d.ts.map

declare enum Environment {
    Development = "development",
    Testbench = "testbench",
    Staging = "staging",
    Production = "production"
}
declare enum RecordingType {
    ScreenAndCamera = "screen_cam",
    ScreenOnly = "screen",
    CameraOnly = "cam"
}
interface SDKStyles {
    /**
     * Font family to be used instead of loom defaults. This is 1:1 with `font-family`.
     */
    fontFamily?: string;
    /**
     * Base font unit size used to calculate the font size for the text.
     */
    fontUnitSize?: string;
    /**
     * Collection of record button color options
     */
    recordButtonColor?: string;
    recordButtonHoverColor?: string;
    recordButtonActiveColor?: string;
    /**
     * Collection of primary color overrides
     */
    primaryColor?: string;
    primaryHoverColor?: string;
    primaryActiveColor?: string;
}
interface SDKConfig {
    bubbleResizable: boolean;
    insertButtonText: string;
    disablePreviewModal?: boolean;
    enableOnboardingTutorial?: boolean;
    allowedRecordingTypes?: [RecordingType, ...RecordingType[]];
    /**
     * The default selection for recording type. If `allowedRecordingTypes` is specified, should
     * include this default type in the list. If unspecified, defaults to Screen and Camera
     */
    defaultRecordingType?: RecordingType;
    /**
     * Collection of styles that can be applied to the loom components.
     */
    styles?: SDKStyles;
}
declare enum SDKState {
    Closed = "closed",
    PreRecording = "pre-recording",
    ActiveRecording = "active-recording",
    PostRecording = "post-recording"
}
interface LoomVideo {
    id: string;
    title: string;
    height: number;
    width: number;
    sharedUrl: string;
    embedUrl: string;
    thumbnailHeight?: number;
    thumbnailWidth?: number;
    thumbnailUrl?: string;
    duration?: number;
    providerUrl: string;
}
/**
 * Types pull eventemitter3 to avoid bundling types from that package.
 */
type ValidEventTypes = string | symbol | any;
type EventNames<T extends ValidEventTypes> = T extends string | symbol ? T : keyof T;
type ArgumentMap<T> = {
    [K in keyof T]: T[K] extends (...args: any[]) => void ? Parameters<T[K]> : T[K] extends any[] ? T[K] : any[];
};
type EventListener<T extends ValidEventTypes, K extends EventNames<T>> = T extends string | symbol ? (...args: any[]) => void : (...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]) => void;
type EventArgs<T extends ValidEventTypes, K extends EventNames<T>> = Parameters<EventListener<T, K>>;
interface EventEmitter<EventTypes extends ValidEventTypes = string | symbol, Context = any> {
    eventNames(): Array<EventNames<EventTypes>>;
    listeners<T extends EventNames<EventTypes>>(event: T): Array<EventListener<EventTypes, T>>;
    listenerCount(event: EventNames<EventTypes>): number;
    emit<T extends EventNames<EventTypes>>(event: T, ...args: EventArgs<EventTypes, T>): boolean;
    on<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    addListener<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    once<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    removeListener<T extends EventNames<EventTypes>>(event: T, fn?: EventListener<EventTypes, T>, context?: Context, once?: boolean): this;
    off<T extends EventNames<EventTypes>>(event: T, fn?: EventListener<EventTypes, T>, context?: Context, once?: boolean): this;
    removeAllListeners(event?: EventNames<EventTypes>): this;
}

type HookFn<T> = (a: T) => void;
interface Hooks {
    onInsertClicked: HookFn<LoomVideo>;
    onStart?: HookFn<void>;
    onRecordingStarted?: HookFn<void>;
    onCancel?: HookFn<void>;
    onComplete?: HookFn<void>;
    onAnalyticsEvent?: HookFn<string>;
    onLifecycleUpdate?: HookFn<SDKState>;
    onRecordingComplete: HookFn<LoomVideo>;
    onUploadComplete: HookFn<LoomVideo>;
}//# sourceMappingURL=hooks.d.ts.map

interface Position {
    x: number;
    y: number;
}
interface ButtonEmitterEvents {
    'bubble-drag-end': (pos: Position) => void;
    'bubble-drag-start': (pos: Position) => void;
    'bubble-move': (pos: Position) => void;
    cancel: () => void;
    complete: () => void;
    'insert-click': (video: LoomVideo) => void;
    'lifecycle-update': (state: SDKState) => void;
    'recording-complete': (video: LoomVideo) => void;
    'recording-start': () => void;
    start: () => void;
    'upload-complete': (video: LoomVideo) => void;
}
/**
 * Public definition for the SDK Button.
 */
interface SDKButtonInterface extends EventEmitter<ButtonEmitterEvents> {
    /**
     * Opens the recording panel to start a user's record flow.
     */
    openPreRecordPanel: () => void;
    /**
     * Closes the recording panel.
     */
    closePreRecordPanel: () => void;
    /**
     * Move the recording bubble.
     * @param pos New position where the bubble will be moved to. This value is pixels relative
     * to the bubble's iframe container.
     */
    moveBubble: (p: Position) => void;
    /**
     * End a recording in progress
     */
    endRecording: () => void;
}

type ButtonFn = (a?: {
    element?: HTMLElement;
    hooks?: Hooks;
}) => SDKButtonInterface;
type SDKResult = {
    teardown: () => void;
    configureButton: ButtonFn;
    status: () => {
        state: SDKState | undefined;
        success: boolean;
    };
};
type SetupFunction = (a: {
    /**
     * @deprecated `apiKey` has been renamed to `publicAppId`, please use that instead
     */
    apiKey?: string;
    publicAppId?: string;
    environment?: Environment;
    config?: Partial<SDKConfig>;
    jws?: string;
}) => Promise<SDKResult>;
declare const setup: SetupFunction;
//# sourceMappingURL=setup.d.ts.map

export { Hooks, LoomVideo, RecordingType, SDKButtonInterface, SDKResult, SDKState, SDKUnsupportedReasons, SetupFunction, isSupported, setup };
