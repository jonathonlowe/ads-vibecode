declare type DataType = any;
export interface DatabaseSchema {
    [collectionName: string]: DataType;
}
export interface Collection<D extends DataType> {
    uuid: number;
    factory: DataFactory<D>;
    records: DataRecord<D>[];
}
export declare type DataFactory<D extends DataType> = () => D;
export declare type RecordId = number;
export interface DataRecord<D extends DataType> {
    id: RecordId;
    data: D;
}
export declare class Database<M extends DatabaseSchema> {
    private collectionStore;
    constructor();
    all<K extends keyof M>(collectionName: K): DataRecord<M[K]>[];
    belongsTo<K extends keyof M>(collectionName: K, conditions: Partial<M[K]>): () => DataRecord<M[K]> | undefined;
    create<K extends keyof M>(collectionName: K, size?: number, factory?: DataFactory<M[K]>): DataRecord<M[K]>[];
    delete<K extends keyof M>(collectionName: K, id: RecordId): DataRecord<M[K]> | null;
    exists<K extends keyof M>(collectionName: K): boolean;
    find<K extends keyof M>(collectionName: K, conditions: Partial<M[K]>): DataRecord<M[K]>[];
    findOne<K extends keyof M>(collectionName: K, conditions: Partial<M[K]>): DataRecord<M[K]> | undefined;
    first<K extends keyof M>(collectionName: K): DataRecord<M[K]> | undefined;
    last<K extends keyof M>(collectionName: K): DataRecord<M[K]> | undefined;
    push<K extends keyof M>(collectionName: K, data: M[K]): DataRecord<M[K]>;
    register<K extends keyof M>(collectionName: K, factory: DataFactory<M[K]>): void;
    reset(): void;
    update<K extends keyof M>(collectionName: K, id: RecordId, data: Partial<M[K]>): DataRecord<M[K]>;
    getCollection<K extends keyof M>(collectionName: K): Collection<M[K]>;
}
export declare class CollectionNotFoundError extends Error {
    constructor(collectionName: string);
}
export declare class RecordNotFoundError extends Error {
    constructor(collectionName: string, id: RecordId);
}
export {};
