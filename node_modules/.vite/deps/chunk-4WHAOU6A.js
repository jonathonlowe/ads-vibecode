import {
  base_exports,
  base_new_exports,
  init_base,
  init_base_new
} from "./chunk-C5UHE4AN.js";
import {
  Manager,
  Popper,
  Portal,
  Reference,
  useNotifyOpenLayerObserver
} from "./chunk-ZGVEQJNH.js";
import {
  UNSAFE_useMediaQuery,
  box_default
} from "./chunk-HQP6RSCY.js";
import {
  noop,
  useId
} from "./chunk-CVCFKGGR.js";
import {
  require_dist
} from "./chunk-WGZLMHA6.js";
import {
  _toConsumableArray
} from "./chunk-UEZMFDUV.js";
import {
  ax
} from "./chunk-55ID7ZG3.js";
import {
  _extends,
  init_extends
} from "./chunk-BA6HJOCH.js";
import {
  _defineProperty,
  _objectWithoutProperties,
  _slicedToArray,
  fg,
  init_defineProperty,
  init_esm,
  init_objectWithoutProperties,
  init_slicedToArray
} from "./chunk-2WJRDDYS.js";
import {
  require_react
} from "./chunk-2YZST6ER.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/tabbable/index.js
var require_tabbable = __commonJS({
  "node_modules/tabbable/index.js"(exports, module) {
    module.exports = function(el, options) {
      options = options || {};
      var elementDocument = el.ownerDocument || el;
      var basicTabbables = [];
      var orderedTabbables = [];
      var isUnavailable = createIsUnavailable(elementDocument);
      var candidateSelectors = [
        "input",
        "select",
        "a[href]",
        "textarea",
        "button",
        "[tabindex]"
      ];
      var candidates = el.querySelectorAll(candidateSelectors.join(","));
      if (options.includeContainer) {
        var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        if (candidateSelectors.some(function(candidateSelector) {
          return matches.call(el, candidateSelector);
        })) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }
      var candidate, candidateIndexAttr, candidateIndex;
      for (var i = 0, l = candidates.length; i < l; i++) {
        candidate = candidates[i];
        candidateIndexAttr = parseInt(candidate.getAttribute("tabindex"), 10);
        candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;
        if (candidateIndex < 0 || candidate.tagName === "INPUT" && candidate.type === "hidden" || candidate.disabled || isUnavailable(candidate, elementDocument)) {
          continue;
        }
        if (candidateIndex === 0) {
          basicTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            index: i,
            tabIndex: candidateIndex,
            node: candidate
          });
        }
      }
      var tabbableNodes = orderedTabbables.sort(function(a, b) {
        return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
      }).map(function(a) {
        return a.node;
      });
      Array.prototype.push.apply(tabbableNodes, basicTabbables);
      return tabbableNodes;
    };
    function createIsUnavailable(elementDocument) {
      var isOffCache = [];
      function isOff(node, nodeComputedStyle) {
        if (node === elementDocument.documentElement) return false;
        for (var i = 0, length = isOffCache.length; i < length; i++) {
          if (isOffCache[i][0] === node) return isOffCache[i][1];
        }
        nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);
        var result = false;
        if (nodeComputedStyle.display === "none") {
          result = true;
        } else if (node.parentNode) {
          result = isOff(node.parentNode);
        }
        isOffCache.push([node, result]);
        return result;
      }
      return function isUnavailable(node) {
        if (node === elementDocument.documentElement) return false;
        var computedStyle = elementDocument.defaultView.getComputedStyle(node);
        if (isOff(node, computedStyle)) return true;
        return computedStyle.visibility === "hidden";
      };
    }
  }
});

// node_modules/focus-trap/index.js
var require_focus_trap = __commonJS({
  "node_modules/focus-trap/index.js"(exports, module) {
    var tabbable = require_tabbable();
    var listeningFocusTrap = null;
    function focusTrap(element, userOptions) {
      var tabbableNodes = [];
      var firstTabbableNode = null;
      var lastTabbableNode = null;
      var nodeFocusedBeforeActivation = null;
      var active = false;
      var paused = false;
      var tabEvent = null;
      var container = typeof element === "string" ? document.querySelector(element) : element;
      var config = userOptions || {};
      config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== void 0 ? userOptions.returnFocusOnDeactivate : true;
      config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== void 0 ? userOptions.escapeDeactivates : true;
      var trap = {
        activate,
        deactivate,
        pause,
        unpause
      };
      return trap;
      function activate(activateOptions) {
        if (active) return;
        var defaultedActivateOptions = {
          onActivate: activateOptions && activateOptions.onActivate !== void 0 ? activateOptions.onActivate : config.onActivate
        };
        active = true;
        paused = false;
        nodeFocusedBeforeActivation = document.activeElement;
        if (defaultedActivateOptions.onActivate) {
          defaultedActivateOptions.onActivate();
        }
        addListeners();
        return trap;
      }
      function deactivate(deactivateOptions) {
        if (!active) return;
        var defaultedDeactivateOptions = {
          returnFocus: deactivateOptions && deactivateOptions.returnFocus !== void 0 ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
          onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== void 0 ? deactivateOptions.onDeactivate : config.onDeactivate
        };
        removeListeners();
        if (defaultedDeactivateOptions.onDeactivate) {
          defaultedDeactivateOptions.onDeactivate();
        }
        if (defaultedDeactivateOptions.returnFocus) {
          setTimeout(function() {
            tryFocus(nodeFocusedBeforeActivation);
          }, 0);
        }
        active = false;
        paused = false;
        return this;
      }
      function pause() {
        if (paused || !active) return;
        paused = true;
        removeListeners();
      }
      function unpause() {
        if (!paused || !active) return;
        paused = false;
        addListeners();
      }
      function addListeners() {
        if (!active) return;
        if (listeningFocusTrap) {
          listeningFocusTrap.pause();
        }
        listeningFocusTrap = trap;
        updateTabbableNodes();
        setTimeout(function() {
          tryFocus(firstFocusNode());
        }, 0);
        document.addEventListener("focus", checkFocus, true);
        document.addEventListener("click", checkClick, true);
        document.addEventListener("mousedown", checkPointerDown, true);
        document.addEventListener("touchstart", checkPointerDown, true);
        document.addEventListener("keydown", checkKey, true);
        return trap;
      }
      function removeListeners() {
        if (!active || listeningFocusTrap !== trap) return;
        document.removeEventListener("focus", checkFocus, true);
        document.removeEventListener("click", checkClick, true);
        document.removeEventListener("mousedown", checkPointerDown, true);
        document.removeEventListener("touchstart", checkPointerDown, true);
        document.removeEventListener("keydown", checkKey, true);
        listeningFocusTrap = null;
        return trap;
      }
      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;
        if (!optionValue) {
          return null;
        }
        if (typeof optionValue === "string") {
          node = document.querySelector(optionValue);
          if (!node) {
            throw new Error("`" + optionName + "` refers to no known node");
          }
        }
        if (typeof optionValue === "function") {
          node = optionValue();
          if (!node) {
            throw new Error("`" + optionName + "` did not return a node");
          }
        }
        return node;
      }
      function firstFocusNode() {
        var node;
        if (getNodeForOption("initialFocus") !== null) {
          node = getNodeForOption("initialFocus");
        } else if (container.contains(document.activeElement)) {
          node = document.activeElement;
        } else {
          node = tabbableNodes[0] || getNodeForOption("fallbackFocus");
        }
        if (!node) {
          throw new Error("You can't have a focus-trap without at least one focusable element");
        }
        return node;
      }
      function checkPointerDown(e) {
        if (config.clickOutsideDeactivates && !container.contains(e.target)) {
          deactivate({ returnFocus: false });
        }
      }
      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      function checkFocus(e) {
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
        if (typeof e.target.blur === "function") e.target.blur();
        if (tabEvent) {
          readjustFocus(tabEvent);
        }
      }
      function checkKey(e) {
        if (e.key === "Tab" || e.keyCode === 9) {
          handleTab(e);
        }
        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
          deactivate();
        }
      }
      function handleTab(e) {
        updateTabbableNodes();
        if (e.target.hasAttribute("tabindex") && Number(e.target.getAttribute("tabindex")) < 0) {
          return tabEvent = e;
        }
        e.preventDefault();
        var currentFocusIndex = tabbableNodes.indexOf(e.target);
        if (e.shiftKey) {
          if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
            return tryFocus(lastTabbableNode);
          }
          return tryFocus(tabbableNodes[currentFocusIndex - 1]);
        }
        if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);
        tryFocus(tabbableNodes[currentFocusIndex + 1]);
      }
      function updateTabbableNodes() {
        tabbableNodes = tabbable(container);
        firstTabbableNode = tabbableNodes[0];
        lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
      }
      function readjustFocus(e) {
        if (e.shiftKey) return tryFocus(lastTabbableNode);
        tryFocus(firstTabbableNode);
      }
    }
    function isEscapeEvent(e) {
      return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
    }
    function tryFocus(node) {
      if (!node || !node.focus) return;
      if (node === document.activeElement) return;
      node.focus();
      if (node.tagName.toLowerCase() === "input") {
        node.select();
      }
    }
    module.exports = focusTrap;
  }
});

// node_modules/@atlaskit/icon/utility/chevron-down.js
var require_chevron_down = __commonJS({
  "node_modules/@atlaskit/icon/utility/chevron-down.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _baseNew = _interopRequireDefault((init_base_new(), __toCommonJS(base_new_exports)));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var ChevronDownIcon = (props) => _react.default.createElement(_baseNew.default, Object.assign({
      dangerouslySetGlyph: `<path fill="currentcolor" fill-rule="evenodd" d="M2.03 3.97 6 7.94l3.97-3.97 1.06 1.06-4.5 4.5a.75.75 0 0 1-1.06 0l-4.5-4.5z" clip-rule="evenodd"/>`,
      type: "utility"
      // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
    }, props));
    ChevronDownIcon.displayName = "ChevronDownIcon";
    var _default = exports.default = ChevronDownIcon;
  }
});

// node_modules/@atlaskit/icon/glyph/chevron-down.js
var require_chevron_down2 = __commonJS({
  "node_modules/@atlaskit/icon/glyph/chevron-down.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _base = (init_base(), __toCommonJS(base_exports));
    var _chevronDown = _interopRequireDefault(require_chevron_down());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var ChevronDownIcon = (props) => _react.default.createElement(_base.IconFacade, Object.assign({
      dangerouslySetGlyph: `<svg width="24" height="24" viewBox="0 0 24 24" role="presentation"><path fill="currentcolor" fill-rule="evenodd" d="M8.292 10.293a1.01 1.01 0 0 0 0 1.419l2.939 2.965c.218.215.5.322.779.322s.556-.107.769-.322l2.93-2.955a1.01 1.01 0 0 0 0-1.419.987.987 0 0 0-1.406 0l-2.298 2.317-2.307-2.327a.99.99 0 0 0-1.406 0"/></svg>`
    }, props, {
      newIcon: _chevronDown.default,
      iconType: "utility"
    }));
    ChevronDownIcon.displayName = "ChevronDownIcon";
    var _default = exports.default = ChevronDownIcon;
  }
});

// node_modules/@atlaskit/icon/utility/migration/chevron-down.js
var require_chevron_down3 = __commonJS({
  "node_modules/@atlaskit/icon/utility/migration/chevron-down.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _chevronDown = _interopRequireDefault(require_chevron_down());
    var _chevronDown2 = _interopRequireDefault(require_chevron_down2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var ChevronDownIcon = (props) => _react.default.createElement(_chevronDown.default, Object.assign({
      LEGACY_fallbackIcon: _chevronDown2.default
      // eslint-disable-next-line @repo/internal/react/no-unsafe-spread-props
    }, props));
    ChevronDownIcon.Name = "ChevronDownIconMigration";
    var _default = exports.default = ChevronDownIcon;
  }
});

// node_modules/@atlaskit/popup/dist/esm/popup.js
init_slicedToArray();
var React4 = __toESM(require_react());
import "/Users/mjerkovic/Documents/GitHub/ads-vibecode/node_modules/@atlaskit/popup/dist/esm/popup.compiled.css";
var import_react11 = __toESM(require_react());

// node_modules/@atlaskit/layering/dist/esm/components/layering-context.js
init_defineProperty();
var import_react = __toESM(require_react());
init_esm();
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var LevelContext = (0, import_react.createContext)(0);
var TopLevelContext = (0, import_react.createContext)({
  topLevelRef: {
    current: null
  },
  layerList: {
    current: null
  },
  setTopLevel: noop
});
var LevelProvider = function LevelProvider2(_ref) {
  var children = _ref.children, currentLevel = _ref.currentLevel;
  var _useContext = (0, import_react.useContext)(TopLevelContext), setTopLevel = _useContext.setTopLevel, topLevelRef = _useContext.topLevelRef, layerList = _useContext.layerList;
  var id = (0, import_react.useRef)(fg("layering-top-level-use-array") ? Math.random().toString(36) : "");
  if (!fg("layering-top-level-use-array")) {
    if (topLevelRef.current === null || currentLevel > topLevelRef.current) {
      setTopLevel(currentLevel);
    }
  }
  if (!fg("layering-top-level-use-array")) {
    (0, import_react.useEffect)(function() {
      return function() {
        setTimeout(function() {
          setTopLevel(currentLevel - 1);
        }, 0);
      };
    }, [setTopLevel, currentLevel, topLevelRef]);
  }
  if (fg("layering-top-level-use-array")) {
    (0, import_react.useEffect)(function() {
      var safeLayerList = layerList === null || layerList === void 0 ? void 0 : layerList.current;
      var safeId = id.current;
      if (!safeLayerList) {
        return;
      }
      safeLayerList.push(safeId);
      return function() {
        var index = safeLayerList.indexOf(safeId);
        if (index > -1) {
          safeLayerList.splice(index, 1);
        }
      };
    }, [layerList, id]);
  }
  return import_react.default.createElement(LevelContext.Provider, {
    value: currentLevel
  }, children);
};
var LayeringProvider = function LayeringProvider2(_ref2) {
  var children = _ref2.children;
  var topLevelRef = (0, import_react.useRef)(0);
  var layerList = (0, import_react.useRef)([]);
  var value = (0, import_react.useMemo)(function() {
    return _objectSpread({
      topLevelRef,
      setTopLevel: function setTopLevel(level) {
        topLevelRef.current = level;
      }
    }, fg("layering-top-level-use-array") ? {
      layerList
    } : {});
  }, [topLevelRef]);
  return import_react.default.createElement(TopLevelContext.Provider, {
    value
  }, children);
};
var Layering = function Layering2(_ref3) {
  var children = _ref3.children, _ref3$isDisabled = _ref3.isDisabled, isDisabled = _ref3$isDisabled === void 0 ? true : _ref3$isDisabled;
  var currentLevel = (0, import_react.useContext)(LevelContext);
  if (isDisabled) {
    return import_react.default.createElement(import_react.default.Fragment, null, children);
  }
  var isNested = currentLevel > 0;
  var content = import_react.default.createElement(LevelProvider, {
    currentLevel: currentLevel + 1
  }, children);
  return isNested ? content : import_react.default.createElement(LayeringProvider, null, content);
};

// node_modules/@atlaskit/layering/dist/esm/hooks/index.js
init_defineProperty();
var import_react2 = __toESM(require_react());
var import_bind_event_listener = __toESM(require_dist());
init_esm();
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function useLayering() {
  var currentLevel = (0, import_react2.useContext)(LevelContext);
  var _useContext = (0, import_react2.useContext)(TopLevelContext), topLevelRef = _useContext.topLevelRef, layerList = _useContext.layerList;
  var isLayerDisabled = (0, import_react2.useCallback)(function() {
    if (fg("layering-top-level-use-array")) {
      var _layerList$current$le, _layerList$current;
      return ((_layerList$current$le = layerList === null || layerList === void 0 || (_layerList$current = layerList.current) === null || _layerList$current === void 0 ? void 0 : _layerList$current.length) !== null && _layerList$current$le !== void 0 ? _layerList$current$le : 0) !== currentLevel;
    }
    return !!topLevelRef.current && currentLevel !== topLevelRef.current;
  }, [currentLevel, topLevelRef, layerList]);
  return _objectSpread2({
    currentLevel,
    topLevelRef,
    isLayerDisabled
  }, fg("layering-top-level-use-array") ? {
    layerList
  } : {});
}

// node_modules/@atlaskit/popup/dist/esm/popup.js
init_esm();

// node_modules/@atlaskit/popup/dist/esm/popper-wrapper.js
init_slicedToArray();
init_extends();
init_objectWithoutProperties();
var React3 = __toESM(require_react());
var import_react7 = __toESM(require_react());
import "/Users/mjerkovic/Documents/GitHub/ads-vibecode/node_modules/@atlaskit/popup/dist/esm/popper-wrapper.compiled.css";
init_esm();

// node_modules/@atlaskit/popup/dist/esm/reposition-on-update.js
var import_react3 = __toESM(require_react());
var RepositionOnUpdate = function RepositionOnUpdate2(_ref) {
  var children = _ref.children, update = _ref.update;
  var isFirstRenderRef = (0, import_react3.useRef)(true);
  (0, import_react3.useLayoutEffect)(function() {
    if (isFirstRenderRef.current) {
      isFirstRenderRef.current = false;
      return;
    }
    update();
  }, [update]);
  return import_react3.default.createElement(import_react3.Fragment, null, children);
};

// node_modules/@atlaskit/popup/dist/esm/use-close-manager.js
var import_react5 = __toESM(require_react());
var import_bind_event_listener2 = __toESM(require_dist());
init_esm();

// node_modules/@atlaskit/popup/dist/esm/utils/is-element-interactive.js
var interactiveTags = ["button", "a", "input", "select", "textarea"];
var isInteractiveElement = function isInteractiveElement2(element) {
  if (interactiveTags.includes(element.tagName.toLowerCase())) {
    return true;
  }
  if (element.getAttribute("tabindex") !== null || element.hasAttribute("contenteditable")) {
    return true;
  }
  return false;
};

// node_modules/@atlaskit/popup/dist/esm/utils/use-animation-frame.js
var import_react4 = __toESM(require_react());
var useAnimationFrame = function useAnimationFrame2() {
  var animationsRef = (0, import_react4.useRef)([]);
  var requestFrame = (0, import_react4.useCallback)(function(callback) {
    var id = requestAnimationFrame(callback);
    animationsRef.current.push(id);
    return id;
  }, []);
  var cancelFrame = (0, import_react4.useCallback)(function(id) {
    cancelAnimationFrame(id);
    animationsRef.current = animationsRef.current.filter(function(frameId) {
      return frameId !== id;
    });
  }, []);
  var cancelAllFrames = (0, import_react4.useCallback)(function() {
    animationsRef.current.forEach(function(id) {
      return cancelAnimationFrame(id);
    });
    animationsRef.current = [];
  }, []);
  return {
    requestFrame,
    cancelFrame,
    cancelAllFrames
  };
};

// node_modules/@atlaskit/popup/dist/esm/use-close-manager.js
var useCloseManager = function useCloseManager2(_ref) {
  var isOpen = _ref.isOpen, onClose = _ref.onClose, popupRef = _ref.popupRef, triggerRef = _ref.triggerRef, autoFocus = _ref.autoFocus, shouldDisableFocusTrap = _ref.shouldDisableFocusTrap, capture = _ref.shouldUseCaptureOnOutsideClick, shouldCloseOnTab = _ref.shouldCloseOnTab, shouldRenderToParent = _ref.shouldRenderToParent;
  var _useLayering = useLayering(), isLayerDisabled = _useLayering.isLayerDisabled, currentLevel = _useLayering.currentLevel;
  var _useAnimationFrame = useAnimationFrame(), requestFrame = _useAnimationFrame.requestFrame, cancelAllFrames = _useAnimationFrame.cancelAllFrames;
  (0, import_react5.useEffect)(function() {
    if (!isOpen || !popupRef) {
      return noop;
    }
    var inIframe = window && window.self !== window.top && fg("fix-dropdown-close-outside-iframe");
    var closePopup = function closePopup2(event) {
      if (onClose) {
        if (fg("sibling-dropdown-close-issue")) {
          var _currentLevel = null;
          if (event.target instanceof HTMLElement) {
            var _event$target$closest;
            _currentLevel = (_event$target$closest = event.target.closest("[data-ds--level]")) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.getAttribute("data-ds--level");
          }
          _currentLevel ? onClose(event, Number(_currentLevel)) : onClose(event);
        } else {
          onClose(event);
        }
      }
      if (shouldDisableFocusTrap && fg("platform_dst_popup-disable-focuslock")) {
        requestFrame(function() {
          triggerRef === null || triggerRef === void 0 || triggerRef.setAttribute("tabindex", "0");
          if (popupRef && autoFocus) {
            popupRef.setAttribute("tabindex", "0");
          }
        });
      }
    };
    var onClick = function onClick2(event) {
      var target = event.target;
      var doesDomNodeExist = document.body.contains(target);
      if (!doesDomNodeExist && !inIframe) {
        return;
      }
      if (isLayerDisabled()) {
        if (fg("design-system-closed-all-when-click-outside")) {
          if (target instanceof HTMLElement) {
            var _target$closest;
            var layeredElement = (_target$closest = target.closest) === null || _target$closest === void 0 ? void 0 : _target$closest.call(target, "[data-ds--level]");
            if (layeredElement) {
              var closeType = layeredElement.getAttribute("[data-ds--close--type]");
              if (closeType === "single") {
                return;
              }
              var levelOfClickedLayer = layeredElement.getAttribute("data-ds--level");
              if (levelOfClickedLayer && Number(levelOfClickedLayer) > currentLevel) {
                return;
              }
            }
          }
        } else {
          return;
        }
      }
      var isClickOnPopup = popupRef && popupRef.contains(target);
      var isClickOnTrigger = triggerRef && triggerRef.contains(target);
      if (!isClickOnPopup && !isClickOnTrigger) {
        closePopup(event);
        if (document.activeElement && !isInteractiveElement(document.activeElement) && fg("platform_dst_popup-disable-focuslock")) {
          triggerRef === null || triggerRef === void 0 || triggerRef.focus();
        }
      }
    };
    var onKeyDown = function onKeyDown2(event) {
      if (fg("platform_dst_popup-disable-focuslock")) {
        var key = event.key, shiftKey = event.shiftKey;
        if (shiftKey && key === "Tab" && !shouldRenderToParent) {
          if (isLayerDisabled()) {
            return;
          }
          requestFrame(function() {
            var isPopupFocusOut = popupRef && !popupRef.contains(document.activeElement);
            if (isPopupFocusOut) {
              closePopup(event);
              if (currentLevel === 1) {
                triggerRef === null || triggerRef === void 0 || triggerRef.focus();
              }
            }
          });
          return;
        }
        if (key === "Tab") {
          var _document$activeEleme;
          if (shouldCloseOnTab) {
            if (isLayerDisabled()) {
              return;
            }
            closePopup(event);
            return;
          }
          if (isLayerDisabled() && (_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.closest("[aria-modal]")) {
            return;
          }
          if (shouldDisableFocusTrap) {
            if (shouldRenderToParent) {
              requestFrame(function() {
                var isPopupFocusOut = popupRef && !popupRef.contains(document.activeElement);
                if (isPopupFocusOut) {
                  closePopup(event);
                }
              });
            } else {
              requestFrame(function() {
                if (!document.hasFocus()) {
                  closePopup(event);
                }
              });
            }
            return;
          }
        }
        if (isLayerDisabled()) {
          return;
        }
        if (key === "Escape" || key === "Esc") {
          if (triggerRef && autoFocus) {
            triggerRef.focus();
          }
          closePopup(event);
        }
      } else {
        if (isLayerDisabled()) {
          return;
        }
        var _key = event.key;
        if (_key === "Escape" || _key === "Esc" || shouldCloseOnTab && _key === "Tab") {
          closePopup(event);
        }
      }
    };
    var parentUnbind;
    if (inIframe && isOpen) {
      parentUnbind = (0, import_bind_event_listener2.bind)(window.parent.window, {
        type: "click",
        listener: onClick,
        options: {
          capture
        }
      });
    }
    var unbind = noop;
    if (fg("popup-onclose-fix")) {
      setTimeout(function() {
        unbind = (0, import_bind_event_listener2.bindAll)(window, [{
          type: "click",
          listener: onClick,
          options: {
            capture
          }
        }, {
          type: "keydown",
          listener: onKeyDown
        }]);
      }, 0);
    } else {
      unbind = (0, import_bind_event_listener2.bindAll)(window, [{
        type: "click",
        listener: onClick,
        options: {
          capture
        }
      }, {
        type: "keydown",
        listener: onKeyDown
      }]);
    }
    var unbindBlur = noop;
    unbindBlur = (0, import_bind_event_listener2.bind)(window, {
      type: "blur",
      listener: function onBlur(e) {
        if (isLayerDisabled() || !(document.activeElement instanceof HTMLIFrameElement)) {
          return;
        }
        closePopup(e);
      }
    });
    return function() {
      var _parentUnbind;
      if (fg("popup-onclose-fix")) {
        setTimeout(function() {
          unbind();
        }, 0);
      } else {
        unbind();
      }
      cancelAllFrames();
      (_parentUnbind = parentUnbind) === null || _parentUnbind === void 0 || _parentUnbind();
      unbindBlur();
    };
  }, [isOpen, onClose, popupRef, triggerRef, autoFocus, shouldDisableFocusTrap, capture, isLayerDisabled, shouldCloseOnTab, currentLevel, shouldRenderToParent, requestFrame, cancelAllFrames]);
};

// node_modules/@atlaskit/popup/dist/esm/use-focus-manager.js
var import_react6 = __toESM(require_react());
var import_focus_trap = __toESM(require_focus_trap());
init_esm();
var useFocusManager = function useFocusManager2(_ref) {
  var initialFocusRef = _ref.initialFocusRef, popupRef = _ref.popupRef, triggerRef = _ref.triggerRef, autoFocus = _ref.autoFocus, shouldCloseOnTab = _ref.shouldCloseOnTab, shouldDisableFocusTrap = _ref.shouldDisableFocusTrap, shouldReturnFocus = _ref.shouldReturnFocus, shouldRenderToParent = _ref.shouldRenderToParent;
  var _useAnimationFrame = useAnimationFrame(), requestFrame = _useAnimationFrame.requestFrame, cancelAllFrames = _useAnimationFrame.cancelAllFrames;
  var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
  (0, import_react6.useEffect)(function() {
    if (!popupRef || shouldCloseOnTab) {
      return noop;
    }
    if (shouldDisableFocusTrap && fg("platform_dst_popup-disable-focuslock")) {
      var isDropdown = popupRef.matches("[id^=ds--dropdown--]");
      var popups = document.querySelectorAll('[data-ds--level="'.concat(currentLevel - 1, '"]'));
      if (!(popups[popups.length - 1] && !shouldRenderToParent && isDropdown)) {
        requestFrame(function() {
          triggerRef === null || triggerRef === void 0 || triggerRef.setAttribute("tabindex", "-1");
          if (popupRef && autoFocus) {
            popupRef.setAttribute("tabindex", "-1");
          }
          (initialFocusRef || popupRef).focus();
        });
        return noop;
      }
    }
    var trapConfig = {
      clickOutsideDeactivates: true,
      escapeDeactivates: true,
      initialFocus: initialFocusRef || popupRef,
      fallbackFocus: popupRef,
      returnFocusOnDeactivate: shouldReturnFocus
    };
    var focusTrap = (0, import_focus_trap.default)(popupRef, trapConfig);
    requestFrame(function() {
      focusTrap.activate();
    });
    return function() {
      cancelAllFrames();
      focusTrap.deactivate();
    };
  }, [popupRef, triggerRef, autoFocus, initialFocusRef, shouldCloseOnTab, shouldDisableFocusTrap, requestFrame, cancelAllFrames, shouldReturnFocus, shouldRenderToParent, currentLevel]);
};

// node_modules/@atlaskit/popup/dist/esm/popper-wrapper.js
var _excluded = ["shouldRenderToParent", "shouldFitContainer", "children", "appearance", "className"];
var wrapperStyles = {
  root: "_2rkoglpi _1e0c1ule _vchhusvi _1pby1nn1 _bfhk1bhr _16qs1cd0 _syaz1fxt _1q1l1bhr _nt751r31 _49pcglyw _1hvw1o36"
};
var focusRingStyles = {
  root: "_mizu194a _1ah31bk5 _ra3xnqa1 _128m1bk5 _1cvmnqa1 _4davt94y"
};
var DefaultPopupComponent = (0, import_react7.forwardRef)(function(props, ref) {
  var shouldRenderToParent = props.shouldRenderToParent, shouldFitContainer = props.shouldFitContainer, children = props.children, appearance = props.appearance, className = props.className, htmlAttributes = _objectWithoutProperties(props, _excluded);
  return React3.createElement("div", _extends({
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
    className: ax([wrapperStyles.root, appearance === "UNSAFE_modal-below-sm" && "_dk5d1b66 _c71ldtre _kqsw1n9t _152t1b66", !shouldRenderToParent && "_1reo1wug _18m91wug", shouldFitContainer && "_1bsb1osq", className])
  }, htmlAttributes, {
    ref
  }), children);
});
function PopperWrapper(_ref) {
  var xcss = _ref.xcss, isOpen = _ref.isOpen, id = _ref.id, offset = _ref.offset, testId = _ref.testId, content = _ref.content, fallbackPlacements = _ref.fallbackPlacements, onClose = _ref.onClose, boundary = _ref.boundary, rootBoundary = _ref.rootBoundary, shouldFlip = _ref.shouldFlip, _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "auto" : _ref$placement, _ref$popupComponent = _ref.popupComponent, PopupContainer = _ref$popupComponent === void 0 ? DefaultPopupComponent : _ref$popupComponent, _ref$autoFocus = _ref.autoFocus, autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus, triggerRef = _ref.triggerRef, shouldUseCaptureOnOutsideClick = _ref.shouldUseCaptureOnOutsideClick, shouldRenderToParent = _ref.shouldRenderToParent, shouldFitContainer = _ref.shouldFitContainer, shouldDisableFocusLock = _ref.shouldDisableFocusLock, _ref$shouldReturnFocu = _ref.shouldReturnFocus, shouldReturnFocus = _ref$shouldReturnFocu === void 0 ? true : _ref$shouldReturnFocu, strategy = _ref.strategy, role = _ref.role, label = _ref.label, titleId = _ref.titleId, modifiers = _ref.modifiers, shouldFitViewport = _ref.shouldFitViewport, _ref$appearance = _ref.appearance, appearance = _ref$appearance === void 0 ? "default" : _ref$appearance;
  var _useState = (0, import_react7.useState)(null), _useState2 = _slicedToArray(_useState, 2), popupRef = _useState2[0], setPopupRef = _useState2[1];
  var _useState3 = (0, import_react7.useState)(null), _useState4 = _slicedToArray(_useState3, 2), initialFocusRef = _useState4[0], setInitialFocusRef = _useState4[1];
  var shouldCloseOnTab = shouldRenderToParent && shouldDisableFocusLock;
  var shouldDisableFocusTrap = role !== "dialog";
  useFocusManager({
    initialFocusRef,
    popupRef,
    shouldCloseOnTab,
    triggerRef,
    autoFocus,
    shouldDisableFocusTrap,
    shouldReturnFocus
  });
  useCloseManager({
    isOpen,
    onClose,
    popupRef,
    triggerRef,
    shouldUseCaptureOnOutsideClick,
    shouldCloseOnTab,
    autoFocus,
    shouldDisableFocusTrap,
    shouldRenderToParent
  });
  var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
  var mergedModifiers = (0, import_react7.useMemo)(function() {
    return [{
      name: "flip",
      enabled: shouldFlip,
      options: {
        rootBoundary,
        boundary,
        fallbackPlacements
      }
    }].concat(_toConsumableArray(modifiers || []));
  }, [shouldFlip, rootBoundary, boundary, fallbackPlacements, modifiers]);
  return React3.createElement(Popper, {
    placement,
    offset,
    modifiers: mergedModifiers,
    strategy,
    shouldFitViewport
  }, function(_ref2) {
    var _ref3 = _ref2.ref, style = _ref2.style, placement2 = _ref2.placement, update = _ref2.update;
    var popupContainer = React3.createElement(
      PopupContainer,
      {
        className: ax([
          xcss,
          // @ts-expect-error: `ax` is not typed correctly
          !initialFocusRef && // eslint-disable-next-line @atlaskit/platform/ensure-feature-flag-prefix
          fg("platform-design-system-apply-popup-wrapper-focus") && focusRingStyles.root
        ]),
        appearance,
        id,
        "data-ds--level": currentLevel,
        "data-placement": placement2,
        "data-testid": testId,
        role,
        "aria-label": label,
        "aria-labelledby": titleId,
        ref: function ref(node) {
          if (node) {
            if (typeof _ref3 === "function") {
              _ref3(node);
            } else {
              _ref3.current = node;
            }
            setPopupRef(node);
          }
        },
        style: appearance === "UNSAFE_modal-below-sm" ? {} : style,
        tabIndex: autoFocus ? 0 : void 0,
        shouldRenderToParent,
        shouldFitContainer
      },
      React3.createElement(RepositionOnUpdate, {
        update
      }, content({
        update,
        isOpen,
        onClose,
        setInitialFocusRef
      }))
    );
    return React3.createElement(import_react7.Fragment, null, popupContainer, appearance === "UNSAFE_modal-below-sm" && React3.createElement("div", {
      className: ax(["_1r04idpf _kqsw1n9t _bfhk10xm"])
    }));
  });
}
var popper_wrapper_default = PopperWrapper;

// node_modules/@atlaskit/popup/dist/esm/use-appearance.js
init_slicedToArray();
var import_react8 = __toESM(require_react());
function usePopupAppearance(_ref) {
  var _appearance = _ref.appearance, _shouldRenderToParent = _ref.shouldRenderToParent;
  var mq = UNSAFE_useMediaQuery("below.sm", function(e) {
    setIsSmallViewport(!!e.matches);
  });
  var _useState = (0, import_react8.useState)(!!(mq !== null && mq !== void 0 && mq.matches)), _useState2 = _slicedToArray(_useState, 2), isSmallViewport = _useState2[0], setIsSmallViewport = _useState2[1];
  var appearance = _appearance === "UNSAFE_modal-below-sm" && isSmallViewport ? "UNSAFE_modal-below-sm" : "default";
  var shouldRenderToParent = _shouldRenderToParent && appearance === "default";
  return {
    appearance,
    shouldRenderToParent
  };
}

// node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref.js
init_slicedToArray();
var import_react9 = __toESM(require_react());

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref.js
var useGetMemoizedMergedTriggerRef = function useGetMemoizedMergedTriggerRef2() {
  var _useState = (0, import_react9.useState)(function() {
    return memoizeOne(function(ref, setTriggerRef, isOpen) {
      return function(node) {
        if (node && isOpen) {
          if (typeof ref === "function") {
            ref(node);
          } else if (ref) {
            ref.current = node;
          }
          setTriggerRef(node);
        }
      };
    });
  }), _useState2 = _slicedToArray(_useState, 1), getMemoizedMergedTriggerRef = _useState2[0];
  return getMemoizedMergedTriggerRef;
};

// node_modules/@atlaskit/popup/dist/esm/use-get-memoized-merged-trigger-ref-new.js
init_slicedToArray();
var import_react10 = __toESM(require_react());
var useGetMemoizedMergedTriggerRefNew = function useGetMemoizedMergedTriggerRefNew2() {
  var _useState = (0, import_react10.useState)(function() {
    return memoizeOne(function(ref, setTriggerRef) {
      return function(node) {
        if (node) {
          if (typeof ref === "function") {
            ref(node);
          } else if (ref) {
            ref.current = node;
          }
          setTriggerRef(node);
        }
      };
    });
  }), _useState2 = _slicedToArray(_useState, 1), getMemoizedMergedTriggerRefNew = _useState2[0];
  return getMemoizedMergedTriggerRefNew;
};

// node_modules/@atlaskit/popup/dist/esm/popup.js
var defaultLayer = 400;
var wrapperStyles2 = {
  root: "_kqswh2mm"
};
var Popup = (0, import_react11.memo)(function(_ref) {
  var xcss = _ref.xcss, _ref$appearance = _ref.appearance, inAppearance = _ref$appearance === void 0 ? "default" : _ref$appearance, isOpen = _ref.isOpen, providedId = _ref.id, offset = _ref.offset, testId = _ref.testId, trigger = _ref.trigger, content = _ref.content, onClose = _ref.onClose, boundary = _ref.boundary, _ref$rootBoundary = _ref.rootBoundary, rootBoundary = _ref$rootBoundary === void 0 ? "viewport" : _ref$rootBoundary, _ref$shouldFlip = _ref.shouldFlip, shouldFlip = _ref$shouldFlip === void 0 ? true : _ref$shouldFlip, _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "auto" : _ref$placement, fallbackPlacements = _ref.fallbackPlacements, PopupContainer = _ref.popupComponent, _ref$autoFocus = _ref.autoFocus, autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus, _ref$zIndex = _ref.zIndex, zIndex = _ref$zIndex === void 0 ? defaultLayer : _ref$zIndex, _ref$shouldUseCapture = _ref.shouldUseCaptureOnOutsideClick, shouldUseCaptureOnOutsideClick = _ref$shouldUseCapture === void 0 ? false : _ref$shouldUseCapture, _ref$shouldRenderToPa = _ref.shouldRenderToParent, inShouldRenderToParent = _ref$shouldRenderToPa === void 0 ? false : _ref$shouldRenderToPa, _ref$shouldFitContain = _ref.shouldFitContainer, shouldFitContainer = _ref$shouldFitContain === void 0 ? false : _ref$shouldFitContain, _ref$shouldDisableFoc = _ref.shouldDisableFocusLock, shouldDisableFocusLock = _ref$shouldDisableFoc === void 0 ? false : _ref$shouldDisableFoc, _ref$shouldReturnFocu = _ref.shouldReturnFocus, shouldReturnFocus = _ref$shouldReturnFocu === void 0 ? true : _ref$shouldReturnFocu, strategy = _ref.strategy, role = _ref.role, label = _ref.label, titleId = _ref.titleId, modifiers = _ref.modifiers, shouldFitViewport = _ref.shouldFitViewport;
  var _useState = (0, import_react11.useState)(null), _useState2 = _slicedToArray(_useState, 2), triggerRef = _useState2[0], setTriggerRef = _useState2[1];
  var getMergedTriggerRef = useGetMemoizedMergedTriggerRef();
  var getMergedTriggerRefNew = useGetMemoizedMergedTriggerRefNew();
  var generatedId = useId();
  var _usePopupAppearance = usePopupAppearance({
    appearance: inAppearance,
    shouldRenderToParent: inShouldRenderToParent
  }), appearance = _usePopupAppearance.appearance, shouldRenderToParent = _usePopupAppearance.shouldRenderToParent;
  var id = providedId || generatedId;
  var handleOpenLayerObserverCloseSignal = (0, import_react11.useCallback)(function() {
    onClose === null || onClose === void 0 || onClose(null);
  }, [onClose]);
  useNotifyOpenLayerObserver({
    isOpen,
    onClose: handleOpenLayerObserverCloseSignal
  });
  var renderPopperWrapper = React4.createElement(Layering, {
    isDisabled: false
  }, React4.createElement(popper_wrapper_default, {
    xcss,
    appearance,
    content,
    isOpen,
    placement,
    fallbackPlacements,
    boundary,
    rootBoundary,
    shouldFlip,
    offset,
    popupComponent: PopupContainer,
    id,
    testId,
    onClose,
    autoFocus,
    shouldUseCaptureOnOutsideClick,
    shouldRenderToParent: shouldRenderToParent || shouldFitContainer,
    shouldFitContainer,
    shouldDisableFocusLock,
    shouldReturnFocus,
    triggerRef,
    strategy: shouldFitContainer ? "absolute" : strategy,
    role,
    label,
    titleId,
    modifiers,
    shouldFitViewport
  }));
  var popupContent = React4.createElement(Manager, null, React4.createElement(Reference, null, function(_ref2) {
    var ref = _ref2.ref;
    return trigger({
      ref: !fg("platform-design-system-popup-ref") ? getMergedTriggerRef(ref, setTriggerRef, isOpen) : getMergedTriggerRefNew(ref, setTriggerRef),
      "aria-controls": isOpen ? id : void 0,
      "aria-expanded": isOpen,
      "aria-haspopup": role === "dialog" && fg("platform_dst_popup-disable-focuslock") ? "dialog" : true
    });
  }), isOpen && (shouldRenderToParent || shouldFitContainer ? renderPopperWrapper : React4.createElement(Portal, {
    zIndex
  }, renderPopperWrapper)));
  if (shouldFitContainer) {
    return React4.createElement(box_default, {
      xcss: wrapperStyles2.root
    }, popupContent);
  }
  return popupContent;
});

// node_modules/@atlaskit/popup/dist/esm/index.js
var esm_default = Popup;

export {
  useLayering,
  esm_default,
  require_chevron_down,
  require_chevron_down3 as require_chevron_down2
};
//# sourceMappingURL=chunk-4WHAOU6A.js.map
