import {
  _assertThisInitialized,
  _objectWithoutPropertiesLoose,
  _setPrototypeOf,
  init_assertThisInitialized,
  init_objectWithoutPropertiesLoose,
  init_setPrototypeOf
} from "./chunk-IYLHYNH2.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
var init_objectWithoutProperties = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"() {
    init_objectWithoutPropertiesLoose();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime4() {
      "use strict";
      module.exports = _regeneratorRuntime4 = function _regeneratorRuntime5() {
        return e;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", {
          value: makeInvokeMethod(t2, r2, c2)
        }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof2(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", {
          value: function value(t3, n2) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n2, e3, r3);
              });
            }
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return {
              value: t,
              done: true
            };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return {
                value: p2.arg,
                done: n2.done
              };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof2(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n2, o3) {
            return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a2 = i2.completion;
            if ("root" === i2.tryLoc) return handle("end");
            if (i2.tryLoc <= this.prev) {
              var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
              if (c2 && u2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              } else if (c2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              } else {
                if (!u2) throw Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o2 = this.tryEntries[r2];
            if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
              var i2 = o2;
              break;
            }
          }
          i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
          var a2 = i2 ? i2.completion : {};
          return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
        },
        complete: function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        },
        finish: function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        },
        "catch": function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n2 = r2.completion;
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                resetTryEntry(r2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e2, r2, n2) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n2
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    module.exports = _regeneratorRuntime4, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@statsig/client-core/src/Log.js
var require_Log = __commonJS({
  "node_modules/@statsig/client-core/src/Log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Log = exports.LogLevel = void 0;
    var DEBUG = " DEBUG ";
    var _INFO = "  INFO ";
    var _WARN = "  WARN ";
    var ERROR = " ERROR ";
    function addTag(args) {
      args.unshift("[Statsig]");
      return args;
    }
    exports.LogLevel = {
      None: 0,
      Error: 1,
      Warn: 2,
      Info: 3,
      Debug: 4
    };
    var Log = class _Log {
      static info(...args) {
        if (_Log.level >= exports.LogLevel.Info) {
          console.info(_INFO, ...addTag(args));
        }
      }
      static debug(...args) {
        if (_Log.level >= exports.LogLevel.Debug) {
          console.debug(DEBUG, ...addTag(args));
        }
      }
      static warn(...args) {
        if (_Log.level >= exports.LogLevel.Warn) {
          console.warn(_WARN, ...addTag(args));
        }
      }
      static error(...args) {
        if (_Log.level >= exports.LogLevel.Error) {
          console.error(ERROR, ...addTag(args));
        }
      }
    };
    exports.Log = Log;
    Log.level = exports.LogLevel.Warn;
  }
});

// node_modules/@statsig/client-core/src/$_StatsigGlobal.js
var require_StatsigGlobal = __commonJS({
  "node_modules/@statsig/client-core/src/$_StatsigGlobal.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getInstance = exports._getStatsigGlobalFlag = exports._getStatsigGlobal = void 0;
    var Log_1 = require_Log();
    var _getStatsigGlobal = () => {
      try {
        return typeof __STATSIG__ !== "undefined" ? __STATSIG__ : statsigGlobal;
      } catch (e) {
        return statsigGlobal;
      }
    };
    exports._getStatsigGlobal = _getStatsigGlobal;
    var _getStatsigGlobalFlag = (flag) => {
      return (0, exports._getStatsigGlobal)()[flag];
    };
    exports._getStatsigGlobalFlag = _getStatsigGlobalFlag;
    var _getInstance = (sdkKey) => {
      const gbl = (0, exports._getStatsigGlobal)();
      if (!sdkKey) {
        if (gbl.instances && Object.keys(gbl.instances).length > 1) {
          Log_1.Log.warn("Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.");
        }
        return gbl.firstInstance;
      }
      return gbl.instances && gbl.instances[sdkKey];
    };
    exports._getInstance = _getInstance;
    var GLOBAL_KEY = "__STATSIG__";
    var _window = typeof window !== "undefined" ? window : {};
    var _global = typeof global !== "undefined" ? global : {};
    var _globalThis = typeof globalThis !== "undefined" ? globalThis : {};
    var statsigGlobal = (_c = (_b = (_a = _window[GLOBAL_KEY]) !== null && _a !== void 0 ? _a : _global[GLOBAL_KEY]) !== null && _b !== void 0 ? _b : _globalThis[GLOBAL_KEY]) !== null && _c !== void 0 ? _c : {
      instance: exports._getInstance
    };
    _window[GLOBAL_KEY] = statsigGlobal;
    _global[GLOBAL_KEY] = statsigGlobal;
    _globalThis[GLOBAL_KEY] = statsigGlobal;
  }
});

// node_modules/@statsig/client-core/src/Diagnostics.js
var require_Diagnostics = __commonJS({
  "node_modules/@statsig/client-core/src/Diagnostics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Diagnostics = void 0;
    var MARKER_MAP = /* @__PURE__ */ new Map();
    var ACT_START = "start";
    var ACT_END = "end";
    var DIAGNOSTICS_EVENT = "statsig::diagnostics";
    exports.Diagnostics = {
      _getMarkers: (sdkKey) => {
        return MARKER_MAP.get(sdkKey);
      },
      _markInitOverallStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "overall"));
      },
      _markInitOverallEnd: (sdkKey, success, evaluationDetails) => {
        _addMarker(sdkKey, _createMarker({
          success,
          error: success ? void 0 : { name: "InitializeError", message: "Failed to initialize" },
          evaluationDetails
        }, ACT_END, "overall"));
      },
      _markInitNetworkReqStart: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_START, "initialize", "network_request"));
      },
      _markInitNetworkReqEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "network_request"));
      },
      _markInitProcessStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "initialize", "process"));
      },
      _markInitProcessEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "process"));
      },
      _clearMarkers: (sdkKey) => {
        MARKER_MAP.delete(sdkKey);
      },
      _formatError(e) {
        if (!(e && typeof e === "object")) {
          return;
        }
        return {
          code: _safeGetField(e, "code"),
          name: _safeGetField(e, "name"),
          message: _safeGetField(e, "message")
        };
      },
      _getDiagnosticsData(res, attempt, body, e) {
        var _a;
        return {
          success: (res === null || res === void 0 ? void 0 : res.ok) === true,
          statusCode: res === null || res === void 0 ? void 0 : res.status,
          sdkRegion: (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a.get("x-statsig-region"),
          isDelta: body.includes('"is_delta":true') === true ? true : void 0,
          attempt,
          error: exports.Diagnostics._formatError(e)
        };
      },
      _enqueueDiagnosticsEvent(user, logger, sdk, options) {
        const markers = exports.Diagnostics._getMarkers(sdk);
        if (markers == null || markers.length <= 0) {
          return -1;
        }
        const overallInitDuration = markers[markers.length - 1].timestamp - markers[0].timestamp;
        exports.Diagnostics._clearMarkers(sdk);
        const event = _makeDiagnosticsEvent(user, {
          context: "initialize",
          markers: markers.slice(),
          statsigOptions: options
        });
        logger.enqueue(event);
        return overallInitDuration;
      }
    };
    function _createMarker(data, action, key, step) {
      return Object.assign({ key, action, step, timestamp: Date.now() }, data);
    }
    function _makeDiagnosticsEvent(user, data) {
      const latencyEvent = {
        eventName: DIAGNOSTICS_EVENT,
        user,
        value: null,
        metadata: data,
        time: Date.now()
      };
      return latencyEvent;
    }
    function _addMarker(sdkKey, marker) {
      var _a;
      const markers = (_a = MARKER_MAP.get(sdkKey)) !== null && _a !== void 0 ? _a : [];
      markers.push(marker);
      MARKER_MAP.set(sdkKey, markers);
    }
    function _safeGetField(data, field) {
      if (field in data) {
        return data[field];
      }
      return void 0;
    }
  }
});

// node_modules/@statsig/client-core/src/TypingUtils.js
var require_TypingUtils = __commonJS({
  "node_modules/@statsig/client-core/src/TypingUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isTypeMatch = exports._typeOf = void 0;
    function _typeOf(input) {
      return Array.isArray(input) ? "array" : typeof input;
    }
    exports._typeOf = _typeOf;
    function _isTypeMatch(a, b) {
      const typeOf = (x) => Array.isArray(x) ? "array" : typeof x;
      return typeOf(a) === typeOf(b);
    }
    exports._isTypeMatch = _isTypeMatch;
  }
});

// node_modules/@statsig/client-core/src/Hashing.js
var require_Hashing = __commonJS({
  "node_modules/@statsig/client-core/src/Hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getSortedObject = exports._DJB2Object = exports._DJB2 = void 0;
    var TypingUtils_1 = require_TypingUtils();
    var _DJB22 = (value) => {
      let hash = 0;
      for (let i = 0; i < value.length; i++) {
        const character = value.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash = hash & hash;
      }
      return String(hash >>> 0);
    };
    exports._DJB2 = _DJB22;
    var _DJB2Object = (value, maxLevels) => {
      return (0, exports._DJB2)(JSON.stringify((0, exports._getSortedObject)(value, maxLevels)));
    };
    exports._DJB2Object = _DJB2Object;
    var _getSortedObject = (object, maxDepth) => {
      if (object == null) {
        return null;
      }
      const keys = Object.keys(object).sort();
      const sortedObject = {};
      keys.forEach((key) => {
        const value = object[key];
        if (maxDepth === 0 || (0, TypingUtils_1._typeOf)(value) !== "object") {
          sortedObject[key] = value;
          return;
        }
        sortedObject[key] = (0, exports._getSortedObject)(value, maxDepth != null ? maxDepth - 1 : maxDepth);
      });
      return sortedObject;
    };
    exports._getSortedObject = _getSortedObject;
  }
});

// node_modules/@statsig/client-core/src/CacheKey.js
var require_CacheKey = __commonJS({
  "node_modules/@statsig/client-core/src/CacheKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getStorageKey = exports._getUserStorageKey = void 0;
    var Hashing_1 = require_Hashing();
    function _getUserStorageKey(sdkKey, user, customKeyGenerator) {
      var _a;
      if (customKeyGenerator) {
        return customKeyGenerator(sdkKey, user);
      }
      const cids = user && user.customIDs ? user.customIDs : {};
      const parts = [
        `uid:${(_a = user === null || user === void 0 ? void 0 : user.userID) !== null && _a !== void 0 ? _a : ""}`,
        `cids:${Object.keys(cids).sort((leftKey, rightKey) => leftKey.localeCompare(rightKey)).map((key) => `${key}-${cids[key]}`).join(",")}`,
        `k:${sdkKey}`
      ];
      return (0, Hashing_1._DJB2)(parts.join("|"));
    }
    exports._getUserStorageKey = _getUserStorageKey;
    function _getStorageKey2(sdkKey, user, customKeyGenerator) {
      if (user) {
        return _getUserStorageKey(sdkKey, user, customKeyGenerator);
      }
      return (0, Hashing_1._DJB2)(`k:${sdkKey}`);
    }
    exports._getStorageKey = _getStorageKey2;
  }
});

// node_modules/@statsig/client-core/src/NetworkConfig.js
var require_NetworkConfig = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkParam = exports.NetworkDefault = exports.Endpoint = void 0;
    exports.Endpoint = {
      _initialize: "initialize",
      _rgstr: "rgstr",
      _download_config_specs: "download_config_specs"
    };
    exports.NetworkDefault = {
      [exports.Endpoint._rgstr]: "https://prodregistryv2.org/v1",
      [exports.Endpoint._initialize]: "https://featureassets.org/v1",
      [exports.Endpoint._download_config_specs]: "https://api.statsigcdn.com/v1"
    };
    exports.NetworkParam = {
      EventCount: "ec",
      SdkKey: "k",
      SdkType: "st",
      SdkVersion: "sv",
      Time: "t",
      SessionID: "sid",
      StatsigEncoded: "se",
      IsGzipped: "gz"
    };
  }
});

// node_modules/@statsig/client-core/src/SafeJs.js
var require_SafeJs = __commonJS({
  "node_modules/@statsig/client-core/src/SafeJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getUnloadEvent = exports._getCurrentPageUrlSafe = exports._addDocumentEventListenerSafe = exports._addWindowEventListenerSafe = exports._isServerEnv = exports._getDocumentSafe = exports._getWindowSafe = void 0;
    var _getWindowSafe = () => {
      return typeof window !== "undefined" ? window : null;
    };
    exports._getWindowSafe = _getWindowSafe;
    var _getDocumentSafe = () => {
      var _a;
      const win = (0, exports._getWindowSafe)();
      return (_a = win === null || win === void 0 ? void 0 : win.document) !== null && _a !== void 0 ? _a : null;
    };
    exports._getDocumentSafe = _getDocumentSafe;
    var _isServerEnv = () => {
      if ((0, exports._getDocumentSafe)() !== null) {
        return false;
      }
      const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      const isVercel = typeof EdgeRuntime === "string";
      return isVercel || isNode;
    };
    exports._isServerEnv = _isServerEnv;
    var _addWindowEventListenerSafe = (key, listener) => {
      const win = (0, exports._getWindowSafe)();
      if (typeof (win === null || win === void 0 ? void 0 : win.addEventListener) === "function") {
        win.addEventListener(key, listener);
      }
    };
    exports._addWindowEventListenerSafe = _addWindowEventListenerSafe;
    var _addDocumentEventListenerSafe = (key, listener) => {
      const doc = (0, exports._getDocumentSafe)();
      if (typeof (doc === null || doc === void 0 ? void 0 : doc.addEventListener) === "function") {
        doc.addEventListener(key, listener);
      }
    };
    exports._addDocumentEventListenerSafe = _addDocumentEventListenerSafe;
    var _getCurrentPageUrlSafe = () => {
      var _a;
      try {
        return (_a = (0, exports._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.location.href.split(/[?#]/)[0];
      } catch (_b) {
        return;
      }
    };
    exports._getCurrentPageUrlSafe = _getCurrentPageUrlSafe;
    var _getUnloadEvent = () => {
      const win = (0, exports._getWindowSafe)();
      if (!win) {
        return "beforeunload";
      }
      const eventType = "onpagehide" in win ? "pagehide" : "beforeunload";
      return eventType;
    };
    exports._getUnloadEvent = _getUnloadEvent;
  }
});

// node_modules/@statsig/client-core/src/StatsigEvent.js
var require_StatsigEvent = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._createLayerParameterExposure = exports._createConfigExposure = exports._mapExposures = exports._createGateExposure = exports._isExposureEvent = void 0;
    var CONFIG_EXPOSURE_NAME = "statsig::config_exposure";
    var GATE_EXPOSURE_NAME = "statsig::gate_exposure";
    var LAYER_EXPOSURE_NAME = "statsig::layer_exposure";
    var _createExposure = (eventName, user, details, metadata, secondaryExposures) => {
      if (details.bootstrapMetadata) {
        metadata["bootstrapMetadata"] = details.bootstrapMetadata;
      }
      return {
        eventName,
        user,
        value: null,
        metadata: _addEvaluationDetailsToMetadata(details, metadata),
        secondaryExposures,
        time: Date.now()
      };
    };
    var _isExposureEvent = ({ eventName }) => {
      return eventName === GATE_EXPOSURE_NAME || eventName === CONFIG_EXPOSURE_NAME || eventName === LAYER_EXPOSURE_NAME;
    };
    exports._isExposureEvent = _isExposureEvent;
    var _createGateExposure = (user, gate, exposureMapping) => {
      var _a, _b, _c;
      const metadata = {
        gate: gate.name,
        gateValue: String(gate.value),
        ruleID: gate.ruleID
      };
      if (((_a = gate.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = gate.__evaluation.version;
      }
      return _createExposure(GATE_EXPOSURE_NAME, user, gate.details, metadata, _mapExposures((_c = (_b = gate.__evaluation) === null || _b === void 0 ? void 0 : _b.secondary_exposures) !== null && _c !== void 0 ? _c : [], exposureMapping));
    };
    exports._createGateExposure = _createGateExposure;
    function _mapExposures(exposures, exposureMapping) {
      return exposures.map((exposure) => {
        if (typeof exposure === "string") {
          return (exposureMapping !== null && exposureMapping !== void 0 ? exposureMapping : {})[exposure];
        }
        return exposure;
      }).filter((exposure) => exposure != null);
    }
    exports._mapExposures = _mapExposures;
    var _createConfigExposure = (user, config, exposureMapping) => {
      var _a, _b, _c, _d;
      const metadata = {
        config: config.name,
        ruleID: config.ruleID
      };
      if (((_a = config.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = config.__evaluation.version;
      }
      if (((_b = config.__evaluation) === null || _b === void 0 ? void 0 : _b.passed) != null) {
        metadata["rulePassed"] = String(config.__evaluation.passed);
      }
      return _createExposure(CONFIG_EXPOSURE_NAME, user, config.details, metadata, _mapExposures((_d = (_c = config.__evaluation) === null || _c === void 0 ? void 0 : _c.secondary_exposures) !== null && _d !== void 0 ? _d : [], exposureMapping));
    };
    exports._createConfigExposure = _createConfigExposure;
    var _createLayerParameterExposure = (user, layer, parameterName, exposureMapping) => {
      var _a, _b, _c, _d;
      const evaluation = layer.__evaluation;
      const isExplicit = ((_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.explicit_parameters) === null || _a === void 0 ? void 0 : _a.includes(parameterName)) === true;
      let allocatedExperiment = "";
      let secondaryExposures = (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.undelegated_secondary_exposures) !== null && _b !== void 0 ? _b : [];
      if (isExplicit) {
        allocatedExperiment = (_c = evaluation.allocated_experiment_name) !== null && _c !== void 0 ? _c : "";
        secondaryExposures = evaluation.secondary_exposures;
      }
      const metadata = {
        config: layer.name,
        parameterName,
        ruleID: layer.ruleID,
        allocatedExperiment,
        isExplicitParameter: String(isExplicit)
      };
      if (((_d = layer.__evaluation) === null || _d === void 0 ? void 0 : _d.version) != null) {
        metadata["configVersion"] = layer.__evaluation.version;
      }
      return _createExposure(LAYER_EXPOSURE_NAME, user, layer.details, metadata, _mapExposures(secondaryExposures, exposureMapping));
    };
    exports._createLayerParameterExposure = _createLayerParameterExposure;
    var _addEvaluationDetailsToMetadata = (details, metadata) => {
      metadata["reason"] = details.reason;
      if (details.lcut) {
        metadata["lcut"] = String(details.lcut);
      }
      if (details.receivedAt) {
        metadata["receivedAt"] = String(details.receivedAt);
      }
      return metadata;
    };
  }
});

// node_modules/@statsig/client-core/src/StorageProvider.js
var require_StorageProvider = __commonJS({
  "node_modules/@statsig/client-core/src/StorageProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._setObjectInStorage = exports._getObjectFromStorage = exports.Storage = void 0;
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var inMemoryStore = {};
    var _inMemoryProvider = {
      isReady: () => true,
      isReadyResolver: () => null,
      getProviderName: () => "InMemory",
      getItem: (key) => inMemoryStore[key] ? inMemoryStore[key] : null,
      setItem: (key, value) => {
        inMemoryStore[key] = value;
      },
      removeItem: (key) => {
        delete inMemoryStore[key];
      },
      getAllKeys: () => Object.keys(inMemoryStore)
    };
    var _localStorageProvider = null;
    try {
      const win = (0, SafeJs_1._getWindowSafe)();
      if (win && win.localStorage && typeof win.localStorage.getItem === "function") {
        _localStorageProvider = {
          isReady: () => true,
          isReadyResolver: () => null,
          getProviderName: () => "LocalStorage",
          getItem: (key) => win.localStorage.getItem(key),
          setItem: (key, value) => win.localStorage.setItem(key, value),
          removeItem: (key) => win.localStorage.removeItem(key),
          getAllKeys: () => Object.keys(win.localStorage)
        };
      }
    } catch (error) {
      Log_1.Log.warn("Failed to setup localStorageProvider.");
    }
    var _main = _localStorageProvider !== null && _localStorageProvider !== void 0 ? _localStorageProvider : _inMemoryProvider;
    var _current = _main;
    function _inMemoryBreaker(get) {
      try {
        return get();
      } catch (error) {
        if (error instanceof Error && error.name === "SecurityError") {
          exports.Storage._setProvider(_inMemoryProvider);
          return null;
        }
        throw error;
      }
    }
    exports.Storage = {
      isReady: () => _current.isReady(),
      isReadyResolver: () => _current.isReadyResolver(),
      getProviderName: () => _current.getProviderName(),
      getItem: (key) => _inMemoryBreaker(() => _current.getItem(key)),
      setItem: (key, value) => _current.setItem(key, value),
      removeItem: (key) => _current.removeItem(key),
      getAllKeys: () => _current.getAllKeys(),
      // StorageProviderManagment
      _setProvider: (newProvider) => {
        _main = newProvider;
        _current = newProvider;
      },
      _setDisabled: (isDisabled) => {
        if (isDisabled) {
          _current = _inMemoryProvider;
        } else {
          _current = _main;
        }
      }
    };
    function _getObjectFromStorage(key) {
      const value = exports.Storage.getItem(key);
      return JSON.parse(value !== null && value !== void 0 ? value : "null");
    }
    exports._getObjectFromStorage = _getObjectFromStorage;
    function _setObjectInStorage(key, obj) {
      exports.Storage.setItem(key, JSON.stringify(obj));
    }
    exports._setObjectInStorage = _setObjectInStorage;
  }
});

// node_modules/@statsig/client-core/src/UrlConfiguration.js
var require_UrlConfiguration = __commonJS({
  "node_modules/@statsig/client-core/src/UrlConfiguration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlConfiguration = void 0;
    var Hashing_1 = require_Hashing();
    var NetworkConfig_1 = require_NetworkConfig();
    var ENDPOINT_DNS_KEY_MAP = {
      [NetworkConfig_1.Endpoint._initialize]: "i",
      [NetworkConfig_1.Endpoint._rgstr]: "e",
      [NetworkConfig_1.Endpoint._download_config_specs]: "d"
    };
    var UrlConfiguration = class {
      constructor(endpoint, customUrl, customApi, fallbackUrls) {
        this.customUrl = null;
        this.fallbackUrls = null;
        this.endpoint = endpoint;
        this.endpointDnsKey = ENDPOINT_DNS_KEY_MAP[endpoint];
        if (customUrl) {
          this.customUrl = customUrl;
        }
        if (!customUrl && customApi) {
          this.customUrl = customApi.endsWith("/") ? `${customApi}${endpoint}` : `${customApi}/${endpoint}`;
        }
        if (fallbackUrls) {
          this.fallbackUrls = fallbackUrls;
        }
        const defaultApi = NetworkConfig_1.NetworkDefault[endpoint];
        this.defaultUrl = `${defaultApi}/${endpoint}`;
      }
      getUrl() {
        var _a;
        return (_a = this.customUrl) !== null && _a !== void 0 ? _a : this.defaultUrl;
      }
      getChecksum() {
        var _a;
        const fallbacks = ((_a = this.fallbackUrls) !== null && _a !== void 0 ? _a : []).sort().join(",");
        return (0, Hashing_1._DJB2)(this.customUrl + fallbacks);
      }
    };
    exports.UrlConfiguration = UrlConfiguration;
  }
});

// node_modules/@statsig/client-core/src/VisibilityObserving.js
var require_VisibilityObserving = __commonJS({
  "node_modules/@statsig/client-core/src/VisibilityObserving.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._notifyVisibilityChanged = exports._subscribeToVisiblityChanged = exports._isUnloading = exports._isCurrentlyVisible = void 0;
    var SafeJs_1 = require_SafeJs();
    var FOREGROUND = "foreground";
    var BACKGROUND = "background";
    var LISTENERS = [];
    var current = FOREGROUND;
    var isUnloading = false;
    var _isCurrentlyVisible = () => {
      return current === FOREGROUND;
    };
    exports._isCurrentlyVisible = _isCurrentlyVisible;
    var _isUnloading = () => isUnloading;
    exports._isUnloading = _isUnloading;
    var _subscribeToVisiblityChanged = (listener) => {
      LISTENERS.unshift(listener);
    };
    exports._subscribeToVisiblityChanged = _subscribeToVisiblityChanged;
    var _notifyVisibilityChanged = (visibility) => {
      if (visibility === current) {
        return;
      }
      current = visibility;
      LISTENERS.forEach((l) => l(visibility));
    };
    exports._notifyVisibilityChanged = _notifyVisibilityChanged;
    (0, SafeJs_1._addWindowEventListenerSafe)("focus", () => {
      isUnloading = false;
      (0, exports._notifyVisibilityChanged)(FOREGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)("blur", () => (0, exports._notifyVisibilityChanged)(BACKGROUND));
    (0, SafeJs_1._addDocumentEventListenerSafe)("visibilitychange", () => {
      (0, exports._notifyVisibilityChanged)(document.visibilityState === "visible" ? FOREGROUND : BACKGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)((0, SafeJs_1._getUnloadEvent)(), () => {
      isUnloading = true;
      (0, exports._notifyVisibilityChanged)(BACKGROUND);
    });
  }
});

// node_modules/@statsig/client-core/src/EventLogger.js
var require_EventLogger = __commonJS({
  "node_modules/@statsig/client-core/src/EventLogger.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventLogger = void 0;
    var CacheKey_1 = require_CacheKey();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var SafeJs_1 = require_SafeJs();
    var StatsigEvent_1 = require_StatsigEvent();
    var StorageProvider_1 = require_StorageProvider();
    var UrlConfiguration_1 = require_UrlConfiguration();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_QUEUE_SIZE = 100;
    var DEFAULT_FLUSH_INTERVAL_MS = 1e4;
    var MAX_DEDUPER_KEYS = 1e3;
    var DEDUPER_WINDOW_DURATION_MS = 6e5;
    var MAX_FAILED_LOGS = 500;
    var QUICK_FLUSH_WINDOW_MS = 200;
    var EVENT_LOGGER_MAP = {};
    var RetryFailedLogsTrigger = {
      Startup: "startup",
      GainedFocus: "gained_focus"
    };
    var EventLogger = class _EventLogger {
      static _safeFlushAndForget(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {
        });
      }
      static _safeRetryFailedLogs(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);
      }
      constructor(_sdkKey, _emitter, _network, _options) {
        var _a;
        this._sdkKey = _sdkKey;
        this._emitter = _emitter;
        this._network = _network;
        this._options = _options;
        this._queue = [];
        this._lastExposureTimeMap = {};
        this._nonExposedChecks = {};
        this._hasRunQuickFlush = false;
        this._creationTime = Date.now();
        this._isLoggingDisabled = (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true;
        this._maxQueueSize = (_a = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _a !== void 0 ? _a : DEFAULT_QUEUE_SIZE;
        const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;
        this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);
      }
      setLoggingDisabled(isDisabled) {
        this._isLoggingDisabled = isDisabled;
      }
      enqueue(event) {
        if (!this._shouldLogEvent(event)) {
          return;
        }
        this._normalizeAndAppendEvent(event);
        this._quickFlushIfNeeded();
        if (this._queue.length > this._maxQueueSize) {
          _EventLogger._safeFlushAndForget(this._sdkKey);
        }
      }
      incrementNonExposureCount(name) {
        var _a;
        const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;
        this._nonExposedChecks[name] = current + 1;
      }
      reset() {
        this._lastExposureTimeMap = {};
      }
      start() {
        if ((0, SafeJs_1._isServerEnv)()) {
          return;
        }
        EVENT_LOGGER_MAP[this._sdkKey] = this;
        (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {
          if (visibility === "background") {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          } else if (visibility === "foreground") {
            _EventLogger._safeRetryFailedLogs(this._sdkKey);
          }
        });
        this._retryFailedLogs(RetryFailedLogsTrigger.Startup);
        this._startBackgroundFlushInterval();
      }
      stop() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._flushIntervalId) {
            clearInterval(this._flushIntervalId);
            this._flushIntervalId = null;
          }
          delete EVENT_LOGGER_MAP[this._sdkKey];
          yield this.flush();
        });
      }
      flush() {
        return __awaiter(this, void 0, void 0, function* () {
          this._appendAndResetNonExposedChecks();
          if (this._queue.length === 0) {
            return;
          }
          const events = this._queue;
          this._queue = [];
          yield this._sendEvents(events);
        });
      }
      /**
       * We 'Quick Flush' following the very first event enqueued
       * within the quick flush window
       */
      _quickFlushIfNeeded() {
        if (this._hasRunQuickFlush) {
          return;
        }
        this._hasRunQuickFlush = true;
        if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {
          return;
        }
        setTimeout(() => _EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);
      }
      _shouldLogEvent(event) {
        if ((0, SafeJs_1._isServerEnv)()) {
          return false;
        }
        if (!(0, StatsigEvent_1._isExposureEvent)(event)) {
          return true;
        }
        const user = event.user ? event.user : { statsigEnvironment: void 0 };
        const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);
        const metadata = event.metadata ? event.metadata : {};
        const key = [
          event.eventName,
          userKey,
          metadata["gate"],
          metadata["config"],
          metadata["ruleID"],
          metadata["allocatedExperiment"],
          metadata["parameterName"],
          String(metadata["isExplicitParameter"]),
          metadata["reason"]
        ].join("|");
        const previous = this._lastExposureTimeMap[key];
        const now = Date.now();
        if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {
          return false;
        }
        if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {
          this._lastExposureTimeMap = {};
        }
        this._lastExposureTimeMap[key] = now;
        return true;
      }
      _sendEvents(events) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (this._isLoggingDisabled) {
            this._saveFailedLogsToStorage(events);
            return false;
          }
          try {
            const isClosing = (0, VisibilityObserving_1._isUnloading)();
            const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;
            this._emitter({
              name: "pre_logs_flushed",
              events
            });
            const response = shouldUseBeacon ? yield this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);
            if (response.success) {
              this._emitter({
                name: "logs_flushed",
                events
              });
              return true;
            } else {
              Log_1.Log.warn("Failed to flush events.");
              this._saveFailedLogsToStorage(events);
              return false;
            }
          } catch (_c) {
            Log_1.Log.warn("Failed to flush events.");
            return false;
          }
        });
      }
      _sendEventsViaPost(events) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this._network.post(this._getRequestData(events));
          const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;
          return { success: code >= 200 && code < 300 };
        });
      }
      _sendEventsViaBeacon(events) {
        return __awaiter(this, void 0, void 0, function* () {
          return {
            success: yield this._network.beacon(this._getRequestData(events))
          };
        });
      }
      _getRequestData(events) {
        return {
          sdkKey: this._sdkKey,
          data: {
            events
          },
          urlConfig: this._logEventUrlConfig,
          retries: 3,
          isCompressable: true,
          params: {
            [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)
          },
          credentials: "same-origin"
        };
      }
      _saveFailedLogsToStorage(events) {
        while (events.length > MAX_FAILED_LOGS) {
          events.shift();
        }
        const storageKey = this._getStorageKey();
        try {
          (0, StorageProvider_1._setObjectInStorage)(storageKey, events);
        } catch (_a) {
          Log_1.Log.warn("Unable to save failed logs to storage");
        }
      }
      _retryFailedLogs(trigger) {
        const storageKey = this._getStorageKey();
        (() => __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (!events) {
            return;
          }
          if (trigger === RetryFailedLogsTrigger.Startup) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
          const isSuccess = yield this._sendEvents(events);
          if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
        }))().catch(() => {
          Log_1.Log.warn("Failed to flush stored logs");
        });
      }
      _getStorageKey() {
        return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;
      }
      _normalizeAndAppendEvent(event) {
        if (event.user) {
          event.user = Object.assign({}, event.user);
          delete event.user.privateAttributes;
        }
        const extras = {};
        const currentPage = this._getCurrentPageUrl();
        if (currentPage) {
          extras.statsigMetadata = { currentPage };
        }
        const final = Object.assign(Object.assign({}, event), extras);
        Log_1.Log.debug("Enqueued Event:", final);
        this._queue.push(final);
      }
      _appendAndResetNonExposedChecks() {
        if (Object.keys(this._nonExposedChecks).length === 0) {
          return;
        }
        this._normalizeAndAppendEvent({
          eventName: "statsig::non_exposed_checks",
          user: null,
          time: Date.now(),
          metadata: {
            checks: Object.assign({}, this._nonExposedChecks)
          }
        });
        this._nonExposedChecks = {};
      }
      _getCurrentPageUrl() {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {
          return;
        }
        return (0, SafeJs_1._getCurrentPageUrlSafe)();
      }
      _startBackgroundFlushInterval() {
        var _a, _b;
        const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;
        const intervalId = setInterval(() => {
          const logger = EVENT_LOGGER_MAP[this._sdkKey];
          if (!logger || logger._flushIntervalId !== intervalId) {
            clearInterval(intervalId);
          } else {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          }
        }, flushInterval);
        this._flushIntervalId = intervalId;
      }
    };
    exports.EventLogger = EventLogger;
  }
});

// node_modules/@statsig/client-core/src/StatsigMetadata.js
var require_StatsigMetadata = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigMetadataProvider = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "3.15.4";
    var metadata = {
      sdkVersion: exports.SDK_VERSION,
      sdkType: "js-mono"
      // js-mono is overwritten by Precomp and OnDevice clients
    };
    exports.StatsigMetadataProvider = {
      get: () => metadata,
      add: (additions) => {
        metadata = Object.assign(Object.assign({}, metadata), additions);
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ClientInterfaces.js
var require_ClientInterfaces = __commonJS({
  "node_modules/@statsig/client-core/src/ClientInterfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/UUID.js
var require_UUID = __commonJS({
  "node_modules/@statsig/client-core/src/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUUID = void 0;
    function getUUID() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      let d = (/* @__PURE__ */ new Date()).getTime();
      let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
      const y = "89ab"[Math.floor(Math.random() * 4)];
      return `xxxxxxxx-xxxx-4xxx-${y}xxx-xxxxxxxxxxxx`.replace(/[xy]/g, (c) => {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 7 | 8).toString(16);
      });
    }
    exports.getUUID = getUUID;
  }
});

// node_modules/@statsig/client-core/src/StableID.js
var require_StableID = __commonJS({
  "node_modules/@statsig/client-core/src/StableID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StableID = void 0;
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var PROMISE_MAP = {};
    var COOKIE_ENABLED_MAP = {};
    var DISABLED_MAP = {};
    exports.StableID = {
      cookiesEnabled: false,
      randomID: Math.random().toString(36),
      get: (sdkKey) => {
        if (DISABLED_MAP[sdkKey]) {
          return null;
        }
        if (PROMISE_MAP[sdkKey] != null) {
          return PROMISE_MAP[sdkKey];
        }
        let stableID = null;
        stableID = _loadFromCookie(sdkKey);
        if (stableID != null) {
          PROMISE_MAP[sdkKey] = stableID;
          _persistToStorage(stableID, sdkKey);
          return stableID;
        }
        stableID = _loadFromStorage(sdkKey);
        if (stableID == null) {
          stableID = (0, UUID_1.getUUID)();
        }
        _persistToStorage(stableID, sdkKey);
        _persistToCookie(stableID, sdkKey);
        PROMISE_MAP[sdkKey] = stableID;
        return stableID;
      },
      setOverride: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = override;
        _persistToStorage(override, sdkKey);
        _persistToCookie(override, sdkKey);
      },
      _setCookiesEnabled: (sdkKey, cookiesEnabled) => {
        COOKIE_ENABLED_MAP[sdkKey] = cookiesEnabled;
      },
      _setDisabled: (sdkKey, disabled) => {
        DISABLED_MAP[sdkKey] = disabled;
      }
    };
    function _getStableIDStorageKey(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(stableID, sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, stableID);
      } catch (e) {
        Log_1.Log.warn("Failed to save StableID to storage");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
    function _loadFromCookie(sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return null;
      }
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [key, value] = cookie.trim().split("=");
        if (key === _getCookieName(sdkKey)) {
          return decodeURIComponent(value);
        }
      }
      return null;
    }
    function _persistToCookie(stableID, sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || !document) {
        return;
      }
      const expiryDate = /* @__PURE__ */ new Date();
      expiryDate.setFullYear(expiryDate.getFullYear() + 1);
      document.cookie = `${_getCookieName(sdkKey)}=${encodeURIComponent(stableID)}; expires=${expiryDate.toUTCString()}; path=/`;
    }
    function _getCookieName(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigUser.js
var require_StatsigUser = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getFullUserHash = exports._normalizeUser = void 0;
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    function _normalizeUser(original, options, fallbackEnvironment) {
      try {
        const copy = JSON.parse(JSON.stringify(original));
        if (options != null && options.environment != null) {
          copy.statsigEnvironment = options.environment;
        } else if (fallbackEnvironment != null) {
          copy.statsigEnvironment = { tier: fallbackEnvironment };
        }
        return copy;
      } catch (error) {
        Log_1.Log.error("Failed to JSON.stringify user");
        return { statsigEnvironment: void 0 };
      }
    }
    exports._normalizeUser = _normalizeUser;
    function _getFullUserHash2(user) {
      return user ? (0, Hashing_1._DJB2Object)(user) : null;
    }
    exports._getFullUserHash = _getFullUserHash2;
  }
});

// node_modules/@statsig/client-core/src/TypedJsonParse.js
var require_TypedJsonParse = __commonJS({
  "node_modules/@statsig/client-core/src/TypedJsonParse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._typedJsonParse = void 0;
    var Log_1 = require_Log();
    function _typedJsonParse(data, guard, typeName) {
      try {
        const result = JSON.parse(data);
        if (result && typeof result === "object" && guard in result) {
          return result;
        }
      } catch (_a) {
      }
      Log_1.Log.error(`Failed to parse ${typeName}`);
      return null;
    }
    exports._typedJsonParse = _typedJsonParse;
  }
});

// node_modules/@statsig/client-core/src/DataAdapterCore.js
var require_DataAdapterCore = __commonJS({
  "node_modules/@statsig/client-core/src/DataAdapterCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeDataAdapterResult = exports.DataAdapterCore = void 0;
    var Log_1 = require_Log();
    var StableID_1 = require_StableID();
    var StatsigUser_1 = require_StatsigUser();
    var StorageProvider_1 = require_StorageProvider();
    var TypedJsonParse_1 = require_TypedJsonParse();
    var CACHE_LIMIT = 10;
    var DataAdapterCore2 = class {
      constructor(_adapterName, _cacheSuffix) {
        this._adapterName = _adapterName;
        this._cacheSuffix = _cacheSuffix;
        this._options = null;
        this._sdkKey = null;
        this._lastModifiedStoreKey = `statsig.last_modified_time.${_cacheSuffix}`;
        this._inMemoryCache = new InMemoryCache();
      }
      attach(sdkKey, options, _network) {
        this._sdkKey = sdkKey;
        this._options = options;
      }
      getDataSync(user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        const inMem = this._inMemoryCache.get(cacheKey, normalized);
        if (inMem) {
          return inMem;
        }
        const cache = this._loadFromCache(cacheKey);
        if (cache) {
          this._inMemoryCache.add(cacheKey, cache);
          return this._inMemoryCache.get(cacheKey, normalized);
        }
        return null;
      }
      setData(data, user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        this._inMemoryCache.add(cacheKey, _makeDataAdapterResult("Bootstrap", data, null, normalized));
      }
      _getDataAsyncImpl(current, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const cache = current !== null && current !== void 0 ? current : this.getDataSync(user);
          const ops = [this._fetchAndPrepFromNetwork(cache, user, options)];
          if (options === null || options === void 0 ? void 0 : options.timeoutMs) {
            ops.push(new Promise((r) => setTimeout(r, options.timeoutMs)).then(() => {
              Log_1.Log.debug("Fetching latest value timed out");
              return null;
            }));
          }
          return yield Promise.race(ops);
        });
      }
      _prefetchDataImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          const result = yield this._getDataAsyncImpl(null, normalized, options);
          if (result) {
            this._inMemoryCache.add(cacheKey, Object.assign(Object.assign({}, result), { source: "Prefetch" }));
          }
        });
      }
      _fetchAndPrepFromNetwork(cachedResult, user, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const cachedData = (_a = cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.data) !== null && _a !== void 0 ? _a : null;
          const isCacheValidFor204 = cachedResult != null && this._isCachedResultValidFor204(cachedResult, user);
          const latest = yield this._fetchFromNetwork(cachedData, user, options, isCacheValidFor204);
          if (!latest) {
            Log_1.Log.debug("No response returned for latest value");
            return null;
          }
          const response = (0, TypedJsonParse_1._typedJsonParse)(latest, "has_updates", "Response");
          const sdkKey = this._getSdkKey();
          const stableID = StableID_1.StableID.get(sdkKey);
          let result = null;
          if ((response === null || response === void 0 ? void 0 : response.has_updates) === true) {
            result = _makeDataAdapterResult("Network", latest, stableID, user);
          } else if (cachedData && (response === null || response === void 0 ? void 0 : response.has_updates) === false) {
            result = _makeDataAdapterResult("NetworkNotModified", cachedData, stableID, user);
          } else {
            return null;
          }
          const cacheKey = this._getCacheKey(user);
          this._inMemoryCache.add(cacheKey, result);
          this._writeToCache(cacheKey, result);
          return result;
        });
      }
      _getSdkKey() {
        if (this._sdkKey != null) {
          return this._sdkKey;
        }
        Log_1.Log.error(`${this._adapterName} is not attached to a Client`);
        return "";
      }
      _loadFromCache(cacheKey) {
        var _a;
        const cache = (_a = StorageProvider_1.Storage.getItem) === null || _a === void 0 ? void 0 : _a.call(StorageProvider_1.Storage, cacheKey);
        if (cache == null) {
          return null;
        }
        const result = (0, TypedJsonParse_1._typedJsonParse)(cache, "source", "Cached Result");
        return result ? Object.assign(Object.assign({}, result), { source: "Cache" }) : null;
      }
      _writeToCache(cacheKey, result) {
        StorageProvider_1.Storage.setItem(cacheKey, JSON.stringify(result));
        this._runLocalStorageCacheEviction(cacheKey);
      }
      _runLocalStorageCacheEviction(cacheKey) {
        var _a;
        const lastModifiedTimeMap = (_a = (0, StorageProvider_1._getObjectFromStorage)(this._lastModifiedStoreKey)) !== null && _a !== void 0 ? _a : {};
        lastModifiedTimeMap[cacheKey] = Date.now();
        const evictable = _getEvictableKey(lastModifiedTimeMap, CACHE_LIMIT);
        if (evictable) {
          delete lastModifiedTimeMap[evictable];
          StorageProvider_1.Storage.removeItem(evictable);
        }
        (0, StorageProvider_1._setObjectInStorage)(this._lastModifiedStoreKey, lastModifiedTimeMap);
      }
    };
    exports.DataAdapterCore = DataAdapterCore2;
    function _makeDataAdapterResult(source, data, stableID, user) {
      return {
        source,
        data,
        receivedAt: Date.now(),
        stableID,
        fullUserHash: (0, StatsigUser_1._getFullUserHash)(user)
      };
    }
    exports._makeDataAdapterResult = _makeDataAdapterResult;
    var InMemoryCache = class {
      constructor() {
        this._data = {};
      }
      get(cacheKey, user) {
        var _a;
        const result = this._data[cacheKey];
        const cached = result === null || result === void 0 ? void 0 : result.stableID;
        const provided = (_a = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (provided && cached && provided !== cached) {
          Log_1.Log.warn("'StatsigUser.customIDs.stableID' mismatch");
          return null;
        }
        return result;
      }
      add(cacheKey, value) {
        const oldest = _getEvictableKey(this._data, CACHE_LIMIT - 1);
        if (oldest) {
          delete this._data[oldest];
        }
        this._data[cacheKey] = value;
      }
      merge(values) {
        this._data = Object.assign(Object.assign({}, this._data), values);
      }
    };
    function _getEvictableKey(data, limit) {
      const keys = Object.keys(data);
      if (keys.length <= limit) {
        return null;
      }
      return keys.reduce((prevKey, currKey) => {
        const prev = data[prevKey];
        const current = data[currKey];
        if (typeof prev === "object" && typeof current === "object") {
          return current.receivedAt < prev.receivedAt ? currKey : prevKey;
        }
        return current < prev ? currKey : prevKey;
      });
    }
  }
});

// node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js
var require_DownloadConfigSpecsResponse = __commonJS({
  "node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SDKType.js
var require_SDKType = __commonJS({
  "node_modules/@statsig/client-core/src/SDKType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKType = void 0;
    var SDK_CLIENT = {};
    var suffix;
    exports.SDKType = {
      _get: (sdkKey) => {
        var _a;
        return ((_a = SDK_CLIENT[sdkKey]) !== null && _a !== void 0 ? _a : "js-mono") + (suffix !== null && suffix !== void 0 ? suffix : "");
      },
      _setClientType(sdkKey, client) {
        SDK_CLIENT[sdkKey] = client;
      },
      _setBindingType(binding) {
        if (!suffix || suffix === "-react") {
          suffix = "-" + binding;
        }
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ErrorBoundary.js
var require_ErrorBoundary = __commonJS({
  "node_modules/@statsig/client-core/src/ErrorBoundary.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorBoundary = exports.EXCEPTION_ENDPOINT = void 0;
    var Log_1 = require_Log();
    var SDKType_1 = require_SDKType();
    var StatsigMetadata_1 = require_StatsigMetadata();
    exports.EXCEPTION_ENDPOINT = "https://statsigapi.net/v1/sdk_exception";
    var UNKNOWN_ERROR = "[Statsig] UnknownError";
    var ErrorBoundary = class {
      constructor(_sdkKey, _options, _emitter, _lastSeenError) {
        this._sdkKey = _sdkKey;
        this._options = _options;
        this._emitter = _emitter;
        this._lastSeenError = _lastSeenError;
        this._seen = /* @__PURE__ */ new Set();
      }
      wrap(instance) {
        try {
          const obj = instance;
          _getAllInstanceMethodNames(obj).forEach((name) => {
            const original = obj[name];
            if ("$EB" in original) {
              return;
            }
            obj[name] = (...args) => {
              return this._capture(name, () => original.apply(instance, args));
            };
            obj[name].$EB = true;
          });
        } catch (err) {
          this._onError("eb:wrap", err);
        }
      }
      logError(tag, error) {
        this._onError(tag, error);
      }
      getLastSeenErrorAndReset() {
        const tempError = this._lastSeenError;
        this._lastSeenError = void 0;
        return tempError !== null && tempError !== void 0 ? tempError : null;
      }
      attachErrorIfNoneExists(error) {
        if (this._lastSeenError) {
          return;
        }
        this._lastSeenError = _resolveError(error);
      }
      _capture(tag, task) {
        try {
          const res = task();
          if (res && res instanceof Promise) {
            return res.catch((err) => this._onError(tag, err));
          }
          return res;
        } catch (error) {
          this._onError(tag, error);
          return null;
        }
      }
      _onError(tag, error) {
        try {
          Log_1.Log.warn(`Caught error in ${tag}`, { error });
          const impl = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const unwrapped = error ? error : Error(UNKNOWN_ERROR);
            const isError = unwrapped instanceof Error;
            const name = isError ? unwrapped.name : "No Name";
            const resolvedError = _resolveError(unwrapped);
            this._lastSeenError = resolvedError;
            if (this._seen.has(name)) {
              return;
            }
            this._seen.add(name);
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.preventAllNetworkTraffic) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag
              });
              return;
            }
            const sdkType = SDKType_1.SDKType._get(this._sdkKey);
            const statsigMetadata = StatsigMetadata_1.StatsigMetadataProvider.get();
            const info = isError ? unwrapped.stack : _getDescription(unwrapped);
            const body = Object.assign({ tag, exception: name, info, statsigOptions: _getStatsigOptionLoggingCopy(this._options) }, Object.assign(Object.assign({}, statsigMetadata), { sdkType }));
            const func = (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.networkOverrideFunc) !== null && _f !== void 0 ? _f : fetch;
            yield func(exports.EXCEPTION_ENDPOINT, {
              method: "POST",
              headers: {
                "STATSIG-API-KEY": this._sdkKey,
                "STATSIG-SDK-TYPE": String(sdkType),
                "STATSIG-SDK-VERSION": String(statsigMetadata.sdkVersion),
                "Content-Type": "application/json"
              },
              body: JSON.stringify(body)
            });
            (_g = this._emitter) === null || _g === void 0 ? void 0 : _g.call(this, {
              name: "error",
              error,
              tag
            });
          });
          impl().then(() => {
          }).catch(() => {
          });
        } catch (_error) {
        }
      }
    };
    exports.ErrorBoundary = ErrorBoundary;
    function _resolveError(error) {
      if (error instanceof Error) {
        return error;
      } else if (typeof error === "string") {
        return new Error(error);
      } else {
        return new Error("An unknown error occurred.");
      }
    }
    function _getDescription(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_a) {
        return UNKNOWN_ERROR;
      }
    }
    function _getAllInstanceMethodNames(instance) {
      const names = /* @__PURE__ */ new Set();
      let proto = Object.getPrototypeOf(instance);
      while (proto && proto !== Object.prototype) {
        Object.getOwnPropertyNames(proto).filter((prop) => typeof (proto === null || proto === void 0 ? void 0 : proto[prop]) === "function").forEach((name) => names.add(name));
        proto = Object.getPrototypeOf(proto);
      }
      return Array.from(names);
    }
    function _getStatsigOptionLoggingCopy(options) {
      if (!options) {
        return {};
      }
      const loggingCopy = {};
      Object.entries(options).forEach(([option, value]) => {
        const valueType = typeof value;
        switch (valueType) {
          case "number":
          case "bigint":
          case "boolean":
            loggingCopy[String(option)] = value;
            break;
          case "string":
            if (value.length < 50) {
              loggingCopy[String(option)] = value;
            } else {
              loggingCopy[String(option)] = "set";
            }
            break;
          case "object":
            if (option === "environment") {
              loggingCopy["environment"] = value;
            } else if (option === "networkConfig") {
              loggingCopy["networkConfig"] = value;
            } else {
              loggingCopy[String(option)] = value != null ? "set" : "unset";
            }
            break;
          default:
        }
      });
      return loggingCopy;
    }
  }
});

// node_modules/@statsig/client-core/src/EvaluationOptions.js
var require_EvaluationOptions = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/EvaluationTypes.js
var require_EvaluationTypes = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/InitializeResponse.js
var require_InitializeResponse = __commonJS({
  "node_modules/@statsig/client-core/src/InitializeResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/MemoKey.js
var require_MemoKey = __commonJS({
  "node_modules/@statsig/client-core/src/MemoKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoKey = exports.MemoPrefix = void 0;
    exports.MemoPrefix = {
      _gate: "g",
      _dynamicConfig: "c",
      _experiment: "e",
      _layer: "l",
      _paramStore: "p"
    };
    var EXIST_KEYS = /* @__PURE__ */ new Set([
      // Add keys that should be memoized based only on their existence, not their value
    ]);
    var DO_NOT_MEMO_KEYS = /* @__PURE__ */ new Set([
      // Add keys that if exist, should not be memoized
      "userPersistedValues"
    ]);
    function createMemoKey(prefix, name, options) {
      let cacheKey = `${prefix}|${name}`;
      if (!options) {
        return cacheKey;
      }
      for (const key of Object.keys(options)) {
        if (DO_NOT_MEMO_KEYS.has(key)) {
          return void 0;
        }
        if (EXIST_KEYS.has(key)) {
          cacheKey += `|${key}=true`;
        } else {
          cacheKey += `|${key}=${options[key]}`;
        }
      }
      return cacheKey;
    }
    exports.createMemoKey = createMemoKey;
  }
});

// node_modules/@statsig/client-core/src/DnsTxtQuery.js
var require_DnsTxtQuery = __commonJS({
  "node_modules/@statsig/client-core/src/DnsTxtQuery.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fetchTxtRecords = void 0;
    var FEATURE_ASSETS_DNS_QUERY = new Uint8Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      13,
      102,
      101,
      97,
      116,
      117,
      114,
      101,
      97,
      115,
      115,
      101,
      116,
      115,
      3,
      111,
      114,
      103,
      0,
      0,
      16,
      0,
      1
    ]);
    var DNS_QUERY_ENDPOINT = "https://cloudflare-dns.com/dns-query";
    var DOMAIN_CHARS = [
      "i",
      // initialize
      "e",
      // events
      "d"
      // dcs
    ];
    var MAX_START_LOOKUP = 200;
    function _fetchTxtRecords(networkFunc) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield networkFunc(DNS_QUERY_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/dns-message",
            Accept: "application/dns-message"
          },
          body: FEATURE_ASSETS_DNS_QUERY
        });
        if (!response.ok) {
          const err = new Error("Failed to fetch TXT records from DNS");
          err.name = "DnsTxtFetchError";
          throw err;
        }
        const data = yield response.arrayBuffer();
        const bytes = new Uint8Array(data);
        return _parseDnsResponse(bytes);
      });
    }
    exports._fetchTxtRecords = _fetchTxtRecords;
    function _parseDnsResponse(input) {
      const start = input.findIndex((byte, index) => index < MAX_START_LOOKUP && String.fromCharCode(byte) === "=" && DOMAIN_CHARS.includes(String.fromCharCode(input[index - 1])));
      if (start === -1) {
        const err = new Error("Failed to parse TXT records from DNS");
        err.name = "DnsTxtParseError";
        throw err;
      }
      let result = "";
      for (let i = start - 1; i < input.length; i++) {
        result += String.fromCharCode(input[i]);
      }
      return result.split(",");
    }
  }
});

// node_modules/@statsig/client-core/src/NetworkFallbackResolver.js
var require_NetworkFallbackResolver = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkFallbackResolver.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isDomainFailure = exports.NetworkFallbackResolver = void 0;
    var DnsTxtQuery_1 = require_DnsTxtQuery();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var DEFAULT_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
    var COOLDOWN_TIME_MS = 4 * 60 * 60 * 1e3;
    var NetworkFallbackResolver = class {
      constructor(options) {
        var _a;
        this._fallbackInfo = null;
        this._errorBoundary = null;
        this._dnsQueryCooldowns = {};
        this._networkOverrideFunc = (_a = options.networkConfig) === null || _a === void 0 ? void 0 : _a.networkOverrideFunc;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
      }
      tryBumpExpiryTime(sdkKey, urlConfig) {
        var _a;
        const info = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint];
        if (!info) {
          return;
        }
        info.expiryTime = Date.now() + DEFAULT_TTL_MS;
        _tryWriteFallbackInfoToCache(sdkKey, Object.assign(Object.assign({}, this._fallbackInfo), { [urlConfig.endpoint]: info }));
      }
      getActiveFallbackUrl(sdkKey, urlConfig) {
        var _a, _b;
        if (urlConfig.customUrl != null && urlConfig.fallbackUrls != null) {
          return null;
        }
        let info = this._fallbackInfo;
        if (info == null) {
          info = (_a = _readFallbackInfoFromCache(sdkKey)) !== null && _a !== void 0 ? _a : {};
          this._fallbackInfo = info;
        }
        const entry = info[urlConfig.endpoint];
        if (!entry || Date.now() > ((_b = entry.expiryTime) !== null && _b !== void 0 ? _b : 0) || urlConfig.getChecksum() !== entry.urlConfigChecksum) {
          delete info[urlConfig.endpoint];
          this._fallbackInfo = info;
          _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
          return null;
        }
        if (entry.url) {
          return entry.url;
        }
        return null;
      }
      tryFetchUpdatedFallbackInfo(sdkKey, urlConfig, errorMessage, timedOut) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!_isDomainFailure(errorMessage, timedOut)) {
              return false;
            }
            const canUseNetworkFallbacks = urlConfig.customUrl == null && urlConfig.fallbackUrls == null;
            const urls = canUseNetworkFallbacks ? yield this._tryFetchFallbackUrlsFromNetwork(urlConfig) : urlConfig.fallbackUrls;
            const newUrl = this._pickNewFallbackUrl((_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint], urls);
            if (!newUrl) {
              return false;
            }
            this._updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl);
            return true;
          } catch (error) {
            (_b = this._errorBoundary) === null || _b === void 0 ? void 0 : _b.logError("tryFetchUpdatedFallbackInfo", error);
            return false;
          }
        });
      }
      _updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl) {
        var _a, _b, _c;
        const newFallbackInfo = {
          urlConfigChecksum: urlConfig.getChecksum(),
          url: newUrl,
          expiryTime: Date.now() + DEFAULT_TTL_MS,
          previous: []
        };
        const endpoint = urlConfig.endpoint;
        const previousInfo = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[endpoint];
        if (previousInfo) {
          newFallbackInfo.previous.push(...previousInfo.previous);
        }
        if (newFallbackInfo.previous.length > 10) {
          newFallbackInfo.previous = [];
        }
        const previousUrl = (_c = (_b = this._fallbackInfo) === null || _b === void 0 ? void 0 : _b[endpoint]) === null || _c === void 0 ? void 0 : _c.url;
        if (previousUrl != null) {
          newFallbackInfo.previous.push(previousUrl);
        }
        this._fallbackInfo = Object.assign(Object.assign({}, this._fallbackInfo), { [endpoint]: newFallbackInfo });
        _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
      }
      _tryFetchFallbackUrlsFromNetwork(urlConfig) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const cooldown = this._dnsQueryCooldowns[urlConfig.endpoint];
          if (cooldown && Date.now() < cooldown) {
            return null;
          }
          this._dnsQueryCooldowns[urlConfig.endpoint] = Date.now() + COOLDOWN_TIME_MS;
          const result = [];
          const records = yield (0, DnsTxtQuery_1._fetchTxtRecords)((_a = this._networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch);
          const path = _extractPathFromUrl(urlConfig.defaultUrl);
          for (const record of records) {
            if (!record.startsWith(urlConfig.endpointDnsKey + "=")) {
              continue;
            }
            const parts = record.split("=");
            if (parts.length > 1) {
              let baseUrl = parts[1];
              if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
              }
              result.push(`https://${baseUrl}${path}`);
            }
          }
          return result;
        });
      }
      _pickNewFallbackUrl(currentFallbackInfo, urls) {
        var _a;
        if (urls == null) {
          return null;
        }
        const previouslyUsed = new Set((_a = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.previous) !== null && _a !== void 0 ? _a : []);
        const currentFallbackUrl = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.url;
        let found = null;
        for (const loopUrl of urls) {
          const url = loopUrl.endsWith("/") ? loopUrl.slice(0, -1) : loopUrl;
          if (!previouslyUsed.has(loopUrl) && url !== currentFallbackUrl) {
            found = url;
            break;
          }
        }
        return found;
      }
    };
    exports.NetworkFallbackResolver = NetworkFallbackResolver;
    function _isDomainFailure(errorMsg, timedOut) {
      var _a;
      const lowerErrorMsg = (_a = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.toLowerCase()) !== null && _a !== void 0 ? _a : "";
      return timedOut || lowerErrorMsg.includes("uncaught exception") || lowerErrorMsg.includes("failed to fetch") || lowerErrorMsg.includes("networkerror when attempting to fetch resource");
    }
    exports._isDomainFailure = _isDomainFailure;
    function _getFallbackInfoStorageKey(sdkKey) {
      return `statsig.network_fallback.${(0, Hashing_1._DJB2)(sdkKey)}`;
    }
    function _tryWriteFallbackInfoToCache(sdkKey, info) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      if (!info || Object.keys(info).length === 0) {
        StorageProvider_1.Storage.removeItem(hashKey);
        return;
      }
      StorageProvider_1.Storage.setItem(hashKey, JSON.stringify(info));
    }
    function _readFallbackInfoFromCache(sdkKey) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      const data = StorageProvider_1.Storage.getItem(hashKey);
      if (!data) {
        return null;
      }
      try {
        return JSON.parse(data);
      } catch (_a) {
        Log_1.Log.error("Failed to parse FallbackInfo");
        return null;
      }
    }
    function _extractPathFromUrl(urlString) {
      try {
        const url = new URL(urlString);
        return url.pathname;
      } catch (error) {
        return null;
      }
    }
  }
});

// node_modules/@statsig/client-core/src/SDKFlags.js
var require_SDKFlags = __commonJS({
  "node_modules/@statsig/client-core/src/SDKFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKFlags = void 0;
    var FLAGMAP = {};
    exports.SDKFlags = {
      setFlags: (sdkKey, flags) => {
        FLAGMAP[sdkKey] = flags;
      },
      get: (sdkKey, flagKey) => {
        var _a, _b;
        return (_b = (_a = FLAGMAP[sdkKey]) === null || _a === void 0 ? void 0 : _a[flagKey]) !== null && _b !== void 0 ? _b : false;
      }
    };
  }
});

// node_modules/@statsig/client-core/src/SessionID.js
var require_SessionID = __commonJS({
  "node_modules/@statsig/client-core/src/SessionID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigSession = exports.SessionID = void 0;
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var MAX_SESSION_IDLE_TIME = 30 * 60 * 1e3;
    var MAX_SESSION_AGE = 4 * 60 * 60 * 1e3;
    var PROMISE_MAP = {};
    exports.SessionID = {
      get: (sdkKey) => {
        return exports.StatsigSession.get(sdkKey).data.sessionID;
      }
    };
    exports.StatsigSession = {
      get: (sdkKey) => {
        if (PROMISE_MAP[sdkKey] == null) {
          PROMISE_MAP[sdkKey] = _loadSession(sdkKey);
        }
        const session = PROMISE_MAP[sdkKey];
        return _bumpSession(session);
      },
      overrideInitialSessionID: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = _overrideSessionId(override, sdkKey);
      }
    };
    function _loadSession(sdkKey) {
      let data = _loadFromStorage(sdkKey);
      const now = Date.now();
      if (!data) {
        data = {
          sessionID: (0, UUID_1.getUUID)(),
          startTime: now,
          lastUpdate: now
        };
      }
      return {
        data,
        sdkKey
      };
    }
    function _overrideSessionId(override, sdkKey) {
      const now = Date.now();
      return {
        data: {
          sessionID: override,
          startTime: now,
          lastUpdate: now
        },
        sdkKey
      };
    }
    function _bumpSession(session) {
      const now = Date.now();
      const data = session.data;
      const sdkKey = session.sdkKey;
      if (_isIdle(data) || _hasRunTooLong(data)) {
        data.sessionID = (0, UUID_1.getUUID)();
        data.startTime = now;
        const client = __STATSIG__ === null || __STATSIG__ === void 0 ? void 0 : __STATSIG__.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }
      data.lastUpdate = now;
      _persistToStorage(data, session.sdkKey);
      clearTimeout(session.idleTimeoutID);
      clearTimeout(session.ageTimeoutID);
      const lifetime = now - data.startTime;
      session.idleTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_IDLE_TIME);
      session.ageTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_AGE - lifetime);
      return session;
    }
    function _createSessionTimeout(sdkKey, duration) {
      return setTimeout(() => {
        var _a;
        const client = (_a = (0, __StatsigGlobal_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }, duration);
    }
    function _isIdle({ lastUpdate }) {
      return Date.now() - lastUpdate > MAX_SESSION_IDLE_TIME;
    }
    function _hasRunTooLong({ startTime }) {
      return Date.now() - startTime > MAX_SESSION_AGE;
    }
    function _getSessionIDStorageKey(sdkKey) {
      return `statsig.session_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(session, sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, session);
      } catch (e) {
        Log_1.Log.warn("Failed to save SessionID");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js
var require_StatsigClientEventEmitter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorTag = void 0;
    exports.ErrorTag = {
      NetworkError: "NetworkError"
    };
  }
});

// node_modules/@statsig/client-core/src/NetworkCore.js
var require_NetworkCore = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkCore = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var NetworkFallbackResolver_1 = require_NetworkFallbackResolver();
    var SDKFlags_1 = require_SDKFlags();
    var SDKType_1 = require_SDKType();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigClientEventEmitter_1 = require_StatsigClientEventEmitter();
    var StatsigMetadata_1 = require_StatsigMetadata();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_TIMEOUT_MS = 1e4;
    var BACKOFF_BASE_MS = 500;
    var BACKOFF_MAX_MS = 3e4;
    var RATE_LIMIT_WINDOW_MS = 1e3;
    var RATE_LIMIT_MAX_REQ_COUNT = 50;
    var LEAK_RATE = RATE_LIMIT_MAX_REQ_COUNT / RATE_LIMIT_WINDOW_MS;
    var RETRYABLE_CODES = /* @__PURE__ */ new Set([408, 500, 502, 503, 504, 522, 524, 599]);
    var NetworkCore = class {
      constructor(options, _emitter) {
        this._emitter = _emitter;
        this._errorBoundary = null;
        this._timeout = DEFAULT_TIMEOUT_MS;
        this._netConfig = {};
        this._options = {};
        this._leakyBucket = {};
        this._lastUsedInitUrl = null;
        if (options) {
          this._options = options;
        }
        if (this._options.networkConfig) {
          this._netConfig = this._options.networkConfig;
        }
        if (this._netConfig.networkTimeoutMs) {
          this._timeout = this._netConfig.networkTimeoutMs;
        }
        this._fallbackResolver = new NetworkFallbackResolver_1.NetworkFallbackResolver(this._options);
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(this._fallbackResolver);
        this._fallbackResolver.setErrorBoundary(errorBoundary);
      }
      isBeaconSupported() {
        return typeof navigator !== "undefined" && typeof navigator.sendBeacon === "function";
      }
      getLastUsedInitUrlAndReset() {
        const tempUrl = this._lastUsedInitUrl;
        this._lastUsedInitUrl = null;
        return tempUrl;
      }
      beacon(args) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!_ensureValidSdkKey(args)) {
            return false;
          }
          const argsInternal = this._getInternalRequestArgs("POST", args);
          yield this._tryToCompressBody(argsInternal);
          const url = yield this._getPopulatedURL(argsInternal);
          const nav = navigator;
          return nav.sendBeacon.bind(nav)(url, argsInternal.body);
        });
      }
      post(args) {
        return __awaiter(this, void 0, void 0, function* () {
          const argsInternal = this._getInternalRequestArgs("POST", args);
          this._tryEncodeBody(argsInternal);
          yield this._tryToCompressBody(argsInternal);
          return this._sendRequest(argsInternal);
        });
      }
      get(args) {
        const argsInternal = this._getInternalRequestArgs("GET", args);
        return this._sendRequest(argsInternal);
      }
      _sendRequest(args) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
          if (!_ensureValidSdkKey(args)) {
            return null;
          }
          if (this._netConfig.preventAllNetworkTraffic) {
            return null;
          }
          const { method, body, retries, attempt } = args;
          const endpoint = args.urlConfig.endpoint;
          if (this._isRateLimited(endpoint)) {
            Log_1.Log.warn(`Request to ${endpoint} was blocked because you are making requests too frequently.`);
            return null;
          }
          const currentAttempt = attempt !== null && attempt !== void 0 ? attempt : 1;
          const abortController = typeof AbortController !== "undefined" ? new AbortController() : null;
          const timeoutHandle = setTimeout(() => {
            abortController === null || abortController === void 0 ? void 0 : abortController.abort(`Timeout of ${this._timeout}ms expired.`);
          }, this._timeout);
          const populatedUrl = yield this._getPopulatedURL(args);
          let response = null;
          const keepalive = (0, VisibilityObserving_1._isUnloading)();
          try {
            const config = {
              method,
              body,
              headers: Object.assign({}, args.headers),
              signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
              priority: args.priority,
              keepalive
            };
            _tryMarkInitStart(args, currentAttempt);
            const bucket = this._leakyBucket[endpoint];
            if (bucket) {
              bucket.lastRequestTime = Date.now();
              this._leakyBucket[endpoint] = bucket;
            }
            const func = (_a = this._netConfig.networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch;
            response = yield func(populatedUrl, config);
            clearTimeout(timeoutHandle);
            if (!response.ok) {
              const text2 = yield response.text().catch(() => "No Text");
              const err = new Error(`NetworkError: ${populatedUrl} ${text2}`);
              err.name = "NetworkError";
              throw err;
            }
            const text = yield response.text();
            _tryMarkInitEnd(args, response, currentAttempt, text);
            this._fallbackResolver.tryBumpExpiryTime(args.sdkKey, args.urlConfig);
            return {
              body: text,
              code: response.status
            };
          } catch (error) {
            const errorMessage = _getErrorMessage(abortController, error);
            const timedOut = _didTimeout(abortController);
            _tryMarkInitEnd(args, response, currentAttempt, "", error);
            const fallbackUpdated = yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(args.sdkKey, args.urlConfig, errorMessage, timedOut);
            if (fallbackUpdated) {
              args.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
            }
            if (!retries || currentAttempt > retries || !RETRYABLE_CODES.has((_b = response === null || response === void 0 ? void 0 : response.status) !== null && _b !== void 0 ? _b : 500)) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag: StatsigClientEventEmitter_1.ErrorTag.NetworkError,
                requestArgs: args
              });
              const formattedErrorMsg = `A networking error occurred during ${method} request to ${populatedUrl}.`;
              Log_1.Log.error(formattedErrorMsg, errorMessage, error);
              (_d = this._errorBoundary) === null || _d === void 0 ? void 0 : _d.attachErrorIfNoneExists(formattedErrorMsg);
              return null;
            }
            yield _exponentialBackoff(currentAttempt);
            return this._sendRequest(Object.assign(Object.assign({}, args), { retries, attempt: currentAttempt + 1 }));
          }
        });
      }
      _isRateLimited(endpoint) {
        var _a;
        const now = Date.now();
        const bucket = (_a = this._leakyBucket[endpoint]) !== null && _a !== void 0 ? _a : {
          count: 0,
          lastRequestTime: now
        };
        const elapsed = now - bucket.lastRequestTime;
        const leakedRequests = Math.floor(elapsed * LEAK_RATE);
        bucket.count = Math.max(0, bucket.count - leakedRequests);
        if (bucket.count >= RATE_LIMIT_MAX_REQ_COUNT) {
          return true;
        }
        bucket.count += 1;
        bucket.lastRequestTime = now;
        this._leakyBucket[endpoint] = bucket;
        return false;
      }
      _getPopulatedURL(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const url = (_a = args.fallbackUrl) !== null && _a !== void 0 ? _a : args.urlConfig.getUrl();
          if (args.urlConfig.endpoint === NetworkConfig_1.Endpoint._initialize || args.urlConfig.endpoint === NetworkConfig_1.Endpoint._download_config_specs) {
            this._lastUsedInitUrl = url;
          }
          const params = Object.assign({ [NetworkConfig_1.NetworkParam.SdkKey]: args.sdkKey, [NetworkConfig_1.NetworkParam.SdkType]: SDKType_1.SDKType._get(args.sdkKey), [NetworkConfig_1.NetworkParam.SdkVersion]: StatsigMetadata_1.SDK_VERSION, [NetworkConfig_1.NetworkParam.Time]: String(Date.now()), [NetworkConfig_1.NetworkParam.SessionID]: SessionID_1.SessionID.get(args.sdkKey) }, args.params);
          const query = Object.keys(params).map((key) => {
            return `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
          }).join("&");
          return `${url}${query ? `?${query}` : ""}`;
        });
      }
      _tryEncodeBody(args) {
        var _a;
        const win = (0, SafeJs_1._getWindowSafe)();
        const body = args.body;
        if (!args.isStatsigEncodable || this._options.disableStatsigEncoding || typeof body !== "string" || (0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-encode") != null || !(win === null || win === void 0 ? void 0 : win.btoa)) {
          return;
        }
        try {
          args.body = win.btoa(body).split("").reverse().join("");
          args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.StatsigEncoded]: "1" });
        } catch (e) {
          Log_1.Log.warn(`Request encoding failed for ${args.urlConfig.getUrl()}`, e);
        }
      }
      _tryToCompressBody(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const body = args.body;
          if (typeof body !== "string" || !_allowCompression(args, this._options)) {
            return;
          }
          try {
            const bytes = new TextEncoder().encode(body);
            const stream = new CompressionStream("gzip");
            const writer = stream.writable.getWriter();
            writer.write(bytes).catch(Log_1.Log.error);
            writer.close().catch(Log_1.Log.error);
            const reader = stream.readable.getReader();
            const chunks = [];
            let result;
            while (!(result = yield reader.read()).done) {
              chunks.push(result.value);
            }
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
              combined.set(chunk, offset);
              offset += chunk.length;
            }
            args.body = combined;
            args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.IsGzipped]: "1" });
          } catch (e) {
            Log_1.Log.warn(`Request compression failed for ${args.urlConfig.getUrl()}`, e);
          }
        });
      }
      _getInternalRequestArgs(method, args) {
        const fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
        const result = Object.assign(Object.assign({}, args), {
          method,
          fallbackUrl
        });
        if ("data" in args) {
          _populateRequestBody(result, args.data);
        }
        return result;
      }
    };
    exports.NetworkCore = NetworkCore;
    var _ensureValidSdkKey = (args) => {
      if (!args.sdkKey) {
        Log_1.Log.warn("Unable to make request without an SDK key");
        return false;
      }
      return true;
    };
    var _populateRequestBody = (args, data) => {
      const { sdkKey, fallbackUrl } = args;
      const stableID = StableID_1.StableID.get(sdkKey);
      const sessionID = SessionID_1.SessionID.get(sdkKey);
      const sdkType = SDKType_1.SDKType._get(sdkKey);
      args.body = JSON.stringify(Object.assign(Object.assign({}, data), { statsigMetadata: Object.assign(Object.assign({}, StatsigMetadata_1.StatsigMetadataProvider.get()), {
        stableID,
        sessionID,
        sdkType,
        fallbackUrl
      }) }));
    };
    function _allowCompression(args, options) {
      if (!args.isCompressable) {
        return false;
      }
      if (options.disableCompression) {
        return false;
      }
      if ((args.urlConfig.customUrl != null || args.urlConfig.fallbackUrls != null) && SDKFlags_1.SDKFlags.get(args.sdkKey, "enable_log_event_compression") !== true) {
        return false;
      }
      if ((0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-compress") != null || typeof CompressionStream === "undefined" || typeof TextEncoder === "undefined") {
        return false;
      }
      return true;
    }
    function _getErrorMessage(controller, error) {
      if ((controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string") {
        return controller.signal.reason;
      }
      if (typeof error === "string") {
        return error;
      }
      if (error instanceof Error) {
        return `${error.name}: ${error.message}`;
      }
      return "Unknown Error";
    }
    function _didTimeout(controller) {
      const timeout = (controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string" && controller.signal.reason.includes("Timeout");
      return timeout || false;
    }
    function _tryMarkInitStart(args, attempt) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqStart(args.sdkKey, {
        attempt
      });
    }
    function _tryMarkInitEnd(args, response, attempt, body, err) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqEnd(args.sdkKey, Diagnostics_1.Diagnostics._getDiagnosticsData(response, attempt, body, err));
    }
    function _exponentialBackoff(attempt) {
      return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((r) => setTimeout(r, Math.min(BACKOFF_BASE_MS * (attempt * attempt), BACKOFF_MAX_MS)));
      });
    }
  }
});

// node_modules/@statsig/client-core/src/OverrideAdapter.js
var require_OverrideAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/OverrideAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/ParamStoreTypes.js
var require_ParamStoreTypes = __commonJS({
  "node_modules/@statsig/client-core/src/ParamStoreTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigClientBase.js
var require_StatsigClientBase = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientBase.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClientBase = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var ErrorBoundary_1 = require_ErrorBoundary();
    var EventLogger_1 = require_EventLogger();
    var Log_1 = require_Log();
    var MemoKey_1 = require_MemoKey();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StorageProvider_1 = require_StorageProvider();
    var MAX_MEMO_CACHE_SIZE = 3e3;
    var StatsigClientBase = class {
      constructor(sdkKey, adapter, network, options) {
        var _a, _b, _c, _d;
        this.loadingStatus = "Uninitialized";
        this._initializePromise = null;
        this._listeners = {};
        const emitter = this.$emt.bind(this);
        (options === null || options === void 0 ? void 0 : options.logLevel) != null && (Log_1.Log.level = options.logLevel);
        (options === null || options === void 0 ? void 0 : options.disableStorage) && StorageProvider_1.Storage._setDisabled(true);
        (options === null || options === void 0 ? void 0 : options.initialSessionID) && SessionID_1.StatsigSession.overrideInitialSessionID(options.initialSessionID, sdkKey);
        (options === null || options === void 0 ? void 0 : options.storageProvider) && StorageProvider_1.Storage._setProvider(options.storageProvider);
        (options === null || options === void 0 ? void 0 : options.enableCookies) && StableID_1.StableID._setCookiesEnabled(sdkKey, options.enableCookies);
        (options === null || options === void 0 ? void 0 : options.disableStableID) && StableID_1.StableID._setDisabled(sdkKey, true);
        this._sdkKey = sdkKey;
        this._options = options !== null && options !== void 0 ? options : {};
        this._memoCache = {};
        this.overrideAdapter = (_a = options === null || options === void 0 ? void 0 : options.overrideAdapter) !== null && _a !== void 0 ? _a : null;
        this._logger = new EventLogger_1.EventLogger(sdkKey, emitter, network, options);
        this._errorBoundary = new ErrorBoundary_1.ErrorBoundary(sdkKey, options, emitter);
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(adapter);
        this._errorBoundary.wrap(this._logger);
        network.setErrorBoundary(this._errorBoundary);
        this.dataAdapter = adapter;
        this.dataAdapter.attach(sdkKey, options, network);
        this.storageProvider = StorageProvider_1.Storage;
        (_d = (_c = (_b = this.overrideAdapter) === null || _b === void 0 ? void 0 : _b.loadFromStorage) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.catch((e) => this._errorBoundary.logError("OA::loadFromStorage", e));
        this._primeReadyRipcord();
        _assignGlobalInstance(sdkKey, this);
      }
      /**
       * Updates runtime configuration options for the SDK, allowing toggling of certain behaviors such as logging and storage to comply with user preferences or regulations such as GDPR.
       *
       * @param {StatsigRuntimeMutableOptions} options - The configuration options that dictate the runtime behavior of the SDK.
       */
      updateRuntimeOptions(options) {
        if (options.disableLogging != null) {
          this._options.disableLogging = options.disableLogging;
          this._logger.setLoggingDisabled(options.disableLogging);
        }
        if (options.disableStorage != null) {
          this._options.disableStorage = options.disableStorage;
          StorageProvider_1.Storage._setDisabled(options.disableStorage);
        }
        if (options.enableCookies != null) {
          this._options.enableCookies = options.enableCookies;
          StableID_1.StableID._setCookiesEnabled(this._sdkKey, options.enableCookies);
        }
      }
      /**
       * Flushes any currently queued events.
       */
      flush() {
        return this._logger.flush();
      }
      /**
       * Gracefully shuts down the SDK, ensuring that all pending events are send before the SDK stops.
       * This function emits a 'pre_shutdown' event and then waits for the logger to complete its shutdown process.
       *
       * @returns {Promise<void>} A promise that resolves when all shutdown procedures, including logging shutdown, have been completed.
       */
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          this.$emt({ name: "pre_shutdown" });
          this._setStatus("Uninitialized", null);
          this._initializePromise = null;
          yield this._logger.stop();
        });
      }
      /**
       * Subscribes a callback function to a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       * Once subscribed, the listener callback will be invoked whenever the specified event is emitted.
       *
       * @param {StatsigClientEventName} event - The name of the event to subscribe to, or '*' to subscribe to all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to execute when the event occurs. The function receives event-specific data as its parameter.
       * @see {@link off} for unsubscribing from events.
       */
      on(event, listener) {
        if (!this._listeners[event]) {
          this._listeners[event] = [];
        }
        this._listeners[event].push(listener);
      }
      /**
       * Unsubscribes a previously registered callback function from a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       *
       * @param {StatsigClientEventName} event - The name of the event from which to unsubscribe, or '*' to unsubscribe from all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to remove from the event's notification list.
       * @see {@link on} for subscribing to events.
       */
      off(event, listener) {
        if (this._listeners[event]) {
          const index = this._listeners[event].indexOf(listener);
          if (index !== -1) {
            this._listeners[event].splice(index, 1);
          }
        }
      }
      $on(event, listener) {
        listener.__isInternal = true;
        this.on(event, listener);
      }
      $emt(event) {
        var _a;
        const barrier = (listener) => {
          try {
            listener(event);
          } catch (error) {
            if (listener.__isInternal === true) {
              this._errorBoundary.logError(`__emit:${event.name}`, error);
              return;
            }
            Log_1.Log.error(`An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.`, event);
          }
        };
        if (this._listeners[event.name]) {
          this._listeners[event.name].forEach((l) => barrier(l));
        }
        (_a = this._listeners["*"]) === null || _a === void 0 ? void 0 : _a.forEach(barrier);
      }
      _setStatus(newStatus, values) {
        this.loadingStatus = newStatus;
        this._memoCache = {};
        this.$emt({ name: "values_updated", status: newStatus, values });
      }
      _enqueueExposure(name, exposure, options) {
        if ((options === null || options === void 0 ? void 0 : options.disableExposureLog) === true) {
          this._logger.incrementNonExposureCount(name);
          return;
        }
        this._logger.enqueue(exposure);
      }
      _memoize(prefix, fn) {
        return (name, options) => {
          if (this._options.disableEvaluationMemoization) {
            return fn(name, options);
          }
          const memoKey = (0, MemoKey_1.createMemoKey)(prefix, name, options);
          if (!memoKey) {
            return fn(name, options);
          }
          if (!(memoKey in this._memoCache)) {
            if (Object.keys(this._memoCache).length >= MAX_MEMO_CACHE_SIZE) {
              this._memoCache = {};
            }
            this._memoCache[memoKey] = fn(name, options);
          }
          return this._memoCache[memoKey];
        };
      }
    };
    exports.StatsigClientBase = StatsigClientBase;
    function _assignGlobalInstance(sdkKey, client) {
      var _a;
      if ((0, SafeJs_1._isServerEnv)()) {
        return;
      }
      const statsigGlobal = (0, __StatsigGlobal_1._getStatsigGlobal)();
      const instances = (_a = statsigGlobal.instances) !== null && _a !== void 0 ? _a : {};
      const inst = client;
      if (instances[sdkKey] != null) {
        Log_1.Log.warn("Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.");
      }
      instances[sdkKey] = inst;
      if (!statsigGlobal.firstInstance) {
        statsigGlobal.firstInstance = inst;
      }
      statsigGlobal.instances = instances;
      __STATSIG__ = statsigGlobal;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigDataAdapter.js
var require_StatsigDataAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigDataAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataAdapterCachePrefix = void 0;
    exports.DataAdapterCachePrefix = "statsig.cached";
  }
});

// node_modules/@statsig/client-core/src/StatsigOptionsCommon.js
var require_StatsigOptionsCommon = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigOptionsCommon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigPlugin.js
var require_StatsigPlugin = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigPlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigTypeFactories.js
var require_StatsigTypeFactories = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypeFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeTypedGet = exports._mergeOverride = exports._makeLayer = exports._makeExperiment = exports._makeDynamicConfig = exports._makeFeatureGate = void 0;
    var Log_1 = require_Log();
    var TypingUtils_1 = require_TypingUtils();
    var DEFAULT_RULE = "default";
    function _makeEvaluation(name, details, evaluation, value) {
      var _a;
      return {
        name,
        details,
        ruleID: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id) !== null && _a !== void 0 ? _a : DEFAULT_RULE,
        __evaluation: evaluation,
        value
      };
    }
    function _makeFeatureGate(name, details, evaluation) {
      return _makeEvaluation(name, details, evaluation, (evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) === true);
    }
    exports._makeFeatureGate = _makeFeatureGate;
    function _makeDynamicConfig(name, details, evaluation) {
      var _a;
      const value = (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, value)), { get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) });
    }
    exports._makeDynamicConfig = _makeDynamicConfig;
    function _makeExperiment(name, details, evaluation) {
      var _a;
      const result = _makeDynamicConfig(name, details, evaluation);
      return Object.assign(Object.assign({}, result), { groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeExperiment = _makeExperiment;
    function _makeLayer2(name, details, evaluation, exposeFunc) {
      var _a, _b;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, void 0)), { get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value, exposeFunc), groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null, __value: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _b !== void 0 ? _b : {} });
    }
    exports._makeLayer = _makeLayer2;
    function _mergeOverride(original, overridden, value, exposeFunc) {
      return Object.assign(Object.assign(Object.assign({}, original), overridden), { get: _makeTypedGet2(original.name, value, exposeFunc) });
    }
    exports._mergeOverride = _mergeOverride;
    function _makeTypedGet2(name, value, exposeFunc) {
      return (param, fallback) => {
        var _a;
        const found = (_a = value === null || value === void 0 ? void 0 : value[param]) !== null && _a !== void 0 ? _a : null;
        if (found == null) {
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        if (fallback != null && !(0, TypingUtils_1._isTypeMatch)(found, fallback)) {
          Log_1.Log.warn(`Parameter type mismatch. '${name}.${param}' was found to be type '${typeof found}' but fallback/return type is '${typeof fallback}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`);
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        exposeFunc === null || exposeFunc === void 0 ? void 0 : exposeFunc(param);
        return found;
      };
    }
    exports._makeTypedGet = _makeTypedGet2;
  }
});

// node_modules/@statsig/client-core/src/StatsigTypes.js
var require_StatsigTypes = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigUpdateDetails.js
var require_StatsigUpdateDetails = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUpdateDetails.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UPDATE_DETAIL_ERROR_MESSAGES = exports.createUpdateDetails = void 0;
    var createUpdateDetails = (success, source, initDuration, error, sourceUrl, warnings) => {
      return {
        duration: initDuration,
        source,
        success,
        error,
        sourceUrl,
        warnings
      };
    };
    exports.createUpdateDetails = createUpdateDetails;
    exports.UPDATE_DETAIL_ERROR_MESSAGES = {
      NO_NETWORK_DATA: "No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error."
    };
  }
});

// node_modules/@statsig/client-core/src/index.js
var require_src = __commonJS({
  "node_modules/@statsig/client-core/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = exports.Log = exports.EventLogger = exports.Diagnostics = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
      return Diagnostics_1.Diagnostics;
    } });
    var EventLogger_1 = require_EventLogger();
    Object.defineProperty(exports, "EventLogger", { enumerable: true, get: function() {
      return EventLogger_1.EventLogger;
    } });
    var Log_1 = require_Log();
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return Log_1.Log;
    } });
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StorageProvider_1 = require_StorageProvider();
    Object.defineProperty(exports, "Storage", { enumerable: true, get: function() {
      return StorageProvider_1.Storage;
    } });
    __exportStar(require_StatsigGlobal(), exports);
    __exportStar(require_CacheKey(), exports);
    __exportStar(require_ClientInterfaces(), exports);
    __exportStar(require_DataAdapterCore(), exports);
    __exportStar(require_Diagnostics(), exports);
    __exportStar(require_DownloadConfigSpecsResponse(), exports);
    __exportStar(require_ErrorBoundary(), exports);
    __exportStar(require_EvaluationOptions(), exports);
    __exportStar(require_EvaluationTypes(), exports);
    __exportStar(require_Hashing(), exports);
    __exportStar(require_InitializeResponse(), exports);
    __exportStar(require_Log(), exports);
    __exportStar(require_MemoKey(), exports);
    __exportStar(require_NetworkConfig(), exports);
    __exportStar(require_NetworkCore(), exports);
    __exportStar(require_OverrideAdapter(), exports);
    __exportStar(require_ParamStoreTypes(), exports);
    __exportStar(require_SafeJs(), exports);
    __exportStar(require_SDKType(), exports);
    __exportStar(require_SessionID(), exports);
    __exportStar(require_StableID(), exports);
    __exportStar(require_StatsigClientBase(), exports);
    __exportStar(require_StatsigClientEventEmitter(), exports);
    __exportStar(require_StatsigDataAdapter(), exports);
    __exportStar(require_StatsigEvent(), exports);
    __exportStar(require_StatsigMetadata(), exports);
    __exportStar(require_StatsigOptionsCommon(), exports);
    __exportStar(require_StatsigPlugin(), exports);
    __exportStar(require_StatsigTypeFactories(), exports);
    __exportStar(require_StatsigTypes(), exports);
    __exportStar(require_StatsigUser(), exports);
    __exportStar(require_StorageProvider(), exports);
    __exportStar(require_TypedJsonParse(), exports);
    __exportStar(require_TypingUtils(), exports);
    __exportStar(require_UrlConfiguration(), exports);
    __exportStar(require_UUID(), exports);
    __exportStar(require_VisibilityObserving(), exports);
    __exportStar(require_StatsigUpdateDetails(), exports);
    __exportStar(require_SDKFlags(), exports);
    Object.assign((0, __StatsigGlobal_1._getStatsigGlobal)(), { Log: Log_1.Log, SDK_VERSION: StatsigMetadata_1.SDK_VERSION });
  }
});

// node_modules/@statsig/js-client/src/EvaluationStore.js
var require_EvaluationStore = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore = class {
      constructor(_sdkKey) {
        this._sdkKey = _sdkKey;
        this._rawValues = null;
        this._values = null;
        this._source = "Uninitialized";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings = /* @__PURE__ */ new Set();
      }
      reset() {
        this._values = null;
        this._rawValues = null;
        this._source = "Loading";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
      }
      finalize() {
        if (this._values) {
          return;
        }
        this._source = "NoValues";
      }
      getValues() {
        return this._rawValues ? (0, client_core_1._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null;
      }
      setValues(result, user) {
        var _a;
        if (!result) {
          return false;
        }
        const values = (0, client_core_1._typedJsonParse)(result.data, "has_updates", "EvaluationResponse");
        if (values == null) {
          return false;
        }
        this._source = result.source;
        if ((values === null || values === void 0 ? void 0 : values.has_updates) !== true) {
          return true;
        }
        this._rawValues = result.data;
        this._lcut = values.time;
        this._receivedAt = result.receivedAt;
        this._values = values;
        this._bootstrapMetadata = this._extractBootstrapMetadata(result.source, values);
        if (result.source && values.user) {
          this._setWarningState(user, values);
        }
        client_core_1.SDKFlags.setFlags(this._sdkKey, (_a = values.sdk_flags) !== null && _a !== void 0 ? _a : {});
        return true;
      }
      getWarnings() {
        if (this._warnings.size === 0) {
          return void 0;
        }
        return Array.from(this._warnings);
      }
      getGate(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.feature_gates, name);
      }
      getConfig(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.dynamic_configs, name);
      }
      getLayer(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.layer_configs, name);
      }
      getParamStore(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.param_stores, name);
      }
      getSource() {
        return this._source;
      }
      getExposureMapping() {
        var _a;
        return (_a = this._values) === null || _a === void 0 ? void 0 : _a.exposures;
      }
      _extractBootstrapMetadata(source, values) {
        if (source !== "Bootstrap") {
          return null;
        }
        const bootstrapMetadata = {};
        if (values.user) {
          bootstrapMetadata.user = values.user;
        }
        if (values.sdkInfo) {
          bootstrapMetadata.generatorSDKInfo = values.sdkInfo;
        }
        bootstrapMetadata.lcut = values.time;
        return bootstrapMetadata;
      }
      _getDetailedStoreResult(lookup, name) {
        let result = null;
        if (lookup) {
          result = lookup[name] ? lookup[name] : lookup[(0, client_core_1._DJB2)(name)];
        }
        return {
          result,
          details: this._getDetails(result == null)
        };
      }
      _setWarningState(user, values) {
        var _a, _b;
        const stableID = client_core_1.StableID.get(this._sdkKey);
        if (((_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID) !== stableID && // don't throw if they're both undefined
        (((_b = user.customIDs) === null || _b === void 0 ? void 0 : _b.stableID) || stableID)) {
          this._warnings.add("StableIDMismatch");
          return;
        }
        if ("user" in values) {
          const bootstrapUser = values["user"];
          if ((0, client_core_1._getFullUserHash)(user) !== (0, client_core_1._getFullUserHash)(bootstrapUser)) {
            this._warnings.add("PartialUserMatch");
          }
        }
      }
      getCurrentSourceDetails() {
        if (this._source === "Uninitialized" || this._source === "NoValues") {
          return { reason: this._source };
        }
        const sourceDetails = {
          reason: this._source,
          lcut: this._lcut,
          receivedAt: this._receivedAt
        };
        if (this._warnings.size > 0) {
          sourceDetails.warnings = Array.from(this._warnings);
        }
        return sourceDetails;
      }
      _getDetails(isUnrecognized) {
        var _a, _b;
        const sourceDetails = this.getCurrentSourceDetails();
        let reason = sourceDetails.reason;
        const warnings = (_a = sourceDetails.warnings) !== null && _a !== void 0 ? _a : [];
        if (this._source === "Bootstrap" && warnings.length > 0) {
          reason = reason + warnings[0];
        }
        if (reason !== "Uninitialized" && reason !== "NoValues") {
          const subreason = isUnrecognized ? "Unrecognized" : "Recognized";
          reason = `${reason}:${subreason}`;
        }
        const bootstrapMetadata = this._source === "Bootstrap" ? (_b = this._bootstrapMetadata) !== null && _b !== void 0 ? _b : void 0 : void 0;
        if (bootstrapMetadata) {
          sourceDetails.bootstrapMetadata = bootstrapMetadata;
        }
        return Object.assign(Object.assign({}, sourceDetails), { reason });
      }
    };
    exports.default = EvaluationStore;
  }
});

// node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js
var require_EvaluationResponseDeltas = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._resolveDeltasResponse = void 0;
    var client_core_1 = require_src();
    var MAX_DELTAS_SORT_DEPTH = 2;
    function _resolveDeltasResponse(cache, deltasString) {
      const deltas = (0, client_core_1._typedJsonParse)(deltasString, "checksum", "DeltasEvaluationResponse");
      if (!deltas) {
        return {
          hadBadDeltaChecksum: true
        };
      }
      const merged = _mergeDeltasIntoCache(cache, deltas);
      const resolved = _handleDeletedEntries(merged);
      const actualChecksum = (0, client_core_1._DJB2Object)({
        feature_gates: resolved.feature_gates,
        dynamic_configs: resolved.dynamic_configs,
        layer_configs: resolved.layer_configs
      }, MAX_DELTAS_SORT_DEPTH);
      const isMatch = actualChecksum === deltas.checksumV2;
      if (!isMatch) {
        return {
          hadBadDeltaChecksum: true,
          badChecksum: actualChecksum,
          badMergedConfigs: resolved,
          badFullResponse: deltas.deltas_full_response
        };
      }
      return JSON.stringify(resolved);
    }
    exports._resolveDeltasResponse = _resolveDeltasResponse;
    function _mergeDeltasIntoCache(cache, deltas) {
      return Object.assign(Object.assign(Object.assign({}, cache), deltas), { feature_gates: Object.assign(Object.assign({}, cache.feature_gates), deltas.feature_gates), layer_configs: Object.assign(Object.assign({}, cache.layer_configs), deltas.layer_configs), dynamic_configs: Object.assign(Object.assign({}, cache.dynamic_configs), deltas.dynamic_configs) });
    }
    function _handleDeletedEntries(deltas) {
      const result = deltas;
      _deleteEntriesInRecord(deltas.deleted_gates, result.feature_gates);
      delete result.deleted_gates;
      _deleteEntriesInRecord(deltas.deleted_configs, result.dynamic_configs);
      delete result.deleted_configs;
      _deleteEntriesInRecord(deltas.deleted_layers, result.layer_configs);
      delete result.deleted_layers;
      return result;
    }
    function _deleteEntriesInRecord(keys, values) {
      keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
        delete values[key];
      });
    }
  }
});

// node_modules/@statsig/js-client/src/Network.js
var require_Network = __commonJS({
  "node_modules/@statsig/js-client/src/Network.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationResponseDeltas_1 = require_EvaluationResponseDeltas();
    var StatsigNetwork = class extends client_core_1.NetworkCore {
      constructor(options, emitter) {
        super(options, emitter);
        const config = options === null || options === void 0 ? void 0 : options.networkConfig;
        this._option = options;
        this._initializeUrlConfig = new client_core_1.UrlConfiguration(client_core_1.Endpoint._initialize, config === null || config === void 0 ? void 0 : config.initializeUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.initializeFallbackUrls);
      }
      fetchEvaluations(sdkKey, current, priority, user, isCacheValidFor204) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
          const cache = current ? (0, client_core_1._typedJsonParse)(current, "has_updates", "InitializeResponse") : null;
          let data = {
            user,
            hash: (_c = (_b = (_a = this._option) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.initializeHashAlgorithm) !== null && _c !== void 0 ? _c : "djb2",
            deltasResponseRequested: false,
            full_checksum: null
          };
          if (cache === null || cache === void 0 ? void 0 : cache.has_updates) {
            const hasHashChanged = (cache === null || cache === void 0 ? void 0 : cache.hash_used) !== ((_f = (_e = (_d = this._option) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.initializeHashAlgorithm) !== null && _f !== void 0 ? _f : "djb2");
            data = Object.assign(Object.assign({}, data), { sinceTime: isCacheValidFor204 && !hasHashChanged ? cache.time : 0, previousDerivedFields: "derived_fields" in cache && isCacheValidFor204 ? cache.derived_fields : {}, deltasResponseRequested: true, full_checksum: cache.full_checksum });
          }
          return this._fetchEvaluations(sdkKey, cache, data, priority);
        });
      }
      _fetchEvaluations(sdkKey, cache, data, priority) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.post({
            sdkKey,
            urlConfig: this._initializeUrlConfig,
            data,
            retries: 2,
            isStatsigEncodable: true,
            priority
          });
          if ((response === null || response === void 0 ? void 0 : response.code) === 204) {
            return '{"has_updates": false}';
          }
          if ((response === null || response === void 0 ? void 0 : response.code) !== 200) {
            return (_a = response === null || response === void 0 ? void 0 : response.body) !== null && _a !== void 0 ? _a : null;
          }
          if ((cache === null || cache === void 0 ? void 0 : cache.has_updates) !== true || ((_b = response.body) === null || _b === void 0 ? void 0 : _b.includes('"is_delta":true')) !== true || data.deltasResponseRequested !== true) {
            return response.body;
          }
          const result = (0, EvaluationResponseDeltas_1._resolveDeltasResponse)(cache, response.body);
          if (typeof result === "string") {
            return result;
          }
          return this._fetchEvaluations(sdkKey, cache, Object.assign(Object.assign(Object.assign({}, data), result), { deltasResponseRequested: false }), priority);
        });
      }
    };
    exports.default = StatsigNetwork;
  }
});

// node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js
var require_ParamStoreGetterFactory = __commonJS({
  "node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeParamStoreGetter = void 0;
    var client_core_1 = require_src();
    var NO_EXPOSURE_OPT = {
      disableExposureLog: true
    };
    function _shouldLogExposure(options) {
      return options == null || options.disableExposureLog === false;
    }
    function _shouldReturnFallback(value, fallback) {
      return fallback != null && !(0, client_core_1._isTypeMatch)(value, fallback);
    }
    function _getMappedStaticValue(param, _options) {
      return param.value;
    }
    function _getMappedGateValue(client, param, options) {
      const gate = client.getFeatureGate(param.gate_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      if (gate.value) {
        return param.pass_value;
      }
      return param.fail_value;
    }
    function _getMappedDynamicConfigValue(client, param, fallback, options) {
      const config = client.getDynamicConfig(param.config_name, NO_EXPOSURE_OPT);
      const value = config.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      if (_shouldLogExposure(options)) {
        client.getDynamicConfig(param.config_name);
      }
      return value;
    }
    function _getMappedExperimentValue(client, param, fallback, options) {
      const experiment = client.getExperiment(param.experiment_name, NO_EXPOSURE_OPT);
      const value = experiment.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      if (_shouldLogExposure(options)) {
        client.getExperiment(param.experiment_name);
      }
      return value;
    }
    function _getMappedLayerValue(client, param, fallback, options) {
      const layer = client.getLayer(param.layer_name, NO_EXPOSURE_OPT);
      const value = layer.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      if (_shouldLogExposure(options)) {
        client.getLayer(param.layer_name).get(param.param_name);
      }
      return value;
    }
    function _makeParamStoreGetter(client, config, options) {
      return (paramName, fallback) => {
        if (config == null) {
          return fallback;
        }
        const param = config[paramName];
        if (param == null || fallback != null && (0, client_core_1._typeOf)(fallback) !== param.param_type) {
          return fallback;
        }
        switch (param.ref_type) {
          case "static":
            return _getMappedStaticValue(param, options);
          case "gate":
            return _getMappedGateValue(client, param, options);
          case "dynamic_config":
            return _getMappedDynamicConfigValue(client, param, fallback, options);
          case "experiment":
            return _getMappedExperimentValue(client, param, fallback, options);
          case "layer":
            return _getMappedLayerValue(client, param, fallback, options);
          default:
            return fallback;
        }
      };
    }
    exports._makeParamStoreGetter = _makeParamStoreGetter;
  }
});

// node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js
var require_StatsigEvaluationsDataAdapter = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigEvaluationsDataAdapter = void 0;
    var client_core_1 = require_src();
    var Network_1 = require_Network();
    var StatsigEvaluationsDataAdapter = class extends client_core_1.DataAdapterCore {
      constructor() {
        super("EvaluationsDataAdapter", "evaluations");
        this._network = null;
        this._options = null;
      }
      attach(sdkKey, options, network) {
        super.attach(sdkKey, options, network);
        if (network !== null && network instanceof Network_1.default) {
          this._network = network;
        } else {
          this._network = new Network_1.default(options !== null && options !== void 0 ? options : {});
        }
      }
      getDataAsync(current, user, options) {
        return this._getDataAsyncImpl(current, (0, client_core_1._normalizeUser)(user, this._options), options);
      }
      prefetchData(user, options) {
        return this._prefetchDataImpl(user, options);
      }
      setData(data) {
        const values = (0, client_core_1._typedJsonParse)(data, "has_updates", "data");
        if (values && "user" in values) {
          super.setData(data, values.user);
        } else {
          client_core_1.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.");
        }
      }
      setDataLegacy(data, user) {
        super.setData(data, user);
      }
      _fetchFromNetwork(current, user, options, isCacheValidFor204) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield (_a = this._network) === null || _a === void 0 ? void 0 : _a.fetchEvaluations(this._getSdkKey(), current, options === null || options === void 0 ? void 0 : options.priority, user, isCacheValidFor204);
          return result !== null && result !== void 0 ? result : null;
        });
      }
      _getCacheKey(user) {
        var _a;
        const key = (0, client_core_1._getStorageKey)(this._getSdkKey(), user, (_a = this._options) === null || _a === void 0 ? void 0 : _a.customUserCacheKeyFunc);
        return `${client_core_1.DataAdapterCachePrefix}.${this._cacheSuffix}.${key}`;
      }
      _isCachedResultValidFor204(result, user) {
        return result.fullUserHash != null && result.fullUserHash === (0, client_core_1._getFullUserHash)(user);
      }
    };
    exports.StatsigEvaluationsDataAdapter = StatsigEvaluationsDataAdapter;
  }
});

// node_modules/@statsig/js-client/src/StatsigClient.js
var require_StatsigClient = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore_1 = require_EvaluationStore();
    var Network_1 = require_Network();
    var ParamStoreGetterFactory_1 = require_ParamStoreGetterFactory();
    var StatsigEvaluationsDataAdapter_1 = require_StatsigEvaluationsDataAdapter();
    var StatsigClient2 = class _StatsigClient extends client_core_1.StatsigClientBase {
      /**
       * Retrieves an instance of the StatsigClient based on the provided SDK key.
       *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.
       *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.
       *
       * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.
       * @returns {StatsigClient|undefined} Returns the StatsigClient instance associated with the given SDK key, or undefined if no instance is associated with the key or if no key is provided and no instances exist.
       */
      static instance(sdkKey) {
        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
        if (instance instanceof _StatsigClient) {
          return instance;
        }
        client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance");
        return new _StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : "", {});
      }
      /**
       * StatsigClient constructor
       *
       * @param {string} sdkKey A Statsig client SDK key. eg "client-xyz123..."
       * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.
       * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.
       */
      constructor(sdkKey, user, options = null) {
        var _a, _b;
        client_core_1.SDKType._setClientType(sdkKey, "javascript-client");
        const network = new Network_1.default(options, (e) => {
          this.$emt(e);
        });
        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);
        this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));
        this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));
        this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));
        this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));
        this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));
        this._store = new EvaluationStore_1.default(sdkKey);
        this._network = network;
        this._user = this._configureUser(user, options);
        const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];
        for (const plugin of plugins) {
          plugin.bind(this);
        }
      }
      /**
       * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.
       * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.
       * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.
       *
       * @see {@link initializeAsync} for the asynchronous version of this method.
       */
      initializeSync(options) {
        var _a;
        if (this.loadingStatus !== "Uninitialized") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
        }
        this._logger.start();
        return this.updateUserSync(this._user, options);
      }
      /**
       * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.
       * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,
       * there might be a transition from cached to network values during the session, which can affect consistency.
       * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.
       *
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.
       * @see {@link initializeSync} for the synchronous version of this method.
       */
      initializeAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._initializePromise) {
            return this._initializePromise;
          }
          this._initializePromise = this._initializeAsyncImpl(options);
          return this._initializePromise;
        });
      }
      /**
       * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.
       * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.
       * This method ensures the client is quickly ready with available data.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @see {@link updateUserAsync} for the asynchronous version of this method.
       */
      updateUserSync(user, options) {
        var _a;
        const startTime = performance.now();
        const warnings = [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []];
        this._resetForUser(user);
        const result = this.dataAdapter.getDataSync(this._user);
        if (result == null) {
          warnings.push("NoCachedValues");
        }
        this._store.setValues(result, this._user);
        this._finalizeUpdate(result);
        const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;
        if (disable === true || disable == null && (result === null || result === void 0 ? void 0 : result.source) === "Bootstrap") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
        }
        this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);
        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
      }
      /**
       * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.
       * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,
       * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.
       * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.
       * @see {@link updateUserSync} for the synchronous version of this method.
       */
      updateUserAsync(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          this._resetForUser(user);
          const initiator = this._user;
          client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);
          let result = this.dataAdapter.getDataSync(initiator);
          this._store.setValues(result, this._user);
          this._setStatus("Loading", result);
          result = yield this.dataAdapter.getDataAsync(result, initiator, options);
          if (initiator !== this._user) {
            return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
          }
          let isUsingNetworkValues = false;
          if (result != null) {
            client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);
            isUsingNetworkValues = this._store.setValues(result, this._user);
            client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {
              success: isUsingNetworkValues
            });
          }
          this._finalizeUpdate(result);
          if (!isUsingNetworkValues) {
            this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);
            this.$emt({ name: "initialization_failure" });
          }
          client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());
          const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
          return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());
        });
      }
      /**
       * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.
       *
       * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.
       */
      getContext() {
        return {
          sdkKey: this._sdkKey,
          options: this._options,
          values: this._store.getValues(),
          user: JSON.parse(JSON.stringify(this._user)),
          errorBoundary: this._errorBoundary,
          session: client_core_1.StatsigSession.get(this._sdkKey),
          stableID: client_core_1.StableID.get(this._sdkKey)
        };
      }
      /**
       * Retrieves the value of a feature gate for the current user, represented as a simple boolean.
       *
       * @param {string} name - The name of the feature gate to retrieve.
       * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.
       */
      checkGate(name, options) {
        return this.getFeatureGate(name, options).value;
      }
      /**
       * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.
       *
       * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.
       * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.
       * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.
       */
      logEvent(eventOrName, value, metadata) {
        const event = typeof eventOrName === "string" ? {
          eventName: eventOrName,
          value,
          metadata
        } : eventOrName;
        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));
      }
      _primeReadyRipcord() {
        this.$on("error", () => {
          this.loadingStatus === "Loading" && this._finalizeUpdate(null);
        });
      }
      _initializeAsyncImpl(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client_core_1.Storage.isReady()) {
            yield client_core_1.Storage.isReadyResolver();
          }
          this._logger.start();
          return this.updateUserAsync(this._user, options);
        });
      }
      _finalizeUpdate(values) {
        this._store.finalize();
        this._setStatus("Ready", values);
      }
      _runPostUpdate(current, user) {
        this.dataAdapter.getDataAsync(current, user, { priority: "low" }).catch((err) => {
          client_core_1.Log.error("An error occurred after update.", err);
        });
      }
      _resetForUser(user) {
        this._logger.reset();
        this._store.reset();
        this._user = this._configureUser(user, this._options);
      }
      _configureUser(originalUser, options) {
        var _a;
        const user = (0, client_core_1._normalizeUser)(originalUser, options);
        const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (stableIdOverride) {
          client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);
        }
        return user;
      }
      _getFeatureGateImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getGate(name);
        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : gate;
        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "gate_evaluation", gate: result });
        return result;
      }
      _getDynamicConfigImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getConfig(name);
        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : config;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "dynamic_config_evaluation", dynamicConfig: result });
        return result;
      }
      _getExperimentImpl(name, options) {
        var _a, _b, _c, _d;
        const { result: evaluation, details } = this._store.getConfig(name);
        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
        if (experiment.__evaluation != null) {
          experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());
        }
        const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "experiment_evaluation", experiment: result });
        return result;
      }
      _getLayerImpl(name, options) {
        var _a, _b, _c;
        const { result: evaluation, details } = this._store.getLayer(name);
        const layer = (0, client_core_1._makeLayer)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);
        if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
          this._logger.incrementNonExposureCount(name);
        }
        const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, (param) => {
          if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
            return;
          }
          this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);
        });
        this.$emt({ name: "layer_evaluation", layer: result });
        return result;
      }
      _getParameterStoreImpl(name, options) {
        var _a, _b;
        const { result: configuration, details } = this._store.getParamStore(name);
        this._logger.incrementNonExposureCount(name);
        const paramStore = {
          name,
          details,
          __configuration: configuration,
          get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options)
        };
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);
        if (overridden != null) {
          paramStore.__configuration = overridden.config;
          paramStore.details = overridden.details;
          paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);
        }
        return paramStore;
      }
    };
    exports.default = StatsigClient2;
  }
});

// node_modules/@statsig/js-client/src/index.js
var require_src2 = __commonJS({
  "node_modules/@statsig/js-client/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClient = void 0;
    var client_core_1 = require_src();
    var StatsigClient_1 = require_StatsigClient();
    exports.StatsigClient = StatsigClient_1.default;
    __exportStar(require_src(), exports);
    var __STATSIG__2 = Object.assign((0, client_core_1._getStatsigGlobal)(), {
      StatsigClient: StatsigClient_1.default
    });
    exports.default = __STATSIG__2;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module) {
    !function(undefined2) {
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          this._maxListeners = conf.maxListeners !== undefined2 ? conf.maxListeners : defaultMaxListeners;
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this.newListener = conf.newListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        } else {
          this._maxListeners = defaultMaxListeners;
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      function EventEmitter(conf) {
        this._events = {};
        this.newListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      function searchListenerTree(handlers, type, tree, i) {
        if (!tree) {
          return [];
        }
        var listeners = [], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached, typeLength = type.length, currentType = type[i], nextType = type[i + 1];
        if (i === typeLength && tree._listeners) {
          if (typeof tree._listeners === "function") {
            handlers && handlers.push(tree._listeners);
            return [tree];
          } else {
            for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
              handlers && handlers.push(tree._listeners[leaf]);
            }
            return [tree];
          }
        }
        if (currentType === "*" || currentType === "**" || tree[currentType]) {
          if (currentType === "*") {
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
            }
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
                  }
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                } else if (branch === nextType) {
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));
                } else {
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                }
              }
            }
            return listeners;
          }
          listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength);
            }
            for (branch in xxTree) {
              if (branch !== "_listeners" && xxTree.hasOwnProperty(branch)) {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener) {
        type = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        for (var i = 0, len = type.length; i + 1 < len; i++) {
          if (type[i] === "**" && type[i + 1] === "**") {
            return;
          }
        }
        var tree = this.listenerTree;
        var name = type.shift();
        while (name !== undefined2) {
          if (!tree[name]) {
            tree[name] = {};
          }
          tree = tree[name];
          if (type.length === 0) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              tree._listeners.push(listener);
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
          name = type.shift();
        }
        return true;
      }
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf) this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn) {
        return this._once(event, fn, false);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn) {
        return this._once(event, fn, true);
      };
      EventEmitter.prototype._once = function(event, fn, prepend) {
        this._many(event, 1, fn, prepend);
        return this;
      };
      EventEmitter.prototype.many = function(event, ttl, fn) {
        return this._many(event, ttl, fn, false);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn) {
        return this._many(event, ttl, fn, true);
      };
      EventEmitter.prototype._many = function(event, ttl, fn, prepend) {
        var self = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self.off(event, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        this._on(event, listener, prepend);
        return self;
      };
      EventEmitter.prototype.emit = function() {
        this._events || init.call(this);
        var type = arguments[0];
        if (type === "newListener" && !this.newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        var al = arguments.length;
        var args, l, i, j;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          if (al > 3) {
            args = new Array(al);
            for (j = 0; j < al; j++) args[j] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
        }
        if (this.wildcard) {
          handler = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++) args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        this._events || init.call(this);
        var type = arguments[0];
        if (type === "newListener" && !this.newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        var promises = [];
        var al = arguments.length;
        var args, l, i, j;
        var handler;
        if (this._all) {
          if (al > 3) {
            args = new Array(al);
            for (j = 1; j < al; j++) args[j] = arguments[j];
          }
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, args));
            }
          }
        }
        if (this.wildcard) {
          handler = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++) args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener) {
        return this._on(type, listener, false);
      };
      EventEmitter.prototype.prependListener = function(type, listener) {
        return this._on(type, listener, true);
      };
      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        this.emit("newListener", type, listener);
        if (this.wildcard) {
          growListenerTree.call(this, type, listener);
          return this;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return this;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        } else {
          if (!this._events[type]) return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            this.emit("removeListener", type, listener);
          }
        }
        function recursivelyGarbageCollect(root) {
          if (root === undefined2) {
            return;
          }
          var keys = Object.keys(root);
          for (var i2 in keys) {
            var key = keys[i2];
            var obj = root[key];
            if (obj instanceof Function || typeof obj !== "object" || obj === null)
              continue;
            if (Object.keys(obj).length > 0) {
              recursivelyGarbageCollect(root[key]);
            }
            if (Object.keys(obj).length === 0) {
              delete root[key];
            }
          }
        }
        recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++)
            this.emit("removeListenerAny", fns[i]);
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (arguments.length === 0) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            leaf._listeners = null;
          }
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers;
        }
        this._events || init.call(this);
        if (!this._events[type]) this._events[type] = [];
        if (!isArray(this._events[type])) {
          this._events[type] = [this._events[type]];
        }
        return this._events[type];
      };
      EventEmitter.prototype.eventNames = function() {
        return Object.keys(this._events);
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module.exports = EventEmitter;
      } else {
        window.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/Subscriptions.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_eventemitter2, ALL_FEATURE_VALUES, Subscriptions;
var init_Subscriptions = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/Subscriptions.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_eventemitter2 = __toESM(require_eventemitter2());
    ALL_FEATURE_VALUES = "@all-features";
    Subscriptions = function() {
      function Subscriptions2() {
        _classCallCheck(this, Subscriptions2);
        _defineProperty(this, "eventToValue", /* @__PURE__ */ new Map());
        this.emitter = new import_eventemitter2.EventEmitter2();
      }
      return _createClass(Subscriptions2, [{
        key: "onGateUpdated",
        value: function onGateUpdated(gateName, callback, checkGate, options) {
          var _this = this;
          var value = checkGate(gateName, _objectSpread(_objectSpread({}, options), {}, {
            fireGateExposure: false
          }));
          if (this.eventToValue.get(callback) === void 0) {
            this.eventToValue.set(callback, value);
          }
          var wrapCallback = function wrapCallback2() {
            var value2 = checkGate(gateName, _objectSpread(_objectSpread({}, options), {}, {
              fireGateExposure: false
            }));
            var existingValue = _this.eventToValue.get(callback);
            if (existingValue !== value2) {
              _this.eventToValue.set(callback, value2);
              callback(value2);
            }
          };
          this.emitter.on(gateName, wrapCallback);
          return function() {
            _this.emitter.off(gateName, wrapCallback);
          };
        }
      }, {
        key: "onExperimentValueUpdated",
        value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback, getExperimentValue, options) {
          var _this2 = this;
          var experimentEventName = "".concat(experimentName, ".").concat(parameterName);
          var value = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread(_objectSpread({}, options), {}, {
            fireExperimentExposure: false
          }));
          if (this.eventToValue.get(callback) === void 0) {
            this.eventToValue.set(callback, value);
          }
          var wrapCallback = function wrapCallback2() {
            var value2 = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread(_objectSpread({}, options), {}, {
              fireExperimentExposure: false
            }));
            var existingValue = _this2.eventToValue.get(callback);
            if (existingValue !== value2) {
              _this2.eventToValue.set(callback, value2);
              callback(value2);
            }
          };
          this.emitter.on(experimentEventName, wrapCallback);
          return function() {
            _this2.emitter.off(experimentEventName, wrapCallback);
          };
        }
      }, {
        key: "onAnyUpdated",
        value: function onAnyUpdated(callback) {
          var _this3 = this;
          this.emitter.on(ALL_FEATURE_VALUES, callback);
          return function() {
            _this3.emitter.off(ALL_FEATURE_VALUES, callback);
          };
        }
      }, {
        key: "anyUpdated",
        value: function anyUpdated() {
          var _this4 = this;
          this.emitter.emit(ALL_FEATURE_VALUES);
          this.emitter.eventNames().filter(function(name) {
            return name !== ALL_FEATURE_VALUES;
          }).forEach(function(event) {
            _this4.emitter.emit(event);
          });
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/index.js
var init_subscriptions = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/index.js"() {
    init_Subscriptions();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/index.js
var FEDRAMP_MODERATE, COMMERCIAL, FEDRAMP_FEDEX, STAGING, PRODUCTION, DEV;
var init_constants = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/index.js"() {
    FEDRAMP_MODERATE = "fedramp-moderate";
    COMMERCIAL = "commercial";
    FEDRAMP_FEDEX = "fedramp-fedex";
    STAGING = "stg";
    PRODUCTION = "prod";
    DEV = "dev";
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/is-fedramp/index.js
function isFedRamp() {
  var _global$location;
  var global2 = globalThis;
  var env = global2.MICROS_PERIMETER || global2.UNSAFE_ATL_CONTEXT_BOUNDARY;
  if (env) {
    return env === FEDRAMP_MODERATE;
  }
  var matches = (_global$location = global2.location) === null || _global$location === void 0 || (_global$location = _global$location.hostname) === null || _global$location === void 0 ? void 0 : _global$location.match(/atlassian-us-gov-mod\.(com|net)|atlassian-us-gov\.(com|net)|atlassian-fex\.(com|net)|atlassian-stg-fedm\.(com|net)/);
  return matches ? matches.length > 0 : false;
}
var init_is_fedramp = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/is-fedramp/index.js"() {
    init_constants();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/domains.js
var domainMap, fullDomainOverride;
var init_domains = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/domains.js"() {
    init_defineProperty();
    init_constants();
    domainMap = _defineProperty(_defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian.com"), PRODUCTION, "atlassian.com")), FEDRAMP_FEDEX, _defineProperty({}, STAGING, "atlassian-fex.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian-us-gov-mod.com"), PRODUCTION, "atlassian-us-gov-mod.com"));
    fullDomainOverride = {
      analytics: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "analytics.atlassian.com")),
      // Marketing site
      confluence: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "confluence.atlassian.com")),
      // Atlassian design system documentation
      design: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "design.atlassian.com")),
      // Old staff intranet (now hello.atlassian.net)
      extranet: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "extranet.atlassian.com")),
      // Go links
      go: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "go.atlassian.com")),
      my: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "my.atlassian.com")),
      schema: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "schema.atlassian.com")),
      start: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian.com"), STAGING, "start.stg.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian-us-gov-mod.com"), STAGING, "start.stg.atlassian-us-gov-mod.com")),
      surveys: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "surveys.atlassian.com")),
      "wac-cdn": _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "wac-cdn.atlassian.com")),
      integrations: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "integrations.atlassian.com")),
      permalink: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "permalink.atlassian.com")),
      id: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian.com"), STAGING, "id.stg.internal.atlassian.com"), DEV, "id.dev.internal.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian-us-gov-mod.com"), STAGING, "id.stg.atlassian-us-gov-mod.com")),
      support: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "support.atlassian.com"))
    };
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/types.js
var init_types = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/types.js"() {
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/domain-lookup/index.js
var init_domain_lookup = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/domain-lookup/index.js"() {
    init_slicedToArray();
    init_constants();
    init_domains();
    init_types();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/index.js"() {
    init_is_fedramp();
    init_domain_lookup();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/types.js
var EvaluationReason;
var init_types2 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/types.js"() {
    EvaluationReason = function(EvaluationReason2) {
      EvaluationReason2["Error"] = "Error";
      EvaluationReason2["LocalOverride"] = "LocalOverride";
      EvaluationReason2["Unrecognized"] = "Unrecognized";
      EvaluationReason2["Uninitialized"] = "Uninitialized";
      EvaluationReason2["NetworkNotModified"] = "NetworkNotModified";
      EvaluationReason2["Network"] = "Network";
      EvaluationReason2["InvalidBootstrap"] = "InvalidBootstrap";
      EvaluationReason2["Bootstrap"] = "Bootstrap";
      EvaluationReason2["Cache"] = "Cache";
      EvaluationReason2["Unknown"] = "Unknown";
      return EvaluationReason2;
    }({});
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/types.js
var FeatureGateEnvironment, PerimeterType;
var init_types3 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/types.js"() {
    FeatureGateEnvironment = function(FeatureGateEnvironment2) {
      FeatureGateEnvironment2["Development"] = "development";
      FeatureGateEnvironment2["Staging"] = "staging";
      FeatureGateEnvironment2["Production"] = "production";
      return FeatureGateEnvironment2;
    }({});
    PerimeterType = function(PerimeterType2) {
      PerimeterType2["COMMERCIAL"] = "commercial";
      PerimeterType2["FEDRAMP_MODERATE"] = "fedramp-moderate";
      return PerimeterType2;
    }({});
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/utils.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_js_client, _excluded, getOptionsWithDefaults, shallowEquals, toStatsigUser, migrateInitializationOptions, evaluationReasonMappings, migrateEvaluationDetails;
var init_utils = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/utils.js"() {
    init_objectWithoutProperties();
    init_slicedToArray();
    init_defineProperty();
    import_js_client = __toESM(require_src2());
    init_esm();
    init_types2();
    init_types3();
    _excluded = ["api", "disableCurrentPageLogging", "loggingIntervalMillis", "loggingBufferMaxSize", "localMode", "eventLoggingApi", "eventLoggingApiForRetries", "disableLocalStorage", "ignoreWindowUndefined", "disableAllLogging", "initTimeoutMs", "disableNetworkKeepalive", "overrideStableID", "disableErrorLogging", "disableAutoMetricsLogging"];
    getOptionsWithDefaults = function getOptionsWithDefaults2(options) {
      return _objectSpread2({
        /**
         * If more federal PerimeterTypes are added in the future, this should be updated so
         * that isFedRamp() === true always returns the strictest perimeter.
         */
        perimeter: isFedRamp() ? PerimeterType.FEDRAMP_MODERATE : PerimeterType.COMMERCIAL
      }, options);
    };
    shallowEquals = function shallowEquals2(objectA, objectB) {
      if (!objectA && !objectB) {
        return true;
      }
      if (!objectA || !objectB) {
        return false;
      }
      var aEntries = Object.entries(objectA);
      var bEntries = Object.entries(objectB);
      if (aEntries.length !== bEntries.length) {
        return false;
      }
      var ascendingKeyOrder = function ascendingKeyOrder2(_ref, _ref2) {
        var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
        var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
        return key1.localeCompare(key2);
      };
      aEntries.sort(ascendingKeyOrder);
      bEntries.sort(ascendingKeyOrder);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), aValue = _aEntries$i[1];
        var _bEntries$i = _slicedToArray(bEntries[i], 2), bValue = _bEntries$i[1];
        if (aValue !== bValue) {
          return false;
        }
      }
      return true;
    };
    toStatsigUser = function toStatsigUser2(identifiers, customAttributes, sdkKey) {
      var user = {
        customIDs: !(customAttributes !== null && customAttributes !== void 0 && customAttributes.stableID) && sdkKey ? _objectSpread2({
          stableID: import_js_client.StableID.get(sdkKey)
        }, identifiers) : identifiers,
        custom: customAttributes
      };
      if (identifiers.atlassianAccountId) {
        user.userID = identifiers.atlassianAccountId;
      }
      return user;
    };
    migrateInitializationOptions = function migrateInitializationOptions2(options) {
      var api = options.api, disableCurrentPageLogging = options.disableCurrentPageLogging, loggingIntervalMillis = options.loggingIntervalMillis, loggingBufferMaxSize = options.loggingBufferMaxSize, localMode = options.localMode, eventLoggingApi = options.eventLoggingApi, eventLoggingApiForRetries = options.eventLoggingApiForRetries, disableLocalStorage = options.disableLocalStorage, ignoreWindowUndefined = options.ignoreWindowUndefined, disableAllLogging = options.disableAllLogging, _initTimeoutMs = options.initTimeoutMs, _disableNetworkKeepalive = options.disableNetworkKeepalive, _overrideStableID = options.overrideStableID, _disableErrorLogging = options.disableErrorLogging, _disableAutoMetricsLogging = options.disableAutoMetricsLogging, rest = _objectWithoutProperties(options, _excluded);
      return _objectSpread2(_objectSpread2({}, rest), {}, {
        networkConfig: {
          api,
          logEventUrl: eventLoggingApi ? eventLoggingApi + "rgstr" : void 0,
          logEventFallbackUrls: eventLoggingApiForRetries ? [eventLoggingApiForRetries] : void 0,
          preventAllNetworkTraffic: localMode || !ignoreWindowUndefined && typeof window === "undefined"
        },
        includeCurrentPageUrlWithEvents: !disableCurrentPageLogging,
        loggingIntervalMs: loggingIntervalMillis,
        loggingBufferMaxSize,
        disableStorage: disableLocalStorage === void 0 ? localMode : disableLocalStorage,
        disableLogging: disableAllLogging === void 0 ? localMode : disableAllLogging
      });
    };
    evaluationReasonMappings = Object.entries(EvaluationReason).map(function(_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2), key = _ref6[0], value = _ref6[1];
      return [key.toLowerCase(), value];
    });
    migrateEvaluationDetails = function migrateEvaluationDetails2(details) {
      var _evaluationReasonMapp, _evaluationReasonMapp2, _details$receivedAt;
      var reasonLower = details.reason.toLowerCase();
      return {
        reason: (_evaluationReasonMapp = (_evaluationReasonMapp2 = evaluationReasonMappings.find(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 1), key = _ref8[0];
          return reasonLower.includes(key);
        })) === null || _evaluationReasonMapp2 === void 0 ? void 0 : _evaluationReasonMapp2[1]) !== null && _evaluationReasonMapp !== void 0 ? _evaluationReasonMapp : EvaluationReason.Unknown,
        time: (_details$receivedAt = details.receivedAt) !== null && _details$receivedAt !== void 0 ? _details$receivedAt : Date.now()
      };
    };
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/DynamicConfig.js
var DynamicConfig;
var init_DynamicConfig = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/DynamicConfig.js"() {
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_utils();
    DynamicConfig = function() {
      function DynamicConfig2(configName, configValue, ruleID, evaluationDetails) {
        var secondaryExposures = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
        var allocatedExperimentName = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "";
        var onDefaultValueFallback = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
        _classCallCheck(this, DynamicConfig2);
        this.value = configValue;
        this._name = configName;
        this._ruleID = ruleID;
        this._secondaryExposures = secondaryExposures;
        this._allocatedExperimentName = allocatedExperimentName;
        this._evaluationDetails = evaluationDetails;
        this._onDefaultValueFallback = onDefaultValueFallback;
      }
      return _createClass(DynamicConfig2, [{
        key: "get",
        value: function get(key, defaultValue, typeGuard) {
          var _this$_onDefaultValue2;
          var val = this.getValue(key, defaultValue);
          if (val == null) {
            return defaultValue;
          }
          var expectedType = Array.isArray(defaultValue) ? "array" : _typeof(defaultValue);
          var actualType = Array.isArray(val) ? "array" : _typeof(val);
          if (typeGuard) {
            var _this$_onDefaultValue;
            if (typeGuard(val)) {
              this.fireExposure(key);
              return val;
            }
            (_this$_onDefaultValue = this._onDefaultValueFallback) === null || _this$_onDefaultValue === void 0 || _this$_onDefaultValue.call(this, this, key, expectedType, actualType);
            return defaultValue;
          }
          if (defaultValue == null || expectedType === actualType) {
            this.fireExposure(key);
            return val;
          }
          (_this$_onDefaultValue2 = this._onDefaultValueFallback) === null || _this$_onDefaultValue2 === void 0 || _this$_onDefaultValue2.call(this, this, key, expectedType, actualType);
          return defaultValue;
        }
      }, {
        key: "getValue",
        value: function getValue(key, defaultValue) {
          if (key == null) {
            return this.value;
          }
          if (defaultValue == null) {
            defaultValue = null;
          }
          if (this.value[key] == null) {
            return defaultValue;
          }
          this.fireExposure(key);
          return this.value[key];
        }
      }, {
        key: "fireExposure",
        value: function fireExposure(key) {
          if (this.experiment) {
            this.experiment.get(key);
          }
        }
      }], [{
        key: "fromExperiment",
        value: function fromExperiment(experiment) {
          var _experiment$__evaluat, _experiment$groupName;
          var config = new DynamicConfig2(experiment.name, experiment.value, experiment.ruleID, migrateEvaluationDetails(experiment.details), (_experiment$__evaluat = experiment.__evaluation) === null || _experiment$__evaluat === void 0 ? void 0 : _experiment$__evaluat.secondary_exposures, (_experiment$groupName = experiment.groupName) !== null && _experiment$groupName !== void 0 ? _experiment$groupName : void 0);
          config.experiment = experiment;
          return config;
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/Layer.js
var Layer;
var init_Layer = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/Layer.js"() {
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_utils();
    Layer = function() {
      function Layer2(name, layerValue, ruleID, evaluationDetails) {
        var logParameterFunction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        var secondaryExposures = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
        var undelegatedSecondaryExposures = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [];
        var allocatedExperimentName = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "";
        var explicitParameters = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
        _classCallCheck(this, Layer2);
        this._logParameterFunction = logParameterFunction;
        this._name = name;
        this._value = JSON.parse(JSON.stringify(layerValue !== null && layerValue !== void 0 ? layerValue : {}));
        this._ruleID = ruleID !== null && ruleID !== void 0 ? ruleID : "";
        this._evaluationDetails = evaluationDetails;
        this._secondaryExposures = secondaryExposures;
        this._undelegatedSecondaryExposures = undelegatedSecondaryExposures;
        this._allocatedExperimentName = allocatedExperimentName;
        this._explicitParameters = explicitParameters;
      }
      return _createClass(Layer2, [{
        key: "get",
        value: function get(key, defaultValue, typeGuard) {
          var _this = this;
          var val = this._value[key];
          if (val == null) {
            return defaultValue;
          }
          var logAndReturn = function logAndReturn2() {
            _this._logLayerParameterExposure(key);
            return val;
          };
          if (typeGuard) {
            return typeGuard(val) ? logAndReturn() : defaultValue;
          }
          if (defaultValue == null) {
            return logAndReturn();
          }
          if (_typeof(val) === _typeof(defaultValue) && Array.isArray(defaultValue) === Array.isArray(val)) {
            return logAndReturn();
          }
          return defaultValue;
        }
      }, {
        key: "getValue",
        value: function getValue(key, defaultValue) {
          if (defaultValue == void 0) {
            defaultValue = null;
          }
          var val = this._value[key];
          if (val != null) {
            this._logLayerParameterExposure(key);
          }
          return val !== null && val !== void 0 ? val : defaultValue;
        }
      }, {
        key: "_logLayerParameterExposure",
        value: function _logLayerParameterExposure(parameterName) {
          var _this$_logParameterFu;
          (_this$_logParameterFu = this._logParameterFunction) === null || _this$_logParameterFu === void 0 || _this$_logParameterFu.call(this, this, parameterName);
        }
      }], [{
        key: "fromLayer",
        value: function fromLayer(layer) {
          var _layer$__evaluation, _layer$__evaluation2, _layer$__evaluation3, _layer$__evaluation4;
          var value = new Layer2(layer.name, layer.__value, layer.ruleID, migrateEvaluationDetails(layer.details), function(_layer, parameterName) {
            return layer.get(parameterName);
          }, (_layer$__evaluation = layer.__evaluation) === null || _layer$__evaluation === void 0 ? void 0 : _layer$__evaluation.secondary_exposures, (_layer$__evaluation2 = layer.__evaluation) === null || _layer$__evaluation2 === void 0 ? void 0 : _layer$__evaluation2.undelegated_secondary_exposures, (_layer$__evaluation3 = layer.__evaluation) === null || _layer$__evaluation3 === void 0 ? void 0 : _layer$__evaluation3.allocated_experiment_name, (_layer$__evaluation4 = layer.__evaluation) === null || _layer$__evaluation4 === void 0 ? void 0 : _layer$__evaluation4.explicit_parameters);
          return value;
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/version.js
var CLIENT_VERSION;
var init_version = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/version.js"() {
    CLIENT_VERSION = "5.2.0";
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
var init_isNativeFunction = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct4() {
    return !!t;
  })();
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
var init_construct = __esm({
  "node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_isNativeReflectConstruct();
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/errors.js
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct4() {
    return !!t;
  })();
}
var ResponseError;
var init_errors = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/errors.js"() {
    init_createClass();
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_wrapNativeSuper();
    ResponseError = function(_Error) {
      function ResponseError2(message) {
        _classCallCheck(this, ResponseError2);
        return _callSuper(this, ResponseError2, [message]);
      }
      _inherits(ResponseError2, _Error);
      return _createClass(ResponseError2);
    }(_wrapNativeSuper(Error));
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_regenerator, DEFAULT_REQUEST_TIMEOUT_MS, PROD_BASE_URL, STAGING_BASE_URL, DEV_BASE_URL, FEDM_STAGING_BASE_URL, FEDM_PROD_BASE_URL, GATEWAY_BASE_URL, Fetcher;
var init_Fetcher = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js"() {
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator = __toESM(require_regenerator());
    init_types3();
    init_version();
    init_errors();
    DEFAULT_REQUEST_TIMEOUT_MS = 5e3;
    PROD_BASE_URL = "https://api.atlassian.com/flags";
    STAGING_BASE_URL = "https://api.stg.atlassian.com/flags";
    DEV_BASE_URL = "https://api.dev.atlassian.com/flags";
    FEDM_STAGING_BASE_URL = "https://api.stg.atlassian-us-gov-mod.com/flags";
    FEDM_PROD_BASE_URL = "https://api.atlassian-us-gov-mod.com/flags";
    GATEWAY_BASE_URL = "/gateway/api/flags";
    Fetcher = function() {
      function Fetcher2() {
        _classCallCheck(this, Fetcher2);
      }
      return _createClass(Fetcher2, null, [{
        key: "fetchClientSdk",
        value: function() {
          var _fetchClientSdk = _asyncToGenerator(import_regenerator.default.mark(function _callee(fetcherOptions) {
            var targetApp, url;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  targetApp = fetcherOptions.targetApp;
                  url = "/api/v2/frontend/clientSdkKey/".concat(targetApp);
                  _context.prev = 2;
                  _context.next = 5;
                  return this.fetchRequest(url, "GET", fetcherOptions);
                case 5:
                  return _context.abrupt("return", _context.sent);
                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](2);
                  if (!(_context.t0 instanceof Error)) {
                    _context.next = 12;
                    break;
                  }
                  throw _context.t0;
                case 12:
                  throw Error("Failed to retrieve client sdk key");
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[2, 8]]);
          }));
          function fetchClientSdk(_x) {
            return _fetchClientSdk.apply(this, arguments);
          }
          return fetchClientSdk;
        }()
      }, {
        key: "fetchExperimentValues",
        value: function() {
          var _fetchExperimentValues = _asyncToGenerator(import_regenerator.default.mark(function _callee2(fetcherOptions, identifiers, customAttributes) {
            var requestBody;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  requestBody = {
                    identifiers,
                    customAttributes,
                    targetApp: fetcherOptions.targetApp
                  };
                  _context2.prev = 1;
                  _context2.next = 4;
                  return this.fetchRequest("/api/v2/frontend/experimentValues", "POST", fetcherOptions, requestBody);
                case 4:
                  return _context2.abrupt("return", _context2.sent);
                case 7:
                  _context2.prev = 7;
                  _context2.t0 = _context2["catch"](1);
                  if (!(_context2.t0 instanceof Error)) {
                    _context2.next = 11;
                    break;
                  }
                  throw _context2.t0;
                case 11:
                  throw Error("Failed to retrieve experiment values");
                case 12:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[1, 7]]);
          }));
          function fetchExperimentValues(_x2, _x3, _x4) {
            return _fetchExperimentValues.apply(this, arguments);
          }
          return fetchExperimentValues;
        }()
      }, {
        key: "handleResponseError",
        value: function() {
          var _handleResponseError = _asyncToGenerator(import_regenerator.default.mark(function _callee3(response) {
            var body;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  if (response.ok) {
                    _context3.next = 5;
                    break;
                  }
                  _context3.next = 3;
                  return response.text();
                case 3:
                  body = _context3.sent;
                  throw new ResponseError("Non 2xx response status received, status: ".concat(response.status, ", body: ").concat(JSON.stringify(body)));
                case 5:
                  if (!(response.status === 204)) {
                    _context3.next = 7;
                    break;
                  }
                  throw new ResponseError("Unexpected 204 response");
                case 7:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function handleResponseError(_x5) {
            return _handleResponseError.apply(this, arguments);
          }
          return handleResponseError;
        }()
      }, {
        key: "extractResponseBody",
        value: function() {
          var _extractResponseBody = _asyncToGenerator(import_regenerator.default.mark(function _callee4(response) {
            var value;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return response.text();
                case 2:
                  value = _context4.sent;
                  return _context4.abrupt("return", JSON.parse(value));
                case 4:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          function extractResponseBody(_x6) {
            return _extractResponseBody.apply(this, arguments);
          }
          return extractResponseBody;
        }()
      }, {
        key: "getBaseUrl",
        value: function getBaseUrl(serviceEnv) {
          var useGatewayUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var perimeter = arguments.length > 2 ? arguments[2] : void 0;
          if (useGatewayUrl) {
            return GATEWAY_BASE_URL;
          }
          if (perimeter === PerimeterType.FEDRAMP_MODERATE) {
            switch (serviceEnv) {
              case FeatureGateEnvironment.Production:
                return FEDM_PROD_BASE_URL;
              case FeatureGateEnvironment.Staging:
                return FEDM_STAGING_BASE_URL;
              default:
                throw new Error('Invalid environment "'.concat(serviceEnv, '" for "').concat(perimeter, '" perimeter'));
            }
          } else if (perimeter === PerimeterType.COMMERCIAL) {
            switch (serviceEnv) {
              case FeatureGateEnvironment.Development:
                return DEV_BASE_URL;
              case FeatureGateEnvironment.Staging:
                return STAGING_BASE_URL;
              default:
                return PROD_BASE_URL;
            }
          } else {
            throw new Error('Invalid perimeter "'.concat(perimeter, '"'));
          }
        }
      }, {
        key: "fetchRequest",
        value: function() {
          var _fetchRequest = _asyncToGenerator(import_regenerator.default.mark(function _callee5(path, method, fetcherOptions, body) {
            var baseUrl, fetchTimeout, abortSignal, abortController, response;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  baseUrl = Fetcher2.getBaseUrl(fetcherOptions.environment, fetcherOptions.useGatewayURL, fetcherOptions.perimeter);
                  fetchTimeout = fetcherOptions.fetchTimeoutMs || DEFAULT_REQUEST_TIMEOUT_MS;
                  if (AbortSignal.timeout) {
                    abortSignal = AbortSignal.timeout(fetchTimeout);
                  } else if (AbortController) {
                    abortController = new AbortController();
                    abortSignal = abortController.signal;
                    setTimeout(function() {
                      return abortController.abort();
                    }, fetchTimeout);
                  }
                  _context5.next = 5;
                  return fetch("".concat(baseUrl).concat(path), _objectSpread3({
                    method,
                    headers: {
                      "Content-Type": "application/json",
                      "X-Client-Name": "feature-gate-js-client",
                      "X-Client-Version": CLIENT_VERSION,
                      "X-API-KEY": fetcherOptions.apiKey
                    },
                    signal: abortSignal
                  }, body && {
                    body: JSON.stringify(body)
                  }));
                case 5:
                  response = _context5.sent;
                  _context5.next = 8;
                  return this.handleResponseError(response);
                case 8:
                  _context5.next = 10;
                  return this.extractResponseBody(response);
                case 10:
                  return _context5.abrupt("return", _context5.sent);
                case 11:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function fetchRequest(_x7, _x8, _x9, _x10) {
            return _fetchRequest.apply(this, arguments);
          }
          return fetchRequest;
        }()
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/index.js
var init_fetcher = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/index.js"() {
    init_Fetcher();
  }
});

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}
var init_superPropBase = __esm({
  "node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_getPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
var init_get = __esm({
  "node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_superPropBase();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/NoFetchDataAdapter.js
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct3 = function _isNativeReflectConstruct4() {
    return !!t;
  })();
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
var import_regenerator2, import_js_client2, NoFetchDataAdapter;
var init_NoFetchDataAdapter = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/NoFetchDataAdapter.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_defineProperty();
    import_regenerator2 = __toESM(require_regenerator());
    import_js_client2 = __toESM(require_src2());
    NoFetchDataAdapter = function(_DataAdapterCore) {
      function NoFetchDataAdapter2() {
        var _this;
        _classCallCheck(this, NoFetchDataAdapter2);
        _this = _callSuper2(this, NoFetchDataAdapter2, ["NoFetchDataAdapter", "nofetch"]);
        _defineProperty(_this, "bootstrapResult", null);
        return _this;
      }
      _inherits(NoFetchDataAdapter2, _DataAdapterCore);
      return _createClass(NoFetchDataAdapter2, [{
        key: "setBootstrapData",
        value: function setBootstrapData(data) {
          this.bootstrapResult = data ? {
            source: "Bootstrap",
            data: JSON.stringify(data),
            receivedAt: Date.now(),
            stableID: import_js_client2.StableID.get(this._getSdkKey()),
            fullUserHash: null
          } : null;
        }
      }, {
        key: "prefetchData",
        value: function() {
          var _prefetchData = _asyncToGenerator(import_regenerator2.default.mark(function _callee(_user, _options) {
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function prefetchData(_x, _x2) {
            return _prefetchData.apply(this, arguments);
          }
          return prefetchData;
        }()
      }, {
        key: "getDataAsync",
        value: function() {
          var _getDataAsync = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(_current, user, _options) {
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", this.bootstrapResult && _objectSpread4(_objectSpread4({}, this.bootstrapResult), {}, {
                    fullUserHash: (0, import_js_client2._getFullUserHash)(user)
                  }));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function getDataAsync(_x3, _x4, _x5) {
            return _getDataAsync.apply(this, arguments);
          }
          return getDataAsync;
        }()
      }, {
        key: "getDataSync",
        value: function getDataSync(user) {
          return this.bootstrapResult && _objectSpread4(_objectSpread4({}, this.bootstrapResult), {}, {
            fullUserHash: (0, import_js_client2._getFullUserHash)(user)
          });
        }
      }, {
        key: "_fetchFromNetwork",
        value: function() {
          var _fetchFromNetwork2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee3(_current, _user, _options) {
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", null);
                case 1:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function _fetchFromNetwork(_x6, _x7, _x8) {
            return _fetchFromNetwork2.apply(this, arguments);
          }
          return _fetchFromNetwork;
        }()
      }, {
        key: "_getCacheKey",
        value: function _getCacheKey(user) {
          var key = (0, import_js_client2._getStorageKey)(this._getSdkKey(), user);
          return "".concat(import_js_client2.DataAdapterCachePrefix, ".").concat(this._cacheSuffix, ".").concat(key);
        }
      }, {
        key: "_isCachedResultValidFor204",
        value: function _isCachedResultValidFor204(_result, _user) {
          return false;
        }
      }, {
        key: "setDataLegacy",
        value: function setDataLegacy(data, user) {
          _superPropGet(NoFetchDataAdapter2, "setData", this, 3)([data, user]);
        }
        // Do not stringify options property since that includes this adapter and will
        // cause a circular reference when Statsig sends diagnostic events and including
        // values is not necessary and makes the result huge
      }, {
        key: "toJSON",
        value: function toJSON() {
          var result = _objectSpread4({}, this);
          delete result._options;
          delete result._inMemoryCache;
          delete result.bootstrapResult;
          return result;
        }
      }]);
    }(import_js_client2.DataAdapterCore);
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/PersistentOverrideAdapter.js
function ownKeys5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
  }
}
function _arrayLikeToArray2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var import_client_core, LOCAL_OVERRIDE_REASON, LOCAL_STORAGE_KEY, LEGACY_LOCAL_STORAGE_KEY, makeEmptyStore, djb2MapKey, PersistentOverrideAdapter;
var init_PersistentOverrideAdapter = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/PersistentOverrideAdapter.js"() {
    init_defineProperty();
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    import_client_core = __toESM(require_src());
    LOCAL_OVERRIDE_REASON = "LocalOverride:Recognized";
    LOCAL_STORAGE_KEY = "STATSIG_OVERRIDES";
    LEGACY_LOCAL_STORAGE_KEY = "STATSIG_JS_LITE_LOCAL_OVERRIDES";
    makeEmptyStore = function makeEmptyStore2() {
      return {
        gates: {},
        configs: {},
        layers: {}
      };
    };
    djb2MapKey = function djb2MapKey2(hash, kind) {
      return kind + ":" + hash;
    };
    PersistentOverrideAdapter = function() {
      function PersistentOverrideAdapter2(localStorageKey) {
        _classCallCheck(this, PersistentOverrideAdapter2);
        this._overrides = makeEmptyStore();
        this._djb2Map = /* @__PURE__ */ new Map();
        this._localStorageKey = localStorageKey;
      }
      return _createClass(PersistentOverrideAdapter2, [{
        key: "parseStoredOverrides",
        value: function parseStoredOverrides(localStorageKey) {
          try {
            var json = window.localStorage.getItem(localStorageKey);
            if (!json) {
              return makeEmptyStore();
            }
            return JSON.parse(json);
          } catch (_unused) {
            return makeEmptyStore();
          }
        }
      }, {
        key: "mergeOverrides",
        value: function mergeOverrides() {
          var merged = makeEmptyStore();
          for (var _len = arguments.length, allOverrides = new Array(_len), _key = 0; _key < _len; _key++) {
            allOverrides[_key] = arguments[_key];
          }
          for (var _i = 0, _allOverrides = allOverrides; _i < _allOverrides.length; _i++) {
            var overrides = _allOverrides[_i];
            for (var _i2 = 0, _Object$entries = Object.entries((_overrides$gates = overrides.gates) !== null && _overrides$gates !== void 0 ? _overrides$gates : {}); _i2 < _Object$entries.length; _i2++) {
              var _overrides$gates;
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
              merged.gates[name] = value;
            }
            for (var _i3 = 0, _Object$entries2 = Object.entries((_overrides$configs = overrides.configs) !== null && _overrides$configs !== void 0 ? _overrides$configs : {}); _i3 < _Object$entries2.length; _i3++) {
              var _overrides$configs;
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), _name = _Object$entries2$_i[0], _value = _Object$entries2$_i[1];
              merged.configs[_name] = _value;
            }
            for (var _i4 = 0, _Object$entries3 = Object.entries((_overrides$layers = overrides.layers) !== null && _overrides$layers !== void 0 ? _overrides$layers : {}); _i4 < _Object$entries3.length; _i4++) {
              var _overrides$layers;
              var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2), _name2 = _Object$entries3$_i[0], _value2 = _Object$entries3$_i[1];
              merged.layers[_name2] = _value2;
            }
          }
          return merged;
        }
      }, {
        key: "initFromStoredOverrides",
        value: function initFromStoredOverrides() {
          var storedOverrides = this.mergeOverrides(this._overrides, this.parseStoredOverrides(LEGACY_LOCAL_STORAGE_KEY), this.parseStoredOverrides(this._localStorageKey));
          try {
            window.localStorage.removeItem(LEGACY_LOCAL_STORAGE_KEY);
          } catch (_unused2) {
          }
          for (var _i5 = 0, _Object$values = Object.values(storedOverrides); _i5 < _Object$values.length; _i5++) {
            var container = _Object$values[_i5];
            var allKeys = new Set(Object.keys(container));
            var _iterator = _createForOfIteratorHelper(allKeys), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var name = _step.value;
                var hash = (0, import_client_core._DJB2)(name);
                if (allKeys.has(hash)) {
                  delete container[hash];
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          this.applyOverrides(storedOverrides);
        }
      }, {
        key: "saveOverrides",
        value: function saveOverrides() {
          try {
            window.localStorage.setItem(this._localStorageKey, JSON.stringify(this._overrides));
          } catch (_unused3) {
          }
        }
      }, {
        key: "getOverrides",
        value: function getOverrides() {
          return this.mergeOverrides(this._overrides);
        }
      }, {
        key: "applyOverrides",
        value: function applyOverrides(overrides) {
          var newOverrides = _objectSpread5(_objectSpread5({}, makeEmptyStore()), overrides);
          this._djb2Map.clear();
          for (var _i6 = 0, _Object$entries4 = Object.entries(newOverrides); _i6 < _Object$entries4.length; _i6++) {
            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i6], 2), containerName = _Object$entries4$_i[0], container = _Object$entries4$_i[1];
            for (var _i7 = 0, _Object$entries5 = Object.entries(container); _i7 < _Object$entries5.length; _i7++) {
              var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i7], 2), name = _Object$entries5$_i[0], value = _Object$entries5$_i[1];
              this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), containerName), value);
            }
          }
          this._overrides = newOverrides;
        }
      }, {
        key: "setOverrides",
        value: function setOverrides(overrides) {
          this.applyOverrides(overrides);
          this.saveOverrides();
        }
      }, {
        key: "overrideGate",
        value: function overrideGate(name, value) {
          this._overrides.gates[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "gates"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeGateOverride",
        value: function removeGateOverride(name) {
          delete this._overrides.gates[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "gates"));
          this.saveOverrides();
        }
      }, {
        key: "getGateOverride",
        value: function getGateOverride(current, _user) {
          var _this$_overrides$gate;
          var overridden = (_this$_overrides$gate = this._overrides.gates[current.name]) !== null && _this$_overrides$gate !== void 0 ? _this$_overrides$gate : this._djb2Map.get(djb2MapKey(current.name, "gates"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            value: overridden,
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }, {
        key: "overrideDynamicConfig",
        value: function overrideDynamicConfig(name, value) {
          this._overrides.configs[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeDynamicConfigOverride",
        value: function removeDynamicConfigOverride(name) {
          delete this._overrides.configs[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
          this.saveOverrides();
        }
      }, {
        key: "getDynamicConfigOverride",
        value: function getDynamicConfigOverride(current, _user) {
          return this._getConfigOverride(current, this._overrides.configs);
        }
      }, {
        key: "overrideExperiment",
        value: function overrideExperiment(name, value) {
          this._overrides.configs[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeExperimentOverride",
        value: function removeExperimentOverride(name) {
          delete this._overrides.configs[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
          this.saveOverrides();
        }
      }, {
        key: "getExperimentOverride",
        value: function getExperimentOverride(current, _user) {
          return this._getConfigOverride(current, this._overrides.configs);
        }
      }, {
        key: "overrideLayer",
        value: function overrideLayer(name, value) {
          this._overrides.layers[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "layers"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeLayerOverride",
        value: function removeLayerOverride(name) {
          delete this._overrides.layers[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "layers"));
          this.saveOverrides();
        }
      }, {
        key: "removeAllOverrides",
        value: function removeAllOverrides() {
          this._overrides = makeEmptyStore();
          try {
            window.localStorage.removeItem(this._localStorageKey);
          } catch (_unused4) {
          }
        }
      }, {
        key: "getLayerOverride",
        value: function getLayerOverride(current, _user) {
          var _this$_overrides$laye;
          var overridden = (_this$_overrides$laye = this._overrides.layers[current.name]) !== null && _this$_overrides$laye !== void 0 ? _this$_overrides$laye : this._djb2Map.get(djb2MapKey(current.name, "layers"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            __value: overridden,
            get: (0, import_client_core._makeTypedGet)(current.name, overridden),
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }, {
        key: "_getConfigOverride",
        value: function _getConfigOverride(current, lookup) {
          var _lookup$current$name;
          var overridden = (_lookup$current$name = lookup[current.name]) !== null && _lookup$current$name !== void 0 ? _lookup$current$name : this._djb2Map.get(djb2MapKey(current.name, "configs"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            value: overridden,
            get: (0, import_client_core._makeTypedGet)(current.name, overridden),
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js
function ownKeys6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_regenerator3, import_js_client3, _excluded2, DEFAULT_CLIENT_KEY, DEFAULT_EVENT_LOGGING_API, Client;
var init_Client = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js"() {
    init_objectWithoutProperties();
    init_slicedToArray();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_regenerator3 = __toESM(require_regenerator());
    import_js_client3 = __toESM(require_src2());
    init_subscriptions();
    init_DynamicConfig();
    init_Layer();
    init_types2();
    init_fetcher();
    init_NoFetchDataAdapter();
    init_PersistentOverrideAdapter();
    init_types3();
    init_utils();
    init_version();
    _excluded2 = ["sdkKey", "environment", "updateUserCompletionCallback", "perimeter"];
    DEFAULT_CLIENT_KEY = "client-default-key";
    DEFAULT_EVENT_LOGGING_API = "https://xp.atlassian.com/v1/rgstr";
    Client = function() {
      function Client2() {
        var _this = this;
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$localStorageKey = _ref.localStorageKey, localStorageKey = _ref$localStorageKey === void 0 ? LOCAL_STORAGE_KEY : _ref$localStorageKey, overrideAdapter = _ref.overrideAdapter;
        _classCallCheck(this, Client2);
        _defineProperty(this, "initPromise", null);
        _defineProperty(this, "initCompleted", false);
        _defineProperty(this, "initWithDefaults", false);
        _defineProperty(this, "hasCheckGateErrorOccurred", false);
        _defineProperty(this, "hasGetExperimentErrorOccurred", false);
        _defineProperty(this, "hasGetExperimentValueErrorOccurred", false);
        _defineProperty(this, "hasGetLayerErrorOccurred", false);
        _defineProperty(this, "hasGetLayerValueErrorOccurred", false);
        _defineProperty(this, "subscriptions", new Subscriptions());
        _defineProperty(this, "dataAdapter", new NoFetchDataAdapter());
        _defineProperty(this, "statsigValuesUpdated", function() {
          if (_this.user) {
            _this.statsigClient.updateUserSync(_this.user, {
              disableBackgroundCacheRefresh: true
            });
          }
          _this.subscriptions.anyUpdated();
        });
        this.overrideAdapter = overrideAdapter || new PersistentOverrideAdapter(localStorageKey);
      }
      return _createClass(Client2, [{
        key: "initialize",
        value: function() {
          var _initialize = _asyncToGenerator(import_regenerator3.default.mark(function _callee(clientOptions, identifiers, customAttributes) {
            var _this2 = this;
            var clientOptionsWithDefaults, startTime;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                  if (!this.initPromise) {
                    _context.next = 4;
                    break;
                  }
                  if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                    console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                  }
                  return _context.abrupt("return", this.initPromise);
                case 4:
                  startTime = performance.now();
                  this.initOptions = clientOptionsWithDefaults;
                  this.initPromise = this.init(clientOptionsWithDefaults, identifiers, customAttributes).then(function() {
                    _this2.initCompleted = true;
                    _this2.initWithDefaults = true;
                  }).finally(function() {
                    var endTime = performance.now();
                    var totalTime = endTime - startTime;
                    _this2.fireClientEvent(startTime, totalTime, "initialize", _this2.initCompleted, clientOptionsWithDefaults.apiKey);
                  });
                  return _context.abrupt("return", this.initPromise);
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function initialize(_x, _x2, _x3) {
            return _initialize.apply(this, arguments);
          }
          return initialize;
        }()
      }, {
        key: "initializeWithProvider",
        value: function() {
          var _initializeWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee2(clientOptions, provider, identifiers, customAttributes) {
            var _this3 = this;
            var clientOptionsWithDefaults, startTime;
            return import_regenerator3.default.wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                  if (!this.initPromise) {
                    _context2.next = 4;
                    break;
                  }
                  if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                    console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                  }
                  return _context2.abrupt("return", this.initPromise);
                case 4:
                  startTime = performance.now();
                  this.initOptions = clientOptionsWithDefaults;
                  this.provider = provider;
                  this.provider.setClientVersion(CLIENT_VERSION);
                  if (this.provider.setApplyUpdateCallback) {
                    this.provider.setApplyUpdateCallback(this.applyUpdateCallback.bind(this));
                  }
                  this.initPromise = this.initWithProvider(clientOptionsWithDefaults, provider, identifiers, customAttributes).then(function() {
                    _this3.initCompleted = true;
                    _this3.initWithDefaults = true;
                  }).finally(function() {
                    var endTime = performance.now();
                    var totalTime = endTime - startTime;
                    _this3.fireClientEvent(startTime, totalTime, "initializeWithProvider", _this3.initCompleted, provider.getApiKey ? provider.getApiKey() : void 0);
                  });
                  return _context2.abrupt("return", this.initPromise);
                case 11:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function initializeWithProvider(_x4, _x5, _x6, _x7) {
            return _initializeWithProvider.apply(this, arguments);
          }
          return initializeWithProvider;
        }()
      }, {
        key: "applyUpdateCallback",
        value: function applyUpdateCallback(experimentsResult) {
          try {
            if (this.initCompleted || this.initWithDefaults) {
              this.assertInitialized(this.statsigClient);
              this.dataAdapter.setBootstrapData(experimentsResult.experimentValues);
              this.dataAdapter.setData(JSON.stringify(experimentsResult.experimentValues));
              this.statsigValuesUpdated();
            }
          } catch (error) {
            console.warn("Error when attempting to apply update", error);
          }
        }
      }, {
        key: "fireClientEvent",
        value: function fireClientEvent(startTime, totalTime, action, success) {
          var _analyticsWebClient, _this4 = this;
          var apiKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
          (_analyticsWebClient = this.initOptions.analyticsWebClient) === null || _analyticsWebClient === void 0 || _analyticsWebClient.then(function(analyticsWebClient) {
            var attributes = _objectSpread6({
              targetApp: _this4.initOptions.targetApp,
              clientVersion: CLIENT_VERSION,
              success,
              startTime,
              totalTime
            }, apiKey && {
              apiKey
            });
            analyticsWebClient.sendOperationalEvent({
              action,
              actionSubject: "featureGatesClient",
              attributes,
              tags: ["measurement"],
              source: "@atlaskit/feature-gate-js-client"
            });
          }).catch(function(err) {
            if (_this4.initOptions.environment !== FeatureGateEnvironment.Production) {
              console.error("Analytics web client promise did not resolve", err);
            }
          });
        }
      }, {
        key: "initializeFromValues",
        value: function() {
          var _initializeFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee3(clientOptions, identifiers, customAttributes) {
            var _this5 = this;
            var initializeValues, clientOptionsWithDefaults, startTime, _args3 = arguments;
            return import_regenerator3.default.wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  initializeValues = _args3.length > 3 && _args3[3] !== void 0 ? _args3[3] : {};
                  clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                  if (!this.initPromise) {
                    _context3.next = 5;
                    break;
                  }
                  if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                    console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                  }
                  return _context3.abrupt("return", this.initPromise);
                case 5:
                  if (!Object.prototype.hasOwnProperty.call(initializeValues, "has_updates")) {
                    initializeValues["has_updates"] = true;
                  }
                  startTime = performance.now();
                  this.initOptions = clientOptionsWithDefaults;
                  this.initPromise = this.initFromValues(clientOptionsWithDefaults, identifiers, customAttributes, initializeValues).then(function() {
                    _this5.initCompleted = true;
                    _this5.initWithDefaults = true;
                  }).finally(function() {
                    var endTime = performance.now();
                    var totalTime = endTime - startTime;
                    _this5.fireClientEvent(startTime, totalTime, "initializeFromValues", _this5.initCompleted);
                  });
                  return _context3.abrupt("return", this.initPromise);
                case 10:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));
          function initializeFromValues(_x8, _x9, _x10) {
            return _initializeFromValues.apply(this, arguments);
          }
          return initializeFromValues;
        }()
      }, {
        key: "assertInitialized",
        value: function assertInitialized(statsigClient) {
          if (!statsigClient) {
            throw new Error("Client must be initialized before using this method");
          }
        }
        /**
         * This method updates the user using a network call to fetch the new set of values.
         * @param fetchOptions {FetcherOptions}
         * @param identifiers {Identifiers}
         * @param customAttributes {CustomAttributes}
         */
      }, {
        key: "updateUser",
        value: function() {
          var _updateUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee4(fetchOptions, identifiers, customAttributes) {
            var fetchOptionsWithDefaults, initializeValuesProducer;
            return import_regenerator3.default.wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  this.assertInitialized(this.statsigClient);
                  fetchOptionsWithDefaults = getOptionsWithDefaults(fetchOptions);
                  initializeValuesProducer = function initializeValuesProducer2() {
                    return Fetcher.fetchExperimentValues(fetchOptionsWithDefaults, identifiers, customAttributes).then(function(_ref2) {
                      var experimentValues = _ref2.experimentValues, customAttributes2 = _ref2.customAttributes;
                      return {
                        experimentValues,
                        customAttributesFromFetch: customAttributes2
                      };
                    });
                  };
                  _context4.next = 5;
                  return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                case 5:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function updateUser(_x11, _x12, _x13) {
            return _updateUser.apply(this, arguments);
          }
          return updateUser;
        }()
      }, {
        key: "updateUserWithProvider",
        value: function() {
          var _updateUserWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee5(identifiers, customAttributes) {
            var _this6 = this;
            return import_regenerator3.default.wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  this.assertInitialized(this.statsigClient);
                  if (this.provider) {
                    _context5.next = 3;
                    break;
                  }
                  throw new Error("Cannot update user using provider as the client was not initialised with a provider");
                case 3:
                  _context5.next = 5;
                  return this.provider.setProfile(this.initOptions, identifiers, customAttributes);
                case 5:
                  _context5.next = 7;
                  return this.updateUserUsingInitializeValuesProducer(function() {
                    return _this6.provider.getExperimentValues();
                  }, identifiers, customAttributes);
                case 7:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function updateUserWithProvider(_x14, _x15) {
            return _updateUserWithProvider.apply(this, arguments);
          }
          return updateUserWithProvider;
        }()
      }, {
        key: "updateUserWithValues",
        value: function() {
          var _updateUserWithValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee6(identifiers, customAttributes) {
            var initializeValues, initializeValuesProducer, _args6 = arguments;
            return import_regenerator3.default.wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  initializeValues = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : {};
                  this.assertInitialized(this.statsigClient);
                  initializeValuesProducer = function initializeValuesProducer2() {
                    return Promise.resolve({
                      experimentValues: initializeValues,
                      customAttributesFromFetch: customAttributes
                    });
                  };
                  _context6.next = 5;
                  return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                case 5:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function updateUserWithValues(_x16, _x17) {
            return _updateUserWithValues.apply(this, arguments);
          }
          return updateUserWithValues;
        }()
      }, {
        key: "initializeCalled",
        value: function initializeCalled() {
          return this.initPromise != null;
        }
      }, {
        key: "initializeCompleted",
        value: function initializeCompleted() {
          return this.initCompleted;
        }
        /**
         * Returns the value for a feature gate. Returns false if there are errors.
         * @param {string} gateName - The name of the feature gate.
         * @param {Object} options
         * @param {boolean} options.fireGateExposure
         *        Whether or not to fire the exposure event for the gate. Defaults to true.
         *        To log an exposure event manually at a later time, use {@link Client.manuallyLogGateExposure}
         *        (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         */
      }, {
        key: "checkGate",
        value: function checkGate(gateName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireGateExpo = options.fireGateExposure, fireGateExposure = _options$fireGateExpo === void 0 ? true : _options$fireGateExpo;
            return this.statsigClient.checkGate(gateName, {
              disableExposureLog: !fireGateExposure
            });
          } catch (error) {
            if (!this.hasCheckGateErrorOccurred) {
              console.warn({
                msg: "An error has occurred checking the feature gate. Only the first occurrence of this error is logged.",
                gateName,
                error
              });
              this.hasCheckGateErrorOccurred = true;
            }
            return false;
          }
        }
      }, {
        key: "isGateExist",
        value: function isGateExist(gateName) {
          try {
            this.assertInitialized(this.statsigClient);
            var gate = this.statsigClient.getFeatureGate(gateName, {
              disableExposureLog: true
            });
            return !gate.details.reason.includes("Unrecognized");
          } catch (error) {
            console.error("Error occurred when trying to check FeatureGate: ".concat(error));
            return true;
          }
        }
      }, {
        key: "isExperimentExist",
        value: function isExperimentExist(experimentName) {
          try {
            this.assertInitialized(this.statsigClient);
            var config = this.statsigClient.getExperiment(experimentName, {
              disableExposureLog: true
            });
            return !config.details.reason.includes("Unrecognized");
          } catch (error) {
            console.error("Error occurred when trying to check Experiment: ".concat(error));
            return true;
          }
        }
        /**
         * Manually log a gate exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated a gate earlier via {@link Client.checkGate} where
         * <code>options.fireGateExposure</code> is false.
         * @param gateName
         */
      }, {
        key: "manuallyLogGateExposure",
        value: function manuallyLogGateExposure(gateName) {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.checkGate(gateName);
        }
        /**
         * Returns the entire config for a given experiment.
         *
         * @param {string} experimentName - The name of the experiment
         * @param {Object} options
         * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
         * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * @returns The config for an experiment
         * @example
         * ```ts
         * const experimentConfig = client.getExperiment('example-experiment-name');
         * const backgroundColor: string = experimentConfig.get('backgroundColor', 'yellow');
         * ```
         */
      }, {
        key: "getExperiment",
        value: function getExperiment(experimentName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireExperime = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime === void 0 ? true : _options$fireExperime;
            return DynamicConfig.fromExperiment(this.statsigClient.getExperiment(experimentName, {
              disableExposureLog: !fireExperimentExposure
            }));
          } catch (error) {
            if (!this.hasGetExperimentErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the experiment. Only the first occurrence of this error is logged.",
                experimentName,
                error
              });
              this.hasGetExperimentErrorOccurred = true;
            }
            return new DynamicConfig(experimentName, {}, "", {
              time: Date.now(),
              reason: EvaluationReason.Error
            });
          }
        }
        /**
         * Returns the value of a given parameter in an experiment config.
         *
         * @template T
         * @param {string} experimentName - The name of the experiment
         * @param {string} parameterName - The name of the parameter to fetch from the experiment config
         * @param {T} defaultValue - The value to serve if the experiment or parameter do not exist, or
         * if the returned value does not match the expected type.
         * @param {Object} options
         * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
         * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
         * @param {function} options.typeGuard - A function that asserts that the return value has the
         * expected type. If this function returns false, then the default value will be returned
         * instead. This can be set to protect your code from unexpected values being set remotely. By
         * default, this will be done by asserting that the default value and value are the same primitive
         * type.
         * @returns The value of the parameter if the experiment and parameter both exist, otherwise the
         * default value.
         * @example
         ``` ts
         type ValidColor = 'blue' | 'red' | 'yellow';
         type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
        	 const isValidColor: ValidColorTypeCheck =
        		(value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
        	 const buttonColor: ValidColor = client.getExperimentValue(
        		'example-experiment-name',
        		'backgroundColor',
        		'yellow',
        		{
        				typeGuard: isValidColor
        		}
         );
         ```
        */
      }, {
        key: "getExperimentValue",
        value: function getExperimentValue(experimentName, parameterName, defaultValue) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var experiment = this.getExperiment(experimentName, options);
          try {
            var typeGuard = options.typeGuard;
            return experiment.get(parameterName, defaultValue, typeGuard);
          } catch (error) {
            if (!this.hasGetExperimentValueErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the experiment value. Only the first occurrence of this error is logged.",
                experimentName,
                defaultValue,
                options,
                error
              });
              this.hasGetExperimentValueErrorOccurred = true;
            }
            return defaultValue;
          }
        }
        /**
         * Manually log an experiment exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated an experiment earlier via {@link Client.getExperimentValue} or
         * {@link Client.getExperiment} where <code>options.fireExperimentExposure</code> is false.
         * @param experimentName
         */
      }, {
        key: "manuallyLogExperimentExposure",
        value: function manuallyLogExperimentExposure(experimentName) {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.getExperiment(experimentName);
        }
        /**
         * Manually log a layer exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated a layer earlier via {@link Client.getLayerValue} where <code>options.fireExperimentExposure</code> is false.
         * @param layerName
         * @param parameterName
         */
      }, {
        key: "manuallyLogLayerExposure",
        value: function manuallyLogLayerExposure(layerName, parameterName) {
          var _this$statsigClient$g;
          this.assertInitialized(this.statsigClient);
          (_this$statsigClient$g = this.statsigClient.getLayer(layerName)) === null || _this$statsigClient$g === void 0 || _this$statsigClient$g.get(parameterName);
        }
      }, {
        key: "shutdownStatsig",
        value: function shutdownStatsig() {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.shutdown();
        }
        /**
         * Adds a new override for the given gate.
         *
         * This method is additive, meaning you can call it multiple times with different gate names to
         * build your full set of overrides.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearGateOverride} after your tests are completed to remove this
         * localStorage entry.
         *
         * @param {string} gateName
         * @param {boolean} value
         */
      }, {
        key: "overrideGate",
        value: function overrideGate(gateName, value) {
          this.overrideAdapter.overrideGate(gateName, value);
          if (this.user) {
            var _this$statsigClient;
            (_this$statsigClient = this.statsigClient) === null || _this$statsigClient === void 0 || _this$statsigClient.updateUserSync(this.user, {
              disableBackgroundCacheRefresh: true
            });
          }
          this.statsigValuesUpdated();
        }
        /**
         * Removes any overrides that have been set for the given gate.
         */
      }, {
        key: "clearGateOverride",
        value: function clearGateOverride(gateName) {
          this.overrideAdapter.removeGateOverride(gateName);
          this.statsigValuesUpdated();
        }
        /**
         * Adds a new override for the given config (or experiment).
         *
         * This method is additive, meaning you can call it multiple times with different experiment
         * names to build your full set of overrides.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearConfigOverride} after your tests are completed to remove this
         * localStorage entry.
         *
         * @param {string} experimentName
         * @param {object} values
         */
      }, {
        key: "overrideConfig",
        value: function overrideConfig(experimentName, values) {
          this.overrideAdapter.overrideDynamicConfig(experimentName, values);
          this.statsigValuesUpdated();
        }
        /**
         * Removes any overrides that have been set for the given experiment.
         * @param {string} experimentName
         */
      }, {
        key: "clearConfigOverride",
        value: function clearConfigOverride(experimentName) {
          this.overrideAdapter.removeDynamicConfigOverride(experimentName);
          this.statsigValuesUpdated();
        }
        /**
         * Set overrides for gates, experiments and layers in batch.
         *
         * Note that these overrides are **not** additive and will completely replace any that have been
         * added via prior calls to {@link Client.overrideConfig} or
         * {@link Client.overrideGate}.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearAllOverrides} after your tests are completed to remove this
         * localStorage entry.
         */
      }, {
        key: "setOverrides",
        value: function setOverrides(overrides) {
          this.overrideAdapter.setOverrides(overrides);
          this.statsigValuesUpdated();
        }
        /**
         * @returns The current overrides for gates, configs (including experiments) and layers.
         */
      }, {
        key: "getOverrides",
        value: function getOverrides() {
          return this.overrideAdapter.getOverrides();
        }
        /**
         * Clears overrides for all gates, configs (including experiments) and layers.
         */
      }, {
        key: "clearAllOverrides",
        value: function clearAllOverrides() {
          this.overrideAdapter.removeAllOverrides();
          this.statsigValuesUpdated();
        }
        /**
         * Returns whether the given identifiers and customAttributes align with the current
         * set that is being used by the client.
         *
         * If this method returns false, then the {@link Client.updateUser},
         * {@link Client.updateUserWithValues} or {@link Client.updateUserWithProvider}
         * methods can be used to re-align these values.
         *
         * @param identifiers
         * @param customAttributes
         * @returns a flag indicating whether the clients current configuration aligns with the given values
         */
      }, {
        key: "isCurrentUser",
        value: function isCurrentUser(identifiers, customAttributes) {
          return shallowEquals(this.currentIdentifiers, identifiers) && shallowEquals(this.currentAttributes, customAttributes);
        }
        /**
         * Subscribe to updates where the given callback will be called with the current checkGate value
         * @param gateName
         * @param callback
         * @param options
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onGateUpdated",
        value: function onGateUpdated(gateName, callback) {
          var _this7 = this;
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var wrapCallback = function wrapCallback2(value) {
            var _options$fireGateExpo2 = options.fireGateExposure, fireGateExposure = _options$fireGateExpo2 === void 0 ? true : _options$fireGateExpo2;
            if (fireGateExposure) {
              _this7.manuallyLogGateExposure(gateName);
            }
            try {
              callback(value);
            } catch (error) {
              console.warn("Error calling callback for gate ".concat(gateName, " with value ").concat(value), error);
            }
          };
          return this.subscriptions.onGateUpdated(gateName, wrapCallback, this.checkGate.bind(this), options);
        }
        /**
         * Subscribe to updates where the given callback will be called with the current experiment value
         * @param experimentName
         * @param parameterName
         * @param defaultValue
         * @param callback
         * @param options
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onExperimentValueUpdated",
        value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback) {
          var _this8 = this;
          var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          var wrapCallback = function wrapCallback2(value) {
            var _options$fireExperime2 = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime2 === void 0 ? true : _options$fireExperime2;
            if (fireExperimentExposure) {
              _this8.manuallyLogExperimentExposure(experimentName);
            }
            try {
              callback(value);
            } catch (error) {
              console.warn("Error calling callback for experiment ".concat(experimentName, " with value ").concat(value), error);
            }
          };
          return this.subscriptions.onExperimentValueUpdated(experimentName, parameterName, defaultValue, wrapCallback, this.getExperimentValue.bind(this), options);
        }
        /**
         * Subscribe so on any update the callback will be called.
         * NOTE: The callback will be called whenever the values are updated even if the values have not
         * changed.
         * @param callback
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onAnyUpdated",
        value: function onAnyUpdated(callback) {
          return this.subscriptions.onAnyUpdated(callback);
        }
        /**
         * This method initializes the client using a network call to fetch the bootstrap values for the
         * given user.
         *
         * @param clientOptions
         * @param identifiers
         * @param customAttributes
         * @private
         */
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator3.default.mark(function _callee7(clientOptions, identifiers, customAttributes) {
            var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all, _yield$Promise$all2, experimentValuesResult;
            return import_regenerator3.default.wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  fromValuesClientOptions = _objectSpread6({}, clientOptions);
                  _context7.prev = 1;
                  clientSdkKeyPromise = Fetcher.fetchClientSdk(clientOptions).then(function(value) {
                    return fromValuesClientOptions.sdkKey = value.clientSdkKey;
                  });
                  experimentValuesPromise = Fetcher.fetchExperimentValues(clientOptions, identifiers, customAttributes);
                  _context7.next = 6;
                  return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                case 6:
                  _yield$Promise$all = _context7.sent;
                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                  experimentValuesResult = _yield$Promise$all2[1];
                  experimentValues = experimentValuesResult.experimentValues;
                  customAttributesFromResult = experimentValuesResult.customAttributes;
                  _context7.next = 20;
                  break;
                case 13:
                  _context7.prev = 13;
                  _context7.t0 = _context7["catch"](1);
                  if (_context7.t0 instanceof Error) {
                    console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context7.t0 === null || _context7.t0 === void 0 ? void 0 : _context7.t0.message));
                  }
                  console.warn("Initialising Statsig client without values");
                  _context7.next = 19;
                  return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                case 19:
                  throw _context7.t0;
                case 20:
                  return _context7.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                case 21:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this, [[1, 13]]);
          }));
          function init(_x18, _x19, _x20) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "initWithProvider",
        value: function() {
          var _initWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee8(baseClientOptions, provider, identifiers, customAttributes) {
            var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all3, _yield$Promise$all4, experimentValuesResult;
            return import_regenerator3.default.wrap(function _callee8$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  fromValuesClientOptions = _objectSpread6(_objectSpread6({}, baseClientOptions), {}, {
                    disableCurrentPageLogging: true
                  });
                  _context8.prev = 1;
                  _context8.next = 4;
                  return provider.setProfile(baseClientOptions, identifiers, customAttributes);
                case 4:
                  clientSdkKeyPromise = provider.getClientSdkKey().then(function(value) {
                    return fromValuesClientOptions.sdkKey = value;
                  });
                  experimentValuesPromise = provider.getExperimentValues();
                  _context8.next = 8;
                  return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                case 8:
                  _yield$Promise$all3 = _context8.sent;
                  _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
                  experimentValuesResult = _yield$Promise$all4[1];
                  experimentValues = experimentValuesResult.experimentValues;
                  customAttributesFromResult = experimentValuesResult.customAttributesFromFetch;
                  _context8.next = 22;
                  break;
                case 15:
                  _context8.prev = 15;
                  _context8.t0 = _context8["catch"](1);
                  if (_context8.t0 instanceof Error) {
                    console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message));
                  }
                  console.warn("Initialising Statsig client without values");
                  _context8.next = 21;
                  return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                case 21:
                  throw _context8.t0;
                case 22:
                  return _context8.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                case 23:
                case "end":
                  return _context8.stop();
              }
            }, _callee8, this, [[1, 15]]);
          }));
          function initWithProvider(_x21, _x22, _x23, _x24) {
            return _initWithProvider.apply(this, arguments);
          }
          return initWithProvider;
        }()
        /**
         * This method initializes the client using a set of boostrap values obtained from one of the
         * server-side SDKs.
         *
         * @param clientOptions
         * @param identifiers
         * @param customAttributes
         * @param initializeValues
         * @private
         */
      }, {
        key: "initFromValues",
        value: function() {
          var _initFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee9(clientOptions, identifiers, customAttributes) {
            var _newClientOptions$net;
            var initializeValues, newClientOptions, sdkKey, environment, _updateUserCompletionCallback, _perimeter, restClientOptions, statsigOptions, _args9 = arguments;
            return import_regenerator3.default.wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  initializeValues = _args9.length > 3 && _args9[3] !== void 0 ? _args9[3] : {};
                  this.overrideAdapter.initFromStoredOverrides();
                  this.currentIdentifiers = identifiers;
                  this.currentAttributes = customAttributes;
                  newClientOptions = migrateInitializationOptions(clientOptions);
                  if (!newClientOptions.sdkKey) {
                    newClientOptions.sdkKey = DEFAULT_CLIENT_KEY;
                  }
                  if (!((_newClientOptions$net = newClientOptions.networkConfig) !== null && _newClientOptions$net !== void 0 && _newClientOptions$net.logEventUrl)) {
                    newClientOptions.networkConfig = _objectSpread6(_objectSpread6({}, newClientOptions.networkConfig), {}, {
                      logEventUrl: DEFAULT_EVENT_LOGGING_API
                    });
                  }
                  if (newClientOptions.perimeter === PerimeterType.FEDRAMP_MODERATE) {
                    newClientOptions.disableLogging = true;
                  }
                  sdkKey = newClientOptions.sdkKey, environment = newClientOptions.environment, _updateUserCompletionCallback = newClientOptions.updateUserCompletionCallback, _perimeter = newClientOptions.perimeter, restClientOptions = _objectWithoutProperties(newClientOptions, _excluded2);
                  this.sdkKey = sdkKey;
                  this.user = toStatsigUser(identifiers, customAttributes, this.sdkKey);
                  statsigOptions = _objectSpread6(_objectSpread6({}, restClientOptions), {}, {
                    environment: {
                      tier: environment
                    },
                    includeCurrentPageUrlWithEvents: false,
                    dataAdapter: this.dataAdapter,
                    overrideAdapter: this.overrideAdapter
                  });
                  _context9.prev = 12;
                  this.statsigClient = new import_js_client3.StatsigClient(sdkKey, this.user, statsigOptions);
                  this.dataAdapter.setBootstrapData(initializeValues);
                  _context9.next = 17;
                  return this.statsigClient.initializeAsync();
                case 17:
                  _context9.next = 29;
                  break;
                case 19:
                  _context9.prev = 19;
                  _context9.t0 = _context9["catch"](12);
                  if (_context9.t0 instanceof Error) {
                    console.error("Error occurred when trying to initialise the Statsig client, error: ".concat(_context9.t0 === null || _context9.t0 === void 0 ? void 0 : _context9.t0.message));
                  }
                  console.warn("Initialising Statsig client with default sdk key and without values");
                  this.statsigClient = new import_js_client3.StatsigClient(DEFAULT_CLIENT_KEY, this.user, statsigOptions);
                  this.dataAdapter.setBootstrapData();
                  _context9.next = 27;
                  return this.statsigClient.initializeAsync();
                case 27:
                  this.initWithDefaults = true;
                  throw _context9.t0;
                case 29:
                case "end":
                  return _context9.stop();
              }
            }, _callee9, this, [[12, 19]]);
          }));
          function initFromValues(_x25, _x26, _x27) {
            return _initFromValues.apply(this, arguments);
          }
          return initFromValues;
        }()
      }, {
        key: "updateUserUsingInitializeValuesProducer",
        value: function() {
          var _updateUserUsingInitializeValuesProducer = _asyncToGenerator(import_regenerator3.default.mark(function _callee11(getInitializeValues, identifiers, customAttributes) {
            var _this9 = this;
            var originalInitPromise, initializeValuesPromise, updateUserPromise;
            return import_regenerator3.default.wrap(function _callee11$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  this.assertInitialized(this.statsigClient);
                  if (this.initPromise) {
                    _context11.next = 3;
                    break;
                  }
                  throw new Error("The client must be initialized before you can update the user.");
                case 3:
                  if (!this.isCurrentUser(identifiers, customAttributes)) {
                    _context11.next = 5;
                    break;
                  }
                  return _context11.abrupt("return", this.initPromise);
                case 5:
                  originalInitPromise = this.initPromise;
                  _context11.prev = 6;
                  _context11.next = 9;
                  return this.initPromise;
                case 9:
                  _context11.next = 13;
                  break;
                case 11:
                  _context11.prev = 11;
                  _context11.t0 = _context11["catch"](6);
                case 13:
                  initializeValuesPromise = getInitializeValues();
                  updateUserPromise = this.updateStatsigClientUser(initializeValuesPromise, identifiers, customAttributes);
                  this.initPromise = updateUserPromise.catch(_asyncToGenerator(import_regenerator3.default.mark(function _callee10() {
                    return import_regenerator3.default.wrap(function _callee10$(_context10) {
                      while (1) switch (_context10.prev = _context10.next) {
                        case 0:
                          _this9.initPromise = originalInitPromise;
                          if (!_this9.provider) {
                            _context10.next = 4;
                            break;
                          }
                          _context10.next = 4;
                          return _this9.provider.setProfile(_this9.initOptions, _this9.currentIdentifiers, _this9.currentAttributes);
                        case 4:
                        case "end":
                          return _context10.stop();
                      }
                    }, _callee10);
                  })));
                  return _context11.abrupt("return", updateUserPromise);
                case 17:
                case "end":
                  return _context11.stop();
              }
            }, _callee11, this, [[6, 11]]);
          }));
          function updateUserUsingInitializeValuesProducer(_x28, _x29, _x30) {
            return _updateUserUsingInitializeValuesProducer.apply(this, arguments);
          }
          return updateUserUsingInitializeValuesProducer;
        }()
      }, {
        key: "updateStatsigClientUser",
        value: function() {
          var _updateStatsigClientUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee12(initializeValuesPromise, identifiers, customAttributes) {
            var _this$initOptions, _this$initOptions$upd;
            var initializeValues, user, _updateUserCompletion, _ref4, errMsg, success, errorMessage;
            return import_regenerator3.default.wrap(function _callee12$(_context12) {
              while (1) switch (_context12.prev = _context12.next) {
                case 0:
                  this.assertInitialized(this.statsigClient);
                  _context12.prev = 1;
                  _context12.next = 4;
                  return initializeValuesPromise;
                case 4:
                  initializeValues = _context12.sent;
                  user = toStatsigUser(identifiers, initializeValues.customAttributesFromFetch, this.sdkKey);
                  _context12.next = 13;
                  break;
                case 8:
                  _context12.prev = 8;
                  _context12.t0 = _context12["catch"](1);
                  errMsg = _context12.t0 instanceof Error ? _context12.t0.message : JSON.stringify(_context12.t0);
                  (_updateUserCompletion = (_ref4 = this.initOptions).updateUserCompletionCallback) === null || _updateUserCompletion === void 0 || _updateUserCompletion.call(_ref4, false, errMsg);
                  throw _context12.t0;
                case 13:
                  success = true;
                  errorMessage = null;
                  _context12.prev = 15;
                  this.dataAdapter.setBootstrapData(initializeValues.experimentValues);
                  this.user = user;
                  _context12.next = 20;
                  return this.statsigClient.updateUserAsync(this.user);
                case 20:
                  _context12.next = 26;
                  break;
                case 22:
                  _context12.prev = 22;
                  _context12.t1 = _context12["catch"](15);
                  success = false;
                  errorMessage = String(_context12.t1);
                case 26:
                  (_this$initOptions = this.initOptions) === null || _this$initOptions === void 0 || (_this$initOptions$upd = _this$initOptions.updateUserCompletionCallback) === null || _this$initOptions$upd === void 0 || _this$initOptions$upd.call(_this$initOptions, success, errorMessage);
                  if (!success) {
                    _context12.next = 33;
                    break;
                  }
                  this.currentIdentifiers = identifiers;
                  this.currentAttributes = customAttributes;
                  this.subscriptions.anyUpdated();
                  _context12.next = 34;
                  break;
                case 33:
                  throw new Error("Failed to update user. An unexpected error occured.");
                case 34:
                case "end":
                  return _context12.stop();
              }
            }, _callee12, this, [[1, 8], [15, 22]]);
          }));
          function updateStatsigClientUser(_x31, _x32, _x33) {
            return _updateStatsigClientUser.apply(this, arguments);
          }
          return updateStatsigClientUser;
        }()
      }, {
        key: "getPackageVersion",
        value: (
          /**
           * @returns string version of the current package in semver style.
           */
          function getPackageVersion() {
            return CLIENT_VERSION;
          }
        )
        /**
         * Returns a specified layer otherwise returns an empty layer as a default value if the layer doesn't exist.
         *
         * @param {string} layerName - The name of the layer
         * @param {Object} options
         * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
         * layer. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * @returns A layer
         * @example
         * ```ts
         * const layer = client.getLayer('example-layer-name');
         * const exampletitle: string = layer.get("title", "Welcome to Statsig!");
         * ```
         */
      }, {
        key: "getLayer",
        value: function getLayer(layerName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireLayerExp = options.fireLayerExposure, fireLayerExposure = _options$fireLayerExp === void 0 ? true : _options$fireLayerExp;
            return Layer.fromLayer(this.statsigClient.getLayer(layerName, {
              disableExposureLog: !fireLayerExposure
            }));
          } catch (error) {
            if (!this.hasGetLayerErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the layer. Only the first occurrence of this error is logged.",
                layerName,
                error
              });
              this.hasGetLayerErrorOccurred = true;
            }
            return Layer.fromLayer((0, import_js_client3._makeLayer)(layerName, {
              reason: "Error"
            }, null));
          }
        }
        /**
         * Returns the value of a given parameter in a layer config.
         *
         * @template T
         * @param {string} layerName - The name of the layer
         * @param {string} parameterName - The name of the parameter to fetch from the layer config
         * @param {T} defaultValue - The value to serve if the layer or parameter do not exist, or if the
         * returned value does not match the expected type.
         * @param {Object} options
         * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
         * layer. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
         * @param {function} options.typeGuard - A function that asserts that the return value has the expected type. If this function returns false, then the default value will be returned instead. This can be set to protect your code from unexpected values being set remotely. By default, this will be done by asserting that the default value and value are the same primitive type.
         * @returns The value of the parameter if the layer and parameter both exist, otherwise the default value.
         * @example
         * ``` ts
         * type ValidColor = 'blue' | 'red' | 'yellow';
         * type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
         *
         * const isValidColor: ValidColorTypeCheck =
         *    (value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
         *
         * const buttonColor: ValidColor = client.getLayerValue(
         *    'example-layer-name',
         *    'backgroundColor',
         *    'yellow',
         *    {
         *        typeGuard: isValidColor
         *    }
         * );
         * ```
         */
      }, {
        key: "getLayerValue",
        value: function getLayerValue(layerName, parameterName, defaultValue) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var layer = this.getLayer(layerName, options);
          try {
            var typeGuard = options.typeGuard;
            return layer.get(parameterName, defaultValue, typeGuard);
          } catch (error) {
            if (!this.hasGetLayerValueErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the layer value. Only the first occurrence of this error is logged.",
                layerName,
                defaultValue,
                options,
                error
              });
              this.hasGetLayerValueErrorOccurred = true;
            }
            return defaultValue;
          }
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/FeatureGates.js
var _FeatureGates, FeatureGates, boundFGJS, _boundFGJS, _boundFGJS$getPackage, boundVersion, message, FeatureGates_default;
var init_FeatureGates = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/FeatureGates.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_Client();
    init_version();
    init_types2();
    init_DynamicConfig();
    init_types3();
    init_version();
    FeatureGates = function() {
      function FeatureGates2() {
        _classCallCheck(this, FeatureGates2);
      }
      return _createClass(FeatureGates2, null, [{
        key: "isGateExists",
        value: function isGateExists(gateName) {
          return this.client.isGateExist(gateName);
        }
      }, {
        key: "isExperimentExists",
        value: function isExperimentExists(experimentName) {
          return this.client.isExperimentExist(experimentName);
        }
      }]);
    }();
    _FeatureGates = FeatureGates;
    _defineProperty(FeatureGates, "client", new Client());
    _defineProperty(FeatureGates, "hasCheckGateErrorOccurred", false);
    _defineProperty(FeatureGates, "hasGetExperimentValueErrorOccurred", false);
    _defineProperty(FeatureGates, "checkGate", function(gateName, options) {
      try {
        if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getFeatureFlagOverride === "function") {
          var overrideValue = window.__CRITERION__.getFeatureFlagOverride(gateName);
          if (overrideValue !== void 0) {
            return overrideValue;
          }
        }
      } catch (error) {
        if (!_FeatureGates.hasCheckGateErrorOccurred) {
          console.warn({
            msg: "An error has occurred checking the feature gate from criterion override. Only the first occurrence of this error is logged.",
            gateName,
            error
          });
          _FeatureGates.hasCheckGateErrorOccurred = true;
        }
      }
      return _FeatureGates.client.checkGate(gateName, options);
    });
    _defineProperty(FeatureGates, "getExperimentValue", function(experimentName, parameterName, defaultValue, options) {
      try {
        if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getExperimentValueOverride === "function") {
          var overrideValue = window.__CRITERION__.getExperimentValueOverride(experimentName, parameterName);
          if (overrideValue !== void 0 && overrideValue !== null) {
            return overrideValue;
          }
        }
      } catch (error) {
        if (!_FeatureGates.hasGetExperimentValueErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the experiment value from criterion override. Only the first occurrence of this error is logged.",
            experimentName,
            defaultValue,
            options,
            error
          });
          _FeatureGates.hasGetExperimentValueErrorOccurred = true;
        }
        return defaultValue;
      }
      return _FeatureGates.client.getExperimentValue(experimentName, parameterName, defaultValue, options);
    });
    _defineProperty(FeatureGates, "initializeCalled", _FeatureGates.client.initializeCalled.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeCompleted", _FeatureGates.client.initializeCompleted.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initialize", _FeatureGates.client.initialize.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeWithProvider", _FeatureGates.client.initializeWithProvider.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeFromValues", _FeatureGates.client.initializeFromValues.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogGateExposure", _FeatureGates.client.manuallyLogGateExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getExperiment", _FeatureGates.client.getExperiment.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogExperimentExposure", _FeatureGates.client.manuallyLogExperimentExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogLayerExposure", _FeatureGates.client.manuallyLogLayerExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "shutdownStatsig", _FeatureGates.client.shutdownStatsig.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "overrideGate", _FeatureGates.client.overrideGate.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearGateOverride", _FeatureGates.client.clearGateOverride.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "overrideConfig", _FeatureGates.client.overrideConfig.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearConfigOverride", _FeatureGates.client.clearConfigOverride.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "setOverrides", _FeatureGates.client.setOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getOverrides", _FeatureGates.client.getOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearAllOverrides", _FeatureGates.client.clearAllOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "isCurrentUser", _FeatureGates.client.isCurrentUser.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onGateUpdated", _FeatureGates.client.onGateUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onExperimentValueUpdated", _FeatureGates.client.onExperimentValueUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onAnyUpdated", _FeatureGates.client.onAnyUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUser", _FeatureGates.client.updateUser.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUserWithProvider", _FeatureGates.client.updateUserWithProvider.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUserWithValues", _FeatureGates.client.updateUserWithValues.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getPackageVersion", _FeatureGates.client.getPackageVersion.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getLayer", _FeatureGates.client.getLayer.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getLayerValue", _FeatureGates.client.getLayerValue.bind(_FeatureGates.client));
    boundFGJS = FeatureGates;
    if (typeof window !== "undefined") {
      if (window.__FEATUREGATES_JS__ === void 0) {
        window.__FEATUREGATES_JS__ = FeatureGates;
      } else {
        boundFGJS = window.__FEATUREGATES_JS__;
        boundVersion = ((_boundFGJS = boundFGJS) === null || _boundFGJS === void 0 || (_boundFGJS$getPackage = _boundFGJS.getPackageVersion) === null || _boundFGJS$getPackage === void 0 ? void 0 : _boundFGJS$getPackage.call(_boundFGJS)) || "4.10.0 or earlier";
        if (boundVersion !== CLIENT_VERSION) {
          message = "Multiple versions of FeatureGateClients found on the current page.\n      The currently bound version is ".concat(boundVersion, " when module version ").concat(CLIENT_VERSION, " was loading.");
          console.warn(message);
        }
      }
    }
    FeatureGates_default = boundFGJS;
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/index.js"() {
    init_FeatureGates();
    init_DynamicConfig();
    init_Layer();
    init_types2();
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/debug.js
var _process, _process2, TESTS_MODE, DEBUG_MODE, debug;
var init_debug = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/debug.js"() {
    TESTS_MODE = (globalThis === null || globalThis === void 0 || (_process = globalThis.process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.JEST_WORKER_ID) !== void 0;
    DEBUG_MODE = !TESTS_MODE && (globalThis === null || globalThis === void 0 || (_process2 = globalThis.process) === null || _process2 === void 0 || (_process2 = _process2.env) === null || _process2 === void 0 ? void 0 : _process2.NODE_ENV) !== "production";
    debug = function debug2() {
      var _console;
      if (!DEBUG_MODE) {
        return;
      }
      (_console = console).debug.apply(_console, arguments);
    };
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/resolvers.js
function resolveBooleanFlag(flagKey) {
  if (ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE) {
    debug('[%s]: The feature flags were enabled while running tests. The flag "%s" will be always enabled.', pkgName, flagKey);
    return true;
  }
  try {
    var _globalVar$PFF_GLOBAL, _globalVar$PFF_GLOBAL2, _globalVar$PFF_GLOBAL3;
    if (((_globalVar$PFF_GLOBAL = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL === void 0 ? void 0 : _globalVar$PFF_GLOBAL.booleanResolver) === void 0 || ((_globalVar$PFF_GLOBAL2 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL2 === void 0 ? void 0 : _globalVar$PFF_GLOBAL2.booleanResolver) === null) {
      return FeatureGates_default.checkGate(flagKey);
    }
    var result = (_globalVar$PFF_GLOBAL3 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL3 === void 0 ? void 0 : _globalVar$PFF_GLOBAL3.booleanResolver(flagKey);
    if (typeof result !== "boolean") {
      console.warn("".concat(flagKey, " resolved to a non-boolean value, returning false for safety"));
      return false;
    }
    return result;
  } catch (e) {
    return false;
  }
}
var pkgName, PFF_GLOBAL_KEY, hasProcessEnv, ENV_ENABLE_PLATFORM_FF, ENV_STORYBOOK_ENABLE_PLATFORM_FF, ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE, DEFAULT_PFF_GLOBAL, globalVar;
var init_resolvers = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/resolvers.js"() {
    init_esm2();
    init_debug();
    pkgName = "@atlaskit/platform-feature-flags";
    PFF_GLOBAL_KEY = "__PLATFORM_FEATURE_FLAGS__";
    hasProcessEnv = typeof process !== "undefined" && typeof process.env !== "undefined";
    ENV_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    ENV_STORYBOOK_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["STORYBOOK_ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE = ENV_ENABLE_PLATFORM_FF || ENV_STORYBOOK_ENABLE_PLATFORM_FF;
    DEFAULT_PFF_GLOBAL = {
      booleanResolver: void 0
    };
    globalVar = typeof window !== "undefined" ? window : globalThis;
    globalVar[PFF_GLOBAL_KEY] = globalVar[PFF_GLOBAL_KEY] || DEFAULT_PFF_GLOBAL;
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/index.js
function fg(name) {
  return resolveBooleanFlag(name);
}
var init_esm3 = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/index.js"() {
    init_resolvers();
  }
});

export {
  _typeof,
  init_typeof,
  _defineProperty,
  init_defineProperty,
  _classCallCheck,
  init_classCallCheck,
  _createClass,
  init_createClass,
  _arrayLikeToArray,
  init_arrayLikeToArray,
  _unsupportedIterableToArray,
  init_unsupportedIterableToArray,
  _possibleConstructorReturn,
  init_possibleConstructorReturn,
  _getPrototypeOf,
  init_getPrototypeOf,
  _get,
  init_get,
  _inherits,
  init_inherits,
  _objectWithoutProperties,
  init_objectWithoutProperties,
  _slicedToArray,
  init_slicedToArray,
  _asyncToGenerator,
  init_asyncToGenerator,
  require_regenerator,
  fg,
  init_esm3 as init_esm
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)
*/
//# sourceMappingURL=chunk-2WJRDDYS.js.map
